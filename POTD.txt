Old:
    Refer from DSA Love Babbar txt file:
    1331)
        int longestSubarray(vector<int> &arr, int k) {
            int mxLen=0, n = arr.size();
            for(int i=0; i<n; i++){
                int GreaterK, LessEqualK;
                GreaterK = LessEqualK = 0;
                for(int j=i; j<n; j++){
                    (arr[j] > k) ? GreaterK++ : LessEqualK++;
                    if(GreaterK > LessEqualK)
                        mxLen = max(mxLen, j-i+1);
                }
            }
            return mxLen;
        }

POTDs:
    1399) Make Matrix Beautiful:
        Problem Statement:
            A beautiful matrix is defined as a square matrix in which the sum of elements in every row and every column is equal. Given a square matrix mat[][], your task is to determine the minimum number of operations required to make the matrix beautiful.
            In one operation, you are allowed to increment the value of any single cell by 1.
            Examples:
            Input: mat[][] = [[1, 2], 
                            [3, 4]]
            Output: 4
            Explanation:
            Increment value of cell(0, 0) by 3, 
            Increment value of cell(0, 1) by 1. 
            Matrix after the operations: [[4, 3], 
                                        [3, 4]]
            Here, sum of each row and column is 7.
            Hence total 4 operation are required.
            Input: mat[][] = [[1, 2, 3],
                            [4, 2, 3],
                            [3, 2, 1]]
            Output: 6
            Explanation: 
            Increment value of cell(0, 0) by 1, 
            Increment value of cell(0, 1) by 2, 
            Increment value of cell(2, 1) by 1, 
            Increment value of cell(2, 2) by 2. 
            Matrix after the operations: [[2, 4, 3], 
                                        [4, 2, 3],
                                        [3, 3, 3]] 
            Here, sum of each row and column is 9.
            Hence total 6 operation are required.
            Constraints:
                1 ≤ mat.size() ≤ 900
                0 ≤ mat[i][j] ≤ 10^6
        // TC: O(n*m) & SC: O(1)
            int balanceSums(vector<vector<int>>& mat) {
                int n = mat.size();
                if(!n) return 0;
                int mxValue = 0, m = mat[0].size();
                for(int i=0; i<n; i++){
                    int cur=0;
                    for(int j=0; j<m; j++)  cur += mat[i][j];
                    mxValue = max(mxValue, cur);
                }
                
                for(int i=0; i<m; i++){
                    int cur=0;
                    for(int j=0; j<n; j++)  cur += mat[j][i];
                    mxValue = max(mxValue, cur);
                }
                int ans=0;
                for(vector<int> cur: mat)
                    ans += mxValue - accumulate(cur.begin(), cur.end(), 0);   
                return ans;
            }

    1400) ASCII Range Sum:
        Problem Statement:
            Given a string s consisting of lowercase English letters, for every character whose first and last occurrences are at different positions, calculate the sum of ASCII values of characters strictly between its first and last occurrence.
            Return all such non-zero sums (order does not matter).
            Examples:
            Input: s = "abacab"
            Output: [293, 294]
            Explanation: characters 'a' and 'b' appear more than once:
            'a' : between positions 1 and 5 → characters are b, a, c and ascii sum is 98 + 97 + 99 = 294.
            'b' : between positions 2 and 6 → characters are a, c, a and ascii sum is 97 + 99 + 97 = 293.
            Input: s = "acdac"
            Output: [197, 199]
            Explanation: characters 'a' and 'c' appear more than once:
            'a' : between positions 1 and 4 → characters are c, d and ascii sum is 99 + 100 = 199.
            'c' : between positions 2 and 5 → characters are d, a and ascii sum is 100 + 97 = 197.
            Constraints:
                1 ≤ s.size() ≤ 10^5
        // TC: O(n) & SC: O(n)
            vector<int> asciirange(string& s) {
                // <character, its indexes>
                vector<vector<int>> mapping (26);
                vector<int> vis(26, 0);
                
                int n = s.size();
                for(int i=0; i<n; i++)
                    mapping[s[i] - 'a'].push_back(i);
                vector<int> ans;
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    // Skip the iteration if,
                    // character is already visited
                    // or its start & end is same index or just difference is 1
                    if(vis[ch - 'a'] or start == end or start == end - 1) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    ans.push_back(sum);
                }
                /*
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    if(vis[ch - 'a'] or start == end) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    if(sum) ans.push_back(sum);
                }
                */
                return ans;
            }

    1401) Powerful Integer:
        Problem Statement:
            You are given a 2D integer array intervals[][] of length n, where each intervals[i] = [start, end] represents a closed interval (i.e., all integers from start to end, inclusive). You are also given an integer k. An integer is called Powerful if it appears in at least k intervals. Find the maximum Powerful Integer.
            Note: If no integer occurs at least k times return -1.
            Examples:
            Input : n = 3, intervals[][] = [[1, 3], [4, 6], [3, 4]], k = 2
            Output: 4
            Explanation: Integers 3 and 4 appear in 2 intervals. The maximum is 4.
            Input : n = 4, intervals[][] = [[1, 4], [12, 45], [3, 8], [10, 12]], k = 3
            Output: -1
            Explanation: No integer appears in at least 3 intervals.
            Input : n = 5, intervals[][] = [[16, 21], [5, 8], [12, 17], [17, 29], [9, 24]], k = 3
            Output: 21
            Explanation: Integers 16, 17, 18, 19, 20 and 21 appear in at least 3 intervals. The maximum is 21.
            Constraints:
                1 ≤ n ≤ 10^5
                1 ≤ intervals[i][0] ≤ intervals[i][1] ≤ 10^9
                1 ≤ k ≤ 10^5
        // Not Optimized: TC: O(n) & SC: O(U)
            where n = total interval length, U = number of unique integers between all [s, e] ranges.
            int powerfulInteger(vector<vector<int>>& intervals, int k) {
                map<int, int> Freq;
                int ans = -1;
                for(auto cur: intervals){
                    int s = cur[0], e = cur[1];
                    for(int i=s; i<=e; i++)
                        Freq[i]++;
                }
                for(auto i: Freq)
                    if(i.second >= k)
                        ans = i.first;          // no need to check is max or not, coz map store all things in sorted order
                return ans;
            }
        // Optimized: ❌Pending

    1402) Balancing Consonants and Vowels Ratio:
        Problem Statement:
            You are given an array of strings arr[], where each arr[i] consists of lowercase english alphabets. You need to find the number of balanced strings in arr[] which can be formed by concatinating one or more contiguous strings of arr[].
            A balanced string contains the equal number of vowels and consonants. 
            Examples:
            Input: arr[] = ["aeio", "aa", "bc", "ot", "cdbd"]
            Output: 4
            Explanation: arr[0..4], arr[1..2], arr[1..3], arr[3..3] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["ab", "be"]
            Output: 3
            Explanation: arr[0..0], arr[0..1], arr[1..1] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["tz", "gfg", "ae"]
            Output: 0
            Explanation: There is no such balanced substring present in arr[] with equal consonants and vowels.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                1 ≤ arr[i].size() ≤ 10^5
                Total number of lowercase english characters in arr[] is lesser than 10^5.
        // Not Optimized: TC: O(n * l + n²) & SC: O(n)
            bool isVowel(char ch){
                return ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u';
            }
            int countBalanced(vector<string>& arr) {
                int cnt=0;
                // <vowels, consonants>
                vector<pair<int, int>> Freq;
                for(string s: arr){
                    int vow, conso;
                    vow = conso = 0;
                    for(char ch: s)
                        isVowel(ch) ? vow++ : conso++;
                    Freq.push_back({vow, conso});
                }
                int n = arr.size();
                for(int i=0; i<n; i++){
                    int curVow, curConso;
                    curVow = curConso = 0;
                    for(int j=i; j<n; j++){
                        curVow += Freq[j].first;
                        curConso += Freq[j].second;
                        if(curVow == curConso) cnt++;
                    }
                }
                return cnt;
            }
        // Optimized: ❌Pending

    1403) 2D Difference Array:
        Problem Statement:
            You are given a 2D integer matrix mat[][] of size n × m and a list of q operations opr[][]. 
            Each operation is represented as an array [v, r1, c1, r2, c2], where:
                v is the value to be added
                (r1, c1) is the top-left cell of a submatrix
                (r2, c2) is the bottom-right cell of the submatrix (inclusive)
            For each of the q operations, add v to every element in the submatrix from (r1, c1) to (r2, c2). 
            Return the final matrix after applying all operations.
            Examples:
            Input: mat[][] = [[1, 2, 3],  opr[][] = [[2, 0, 0, 1, 1], [-1, 1, 0, 2, 2]]
                            [1, 1, 0],
                            [4,-2, 2]]
            Output: [[3, 4, 3],
                    [2, 2, -1],
                    [3, -3, 1]] 
            Explanation:
            Constraint:
                1 ≤ n×m, q ≤ 10^5
                0 ≤ r1 ≤ r2 ≤ n - 1
                0 ≤ c1 ≤ c2 ≤ m - 1
                -10^4 ≤ mat[i][j], v ≤ 10^4
        // Not Optimized: TC: O(n * R * C) & SC: O(1):
            vector<vector<int>> applyDiff2D(vector<vector<int>>& mat, vector<vector<int>>& opr) {
                for(auto q: opr){
                    for(int r=q[1]; r<=q[3]; r++){
                        for(int c=q[2]; c<=q[4]; c++){
                            mat[r][c] += q[0];
                        }
                    }
                }
                return mat;
            }
        // Optimized: ❌Pending

    1404) Maximum sum Rectangle:
        Problem Statement:
            Given a 2D matrix mat[][] with dimensions n×m. Find the maximum possible sum of any submatrix within the given matrix.
            Examples:
            Input: mat[][] = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]
            Output: 29
            Explanation: The matrix is as follows and the green rectangle denotes the maximum sum rectangle which is equal to 29.
            Input: mat[][] = [[-1, -2], [-3, -4]]
            Output: -1
            Explanation: Taking only the first cell is the optimal choice.
            Constraints:
                1 ≤ n, m ≤ 300
                -1000 ≤ mat[i][j] ≤ 1000
        // Not Optimized: TC: O(n³ * m²) & SC: O(1)
            int curSubMatrixSum(int sr, int sc, int er, int ec, vector<vector<int>> &mat){
                int s = 0;
                for(int i=sr; i<=er; i++)
                    for(int j=sc; j<=ec; j++)
                        s += mat[i][j];
                return s;
            }
            int maxRectSum(vector<vector<int>> &mat) {
                int mx = INT_MIN, n = mat.size(), m = mat[0].size();
                for(int i=0; i<n; i++){
                    for(int j=0; j<m; j++){
                        // start row = sr, start col = sc, end row = er, end col = ec;
                        int sr, sc, er, ec; 
                        sr = er = i, sc = ec = j;
                        while(er < n){
                            mx = max(mx, curSubMatrixSum(sr, sc, er, ec, mat));
                            ec++;
                            if(ec == m){
                                er++;
                                ec = j;
                            }
                        }
                    }
                }
                return mx;
            }
        // Optimized: ❌Pending

    1405) Palindrome Sentence:
        Problem Statement:
            Given a single string s, the task is to check if it is a palindrome sentence or not.
            A palindrome sentence is a sequence of characters, such as word, phrase, or series of symbols that reads the same backward as forward after converting all uppercase letters to lowercase and removing all non-alphanumeric characters (including spaces and punctuation).
            Examples:
            Input: s = "Too hot to hoot"
            Output: true
            Explanation: If we remove all non-alphanumeric characters and convert all uppercase letters to lowercase, string s will become "toohottohoot" which is a palindrome.
            Input: s = "Abc 012..## 10cbA"
            Output: true
            Explanation: If we remove all non-alphanumeric characters and convert all uppercase letters to lowercase, string s will become "abc01210cba" which is a palindrome.
            Input: s = "ABC $. def01ASDF"
            Output: false
            Explanation: The processed string becomes "abcdef01asdf", which is not a palindrome.
            Constraints:
                1 ≤ s.length() ≤ 10^6
        // TC: O(n) & SC: O(1)
            bool isPalinSent(string &s) {
                int i=0, j = s.size()-1;
                while(i < j){
                    if(isalnum(s[i])){
                        if(isalnum(s[j])){
                            if((isdigit(s[i]) and isdigit(s[j]) and s[i] == s[j]) or 
                                isalpha(s[i]) and isalpha(s[j]) and toupper(s[i]) == toupper(s[j])){
                                i++, j--;
                            } else {
                                return 0;
                            }
                        } else {
                            j--;
                        }
                    } else {
                        i++;
                    }
                }
                return 1;
            }
        
    1406) Shop in Candy Store:
        Problem Statement:
            In a candy store, there are different types of candies available and prices[i] represent the price of  ith types of candies. You are now provided with an attractive offer.
            For every candy you buy from the store, you can get up to k other different candies for free. Find the minimum and maximum amount of money needed to buy all the candies.
            Note: In both cases, you must take the maximum number of free candies possible during each purchase.
            Examples:
            Input: prices[] = [3, 2, 1, 4], k = 2
            Output: [3, 7]
            Explanation: As according to the offer if you buy one candy you can take at most k more for free. So in the first case, you buy the candy worth 1 and takes candies worth 3 and 4 for free, also you need to buy candy worth 2. So min cost: 1+2 = 3. In the second case, you can buy the candy worth 4 and takes candies worth 1 and 2 for free, also you need to buy candy worth 3. So max cost: 3+4 = 7.
            Input: prices[] = [3, 2, 1, 4, 5], k = 4
            Output: [1, 5]
            Explanation: For minimimum cost buy the candy with the cost 1 and get all the other candies for free. For maximum cost buy the candy with the cost 5 and get all other candies for free.
            Constraints:
                1 ≤ prices.size() ≤ 10^5
                0 ≤ k ≤ prices.size()
                1 ≤ prices[i] ≤ 10^4
        // TC: O(N LOG N) & SC: O(1)
            vector<int> minMaxCandy(vector<int>& prices, int k) {
                sort(prices.begin(), prices.end());
                int minValue, maxValue, n = prices.size();
                minValue = maxValue = 0;
                int i, j=n;
                for(i=0; i<j; i++, j-=k)
                    minValue += prices[i];
                    
                j = -1;
                for(i=n-1; i>j;  j+=k, i--)
                    maxValue += prices[i];
                
                return {minValue, maxValue};
            }

    1407) Form the Largest Number: (Refer POTD: 493)
        Problem Statement:
            Given an array of integers arr[] representing non-negative integers, arrange them so that after concatenating all of them in order, it results in the largest possible number. Since the result may be very large, return it as a string.
            Examples:
            Input: arr[] = [3, 30, 34, 5, 9]
            Output: 9534330
            Explanation: Given numbers are [3, 30, 34, 5, 9], the arrangement [9, 5, 34, 3, 30] gives the largest value.
            Input: arr[] = [54, 546, 548, 60]
            Output: 6054854654
            Explanation: Given numbers are [54, 546, 548, 60], the arrangement [60, 548, 546, 54] gives the largest value.
            Input: arr[] = [3, 4, 6, 5, 9]
            Output: 96543
            Explanation: Given numbers are [3, 4, 6, 5, 9], the arrangement [9, 6, 5, 4, 3] gives the largest value.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                0 ≤ arr[i] ≤ 10^5
        // TC: O(n log n) & SC: O(n):
            string findLargest(vector<int> &arr) {
                if(arr.empty()) return "";
                vector<string> store;
                for(int i: arr)
                    store.push_back(to_string(i));
                sort(store.begin(), store.end(), [](string &a, string &b){
                    return (a+b > b+a) ? 1 : 0;
                });
                string s;
                for(string cur: store)
                    s += cur;
                // leading zeros
                // even if leading is zero then rest also will be zero, so
                if(s[0] == '0')
                    return "0";
                // int i=0, n = s.size();
                // while(i < n-1 and s[i] == '0'){
                //     i++;
                // }
                // s = s.substr(i);
                // if(s.empty()) return "0";
                return s;
            }

    1408) Sort by Absolute Difference:
        Problem Statement:
            You are given a number x and array arr[]. Your task is to rearrange the elements of the array according to the absolute difference with x, i.e., an element having minimum difference comes first, and so on.
            Note: If two or more elements are at equal distances arrange them in the same sequence as in the given array.
            Examples:
            Input: x = 7, arr[] = [10, 5, 3, 9, 2]
            Output: [5, 9, 10, 3, 2]
            Explanation: Sorting the numbers according to the absolute difference with 7, we have array elements as 5, 9, 10, 3, 2.
            Input: x = 6, arr[] = [1, 2, 3, 4, 5]
            Output: [5, 4, 3, 2, 1]
            Explanation: Sorting the numbers according to the absolute difference with 6, we have array elements as 5, 4, 3, 2, 1.
            Constraints:
                1 ≤ x ≤ 10^5
                1 ≤ arr.size() ≤ 10^5
                1 ≤ arr[i] ≤ 10^5
        // Strange: TC: O(n log n)
            void rearrange(vector<int> &arr, int x) {
                // <value after - x, actual arr value>
                vector<pair<int, int>> hold;
                for(int i: arr)
                    hold.push_back({abs(x-i), i});
                
                sort(hold.begin(), hold.end(), [](pair<int, int> &a, pair<int, int> &b){
                    return a.first < b.first;
                });
                int n = arr.size();
                for(int i=0; i<n; i++)
                    arr[i] = hold[i].second;
            }
        // Using Stable sort TC: O(n log n) & SC: O(1): it will preserve the order of element if they are same
            void rearrange(vector<int> &arr, int x) {
                stable_sort(arr.begin(), arr.end(), [x](int a, int b){
                    return abs(a - x) < abs(b - x);
                });
            }

    1409) Farthest Smaller Right:
        Problem Statement:
            You are given an array arr[]. For each element at index i (0-based indexing), find the farthest index j to the right (i.e., j > i) such that arr[j] < arr[i]. If no such index exists for a given position, return -1 for that index. Return the resulting array of answers.
            Examples:
            Input: arr[] = [2, 5, 1, 3, 2]
            Output: [2, 4, -1, 4, -1]
            Explanation: arr[0] = 2: Farthest smaller element to the right is arr[2] = 1.
            arr[1] = 5: Farthest smaller element to the right is arr[4] = 2.
            arr[2] = 1: No smaller element to the right → -1.
            arr[3] = 3: Farthest smaller element to the right is arr[4] = 2.
            arr[4] = 2: No elements to the right → -1.
            Input: arr[] = [2, 3, 5, 4, 1] 
            Output: [4, 4, 4, 4, -1]
            Explanation: arr[4] is the farthest smallest element to the right for arr[0], arr[1], arr[2] and arr[3].
            Constraints:
                1 ≤ arr.size() ≤ 10^6
                1 ≤ arr[i] ≤ 10^6
        // Not Optimized: TC: O(n²) & SC: O(1)
            vector<int> farMin(vector<int>& arr) {
                int n = arr.size();
                if(!n) return {};
                vector<int> ans (n, -1);
                for(int i=0; i<n; i++){
                    int index = -1;
                    for(int j=i+1; j<n; j++){
                        if(arr[i] > arr[j]) index = j;
                    }
                    ans[i] = index;
                }
                return ans;
            }
        // Optimized: TC: O(n log n) & SC: O(n):
            vector<int> farMin(vector<int>& arr) {
                int n = arr.size();
                if(!n) return {};
                vector<int> ans (n, -1);
                for(int i=0; i<n; i++){
                    for(int j=n-1; j>i; j--){
                        if(arr[i] > arr[j]){
                            ans[i] = j;
                            break;
                        }
                    }
                }
                return ans;
            }

    1410) Search in fully rotated sorted 2D matrix:
        Problem Statement:
            You are given a 2D matrix mat[][] of size n x m that was initially filled in the following manner:
            Each row is sorted in increasing order from left to right.
            The first element of every row is greater than the last element of the previous row.
            This implies that if the matrix is flattened row-wise, it forms a strictly sorted 1D array.
            Later, this sorted 1D array was rotated at some unknown pivot. The rotated array was then written back into the matrix row-wise to form the current matrix.
            Given such a matrix mat[][] and an integer x, determine whether x exists in the matrix.
            Examples:
            Input: x = 3,
            mat[][] = [[7, 8, 9, 10],
                    [11, 12, 13, 1],
                    [2, 3, 4, 5]] 
            Output: true
            Explanation: 3 is located at the 3rd row and 2nd column.
            Input: x = 10,
            mat[][] = [[6, 7, 8],
                    [9, 1, 2],
                    [3, 4, 5]]
            Output: false
            Explanation: The value 10 does not exist in the matrix.
            Constraint:
                1 ≤ n × m ≤ 105
                1 ≤ mat[i][j], x ≤ 106
        // Not Optimized: TC: O(n * m) & SC: O(1)
            bool searchMatrix(vector<vector<int>> &mat, int x) {
                int n = mat.size();
                if(!n) return 0;
                int m = mat[0].size();
                for(int i=0; i<n; i++){
                    for(int j=0; j<m; j++){
                        if(mat[i][j] == x) return 1;
                    }
                }
                return 0;
            }
        // Using priority_queue: TC: (n*m*log(n)) & SC: O(n)
            int median(vector<vector<int>> &mat) {
                // <current element of mat, rowIndex, colIndex>
                priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHP;
                int n=mat.size(), m = mat[0].size();
                for(int i=0; i<n; i++)
                    minHP.push({mat[i][0], i, 0});
                
                int mid = (n * m) / 2;
                int cnt = 0, res=0;
                
                while(cnt <= mid){
                    vector<int> v = minHP.top();
                    minHP.pop();
                    
                    int val = v[0], row = v[1], col = v[2];
                    res = val;
                    cnt++;
                    
                    if(col + 1 < m)
                        minHP.push({mat[row][col+1], row, col+1});
                }
                return res;
            }
        // Optimized: ❌Pending

    1411) Median in a row-wise sorted Matrix:
        Problem Statement:
            Given a row-wise sorted matrix mat[][] of size n*m, where the number of rows and columns is always odd. Return the median of the matrix.
            Examples:
            Input: mat[][] = [[1, 3, 5], 
                            [2, 6, 9], 
                            [3, 6, 9]]
            Output: 5
            Explanation: Sorting matrix elements gives us [1, 2, 3, 3, 5, 6, 6, 9, 9]. Hence, 5 is median.
            Input: mat[][] = [[2, 4, 9],
                            [3, 6, 7],
                            [4, 7, 10]]
            Output: 6
            Explanation: Sorting matrix elements gives us [2, 3, 4, 4, 6, 7, 7, 9, 10]. Hence, 6 is median.
            Input: mat = [[3], [4], [8]]
            Output: 4
            Explanation: Sorting matrix elements gives us [3, 4, 8]. Hence, 4 is median.
            Constraints:
                1 ≤ n, m ≤ 400
                1 ≤ mat[i][j] ≤ 2000
        // Not Optimized: TC: O(x + x log x), SC: O(x), where x = n*m
            int median(vector<vector<int>> &mat) {
                vector<int> v;
                for(auto itr: mat)
                    for(int i: itr)
                        v.push_back(i);
                sort(v.begin(), v.end());
                return v[v.size()/2];
            }
        // Optimized: ❌Pending

    1412) Maximize the minimum difference between k elements:
        Problem Statement:
            Given an array arr[] of integers and an integer k, select k elements from the array such that the minimum absolute difference between any two of the selected elements is maximized. Return this maximum possible minimum difference.
            Examples:
            Input: arr[] = [2, 6, 2, 5], k = 3
            Output: 1
            Explanation: 3 elements out of 4 elements are to be selected with a minimum difference as large as possible. Selecting 2, 2, 5 will result in minimum difference as 0. Selecting 2, 5, 6 will result in minimum difference as 6 - 5 = 1.
            Input: arr[] = [1, 4, 9, 0, 2, 13, 3], k = 4
            Output: 4
            Explanation: Selecting 0, 4, 9, 13 will result in minimum difference of 4, which is the largest minimum difference possible.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                0 ≤ arr[i] ≤ 10^6
                2 ≤ k ≤ arr.size() 
        // Not Optimized: TC: O(n * n^k * k²), SC: O()
            void RetriveAns(vector<int>& arr, int &ans, int k, vector<int>& temp, int i){
                int n = arr.size();
                if(k == 0){
                    int v = INT_MAX, t2 = temp.size();
                    for(int j=0; j<t2-1; j++){
                        for(int z=j+1; z<t2; z++){
                            v = min(v, abs(temp[j] - temp[z]));
                        }
                    }
                    ans = max(ans, v);
                    return ;
                }
                
                for(int z=i; z<n; z++){
                    temp.push_back(arr[z]);
                    RetriveAns(arr, ans, k-1, temp, z);
                    temp.pop_back();
                }
            }
            int maxMinDiff(vector<int>& arr, int k) {
                int ans=0, n = arr.size();
                vector<int> temp;
                for(int i=0; i<=n-k; i++){
                    if(i == n-k){
                        int v = INT_MAX;
                        for(int j=i; j<n-1; j++){
                            for(int z=j+1; z<n; z++){
                                v = min(v, abs(arr[j] - arr[z]));
                            }
                        }
                        ans = max(ans, v);
                    } else {
                        RetriveAns(arr, ans, k, temp, i);
                    }
                }
                return ans;
            }
        // Optimized: ❌Pending

1413) 

1414)
    
