POTDs:
    1399) Make Matrix Beautiful:
        Problem Statement:
            A beautiful matrix is defined as a square matrix in which the sum of elements in every row and every column is equal. Given a square matrix mat[][], your task is to determine the minimum number of operations required to make the matrix beautiful.
            In one operation, you are allowed to increment the value of any single cell by 1.
            Examples:
            Input: mat[][] = [[1, 2], 
                            [3, 4]]
            Output: 4
            Explanation:
            Increment value of cell(0, 0) by 3, 
            Increment value of cell(0, 1) by 1. 
            Matrix after the operations: [[4, 3], 
                                        [3, 4]]
            Here, sum of each row and column is 7.
            Hence total 4 operation are required.
            Input: mat[][] = [[1, 2, 3],
                            [4, 2, 3],
                            [3, 2, 1]]
            Output: 6
            Explanation: 
            Increment value of cell(0, 0) by 1, 
            Increment value of cell(0, 1) by 2, 
            Increment value of cell(2, 1) by 1, 
            Increment value of cell(2, 2) by 2. 
            Matrix after the operations: [[2, 4, 3], 
                                        [4, 2, 3],
                                        [3, 3, 3]] 
            Here, sum of each row and column is 9.
            Hence total 6 operation are required.
            Constraints:
                1 ≤ mat.size() ≤ 900
                0 ≤ mat[i][j] ≤ 10^6
        // TC: O(n*m) & SC: O(1)
            int balanceSums(vector<vector<int>>& mat) {
                int n = mat.size();
                if(!n) return 0;
                int mxValue = 0, m = mat[0].size();
                for(int i=0; i<n; i++){
                    int cur=0;
                    for(int j=0; j<m; j++)  cur += mat[i][j];
                    mxValue = max(mxValue, cur);
                }
                
                for(int i=0; i<m; i++){
                    int cur=0;
                    for(int j=0; j<n; j++)  cur += mat[j][i];
                    mxValue = max(mxValue, cur);
                }
                int ans=0;
                for(vector<int> cur: mat)
                    ans += mxValue - accumulate(cur.begin(), cur.end(), 0);   
                return ans;
            }

    1400) ASCII Range Sum:
        Problem Statement:
            Given a string s consisting of lowercase English letters, for every character whose first and last occurrences are at different positions, calculate the sum of ASCII values of characters strictly between its first and last occurrence.
            Return all such non-zero sums (order does not matter).
            Examples:
            Input: s = "abacab"
            Output: [293, 294]
            Explanation: characters 'a' and 'b' appear more than once:
            'a' : between positions 1 and 5 → characters are b, a, c and ascii sum is 98 + 97 + 99 = 294.
            'b' : between positions 2 and 6 → characters are a, c, a and ascii sum is 97 + 99 + 97 = 293.
            Input: s = "acdac"
            Output: [197, 199]
            Explanation: characters 'a' and 'c' appear more than once:
            'a' : between positions 1 and 4 → characters are c, d and ascii sum is 99 + 100 = 199.
            'c' : between positions 2 and 5 → characters are d, a and ascii sum is 100 + 97 = 197.
            Constraints:
                1 ≤ s.size() ≤ 10^5
        // TC: O(n) & SC: O(n)
            vector<int> asciirange(string& s) {
                // <character, its indexes>
                vector<vector<int>> mapping (26);
                vector<int> vis(26, 0);
                
                int n = s.size();
                for(int i=0; i<n; i++)
                    mapping[s[i] - 'a'].push_back(i);
                vector<int> ans;
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    // Skip the iteration if,
                    // character is already visited
                    // or its start & end is same index or just difference is 1
                    if(vis[ch - 'a'] or start == end or start == end - 1) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    ans.push_back(sum);
                }
                /*
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    if(vis[ch - 'a'] or start == end) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    if(sum) ans.push_back(sum);
                }
                */
                return ans;
            }

    1401) Powerful Integer:
        Problem Statement:
            You are given a 2D integer array intervals[][] of length n, where each intervals[i] = [start, end] represents a closed interval (i.e., all integers from start to end, inclusive). You are also given an integer k. An integer is called Powerful if it appears in at least k intervals. Find the maximum Powerful Integer.
            Note: If no integer occurs at least k times return -1.
            Examples:
            Input : n = 3, intervals[][] = [[1, 3], [4, 6], [3, 4]], k = 2
            Output: 4
            Explanation: Integers 3 and 4 appear in 2 intervals. The maximum is 4.
            Input : n = 4, intervals[][] = [[1, 4], [12, 45], [3, 8], [10, 12]], k = 3
            Output: -1
            Explanation: No integer appears in at least 3 intervals.
            Input : n = 5, intervals[][] = [[16, 21], [5, 8], [12, 17], [17, 29], [9, 24]], k = 3
            Output: 21
            Explanation: Integers 16, 17, 18, 19, 20 and 21 appear in at least 3 intervals. The maximum is 21.
            Constraints:
                1 ≤ n ≤ 10^5
                1 ≤ intervals[i][0] ≤ intervals[i][1] ≤ 10^9
                1 ≤ k ≤ 10^5
        // Not Optimized: TC: O(n) & SC: O(U)
            where n = total interval length, U = number of unique integers between all [s, e] ranges.
            int powerfulInteger(vector<vector<int>>& intervals, int k) {
                map<int, int> Freq;
                int ans = -1;
                for(auto cur: intervals){
                    int s = cur[0], e = cur[1];
                    for(int i=s; i<=e; i++)
                        Freq[i]++;
                }
                for(auto i: Freq)
                    if(i.second >= k)
                        ans = i.first;          // no need to check is max or not, coz map store all things in sorted order
                return ans;
            }
        // Optimized: ❌pending

    1402) Balancing Consonants and Vowels Ratio:
        Problem Statement:
            You are given an array of strings arr[], where each arr[i] consists of lowercase english alphabets. You need to find the number of balanced strings in arr[] which can be formed by concatinating one or more contiguous strings of arr[].
            A balanced string contains the equal number of vowels and consonants. 
            Examples:
            Input: arr[] = ["aeio", "aa", "bc", "ot", "cdbd"]
            Output: 4
            Explanation: arr[0..4], arr[1..2], arr[1..3], arr[3..3] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["ab", "be"]
            Output: 3
            Explanation: arr[0..0], arr[0..1], arr[1..1] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["tz", "gfg", "ae"]
            Output: 0
            Explanation: There is no such balanced substring present in arr[] with equal consonants and vowels.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                1 ≤ arr[i].size() ≤ 10^5
                Total number of lowercase english characters in arr[] is lesser than 10^5.
        // Not Optimized: TC: O(n * l + n²) & SC: O(n)
            bool isVowel(char ch){
                return ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u';
            }
            int countBalanced(vector<string>& arr) {
                int cnt=0;
                // <vowels, consonants>
                vector<pair<int, int>> Freq;
                for(string s: arr){
                    int vow, conso;
                    vow = conso = 0;
                    for(char ch: s)
                        isVowel(ch) ? vow++ : conso++;
                    Freq.push_back({vow, conso});
                }
                int n = arr.size();
                for(int i=0; i<n; i++){
                    int curVow, curConso;
                    curVow = curConso = 0;
                    for(int j=i; j<n; j++){
                        curVow += Freq[j].first;
                        curConso += Freq[j].second;
                        if(curVow == curConso) cnt++;
                    }
                }
                return cnt;
            }
        // Optimized: ❌pending

1403)

1404)

1405)

1406)

1407)

1408)
1409)
1410)
1411)
1412)
1413)
1414)
    
