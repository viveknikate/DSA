Old:
    Refer from DSA Love Babbar txt file:
    1331)
        int longestSubarray(vector<int> &arr, int k) {
            int mxLen=0, n = arr.size();
            for(int i=0; i<n; i++){
                int GreaterK, LessEqualK;
                GreaterK = LessEqualK = 0;
                for(int j=i; j<n; j++){
                    (arr[j] > k) ? GreaterK++ : LessEqualK++;
                    if(GreaterK > LessEqualK)
                        mxLen = max(mxLen, j-i+1);
                }
            }
            return mxLen;
        }

POTDs:
    1399) Make Matrix Beautiful:
        Problem Statement:
            A beautiful matrix is defined as a square matrix in which the sum of elements in every row and every column is equal. Given a square matrix mat[][], your task is to determine the minimum number of operations required to make the matrix beautiful.
            In one operation, you are allowed to increment the value of any single cell by 1.
            Examples:
            Input: mat[][] = [[1, 2], 
                            [3, 4]]
            Output: 4
            Explanation:
            Increment value of cell(0, 0) by 3, 
            Increment value of cell(0, 1) by 1. 
            Matrix after the operations: [[4, 3], 
                                        [3, 4]]
            Here, sum of each row and column is 7.
            Hence total 4 operation are required.
            Input: mat[][] = [[1, 2, 3],
                            [4, 2, 3],
                            [3, 2, 1]]
            Output: 6
            Explanation: 
            Increment value of cell(0, 0) by 1, 
            Increment value of cell(0, 1) by 2, 
            Increment value of cell(2, 1) by 1, 
            Increment value of cell(2, 2) by 2. 
            Matrix after the operations: [[2, 4, 3], 
                                        [4, 2, 3],
                                        [3, 3, 3]] 
            Here, sum of each row and column is 9.
            Hence total 6 operation are required.
            Constraints:
                1 ≤ mat.size() ≤ 900
                0 ≤ mat[i][j] ≤ 10^6
        // TC: O(n*m) & SC: O(1)
            int balanceSums(vector<vector<int>>& mat) {
                int n = mat.size();
                if(!n) return 0;
                int mxValue = 0, m = mat[0].size();
                for(int i=0; i<n; i++){
                    int cur=0;
                    for(int j=0; j<m; j++)  cur += mat[i][j];
                    mxValue = max(mxValue, cur);
                }
                
                for(int i=0; i<m; i++){
                    int cur=0;
                    for(int j=0; j<n; j++)  cur += mat[j][i];
                    mxValue = max(mxValue, cur);
                }
                int ans=0;
                for(vector<int> cur: mat)
                    ans += mxValue - accumulate(cur.begin(), cur.end(), 0);   
                return ans;
            }

    1400) ASCII Range Sum:
        Problem Statement:
            Given a string s consisting of lowercase English letters, for every character whose first and last occurrences are at different positions, calculate the sum of ASCII values of characters strictly between its first and last occurrence.
            Return all such non-zero sums (order does not matter).
            Examples:
            Input: s = "abacab"
            Output: [293, 294]
            Explanation: characters 'a' and 'b' appear more than once:
            'a' : between positions 1 and 5 → characters are b, a, c and ascii sum is 98 + 97 + 99 = 294.
            'b' : between positions 2 and 6 → characters are a, c, a and ascii sum is 97 + 99 + 97 = 293.
            Input: s = "acdac"
            Output: [197, 199]
            Explanation: characters 'a' and 'c' appear more than once:
            'a' : between positions 1 and 4 → characters are c, d and ascii sum is 99 + 100 = 199.
            'c' : between positions 2 and 5 → characters are d, a and ascii sum is 100 + 97 = 197.
            Constraints:
                1 ≤ s.size() ≤ 10^5
        // TC: O(n) & SC: O(n)
            vector<int> asciirange(string& s) {
                // <character, its indexes>
                vector<vector<int>> mapping (26);
                vector<int> vis(26, 0);
                
                int n = s.size();
                for(int i=0; i<n; i++)
                    mapping[s[i] - 'a'].push_back(i);
                vector<int> ans;
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    // Skip the iteration if,
                    // character is already visited
                    // or its start & end is same index or just difference is 1
                    if(vis[ch - 'a'] or start == end or start == end - 1) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    ans.push_back(sum);
                }
                /*
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    if(vis[ch - 'a'] or start == end) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    if(sum) ans.push_back(sum);
                }
                */
                return ans;
            }

    1401) Powerful Integer:
        Problem Statement:
            You are given a 2D integer array intervals[][] of length n, where each intervals[i] = [start, end] represents a closed interval (i.e., all integers from start to end, inclusive). You are also given an integer k. An integer is called Powerful if it appears in at least k intervals. Find the maximum Powerful Integer.
            Note: If no integer occurs at least k times return -1.
            Examples:
            Input : n = 3, intervals[][] = [[1, 3], [4, 6], [3, 4]], k = 2
            Output: 4
            Explanation: Integers 3 and 4 appear in 2 intervals. The maximum is 4.
            Input : n = 4, intervals[][] = [[1, 4], [12, 45], [3, 8], [10, 12]], k = 3
            Output: -1
            Explanation: No integer appears in at least 3 intervals.
            Input : n = 5, intervals[][] = [[16, 21], [5, 8], [12, 17], [17, 29], [9, 24]], k = 3
            Output: 21
            Explanation: Integers 16, 17, 18, 19, 20 and 21 appear in at least 3 intervals. The maximum is 21.
            Constraints:
                1 ≤ n ≤ 10^5
                1 ≤ intervals[i][0] ≤ intervals[i][1] ≤ 10^9
                1 ≤ k ≤ 10^5
        // Not Optimized: TC: O(n) & SC: O(U)
            where n = total interval length, U = number of unique integers between all [s, e] ranges.
            int powerfulInteger(vector<vector<int>>& intervals, int k) {
                map<int, int> Freq;
                int ans = -1;
                for(auto cur: intervals){
                    int s = cur[0], e = cur[1];
                    for(int i=s; i<=e; i++)
                        Freq[i]++;
                }
                for(auto i: Freq)
                    if(i.second >= k)
                        ans = i.first;          // no need to check is max or not, coz map store all things in sorted order
                return ans;
            }
        // Optimized: ❌Pending

    1402) Balancing Consonants and Vowels Ratio:
        Problem Statement:
            You are given an array of strings arr[], where each arr[i] consists of lowercase english alphabets. You need to find the number of balanced strings in arr[] which can be formed by concatinating one or more contiguous strings of arr[].
            A balanced string contains the equal number of vowels and consonants. 
            Examples:
            Input: arr[] = ["aeio", "aa", "bc", "ot", "cdbd"]
            Output: 4
            Explanation: arr[0..4], arr[1..2], arr[1..3], arr[3..3] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["ab", "be"]
            Output: 3
            Explanation: arr[0..0], arr[0..1], arr[1..1] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["tz", "gfg", "ae"]
            Output: 0
            Explanation: There is no such balanced substring present in arr[] with equal consonants and vowels.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                1 ≤ arr[i].size() ≤ 10^5
                Total number of lowercase english characters in arr[] is lesser than 10^5.
        // Not Optimized: TC: O(n * l + n²) & SC: O(n)
            bool isVowel(char ch){
                return ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u';
            }
            int countBalanced(vector<string>& arr) {
                int cnt=0;
                // <vowels, consonants>
                vector<pair<int, int>> Freq;
                for(string s: arr){
                    int vow, conso;
                    vow = conso = 0;
                    for(char ch: s)
                        isVowel(ch) ? vow++ : conso++;
                    Freq.push_back({vow, conso});
                }
                int n = arr.size();
                for(int i=0; i<n; i++){
                    int curVow, curConso;
                    curVow = curConso = 0;
                    for(int j=i; j<n; j++){
                        curVow += Freq[j].first;
                        curConso += Freq[j].second;
                        if(curVow == curConso) cnt++;
                    }
                }
                return cnt;
            }
        // Optimized: ❌Pending

    1403) 2D Difference Array:
        Problem Statement:
            You are given a 2D integer matrix mat[][] of size n × m and a list of q operations opr[][]. 
            Each operation is represented as an array [v, r1, c1, r2, c2], where:
                v is the value to be added
                (r1, c1) is the top-left cell of a submatrix
                (r2, c2) is the bottom-right cell of the submatrix (inclusive)
            For each of the q operations, add v to every element in the submatrix from (r1, c1) to (r2, c2). 
            Return the final matrix after applying all operations.
            Examples:
            Input: mat[][] = [[1, 2, 3],  opr[][] = [[2, 0, 0, 1, 1], [-1, 1, 0, 2, 2]]
                            [1, 1, 0],
                            [4,-2, 2]]
            Output: [[3, 4, 3],
                    [2, 2, -1],
                    [3, -3, 1]] 
            Explanation:
            Constraint:
                1 ≤ n×m, q ≤ 10^5
                0 ≤ r1 ≤ r2 ≤ n - 1
                0 ≤ c1 ≤ c2 ≤ m - 1
                -10^4 ≤ mat[i][j], v ≤ 10^4
        // Not Optimized: TC: O(n * R * C) & SC: O(1):
            vector<vector<int>> applyDiff2D(vector<vector<int>>& mat, vector<vector<int>>& opr) {
                for(auto q: opr){
                    for(int r=q[1]; r<=q[3]; r++){
                        for(int c=q[2]; c<=q[4]; c++){
                            mat[r][c] += q[0];
                        }
                    }
                }
                return mat;
            }
        // Optimized: ❌Pending

    1404) Maximum sum Rectangle:
        Problem Statement:
            Given a 2D matrix mat[][] with dimensions n×m. Find the maximum possible sum of any submatrix within the given matrix.
            Examples:
            Input: mat[][] = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]
            Output: 29
            Explanation: The matrix is as follows and the green rectangle denotes the maximum sum rectangle which is equal to 29.
            Input: mat[][] = [[-1, -2], [-3, -4]]
            Output: -1
            Explanation: Taking only the first cell is the optimal choice.
            Constraints:
                1 ≤ n, m ≤ 300
                -1000 ≤ mat[i][j] ≤ 1000
        // Not Optimized: TC: O(n³ * m²) & SC: O(1)
            int curSubMatrixSum(int sr, int sc, int er, int ec, vector<vector<int>> &mat){
                int s = 0;
                for(int i=sr; i<=er; i++)
                    for(int j=sc; j<=ec; j++)
                        s += mat[i][j];
                return s;
            }
            int maxRectSum(vector<vector<int>> &mat) {
                int mx = INT_MIN, n = mat.size(), m = mat[0].size();
                for(int i=0; i<n; i++){
                    for(int j=0; j<m; j++){
                        // start row = sr, start col = sc, end row = er, end col = ec;
                        int sr, sc, er, ec; 
                        sr = er = i, sc = ec = j;
                        while(er < n){
                            mx = max(mx, curSubMatrixSum(sr, sc, er, ec, mat));
                            ec++;
                            if(ec == m){
                                er++;
                                ec = j;
                            }
                        }
                    }
                }
                return mx;
            }
        // Optimized: ❌Pending

    1405) Palindrome Sentence:
        Problem Statement:
            Given a single string s, the task is to check if it is a palindrome sentence or not.
            A palindrome sentence is a sequence of characters, such as word, phrase, or series of symbols that reads the same backward as forward after converting all uppercase letters to lowercase and removing all non-alphanumeric characters (including spaces and punctuation).
            Examples:
            Input: s = "Too hot to hoot"
            Output: true
            Explanation: If we remove all non-alphanumeric characters and convert all uppercase letters to lowercase, string s will become "toohottohoot" which is a palindrome.
            Input: s = "Abc 012..## 10cbA"
            Output: true
            Explanation: If we remove all non-alphanumeric characters and convert all uppercase letters to lowercase, string s will become "abc01210cba" which is a palindrome.
            Input: s = "ABC $. def01ASDF"
            Output: false
            Explanation: The processed string becomes "abcdef01asdf", which is not a palindrome.
            Constraints:
                1 ≤ s.length() ≤ 10^6
        // TC: O(n) & SC: O(1)
            bool isPalinSent(string &s) {
                int i=0, j = s.size()-1;
                while(i < j){
                    if(isalnum(s[i])){
                        if(isalnum(s[j])){
                            if((isdigit(s[i]) and isdigit(s[j]) and s[i] == s[j]) or 
                                isalpha(s[i]) and isalpha(s[j]) and toupper(s[i]) == toupper(s[j])){
                                i++, j--;
                            } else {
                                return 0;
                            }
                        } else {
                            j--;
                        }
                    } else {
                        i++;
                    }
                }
                return 1;
            }
        
    1406) Shop in Candy Store:
        Problem Statement:
            In a candy store, there are different types of candies available and prices[i] represent the price of  ith types of candies. You are now provided with an attractive offer.
            For every candy you buy from the store, you can get up to k other different candies for free. Find the minimum and maximum amount of money needed to buy all the candies.
            Note: In both cases, you must take the maximum number of free candies possible during each purchase.
            Examples:
            Input: prices[] = [3, 2, 1, 4], k = 2
            Output: [3, 7]
            Explanation: As according to the offer if you buy one candy you can take at most k more for free. So in the first case, you buy the candy worth 1 and takes candies worth 3 and 4 for free, also you need to buy candy worth 2. So min cost: 1+2 = 3. In the second case, you can buy the candy worth 4 and takes candies worth 1 and 2 for free, also you need to buy candy worth 3. So max cost: 3+4 = 7.
            Input: prices[] = [3, 2, 1, 4, 5], k = 4
            Output: [1, 5]
            Explanation: For minimimum cost buy the candy with the cost 1 and get all the other candies for free. For maximum cost buy the candy with the cost 5 and get all other candies for free.
            Constraints:
                1 ≤ prices.size() ≤ 10^5
                0 ≤ k ≤ prices.size()
                1 ≤ prices[i] ≤ 10^4
        // TC: O(N LOG N) & SC: O(1)
            vector<int> minMaxCandy(vector<int>& prices, int k) {
                sort(prices.begin(), prices.end());
                int minValue, maxValue, n = prices.size();
                minValue = maxValue = 0;
                int i, j=n;
                for(i=0; i<j; i++, j-=k)
                    minValue += prices[i];
                    
                j = -1;
                for(i=n-1; i>j;  j+=k, i--)
                    maxValue += prices[i];
                
                return {minValue, maxValue};
            }

    1407) Form the Largest Number: (Refer POTD: 493)
        Problem Statement:
            Given an array of integers arr[] representing non-negative integers, arrange them so that after concatenating all of them in order, it results in the largest possible number. Since the result may be very large, return it as a string.
            Examples:
            Input: arr[] = [3, 30, 34, 5, 9]
            Output: 9534330
            Explanation: Given numbers are [3, 30, 34, 5, 9], the arrangement [9, 5, 34, 3, 30] gives the largest value.
            Input: arr[] = [54, 546, 548, 60]
            Output: 6054854654
            Explanation: Given numbers are [54, 546, 548, 60], the arrangement [60, 548, 546, 54] gives the largest value.
            Input: arr[] = [3, 4, 6, 5, 9]
            Output: 96543
            Explanation: Given numbers are [3, 4, 6, 5, 9], the arrangement [9, 6, 5, 4, 3] gives the largest value.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                0 ≤ arr[i] ≤ 10^5
        // TC: O(n log n) & SC: O(n):
            string findLargest(vector<int> &arr) {
                if(arr.empty()) return "";
                vector<string> store;
                for(int i: arr)
                    store.push_back(to_string(i));
                sort(store.begin(), store.end(), [](string &a, string &b){
                    return (a+b > b+a) ? 1 : 0;
                });
                string s;
                for(string cur: store)
                    s += cur;
                // leading zeros
                // even if leading is zero then rest also will be zero, so
                if(s[0] == '0')
                    return "0";
                // int i=0, n = s.size();
                // while(i < n-1 and s[i] == '0'){
                //     i++;
                // }
                // s = s.substr(i);
                // if(s.empty()) return "0";
                return s;
            }

1408)
1409)
1410)
1411)
1412)
1413)
1414)
    
