Old:
    Refer from DSA Love Babbar txt file:
    453) Maximize Number of 1's:
        // TC: O(n) & SC: (1)
            int maxOnes(vector<int>& arr, int k) {
                int i, j, n = arr.size(), mxLen=0;
                i = j = 0;
                while(i < n){
                    if(!arr[i++]) k--;
                    while(k < 0){
                        if(!arr[j++]) k++;
                    }
                    mxLen = max(mxLen, i-j);
                }
                return mxLen;
            }

    1331)
        int longestSubarray(vector<int> &arr, int k) {
            int mxLen=0, n = arr.size();
            for(int i=0; i<n; i++){
                int GreaterK, LessEqualK;
                GreaterK = LessEqualK = 0;
                for(int j=i; j<n; j++){
                    (arr[j] > k) ? GreaterK++ : LessEqualK++;
                    if(GreaterK > LessEqualK)
                        mxLen = max(mxLen, j-i+1);
                }
            }
            return mxLen;
        }

POTDs:
    1399) Make Matrix Beautiful:
        Problem Statement:
            A beautiful matrix is defined as a square matrix in which the sum of elements in every row and every column is equal. Given a square matrix mat[][], your task is to determine the minimum number of operations required to make the matrix beautiful.
            In one operation, you are allowed to increment the value of any single cell by 1.
            Examples:
            Input: mat[][] = [[1, 2], 
                            [3, 4]]
            Output: 4
            Explanation:
            Increment value of cell(0, 0) by 3, 
            Increment value of cell(0, 1) by 1. 
            Matrix after the operations: [[4, 3], 
                                        [3, 4]]
            Here, sum of each row and column is 7.
            Hence total 4 operation are required.
            Input: mat[][] = [[1, 2, 3],
                            [4, 2, 3],
                            [3, 2, 1]]
            Output: 6
            Explanation: 
            Increment value of cell(0, 0) by 1, 
            Increment value of cell(0, 1) by 2, 
            Increment value of cell(2, 1) by 1, 
            Increment value of cell(2, 2) by 2. 
            Matrix after the operations: [[2, 4, 3], 
                                        [4, 2, 3],
                                        [3, 3, 3]] 
            Here, sum of each row and column is 9.
            Hence total 6 operation are required.
            Constraints:
                1 ≤ mat.size() ≤ 900
                0 ≤ mat[i][j] ≤ 10^6
        // TC: O(n*m) & SC: O(1)
            int balanceSums(vector<vector<int>>& mat) {
                int n = mat.size();
                if(!n) return 0;
                int mxValue = 0, m = mat[0].size();
                for(int i=0; i<n; i++){
                    int cur=0;
                    for(int j=0; j<m; j++)  cur += mat[i][j];
                    mxValue = max(mxValue, cur);
                }
                
                for(int i=0; i<m; i++){
                    int cur=0;
                    for(int j=0; j<n; j++)  cur += mat[j][i];
                    mxValue = max(mxValue, cur);
                }
                int ans=0;
                for(vector<int> cur: mat)
                    ans += mxValue - accumulate(cur.begin(), cur.end(), 0);   
                return ans;
            }

    1400) ASCII Range Sum:
        Problem Statement:
            Given a string s consisting of lowercase English letters, for every character whose first and last occurrences are at different positions, calculate the sum of ASCII values of characters strictly between its first and last occurrence.
            Return all such non-zero sums (order does not matter).
            Examples:
            Input: s = "abacab"
            Output: [293, 294]
            Explanation: characters 'a' and 'b' appear more than once:
            'a' : between positions 1 and 5 → characters are b, a, c and ascii sum is 98 + 97 + 99 = 294.
            'b' : between positions 2 and 6 → characters are a, c, a and ascii sum is 97 + 99 + 97 = 293.
            Input: s = "acdac"
            Output: [197, 199]
            Explanation: characters 'a' and 'c' appear more than once:
            'a' : between positions 1 and 4 → characters are c, d and ascii sum is 99 + 100 = 199.
            'c' : between positions 2 and 5 → characters are d, a and ascii sum is 100 + 97 = 197.
            Constraints:
                1 ≤ s.size() ≤ 10^5
        // TC: O(n) & SC: O(n)
            vector<int> asciirange(string& s) {
                // <character, its indexes>
                vector<vector<int>> mapping (26);
                vector<int> vis(26, 0);
                
                int n = s.size();
                for(int i=0; i<n; i++)
                    mapping[s[i] - 'a'].push_back(i);
                vector<int> ans;
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    // Skip the iteration if,
                    // character is already visited
                    // or its start & end is same index or just difference is 1
                    if(vis[ch - 'a'] or start == end or start == end - 1) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    ans.push_back(sum);
                }
                /*
                for(char ch: s){
                    int start = mapping[ch - 'a'].front(), end = mapping[ch-'a'].back();
                    if(vis[ch - 'a'] or start == end) continue;
                    vis[ch - 'a'] = 1;
                    int sum=0;
                    for(int i = start+1; i<end; i++)
                        sum += s[i];
                    if(sum) ans.push_back(sum);
                }
                */
                return ans;
            }

    1401) Powerful Integer:
        Problem Statement:
            You are given a 2D integer array intervals[][] of length n, where each intervals[i] = [start, end] represents a closed interval (i.e., all integers from start to end, inclusive). You are also given an integer k. An integer is called Powerful if it appears in at least k intervals. Find the maximum Powerful Integer.
            Note: If no integer occurs at least k times return -1.
            Examples:
            Input : n = 3, intervals[][] = [[1, 3], [4, 6], [3, 4]], k = 2
            Output: 4
            Explanation: Integers 3 and 4 appear in 2 intervals. The maximum is 4.
            Input : n = 4, intervals[][] = [[1, 4], [12, 45], [3, 8], [10, 12]], k = 3
            Output: -1
            Explanation: No integer appears in at least 3 intervals.
            Input : n = 5, intervals[][] = [[16, 21], [5, 8], [12, 17], [17, 29], [9, 24]], k = 3
            Output: 21
            Explanation: Integers 16, 17, 18, 19, 20 and 21 appear in at least 3 intervals. The maximum is 21.
            Constraints:
                1 ≤ n ≤ 10^5
                1 ≤ intervals[i][0] ≤ intervals[i][1] ≤ 10^9
                1 ≤ k ≤ 10^5
        // Not Optimized: TC: O(n) & SC: O(U)
            where n = total interval length, U = number of unique integers between all [s, e] ranges.
            int powerfulInteger(vector<vector<int>>& intervals, int k) {
                map<int, int> Freq;
                int ans = -1;
                for(auto cur: intervals){
                    int s = cur[0], e = cur[1];
                    for(int i=s; i<=e; i++)
                        Freq[i]++;
                }
                for(auto i: Freq)
                    if(i.second >= k)
                        ans = i.first;          // no need to check is max or not, coz map store all things in sorted order
                return ans;
            }
        // Optimized: ❌Pending

    1402) Balancing Consonants and Vowels Ratio:
        Problem Statement:
            You are given an array of strings arr[], where each arr[i] consists of lowercase english alphabets. You need to find the number of balanced strings in arr[] which can be formed by concatinating one or more contiguous strings of arr[].
            A balanced string contains the equal number of vowels and consonants. 
            Examples:
            Input: arr[] = ["aeio", "aa", "bc", "ot", "cdbd"]
            Output: 4
            Explanation: arr[0..4], arr[1..2], arr[1..3], arr[3..3] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["ab", "be"]
            Output: 3
            Explanation: arr[0..0], arr[0..1], arr[1..1] are the balanced substrings with equal consonants and vowels.
            Input: arr[] = ["tz", "gfg", "ae"]
            Output: 0
            Explanation: There is no such balanced substring present in arr[] with equal consonants and vowels.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                1 ≤ arr[i].size() ≤ 10^5
                Total number of lowercase english characters in arr[] is lesser than 10^5.
        // Not Optimized: TC: O(n * l + n²) & SC: O(n)
            bool isVowel(char ch){
                return ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u';
            }
            int countBalanced(vector<string>& arr) {
                int cnt=0;
                // <vowels, consonants>
                vector<pair<int, int>> Freq;
                for(string s: arr){
                    int vow, conso;
                    vow = conso = 0;
                    for(char ch: s)
                        isVowel(ch) ? vow++ : conso++;
                    Freq.push_back({vow, conso});
                }
                int n = arr.size();
                for(int i=0; i<n; i++){
                    int curVow, curConso;
                    curVow = curConso = 0;
                    for(int j=i; j<n; j++){
                        curVow += Freq[j].first;
                        curConso += Freq[j].second;
                        if(curVow == curConso) cnt++;
                    }
                }
                return cnt;
            }
        // Optimized: ❌Pending

    1403) 2D Difference Array:
        Problem Statement:
            You are given a 2D integer matrix mat[][] of size n × m and a list of q operations opr[][]. 
            Each operation is represented as an array [v, r1, c1, r2, c2], where:
                v is the value to be added
                (r1, c1) is the top-left cell of a submatrix
                (r2, c2) is the bottom-right cell of the submatrix (inclusive)
            For each of the q operations, add v to every element in the submatrix from (r1, c1) to (r2, c2). 
            Return the final matrix after applying all operations.
            Examples:
            Input: mat[][] = [[1, 2, 3],  opr[][] = [[2, 0, 0, 1, 1], [-1, 1, 0, 2, 2]]
                            [1, 1, 0],
                            [4,-2, 2]]
            Output: [[3, 4, 3],
                    [2, 2, -1],
                    [3, -3, 1]] 
            Explanation:
            Constraint:
                1 ≤ n×m, q ≤ 10^5
                0 ≤ r1 ≤ r2 ≤ n - 1
                0 ≤ c1 ≤ c2 ≤ m - 1
                -10^4 ≤ mat[i][j], v ≤ 10^4
        // Not Optimized: TC: O(n * R * C) & SC: O(1):
            vector<vector<int>> applyDiff2D(vector<vector<int>>& mat, vector<vector<int>>& opr) {
                for(auto q: opr){
                    for(int r=q[1]; r<=q[3]; r++){
                        for(int c=q[2]; c<=q[4]; c++){
                            mat[r][c] += q[0];
                        }
                    }
                }
                return mat;
            }
        // Optimized: ❌Pending

    1404) Maximum sum Rectangle:
        Problem Statement:
            Given a 2D matrix mat[][] with dimensions n×m. Find the maximum possible sum of any submatrix within the given matrix.
            Examples:
            Input: mat[][] = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]
            Output: 29
            Explanation: The matrix is as follows and the green rectangle denotes the maximum sum rectangle which is equal to 29.
            Input: mat[][] = [[-1, -2], [-3, -4]]
            Output: -1
            Explanation: Taking only the first cell is the optimal choice.
            Constraints:
                1 ≤ n, m ≤ 300
                -1000 ≤ mat[i][j] ≤ 1000
        // Not Optimized: TC: O(n³ * m²) & SC: O(1)
            int curSubMatrixSum(int sr, int sc, int er, int ec, vector<vector<int>> &mat){
                int s = 0;
                for(int i=sr; i<=er; i++)
                    for(int j=sc; j<=ec; j++)
                        s += mat[i][j];
                return s;
            }
            int maxRectSum(vector<vector<int>> &mat) {
                int mx = INT_MIN, n = mat.size(), m = mat[0].size();
                for(int i=0; i<n; i++){
                    for(int j=0; j<m; j++){
                        // start row = sr, start col = sc, end row = er, end col = ec;
                        int sr, sc, er, ec; 
                        sr = er = i, sc = ec = j;
                        while(er < n){
                            mx = max(mx, curSubMatrixSum(sr, sc, er, ec, mat));
                            ec++;
                            if(ec == m){
                                er++;
                                ec = j;
                            }
                        }
                    }
                }
                return mx;
            }
        // Optimized: ❌Pending

    1405) Palindrome Sentence:
        Problem Statement:
            Given a single string s, the task is to check if it is a palindrome sentence or not.
            A palindrome sentence is a sequence of characters, such as word, phrase, or series of symbols that reads the same backward as forward after converting all uppercase letters to lowercase and removing all non-alphanumeric characters (including spaces and punctuation).
            Examples:
            Input: s = "Too hot to hoot"
            Output: true
            Explanation: If we remove all non-alphanumeric characters and convert all uppercase letters to lowercase, string s will become "toohottohoot" which is a palindrome.
            Input: s = "Abc 012..## 10cbA"
            Output: true
            Explanation: If we remove all non-alphanumeric characters and convert all uppercase letters to lowercase, string s will become "abc01210cba" which is a palindrome.
            Input: s = "ABC $. def01ASDF"
            Output: false
            Explanation: The processed string becomes "abcdef01asdf", which is not a palindrome.
            Constraints:
                1 ≤ s.length() ≤ 10^6
        // TC: O(n) & SC: O(1)
            bool isPalinSent(string &s) {
                int i=0, j = s.size()-1;
                while(i < j){
                    if(isalnum(s[i])){
                        if(isalnum(s[j])){
                            if((isdigit(s[i]) and isdigit(s[j]) and s[i] == s[j]) or 
                                isalpha(s[i]) and isalpha(s[j]) and toupper(s[i]) == toupper(s[j])){
                                i++, j--;
                            } else {
                                return 0;
                            }
                        } else {
                            j--;
                        }
                    } else {
                        i++;
                    }
                }
                return 1;
            }

    1406) Shop in Candy Store:
        Problem Statement:
            In a candy store, there are different types of candies available and prices[i] represent the price of  ith types of candies. You are now provided with an attractive offer.
            For every candy you buy from the store, you can get up to k other different candies for free. Find the minimum and maximum amount of money needed to buy all the candies.
            Note: In both cases, you must take the maximum number of free candies possible during each purchase.
            Examples:
            Input: prices[] = [3, 2, 1, 4], k = 2
            Output: [3, 7]
            Explanation: As according to the offer if you buy one candy you can take at most k more for free. So in the first case, you buy the candy worth 1 and takes candies worth 3 and 4 for free, also you need to buy candy worth 2. So min cost: 1+2 = 3. In the second case, you can buy the candy worth 4 and takes candies worth 1 and 2 for free, also you need to buy candy worth 3. So max cost: 3+4 = 7.
            Input: prices[] = [3, 2, 1, 4, 5], k = 4
            Output: [1, 5]
            Explanation: For minimimum cost buy the candy with the cost 1 and get all the other candies for free. For maximum cost buy the candy with the cost 5 and get all other candies for free.
            Constraints:
                1 ≤ prices.size() ≤ 10^5
                0 ≤ k ≤ prices.size()
                1 ≤ prices[i] ≤ 10^4
        // TC: O(N LOG N) & SC: O(1)
            vector<int> minMaxCandy(vector<int>& prices, int k) {
                sort(prices.begin(), prices.end());
                int minValue, maxValue, n = prices.size();
                minValue = maxValue = 0;
                int i, j=n;
                for(i=0; i<j; i++, j-=k)
                    minValue += prices[i];
                    
                j = -1;
                for(i=n-1; i>j;  j+=k, i--)
                    maxValue += prices[i];
                
                return {minValue, maxValue};
            }

    1407) Form the Largest Number: (Refer POTD: 493)
        Problem Statement:
            Given an array of integers arr[] representing non-negative integers, arrange them so that after concatenating all of them in order, it results in the largest possible number. Since the result may be very large, return it as a string.
            Examples:
            Input: arr[] = [3, 30, 34, 5, 9]
            Output: 9534330
            Explanation: Given numbers are [3, 30, 34, 5, 9], the arrangement [9, 5, 34, 3, 30] gives the largest value.
            Input: arr[] = [54, 546, 548, 60]
            Output: 6054854654
            Explanation: Given numbers are [54, 546, 548, 60], the arrangement [60, 548, 546, 54] gives the largest value.
            Input: arr[] = [3, 4, 6, 5, 9]
            Output: 96543
            Explanation: Given numbers are [3, 4, 6, 5, 9], the arrangement [9, 6, 5, 4, 3] gives the largest value.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                0 ≤ arr[i] ≤ 10^5
        // TC: O(n log n) & SC: O(n):
            string findLargest(vector<int> &arr) {
                if(arr.empty()) return "";
                vector<string> store;
                for(int i: arr)
                    store.push_back(to_string(i));
                sort(store.begin(), store.end(), [](string &a, string &b){
                    return (a+b > b+a) ? 1 : 0;
                });
                string s;
                for(string cur: store)
                    s += cur;
                // leading zeros
                // even if leading is zero then rest also will be zero, so
                if(s[0] == '0')
                    return "0";
                // int i=0, n = s.size();
                // while(i < n-1 and s[i] == '0'){
                //     i++;
                // }
                // s = s.substr(i);
                // if(s.empty()) return "0";
                return s;
            }

    1408) Sort by Absolute Difference:
        Problem Statement:
            You are given a number x and array arr[]. Your task is to rearrange the elements of the array according to the absolute difference with x, i.e., an element having minimum difference comes first, and so on.
            Note: If two or more elements are at equal distances arrange them in the same sequence as in the given array.
            Examples:
            Input: x = 7, arr[] = [10, 5, 3, 9, 2]
            Output: [5, 9, 10, 3, 2]
            Explanation: Sorting the numbers according to the absolute difference with 7, we have array elements as 5, 9, 10, 3, 2.
            Input: x = 6, arr[] = [1, 2, 3, 4, 5]
            Output: [5, 4, 3, 2, 1]
            Explanation: Sorting the numbers according to the absolute difference with 6, we have array elements as 5, 4, 3, 2, 1.
            Constraints:
                1 ≤ x ≤ 10^5
                1 ≤ arr.size() ≤ 10^5
                1 ≤ arr[i] ≤ 10^5
        // Strange: TC: O(n log n)
            void rearrange(vector<int> &arr, int x) {
                // <value after - x, actual arr value>
                vector<pair<int, int>> hold;
                for(int i: arr)
                    hold.push_back({abs(x-i), i});
                
                sort(hold.begin(), hold.end(), [](pair<int, int> &a, pair<int, int> &b){
                    return a.first < b.first;
                });
                int n = arr.size();
                for(int i=0; i<n; i++)
                    arr[i] = hold[i].second;
            }
        // Using Stable sort TC: O(n log n) & SC: O(1): it will preserve the order of element if they are same
            void rearrange(vector<int> &arr, int x) {
                stable_sort(arr.begin(), arr.end(), [x](int a, int b){
                    return abs(a - x) < abs(b - x);
                });
            }

    1409) Farthest Smaller Right:
        Problem Statement:
            You are given an array arr[]. For each element at index i (0-based indexing), find the farthest index j to the right (i.e., j > i) such that arr[j] < arr[i]. If no such index exists for a given position, return -1 for that index. Return the resulting array of answers.
            Examples:
            Input: arr[] = [2, 5, 1, 3, 2]
            Output: [2, 4, -1, 4, -1]
            Explanation: arr[0] = 2: Farthest smaller element to the right is arr[2] = 1.
            arr[1] = 5: Farthest smaller element to the right is arr[4] = 2.
            arr[2] = 1: No smaller element to the right → -1.
            arr[3] = 3: Farthest smaller element to the right is arr[4] = 2.
            arr[4] = 2: No elements to the right → -1.
            Input: arr[] = [2, 3, 5, 4, 1] 
            Output: [4, 4, 4, 4, -1]
            Explanation: arr[4] is the farthest smallest element to the right for arr[0], arr[1], arr[2] and arr[3].
            Constraints:
                1 ≤ arr.size() ≤ 10^6
                1 ≤ arr[i] ≤ 10^6
        // Not Optimized: TC: O(n²) & SC: O(1)
            vector<int> farMin(vector<int>& arr) {
                int n = arr.size();
                if(!n) return {};
                vector<int> ans (n, -1);
                for(int i=0; i<n; i++){
                    int index = -1;
                    for(int j=i+1; j<n; j++){
                        if(arr[i] > arr[j]) index = j;
                    }
                    ans[i] = index;
                }
                return ans;
            }
        // Optimized: TC: O(n log n) & SC: O(n):
            vector<int> farMin(vector<int>& arr) {
                int n = arr.size();
                if(!n) return {};
                vector<int> ans (n, -1);
                for(int i=0; i<n; i++){
                    for(int j=n-1; j>i; j--){
                        if(arr[i] > arr[j]){
                            ans[i] = j;
                            break;
                        }
                    }
                }
                return ans;
            }

    1410) Search in fully rotated sorted 2D matrix:
        Problem Statement:
            You are given a 2D matrix mat[][] of size n x m that was initially filled in the following manner:
            Each row is sorted in increasing order from left to right.
            The first element of every row is greater than the last element of the previous row.
            This implies that if the matrix is flattened row-wise, it forms a strictly sorted 1D array.
            Later, this sorted 1D array was rotated at some unknown pivot. The rotated array was then written back into the matrix row-wise to form the current matrix.
            Given such a matrix mat[][] and an integer x, determine whether x exists in the matrix.
            Examples:
            Input: x = 3,
            mat[][] = [[7, 8, 9, 10],
                    [11, 12, 13, 1],
                    [2, 3, 4, 5]] 
            Output: true
            Explanation: 3 is located at the 3rd row and 2nd column.
            Input: x = 10,
            mat[][] = [[6, 7, 8],
                    [9, 1, 2],
                    [3, 4, 5]]
            Output: false
            Explanation: The value 10 does not exist in the matrix.
            Constraint:
                1 ≤ n × m ≤ 105
                1 ≤ mat[i][j], x ≤ 106
        // Not Optimized: TC: O(n * m) & SC: O(1)
            bool searchMatrix(vector<vector<int>> &mat, int x) {
                int n = mat.size();
                if(!n) return 0;
                int m = mat[0].size();
                for(int i=0; i<n; i++){
                    for(int j=0; j<m; j++){
                        if(mat[i][j] == x) return 1;
                    }
                }
                return 0;
            }
        // Optimized: ❌Pending

    1411) Median in a row-wise sorted Matrix:
        Problem Statement:
            Given a row-wise sorted matrix mat[][] of size n*m, where the number of rows and columns is always odd. Return the median of the matrix.
            Examples:
            Input: mat[][] = [[1, 3, 5], 
                            [2, 6, 9], 
                            [3, 6, 9]]
            Output: 5
            Explanation: Sorting matrix elements gives us [1, 2, 3, 3, 5, 6, 6, 9, 9]. Hence, 5 is median.
            Input: mat[][] = [[2, 4, 9],
                            [3, 6, 7],
                            [4, 7, 10]]
            Output: 6
            Explanation: Sorting matrix elements gives us [2, 3, 4, 4, 6, 7, 7, 9, 10]. Hence, 6 is median.
            Input: mat = [[3], [4], [8]]
            Output: 4
            Explanation: Sorting matrix elements gives us [3, 4, 8]. Hence, 4 is median.
            Constraints:
                1 ≤ n, m ≤ 400
                1 ≤ mat[i][j] ≤ 2000
        // Not Optimized: TC: O(x + x log x), SC: O(x), where x = n*m
            int median(vector<vector<int>> &mat) {
                vector<int> v;
                for(auto itr: mat)
                    for(int i: itr)
                        v.push_back(i);
                sort(v.begin(), v.end());
                return v[v.size()/2];
            }
        // Optimized: Using priority_queue: TC: (n*m*log(n)) & SC: O(n)
            int median(vector<vector<int>> &mat) {
                // <current element of mat, rowIndex, colIndex>
                priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHP;
                int n=mat.size(), m = mat[0].size();
                for(int i=0; i<n; i++)
                    minHP.push({mat[i][0], i, 0});
                
                int mid = (n * m) / 2;
                int cnt = 0, res=0;
                while(cnt <= mid){
                    vector<int> v = minHP.top();
                    minHP.pop();
                    
                    int val = v[0], row = v[1], col = v[2];
                    res = val;
                    cnt++;
                    
                    if(col + 1 < m)
                        minHP.push({mat[row][col+1], row, col+1});
                }
                return res;
            }
        // Optimized: ❌Pending

    1412) Maximize the minimum difference between k elements:
        Problem Statement:
            Given an array arr[] of integers and an integer k, select k elements from the array such that the minimum absolute difference between any two of the selected elements is maximized. Return this maximum possible minimum difference.
            Examples:
            Input: arr[] = [2, 6, 2, 5], k = 3
            Output: 1
            Explanation: 3 elements out of 4 elements are to be selected with a minimum difference as large as possible. Selecting 2, 2, 5 will result in minimum difference as 0. Selecting 2, 5, 6 will result in minimum difference as 6 - 5 = 1.
            Input: arr[] = [1, 4, 9, 0, 2, 13, 3], k = 4
            Output: 4
            Explanation: Selecting 0, 4, 9, 13 will result in minimum difference of 4, which is the largest minimum difference possible.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                0 ≤ arr[i] ≤ 10^6
                2 ≤ k ≤ arr.size() 
        // Not Optimized: TC: O(n * n^k * k²), SC: O()
            void RetriveAns(vector<int>& arr, int &ans, int k, vector<int>& temp, int i){
                int n = arr.size();
                if(k == 0){
                    int v = INT_MAX, t2 = temp.size();
                    for(int j=0; j<t2-1; j++){
                        for(int z=j+1; z<t2; z++){
                            v = min(v, abs(temp[j] - temp[z]));
                        }
                    }
                    ans = max(ans, v);
                    return ;
                }
                
                for(int z=i; z<n; z++){
                    temp.push_back(arr[z]);
                    RetriveAns(arr, ans, k-1, temp, z);
                    temp.pop_back();
                }
            }
            int maxMinDiff(vector<int>& arr, int k) {
                int ans=0, n = arr.size();
                vector<int> temp;
                for(int i=0; i<=n-k; i++){
                    if(i == n-k){
                        int v = INT_MAX;
                        for(int j=i; j<n-1; j++){
                            for(int z=j+1; z<n; z++){
                                v = min(v, abs(arr[j] - arr[z]));
                            }
                        }
                        ans = max(ans, v);
                    } else {
                        RetriveAns(arr, ans, k, temp, i);
                    }
                }
                return ans;
            }
        // Optimized: ❌Pending

    1413) Check if a String is Subsequence of Other:
        Problem Statement:
            Given two strings s1 and s2. You have to check that s1 is a subsequence of s2 or not.
            Note: A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.
            Examples:
            Input: s1 = "AXY", s2 = "YADXCP"
            Output: false
            Explanation: s1 is not a subsequence of s2 as 'Y' appears before 'A'.
            Input: s1 = "gksrek", s2 = "geeksforgeeks"
            Output: true
            Explanation: If we combine the bold character of "geeksforgeeks", it equals to s1. So s1 is a subsequence of s2. 
            Constraints:
            1 ≤ s1.size(), s2.size() ≤ 10^6
        // Not Optimized: TC: O(2ⁿ * n) & SC: O(2ⁿ * n)
            void SubSeqGen(string &s, int i, vector<string> &allSubSeq, string temp){
                if(i >= s.size()){
                    allSubSeq.push_back(temp);
                    return;
                }
                SubSeqGen(s, i+1, allSubSeq, temp);
                temp.push_back(s[i]);
                SubSeqGen(s, i+1, allSubSeq, temp);
            }
            bool isSubSeq(string& s1, string& s2) {
                vector<string> allSubSeq;
                int n = s1.size(), m = s2.size();
                if(m < n) return 0;
                SubSeqGen(s2, 0, allSubSeq, "");
                
                for(string s: allSubSeq){
                    // cout<<s<<" ";
                    if(s1 == s) return 1;
                }
                return 0;
            }
        // Optimized: TC: O(max(n, m)) or O(n+m) & SC: O(1)
            bool isSubSeq(string& s1, string& s2) {
                int i, j, n = s1.size(), m = s2.size();
                i = j = 0;
                while(i < n and j < m){
                    if(s1[i] == s2[j]) i++, j++;
                    else j++;
                }
                return (i == n) ? 1 : 0;
            }

    1414) Maximize median after doing k addition operation:
        Problem Statement:
            Given an array arr[] consisting of positive integers and an integer k. You are allowed to perform at most k operations, where in each operation, you can increment any one element of the array by 1. Determine the maximum possible median of the array that can be achieved after performing at most k such operations.
            Note: The median of an array is defined as the middle element when the array (after sorting) has an odd size, or the average of the two middle elements when the array (after sorting) has an even size.
            Examples:
            Input: arr[] = [1, 3, 4, 5], k = 3
            Output: 5
            Explanation: We can add +2 to the second element and +1 to the third element to get the array [1, 5, 5, 5]. After sorting, the array remains [1, 5, 5, 5]. Since the length is even, the median is (5 + 5) / 2 = 5.
            Input: arr[] = [1, 3, 6, 4, 2], k = 10
            Output: 7
            Explanation: After applying operations optimally, we can transform the array to [1, 3, 7, 7, 7] (one possible way). Sorted array becomes [1, 3, 7, 7, 7]. Since the length is odd, the median is the middle element 7.
            Constraints:
                1 ≤ arr.size() ≤ 10^5
                0 ≤ arr[i], k ≤ 10^9
        // Not Optimized: TC: (k * n log n) & SC: O(1)
            int maximizeMedian(vector<int>& arr, int k) {
                int n = arr.size()-1;
                sort(arr.begin(), arr.end());
                while(k--){
                    arr[n/2] = ++arr[n/2];
                    sort(arr.begin(), arr.end());
                }
                return n&1 ? (arr[n/2] + arr[n/2+1])/2 : arr[n/2];
            }
        // Optimized: TC: O(n log n + m log m + k * log m) & SC: O(m), where m = n/2
            int maximizeMedian(vector<int>& arr, int k) {
                int n = arr.size();
                if(!n) return 0;
                priority_queue<int, vector<int>, greater<int>> minHP;
                sort(arr.rbegin(), arr.rend());         // in Descending order
                
                for(int i=0; i<=(n/2); i++)
                    minHP.push(arr[i]);
                
                while(k--){
                    int val = minHP.top();
                    minHP.pop();
                    val++;
                    minHP.push(val);
                }
                
                if(!(n&1)){             // if n is even
                    int v1 = minHP.top();
                    minHP.pop();
                    int v2 = minHP.top();
                    return (v1+v2)/2;
                }
                return minHP.top();     // if n is odd;
            }

    1415) Minimum days to make M bouquets:
        Problem Statement:
            You have a row of flowers, where each flower blooms after a specific day. The array arr[] represents the blooming schedule: arr[i] is the day the flower at position i will bloom. To create a bouquet, you need to collect k adjacent bloomed flowers. Each flower can only be used in one bouquet.
            Your goal is to find the minimum number of days required to make exactly m bouquets. If it is not possible to make m bouquets with the given arrangement, return -1.
            Examples:
            Input: m = 3, k = 2, arr[] = [3, 4, 2, 7, 13, 8, 5]
            Output: 8
            Explanation: We need 3 bouquets and each bouquet should have 2 flowers. After day 8: [x, x, x, x, _, x, x], we can make first bouquet from the first 2 flowers, second bouquet from the next 2 flowers and the third bouquet from the last 2 flowers.
            Input: m = 2, k = 3, arr[] = [5, 5, 5, 5, 10, 5, 5]
            Output: 10
            Explanation: We need 2 bouquets and each bouquet should have 3 flowers, After day 5: [x, x, x, x, _, x, x], we can make one bouquet of the first three flowers that bloomed, but cannot make another bouquet. After day 10: [x, x, x, x, x, x, x], Now we can make two bouquets, taking 3 adjacent flowers in one bouquet.
            Input: m = 3, k = 2, arr[] = [1, 10, 3, 10, 2]
            Output: -1
            Explanation: As 3 bouquets each having 2 flowers are needed, that means we need 6 flowers. But there are only 5 flowers so it is impossible to get the needed bouquets therefore -1 will be returned.
            Constraints:
                1 ≤ k ≤ arr.size() ≤ 10^5
                1 ≤ m ≤ 10^5
                1 ≤ arr[i] ≤ 10^9
        // Not Optimized: TC= O(n + n * (max(arr) - min(arr)))
                            = O(n * (max(arr) - min(arr))       // ignore n+ as its so less compared to second value (n * (max(arr) - min(arr))).
                        SC= O (1)
            int minDaysBloom(vctor<int>& arr, int k, int m) {
                int minDayCnt = -1, n = arr.size();
                if(k*m > n) return minDayCnt;
                int minDayStartValue = *min_element(arr.begin(), arr.end());
                while(1){
                    int bouquetCnt=0, adjacent=0;
                    for(int i=0; i<n; i++){
                        if(arr[i] <= minDayStartValue){
                            adjacent++;
                            if(adjacent == k){
                                bouquetCnt++;
                                adjacent=0;
                                if(bouquetCnt == m) return minDayStartValue;
                            }
                        } else {
                            adjacent=0;
                        }
                    }
                    bouquetCnt=0;
                    minDayStartValue++;
                }
                return -1;
            }
        // Optimized: Using Binary Search:  TC = O (n + n + n * log (max-min)), where min & max are smallest & largest values in array
                                            = O (n * log (max-min))
                                            SC: O (1)
            bool CanCover(vector<int> &a, int day, int expectedBouquetCnt, int minAdjacentBloomedFlower){
                int currentBouquetCnt, currentBloomedFlower;
                currentBloomedFlower = currentBouquetCnt = 0;
                for(int i: a){
                    if(i <= day) {
                        currentBloomedFlower++;
                        if(currentBloomedFlower == minAdjacentBloomedFlower){
                            currentBouquetCnt++;
                            currentBloomedFlower=0;
                        } 
                        if(currentBouquetCnt == expectedBouquetCnt) break;
                    } else {
                        currentBloomedFlower = 0;
                    }
                }
                return (expectedBouquetCnt == currentBouquetCnt);
            }
            int minDaysBloom(vector<int>& arr, int k, int m) {
                int minDayCnt = -1, n = arr.size();
                if(k*m > n) return minDayCnt;
                int low = *min_element(arr.begin(), arr.end());
                int high = *max_element(arr.begin(), arr.end());
                while(low <= high){
                    int mid = (low + high) / 2;
                    if(CanCover(arr, mid, m, k)){
                        high = mid - 1;
                    } else {
                        low = mid + 1;
                    }
                }
                return low;
            }

    1416) Allocate Minimum Pages:
        Problem Statement:
            Given an array arr[] of integers, where each element arr[i] represents the number of pages in the i-th book. You also have an integer k representing the number of students. The task is to allocate books to each student such that:
            Each student receives atleast one book.
            Each student is assigned a contiguous sequence of books.
            No book is assigned to more than one student.
            The objective is to minimize the maximum number of pages assigned to any student. In other words, out of all possible allocations, find the arrangement where the student who receives the most pages still has the smallest possible maximum.
            Note: If it is not possible to allocate books to all students, return -1.
            Examples:
            Input: arr[] = [12, 34, 67, 90], k = 2
            Output: 113
            Explanation: Allocation can be done in following ways:
            => [12] and [34, 67, 90] Maximum Pages = 191
            => [12, 34] and [67, 90] Maximum Pages = 157
            => [12, 34, 67] and [90] Maximum Pages = 113.
            The third combination has the minimum pages assigned to a student which is 113.
            Input: arr[] = [15, 17, 20], k = 5
            Output: -1
            Explanation: Since there are more students than total books, it's impossible to allocate a book to each student.
            Constraints:
                1 ≤ arr.size() ≤ 10^6
                1 ≤ arr[i], k ≤ 10^3
        // Not Optimized TC: O(n * (sum(arr) - max(arr))) & SC: O(1)
            bool CanWeAllocate(vector<int> &a, int &v, int &k){
                int sum=0;
                int PersonCnt=1;
                
                for(int i: a){
                    if(sum + i > v){
                        sum=i;
                        PersonCnt++;
                    } else {
                        sum += i;
                    }
                }
                return (PersonCnt <= k) ? 1 : 0;
            }
            int findPages(vector<int> &arr, int k) {
                if(k > arr.size()) return -1;
                int low = *max_element(arr.begin(), arr.end());
                int high = accumulate(arr.begin(), arr.end(), 0);
                
                for(int i=low; i<=high; i++)
                    if(CanWeAllocate(arr, i, k)) return i;
                return 0;       // will never reach here.
            }
        // Optimized:  Using Binary Search: TC: O(n * log(sum(arr) - max(arr))) & SC: O()
            bool CanWeAllocate(vector<int> &a, int &v, int &k){
                int sum=0;
                int PersonCnt=1;
                
                for(int i: a){
                    if(sum + i > v){
                        sum=i;
                        PersonCnt++;
                        if(PersonCnt > k) return 0;
                    } else {
                        sum += i;
                    }
                }
                return 1;
            }
            int findPages(vector<int> &arr, int k) {
                if(k > arr.size()) return -1;
                int low = *max_element(arr.begin(), arr.end());
                int high = accumulate(arr.begin(), arr.end(), 0);
                
                while(low <= high){
                    int mid = (low + high) / 2;
                    if(CanWeAllocate(arr, mid, k)){
                        high = mid - 1;
                    } else {
                        low = mid + 1;
                    }
                }
                return low;
            }

1417)
1418)
1419)
1420)

    
