-When you start reading/ revising notes, read problem statement properly & think logical,
 if you don't understand the program, Google the question.
-VISIT ALL ❌Pending THINGS ONCE YOU COMPLETE WHOLE PLAYLIST.
-If you don't understand the codes, observe it clearly, try to visualize/ imagine the things, how they are working.
-----------------------------------------------------------------------------------------------------------
	01/08/2023
Lecture-1: Intro to Programming & Flowcharts
     -Understand the problem
     -check given data
     -search approach (make flowchart)
     -start programming

     -Flowchart:
          Diagrammatic representation of an approach
          Components:
               1.Terminator: start/end
               2.Parallelogram block   : represent IO/OP 
               3.Rectangular block: represent process
               4.Diamond: decision making (condition)
          e.g., Sum of 2 num:
	-Pseudocode:	Generic way of representing look of code.
	-Flowchart for Simple Interest
		SI = (P*R*T)/100
		eg.
			Calculate Simple Interest
				#include <bits/stdc++.h> 
				#include <iostream>
				using namespace std;

				int main(){
					float pr,time, RI;
					cin>>pr>>RI>>time;
					float ans;
					ans =(int) (pr*time*RI)/100;
					cout<<ans;
					return 0;
				}

	-Two colons (::) are used in C++ as a scope resolution operator

	-Flowchart for average of 3 num
		avg = (a+b+c)/3;

	-Greater between 2 num:
		a>b? print(a greater) : print(b greater);

		//Largest of 3 numbers
			#include <bits/stdc++.h> 
			#include <iostream>
			using namespace std;

			int main() {
				int a,b,c;
				cin>>a>>b>>c;
				cout<<max(a,max(b,c));
				return 0;
			}

	-Odd or even num:
		(num %2 ==0) ? print(even):print(odd)

	-num is +ve or -ve or zero?
		If(num >0) print(+ve)
		else if (num<0) print(-ve)
		else print(zero)
		
	-Valid triangle or not?
		Angles A, B & C
		A+B > C
		B+C > A
		C+A > B

	-Loops:
		-Print 1 to 5 nums.
			#include<bits/stdc++.h>
			using namespace std;

			int main(){
		
				int i{};	
				for(;i<=5;)
					std::cout << i++ << "\t";
				
				int a {5};
				std::cout << std::endl;
				for(;a<=17;)
					std::cout << a++ << "\t";
				
				return 0;
			}	

		-print even nums from given range (copy paste program directly on compiler to check)

			#include <iostream>
			using namespace std;
			int main() {
				// Write C++ code here
				cout << "Range..!"<<"\n";
				int s=1,e=10,i;
				for(i=s; i<=e; i++){	
					cout<<i<<"\t";
				}
				cout<<"\neven nums.."<<"\n";
				for(i=s;i<e;i++){
					if(i%2==0){
						cout<<i<<endl;
					}else{
						continue;
					}
				}
				cout<<"\nend";
				return 0;
			}

		-Sum of 1 to N nums:
			#include <iostream>
			using namespace std;

			int main() {
				// Write C++ code here
				cout<<"Enter n::";
				int n;
				cin>>n;
				int sum = 0;
				
				// sum = n*(n+1)/2;
				//or
				for(int i=1;i<=n;i++){
					sum = sum +i;
				}
				cout<<"The sum of first "<<n<<" numbers ::"<<sum;
				cout<<"\nend";

				return 0;
			}

		-Factorial:
			#include <iostream>			//using namespace std not used here.
			int main() {
				std::cout<<"Enter n::";
				int n,fact=1;
				std::cin>>n;
				
				for(int i=1;i<=n;i++){
					fact = fact * i;
				}
				std::cout<<"The factorial of "<<n<<" is ::"<<fact;
				std::cout<<"\nend";

				return 0;
			}

				//or
					#include <iostream>
					using namespace std;

					int main() {
						int n;
						cin>>n;
						int fact=1;
						if (n == 0) {
							cout << 1;
							return 0;
						}else if (n<0){
							cout<<"Error";
							return 0;
						}else{
							while(n>0){
								fact = fact * n;
								n--;
							}
						}

						cout<<fact;
						return 0;
					}

		-Prime num:
			#include <iostream>
			int main() {
				// Write C++ code here
				std::cout<<"Enter n to check prime or not::";
				int n;
				std::cin>>n;
				bool flag = true;
				
				if(n == 1){
					std::cout<<"1 is neither prime nor composite";
					return 0;
				}
				
				for(int i=2;i<n;i++){
					if(n % i ==0){
						flag = false;
						break;
					}else{
						flag = true;
					}
				}
				
				if(flag){
					std::cout<<n<<" is Prime num.";
				}else{
					std::cout<<n<<" is not Prime num.";
				}
				
				std::cout<<"\nend";
				return 0;
			}
		
	-Compiler: convert High Level Language to Binary Language (machine understandable)
---------------------------------------------------------------------------------------------------------
	02/08/2023
Lecture-2: Write Your First Program in C++
	Compiler:
		-convert program to machine understandable Language ( Binary ).
		-checks the error & let you know.
	
	IDE: Integrated Development Environment
	
	-Program always start from main function.
	eg.
		#include <iostream>
		int main() {
			std::cout << "Hello world!"<<endl;
			return 0;
		}

		//if you used this statement no need to mention std in program
		using namespace std;
		#include <iostream>
		int main() {
			cout << "Hello world!";
			return 0;
		}

		where,
			std 			- is a namespace.
			cout 		- is function for printing
			<< 			- is outputing a output.
			endl  or '\n' 	- end line/ new line.
			; 			- represent end line.

	-Datatype & Variables:
		1 Byte is 8 bit.
		4bit is 1 nibble.
		int-
			size is 4 byte(32bit) generally (sometimes 2 bytes also, depends on compiler).
			Stores whole numbers, without decimals
			eg.
				int a = 20;

			min size -2³¹
			max size 2³¹-1
		
		char-
			size is 1 byte
			Stores a single character/letter/number, or ASCII values
			eg.
				char ch = 'a';		//valid

				char ch = 'ab';	//invalid
			
			Alternatively, you can use ASCII values to display certain characters:
			eg.
				char a = 65, b = 66, c = 67;
				cout << a;		//A
				cout << b;		//B
				cout << c;		//C

			-ASCII values:	ASCII - 'American Standard Code for Information Interchange'
				32 		is value of space.
				48 to 57 	is for 	0 to 9.
				65 to 90 	is for 	A to Z.
				97 to 122 is for 	a to z.

		boolean-
			1 byte	
			Stores true or false values
			you can keep any value for this boolean if it is non-zero(+ve) or -ve  then its considered as true (1).
				if it is zero then its considered as false(0).
			eg.
				bool a = true;

				bool b = 1,c =true, d = false;
				cout <<b<<endl;         //1
				cout <<c<<endl;         //1
				cout <<d<<endl;         //0
	
		float-
			4 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 6-7 decimal digits.
			eg.
				float f1 = 35e3;
				double d1 = 12E4;

				float ff = 35.453f;				//f to represent its is a floating point num.
				
				float f2 = 35e30;
				double d2 = 12E84;
				
				cout << f2 << "\n";
				cout << d2 << endl;
				
				double dd = 12.78909d;			//d to represent its is a double
				cout << f1 << "\n";				// 35000
				cout << d1;					// 120000
		
		double-
			8 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits.
		
		NOTE:
			float vs. double
			The precision of a floating point value indicates how many digits the value can have after the decimal point. 
			The precision of float is only six or seven decimal digits, while double variables have a precision of about 15 digits. 
			Therefore it is safer to use double for most calculations.
		
		string-
			32 byte.
			string type is used to store a sequence of characters (text).
			This is not a built-in type, but it behaves like one in its most basic usage. 
			String values must be surrounded by double quotes:
			eg.
				#include <string>				//including this header file is not mandatory.
				string str  = "Vivek";
				cout << str;
			
			-Different ways to initialize string in cpp:
				   char str1[10] = "Freshers";

				#include <iostream>
				using namespace std;

				int main() {
					char str1[10] = "Freshers";
					std::cout << str1 << std::endl;
					
					char str2[6] = "Geeks";
					std::cout << str2 << std::endl;
					
					char str3[] = {'G', 'e', 'e', 'k', 's', '\0'};
					std::cout << str3 << std::endl;
					
					char str4[6] = {'G', 'e', 'e', 'k', 's', '\0'};
					std::cout << str4 << std::endl;
					
					
					string str5 = "Welcome to GeeksforGeeks!"; 
					std::cout << str5 << std::endl;
					
					// Initialization by raw string 
					string str6("A Computer Science Portal"); 
					std::cout << str6 << std::endl;
					
					//char to to string
					char ch = 'Z';
					std::cout << ch << std::endl;
					
					ch='A';
					string temp = str6 + ch;
					std::cout << temp << std::endl;
					
					ch++;
					temp = ch+str6;
					std::cout << temp << std::endl;
					
					std::cout << string(5,ch) << std::endl;
					
					std::cout << str5.front() << std::endl;
					std::cout << str5.back() << std::endl;
					return 0;
				}

				//or

					#include <iostream>
					using namespace std;

					int main() {
						string s1("qwerqty");
						string s2 ("asdf");
						string s3 = "vivek";
						string s4 = {"one two"};
						
						std::cout << s1 << std::endl;       //qwerqty
						std::cout << s2 << std::endl;       //asdf
						std::cout << s3 << std::endl;       //vivek
						std::cout << s4 << std::endl;       //one two
						return 0;
					}

		Variable Naming Convention:
			int abc1 = 1;			// valid
			int _abc = 21;			// valid
			int $abc = 22;			// valid
			int #abc = 22;			// invalid
			int @abc = 22;			// invalid
			int a abc = 22;		// invalid variable name can't contain whitespace
			int 1abc = -10; 		// invalid because the first character must be letter/underscore or $ (dollar) should not be number.

		sizeof:
			eg.
				#include <iostream>

				int main() {
					bool c  = -12;
					int i   = 10;
					char ch = 'A';
					float f =  11.12; 
					double d   = 12.1245d;
					std::string str = "Vivek ";
					
					std::cout<<"The size of "<<c<<" Boolean :: "<<sizeof(c)<<" Byte\n";
					std::cout<<"The size of "<<i<<" integer :: "<<sizeof(i)<<" Byte\n";
					std::cout<<"The size of "<<ch<<" char :: "<<sizeof(ch)<<" Byte\n";
					std::cout<<"The size of "<<f<<" float :: "<<sizeof(f)<<" Byte\n";
					std::cout<<"The size of "<<d<<" double :: "<<sizeof(d)<<" Byte\n";
					std::cout<<"The size of "<<str<<" string :: "<<sizeof(str)<<" Byte\n";
					
					return 0;
				}

				//output
					The size of 1 Boolean :: 1 Byte
					The size of 10 integer :: 4 Byte
					The size of A char :: 1 Byte
					The size of 11.12 float :: 4 Byte
					The size of 12.1245 double :: 8 Byte
					The size of Vivek  string :: 32 Byte

		storing process:
			int is 4 bytes ie. 32 bits.
				4 blocks of bits are made
				eg.
					[-------- -------- -------- --------] this how integer converted to binary & store data in bits format.

		TypeCasting:
			when you assign a value of one primitive data type to another type.
			eg.
				int a = 'a';
				cout<<a;

				char ch = 98;
				cout<<ch;

				-int is 4 byte & char is 1 byte, if we try to store big integer to char
				 warning will be thrown & last 1 byte of data will be store in char.
				 eg.
				 	char ch = 123456		//binary of 123456 = 11110001001000000
					cout<< ch;			//@

					but char is of size 1 byte ie. 8 bits, so last 8 bit of binary 123456 will extracted ie.01000000 
						& rest all bits will be lost
					& if we print the ch then output will be @.
					coz this binary 01000000 is 64 in decimal.
					& 64 is mapped with @ char.
			
			eg.
				#Converting strings to numerical types
					C++ provides several functions for converting strings to numerical types, 
					each with different ranges and precision. Here are some commonly used ones:

						std::stoi (String to Integer):
							Converts a string to an int.
							Usage: int result = std::stoi(str);

						std::stol (String to Long):
							Converts a string to a long.
							Usage: long result = std::stol(str);

						std::stoll (String to Long Long):
							Converts a string to a long long.
							Usage: long long result = std::stoll(str);

						std::stof (String to Float):
							Converts a string to a float.
							Usage: float result = std::stof(str);

						std::stod (String to Double):
							Converts a string to a double.
							Usage: double result = std::stod(str);

						std::stold (String to Long Double):
							Converts a string to a long double.
							Usage: long double result = std::stold(str);

						These functions are part of the <string> header in C++. 
						Choose the appropriate function based on the 
						data type you need for your specific use case.

			eg.
				include <iostream>
				int main() {
					float f = 45.99f;
					int b = f;
					
					float f1 = b;
					
					std::string str = "1234";
					// int a = int(str);       // this won't work
					int a = stoi(str);       //to convert string to int
					
					std::cout<<a<<std::endl;		//1234
					std::cout<<a+6<<std::endl;	//1240
					
					std::cout<<f<<"\n";		//45.99
					std::cout<<b+2<<"\n";	//47
					std::cout<<f1<<"\n";	//45
					
					return 0;
				}

				#include <iostream>
				int main() {
					std::string str = "450";
					int a;
					std::cout<<str<<std::endl;
					std::cout<<a<<std::endl;
					std::cout<<stoi(str)+10;			//string to integer stoi().
					return 0;
				}

				//or
					string to Int
						#include <iostream>
						#include<sstream>
						using namespace std;

						int main() {
							string s = "1234";
							
							stringstream ss;        //ss obj of stringstream class
							ss<<s;          //inserting string
							
							int n;
							ss>>n;          //outputing num to n
							
							std::cout <<n*2<< std::endl;        //2468
							return 0;
						}

		How -ve num stored:
			if first bit is 1, then num is -ve.
			if first bit is 0, then num is +ve.
			eg.
				want to store -8.
				step 1:	
					ignore negative sing(-ve)
					8
				step 2:
					convert 8 to binary format
					1000
					stored as
						[-------- -------- -------- ----1000] rest all are zero only like below,
						[00000000 00000000 00000000 00001000]

				step 3:
					-Take 2's (two's) complement & store.
					 for taking 2's complement first take 1's complement
					 
					 step 1: 
					 	1's complement change 0 to 1 & viceversa.
						[11111111 11111111 11111111 11110111]

					 step 2:
					 	add 1 in 1's complement.
						[11111111 11111111 11111111 11110111]
						+							1
						______________________________________
						[11111111 11111111 11111111 11111000]		
							--here in the answer first bit is 1, so it denotes its -ve num.
							--this is 2s complement of 8
				
				step 4:
					-To print that -ve num then take 2's complement of above output:
						[11111111 11111111 11111111 11111000]		
					
					-1's complement
						[00000000 00000000 00000000 00000111]
						+							1
						_____________________________________
						[00000000 00000000 00000000 00001000]
					
					now print above as its 8, but -ve.

		For +ve num only:
			unsigned int a = 122;
			range:
				0 to 2³²-1;

			if you try to store -ve num then it will generate huge num becoz 
			of most significant bit (first bit) is 1 to represent it is a -ve but,
			you said its +ve by mentioning usigned so compiler treat it as positive & generates huge num.
		
		Operator:
			Unary:
				increment (++)
				decrement (--)
				eg.
					postIncrement/postDecrement means the value will get incremented or decremented after using.
					old value gets used then value gets updated
						a++;		//postIncrement
						a--;		//postDecrement
					
					
					preIncrement/ preDecrement means the value will get incremented or decremented before using.
					value gets incresed or decresed first then it will gets used.
						++a;		//pretIncrement
						--a;		//pretDecrement
					
			Arithmetic:-
				+,-,*,/,%

				int/ int  = int		//if we divide int by int the answer will be integer
				float / int = float		//if we divide float by int the answer will be floating point num.
				double / int = double		//if we divide double by int the answer will be double.

				eg.
					#include <iostream>
					#include<cmath>
					using namespace std;
					int main(){
						int n=60, sum =101;
						
						double d = sum/(double)n;			//getting value in double.		
						std::cout << d << std::endl;					//1.68333
						std::cout << round(d) << std::endl;			//2
						
						return 0;
					}

			Relational:- 
				To Check
				== is equal to equal to (double equals to)
				< is less than
				> is greater than
				<= is less than equal to
				>= is greater than equal to
				!= is not equal to
			
			Assignment operator:
				=, +=, *=, -=, /=, %= etc
				eg.
					a = 10;
					a = a + 10;		-->		a += 10;
					a = a * 10;		-->		a *= 10;
					a = a - 10;		-->		a -= 10;
					a = a / 10;		-->		a /= 10;
					a = a % 10;		-->		a %= 10;

			Logical:-
				&& AND operation takes two boolean values and returns True if both are True else False.
				|| OR any one conditions should true for that statement to execute.
				! NOT reverse value.
				eg.
					ignores the sign.
					int a = 0;
						std::cout << !a;		//1
					int b = 1;
						std::cout << !b;		//0
					int c = 10;
						std::cout << !c;		//0
					int d = -10;
						std::cout << !d;		//0
					int e = -0;
						std::cout << !e;		//1

				eg.
					#include <iostream>
					using namespace std;

					int main() {
						int x = -5;
						int y = -10;

						// ||- or
						if (x > 0 or y > 0) {
							std::cout << "Both x and y are greater than 0." << std::endl;
						}else{
							std::cout << "nothing" << std::endl;
						}
						
						x=90,y=88;
						// Logical AND using 'and'
						if (x > 0 and y > 0) {
							std::cout << "Both x and y are greater than 0." << std::endl;
						}else{
							std::cout << "nothing" << std::endl;
						}   
						return 0;
					}

			Ternary Operator:
				syntax:
					(condition) ? ([if true execute this]) : ([if false execute this])
				eg.
					#include <iostream>
					using namespace std;

					int main() {
						int a = 100;
						
						//ternary operator
						(a>20) ? cout<< a << " Greater Than 20" : cout<< a << "Less than 20";

						return 0;
					}
				
				-for single statement don't use ( ) in ternary operator direct mention your statement.
				-for multiple statement to print or do operation use ( ).
				eg.
					printing twice,
						#include <iostream>
						using namespace std;

						int main()
						{
							int n =91;
							(n % 2 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or above there is just one condition so no need to use braces near condition also, like
							n % 2 == 0 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//if more than one condition is there in ternary operator, use braces ( ), for best practices
							//if you don't use still it works

							//first even condition is true but 2nd 400 is not less than 50, its false 
							//but && requires both condition must be true so complete equation is false,
							//output odd world.
							n =400;
							(n % 2==0 && n< 50 == 1) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							

							//output for below is even n<50 which is false means 0, & 0 == 0 so n= 400 is even & 0 == 0 both condition are true so even world will printed.
							(n % 2==0 && n< 50 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or even world will run
							//first condition is true, 2nd is false
							n=400;
							(n % 2==0 || n< 50) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
  
							//without braces
							//works fine and (,) comma is behaves like && operator,
							n % 2==0 && n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							n % 2==0 , n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							return 0;
						}

					initializing int inside ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							//syntax to initialize,
							(condition)? ([] {//initialization,//statement, //code})(): ([] {//initialization,//statement, //code})()

							//integer initialized
							n % 2 == 0 && n < 50 ? ([]{ int v = 80; cout << "Hello Even World " << v << " Hello 2nd World "; })() : ([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							//string initialized
							n%2 ? ([]{ string v = "Vivek"; cout << "Hello Even World " << v << " Hello 2nd World ";})() :([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							return 0;
						}

					ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							n % 2 == 0 && n < 50 ? ([]{
								int v = 80;
								string evenMessage = "Hello Even World " + to_string(v);
								string secondMessage = "Hello 2nd World";
								cout << evenMessage << " " << secondMessage;
							})() : ([]{
								string oddMessage = "Hello Odd World";
								string thirdMessage = "Hello 3rd World";
								cout << oddMessage << " " << thirdMessage;
							})();

							return 0;
						}

					string ternary:
						#include <iostream>
						using namespace std;

						int main()
						{
							string finalgrade = []() {
								int grade = 100;
								return (grade < 60) ? "fail" : "pass";
							}();

							std::cout << finalgrade << std::endl;

							return 0;
						}

			Bitwise:-
				& and
				| or
				^ xor
				~ complement of bits in binary representation
				<< left shift
				>> right shift
			
			//Converting num to string & counting digit in it.
				#include <iostream>
				using namespace std;
				int main(){
					int i=1234,j=12,k=9686854;
					cout<<"no.of digit in i: "<<(to_string(i).length())<<endl;            //4
					cout<<"no.of digit in j: "<<to_string(j).size()<<endl;                //2
					cout<<"no.of digit in k: "<<to_string(k).size()<<endl;                //7
					
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-3: Conditionals, Loops, Patterns
	1) if Statement
		if(condition){
			//code block executed when condition evaluates as TRUE
		}

	2) if-else Statement
		if(condition){ 
			//This code block will be executed only if 'condition' is evaluated as TRUE
		}
		else{   
			//this block gets executed when if block evaluates to FALSE
		}
		
	3) else-if Statement
		if (cond_A) { 
			//first conditional expression
			/* statements */
		}
		else if (cond_B) {
			//second condtional expression
			/* other statements*/
		}
		else if (cond_C) {
			//third condtional expression
			/* other statements*/
		}
		else {
			/* last statement for default case */
		}
		//else is last default block not mandatory to write.
	
	4) Nested If statements / Nested If-else:
		if-statement inside another if statement

		if(cond){
			//if true
		}else{
			if(nestedCond){ 
				// nested condition code here
			} else{

			}
		}
	
	5) Switch Case Statement
			Why we use switch case instead of if-else?
				Editing in switch statement is easier as compared to the 'if-else' statement. 
				If we remove any of the cases from the switch, then it will not interrupt the execution of other cases. 
				Therefore, we can say that the switch statement is easy to modify and maintain.

				-If we have multiple choices then the
				switch statement is the best option as
				the speed of the execution will be much
				higher than 'if-else'

				-Break keyword:
					The break in C++ is a loop control statement that is used to terminate the loop. 
					As soon as the break statement is encountered from within a loop, 
					the loop iterations stop there and control returns from the loop immediately to the first statement after the loop.
				
				-Continue:
					C++ continue statement is a loop control statement that forces the 
					program control to execute the next iteration of the loop. As a result, 
					the code inside the loop following the continue statement will be 
					skipped and the next iteration of the loop will begin.

			eg.
				#include <iostream>
				using namespace std;

				int main() {
					char oper;
					float num1, num2;
					cout << "Enter an operator (+, -, *, /): ";
					cin >> oper;
					cout << "Enter two numbers: " << endl;
					cin >> num1 >> num2;

					switch (oper) {
						case '+':
							cout << num1 << " + " << num2 << " = " << num1 + num2;
							break;
						case '-':
							cout << num1 << " - " << num2 << " = " << num1 - num2;
							break;
						case '*':
							cout << num1 << " * " << num2 << " = " << num1 * num2;
							break;
						case '/':
							cout << num1 << " / " << num2 << " = " << num1 / num2;
							break;
						default:
							// operator is doesn't match any case constant (+, -, *, /)
							cout << "Error! The operator is not correct";
							break;
					}
					return 0;
				}

	6) While Loop:
		while loop require just a num inside as condition it may be -ve or +ve, it will work, 
		except the 0, if zero cames then loop breaks.
		eg.
			while(1)		//works
			while(100)	//works
			while(-23)	//works
			while(5)		//works

			while(0)		//stops this will breaks the loop.
			eg.
				#include <iostream>
				using namespace std;

				int main()
				{
					int i=1, b=-5;
					while(b++){
						std::cout << "say hii" << i++ << std::endl;
						//b++;
					}
					return 0;
				}

	 eg
	 	//WAP TO PRINT THE N NUMS:
			#include <iostream>
			using namespace std;

			int main() {
				int i=1;
				// while(i<11)
				//     cout << i++ <<"\t";
				//or
				
				while(i<11){
					cout << i << end;
					i++;                //i = i + 1
				}
				return 0;
			}

			#include <iostream>
			using namespace std;

			int main() {
				int i=1,n;
				cout << "enter n :: ";
				cin>>n;
				while(i<=n)
					cout << i++ <<"\t";
				//or
				
				//while(i<=n){
				//	cout << i << "\t";
				//	i++;                //i = i + 1
				//}
				return 0;
			}

		//WAP sum of first n num
			#include <iostream>
			using namespace std;

			int main() {
				int n,i=1,sum=0;
				cout << "enter n:: ";
				cin>>n;

				//shorthand
				while(i<=n)
					sum += i++;
				
				// or
				// while(i<=n){
				//     sum = sum + i;       //sum = sum + i
				//     i++;            //i = i +1;
				// }

				cout<< "The sum of "<<n<<" is "<<sum;
				
				return 0;
			}

		//WAP sum of even num
			#include <iostream>
			using namespace std;

			int main() {
				// sum of even num
				int n,i=2;
				cout << "Enter n:: ";
				cin>>n;
				
				int sum =0;
				while(i<=n){
					if(i % 2 == 0)
						sum = sum + i;
					i++;
				}
				
				// or shorhand
				// while(i <= n){
				//     if(i % 2 == 0)
				//         sum += i;
				//     i++;
				// }
					
				cout << "Sum of even till "<< n << " is :: "<< sum;
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					int sum=0;
					int n;
					cin>>n;

					for(int i=2;i<=n;i+=2)
						sum +=i;
					cout<<sum;
					return 0;
				}							
			
		//WAP to check entered num is prime or not?
			#include <iostream>
			using namespace std;

			int main() {
				//WAP num is prime or not.
				int n,i=2,flag=0;
				cout << "enter num :: ";
				cin>>n;
				
				while(i <= n/2){
					if(n % i == 0){
						flag = 1;
						break;
					}
					i++;
				}
				
				if(flag)
					cout << n << " is not prime";
				else
					cout << n << " is Prime Num";
				
				return 0;
			}
		
		//WAP to print:
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			->
				#include <iostream>
				int main() {
					int i=1,j=1;
					while(i++ <6){              //shorthands
						while(j++ < 8){         //shorthands for increment
							std::cout << "* ";
							// j++              
						}
						j=1;
						// i++;     
						std::cout<<"\n";
					}
					return 0;
				}
		
		//WAP to take rows & column from user.
			#include <iostream>
			int main() {
				int i=1,j=1,n;
				
				std::cout<<"Enter rows column :: ";
				std::cin>>n;
				
				while(i++ <n){              //shorthands
					while(j++ < n){         //shorthands for increment
						std::cout << "* ";
						// j++              
					}
					j=1;
					// i++;     
					std::cout<<"\n";
				}

				return 0;
			}
		
		//WAP to print this Patterns with custom rows:
		 if rows are 5,
			1 1 1 1 1 
			2 2 2 2 2 
			3 3 3 3 3 
			4 4 4 4 4 
			5 5 5 5 5
		     ->
			#include <iostream>
			int main() {
			
				int z,p,rows;
				std::cout << "Enter num of rows you want :: ";
				std::cin >> rows;
				for(z=1; z<=rows; z++){
					for(p=1; p<=rows; p++)
						std::cout << z << " ";
					std::cout<<std::endl;
				}
				return 0;
			}
			//output:
				Enter num of rows you want :: 8
					1 1 1 1 1 1 1 1 
					2 2 2 2 2 2 2 2 
					3 3 3 3 3 3 3 3 
					4 4 4 4 4 4 4 4 
					5 5 5 5 5 5 5 5 
					6 6 6 6 6 6 6 6 
					7 7 7 7 7 7 7 7 
					8 8 8 8 8 8 8 8

	eg.
		1).WAP to check num is +ve, -ve or zero?
			#include <iostream>
			using namespace std;

			int main() {
				cout<<"Enter value for A::";
				int a;
				cin>>a;
				if(a>0){
					cout<<"A is +ve "<<a;
				}else if(a<0){
					cout<<"A is -ve "<<a;
				}else{
					cout<<"A is Zero "<<a;
				}
				return 0;
			}
			--here cin function takes the input, cin function don't read tabs, space & new line char.

		2).WAP for Greater num
			#include <iostream>
			using namespace std;

			int main() {
				cout << "Enter values of A & B::";
				int a,b;
				cin >> a >> b;						//taking input at same time.
				
				cout << "A :: " << a << " B :: " << b << endl;
				if(a>b)
					cout << "A is Greater than B";
				else if(b > a)
					cout << "B is Greater than A";
				else
					cout << "A is equals to B";
				return 0;
			}

			--if there is one statement in if block then no need to put the { } curly braces

		3). WAP to check char is lowercase or uppercase or digit?
			#include <iostream>
			using namespace std;

			int main() {
				char ch;
				cout<< "Enter char :: ";
				cin>>ch;
				
				if(ch >= 'a' && ch<='z')
					cout << "Char is Lowercase "<<ch;
				else if(ch >= 'A' && ch <= 'Z')
					cout << "Char is Uppercase "<<ch;
				else if(ch >= '0' && ch <= '9')
					cout << "Char is Digit "<<ch;
				else
					cout << "Char is something Strange "<<ch;
				return 0;
			}

			CHAR Functions:
				-To use below functions you have to include this library,
					#include <ctype.h>
					//or
					#include <cctype>

				1) isalnum:
					int isalnum ( int ch );
					
					-return true if char is alphabet (upper or lower) or digit (0-9). (alphanumeric = alphabet or number).
					-The function returns a non-zero value if the character is alphanumeric and 0 otherwise.

					#include <iostream>
					#include <ctype.h>

					int main() {
						char ch1 = 'A';
						char ch2 = '7';
						char ch3 = '$';
						
						char ch4 = 'z';
						char ch5 = '8';

						if (isalnum(ch1)) {
							std::cout << ch1 << " is alphanumeric.\n";
						} else {
							std::cout << ch1 << " is not alphanumeric.\n";
						}

						if (isalnum(ch2)) {
							std::cout << ch2 << " is alphanumeric.\n";
						} else {
							std::cout << ch2 << " is not alphanumeric.\n";
						}

						if (isalnum(ch3)) {
							std::cout << ch3 << " is alphanumeric.\n";
						} else {
							std::cout << ch3 << " is not alphanumeric.\n";
						}
						
						if (isalnum(ch4)) {
							std::cout << ch4 << " is alphanumeric.\n";
						} else {
							std::cout << ch4 << " is not alphanumeric.\n";
						}
						
						if (isalnum(ch5)) {
							std::cout << ch5 << " is alphanumeric.\n";
						} else {
							std::cout << ch5 << " is not alphanumeric.\n";
						}
						return 0;
					}
					//output:
						A is alphanumeric.
						7 is alphanumeric.
						$ is not alphanumeric.
						z is alphanumeric.
						8 is alphanumeric.

				2) isalpha:
					isalpha function is also part of the <cctype> header. 
					and is used to check whether a given character is an alphabetic character (a letter lowercase or uppercase). 
					The function returns (true) a non-zero value if the character is an alphabetic character and (false) 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = 'a';
						char ch3 = '7';
						char ch4 = '$';

						if (isalpha(ch1)) {
							std::cout << ch1 << " is an alphabetic character.\n";
						} else {
							std::cout << ch1 << " is not an alphabetic character.\n";
						}

						if (isalpha(ch2)) {
							std::cout << ch2 << " is an alphabetic character and in lowercase.\n";
						} else {
							std::cout << ch2 << " is not an alphabetic character.\n";
						}

						if (isalpha(ch3)) {
							std::cout << ch3 << " is an alphabetic character.\n";
						} else {
							std::cout << ch3 << " is not an alphabetic character.\n";
						}

						if (isalpha(ch4)) {
							std::cout << ch4 << " is an alphabetic character.\n";
						} else {
							std::cout << ch4 << " is not an alphabetic character.\n";
						}

						return 0;
					}
					//output:
						A is an alphabetic character.
						a is an alphabetic character and in lowercase.
						7 is not an alphabetic character.
						$ is not an alphabetic character.

				3) isblank:
					The isblank function is another function from the <cctype> header in C++. 
					It is used to check whether a given character is a blank character, 
					which includes space (' ') 
					and horizontal tab ('\t'). 
					The function returns a non-zero value if the character is a blank character and 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = ' ';
						char ch3 = '\t';

						if (isblank(ch1)) {
							std::cout << ch1 << " is a blank character.\n";
						} else {
							std::cout << ch1 << " is not a blank character.\n";
						}

						if (isblank(ch2)) {
							std::cout << ch2 << " is a blank character.\n";
						} else {
							std::cout << ch2 << " is not a blank character.\n";
						}

						if (isblank(ch3)) {
							std::cout << "Tab character is a blank character.\n";
						} else {
							std::cout << "Tab character is not a blank character.\n";
						}

						return 0;
					}
					//output:
						A is not a blank character.
						   is a blank character.
						Tab character is a blank character.

				4) iscntrl:
					The iscntrl function in C++ is part of the <cctype> header, 
					and it checks whether a given character is a control character. 
					Control characters are non-printing characters that are used to control 
					the formatting and other aspects of output. 
					Examples of control characters include newline ('\n'), carriage return ('\r'), and tab ('\t').

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = '\n';
						char ch3 = '\t';
						char ch4 = '\r';

						if (iscntrl(ch1)) {
							std::cout << ch1 << " is a control character.\n";
						} else {
							std::cout << ch1 << " is not a control character.\n";
						}

						if (iscntrl(ch2)) {
							std::cout << "Newline character is a control character.\n";
						} else {
							std::cout << "Newline character is not a control character.\n";
						}

						if (iscntrl(ch3)) {
							std::cout << "Tab character is a control character.\n";
						} else {
							std::cout << "Tab character is not a control character.\n";
						}

						if (iscntrl(ch4)) {
							std::cout << "Carriage return character is a control character.\n";
						} else {
							std::cout << "Carriage return character is not a control character.\n";
						}

						return 0;
					}
					//output:
						A is not a control character.
						Newline character is a control character.
						Tab character is a control character.
						Carriage return character is a control character.

				5) isdigit:
					The isdigit function in C++ is used to check whether a given 
					character is a digit (0-9). 
					The function returns a non-zero (true) value if the character is a digit and (false) 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = '7';
						char ch3 = '$';

						if (isdigit(ch1)) {
							std::cout << ch1 << " is a digit.\n";
						} else {
							std::cout << ch1 << " is not a digit.\n";
						}

						if (isdigit(ch2)) {
							std::cout << ch2 << " is a digit.\n";
						} else {
							std::cout << ch2 << " is not a digit.\n";
						}

						if (isdigit(ch3)) {
							std::cout << ch3 << " is a digit.\n";
						} else {
							std::cout << ch3 << " is not a digit.\n";
						}

						return 0;
					}
					//output:
						A is not a digit.
						7 is a digit.
						$ is not a digit.

				6) isgraph:
					The isgraph function in C++ is used to check whether a given character is a graphical character. 
					A graphical character is any character that has a visible representation, 
					meaning it is printable and not a space (' '). 
					-The function returns a non-zero value if the character is a graphical character and 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is a graphical character.
						char ch2 = ' ';
						char ch3 = '7';         // 7 is a graphical character.
						char ch4 = '@';         // @ is a graphical character.
						char ch5 = '\t';        // Tab character is not a graphical character.
						char ch6 = '!';         // ! is a graphical character.

						if (isgraph(ch1)) {
							std::cout << ch1 << " is a graphical character.\n";
						} else {
							std::cout << ch1 << " is not a graphical character.\n";
						}

						if (isgraph(ch2)) {
							std::cout << "Space character is not a graphical character.\n";
						} else {
							std::cout << "Space character is a graphical character.\n";
						}

						if (isgraph(ch3)) {
							std::cout << ch3 << " is a graphical character.\n";
						} else {
							std::cout << ch3 << " is not a graphical character.\n";
						}

						if (isgraph(ch4)) {
							std::cout << ch4 << " is a graphical character.\n";
						} else {
							std::cout << ch4 << " is not a graphical character.\n";
						}

						if (isgraph(ch5)) {
							std::cout << "Tab character is not a graphical character.\n";
						} else {
							std::cout << "Tab character is a graphical character.\n";
						}

						if (isgraph(ch6)) {
							std::cout << ch6 << " is a graphical character.\n";
						} else {
							std::cout << ch6 << " is not a graphical character.\n";
						}

						return 0;
					}
					//output:
						A is a graphical character.
						Space character is not a graphical character.
						7 is a graphical character.
						@ is a graphical character.
						Tab character is not a graphical character.
						! is a graphical character.

				7) islower:
					The islower function in C++ is used to check whether a given character is a 
					lowercase alphabetic character. 
					The function returns a non-zero(true) value if the character is a lowercase letter and 0(false) otherwise.
					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is not a lowercase letter.
						char ch2 = 'a';         // a is a lowercase letter.
						char ch3 = '7';         // 7 is not a lowercase letter.
						char ch4 = '!';         // ! is not a lowercase letter.
						char ch5 = 'z';         // z is a lowercase letter.
						char ch6 = ' ';         // Space character is not a lowercase letter.

						if (islower(ch1)) {
							std::cout << ch1 << " is a lowercase letter.\n";
						} else {
							std::cout << ch1 << " is not a lowercase letter.\n";
						}

						if (islower(ch2)) {
							std::cout << ch2 << " is a lowercase letter.\n";
						} else {
							std::cout << ch2 << " is not a lowercase letter.\n";
						}

						if (islower(ch3)) {
							std::cout << ch3 << " is not a lowercase letter.\n";
						} else {
							std::cout << ch3 << " is not a lowercase letter.\n";
						}

						if (islower(ch4)) {
							std::cout << ch4 << " is not a lowercase letter.\n";
						} else {
							std::cout << ch4 << " is not a lowercase letter.\n";
						}

						if (islower(ch5)) {
							std::cout << ch5 << " is a lowercase letter.\n";
						} else {
							std::cout << ch5 << " is not a lowercase letter.\n";
						}

						if (islower(ch6)) {
							std::cout << ch6 << " is not a lowercase letter.\n";
						} else {
							std::cout << ch6 << " is not a lowercase letter.\n";
						}

						return 0;
					}
					//output:
						A is not a lowercase letter.
						a is a lowercase letter.
						7 is not a lowercase letter.
						! is not a lowercase letter.
						z is a lowercase letter.
						Space character is not a lowercase letter.

				8) isupper:
					isupper function in C++ is a part of the <cctype> library, 
					and it is used to determine whether a given character is an uppercase alphabetic character.
					-Returns a non-zero(true) value if c is an uppercase alphabetic character.
					-Returns 0(false) otherwise.
					
					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is an uppercase letter.
						char ch2 = 'a';         // a is not an uppercase letter.
						char ch3 = '7';         // 7 is not an uppercase letter.
						char ch4 = '!';         // ! is not an uppercase letter.
						char ch5 = 'Z';         // Z is an uppercase letter.
						char ch6 = ' ';         // Space character is not an uppercase letter.

						if (isupper(ch1)) {
							std::cout << ch1 << " is an uppercase letter.\n";
						} else {
							std::cout << ch1 << " is not an uppercase letter.\n";
						}

						if (isupper(ch2)) {
							std::cout << ch2 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch2 << " is not an uppercase letter.\n";
						}

						if (isupper(ch3)) {
							std::cout << ch3 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch3 << " is not an uppercase letter.\n";
						}

						if (isupper(ch4)) {
							std::cout << ch4 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch4 << " is not an uppercase letter.\n";
						}

						if (isupper(ch5)) {
							std::cout << ch5 << " is an uppercase letter.\n";
						} else {
							std::cout << ch5 << " is not an uppercase letter.\n";
						}

						if (isupper(ch6)) {
							std::cout << ch6 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch6 << " is not an uppercase letter.\n";
						}

						return 0;
					}
					//output:
						A is an uppercase letter.
						a is not an uppercase letter.
						7 is not an uppercase letter.
						! is not an uppercase letter.
						Z is an uppercase letter.
						Space character is not an uppercase letter.

				9) isspace:
					The isspace function in C++ is used to check whether a given character is a white-space character. 
					White-space characters include space (' '), tab ('\t'), newline ('\n'), carriage return ('\r'), 
					form feed ('\f'), and vertical tab ('\v'). 
					-The function returns a non-zero value if the character is a white-space character and 0 otherwise.

					#include <iostream>
					#include <cctype>
					int main() {
						char ch1 = 'A';
						char ch2 = ' ';
						char ch3 = '\t';  // Tab character
						char ch4 = '\n';  // Newline character
						char ch5 = '\v';  // Vertical tab character
						char ch6 = '\r';  // Carriage return character

						if (isspace(ch1)) {
							std::cout << ch1 << " is a white-space character.\n";
						} else {
							std::cout << ch1 << " is not a white-space character.\n";
						}

						if (isspace(ch2)) {
							std::cout << ch2 << " is a white-space character.\n";
						} else {
							std::cout << ch2 << " is not a white-space character.\n";
						}

						if (isspace(ch3)) {
							std::cout << "Tab character is a white-space character.\n";
						} else {
							std::cout << "Tab character is not a white-space character.\n";
						}

						if (isspace(ch4)) {
							std::cout << "Newline character is a white-space character.\n";
						} else {
							std::cout << "Newline character is not a white-space character.\n";
						}

						if (isspace(ch5)) {
							std::cout << "Vertical tab character is a white-space character.\n";
						} else {
							std::cout << "Vertical tab character is not a white-space character.\n";
						}

						if (isspace(ch6)) {
							std::cout << "Carriage return character is a white-space character.\n";
						} else {
							std::cout << "Carriage return character is not a white-space character.\n";
						}

						return 0;
					}

					//output:
						A is not a white-space character.
						 is a white-space character.
						Tab character is a white-space character.
						Newline character is a white-space character.
						Vertical tab character is a white-space character.
						Carriage return character is a white-space character.

				10) ispunct:
					ispunct function in C++, punctuation characters are considered to be special characters. 
					Punctuation characters are those that are not letters, digits, or whitespace characters. 
					They typically include characters like '.', ',', '!', '?', ';', and other symbols commonly 
					used for punctuation in written language.

					So, when you use the ispunct function, 
					it will return a non-zero value for characters that are considered punctuation characters, 
					and 0 for characters that are not. 
					In the provided example, characters like '.', ',', '!', ';', and '?' are considered punctuation characters.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is not a punctuation character.
						char ch2 = '!';         // ! is a punctuation character.
						char ch3 = '7';         // 7 is not a punctuation character.
						char ch4 = ' ';         // Space character is not a punctuation character.
						char ch5 = '.';         // . is a punctuation character.
						char ch6 = ',';         // , is a punctuation character.
						char ch7 = ';';         // ; is a punctuation character.
						char ch8 = '?';         // ? is a punctuation character.
						char ch9 = '#';         // # is a punctuation character.
						char ch10 = '$';        // $ is a punctuation character.
						char ch11 = '%';        // % is a punctuation character.
						char ch12 = '^';        // ^ is a punctuation character.
						char ch13 = '&';        // & is a punctuation character.
						char ch14 = '@';        // @ is a punctuation character.

						if (ispunct(ch1)) {
							std::cout << ch1 << " is not a punctuation character.\n";
						} else {
							std::cout << ch1 << " is not a punctuation character.\n";
						}

						if (ispunct(ch2)) {
							std::cout << ch2 << " is a punctuation character.\n";
						} else {
							std::cout << ch2 << " is not a punctuation character.\n";
						}

						if (ispunct(ch3)) {
							std::cout << ch3 << " is not a punctuation character.\n";
						} else {
							std::cout << ch3 << " is not a punctuation character.\n";
						}

						if (ispunct(ch4)) {
							std::cout << "Space character is not a punctuation character.\n";
						} else {
							std::cout << "Space character is not a punctuation character.\n";
						}

						if (ispunct(ch5)) {
							std::cout << ch5 << " is a punctuation character.\n";
						} else {
							std::cout << ch5 << " is not a punctuation character.\n";
						}

						if (ispunct(ch6)) {
							std::cout << ch6 << " is a punctuation character.\n";
						} else {
							std::cout << ch6 << " is not a punctuation character.\n";
						}

						if (ispunct(ch7)) {
							std::cout << ch7 << " is a punctuation character.\n";
						} else {
							std::cout << ch7 << " is not a punctuation character.\n";
						}

						if (ispunct(ch8)) {
							std::cout << ch8 << " is a punctuation character.\n";
						} else {
							std::cout << ch8 << " is not a punctuation character.\n";
						}

						if (ispunct(ch9)) {
							std::cout << ch9 << " is a punctuation character.\n";
						} else {
							std::cout << ch9 << " is not a punctuation character.\n";
						}

						if (ispunct(ch10)) {
							std::cout << ch10 << " is a punctuation character.\n";
						} else {
							std::cout << ch10 << " is not a punctuation character.\n";
						}

						if (ispunct(ch11)) {
							std::cout << ch11 << " is a punctuation character.\n";
						} else {
							std::cout << ch11 << " is not a punctuation character.\n";
						}

						if (ispunct(ch12)) {
							std::cout << ch12 << " is a punctuation character.\n";
						} else {
							std::cout << ch12 << " is not a punctuation character.\n";
						}

						if (ispunct(ch13)) {
							std::cout << ch13 << " is a punctuation character.\n";
						} else {
							std::cout << ch13 << " is not a punctuation character.\n";
						}

						if (ispunct(ch14)) {
							std::cout << ch14 << " is a punctuation character.\n";
						} else {
							std::cout << ch14 << " is not a punctuation character.\n";
						}

						return 0;
					}
					//output:
						A is not a punctuation character.
						! is a punctuation character.
						7 is not a punctuation character.
						Space character is not a punctuation character.
						. is a punctuation character.
						, is a punctuation character.
						; is a punctuation character.
						? is a punctuation character.
						# is a punctuation character.
						$ is a punctuation character.
						% is a punctuation character.
						^ is a punctuation character.
						& is a punctuation character.
						@ is a punctuation character.

				11) isprint:
					isprint function in C++ is used to check whether a given character is a printable character. 
					A printable character is any character that is not a control character (like newline or tab) 
					and is not part of the extended character set (values greater than 127 in ASCII). 
					The function returns a non-zero value if the character is printable and 0 otherwise.


					#include <stdio.h>
					#include <ctype.h>
					int main () {
						int i=0;
						char str[]="first line \n second line \n";
						while (isprint(str[i])) {
							putchar (str[i]);
							i++;
						}
						return 0;
					}
					//output:
						first line 

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is a printable character.
						char ch2 = ' ';         //   is a printable character.
						char ch3 = '\t';        // Tab character is not a printable character.
						char ch4 = '\n';        // Newline character is not a printable character.
						char ch5 = '#';         // # is a printable character.
						char ch6 = 7;           // ASCII control character (Bell) is not a printable character.
						char ch7 = 127;         // ASCII control character (Delete) is not a printable character.
						char ch8 = '0';         // 0 is a printable character.
						char ch9 = '7';         // 7 is a printable character.
						char ch10 = 'a';        // a is a printable character.
						char ch11 = 'z';        // z is a printable character.

						if (isprint(ch1)) {
							std::cout << ch1 << " is a printable character.\n";
						} else {
							std::cout << ch1 << " is not a printable character.\n";
						}

						if (isprint(ch2)) {
							std::cout << ch2 << " is a printable character.\n";
						} else {
							std::cout << ch2 << " is not a printable character.\n";
						}

						if (isprint(ch3)) {
							std::cout << "Tab character is not a printable character.\n";
						} else {
							std::cout << "Tab character is not a printable character.\n";
						}

						if (isprint(ch4)) {
							std::cout << "Newline character is not a printable character.\n";
						} else {
							std::cout << "Newline character is not a printable character.\n";
						}

						if (isprint(ch5)) {
							std::cout << ch5 << " is a printable character.\n";
						} else {
							std::cout << ch5 << " is not a printable character.\n";
						}

						if (isprint(ch6)) {
							std::cout << "Bell character is not a printable character.\n";
						} else {
							std::cout << "Bell character is not a printable character.\n";
						}

						if (isprint(ch7)) {
							std::cout << "Delete character is not a printable character.\n";
						} else {
							std::cout << "Delete character is not a printable character.\n";
						}

						if (isprint(ch8)) {
							std::cout << ch8 << " is a printable character.\n";
						} else {
							std::cout << ch8 << " is not a printable character.\n";
						}

						if (isprint(ch9)) {
							std::cout << ch9 << " is a printable character.\n";
						} else {
							std::cout << ch9 << " is not a printable character.\n";
						}

						if (isprint(ch10)) {
							std::cout << ch10 << " is a printable character.\n";
						} else {
							std::cout << ch10 << " is a printable character.\n";
						}

						if (isprint(ch11)) {
							std::cout << ch11 << " is a printable character.\n";
						} else {
							std::cout << ch11 << " is a printable character.\n";
						}

						return 0;
					}
				
				12) isxdigit:
					isxdigit function in C++ is used to check whether a given character is a hexadecimal digit. 
					Hexadecimal digits include the numbers 0-9 and the letters A-F (or a-f) representing the values 10-15. 
					The function returns a non-zero value if the character is a hexadecimal digit and 0 

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = '7';
						char ch3 = '$';
						char ch4 = '2';
						char ch5 = 'f';
						char ch6 = 'G';  // Uppercase G is not a hexadecimal digit.
						char ch7 = 'x';  // Lowercase x is not a hexadecimal digit.
						char ch8 = ' ';  // Space is not a hexadecimal digit.

						// Output for given characters
						std::cout << ch1 << ": " << (isxdigit(ch1) ? ch1 + " is a hexadecimal digit." : ch1 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch2 << ": " << (isxdigit(ch2) ? ch2 + " is a hexadecimal digit." : ch2 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch3 << ": " << (isxdigit(ch3) ? ch3 + " is a hexadecimal digit." : ch3 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch4 << ": " << (isxdigit(ch4) ? ch4 + " is a hexadecimal digit." : ch4 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch5 << ": " << (isxdigit(ch5) ? ch5 + " is a hexadecimal digit." : ch5 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch6 << ": " << (isxdigit(ch6) ? ch6 + " is a hexadecimal digit." : ch6 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch7 << ": " << (isxdigit(ch7) ? ch7 + " is a hexadecimal digit." : ch7 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch8 << ": " << (isxdigit(ch8) ? ch8 + " is a hexadecimal digit." : ch8 + " is not a hexadecimal digit.") << "\n";

						// Additional cases for all lowercase and uppercase hexadecimal digits
						for (char ch = 'A'; ch <= 'F'; ++ch) {
							std::cout << ch << ": " << (isxdigit(ch) ? ch + " is a hexadecimal digit." : ch + " is not a hexadecimal digit.") << "\n";
						}

						for (char ch = 'a'; ch <= 'f'; ++ch) {
							std::cout << ch << ": " << (isxdigit(ch) ? ch + " is a hexadecimal digit." : ch + " is not a hexadecimal digit.") << "\n";
						}

						return 0;
					}

					//output:
						A: A is a hexadecimal digit.
						7: 7 is a hexadecimal digit.
						$: $ is not a hexadecimal digit.
						2: 2 is a hexadecimal digit.
						f: f is a hexadecimal digit.
						G: G is not a hexadecimal digit.
						x: x is not a hexadecimal digit.
						:   is not a hexadecimal digit.
						A: A is a hexadecimal digit.
						B: B is a hexadecimal digit.
						C: C is a hexadecimal digit.
						D: D is a hexadecimal digit.
						E: E is a hexadecimal digit.
						F: F is a hexadecimal digit.
						a: a is a hexadecimal digit.
						b: b is a hexadecimal digit.
						c: c is a hexadecimal digit.
						d: d is a hexadecimal digit.
						e: e is a hexadecimal digit.
						f: f is a hexadecimal digit.

				13) tolower:
					tolower function in C++ is used to convert a given character to its lowercase equivalent.
					It is part of the <cctype> header.

					#include <iostream>
					#include <cctype>

					int main() {
						char uppercaseChar = 'A';
						char lowercaseChar = tolower(uppercaseChar);

						std::cout << "Original character: " << uppercaseChar << std::endl;
						std::cout << "Lowercase character: " << lowercaseChar << std::endl;

						char nonUppercaseChar = '1';
						char unchangedChar = tolower(nonUppercaseChar);

						std::cout << "Original character: " << nonUppercaseChar << std::endl;
						std::cout << "Unchanged character: " << unchangedChar << std::endl;

						char mixedCaseChar = 'M';
						char convertedMixedCaseChar = tolower(mixedCaseChar);

						std::cout << "Original character: " << mixedCaseChar << std::endl;
						std::cout << "Converted character: " << convertedMixedCaseChar << std::endl;

						char specialChar = '$';
						char unchangedSpecialChar = tolower(specialChar);

						std::cout << "Original character: " << specialChar << std::endl;
						std::cout << "Unchanged character: " << unchangedSpecialChar << std::endl;

						return 0;
					}
					//output:
						Original character: A
						Lowercase character: a
						Original character: 1
						Unchanged character: 1
						Original character: M
						Converted character: m
						Original character: $
						Unchanged character: $

				14) toupper:
					The toupper function in C++ is used to convert a given character to its uppercase equivalent. 
					It is part of the <cctype> header.

					#include <cctype>
					#include <iostream>
					using namespace std;
					int main() {
						char c1 = 'A', c2 = 'b', c3 = '9', c4 = 'z', c5 = 'g';

						cout << toupper(c1) << endl;            //type conversion NOT used		//65
						cout << toupper(c2) << endl;  		//66
						cout << toupper(c3) << endl;			//57			(ASCII value of 9)
						cout << char(toupper(c4)) << endl;    //type conversion used	//Z
						cout <<(char) toupper(c5);            //type conversion used	//G

						return 0;
					}
					//output:
						65
						66
						57
						Z
						G
					
					#include <iostream>
					#include <cctype>

					int main() {
						char lowercaseChar = 'a';
						char uppercaseChar = toupper(lowercaseChar);

						std::cout << "Original character: " << lowercaseChar << std::endl;
						std::cout << "Uppercase character: " << uppercaseChar << std::endl;

						char nonLowercaseChar = '1';
						char unchangedChar = toupper(nonLowercaseChar);

						std::cout << "Original character: " << nonLowercaseChar << std::endl;
						std::cout << "Unchanged character: " << unchangedChar << std::endl;

						char mixedCaseChar = 'm';
						char convertedMixedCaseChar = toupper(mixedCaseChar);

						std::cout << "Original character: " << mixedCaseChar << std::endl;
						std::cout << "Converted character: " << convertedMixedCaseChar << std::endl;

						char specialChar = '$';
						char unchangedSpecialChar = toupper(specialChar);

						std::cout << "Original character: " << specialChar << std::endl;
						std::cout << "Unchanged character: " << unchangedSpecialChar << std::endl;

						return 0;
					}
					//output:
						Original character: a
						Uppercase character: A
						Original character: 1
						Unchanged character: 1
						Original character: m
						Converted character: M
						Original character: $
						Unchanged character: $

		-to take space, new line as input use cin.get() function.
			int a= cin.get();
			cout<<"A :: "<<a;
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-4: Solving Pattern Questions (Part-2)
	if 'return 0' is not there at the end still program works.
	Patterns solving
	1)	1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){            			//shorthand checking as well as incrementing king as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementing
					while(b <= n){          			//for be also you can increment while checking
						cout << b++ << " ";         	//shorthand (printing as well as incrementing)
						// b++;
					}
					b=1;
					// a++; 
					cout<<"\n";
				}

				return 0;
			}

	2)
		n = 5
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
		->
			#include <iostream>
			using namespace std;		

			int main() {
			
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n) {          //shorthand
					while(b <= n){    
						cout << n - b +1<< " ";
						b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}

	3)
		1	2	3 	4	 5
		6	7 	8 	9	 10
		11	12 	13 	14	 15
		16 	17 	18	19	 20
		21 	22 	23	24	 25
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1,counter=1;

				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){          //shorthand
					while(b++ <= n){    //shorthand
						cout<<counter++<<"\t";
						// b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}
	
	4) Start pattern for custom rows:
		Enter rows:: 5
			* 
			* * 
			* * * 
			* * * * 
			* * * * * 
		->
			#include <iostream>
			using namespace std;

			int main() {
			
				int n,a=1,b=1;
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){      //shorthand 
						cout<< "* ";
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			}
	
	5)
		take rows from user:
		 Enter rows:: 5
			1 
			1 2 
			1 2 3 
			1 2 3 4 
			1 2 3 4 5 
		->
			#include <iostream>
			using namespace std;

			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b <= a){      
						cout<< b++ <<" ";     //shorthand 
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}
			return 0;
			}
	
	6)
		take rows from user:
		 Enter rows:: 5
			1 
			2 2 
			3 3 3
			4 4 4 4
			5 5 5 5 5
		 ->
		 	#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){            //shorthand
						cout<< a <<" ";     
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			} 

	7)
		Take rows input from user..
			Enter rows:5
				1	
				2	3	
				4	5	6	
				7	8	9	10	
				11	12	13	14	15	
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,counter=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){        //shorthand
						while(b++ <= a){                    //shorthand
							cout << counter++ << "\t";      //shorthand
							// counter++;
							// b++;
						}
						b=1;
						a++;
						cout << "\n";
					}
					
					
					return 0;
				}

	8)
		Take user input for rows
			Enter rows:5
			1	
			2	3	
			3	4	5	
			4	5	6	7	
			5	6	7	8	9
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,temp;
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					temp = a;						//need to try without using extra var.
					while(b <= a){
						cout << temp++ << "\t";
						b++;
					}
					cout << "\n";
					a++;
					b=1;      //important step
				}
				return 0;
			}

			//or without using temp.
			#include <iostream>
			using namespace std;
			int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << a + b - 1 << "\t";
							b++;
						}
						cout << "\n";
						a++;
						b=1;      //important step
					}
					return 0;
			}
	
	9)
		Take user input for rows
			Enter rows:5
			1
			2 1
			3 2 1
			4 3 2 1
			5 4 3 2 1
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,temp;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						temp = a;
						while(b <= a){
							cout << temp-- << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
			
			//or without using that extra temp variable

				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						// temp = a;
						while(b <= a){
							cout << a - b + 1 << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}

	10)
		Take user input for rows
			enter rows:3
				A A A
				B B B
				C C C
			->	
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a++ <= n){						//shorhand
						while(b++ <= n){					//shorhand
							cout << ch <<" ";
							//b++;
						}
						ch++;
						//a++;
						b=1;
						cout<< "\n";
					}

					//for above while loop short code.
					// 	while(a++ <= n){
					// 	    while(b++ <= n)1
					// 	        cout << ch <<" ";
					// 	    ch++;b=1;
					// 	    cout<< "\n";
					// 	}


					return 0;
				}
			
			//without using that extra char ch variable.
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:";
				cin>>n;
				
				//using char function to convert the int to char.
				
				while(a <= n){
					while(b++ <= n)
						cout << char('A' + a - 1) <<" ";

					b=1;
					a++;
					cout<< "\n";
				}
				return 0;
			}
	
	11)
		Take user input for rows
			enter rows: 3
				A B C
				A B C
				A B C
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
						cout << ch << " ";
						b++;
					}
					ch++;
					a++;
					b=1;
					cout << "\n";
				}
				
				return 0;
			}

			//or without using that extra ch
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							
							cout << char(64 + a) << " ";					//ASCII value of A is 65 so we purposefully added 64 before it.
							
							//or
							//cout << char('A' + a - 1) << " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
		
	12)
		Take user input for rows
			Enter rows:5
			A B C D E 
			F G H I J 
			K L M N O 
			P Q R S T 
			U V W X Y 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
						cout << ch++ << " ";			//shorhand for ch.
							b++;
							//ch++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	14)
		Take user input for rows
		Enter rows:5
			A B C D E 
			B C D E F 
			C D E F G 
			D E F G H 
			E F G H I 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';

				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
					cout << ch++  << " ";
						b++;
						// ch++;
					}
					ch = 'A' + a;
					a++;
					b=1;
					cout << endl;
				}
				return 0;
			}

			//or without using that extra char ch.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							cout << char('A' + b - 1 + a - 1) << " ";			//to match the above pattern so we did adjustment.

							//or using ASCII value to print A , for first iteration (63 + 1 + 1 = 65) which is A.
							//cout << char(63 + b + a) << " ";
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	15)
		Take user input for rows
		  enter rows: 3
		  	A
			B B
			C C C
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
						cout << ch << " ";
						b++;
						}
						ch++;
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

			//without using ch char.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + a - 1) << " ";

							//or
							//cout << char(64 + a) << " ";

							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	16)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				D E F 
				G H I J 
				K L M N O 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b++ <= a)				//shorhand for b first checking then incrementing.
							cout << ch++ << " ";
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	17)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				C D E 
				D E F G 
				E F G H I
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							// cout << char('A' - 1 + b + a -1) << " ";
							// or
							cout << char(63 + b + a ) << " ";
							
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	18)
		Take user input for rows
			Enter rows:5
				E 
				D D 
				C C C 
				B B B B 
				A A A A A 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					
					while(a <= n){
						while(b <= a){
							cout << char(ch + n - a)<< " ";

							//or without using that char ch.
							//cout << char('A' + n - a)<< " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}	
					return 0;
				}

	19)
		Take user input for rows
			Enter rows:5
				E 
				D E 
				C D E 
				B C D E 
				A B C D E 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + n - a + b -1) << " ";
							b++;
						}
						a++;
						b=1;
						
						cout << "\n";
					}
					
					return 0;
				}

				//or short
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows:";
						cin>>n;
						
						while(a <= n){
							while(b <= a)
								cout << char(64 + n - a + b++) << " ";
							a++;b=1;
							cout << "\n";
						}
						return 0;
					}

	20)
		Take user input for rows
			Enter rows: 5
			     *
			    **
			   ***
			  ****
			 *****
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,c,temp;
			
				cout << "Enter rows: ";
				cin >>n;
				c=n;
				
				while(a <= n){  
					temp = c--;                 //shorthand for c
					while(temp >= 1){
						cout << " ";
						temp--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;
			}

			//or
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,space;
			
				cout << "Enter rows: ";
				cin >>n;
			
				while(a <= n){
					space = n - a;
					while(space){
						cout << " ";
						space--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;			
			}

	21)
			Take user input for rows
				Enter rows: 5
					XXXXX
					XXXX
					XXX
					XX
					X
				->
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows: ";
						cin >>n;
						b=n;
						
						while(a <= n){
							while(b--){         //b shorthand
								cout << "X";
								// b--;
							}
							b=n-a++;        //a shorthand
							// a++;
							cout << endl;
						}
						return 0;
					}

	22)Take user input for rows
		Enter rows: 5
			* * * * * 
			  * * * * 
			    * * * 
			      * * 
			        * 
		->
		#include <iostream>
		using namespace std;
		int main() {
			int n,a=1,b, space;
			
			cout << "Enter rows: ";
			cin >>n;

			b = n;
			
			while(a <= n){
				space = a - 1;
				while(space--){         //space shorthand
					cout << "  ";
					// space--;
				}
				while(b--){             //b shorthand
					cout << "* ";
					// b--;
				}
				
				b= n - a;
				a++;
				cout << "\n";
			}
			return 0;
		}

	23)Take user input for rows
		Enter rows: 5
			1 1 1 1 1 
			  2 2 2 2 
			    3 3 3 
			      4 4 
			        5 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b, space;
				cout << "Enter rows: ";
				cin >>n;
				b = n;
				
				while(a <= n){
					space = a - 1;
					while(space--){         //space shorthand
						cout << "  ";
						// space--;
					}
					while(b--){             //b shorthand
						cout << a <<" ";
						// b--;
					}
					
					b= n - a;
					a++;
					cout << "\n";
				}	
				return 0;
			}

	24)Take user input for rows
		Enter rows:5
						1
					2	2
				3	3	3
			4   	4	4	4
		5  	5	5	5	5
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			space = n-1;
			
			while(i <= n){
				while(space--){                 //shorthand for space 
					cout << "  ";
					// space--;
				}
				
				while(j++ <= i){                //shorthand for j
					cout << i << " ";
					// j++;
				}
				i++;
				j = 1;
				
				space = n - i;          //important step.
				
				cout << "\n";
			}

			return 0;
		}

	25)Take user input for rows
	 Enter rows:4
		1 2 3 4
		  2 3 4
		    3 4
		      4
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){
				
				//spacing
				space = 1;
				while(space < i){
					cout << "  ";
					space++;
				}
				
				//printing num
				while(j <= n){
					cout << j << " " ;
					j++;
				}
				cout << "\n";
				i++;
				j=i;            //important step
			}
			return 0;
		}

	26)Take user input for rows
	    Enter rows:4
					1
				2	3
			4	5	6
		7	8	9	10
	   ->
	   	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,counter=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){	
				//spacing
				space = n - i;
				while(space--){		//shorhand for space
					cout << "\t";
				}
				
				while(j <= i){
					cout << counter++ << "\t";
					j++;
				}
				i++;
				cout << "\n";
				j=1;
			}	
			return 0;
		}

	27)Take user input for rows
		Enter rows:4

						1
					1	2	1
				1	2	3	2	1
			1	2	3	4	3	2	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, k=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--) {
						cout << "  ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << j << " ";
						j++;
					}
					
					while(k < i){
						cout << i - k << " ";
						k++;
					}
					
					cout<<endl;
					k=1;
					j=1;
					i++;
				}				
				return 0;
			}

	28)Take user input for rows
		Enter rows:5
		1	2	3	4	5	5	4	3	2	1
		1	2	3	4	*	*	4	3	2	1
		1	2	3	*	*	*	*	3	2	1
		1	2	*	*	*	*	*	*	2	1
		1	*	*	*	*	*	*	*	*	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space=1;
				
				cout << "Enter rows: ";
				cin >> n;
				
				while(i <= n){
					
					//start looping
					while(j <= n-i+1){              //important step
						cout << j  << " "; 
						j++;
					}
					
					//spacing
					while(space < i){
						cout << "* * ";
						space++;
					}
					
					//reverse loop
					while(--j){
						cout << j << " ";
					}
					
					//resetting the values
					j=1;
					space=1;
					
					cout << endl;
					i++;
				}
				return 0;
			}
			//output
				Enter rows: 5
					1 2 3 4 5 5 4 3 2 1 
					1 2 3 4 * * 4 3 2 1 
					1 2 3 * * * * 3 2 1 
					1 2 * * * * * * 2 1 
					1 * * * * * * * * 1 

	29) pyramid start pattern:
		Enter rows: 5
 			    * 
 			   * * 
 			  * * * 
 			 * * * * 
 			* * * * *
		->

			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--){
						cout << " ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << "* ";
						j++;
					}
					cout<<endl;
					j=1;
					i++;
				}
				return 0;
			}

	30) Hollow Box star pattern:
		#include <iostream>
		#include <bits/stdc++.h> 
		using namespace std;

		void printPattern(int m, int n) {
		for(int i=0; i<m; i++){
			for(int j=0; j<n; j++)
				if(i == 0 || i == m-1 || j==0 || j== n-1)
					cout<<" * ";
				else
					cout<<"   ";
				cout<<"\n";
			}
		}

		int main() {
			int row = 4, col = 5;
			printPattern(row,col);
			return 0;
		}
		//output:
			*  *  *  *  * 
			*           * 
			*           * 
			*  *  *  *  * 
	
	31) Pattern:
		for n = 5
			1
			2 9
			3 8 10
			4 7 11 14
			5 6 12 13 15
		->
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				// n = 5
				// 1
				// 2 9
				// 3 8 10
				// 4 7 11 14
				// 5 6 12 13 15
				
				int n;
				cin>>n;
				vector<vector<int>> holder(n);
				
				int j=0,cnt=1, f=1;
				for(int i=0; i<n; i++) {
					int rEnd = n - i;
					
					while(rEnd--){
						if(f){
							holder[j++].push_back(cnt++);
						}else{
							holder[j--].push_back(cnt++);
						}
					}

					(f) ? j-- : j+=2;
					
					f = (f) ? 0 : 1;
				}
				//or complex
				/*
					for(int i=0; i<n; i++) {
						int rEnd = n - i;
						while(rEnd--)
							(f) ? holder[j++].push_back(cnt++) : holder[j--].push_back(cnt++);
						(f) ? j-- : j+=2;
						f = (f) ? 0 : 1;
					}
					
				*/				
				
				for(auto &v : holder){
					for(int i: v)
						cout<< i <<" ";
					std::cout << std::endl;
				}
				return 0;
			}
---------------------------------------------------------------------------------------------------------
	04/08/2023
Lecture-5: Bitwise Operators, For Loops, Operator Precedence & Variable Scoping
	-Bitwise Operator
		This operator will work on BIT level.
			1). AND (&)
			2). OR (|)
			3). NOT (~)
			4). XOR (^)
		
		Let’s look at the truth table of the bitwise operators
			  Operator	Description				Example
				&		Bitwise AND	 			a & b
				|		Bitwise OR	 			a | b
				^		Bitwise XOR	 			a ^ b
				~		Bitwise NOT (Complement)		  ~a
				<<		Bitwise Left Shift			a << n
				>>		Bitwise Right Shift			a >> n


		Table:
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   a   |   b   | a & b | (a | b)| a ^ b |   ~a  | a << 1 | a >> 1 |
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   0   |   0   |   0   |   0    |   0   |   1   |   0    |   0    |
			|   0   |   1   |   0   |   1    |   1   |   1   |   0    |   0    |
			|   1   |   0   |   0   |   1    |   1   |   0   |   2    |   0    |
			|   1   |   1   |   1   |   1    |   0   |   0   |   2    |   0    |
			+-------+-------+-------+--------+-------+-------+--------+--------+


		eg.
			#include <iostream>
			#include <bitset>
			using namespace std;

			int main() {
				// Bitwise AND (&)
				int a = 12;  // 1100 in binary
				int b = 25;  // 11001 in binary
				int result_and = a & b;
				cout << "Bitwise AND: " << result_and << " (" << bitset<8>(result_and) << ")" << endl;  // Output: 8 (00001000)

				// Bitwise OR (|)
				int result_or = a | b;
				cout << "Bitwise OR: " << result_or << " (" << bitset<8>(result_or) << ")" << endl;  // Output: 29 (00011101)

				// Bitwise XOR (^)
				int result_xor = a ^ b;
				cout << "Bitwise XOR: " << result_xor << " (" << bitset<8>(result_xor) << ")" << endl;  // Output: 21 (00010101)

				// Bitwise NOT (~)
				int result_not = ~a;
				cout << "Bitwise NOT: " << result_not << " (" << bitset<8>(result_not) << ")" << endl;  // Output: -13 (11110011)

				// Bitwise Left Shift (<<)
				int n_left = 2;
				int result_left = a << n_left;
				cout << "Bitwise Left Shift: " << result_left << " (" << bitset<8>(result_left) << ")" << endl;  // Output: 48 (00110000)

				// Bitwise Right Shift (>>)
				int n_right = 2;
				int result_right = a >> n_right;
				cout << "Bitwise Right Shift: " << result_right << " (" << bitset<8>(result_right) << ")" << endl;  // Output: 3 (00000011)

				return 0;
			}
		
			Practice:
				#include <iostream>
				using namespace std;

				int main()
				{
					int a=4,b=6;
					
					cout<<"A&B "<< (a&b) << endl;           //4
					cout << "A|B "<< (a|b) << endl;         //6
					cout << "A^B "<< (a^b) << endl;         //2
					cout << "~A "<< (~a) << endl;           //-5
					
					//~a --> 32 bit
						// 4 ==> [-------- -------- -------- -----100] all bits are zero 
						// ~a ==> [11111111 11111111 11111111 11111011]    reverse of above 
						
						// from first bit you can say that it's -ve num.
						//     so before to print take its 2's complement
						//     1's complement [-------- -------- -------- -----100] adding + 1 in it.
						//     ==> [-------- -------- -------- -----101]
							//this above binary in decimal is 5 so ans is -5.
					return 0;
				}
		
		-Left shift:
			syntax.
				var << num;
			eg.
				5 << 1		ie.		101 after shifting 1 bit to left 1010, so 1010 is 10.
				3 << 2         ie. 		011 after shifting 2 bit to left 1100 so its 12.

		-NOTE: here you can see when we use left shift it will get multiplied by 2 in most cases.
				but BE CAREFULL SOMETIME IT WILL GENERATE AN -VE NUM ALSO, WHEN NUM IS TOO LARGE,
				SO, ITS NOT LIKE THAT WHEN WE DO LEFT SHIFT THEN IT'LL GET MULTIPLIED BY 2.
			
		-Right Shift:
			syntax.
				var >> num;
			eg.
				15 >> 1;			ie. right shift by 1 bit.
				
				5 >> 2;			ie. right shift by 2 bit,
								101 >> 2 -->	001 its 1.

				5/2 = 2 ------- pass 1
				2/2 = 1 ------- pass 2	
				so 5 >> 2 => 1
		
		NOTE: 
			either it is a left shift(<<) or right shift(>>) to any +VE NUM, 
			then num of bits padded with zero(0). (means zero will get added after shifting).

			else if the num is -ve then padding will depends on compiler
		
		eg.
			int a=1,b=2;

			if(a-- >0 && ++b > 2)				//it will check for b also cause && require all condition must be true
				cout<<"if";
			else
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 3 
		
			//OR
			int a=1,b=2;
			if(a-- >0 || ++b > 2)				//it will check for a only, cause one condition needs to be true,
				cout<<"if";					//so if first condition is true then control don't go for next condition & 
			else								//b won't get incremented also. check output
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 2
		
	-For Loop:
		flow:
			once we visit initialization part, 
			then for next all iteration we just check the condition & updation value.

		for(initialize; condition; increment/ decrement){
			//statement
		}
		//or
		for(;;){
				
		}
		eg.
			for(int i=1; i<=5; i++){
				cout << i;
			}
			//or

			int i = 1;
			for(;;){
				if(i<=n){
					cout << i++ ;
				}else{
					break;
				}
			}

			//multiple
			for(int a=0, b=1; a>=0, b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;

			for(int a=0, b=1; a>=0 && b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;
		
		1). WAP Sum of n
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, sum=0;
				cout << "enter n ";
				cin>>n;
				for(int i =1; i<=n; i++)
					sum += i;
					
				std::cout <<"The sum of "<<n<<" num is "<<sum << std::endl;
				
				return 0;
			}
		
		2). WAP for Fibonacci series
			#include <iostream>
			using namespace std;

			int main()
			{
				int n,prev=0, cur=1,temp;
				cout << "enter n ";
				cin>>n;
				
				for(int i =1; i<=n; i++){
					
					cout << prev << " ";
					
					temp = cur + prev;
					prev = cur;
					cur = temp;
					
				}
					
				return 0;
			}
		
		3). check entered num is Prime num or not?
			#include <iostream>
			using namespace std;

			int main()
			{
				int n;
				cout << "Enter num : ";
				cin >> n;
				
				bool PRM = true;
				
				for(int i=2; i < n/2; i++)
					if(n % i == 0){
						PRM = false;
						break;
					}
				
				if(PRM)
					cout << n << " is prime num.";
				else
					cout << n << " is not prime num.";
				
				cout << endl << "END";
				return 0;
			}
		
		4). Print all prime nums between given range
			#include <iostream>
			using namespace std;

			int main()
			{
				int startNum, endNum;
				
				std::cout << "Enter Range to print all Prime nums in-between : " << std::endl;
				
				std::cout << "Enter Starting num :: ";
				std::cin >> startNum;
				
				std::cout << "Enter Ending num :: ";
				std::cin >> endNum;
				
				std::cout << "Prime nums in-between given range :: " << std::endl;
					
				for(int i = startNum; i <= endNum; i++){
					
					bool PRM = true;
					
					if( i == 1){
						std::cout << "1 neither prime nor composite" << std::endl;
						continue;
					}
					
					for(int j=2; j <= i/2; j++)
						if(i % j == 0){
							PRM = false;
							break;
						}
					
					if(PRM)
						std::cout << i << " is Prime num." << std::endl;
					else{
						// std::cout << i << " is not Prime num." << std::endl;
						continue;
					}
				}
				
				cout << endl << "END";
				return 0;
			}

		5). 

	-Variable & Scope:
		-You can't create same variable within single block.
		eg.
			#include <iostream>
			int main()
			{    
				int a =10;
				std::cout << a << std::endl;                //10
				
				if(true){
					std::cout <<"inside if before creating "<< a << std::endl;          //10
					int a = 89, b = 77;
					std::cout <<"inside if after creating "<< a << std::endl;           //89
					std::cout << "b = "<< b << std::endl;
				}
				
				// std::cout << "b" <<b<< std::endl;                       //you cant access b outside if block
				std::cout << "Outside if : "<< a << std::endl;          //10
				
				int i=1;
				for(int i= 5;i<=5;i++)
					std::cout << "HII" << std::endl;
					
				//below code works fine.
				if(1){
					int b;
					
					if(1){
						int b;
						
						if(1){
							int b;
							
							if(1){
								int b;
							}
						}
					}
				}
				std::cout << std::endl << "END";
				return 0;
			}

	-Operator Precedence:
		BODMAS
			-Brackets
			-Orders (Exponents and Roots): 
				Evaluate exponents and roots next. This includes calculations involving powers (^) and square roots (√).
			D - Division
			M - Multiplication
			A - Addition
			S - Subtraction
		
	-Practice:
		1].WAP print the difference of product & sum of given num.
		
			#include <iostream>
			using namespace std;

			int main()
			{
				int num;
				cout << "Enter num ";
				cin >> num;
				
				int sum =0 , prod=1;
				
				while(num > 0){
					int temp = num % 10;
					
					sum = sum + temp;
					prod = prod * temp;
					
					num = num / 10;
				}
				
				std::cout << "SUM "<< sum << std::endl;
				std::cout << "Product "<< prod << std::endl;
				std::cout << "Product - SUM "<< prod-sum << std::endl;
				
				cout << "END";
				return 0;
			}

		2]. WAP to count  Number of 1 Bits in given num:
			#include <iostream>
			using namespace std;

			int main()
			{
				int count =0,n=123;
				while(n > 0){
					if(n & 1){
						c++;
					}
					n >>= 1;
				}
				cout << "no.of 1 bit " <<count;
			}
		
		3]. Reverse integer

			int reverse(int n) {
				int rev = 0;
				while(n){
					if( rev > INT_MAX/10 || rev < INT_MIN/10)   return 0;		//if crossing the limit then return 0.
					rev = (rev * 10) +  n % 10;
					n /= 10;
				}
				return rev;
			}

			#include <iostream>
				using namespace std;
				int main()
				{
					int rev = 0, n;
					
					cin>>n; //123

						while(n > 0){
							int lastDigit = (n % 10);
							rev = rev * 10 + lastDigit;
							n /= 10;
						}
						cout << rev;
					return 0;
				}

			int reverse(int x) {
				int rev = 0, n = abs(x);				//abs() it convert num -ve to +ve, & +ve is +ve only. 

				while(n > 0){
					rev += (n % 10);
					
					if(n > 10){
						rev *= 10;
					}
					
					n /= 10;
				}
				if(x <0 )
					return -rev;
	
				return rev;
			}

			//using do-while loop.
			#include <iostream>
				using namespace std;

				int main()
				{
					int n;
					std::cout << "enter n:" << std::endl;
					cin>> n;
					int rev =0;
					
					do{
						rev = (n % 10) + rev * 10;
					}while(n /=10);
					
					cout<<"The Reverse "<< rev;
					return 0;
				}
	
		4]. WAP to find entered num is even or odd.
			#include <iostream>
			using namespace std;
				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					if( num % 2 == 0)
						cout << num << " is Even." <<endl;
					else
						cout << num << " is Odd." <<endl;

					//or
					//(num % 2 == 0)? std::cout << num << " is Even" : cout << num << " is odd";


					return 0;
				}

			//or without using modulo operator,
				cout << (num & 1 == 1); 
				-This part is attempting to check whether the least significant bit (LSB) of num is 1. 
				However, the code is not written correctly for this purpose.
				The issue lies in operator precedence. 
				The equality operator (==) has higher precedence than the bitwise AND operator (&). 
				So, the expression is evaluated like this:
					(num & (1 == 1))
				
				To fix this issue add parentheses,
					cout << ((num & 1) == 1);
				#include <iostream>
				using namespace std;

				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					((num & 1) == 1) ? printf("%d is Odd num",num) : printf("%d is Even num.",num);

					//or
					//((num & 1) == 0) ? printf("%d is Even num.",num) : printf("%d is Odd num",num) ;
	
					return 0;
				}

			//or
				first division then multiply, it because of rounding in integer,
				#include <iostream>
				using namespace std;
				int main() {
					int num;
					std::cout << "Enter num: ";
					std::cin >> num;

					if((num / 2) * 2 == num)
						cout << "even"<<std::endl;
					else
						cout << "Odd"<<std::endl;
						
					std::cout << "End" ;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	05/08/23
Lecture-6: Binary & Decimal Num System
		1) Decimal to Binary
			-divide by 2.
			-Store remainder
			-repeat above 2 step until n != 0.
			-at last reverse the answer
			eg.
				5 -> 101
				7 -> 111
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main(){
					int num, i=0;
					std::cout << "Enter num :" << std::endl;
					cin>>num;
					
					int binaryForm = 0;
					cout << "Binary of " << num << " is ";
					
					while(num){
						int bit = num & 1;
						
						binaryForm = (bit * pow(10,i++)) + binaryForm;
						
						num >>= 1;          //num = num >> 1;
					}
					std::cout << binaryForm <<std::endl;	
					return 0;
				}

				//or
					#include <iostream>
					#include<algorithm>
					using namespace std;
					int main(){
						string s;
						int n = 8;
						while(n){
							s += to_string(n%2);
							n /= 2;
						}
						
						reverse(s.begin(), s.end());
						std::cout << s << std::endl;
						return 0;
					}
			
			eg. to keep same sequence of num.
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int a = 203,b=0,last,i=0;
					
					std::cout << a << std::endl;
					
					while(a){
						last = a % 10;
						b = b + last* pow(10,i++);
						a /=10;
					}

					cout<<b;
					return 0;
				}

			//Homework -ve num to binary
				->

		2) Binary to Decimal
			-multiply by 2's power to that numbers binary bit
			-if that bit is 1, then consider 2's power else ignore
			-last add all 2's power

				1 -> 1011

				=(2⁰ * 1) + (2¹ * 1) + (2² * 0) + (2³ * 1)
				=1+2+0+8
				=11.
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int num,i=0;
					std::cout << "Enter num in binary : " << std::endl;
					cin>>num;            //1010
					
					int deci=0;

					//using while loop
					while(num){
						
						if(num % 10 == 1)					//if(num%10)
							deci = pow(2,i) + deci;
						i++; 
						num /= 10;
					}
					
					//or using do-while loop
					//do{
					//	if(num % 10 == 1)				//if(num%10)
					//		deci = pow(2,i) + deci;
					//	i++;
					//}while(num /=10);

					cout << "The Decimal num is :: "<<deci;
					return 0;
				}
		
		#Bitset:
			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<5> bits; // Creates a bitset with 5 bits, initialized to all zeros
				
				bits[2] = 1; // Set the third bit to 1
				std::cout << "Bitset value: " << bits << std::endl; // Output: 00100
				
				return 0;
			}

		eg.
			#include <bitset>
			std::bitset<8> bits; // Creates a bitset with 8 bits, defaultly initialized to all zeros
			std::bitset<8> anotherBits("10101010"); // Initializes the bitset with the given binary string

			std::bitset<32> thirtyTwoBits;   // Creates a bitset with 32 bits
			std::bitset<64> sixtyFourBits;   // Creates a bitset with 64 bits
			std::bitset<128> oneTwentyEightBits; // Creates a bitset with 128 bits, & all are zero.
			
			#include <iostream>
			#include<bitset>
			using namespace std;

			int main() {
				
				int n=9;
				bitset<32> bits (n);         //bitset<num> name (decimal_num_to_convert_into_binary);
				
				std::cout << n << "\t" << bits << std::endl;
				
				int a = 10;
				bitset<32> b2(a);
				std::cout << a << "\t" << b2 << std::endl;
				
				
				//converting bitset datatype value into string.
				string s = bits.to_string();
				std::cout << s << std::endl;
				
				int num = stoi(s,0,2);              //from binary to decimal coversion.
				std::cout << num << std::endl;

				bitset<12> nt;
				std::cout << nt << std::endl;       //000000000000
				return 0;
			}
		
		eg.
			it's okay to define a std::bitset<8> and initialize it with a binary string that has fewer than 8 characters. 
			The missing bits will be implicitly set to 0. In your example, std::bitset<8> anotherBits("101"), 
			since the binary string "101" has only 3 characters, the remaining 5 bits will be set to 0, 
			resulting in a bitset equivalent to "00000101".

			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<8> anotherBits("101"); // Initializes the bitset with "101"

				std::cout << "Bitset value: " << anotherBits << std::endl; // Output: 00000101

				//printing any binary num
					int n;
					cin>>n;
					std::cout << "n "<< bitset<8>(n) << std::endl;
   				
				return 0;
			}
				In this example, the std::bitset<8> is initialized with the binary string "101", 
				which fills the lower three bits. The remaining bits are automatically set to 0, 
				resulting in the bitset value "00000101".
---------------------------------------------------------------------------------------------------------
	06/08/23
Lecture-7: LeetCode Problem Solving Session
	eg.
		max/min int printing:
			#include<climits>				
				cout<<INT_MIN;				//minimum value of int stored in INT_MIN
				cout<<INT_MAX;				//maximum value of int stored in INT_MAX

	Practice:
		1]. Complement of base 10 integer
			5 -> 101
			complement -> 010
			which is 2 in decimal

			7 -> 111
			complement -> 000
			which is 0 in decimal

			#include <iostream>
				#include<bitset>
				using namespace std;

				int main()
				{
					
					int n;
					cin>>n;
					
					if(!n){                                 //if(n == 0)
						cout << "new num "<< !n;            //cout << "new num "<< 1;
						return 0;
					}
					
					int temp = n, mask=0;
					
					while(temp){
						mask <<= 1;              //mask = mask << 1;
						mask |= 1;               //mask = mask | 1;
						temp >>=1;               //temp =  temp >> 1;
					}
					
					n = (~n) & mask;
					
					cout << "new num "<<n;
					
					return 0;
				}

			LeetCode:
				int bitwiseComplement(int n) {

					if(!n){
						return !n;
					}

					int temp = n,mask=0;

					while(temp){
						mask <<=1;
						mask |= 1;
						temp >>= 1;
					}

					n = (~n) & mask;
					return n;
				}

		2]. Given num is representation of power of 2.	(hint if no.of setbits = 1 then that num is power of 2)
			#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int n,i=0;
					cin>>n;
					
					while(n >=1){
						int temp = pow(2,i++);
						if(n == temp){
							std::cout << "TRUE" << std::endl;
							return 0;
						}
						
						if(temp > n)
						{
							cout <<"FALSE";
							return 0;
						}
					}
					cout << "FALSE";
					return 0;
				}
				//or
					int main()
					{
						int a;
						
						std::cout << "Enter num " << std::endl;
						cin>>a;
						
						for(int i=0; ;i++){
							int temp = pow(2,i);
							if(temp == a){
								std::cout << "Yes power of 2" << std::endl;
								break;
							}
							
							if(temp > a){
								std::cout << "No it's not power of 2" << std::endl;
								break;
							}
						}
						
						std::cout << "END" << std::endl;
						return 0;
					}

			LeetCode:
				bool isPowerOfTwo(int n) {
					int temp=1;					
					while(n>=1){
						if(n == temp)
							return true;
						
						if(temp > n)
							return false;

						temp = temp * 2;
					}
					return false;
				}	

				//or
				if(n==0) return false;
				while(n%2==0) n/=2;
				return n==1;

			// power finding without using * & pow().
				#include <iostream>
				#include<cmath>
				using namespace std;
				int main(){
					
					int n=-9;
					int sqr =0;
					
					//without using *,/ or pow()
					if(n<0)
						n = -n;
					for(int i=1; i<=n; i++)
						sqr +=n;
					std::cout << sqr << std::endl;
					
					//using pow()
					std::cout << pow(n,2) << std::endl;
					
					//using *
					std::cout << n*n << std::endl;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	07/08/23
Lecture-8: Switch case & functions
		syntax.
			switch(condition){
				case value_1 :
					//statement block ;
					break;
					
				case value_2:
					//statement block ;
					break;

				case value_3:
					//statement block;
					break;

				default:
					//statement block ;
			}
			--here for above case no need to use break after default, coz default is at the last of switch case,
				so it will automatically go out of switch case and continue with next line.

			--in place of condition in switch case [switch(condition)], you can keep integer or character value,
				but not float / string value.
				you can keep expression also, like	
				switch(a+b*10)		which generates an constant value.
				
			
			--default case is not mandatory, if its there in code then GOOD, if its not then NO WORRIES.
			--default case is better to keep at last,
		->		
			Include break after default: 
				If you want the switch statement to exit immediately after the default case is executed, 
				you should include a break statement. This prevents the program from continuing to execute 
				code in other case blocks that come after the default case.
				switch(condition){
					case value_1 :
						//statement block ;
						break;
						
					case value_2:
						//statement block ;
						break;

					default:
						//statement block ;
						break;
					
					case value_3:
						//statement block;
						break;
				}

				--if the code is like this above then better to keep the break after default, if you don't 
					write break; after default, then it'll continues to executes the next cases which are after default.

				Nested switch:
					switch(condition){
						case value_1 :
							//statement block ;
							break;
							
						case value_2:
							switch(condition){
									case value_1 :
										//statement block ;
										break;
										
									case value_2:
										//statement block ;
										break;

									default:
										//statement block ;
										break;
									
									case value_3:
										//statement block;
										break;
								}
							break;

						default:
							//statement block ;
							break;
						
						case value_3:
							//statement block;
							break;
					}
		
		eg.
			#include <iostream>
			using namespace std;

			int main()
			{
				int num = 1;
				char ch = '1';
				switch(ch){
					case '2':
						std::cout << "2nd Character" << std::endl;
						break;
						
					case '3':
						std::cout << "3rd Character" << std::endl;
						break;
						
					case '1':
						switch(num){
							case 1:
								std::cout << "1st Character Nested switch" << std::endl;
								break;
						}
						break;
						
					default:
						std::cout << "Default case" << std::endl;
				}
				return 0;
			}
			//output : 1st Character Nested switch

		-Function exit(0)
			--used to come out from infinite loop if we got stuck, without using break. 
			--The most common convention is to use exit(0) to indicate successful execution.
			--and exit(1) (or any non-zero value) to indicate an error or abnormal termination.

			#include <iostream>
			#include <stdlib.h>
			using namespace std;

			int main()
			{
				int num = 1;
				
				while(1){
					std::cout << num << std::endl;
					if(num > 10)
						exit(0);
					num++;
				}
			return 0;
			}
		
		Practice:
			#include <iostream>
				using namespace std;

				int main()
				{
					int a,b;
					char Op;
					
					std::cout << "Enter A :: ";
					std::cin >> a;
					std::cout << "Enter B :: ";
					cin>>b;
					
					cout<<"Enter Operation want to perform: ";
					cin>>Op;
					
					switch(Op){
						case '+':
							{
								std::cout << "Addition: " <<a+b << std::endl;				//you can use Brackets for cases also.
								break;
							}
							
						case '*':
							{
								std::cout <<  "Multiplication: " << a*b << std::endl;
							}
							break;
						
						case '-':
							std::cout <<  "Subtraction: " <<  a-b << std::endl;
							break;
						
						case '/':
							std::cout <<   "Division: " << a/b << std::endl;
							break;
						
						case '%':
							std::cout <<  "Remainder: " <<  a%b << std::endl;
							break;
						default:
							cout << "Not Matching Operation.\n";
					}
					
					std::cout << "END" << std::endl;
					return 0;
				}

			#include <iostream>
				using namespace std;

				int main()
				{
					int num;
					std::cout << "Enter Num : " << std::endl;
					cin >>num;
					
					switch(1){
						
					}
					int temp = num;
					//1234      =12
					
					std::cout << "you need "<< num/ 100 << " 100 notes" << std::endl;        //12
					num -= (num/100) * 100;                     //1234-1200 = 34
					
					std::cout << "you need "<< num / 50 << " 50 notes" << std::endl;         //0
					num -= (num/50) * 50;                                               //34
					
					std::cout << "you need "<<num/20 << " 20 notes" << std::endl;        //1
					num -= (num/20) * 20;                                           //34-20 =14
					
					std::cout << "you need "<< num/10 << " 10 notes" << std::endl;       //1
					num -= (num/10) * 10;                                       //14-10=4
					
					std::cout << "you need "<< num/1 << " 1 coins" << std::endl;       //4
					num = num;

					std::cout << "For "<<temp<<" Amout." << std::endl;
					
					std::cout << "END" << std::endl;
					return 0;
				}	

		Functions:
			A function is a block of code that performs a specific task.
			Suppose we need to create a program to create a circle and color it. We can create two functions to solve this problem:

				a function to draw the circle
				a function to color the circle
			Dividing a complex problem into smaller chunks makes our program easy to understand and reusable.

			There are two types of function:
				Standard Library Functions: Predefined in C++
				User-defined Function: Created by users 
			
			syntax to declare a function is:

				returnType functionName (parameter1, parameter2,...) {
					// function body   
				}

				Here's an example of a function declaration.
				
				// function declaration
				void greet() {
					cout << "Hello World";
				}

				Here,
					the name of the function is greet()
					the return type of the function is void
					the empty parentheses mean it doesn't have any parameters
					the function body is written inside {}
				
				Calling a Function
					In the above program, we have declared a function named greet(). 
					To use the greet() function, we need to call it.
					Here's how we can call the above greet() function.
						greet();
			eg.
				Power of n, pow(a,b);
					#include <iostream>
					using namespace std;

					int power(int, int);            //function declaration,because after main function
											//we are giving the function definition
					int main()
					{
						int a,b;
						std::cout << "Enter a, b :: " << std::endl;
						std::cin >> a>>b;
						
						int ans = power(a,b);
						
						cout<<"Power "<<ans;
						
						return 0;
					}

						int power(int a, int b){

							if(a == 0)                  //if(!a)
								return 0;       
							
							int t=a;
							while(--b){
								a = a * t;
							}
							return a;
						}
					
					//or
						Find power of a number
						#include <bits/stdc++.h> 
						#include <iostream>
						using namespace std;

						int main() {
							int n,x;
							cin>>x>>n;
							int ans = pow(x,n);
							int mod = 1e9+7;
							cout<< ans % mod;
							return 0;
						}

				Even Odd function:
					#include <iostream>
					using namespace std;

					bool isEven(int);        //function declaration

					int main()
					{
						int a;
						std::cout << "Enter a ";
						cin >> a;
						
						// (a&1)?cout<<"Odd":cout<<"Even";      
						//or
						
						isEven(a)?cout<<" Even": cout<< " Odd";         //using function
						
						return 0;
					}

						bool isEven(int num){
							if(num % 2 ==0)
								return 1;
							return 0;
						}

				nCr= n!/(r!* (n-r)!)
					#include <iostream>
					using namespace std;

					int fact(int);
					int nCr(int, int); 	          //function declaration  its not required if 
											//we defined function before main function
											//but here we are giving the function definition after main function.
					int main()
					{
						int n,r;
						cout<<"Enter n & r :: ";
						cin>>n>>r;
						
						cout<<n<<"C"<<r<<" = "<< nCr(n,r);
						return 0;
					}

						int nCr(int a, int b){
						
						int NMR = fact(a);                  //numerator
						
						int DNMR = fact(b) * fact(a-b);                     //denominator
						
						return NMR/DNMR;
					}

					int fact(int num){
					
						if(num == 0)
							return 1;
						int t = num;
						
						for(int i=1; i<t; i++)
							num *= i;                               //num = num * i;

						return num;
					}

				Printcouting:
					//void function returns nothing, 

					#include <iostream>
					using namespace std;

					// void printCouting(int);             //function declaration no need here coz 
												//we defined the function with its definition here.

					void printCouting(int c){
					for(int i=1;i<=c;i++)
						std::cout << i << std::endl;
					}

					int main()
					{
						int n;
						cin>>n;
						
						printCouting(n);
						
						std::cout << "END" << std::endl;
						return 0;
					}

				isPrime:
					#include <iostream>
					using namespace std;

					bool isPrime(int num){
						for(int i=2; i<= num/2; i++)
							if(num % i == 0)
								return 1;
						
						return 0;
					}

					int main()
					{
						
						int n;
						cin>>n;
						
						isPrime(n)? cout<<"NO "<<n<<" is NOT Prime num" :cout<<"Yes "<<n<<" is Prime num"; 

						return 0;
					}

				NOTE:
					You can use return in void returnType function without specifying any number;
					eg.
						This is OK.
						void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;							
								return ;
							}
						
						This is not OK.
							void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;
								
								return 0;						//here return 0, void doesn't return anything will generate error.
							}

			function calling stack:
				FILO	: First in Last out
			
			-Parameter/ argument:
				Formal Parameter:
					-A variable and its type as they appear in the prototype of the function or method.
					-Formal parameters are declared in the function signature and 
					 act as placeholders for values that the function will receive.
					 eg.
					 	void displayNumber(int num); // Formal parameter: "int num"

				Actual Parameter: 
					-The variable or expression corresponding to a formal parameter that appears in 
					 the function or method call in the calling environment.
					-Actual parameters (arguments) are the specific values that are 
					 provided to the function when it is called, corresponding to the formal parameters
					eg.
						displayNumber(42); // Actual parameter: "42"

			-Pass by Value/ call by value:
				#include <iostream>
				using namespace std;
				void func(int n){						//formal parameter
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90
					func(n);											//91			//Actual parameter
					std::cout << "After func: "<< n << std::endl;			//90
					return 0;
				}

			-Pass by reference/ call by reference:
				#include <iostream>
				using namespace std;

				void func(int &n){
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90

					//pass by reference- sending memory 
					func(n);											//91
					
					std::cout << "After func: "<< n << std::endl;			//91
					return 0;
				}

			Homework:
				1)ArithmeticProgression  = 3 * n +  7 make function of it.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int n;
							std::cout << "enter n: " << std::endl;
							cin>>n;
							
							std::cout << "The Arithmetic Progression for "<< n << " is "<< (3*n)+7;
							return 0;
						}

				2)Total no.of set bits (1) from given 2 numbers.
					eg.
						2 -> 10 			->1
						3 -> 11			->2
						Total set bits : 1+2 = 3
					->
						#include <iostream>
						#include <bitset>
						using namespace std;

						int setBitCouter(int z){
							int counter=0;
							
							while(z != 0){
								if(z&1)
									counter++;
								z >>=1;
							}
							return counter;
						}

						int main()
						{
							int a,b;
							std::cout << "enter a: ";
							cin>>a;
							
							std::cout << "enter b: ";
							cin>>b;
							
							std::cout << "Binary if a :: "<< bitset<32>(a) << std::endl;
							std::cout << "Binary if b :: "<< bitset<32>(b) << std::endl;
							
							//couting the no.of setbits, for a
							int sbA = setBitCouter(a);
							
							//for b
							int sbB = setBitCouter(b);
							
							std::cout << "The no.of setbits in "<<a<< " & "<<b<<" is "<< sbA+sbB << std::endl;
							
							return 0;
						}

					#include <iostream>
					using namespace std;
					int main(){
						int n=3;
						int ans = __builtin_popcount(n);
						std::cout << ans << std::endl;
						return 0;   
					}

				3)Fibonacci series nth term function:
					input: n = 5;			// 0 1 1 2 3 5 8 13
					output: 3			//5th num of that series.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int prev= 0, curr= 1;
							
							int n;
							cout<<"Enter n:";
							cin>>n;
							
							int i=0;
							
							for(;i<n-1; i++){
								// cout<<prev<<" ";            
								
								int next = prev + curr;
								prev = curr;          
								curr = next;          
							}
							
							std::cout << "The "<< i+1 <<" number term is "<< prev << std::endl;
							return 0;
						}

			Local variable: 
				A variable declared within a function or a block of code is called a local variable. 
				Local variables are frequently used to temporarily store data in a defined 
				scope where they can be accessed and manipulated. They are stored in the memory stack, 
				Once the function or block of code in which the local variable is declared finishes executing. 
				The variable is automatically removed from the memory.

		2]. Number complement

			#include <iostream>
			#include <bitset>
			using namespace std;
			int main()
			{
				int n;
				std::cout << "Enter num : " << std::endl;
				cin>>n;
				
				cout<<"Binary of "<<n<<" "<<bitset<32>(n)<<endl;
				std::cout << "Complement of above binary "<< bitset<32>(~n) << std::endl;
				
				return 0;
			}
			
		3]. Square root of n ❌
---------------------------------------------------------------------------------------------------------
	08/08/23
Lecture-9: Introduction to Arrays in C++
	Introduction to Arrays
		-Array is a collection of variables of the same type.
		-Arrays are used to store multiple values of same Datatype in a single variable, 
		 instead of declaring separate variables for each value.
		-To declare an array, define the variable type, specify the name of the array 
		 followed by square brackets and specify the number of elements it should store

		-All arrays consist of contiguous memory locations. 
		 The lowest address corresponds to the first element and the highest address to the last element.

		-Array elements/ value we can access by INDEX.
		-Array start from 0.
		-defaultly they contain garbage value inside it.
		-use index num to access value of array on that location.
		
		-size of array = n, then till (n-1) index we can access.

		-Array declaration:
			 int a[10] ={1,2,3};         //ok
    
			int b[3] = {1,2,3};         //ok
			
			int c[] = {1,2,3,4,5,6,7};      //ok
			
			// int d[2] = {1,2,3,4,5,6,7};     //not ok
			
			// int e[];            //not ok

			// int f[10];              //not ok
			// f[10] = {1,2,2};
			// f[] = {1,2,4,3};

			int g[15];				//ok
	
		-declararing array with random/ Garbage value:
			int a[10];
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

		-Initializing all array element with 0.
			int a[10] ={0};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			-When you try to initialize some elements of array, they will get your specified value, 
				& rest all element of array elements become zero.

			--here in above case first element is initialized with 0, & rest all become will initialized with zero. 
		
		-Initializing all array element with 1 WON'T WORK ❌, only with 0 it will work.
			int a[10] ={5};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			In the above example, only the first element will be initialized to 5. All others are initialized to 0.

		--Here in below
			example you can see that if you try to initialize any position's value in array,
			then that position will get specified mentioned value, rest all by default initialized with zero.

			#include <iostream>
			using namespace std;

			int main()
			{
				int a[10] = {2,8};
				a[9]=90;
				a[5]=60;
				
				for(int i=0;i<10;i++)
					std::cout << i <<" "<<a[i]<< "\t";					
					
				return 0;
			}
				//2       8       0       0       0       60      0       0       0       90
			
		-To initialize array element with some default value,
			int a[10];
			for(int i=0;i<10;i++)
				a[i] = 4;
			
			for(int i=0; i<10;i++)
				std::cout << i << " " << a[i] << std::endl;
			
			//or using fill_n method
			std::fill_n(arrayName, arraySize, defaultValue);

			std::fill_n(a,10,90);

		string cars[4];
		eg.
		 int a[] = {1,2,3};
		 std::cout << sizeof(a) << std::endl;			//each int size is 4 so here, 12.

		 int b[] = {1,2,3,4};
		 std::cout << sizeof(b) << std::endl;			//each int size is 4 so here, 16.

		 //to print memory address of variable stored use &.
		 	int b=90;
			cout<< "memory location of B :: "<<b<<" "<<&b;

		for array just print the variable name it will give the memory address
			int a[] = {1,2,3};
			cout<< "memory location of Array a :: "<<a<<" "<<&a<<endl;			//this both a & (&a) will print the same thing.
		
		-Index accessing:
			int a[5] ={1,2,3,4,5};
				//100 , 104, 108, 112, 116			--memory address.
			
			-variable a will store the base address.
			-Suppose 100, first element's address, the next will be 104, next 108 coz size of int is 4 byte.

			a[0];			//base address	100, output value will be 1
			a[3];			//(base address + indexNum * sizeOfDatatype) =100 + 3*4 = 112, value will be 4.
        
	   	----External Link---------
			https://www.tutorialspoint.com/cplusplus/cpp_arrays.htm	
		-------------

		-If we try to access the index which is greater than size of array,
			then you will get an GARBAGE value.
		
		-Finding array length
			we can find the length using sizeof operator,
			-first find the sizeof whole array
			-then divide it by sizeof Datatype of that array.
			eg.
				int a[10];
				sizeof (a); //output : 40
				sizeof(int);	//output:4
				sizeof (a)/sizeof(int); //output : 10

			BUT,here in below case we initialized just 2 element then it should show the 
				length is 2 but according to that above method it will print length as whole 
				array size. drawback.
				eg.
					int b[10]={1,5};			//length:2
					int len = sizeof(b)/sizeof(int);		//len: 10 		(not expected this.)

		-Advance for loop in c++:
			int b[10] = {90};

			for(int j: b){
				cout<<j<<"\t";
			}

			for(int i: b)
				cout<<i<<"\t";
		
		-BAD Practice:
			int size;
			cin>>size;

			int arr[size];				//never do this.
				//instead of doing like this directly mention constant as size of array thats better,
			int arr[10000];			//this is ok than above

		-Practice:
			1.Array:
				#include <iostream>
				using namespace std;
				void printArray(int[], int);        //function declaration says that takes input parameter first as array, 2nd is integer

				int main()
				{
					//creating array & initializing
					int arr[10]= {1,2,3,4,5,6,7,8,9,10};
					
					//printing it,
					for(int i=0;i<10;i++)
						std::cout << arr[i] << "\t";
						
					std::cout << std::endl;     //or
					
					//printing using function
					printArray(arr, 10);
					
					std::cout << std::endl;
					
					//using advance loop,
					for(int j: arr)
						cout << j << "\t";
					
					return 0;
				}

				void printArray(int v[],int size){
					for(int i=0;i<size;i++)
						std::cout << v[i] << "\t";
				}

			2.Min/Max Array:
				#include <iostream>
				#include <climits>
				using namespace std;

				void getMax(int n[], int len){
					int maxi = INT_MIN;
					
					for(int a=0; a<len; a++){
						
						// if(maxi < n[a]){
						//     maxi = n[a];
						// }
						
						maxi = max(maxi, n[a]);     //it will compare these 2 values we passed then 
												// decides which one is maximum & stores maximum value.
					}
					cout<<"MAX : "<<maxi;
				}

				void getMin(int k[], int L){
					int mini = INT_MAX;
					
					for(int a=0; a<L; a++){
						
						// if(mini > k[a]){
						//     mini = k[a];
						// }
						
						//or using built in function
						mini = min(mini,k[a]);       //it will compare these 2 values we passed then 
												// decides which is min & stores minimum value
					}
					
					cout<<"Min : "<<mini;
				}

				int main(){
					int array[100];
					
					int size;
					std::cout << "Enter size of array : (should be <100)" << std::endl;
					cin>>size;
					
					std::cout << "Enter "<<size<<" elements in array :" << std::endl;
					
					//taking array elements
					for(int i=0; i<size; i++)
						cin>>array[i];
						
					//printing array
					for(int o=0; o<size; o++)
						cout<<array[o]<<" ";
					
					std::cout << std::endl;
					getMax(array,size);
					
					std::cout << std::endl;
					getMin(array,size);
					
					return 0;
				}

		-Passing array to function:
			--here passing array to function means passing memory address of that array to function,
			  so as we learnt name of array holds the base/ starting memory address of array.
			  eg.
			  	int ar[10];		//here ar holds the memory address, so if we pass ar to function
								//then we passing memory address of array, not copy of array.
			
			--so if you update the array inside any other function also, this will affect 
			  the original array.
			eg.
				#include <iostream>
				using namespace std;

				void UpdateArr(int z[], int len){
				
					z[5] = 500;			//updating value at 6th location.
					
					std::cout << "Inside Update function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<z[i]<<"\t";
						
					cout<<"\n";
				}

				int main(){
					int arr[100] = {1,2,3,4,5,6,7,8,9,10};
					
					std::cout << "Inside main function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					std::cout  << std::endl;
					UpdateArr(arr, 10);
					
					std::cout << "Back to main function again Now Array : " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					return 0;
				}
				//output:
					Inside main function array: 
					1       2       3       4       5       6       7       8       9       10
					Inside Update function array: 
					1       2       3       4       5       500     7       8       9       10
					Back to main function again Now Array : 
					1       2       3       4       5       500     7       8       9       10

				Sum of array elements:
					#include <iostream>
					using namespace std;

					int SUM(int z[], int len){	
						int sum =0; 
						
						for(int i=0;i<10;i++)
							sum += z[i];
							
						return sum;
					}

					int main()
					{
						int arr[100] = {1,2,3,4,5,6,7,8,9,-10};
						
						int sum = SUM(arr,10);
						std::cout << "Sum of Array elements :: "<< sum << std::endl;	//Sum of Array elements :: 35
						
						return 0;
					}

					//in reverse order
						int sumElement(int arr[],int n){
							int s=0;
							//Your code here
							while(n)
								s += arr[--n];
							return s;
						}


				Reverse Array:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						
						//Array
						for(int q: arr)
							std::cout << q << "\t";                 //use this advance loop if your are using whole size of array.
							
						std::cout << std::endl;
						
						//printing array in reverse way. means not reversing actual array.
						for(int i=9; i>=0; i--)
							cout<< arr[i]<<"\t";
						
						//for this you should know the length of array
						//array reversed.
						int len = 10;
						for(int i=0; i<len/2; i++){
							
							int temp = arr[i];
							arr[i] = arr[(len-1)-i];
							arr[(len-1)-i] = temp;
						}
						
						//printing original array
						std::cout << std::endl;
						for(int i: arr){
							cout<<i<<"\t";
						}
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;

						void reverse(int arr[], int n) {

							int start = 0;
							int end = n-1;

							while(start<=end) {
								swap(arr[start], arr[end]);
								start++;
								end--;
							}
						}

						void printArray(int arr[], int n) {
							
							for(int i=0; i<n; i++) {
								cout << arr[i] << " ";
							}
							cout << endl;
						}

						int main() {

							int arr[6] = {1,4,0,5,-2,15};
							int brr[5] = {2,6,3,9,4};

							reverse(arr, 6);
							reverse(brr, 5);

							printArray(arr, 6);
							printArray(brr, 5);

							return 0;
						}

				Linear search:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						int key;
						
						std::cout << "enter key: " << std::endl;
						cin>>key;
						
						for(int i=0;i<10;i++){
							if(arr[i] == key){
								std::cout << "Key Found, at "<< i << std::endl;
								break;
							}
							
							if(i==9)
								std::cout << "Key Not Found." << std::endl;             //array traversed till last but didn't found key
						}
							
						return 0;
					}
---------------------------------------------------------------------------------------------------------
	09/08/23
Lecture-10: Solving LeetCode/CodeStudio Questions [Arrays]
	Alternate swap
		i/p-> {1,2,3,4,5,6};
		o/p-> {2,1,4,3,6,5};
		->
			#include <iostream>
			using namespace std;

			void swapAlternate(int ar[], int size){
    
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = ar[i];
					//     ar[i] = ar[i+1];
					//     ar[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(ar[i],ar[i+1]);
				}
			}


			int main()
			{
				int a[100];
				
				int size;
				std::cout << "Enter size of array:" << std::endl;
				cin>>size;
				
				cout<<"Enter "<< size << "elements in array: ";
				
				//inputing array elements
				for(int i=0;i<size;i++)
					cin>>a[i];
				
				//printing array.
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";
					
				
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = a[i];
					//     a[i] = a[i+1];
					//     a[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(a[i],a[i+1]);
				}

				//or using function
				//swapAlternate(a, size);
				
				cout<<"\n";
				
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";

				return 0;
			}

	-find unique element in array
		(hint: XOR with same num will give output 0) a ^ a =0
		eg.
			5 ^ 5 = 0
		(XOR with zero & any other num will output the same num ) 0 ^ a = a
		eg.
			0 ^ 5 = 5
			0 ^ 23 = 23.
		->
			int findUnique(int arr, int size){
				int ans = 0;
				for(int i=0;i<size;i++)
					ans = ans ^ arr[i];

				return ans;
			}
	
	-check the occurence of elements are unique or not?
		bool uniqueOccurrences(vector<int>& arr) {
			vector<int> ans;

			int counter=1;
			
			for(int i=0;i<arr.size(); i++){
				int temp = arr[i];
				if(arr[i] == -2000)
					continue;
				for(int j=i+1; j<arr.size();j++){
					if(temp == arr[j]){
						arr[j] = -2000;
						counter++;
					}
				}
				ans.push_back(counter);
				counter=1;
			}

			for(int i=0; i<ans.size(); i++){
				int temp = ans[i];
				for(int j=i+1; j<ans.size(); j++){
					if(temp == ans[j])
						return false;
				}
			}
			return true;
		}

	-find duplicate element in array
		Vector- It's dyanamic kind of thing.

		//not optimized
			int n = arr.size();
			for(int o=0;o<n;o++){
				int t = arr[o];

				if(o<n-1)
					for(int i=o+1; i<n; i++)
						if(t == arr[i])
							return t;
			}
		
		//optimized
			int findDuplicate(vector<int> &arr) 
			{
				// Write your code here
				int ans =0;

				//first we initialized the ans to 0 coz xor 0 with any other num will
				//give ans as that num only.

				//then we run for loop 0 to till length of array some answer will come,
				//again we will run loop from 1 to length-1 of array means to skip any one value.
				//then the answer will be duplicate value.

				for(int a=0; a<arr.size(); a++)
					ans = ans ^ arr[a];
				
				//we are doing xor with a directly coz there is only one duplicate element
				//& array contain the element from 1 & n-1 at least once
				for(int a=1; a< arr.size(); a++)
					ans = ans ^ a;

				return ans;
			}

	-find all duplicates num in array.
		//dyamica array in c++
			#include <iostream>
			#include <vector>
			int main() {
				// Write C++ code here
				//dynamic array
				
				std::vector<int> arr = {1,2,3};
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
					
				arr.push_back(100);
				
				std::cout<<"\n";
				
				arr.push_back(200);			//inserting num in array.
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
				
				return 0;
			}

		//brute force-> TIME LIMIT EXCEEDED
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				for(int a=0; a< nums.size(); a++)
				{
					int temp = nums[a];
					for(int b =a+1; b< nums.size(); b++){
						if(temp == nums[b]){
							dual.push_back(nums[b]);
							break;
						}
					}
				}
				return dual;
			}

		//optimized
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				sort(nums.begin(), nums.end());			//built in function to sort array.

				for(int a=1; a< nums.size(); a++)
				{
					if(nums[a-1] == nums[a]){
						dual.push_back(nums[a]);
					}
				}
				return dual;
			}

			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;			//dynamic array.
				set<int> st;				//set which contains any element once only.

				for(int a=0; a< nums.size(); a++)
				{
					if(st.count(nums[a])){				//count method return 1 if that element present in set, else 0.
						dual.push_back(nums[a]);
					}else{	
						st.insert(nums[a]);				//insert method will insert that element/value into set.
					}
				}
				return dual;
			}

	-Sorting array:
		#include <iostream>
		#include <set>
		#include<algorithm> //mandatory for sort functionality
		using namespace std;

		int main() {
			// Write C++ code here
			int nums[] = {5,4,3,2,1};
			
			int len = sizeof(nums)/sizeof(nums[0]);     //calculating the length of array. 
												//this works if complete array which length is specified is filled completely, like a[100], then all 100 elements should be present.
												//or they if left length of array empty, like int arr[] = {1,2,3};
			
			for(int i=0;i<len; i++)
					cout<<" "<<nums[i];
					
			cout<<"\n";
			
			sort(nums, nums+len);			//from base(starting) address to till last
			
			//sort(starting array_memory_address, end array_memory_address);
			
			for(int i=0;i<len; i++)
				cout<<" "<<nums[i];
			return 0;
		}
	
	-sort & reverse array:
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> holder = {5,9,3,10,8,4,1,2,6,7};
			
			std::cout << "The size of array is :: " << holder.size() << std::endl;
			
			//sorting first 5 elements only.
			//output = 3,5,8,9,10,4,1,2,6,7
			
			std::cout << "Before sorting: " << std::endl;
			for(int i: holder)
				std::cout << i << "\t";             //5,9,3,10,8,4,1,2,6,7.
				
			std::cout << std::endl;
			std::cout << "After sorting first 5 elements: " << std::endl;
			
			sort(holder.begin(), holder.begin()+5);
			for(auto i: holder)
				std::cout << i << "\t";             //3,5,8,9,10,4,1,2,6,7
			
			std::cout << std::endl;
			cout<<"sorting array in increasing order: \n";
			sort(holder.begin(), holder.end());
			
			for(int o: holder)
				std::cout << o << "\t";
				
			std::cout << std::endl;
			cout<<"sorting array in decreasing order: \n";
			sort(holder.begin(), holder.end(), greater<int>());
			
			for(int o: holder)
				std::cout << o << "\t";
				
			//reversing the array
			std::cout << std::endl;
			cout<<"Reversing the given array: \n";
			reverse(holder.begin(), holder.end());
			
			for(int o: holder)
				std::cout << o << "\t";
				
			
			//sorting first 5 elements in decreasing order
			std::cout << std::endl;
			cout<<"sorting first 5 elements in decreasing order: \n";
			sort(holder.begin(), holder.begin()+5, greater<int>());
			
			for(int o: holder)
				std::cout << o << "\t";
			
			//Reversing first 6 elements
			std::cout << std::endl;
			cout<<"Reversing first 6 elements: \n";
			reverse(holder.begin(), holder.begin()+6);
			
			for(int o: holder)
				std::cout << o << "\t";
			return 0;
		}
		//output:
			The size of array is :: 10
			Before sorting: 
			5       9       3       10      8       4       1       2       6       7
			After sorting first 5 elements: 
			3       5       8       9       10      4       1       2       6       7
			sorting array in increasing order: 
			1       2       3       4       5       6       7       8       9       10
			sorting array in decreasing order: 
			10      9       8       7       6       5       4       3       2       1
			Reversing the given array: 
			1       2       3       4       5       6       7       8       9       10
			sorting first 5 elements in decreasing order: 
			5       4       3       2       1       6       7       8       9       10
			Reversing first 6 elements: 
			6       1       2       3       4       5       7       8       9       10

		// or
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;
			int main() {
				vector<int> v1 {0,9,8,7,6,5,100,4,3,2};
				for(int i: v1)
					std::cout << i << "\t";
					
				sort(v1.begin(), v1.end());
				std::cout << std::endl;
				for(int i: v1)
					std::cout << i << "\t";
					
				sort(v1.rbegin(), v1.rend());               // to sort array in descending order this one or below one
				// sort(v1.begin(), v1.end(), greater<int>());
				std::cout << std::endl;
				for(int i: v1)
					std::cout << i << "\t";
				return 0;
			}

	-Set:
		-set by default store element in ascending order,
		-set store unique elements. not duplicate.
		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.
		eg.
			std::set <data_type> set_name;

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values
			set<int> s {1,2,3};			// set assigning values without = sign
			for(int i: s)
				std::cout << i << std::endl;

			//to check element present in set or not use count method with parameter in it.
			val.count(5);			//if that value present in set it returns 1
			val.count(12);			//if that value absent in set it returns 0
		Pratical:
			#include <iostream>
			#include <set>
			using namespace std;
			int main() {
				std::set<int> a;
				a.insert(10);
				a.insert(9);
				a.insert(7);
				
				a.insert(9);        //these 2 values won't get added.
				a.insert(7);
				
				a.insert(90);
				a.insert(70);
				
				
				a.insert(23);
				a.insert(34);            //inserting into set.


				cout<<*a.begin()<<"\t";     //return first element of set.
				
				cout<< *a.end() <<"\t";       //return the last element index, Length of set, or might not be correct
				
				// to access the last element of set
				// a is acts as iterator, end() function pointing to index (last element + 1) which is out of last index
				// need to decrement iterator by one using decrement operator only. 
				// for printing the values at that index need to use dereference operator *
				std::cout << *--a.end() << std::endl;

				//length of set:
				cout<<"\n the length of set A is :: "<<a.size();

				//printing set
				for (int str : a) {
					cout << str << ' ';
				}
				
				cout<<"\n";
				cout<<"is 12 present in set A :: "<<a.count(12);			//0 means not present
				cout<<"is 10 present in set A :: "<<a.count(10);			//1 means present
				
				std::cout << '\n';
				return 0;
			}
		
			//printing char set,
			--need to define the iterator on it which is character (char) type.
				set<char> set1;
				set<char> :: iterator MY;
				for(MY = set1.begin(); MY != set1.end(); MY++){
					cout<< *MY;
				}

		// set in reverse order:
			#include <iostream>
			#include<set>
			using namespace std;
			int main() {
				
				// storing elements in reverse order in set
				set<int, greater<int>> s;
				
				for(int i=0; i<5; i++)
					s.insert(i);
					
				// first element of set
				cout<<*s.begin()<<"\n";
				
				// last element of set
				std::cout << *--s.end() << std::endl;
				
				cout<<"element of set: ";
				for(auto i=s.begin(); i != s.end(); i++)
					cout<<*i<<"\t";

				return 0;
			}

	-Array intersection (common element from 2 array).
		Intersection Of Two Sorted Arrays
		Constraints:
			1 <= T <= 100
			1 <= N, M <= 10^4
			0 <= A[i] <= 10^5
			0 <= B[i] <= 10^5
			Time Limit: 1 sec
		
		Sample Input 1 :
			2				T		test cases
			6 4				N M
			1 2 2 2 3 4		A	array 
			2 2 3 3			B	array

			3 2				N M  lengths
			1 2 3			array A
			3 4  			array B
		Sample Output 1 :
			2 2 3		
			3   
		Explanation For Sample Input 1 :
			For the first test case, the common elements are 2 2 3 in both the arrays, so we print it.
			For the second test case, only 3 is common so we print 3.
		->
			//Time Limit EXCEEDED (TLE)
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;

					for(int i=0; i<n; i++){
						int temp = arr1[i];

						for(int j=0; j<m; j++){
							if(temp == arr2[j]){
								common.push_back(temp);
								arr2[j] = -1;
								break;
							}
						}
					}
					return common;
				}
			
			//optimized:
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;
					int i=0,j=0;
					
					while(i<n && j<m){
						if(arr1[i] == arr2[j]){
							common.push_back(arr1[i]);
							i++;j++;
						}else if(arr1[i]< arr2[j]){
							i++;
						}else{
							j++;
						}
					}
					return common;
				}

	-Pair sum
		-https://www.codingninjas.com/studio/problems/pair-sum_697295
		Sample Input 1:
		5
		1 2 3 4 5
		Sample Output 1:
		1 4
		2 3

		Explanation For Sample Output 1:
		Here, 1 + 4 = 5
			2 + 3 = 5
		Hence the output will be, (1,4) , (2,3).
		
		Sample Input 2:
		0
		2 -3 3 3 -2
		Sample Output 2:
		-3 3
		-3 3
		-2 2

		#include <bits/stdc++.h>
		vector<vector<int>> pairSum(vector<int> &arr, int s){
			vector< vector<int> > ans;

			for(int i=0; i<arr.size(); i++){
				for(int j=i+1; j<arr.size(); j++){
					if(arr[i]+arr[j] == s){
						vector<int> temp;
						temp.push_back(min(arr[i], arr[j]));            
						temp.push_back(max(arr[i], arr[j]));
						ans.push_back(temp);
					}
				}
			}
			sort(ans.begin(), ans.end());
			return ans;
		}
		
	-Triplet sum:
		#include <bits/stdc++.h> 
		vector<vector<int>> findTriplets(vector<int>arr, int n, int K) {  
			sort(arr.begin(),arr.end());
				vector<vector<int>>ans;
			set<vector<int>> s;
			for(int i=0;i<n;i++){
				int sum = K - arr[i];
				int j = i+1;
				int k = n-1;
				while(j<k){
						if(arr[j]+arr[k] == sum){
							vector<int> temp;
							temp.push_back(arr[i]);
							temp.push_back(arr[j]);
							temp.push_back(arr[k]);
							sort(temp.begin(),temp.end());
							s.insert(temp);
							j++;
						}
					else if(arr[j]+arr[k]<sum){
						j++;
					}
					else{
						k--;
					}
				}
			}
			for(auto val: s){
				ans.push_back(val);
			}
			return ans;
		}

	-sort 0's & 1's:
		#include <iostream>
		using namespace std;

		void printArr(int a[], int n){
			for(int i=0;i<n; i++){
				cout<<a[i] << "\t";
			}
			cout<<"\n";
		}

		int main() {
			int arr[] = {1,1,1,1,1,0,0,0,0,0};
			int len = 10;
			printArr(arr, len);
						
			int i=0, j = len-1;
			while(i <= j ){
				if(arr[i] > arr[j]){
					swap(arr[i],arr[j]);
					i++;j--;
				}else if(arr[i] < arr[j]){
					i++;
				}else if(arr[i] ==  arr[j]){
					j--;
				}
			}
			
			printArr(arr, len);
			return 0;
		}

	-sort 0's, 1's & 2's:
		remain.. ❌
---------------------------------------------------------------------------------------------------------
	10/08/23
Lecture-11: Time & Space Complexity, How to avoid Time Limit Exceeded [TLE]
		Time Complexity:
			-It is the amount of time taken by an algorithm to run, as function of length of input.
			-the computational complexity that describes the amount of computer time it takes to run an algorithm. or
			-The Time Complexity of an algorithm/code is not equal to the actual time required to execute a particular code, 
			 but the number of times a statement executes.

			-we use time/space complexity for making better programs.
			-using these terms, we can decide algorithm is fast or slow.
			-It represented in 3 forms,
				1). Big O - Upper bound, (at max this much time program will take). worst case scenario
				2). Theta θ - Average, average case scenario.
				3). Omega Ω - Lower bound (at minimum, this much amount of time program will take) best case scenario.
			
			-Time:
				1) Constant time O(1).
				2) Linear time O(n).
				3) Logarithmic time O(log n).
				4) Quadratic time O(n²).		(nested loops)
				5) Cubic time O(n³).		(nested nested loops)

				chart: 
						O(N!)			--maximum time takes.
						O(2ⁿ)
					↑	O(n³)
					↑	O(n²)
					↑	O(n log(n))
					↑	O(n)
					↑	O(log(n))
					↑	O(1)			--minimum time takes.
			eg.
				-ignore constant, choose highest degree in equation.
					f(n) = 2n² + 3n 
					->
						O(n²)
					f(n) = 4n⁴ + 3n³
					->
						O(n⁴)
					
					f(n) = n² + log(n)
					-> O(n²).

					f(n) = 120043
					->
						O(1).
					
					f(n) = 5n³ + 3n² + 5
					->
						O(n³)
					
					f(n) = n³ / 300
					->
						O(n³)
					
					f(n) = 5n² + log(n)
					->
						O(n²)
					
					f(n) = n/4
					->
						O(n)				(Linear Time complexity)
					
					f(n) = (n+4)/4
					->
						O(n)				(Linear Time complexity)

				-Take this function to find its time complexity:
					void printArr(int a[], int n){
						for(int i=0;i<n; i++){
							cout<<a[i] << "\t";
						}
						cout<<"\n";
					}
					->
						here the length of array is n, so time depends length of array,
						so 
						Time Complexity will be O(n).
				
				-for calculating time complexity, if 2 for loops are there which are nested then their last
				value will be multiplied with eachother,
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements
					->
						time complexity: n*n  = O(n²);
					
				-if 2 for loops are there which are next to each other then we add their last value;
					for(int i=0;i<n; i++) ->	O(n)
						//statements
					
					for(j=0;j<m;j++)		-> O(m)
						//statements
					
					Time Complexity = O(n+m)

				-for this?
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements		// O(n²)
					
					for(j=0;j<n;j++)			// O(n)
						//statements
					
					= O(n²) + O(n)
					Time Complexity = O(n²)
				
				-for this?
					for(i=0;i<n;i++)			//this loop will run till (n-1)	ie.	O(n)
						for(j=n;j>i;j--)		//suppose i=0 then, this loop will run n to 0, ie. O(n)
							//statements		
					
					Time Complexity = O(n²)

		Space Complexity:
			-The total amount of memory space used by an algorithm/program, including the space of input values for execution.
			-The space complexity of an algorithm or a computer program is the amount of memory space required to solve an instance 
			 of the computational problem as a function of characteristics of the input. 
			 It is the memory required by an algorithm until it executes completely.
			-This includes the memory space used by its inputs, called input space, and any other (auxiliary) memory it uses during execution, 
			 which is called auxiliary space.

			-Similar to time complexity, space complexity is often expressed asymptotically in big O notation, such as O(n), O(n long(n)), 
			eg.
				-if we mention the array size then its fixed space complexity O(1).
				-if we declare any variable, it will take fixed space, so space Complexity O(1).
		
		eg.
			#include <iostream>
			using namespace std;
			int main() {
				vector<int> v (10,90);		//vector generally having space complexity of O(n), but here n is constant which is 10
										//so SC (space complexity): O(1)
				int i = 45;				//TC (time complexity): O(1)
				return 0;
			}
			
			#include <iostream>
			using namespace std;
			int main() {
				int n;
				cin>>n;

				vector<int> v (n,7);		//creating vector of size n with default value 7.
										//so SC (space complexity): O(n)
				int i = 45;				//TC (time complexity): O(n), The vector constructor initializes all n elements to the value 7, which takes linear time.
				return 0;
			}
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-12: Binary Search
		Binary search is applied only in list/ array where the data is sorted, 
		 either in increasing or in decreasing order, called monotonic function.
		Steps for Binary Search :
		1. Find middle element of the given array.
			If the value found at mid index is equal to key, return true else,
		2. if key >  mid,
			then go left side of the array by start = mid+1 to end is same.
		3. if Key <  mid,
			then go right side of the array from start is same & end = mid -1
		3. If key not found after searching whole array, return false.

		--here in case of binary search the Time Complexity is O(log(n)), where n is length of array.
		--because for every next iteration the array size is getting half,
		  for first len/2
		  for 2nd len/4
		  for 3rd len/8, like len/2¹, len/2², len/2³,... len/2ⁿ
		  len/2ⁿ = 1
		  len = 2ⁿ
		  n = log₂(len) 

		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[],int size){
				for(int i=0;i<size;i++){
					cout<<a[i]<<" ";
				}
				
				std::cout << std::endl;
			}

			int BinarySearch(int b[], int len, int key){
			
				int start = 0, end = len-1;
				
				//int mid = (start+end)/2;
				
				int mid = start + (end - start)/2;
    
				//sometimes array length is too large that start & end index is of (2³¹ - 1) & (2³¹ - 1) 
				//then their addition will be out of range of integer
				
				// so to avoid this issue we can use this formula,			

				while(start <= end){
					
					if(b[mid] == key)
						return mid;
					else if(key > b[mid])
						start = mid+1;
					else
						end = mid-1;
						
					mid = start + (end - start)/2;
				}
				return -1;
			}

			int main()
			{
				int Even[] = {2,4,6,8,12,14,16,22,28,30};
				int Odd[] = {1,3,5,9,13,17,41,43,59,55,69};
				
				cout<<"Even array: ";
				printArr(Even,10);
				
				
				cout<<"Odd array: ";
				printArr(Odd,11);
				
				int element;
				std::cout << "Enter element you want to find in Even array: " << std::endl;
				cin>>element;
				
				std::cout << element << " is at " << BinarySearch(Even, 10, element) << " Index." << std::endl;
				
				std::cout << "Enter element you want to find in Odd array: " << std::endl;
				cin>>element;
				std::cout << element << " is at " << BinarySearch(Odd, 11, element) << " Index." << std::endl;
				
				std::cout << "--END--" << std::endl;
			}
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-13: Questions on BinarySearch
	#Pair in C++ Standard Template Library (STL)
		-Pair is used to combine together two values that may be of different data types. 
		-Pair provides a way to store two heterogeneous objects as a single unit. 
		-It is basically used if we want to store tuples. 
		-The pair container is a simple container defined in <utility> header consisting of two data elements or objects. 

		-The first element is referenced as ‘first’ and the second element as ‘second’ and the order is fixed (first, second).
		-Pair can be assigned, copied, and compared. 
		-The array of objects allocated in a map or hash_map is of type ‘pair’ by default in which all the ‘first’ elements are unique keys associated with their ‘second’ value objects.
		-To access the elements, we use variable name followed by dot operator followed by the keyword first or second.
		Syntax: 
			pair <data_type1, data_type2> Pair_name
			eg.
				#include <iostream>
				#include <utility>
				using namespace std;
				int main()
				{
					// defining a pair
					pair<int, char> PAIR1;

					// first part of the pair
					PAIR1.first = 100;

					// second part of the pair
					PAIR1.second = 'G';

					cout << PAIR1.first << " ";
					cout << PAIR1.second << endl;

					// defining a pair
					pair<string, double> PAIR2("GeeksForGeeks", 1.23);
					
					cout << PAIR2.first << " ";
					cout << PAIR2.second << endl;

					return 0;
				}
				output:	100 G

				Initializing a Pair: We can also initialize a pair. 
					Syntax:
						pair <data_type1, data_type2> Pair_name (value1, value2) ;
					
					Different ways to initialize pair:  

						pair  g1;         //default
						pair  g2(1, 'a');  //initialized,  different data type
						pair  g3(1, 10);   //initialized,  same data type
						pair  g4(g3);    //copy of g3
						
						Another way to initialize a pair is by using the make_pair() function. 
							g2 = make_pair(1, 'a');

						Another valid syntax to declare pair is:
							g2 = {1, 'a'};
							pair<int, int> p1 {a,b};		
							pair<int, int> p1 = {a,b};
							eg.
								#include <iostream>
								using namespace std;

								int main(){
									int a = 10,b =20;

									pair<int, int> p1 {a,b};
									pair<char, string> p2('A',"First Alphabet");
									
									std::cout << p1.first<<" ";                     //10 20
									std::cout << p1.second << std::endl;
									
									std::cout << p2.first <<" ";                    //A First Alphabet
									std::cout << p2.second << std::endl;
									
									
									return 0;
								}

				Note: If not initialized, the first value of the pair gets automatically initialized. 
				
					#include <iostream>
					#include <utility>
					using namespace std;
					int main()
					{
						pair<int, double> PAIR1;
						pair<string, char> PAIR2;
						
						// it is initialised to 0
						cout << PAIR1.first;
						
						// it is initialised to 0
						cout << PAIR1.second;
						
						cout << " ";
						
						// it prints nothing i.e NULL
						cout << PAIR2.first;
							
						// it prints nothing i.e NULL
						cout << PAIR2.second;
						
						return 0;
					}
				-for more example Visit GFG pair
					1)swap
					2)make_pair
					3)tie

	1)Find the First & Last occurence of element in array:
		//Linear search method
			#include <bits/stdc++.h> 
			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				int i;
				int len = arr.size();

				for(i=0; i< len;i++){
					if(k == arr[i]){
						ans.first = i;
						break;
					}
				}
				
				if(i == len)
					ans.first = -1;
				

				for(i=len-1; i>-1; i--)
				{
					if(k == arr[i]){
						ans.second = i;
						break;
					}
				}

				if(i == -1)
					ans.second = -1;

				return ans;
			}

		//Binary search method
			#include <bits/stdc++.h> 
			int firstOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						e = mid -1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			int lastOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						s = mid + 1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				ans.first = firstOcc(arr, n, k);
				ans.second = lastOcc(arr, n, k);
				return ans;
			}

	example:To find the total no.of occurence of key in sorted array
		find the first/start index & last/end index, then 
		no.of occurence = (last - first)+1;
		eg.
			1 2 3 4 4 4 4 4 5 6 7
			--here 4's first index is 3 & last index is 7
			 so 7-3+1 = 5
			-no.of occurence of 4 is 5 times.
		
	2)Peak Index in Mountain Array:
		https://leetcode.com/problems/peak-index-in-a-mountain-array/
		//Linear or Brute force  algorithm			//TC- O(n)
			int peakIndexInMountainArray(vector<int>& arr) {
				int temp = arr[0], ans=0;
				for(int i=1; i< arr.size(); i++){
					if(temp < arr[i]){
						ans = i;
						temp = arr[i];
					}   
				}
				return ans;
			}

			//or
				class Solution {
					public:
					int peakIndexInMountainArray(vector<int>& arr) {
						for(int i=1; i<arr.size(); i++){
							if((arr[i-1]<arr[i]) && (arr[i]>arr[i+1]))
								return i;
						}
						return 0;

						//or
						//int n;
						//for(int i=1; i<arr.size(); i++){
						//	if((arr[i-1]<arr[i]) && (arr[i]>arr[i+1])){
						//		n= i;
						//		break;
						//	}
						//}
						//return n;
					}
				};
		
		//using Binary Search algorithm
			int peakIndexInMountainArray(vector<int>& arr) {
				int s=0, e= arr.size()-1;
				int mid = (s+e)/2;
				
				while(s < e){
					if(arr[mid] < arr[mid+1]){
						s = mid +1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}
				return e;
			}

	3)Find Pivot Index: HW
		-Left side summation & right side summation must be same then return the index of that element.
		//Linear search method:
			https://leetcode.com/problems/find-pivot-index/description/
			int pivotIndex(vector<int>& nums) {
				int left=0,right=0;
				int i=0;
				for(;i<nums.size(); i++){

					//for rightSide
					for(int j=i+1; j<nums.size(); j++){
						right += nums[j]; 
					}

					//for leftSide
					for(int k=0; k<i; k++){
						left += nums[k];
					}

					if(left == right)
					{
						break;
					}
					right=0; left=0;
				}

				if(i == nums.size())
						return -1;
				return i;
			}

			//or Simplified
				class Solution {
					public:
					int pivotIndex(vector<int>& nums) {

						for(int i=0; i<nums.size(); i++){
							//for left sum
							int LSum=0;
							for(int l=0; l<i; l++){
								LSum += nums[l];
							}

							//for right sum
							int RSum=0;
							for(int r=i+1; r<nums.size(); r++){
								RSum += nums[r];
							}

							if(LSum == RSum)
								return i;
						}
						return -1;
					}
				};
---------------------------------------------------------------------------------------------------------
	13/08/23
Lecture-14: Binary Search Interview Questions | Problem set-2
		Find the pivot in sorted & rotated array,
		eg.
			sorted array : [1,2,3,4,5,6,7,8,9];	
			rotated array by 3 in right direction : [7,8,9,1,2,3,4,5,6];
		-finding pivot in it,
			-> The minimum value in array is a pivot element.
		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[], int L){
				for(int i=0;i<L;i++){
					cout<<a[i]<<" ";
				}
				std::cout << std::endl;
			}

			int main()
			{
				int arr[] = {4,5,6,7,8,9,10,1,2,3};
				int len = 10;

				std::cout << "The array is : " << std::endl;
				printArr(arr, len);

				int s=0, e=len-1;
				int mid = (s+e)/2;

				while(s < e){
					if(arr[mid] >= arr[0]){
						s = mid + 1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}

				cout<<"The pivot Element is at location/index :"<<s<<" or at "<<e;
				return 0;
			}

		1). Search K In Rotated Sorted Array

			//Linear way O(n) time complexity,
				int search(vector<int>& arr, int n, int k)
				{
					// Write your code here.
					// Return the position of K in ARR else return -1.
					int i=0;
					for(;i<arr.size();i++){
						if(k == arr[i]){
							return i;
						}
					}

					if(i == arr.size())
						return -1;
				}
				
				//or
				int search(vector<int>& arr, int n, int k) {
					for(int i=0; i<arr.size(); i++)
						if(k == arr[i])
							return i;		
					return -1;
				}

			//Using Binary search O(log(n)) Time complexity,
				int BinarySearch(vector<int>& arr, int start, int n, int key){
					int s = start, e= n-1;
					int mid= (s+e)/2;
					
					while(s <= e){
						if(arr[mid] == key){
							return mid;
						}else if(key > arr[mid]){
							s = mid + 1;
						}else{
							e = mid -1;
						}
						mid = (s+e)/2;
					}
					return -1;
				}

				int pivotFind(vector<int>& arr, int len){
					
					int s=0, e = len-1;
					int mid = (s+e)/2;

					while(s < e){
						if(arr[mid] > arr[0] ){
							s = mid +1;
						}else{
							e =mid;
						}
						mid = (s+e)/2;
					}
					return s;
				}

				int search(vector<int>& arr, int n, int k){
					// Return the position of K in ARR else return -1
					int pivot = pivotFind(arr, n);
					
					if(arr[0] <= k && k <= arr[pivot-1]){
						//first line from start to till pivot
						return BinarySearch(arr, 0, pivot, k);        
					}else{
						// second line from pivot to till end.
						return  BinarySearch(arr, pivot, n, k);
					}				
				}

		2). Square Root of a number
			//Linear Search, not optimized
				int floorSqrt(int n){
					for(int i=1;i<=n/2;i++){
						if(n == pow(i,2)){
							return i;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
				}

			//using BinarySearch optimized
				int floorSqrt(int n){
					int s=0, e = n;
					long long int mid = (s+e)/2;
					long long int sqr;
					long long int ans;

					while(s <= e){
						sqr = mid * mid;
						if(sqr == n){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid -1;
						}else{
							ans = mid;
							s = mid +1;
						}
						mid = (s+e)/2;
					}
					return ans;
				}

		3). Sqrt(x):
			//Linear search not optimized
				int mySqrt(int n) {
					int i=0;
					for(;i<=n;i++){

						if(n == pow(i,2)){
							break;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
					return i;
				}
			
			//using BinarySearch 
				int mySqrt(int n) {
					int s=0, e =n;
					long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
					long long int ans;
					long long int sqr;

					while(s <= e){
						sqr = mid * mid;
						if(n == sqr){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid-1;
						}else{
							ans = mid;
							s=mid+1;
						}
						mid = (s+e)/2;
					}
					return ans;  
				}

		4). Square Root with decimal precision:
			#include <iostream>
			using namespace std;
			long long int SQRTn(int n){
				int s=0, e =n;
				long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
				long long int ans;
				long long int sqr;

				while(s <= e){
					sqr = mid * mid;
					if(n == sqr){
						ans = mid;
						break;
					}else if(sqr > n){
						e = mid-1;
					}else{
						ans = mid;
						s=mid+1;
					}
					mid = (s+e)/2;			//or mid = s + (e-s)/2;
				}
				return ans;
			}

			double morePrecision(int n, int uptoDecimal, int sqrtNum){

				double factor=1;
				double ans= sqrtNum;

				for(int i=0; i< uptoDecimal; i++){
					factor = factor/10;

					for(double j=sqrtNum; j*j < n; j = j + factor){
						ans = j;
					}
				}
				return ans;
			}

			int main(){
				int n;
				cout<<"Enter n";
				cin>>n;

				int sqrt1 = SQRTn(n);
				cout<<"answer is upto 4 decimal precision ::"<< morePrecision(n, 4, sqrt1);
				return 0;	
			}
---------------------------------------------------------------------------------------------------------
	14/08/23
Lecture-15: Allocation Problem || Aggressive Cows Problem || Binary Search Advanced Problems ❌Pending
		1). Book Allocation:
			HW- https://www.codingninjas.com/studio/problems/allocate-books_1090540
		2). Painter partition
			HW.
		3). Aggressive cows

	COME BACK TO THIS LECTURE AGAIN. 
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-16: Selection Sort
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1;i++){
			int minIndex = i;
			for(int j=i+1; j<n;j++){
				if(arr[j] < arr[minIndex])
					minIndex = j;
			}
			swap(arr[minIndex],arr[i]);
		}
	}

	//or
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1; i++){
			for(int j=i+1;j<n;j++){
				if(arr[i] > arr[j])
					swap(arr[i],arr[j]);
			}
		}
	}

	//or
	#include <bits/stdc++.h> 
	void selectionSort(vector<int>& arr, int n){
		int i,j;
		for(i=0;i<n-1;i++)
			for(j=i+1; j<n; j++)
				if(arr[i]> arr[j])
					swap(arr[i], arr[j]);
	}

	-for Selection Sort program,
		Space complexity:	O(1).
		Time complexity: O(n²);		
	
	-Use case:
		if given array/vector size is small then we can go for Selection sort.
	
	HW ❌Pending
		-Flowchart : 
		-Stable & unstable algorithm
			-a stable sorting algorithm preserves the relative order of equal keys in the input.
			examples of stable sorting algorithms:
				Bubble sort, Counting sort, Heap sort, Insertion sort, Merge sort.
			Here are some examples of unstable sorting algorithms:
				Quicksort, Radix sort, Selection sort.

	Practice:
		#include <iostream>
		using namespace std;
		void printArray(int [], int);		//or void printArray(int anyName[], int)	or if you don't give name to array still its fine, its just function declaration.

		int main() {
			int arr[] = {55,44,33,32,11,22,57,90,87,76,65,1};
			//1,11,22,32,33,44,55,57,65,76,87,90
			
			int len = 12;
			
			printf("Before Sorting :: \n");
			printArray(arr, len);
			
			int minValueIndex = arr[0];
			
			//sorting array,
			for(int i=0; i<len-1; i++){
				for(int j=i+1; j < len; j++)
					if(arr[minValueIndex] > arr[j])
						minValueIndex = j;
				
				//after getting the minimum value's index swap it, 
				swap(arr[i],arr[minValueIndex]);
			}
			printf("\nAfter Sorting :: \n");
			printArray(arr, len);

			return 0;
		}

		void printArray(int brr[], int len){
			for(int i=0;i<len;i++)
				printf("%d ",brr[i]);
		}
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-17: BUBBLE SORT
	-Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. 
	-This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.
	Bubble Sort Algorithm
		In this algorithm,
		-in i'th round the i'th largest value get placed at right position.
		-traverse from left and compare adjacent elements and the higher one is placed at right side. 
		-In this way, the LARGEST element is moved to the rightmost end in first round, at the end of array. 
		-This process is then continued to find the second largest and place it and so on until the data is sorted.
		
		Advantages of Bubble Sort:
			-Bubble sort is easy to understand and implement.
			-It does not require any additional memory space.
			-It is a stable sorting algorithm, 
			 meaning that elements with the same key value maintain their relative order in the sorted output.

		Disadvantages of Bubble Sort:
			-Bubble sort has a time complexity of O(n²) which makes it very slow for large data sets.
			-Bubble sort is a comparison-based sorting algorithm, 
			 which means that it requires a comparison operator to determine the relative order of elements in the input data set. 
			 It can limit the efficiency of the algorithm in certain cases.

	QnA:
		-In Bubble Sort, after each pass, the largest element among the unsorted elements "bubbles up" to which position?
		-> Last

		-main drawback of the Bubble Sort algorithm?
		->It has a high time complexity. ie. O(n²).

		-space complexity:
			O(1), haven't created a dynamic variable so no space complexity.

		-true regarding Bubble Sort?
		->It is an in-place sorting algorithm.
		Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. 
		Hence Bubble sort algorithm is an in-place algorithm.

		-Bubble Sort is an example of a sorting algorithm that:
		->Swaps adjacent elements directly

		-Bubble Sort is an example of a ______ sorting algorithm.
		->Comparison - based

		-worst-case time complexity of the Bubble sort Algorithm?
		->O(n²)

		-What is the maximum number of comparisons that can take place when a bubble sort algorithm is implemented?, 
		suppose there are n elements in the array.
		->	(n*(n-1))/2

		-The number of swappings needed to sort the numbers 8, 22, 7, 9, 31, 5, 13 in ascending order, using bubble sort is,
		->10

		-Assume that we use Bubble Sort to sort n distinct elements in ascending order. When does the best case of Bubble Sort occur?
		->When elements are sorted in ascending order
		the time complexity of bubble sort in the BEST-CASE scenario is O(n).

	eg.
		#include <bits/stdc++.h> 
		void bubbleSort(vector<int>& arr, int n){
			for(int i=0;i<n-1; i++)
				for(int j=0; j<n-1;j++)				//here covering the last element looping from start to till end.
					if(arr[j]> arr[j+1])
						swap(arr[j],arr[j+1]);
		}

		//or neglecting the last element as it is already sorted,
			-here i=1 to n

			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++)					
					for(int j=0; j<n-i;j++)				//here ignoring the last element from start to till n-1.
						if(arr[j]> arr[j+1])
							swap(arr [j],arr[j+1]);
			}

		//or 
			-here i=0 to (n-1)
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n) {
				
				for(int i=0; i<n-1; i++)
					for(int j=0; j < n-i-1; j++)
						if(arr[j] > arr[j+1])
							swap(arr[j],arr[j+1]);
			}

			//optimizing more:
				-if not a single swapping done, then array is already sorted
				#include <bits/stdc++.h> 
				void bubbleSort(vector<int>& arr, int n) {

					for(int i=0; i<n-1; i++){
						int flag = 1;
						for(int j=0; j < n-i-1; j++)
							if(arr[j] > arr[j+1]){
								swap(arr[j],arr[j+1]);
								flag = 0;
							}

						if(flag)
							break;      // not a single swapping done, so break loop & exit.
					}
				}
		
		//optimizing more.., 
		 in a random round there is no any swapping done, then we can consider that it's sorted.
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++){
					bool isSwappingOn = false;

					for(int j=0; j<n-i;j++)				// (n-i) means the last i element no need to check, coz its already sorted.
						if(arr[j] > arr[j+1]){
							swap(arr [j],arr[j+1]);
							//swapping on..
							isSwappingOn = true;
						}
					if(isSwappingOn == false)
						break;        
				}
			}
		
	HW:
		Q. stable or unstable bubble sort?
			-Bubble sort is stable algorithm
		
		Q. in-place sort
			In-place sorting means sorting without using any extra space requirement. 
			Quicksort is one example of In-Place Sorting.

			In-place sorting is an algorithm that sorts data without using any additional memory. 
			This is in contrast to out-of-place sorting algorithms, 
			which require some additional memory to store the sorted data.
			
			There are many different in-place sorting algorithms, including:
			1) Selection sort:
				Selection sort works by repeatedly finding the smallest element 
				in the unsorted portion of the array and swapping it with the leftmost unsorted element.
			
			2) Insertion sort:
				Insertion sort works by repeatedly inserting the current element into the sorted portion of the array, one element at a time.

			3) Bubble sort:
				Bubble sort works by repeatedly comparing adjacent elements in the array and swapping them 
				if they are in the wrong order.

			4) Merge sort:
				Merge sort works by recursively dividing the array into smaller and smaller subarrays, 
				sorting each subarray, and then merging the sorted subarrays back together.

			5) Quicksort:
				Quicksort works by choosing a pivot element in the array and then 
				partitioning the array into two subarrays, 
				one containing all the elements smaller than the pivot and the other 
				containing all the elements larger than the pivot. 
				Quicksort is then recursively applied to each subarray.

			In-place sorting algorithms are often preferred over out-of-place sorting algorithms 
			because they require less memory. 
			
			However, in-place sorting algorithms can be slower than out-of-place sorting algorithms, 
			especially for large arrays.

		Q. Adaptive sorting algorithm:
			An adaptive sorting algorithm is a sorting algorithm that can efficiently handle input data 
			that is already partially sorted or nearly sorted. 
			These algorithms take advantage of the existing order in the input data to improve their performance.
			eg.
				Bubble sort, Selection sort, Insertion sort, Merge sort, Quicksort.
---------------------------------------------------------------------------------------------------------
	16/08/23	
Lecture-18: INSERTION SORT
	Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. 
	The array is virtually split into a sorted and an unsorted part. 
	Values from the unsorted part are picked and placed at their correct position in the sorted part.

	-shifting of element done here.
	-https://www.geeksforgeeks.org/insertion-sort/

	-code:
		#include <bits/stdc++.h> 
		void insertionSort(int n, vector<int> &arr){
			for(int i=1; i<n; i++){
				int temp = arr[i],j;
				for(j=i-1; j>=0; j--){
					if(temp< arr[j]){
						//shifting
						arr[j+1] = arr[j]; 
					}else{
						break;
					}
				}
				arr[j+1] = temp;
			}
		}
	
	//or Practice:
		#include <bits/stdc++.h> 
		void insertionSort(int n, vector<int> &arr){
			for(int i=1; i<n; i++){
				int crntVal = arr[i];
				int j;

				for(j=i-1; j>=0; j--){
					if(arr[j] < crntVal)
						break;
					arr[j+1] = arr[j];
				}
				arr[j+1] = crntVal;
			}
		}

	Characteristics of Insertion Sort
		-This algorithm is one of the simplest algorithms with a simple implementation
		-Basically, Insertion sort is efficient for small data values
		-Insertion sort is adaptive in nature, i.e. it is appropriate for data sets that are already partially sorted.

	-insertion sort is a STABLE sorting algorithm.
	-insertion sort is a ADAPTABLE sorting algorithm.
	-Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, 
	 and only a few elements are misplaced in a complete big array.
	
	Time complexity:
		O(n²)
		-Best-Case : O(n);
		-Worst-case: O(n²)
	space complexity:
		O(1)
	
	HW:
		//using while loop
		#include <bits/stdc++.h> 
		void insertionSort(int n, vector<int> &arr){
			int i=1;

			while(i<n){
				int crntVal = arr[i];
				int j = i-1;

				while(j>=0){
					if(arr[j] < crntVal)
						break;
					arr[j+1] = arr[j];
					j--;
				}
				arr[j+1] = crntVal;
				i++;
			}
		}
---------------------------------------------------------------------------------------------------------
	17/08/23
Lecture-19: C++ STL (Standard Template Library)
	-Algorithm
	-Containers

	1) STD::array in C++:
		The array is a collection of homogeneous objects and this array container is defined for constant size arrays or (static size). 
		This container wraps around fixed-size arrays and the information of its size are not lost when declared to a pointer. 
		In order to utilize arrays, we need to include the array header:
			#include <array>

			Syntax:
				array<object_type, arr_size> arr_name;

			a)[] Operator : This is similar to the normal array, we use it to access the element store at index ‘i’ .
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <char , 3> arr={'G','f','G'};
						cout<<arr[0] <<" "<<arr[2];			//G G
						return 0;
					}
			
			b) front( ) and back( ) function: 
				-These methods are used to access the first and the last element of the array directly.
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				
			c) swap( ) function: 
				-This swap function is used to swap the content of the two arrays.
					Ex: 
					#include <iostream>
					#include <array>
					using namespace std;
				
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						arr.swap(arr1);  // now arr = {M,M,P}
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				eg.
					#include <iostream>
					#include<array>
					using namespace std;

					int main()
					{
						//double or single braces works fine.
						array<int, 5> a {1,2,3,4};
						array<int, 5> b {{10,20,30,40,150}};
						array<int, 5> c {1,2,3,4,5};
						
						cout<<"A:\n";
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nB : " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
							
						a.swap(b);
						std::cout << "\nAfter swapping: Array A:  " << std::endl;
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nAfter swapping: Array B:  " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
					}

			d)empty(): to check array is empty or not
				first need to cout boolalpha then after print the boolean value, if you print boolean values 
				before cout boolalpha then it will printed like 0,1.
				eg.
					bool x = arr.empty(); // false ( not empty)
					cout<<boolalpha;		//or cout<<boolalpha<<(x);				
					bool y = 1;
					cout<<y;
					cout<<"\n"<<x;

				-boolalpha is a manipulator used in C++ for the std::cout stream (the standard output stream) 
				to display boolean values as their corresponding textual representations "true" or "false," 
				rather than as integer values 1 or 0.
			
			e) at() function: 
				This function is used to access the element stored at a specific location, 
				if we try to access the element which is out of bounds of the array size then it throws an exception. 
				Ex: 
					#include <iostream>
					#include <array>
					using namespace std;

					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						cout<< arr.at(2) <<" " << arr1.at(2);
						//cout<< arr.at(3); // exception{Abort signal from abort(3) (SIGABRT)}
						return 0;
					}
					Output
						71 80

			f) fill( ) function: 
				This is specially used to initialize or fill all the indexes of the array with a similar value.
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 5> arr;
						arr.fill(1);
						for(int i: arr)
							cout<<arr[i]<<" ";
						return 0;
					}
						Output
						1 1 1 1 1 

			g) size( ) or max_size( ) and sizeof( ) function: 
				Both size( ) or max_size( ) are used to get the maximum number of indexes in the array 
				while sizeof( ) is used to get the total size of array in bytes.

				#include <iostream>
				#include <array>
				using namespace std;				
				int main() {
					array <int , 10> arr;   
					cout<<arr.size()<<'\n'; // total num of indexes
					cout<<arr.max_size()<<'\n'; // total num of indexes
					cout<<sizeof(arr); // total size of array
					return 0;
				}
				Output
					10
					10
					40

		eg.
			#include <iostream>
			#include <array>
			using namespace std;

			int main()
			{
				int arr[] = {1,2,3};            //static array
							
				array<int, 4> a = {1,2,3,4};        //this is also static array
				
				std::cout << "Size : "<< a.size() << std::endl;     //to get the length of array    //Size : 4
				
				//printing the array element
				for(int i: a){
					cout<<i<<"\t";              //1       2       3       4
				}
				std::cout << std::endl;
				
				for(int it=0; it<a.size(); it++)
					cout<<a[it]<<" ";               //1       2       3       4
					
				//First last element of array
				std::cout << "\n\n First element of array A :: "<< a.front() << endl;           //  First element of array A :: 1
				std::cout << " Last element of array A :: "<< a.back()<<endl;                   //   Last element of array A :: 4
				
				//random index of array
				std::cout << "\n3rd index : "<< a[3] << std::endl;                  // 3rd index : 4
				std::cout << "2nd index : "<< a.at(2) << std::endl;                 // 2nd index : 3
				
				//checking the array is empty or not?
				cout<<"Array A is empty : "<<a.empty();                         // array is not empty so, Array A is empty : 0
				
				return 0;
			}

		eg.
			#include <iostream>
			#include<array>

			//for sorting algorithm need to include,
			#include <algorithm>
			using namespace std;

			int main()
			{
				//double or single braces works fine.
				array<int, 5> a {1,2,3,4};
				array<int, 5> b {{1,2,3,4,15}};
				array<int, 5> c {1,2,3,4,5};
				
				//printing array
				for(auto i: a){
					std::cout << i <<" ";
				}
				std::cout << std::endl;
				
				for(auto i: b){
					printf("%d ",i);
				}
				
				
				//sort
				std::cout << std::endl;
				array<int, 5> d = {5,4,3,2,1};          //equal sign with single braces.
						
				for(auto i: d)
					cout<<i<<" ";
					
				std::cout  << std::endl;
				
				//after sorting
				sort(d.begin(), d.end());
				
				
				//if you just try to print the begin() function on array it will print the memory location of that array
				//so to print the element at that address Use asterisk.
				
				cout<<"Beging memory address: "<<d.begin()<<"\n";
				cout<<"starting element: "<<*d.begin()<<"\n";
				
				cout<<"End: "<<*d.end()<<"\n";
				
				for(auto i: d)
					cout<<i<<" ";
					
				array<int, 3> e = {{}};         //equal sign with double braces.
				
				
				//by default array e gets initialized with 0.
				cout<<"\n";
				for(int o: e){
					cout<<o<<" ";
				}
				
				
				//initializing array e with default specific element with 97,
				cout<<"\n";
				e.fill(97);
				for(auto i: e)
					cout<<i<<" ";
					
				//initializing string array
				cout<<"\n";
				array<string, 5> strings {"Vivek","Nikate","a","b"};
				
				for(string s: strings)
					cout<<s<<"\t";
					
				//printing string array
				cout<<"\n";
				for(auto s: strings)
					cout<<s<<"\t";

				return 0;
			}

	2) Vector:
		-It's a dynamic array.
		-Vectors are the same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, 
		 with their storage being handled automatically by the container. Vector elements are placed in contiguous storage 
		 so that they can be accessed and traversed using iterators. 
		 In vectors, data is inserted at the end. Inserting at the end takes differential time, 
		 as sometimes the array may need to be extended. Removing the last element takes only constant 
		 time because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.
		 
					vector::push_back() 								|	vector::pop_back()
				It is used to add a new element at the end of the vector. 		|	It is used to remove a new element at the end of the vector.
				Its parameter is the value we want to add in the end of vector. 	|	It does not take any parameters.
				It does not have any return type.							|	It does not have any return value.
				Its complexity is constant.								|	Its complexity is constant.
				`container.push_back(element);							| 	container.pop_back();
			Container-    Vector, Deque, List, etc. 						| 	Vector, Deque, List, etc..
			Effects  -    Increases container size by 1 						|	 Decreases container size by 1.

		-std::vector in C++, It is defined inside the <vector> header file.

		Reverse Vector:
			#include <iostream>
			#include<vector>
			// this algorithm header file is for reverse method,
			#include <algorithm>
			using namespace std;

			int main()
			{
				vector<int> v {10,9,8,7,6,5,4,3,2,1};
				std::cout << "Size "<< v.size() << std::endl;       //Size 10
				
				for(auto i: v)
					cout<<i<<" ";                               // 10 9 8 7 6 5 4 3 2 1 
					
				reverse(v.begin(), v.end());
				
				cout<<"\n After reversing: ";
				for(auto i: v)
					cout<<i<<" ";                               // After reversing: 1 2 3 4 5 6 7 8 9 10 

				return 0;
			}

			//Initialize an array with consecutive numbers using std::iota

				#include <iostream>
				#include <vector>
				#include<numeric>               //for iota 
				#include<algorithm>             //for reversing
				using namespace std;
				int main(){
					vector<int> v(10);
					
					iota(v.begin(), v.end(), 9);        // from 9 to 18
					
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 14 15 16 17 18
						
					reverse(v.begin()+5,v.end());       //reverse after 5th index
					
					cout<<"\n";
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 18 17 16 15 14
					
					return 0;
				}

		Practice:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main()
			{
				vector<int> v;
				
				//Capacity- means how many elements it can contain.
				//Size- means how many elements it is containing/ contained now.
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;
				std::cout << "Size- "<<v.size() << std::endl;
				
				v.push_back(1);
				v.push_back(2);
				v.push_back(3);
				v.push_back(4);
				v.push_back(5);
				v.push_back(48);
				v.push_back(45);
				
				v.push_back(18);
				v.push_back(345);
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //capacity gets double everytime if size is greater than capacity value.
					std::cout << "Size- "<<v.size() << std::endl;                   //9
				
				for(auto i: v)
					cout<<i<<" ";
					
				std::cout << "\nAfter Popping last element : " << std::endl;
				v.pop_back();
				
				for(auto i: v)
					cout<<i<<" ";
					
				v.clear();
				
				std::cout  << std::endl;
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //after clearing also capacity is same.
				std::cout << "Size- "<<v.size() << std::endl;                   //size reduce back to 0.
				return 0;
			}

		-vector initialization:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> a;      //size=0
				std::cout << a.size() << std::endl;
				
				vector<int> b(5);   //size=5, but all element are by default initialized to 0.
				std::cout << b.size() << std::endl;
				
				for(auto i:b)
					cout<<i<<" ";
					
				//vector with initializing default value,
				//vector<DataType> VectorName(size, defaultValue);
				vector<int> c(10, 580);     //10 element having all value 580.
				
				cout<<"\n";
				for(int i: c)
					cout<<i<<" ";
					
				//copying vector from another
				vector<int> d(c);        //copying vector c to d.
				
				cout<<"\n vector D: ";
				for(int i: d)
					cout<<i<<" ";
				
				//inserting value to specific index,
				cout<<"\n";
				
				d.insert(d.begin(),34);     //at start
				d.insert(d.begin()+4,23);     //at 4th index
				
				cout<<"\n vector D After insertion: ";
				for(int i: d)
					cout<<i<<" ";
					
					//inserting specific no.of same element to vector  
					cout<<"\n vector e :";
				vector<int> e(5,4);
				for(int i: e)
					cout<<i<<" ";
				
				std::cout<<"\nAfter insertion 99 in vector e: " << std::endl;
				//vector_name.insert(position, size (no.of times to be inserted), val (defaultValue) )
				e.insert(e.begin()+2, 5, 99);              //inserting 780, 5 times after 2nd index.
				
				for(int i: e)
					cout<<i<<" ";

				return 0;
			}

		eg.
			#include <iostream>
			#include <vector>

			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 5; i++)
					g1.push_back(i);						//inserting element into the vector.

				cout << "Output of begin and end: ";
				for (auto i = g1.begin(); i != g1.end(); ++i)
					cout << *i << " ";						//Output of begin and end: 1 2 3 4 5 

				cout << "\nOutput of cbegin and cend: ";
				for (auto i = g1.cbegin(); i != g1.cend(); ++i)
					cout << *i << " ";						//Output of cbegin and cend: 1 2 3 4 5 

				cout << "\nOutput of rbegin and rend: ";
				for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir)
					cout << *ir << " ";						//Output of rbegin and rend: 5 4 3 2 1 

				cout << "\nOutput of crbegin and crend : ";
				for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir)
					cout << *ir << " ";						//Output of crbegin and crend : 5 4 3 2 1

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 10; i++)
					g1.push_back(i * 10);

				cout << "\nReference operator [g] : g1[2] = " << g1[2];			//Reference operator [g] : g1[2] = 30

				cout << "\nat : g1.at(4) = " << g1.at(4);                   //element at 4th index (means 0-based indexing so 5th)
				//at : g1.at(4) = 50

				cout << "\nfront() : g1.front() = " << g1.front();          //first element
				//front() : g1.front() = 10

				cout << "\nback() : g1.back() = " << g1.back();             //last element
				//back() : g1.back() = 100

				// pointer to the first element
				int* pos = g1.data();           //storing the base address of vector g1 here.

				cout << "\nThe first element is " << *pos;          //accessing first/base element
				//The first element is 10
				
				cout << "\nThe 9th element is " << *(pos+8);
				//The 9th element is 90

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			#include <vector>
			using namespace std;

			int main()
			{
				// Assign vector
				vector<int> v;

				// fill the vector with 10 five times
				v.assign(5, 10);

				//or you can pass array in assign
				v.assign({23,24,55,46,57,78});

				cout << "The vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 15 to the last position
				v.push_back(15);
				int n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// removes last element
				v.pop_back();

				// prints the vector
				cout << "\nThe vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 5 at the beginning
				v.insert(v.begin(), 5);

				cout << "\nThe first element is: " << v[0];

				// removes the first element
				v.erase(v.begin());

				cout << "\nThe first element is: " << v[0];

				// inserts at the beginning
				v.emplace(v.begin(), 5);
				cout << "\nThe first element is: " << v[0];

				// Inserts 20 at the end
				v.emplace_back(20);
				n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// erases the vector
				v.clear();
				cout << "\nVector size after clear(): " << v.size();

				// two vector to perform swap
				vector<int> v1, v2;
				v1.push_back(1);
				v1.push_back(2);
				v2.push_back(3);
				v2.push_back(4);

				cout << "\n\nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";

				// Swaps v1 and v2
				v1.swap(v2);

				cout << "\nAfter Swap \nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";
			}
			Output:
				The vector elements are: 10 10 10 10 10 
				The last element is: 15
				The vector elements are: 10 10 10 10 10 
				The first element is: 5
				The first element is: 10
				The first element is: 5
				The last element is: 20
				Vector size after erase(): 0

				Vector 1: 1 2 
				Vector 2: 3 4 
				After Swap 
				Vector 1: 3 4 
				Vector 2: 1 2
		
		-Erase method:
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
					// Assign vector
				vector<int> v;
				
				// fill the vector with 10 five times
				v.push_back(10);
				v.push_back(20);
				v.push_back(30);
				v.push_back(40);
				v.push_back(50);
				
				for(auto i: v)
					std::cout << i << " ";
				
				v.erase(v.begin()+3);       //removing 4th element 40.
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
					
					v.erase(v.begin());     //removing first element
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
				
				return 0;
			}

		Time Complexity of Vector:
			-The time complexity for doing various operations on vectors is-
				Random access – constant O(1)
				Insertion or removal of elements at the end – constant O(1)
				Insertion or removal of elements – linear in the distance to the end of the vector O(N)
				Knowing the size – constant O(1)
				Resizing the vector- Linear O(N)
		
		◉ NOTE:
			if you mention the size of vector while declaring it, like vector<int> ans(n); or vector<int> ans(5);
			then don't use push_back() to insert element at the end,
			directly use the index where you want to insert the value.
			like
				ans[0] = 1;
				ans[1] = 2;
				//no			ans.push_back(1);

	3) Deque:
		-Doubly ended queue
		-Means you can perform insertion/Deletion (push/ pop) operation from both ends, front & back.
		-Its implementation is bit complex, it uses static array not on contiguous location
		-It is DYNAMIC.
		-Random Access of element is possible
		-The deque::max_size() is a built-in function in C++ STL,
		 which returns the maximum number of elements that a deque container can hold.
			Syntax:
				deque_name.max_size()

			Parameters: The function does not accept any parameters.
			Return Value: The function returns the maximum number of elements that a deque container can hold.
			eg.
				int main(){
					deque<int> dq;
					
					cout << "The max-size of deque: " << dq.max_size();			//The max-size of deque: 4611686018427387903	
					return 0;
				}
			
		eg.
			#include <iostream>
			#include<deque>
			using namespace std;

			int main()
			{
				deque<int> d;
				
				//inserting at ending,
				d.push_back(1);
				d.push_back(2);
				d.push_back(3);
				d.push_back(4);
				d.push_back(5);
				
				d.push_front(100);
				d.push_front(200);
				d.push_front(300);
				d.push_front(400);
				d.push_front(500);
				
				for(auto i: d)
					std::cout << i << " ";          //500 400 300 200 100 1 2 3 4 5 

				//Removing element from start       //500
				d.pop_front();
				
				//Removing element from back        //5
				d.pop_back();
				
				cout<<"\nAfter removal : \n ";
				for(auto i: d)
					std::cout << i << " ";                  // 400 300 200 100 1 2 3 4 
					
				//accessing first index element
				cout<<"\nFirst index element : "<<d[1];     //First index element : 300
				
				//using at()
				cout<<"\n4th index element : "<<d.at(4);    //4th index element : 1
					
				//start element
				std::cout << "\n Start element : "<< d.front() << std::endl;            //Start element : 400
				
				//end element
				
				std::cout << "End element : "<< d.back() << std::endl;                  //End element : 4
				
				std::cout << "deque empty? : "<<boolalpha<< d.empty() << std::endl;     //0 or false, its not empty.
				
				std::cout << "Deque Size : "<< d.size() << std::endl;                   //Deque Size : 8
				
				std::cout << "Capacity : "<< d.max_size() << std::endl;                 //Capacity : 2305843009213693951
				
				//Deleting range of elements from 3 to 5, 3rd & 4th only not 5th.
				d.erase(d.begin()+3, d.begin()+5);              //100 1
				
				cout<<"\nDeleted few elements: ";
				for(auto i: d)
					std::cout << i << " ";                  // Deleted few elements: 400 300 200 2 3 4 
				
				//Deleting all elements
				d.clear();
				std::cout << "\nDeque Size : "<< d.size() << std::endl;                   //Deque Size : 0

				return 0;
			}

	4) List:
		-Lists are sequence containers that allow non-contiguous memory allocation. 
		-As compared to the vector, the list has slow traversal, but once a position has been found, 
		 insertion and deletion are quick (constant time). 
		-Normally, when we say a List, we talk about a doubly linked list. For implementing a singly linked list, 
		 we use a forward_list.

		-std::list is the class of the List container. 
		-It is the part of C++ Standard Template Library (STL) and is defined inside <list> header file.
		-Random access is not possible.
		Points to Remember about List Container:-
			-It is generally implemented using a dynamic doubly linked list with traversal in both directions.
			-Faster insert and delete operation as compared to arrays and vectors.
			-It provides only sequential access. Random Access to any middle element is not possible
			-It is defined as a template so it is able to hold any data type.
			-It operates as an unsorted list would, which implies that by default, the list’s order is not preserved. However, there are techniques for sorting.

		Syntax:
			std::list <data-type> name_of_list;
			eg.
				list<int> L;
		
		eg.
			#include <iostream>
			#include <list>
			using namespace std;

			int main()
			{
				list<int> L;
				
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;          //The size of List :: 0

				
				L.push_back(90);            //insertion at back
				L.push_back(100);
				
				L.push_front(910);          //insertion at front side
				L.push_front(800);
				
				for(auto i:L)
					cout<<i<<" ";           //800 910 90 100 
					
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;      //The size of List :: 4
				
				std::cout << "\nThe max size of List :: "<< L.max_size();           //The max size of List :: 384307168202282325
				
				//deleting start element      //800
				//you can't delete random element coz list doesn't provide random access to element.
				
				L.erase(L.begin());
				cout<<"\n start element removed : ";            // start element removed : 910 90 100 
				for(auto i:L)
					cout<<i<<" ";
					
				//copy
				list<int> n(L);
				cout<<"\n copied list : ";
				for(auto i:L)
					cout<<i<<" ";                       //copied list : 910 90 100 
					
				//list with default value 0
				
				//list<DataType> list_name(size)
				list<int> a(5);         
				
				cout<<"\n List A: ";
				for(int i:a)
					cout<<i<<" ";           // List A: 0 0 0 0 0 
					
				//list<DataType> list_name(size, DefaultValue);
				
				list<int> b(7, 31);         
				
				cout<<"\n List B: ";
				for(int i:b)
					cout<<i<<" ";           //  List B: 31 31 31 31 31 31 31 
				
				L.clear();      //deleting all list element,
				cout << "\n The size of List AFTER CLEARING :: "<< L.size();            // The size of List AFTER CLEARING :: 0

				return 0;
			}

	5) Stack:
		-LIFO (Last In First Out).
		-new element is added at one end (top) and an element is removed from that end only.
		-Operations:
			push(), pop(), top(), size(), empty() all are having Time complexity of O(1)
		
		eg.
			#include <iostream>
			#include <stack>
			using namespace std;

			int main(){
				stack<string> stsr;
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        //Size of Stack :: 0
				
				stsr.push("Vivek");
				stsr.push("Mahesh");
				stsr.push("Saraswait");
				stsr.push("Rohini");
				stsr.push("Computer");
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;					//TOP element of stack : Computer
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        					//Size of Stack :: 5

				stsr.pop();
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;								//TOP element of stack : Rohini
				
				std::cout << "Stack empty? :: "<< stsr.empty() << " " << boolalpha <<stsr.empty() << std::endl;		//Stack empty? :: 0 false
				return 0;
			}

	6) Queue:
		-operate in a first in first out (FIFO) type of arrangement. 
		-Elements are inserted at the back (end) and are deleted from the front.
		-operations:
			push(), pop(), front(), back(), emplace(), size(), empty() all are have Time complexity of O(1).

		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				queue<string> sq;
				
				std::cout << "Size of Queue before insertion : "<< sq.size() << std::endl;
				
				sq.push("First");
				sq.push("Second");
				sq.push("Third");
				sq.push("Forth");
				
				std::cout << "Size of Queue After insertion : "<< sq.size() << std::endl;
				
				std::cout << "start element of Queue : "<< sq.front() << std::endl;
				
				std::cout << "Last element of Queue : "<< sq.back() << std::endl;
				
				sq.pop();
				
				std::cout << "start element After poping : "<< sq.front() << std::endl;
				
				std::cout << "Queue empty? : "<< boolalpha <<sq.empty() << std::endl;
				return 0;
			}

			//output:
				Size of Queue before insertion : 0
				Size of Queue After insertion : 4
				start element of Queue : First
				Last element of Queue : Forth
				start element After poping : Second
				Queue empty? : false

		emplace operation used to insert element in queue:{
			queue<char> myqueue;
			myqueue.emplace('k');
			myqueue.emplace('j');
			myqueue.emplace('y');
			myqueue.emplace('r');
			myqueue.emplace('y');
			myqueue.emplace('u');
			
			// queue becomes k, j, y, r, y, u
			
			while (!myqueue.empty())
			{
				cout << ' ' << myqueue.front();
				myqueue.pop();
			}
			return 0;
		}

	7) Priority Queue:
		https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/
		Time complexity:
			push(), pop() on priority queue is of O(logN).
			top(), size() & empty() are constant time operations O(1).
		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				priority_queue<int> pq;     //by default it creates max-heap(decreasing order).
				
				std::cout << "Size : "<< pq.size() << std::endl;        //Size : 0

				pq.push(1);
				pq.push(3);
				pq.push(5);
				pq.push(2);
				pq.push(4);
				
				std::cout << "First element : "<< pq.top() << std::endl;        //First element : 5
				int pqSize = pq.size();
				
				std::cout << "Size : "<< pqSize << std::endl;           //Size : 5

				for(int i=0;i<pqSize;i++){
					cout<<pq.top()<<" ";            //5 4 3 2 1 
					pq.pop();
				}
				
				//min heap increasing order
				priority_queue<int, vector<int>, greater<int>> min;
				
				min.push(100);
				min.push(200);
				min.push(400);
				min.push(300);
				min.push(500);
				
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty(); //Min priority_queue is empty ? 0
				int minSize= min.size();
				
				cout<<"\n Min elements : ";
				
				for(int i=0;i<minSize;i++){
					cout<<min.top()<<" ";                   //Min elements : 100 200 300 400 500 
					min.pop();
				}
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty();     //Min priority_queue is empty ? 1
				return 0;
			}

	8) Set:
		-Stores unique elements
		-The values are stored in a specific sorted order i.e. either ascending or descending.
		-By default, the std::set is sorted in ascending order.
		-The std::set class is the part of C++ Standard Template Library (STL) and it is defined inside the <set> header file.
		-Syntax:
			std::set <data_type> set_name;

		-we have the option to change the sorting order by using the following syntax.
		-Syntax:
			std::set <data_type, greater<data_type>> set_name;

		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values
		
		Properties-
			Storing order – The set stores the elements in sorted order.
			Values Characteristics – All the elements in a set have unique values.
			Values Nature – The value of the element cannot be modified once it is added to the set, 
						though it is possible to remove and then add the modified value of that element. Thus, the values are immutable.
			Search Technique – Sets follow the Binary search tree implementation.
			Arranging order – The values in a set are unindexed.
		Note: To store the elements in an unsorted(random) order,  unordered_set() can be used.
		-set is little slower than unordered_set.

		•The time complexities for doing various operations on sets are:
			-Insertion of Elements – O(log N)
			-Deletion of Elements – O(log N)
			-insert(), find(), erase(), count() -> O(long N)
			-size(), begin(), empty(), end() -> O(1).
		eg.
			#include <iostream>
			#include <set>
			using namespace std;
			int main(){
				std::set<char> a;
				a.insert('A');
				a.insert('B');
				a.insert('E');
				a.insert('D');
				a.insert('C');
				
				//repeated element will not be inserted again in set.
				a.insert('B');
				a.insert('A');
				
				
				//sorted increasing order,
				for (auto& str : a) {           //& sign used
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (auto str : a) {                //& not used still fine
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (char str : a) {                //dataType char used.
					std::cout << str << ' ';
				}
				
				set<int> inSt;
				inSt.insert(100);
				
				inSt.insert(1);
				inSt.insert(1);
				
				inSt.insert(2);
				
				inSt.insert(5);
				inSt.insert(5);
				
				inSt.insert(4);
				inSt.insert(200);
				
				cout<<"\n";
				for(int i: inSt)
				cout<<i<<" ";
				
				//Decreasing order set
				set<int, greater<int>> descSet;
				
				descSet.insert(0);
				descSet.insert(1);
				
				descSet.insert(3);
				descSet.insert(3);
				
				descSet.insert(4);
				
				
				descSet.insert(200);
				descSet.insert(200);
				descSet.insert(300);
				
				descSet.insert(400);
				
				descSet.insert(2);
				descSet.insert(2);
				
				//descSet 
				cout<<"\n";
				for(int i: descSet)
				cout<<i<<" ";
				
				//erasing
				set<int>::iterator IT = descSet.begin();
				IT++;
				IT++;
				
				descSet.erase(IT);
				cout<<"\n Erased 2nd element:";
				for(int i: descSet)
				cout<<i<<" ";
				
				//deleting 300 from set, directly passing element which want to delete.
				descSet.erase(300);
				cout<<"\n 300 erased: ";
				for(int i: descSet)
				cout<<i<<" ";
				
				cout<<"\n400 is present in descSet ? "<<descSet.count(400);
				cout<<"\n300 is present in descSet ? "<<descSet.count(300);
				
				cout<<"\ndescSet empty? "<<descSet.empty();

				cout<<"\ndescSet max_size? "<<descSet.max_size();
				cout<<"\ndescSet size? "<<descSet.size();
				
				descSet.clear();
				cout<<"\ndescSet empty? "<<descSet.empty();
				
				return 0;
			}
			//output:
				A B C D E 
				A B C D E 
				A B C D E 
				1 2 4 5 100 200 
				400 300 200 4 3 2 1 0 
				Erased 2nd element:400 300 4 3 2 1 0 
				300 erased: 400 4 3 2 1 0 
				400 is present in descSet ? 1
				300 is present in descSet ? 0
				descSet empty? 0
				descSet max_size? 230584300921369395
				descSet size? 6
				descSet empty? 1

	9) Map:
		-Stores data in form of key-value pair
		-all keys are unique, one key points to one value only.
		-same keys will not points to different value,
		-value of keys might be same.
		-keys stored in sorted order.
		-Time Complexity:
			insert(), erase(), find(), count() is O(log N).
		eg.

			#include <iostream>
			#include <map>
			using namespace std;

			int main(){
				map<int, string> m;
				std::cout << " Before, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;
				
				m[4] = "Vivek";
				m[70] = "Seven";
				m[80] = "EIGHT";
				m[3] = "Rohini";
				m[2] = "Nikate";
				m[1] = "Aai";
				m[50] = "papa";
				
				m.insert({-10,"Minus num"});
				m.insert({-11, "minus 11"});

				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";

				std::cout << "After, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;

				//key present
				std::cout << "4 key present? "<< m.count(4) << std::endl;
				std::cout << "40 key present? "<< m.count(40) << std::endl;

				//erase
				m.erase(2); //key 2 removed
				m.erase(-11); //key 2 removed
				
				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";
				
				cout<<"\n";
				//print all element after key 4.
				auto it = m.find(4);
				for(auto i=it; i != m.end(); i++)
					cout<<(*i).first<<" "<<(*i).second<<"\n";
				
				return 0;
			}

	10) STL Algorithm:
		sort() works on introsort, its combination of quick sort, heap sort & insertion sort.
		eg.
			#include <algorithm>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> v={11,55,44,33,22,23,78,90,45,67,879,675};
				
				std::cout << "Vector size : "<< v.size() << std::endl;
				
				//find 22 (not working properly)
				std::cout << "22 present? "<< binary_search(v.begin(), v.end(), 55) << std::endl;
				std::cout << "upper_bound : "<< upper_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				std::cout << "lower_bound : "<< lower_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				

				int a=90, b=40;
				std::cout << "MAX of A & B : "<< max(a,b) << std::endl;
				std::cout << "min of A B"<< min(a,b) << std::endl;

				printf("A: %d, B: %d", a,b);
				swap(a,b);
				printf("\nA: %d, B: %d", a,b);
				
				string str = "asdfghjkl";
				std::cout << "String : "<< str << std::endl;
				
				reverse(str.begin(),str.end());
				std::cout << "Reverse String : "<< str << std::endl;

				std::cout  << std::endl;
				//rotate
				for(auto i:v)
					cout<<i<<" ";
				
				rotate(v.begin(), v.begin()+3, v.end());
				
				std::cout  << std::endl;
				for(auto i:v)
					cout<<i<<" ";
					
				//sorted
				sort(v.begin(), v.end());
				std::cout << std::endl << "Sorted: ";
				for(auto i:v)
					cout<<i<<" ";
				return 0;
			}
			//output:
				Vector size : 12
				22 present? 0
				upper_bound : 10
				lower_bound : 10
				MAX of A & B : 90
				min of A B40
				A: 90, B: 40
				A: 40, B: 90String : asdfghjkl
				Reverse String : lkjhgfdsa

				11 55 44 33 22 23 78 90 45 67 879 675 
				33 22 23 78 90 45 67 879 675 11 55 44 
				Sorted: 11 22 23 33 44 45 55 67 78 90 675 879
---------------------------------------------------------------------------------------------------------
	27/08/23
Lecture-20: LeetCode Practice:
		1) Reverse Vector:
			-reverse(startIndex, endIndex);
			-reverse function defined in the algorithm header file.
			using built in function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					std::cout  << std::endl;
					reverse(v.begin(), v.end());
					
					cout<<"After: ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";

					return 0;
				}

			Without using builtint function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				vector<int> REVERSE(vector<int> a){
					int start=0, end = a.size()-1;
					
					while(start <= end){
						swap(a[start], a[end]);
						start++;
						end--;
					}
					
					return a;
				}

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					
					vector<int> ans= REVERSE(v);
					
					cout<<"\nAfter: ";
					for(int i=0;i<ans.size();i++)
						cout<<ans[i]<<" ";

					return 0;
				}
			
		2) Reverse The Array:
			-Reversing array from given position
			eg.
				Sample Input 1:
				2
				6 3
				1 2 3 4 5 6
				5 2
				10 9 8 7 6
				Sample Output 1:
				1 2 3 4 6 5
				10 9 8 6 7
				Explanation 1:
				For the first test case, 
				Considering 0-based indexing we have M = 3 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {1, 2, 3, 4, 6, 5}.

				For the second test case, 
				Considering 0-based indexing we have M = 2 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {10, 9, 8, 6, 7}.
				Sample Input 2:
				2
				7 3
				1 4 5 6 6 7 7 
				9 3
				10 4 5 2 3 6 1 3 6
				Sample Output 2:
				1 4 5 6 7 7 6
				10 4 5 2 6 3 1 6 3 

			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				return reverse(arr.begin()+m+1,arr.end());
			}

			//or
			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				int start = m+1, end = arr.size()-1;
				while (start <= end) {
					swap(arr[start], arr[end]);
					start++;
					end--;
				}
			}
		
		3) Merge Sorted Array:
			void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
				vector<int> nm;
				int i=0,j=0;
				while(i<m && j<n){
					if(nums1[i] < nums2[j]){
						nm.push_back(nums1[i++]);
					}else{
						nm.push_back(nums2[j++]);
					}
				}

				while(i < m)
					nm.push_back(nums1[i++]);

				while(j < n)
					nm.push_back(nums2[j++]);
				
				//nums1.clear();
				nums1 = nm;
			}
		
			#Program:
				#include<iostream>
				#include<vector>
				using namespace std;

				void merge(int arr1[], int n, int arr2[], int m, int arr3[]) {
					int i = 0, j = 0;
					int k = 0;
					while( i<n && j<m) {
						if(arr1[i] < arr2[j]){
							arr3[k++] = arr1[i++];
						}
						else{
							arr3[k++] = arr2[j++];
						}
					}

					//copy first array k element ko
					while(i<n) {
						arr3[k++] = arr1[i++];
					}

					//copy kardo second array k remaining element ko
					while(j<m) {
						arr2[k++] = arr2[j++];
					}
				}

				void print(int ans[], int n) {
					for(int i=0; i<n; i++) {
						cout<< ans[i] <<" ";
					}
					cout << endl;
				}

				int main(){
					int arr1[5] = {1,3,5,7,9};
					int arr2[3] = {2,4,6};

					int arr3[8] = {0};

					merge(arr1, 5, arr2, 3, arr3);
					print(arr3, 8);
					return 0;
				}

		4) Move Zeroes:
			Given an integer array nums, move all 0's 
			to the end of it while maintaining the relative order of the non-zero elements.
			Note that you must do this in-place without making a copy of the array.
				Example 1:

				Input: nums = [0,1,0,3,12]
				Output: [1,3,12,0,0]
				Example 2:

				Input: nums = [0]
				Output: [0]
			->
				void moveZeroes(vector<int>& nums) {
					int len = nums.size();
					int cnt =0;
					vector<int> temp;
					for(int i=0;i<len;i++){
						if(nums[i] == 0)
							cnt++;
						else
							temp.push_back(nums[i]);
					}
					for(int i=0; i<cnt; i++)
						temp.push_back(0);
					
					nums = temp;
				}

				//or
					int i=0;
					for(int j=0;j<nums.size(); j++)
						if(nums[j] != 0)
							swap(nums[i++], nums[j]);
				
				//or
					int cnt=0;
					for(int i=0;i<nums.size();i++)
						if(nums[i] != 0)
							nums[cnt++] = nums[i];
					
					while(cnt<nums.size())
						nums[cnt++] = 0;
		
		5) Subarray or not?
			#include <iostream>
			using namespace std;

			bool isSubArr(int mainArr[], int orSize, int part[], int partSize){
				if(partSize > orSize)
					return 0;
				
				int k=0,i;
				for(i=0;i<partSize;){
					if(part[i] == mainArr[k]){
						for(int tr = k;;tr++){
							if((i < partSize) && tr != orSize && part[i] == mainArr[tr]){
								i++;
								if(i == partSize)
								return 1;
								continue;
							}else{
								return 0;
							}
						}
					}
					if(k >= orSize)
					break;
					k++;
				}
				return 0;
			}

			int main(){
				int arr[] = {1,2,3,4,5,6,7,8,9,10}, len=10;
				
				int sub[] = {13,14,15};
				int nSub[] = {6,7,8,9,10,11};
				int largerSizeArr[] = {1,2,3,4,5,6,7,8,9,10,11};
				
				int testArr1[] = {4,5,6,7}, testLen1 = 4;
				int testArr2[] = {8,9,10}, testLen2 = 3;
				int testArr3[] = {9,10,11,12}, testLen3 = 4;
				int testArr4[] = {11,12,15,16,20}, testLen4 = 5;

				isSubArr(arr, len, sub, 3)? std::cout << "Sub is SubArray " << std::endl : std::cout << "Sub is not SubArray" << std::endl;
				isSubArr(arr, len, nSub, 6)? std::cout << "nSub is SubArray " << std::endl : std::cout << "nSub is not SubArray" << std::endl;
				isSubArr(arr, len, largerSizeArr, 11)? std::cout << "largerSizeArr is SubArray " << std::endl : std::cout << "largerSizeArr is not SubArray" << std::endl;
				
				isSubArr(arr, len, testArr1, testLen1)? std::cout << "testArr1 is SubArray " << std::endl : std::cout << "testArr1 is not SubArray" << std::endl;
				isSubArr(arr, len, testArr2, testLen2)? std::cout << "testArr2 is SubArray " << std::endl : std::cout << "testArr2 is not SubArray" << std::endl;
				isSubArr(arr, len, testArr3, testLen3)? std::cout << "testArr3 is SubArray " << std::endl : std::cout << "testArr3 is not SubArray" << std::endl;
			
				//not SubArray
				isSubArr(arr, len, testArr4, testLen4)? std::cout << "testArr4 is SubArray " << std::endl : std::cout << "testArr4 is not SubArray" << std::endl;

				return 0;
			}
---------------------------------------------------------------------------------------------------------
	3/09/23
Lecture-21: Solving LeetCode/CodeStudio Questions [Arrays]
		1) Rotate Array
			Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
				Example 1:

				Input: nums = [1,2,3,4,5,6,7], k = 3
				Output: [5,6,7,1,2,3,4]
				Explanation:
				rotate 1 steps to the right: [7,1,2,3,4,5,6]
				rotate 2 steps to the right: [6,7,1,2,3,4,5]
				rotate 3 steps to the right: [5,6,7,1,2,3,4]
				Example 2:

				Input: nums = [-1,-100,3,99], k = 2
				Output: [3,99,-1,-100]
				Explanation: 
				rotate 1 steps to the right: [99,-1,-100,3]
				rotate 2 steps to the right: [3,99,-1,-100]

			// Not Optimized:
				class Solution {
					public:
					void rotate(vector<int>& nums, int k) {
						while(k--){
							int val = nums.back();
							nums.pop_back();

							nums.insert(nums.begin(), val);
						}
					}
				};

			class Solution {
				public:
				void rotate(vector<int>& nums, int k) {
					int n = nums.size();
					vector<int> temp(n);

					for(int i=0;i<n;i++)
						temp[(i+k)%n] = nums[i];

					nums = temp;
				}
			};

			// or
				 class Solution {
					public:
					void rotate(vector<int>& nums, int k) {
						//if(k >= nums.size())
							k %= nums.size();
						reverse(nums.begin(), nums.end());
						reverse(nums.begin(), nums.begin()+k);
						reverse(nums.begin()+k, nums.end());
					}
				};
		
		2) Check if Array Is Sorted and Rotated:
			https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/
			class Solution {
				public:
				bool check(vector<int>& nums) {
					int cnt=0;
					for(int i=1;i<nums.size();i++)
						if(nums[i-1] > nums[i])
							cnt++; 
					if(nums[nums.size()-1] > nums[0])
						cnt++;
					return cnt<=1;
				}	
			};

			// or
				class Solution {
					public:
					bool check(vector<int>& nums) {
						int n = nums.size()-1;
						while(n--){
							if(is_sorted(nums.begin(), nums.end()))
								return 1;
							reverse(nums.begin(), nums.end());
							reverse(nums.begin(), nums.begin()+1);
							reverse(nums.begin()+1, nums.end());
						}
						if(is_sorted(nums.begin(), nums.end()))
							return 1;
						return 0;
					}
				};

		3) Sum Of Two Arrays:
			Sample Input 1:
				2
				4 1 
				1 2 3 4
				6
				3 2
				1 2 3
				9 9    
				Sample Output 1:
				1 2 4 0
				2 2 2
				Explanation For Sample Input 1:
				For the first test case, the integer represented by the first array is 1234 and the second array is 6, so the sum is 1234 + 6 =  1240.

				For the second test case, the integer represented by the first array is 123 and the second array is 99, so the sum is 123 + 99 = 222.
				Sample Input 2:
				2
				3 3 
				4 5 1
				3 4 5
				2 2
				1 1
				1 2
				Sample Output 2:
				7 9 6
				2 3

			#include <bits/stdc++.h> 
			int convertor(vector<int> , int);
			vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {

				int n1 = convertor(a, n);
				int n2 = convertor(b, m);

				int sum = n1 + n2;

				vector<int> sample;

				while(sum){
					int temp = sum % 10;
					sample.push_back(temp);
					sum /=10;
				}

				reverse(sample.begin(), sample.end());
				return sample;	
			}

			int convertor(vector<int> a, int len){
				int num =0;
				//array to num
				for(int i=0;i<len;i++)
					num = num * 10 + a[i];

				return num;
			}

			#include <bits/stdc++.h> 
			vector<int> findArraySum(vector<int>& a, int n, std::vector<int>& b, int m) {
				vector<int> v;
				int i = n - 1;
				int j = m - 1;
				int carry = 0;

				while (i >= 0 && j >= 0) {
						
					int sum = a[i--] + b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//first array len is greater than second
				while (i >= 0) {
					int sum = a[i--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//second array len is greater than first
				while (j >= 0) {
					int sum = b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//carry is remain to add
				while (carry != 0) {
					int sum = carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}
				return v;
			}
---------------------------------------------------------------------------------------------------------
	14/09/23
Lecture-22: All about Char Arrays, Strings & solving LeetCode Questions
		-String: 1D (one-dimensional char array.)
		 '\0' - end of string, present at the end of string (null character).
		 #include <iostream>
		 using namespace std;
		 int main(){
			char name[10];
		 	std::cout << "Enter name : " << std::endl;
		 	
		 	cin>>name;      //cin stop taking input after getting space, new line or tab.
		 	std::cout << name << std::endl;
		 	
		 	// Enter name : 
			// Vivek Nikate
			// Vivek
			return 0;
		}

		-if null character found then compiler consider it as the end of string.
			eg.
			#include <iostream>
			using namespace std;
			int main(){
				char name[15];
				std::cout << "Enter name : " << std::endl;
				
				cin>>name;      //cin stop taking input after getting space, new line or tab.
				name[3] = '\0';	//after 3rd index compiler consider it as end of string.
				std::cout << name << std::endl;
				
				// Enter name : 
				// VivekNikate
				// Viv
				
				return 0;
			}

		// WAP to find the Length of string
			#include <iostream>
			using namespace std;
			int main(){
				char name[15];
				std::cout << "Enter name : " << std::endl;
				
				cin>>name;
				int len=0;

				while(name[len++] != '\0');	
				std::cout << "The Length of string is :: "<< len-1 << std::endl;
				return 0;
			}
			Enter name : 
			Vivek
			The Length of string is :: 5
		
		//String
			#include <iostream>
			using namespace std;
			int main(){
			
				// string s;        //for printf statement string won't work.
				char s[100];
				std::cout << "Enter name: " << std::endl;
				cin>>s;
				
				printf("Your name : %s ",s);
				cout<<"your name: "<<s;
				return 0;
			}

		- WAP Reverse a string:
			#include <iostream>
			#include<algorithm>
			using namespace std;
			int main(){
				
				string s;
				std::cout << "Enter name: " << std::endl;
				cin>>s;
				string temp = s;
				std::cout << "Your name : " <<s<< std::endl;
				
				reverse(s.begin(), s.end());
				//or
				cout<<"reverse : "<<s<<endl;
				
				s = temp;
				cout<<"Length of string is :: "<< s.size()<<endl;             //Length using size() function
				cout<<"Length of string is :: "<< s.length()<<endl;           //Length using length() function
				
				//or custom calculating length of string
				int i=0;
				while(s[i++] != '\0');
				cout<<"Length of string is :: "<< i-1<<endl;
				
				int start =0;
				int len = i-2;
				while(start <= len){
					swap(s[start++],s[len--]);
				}
				
				cout<<"Reverse string custom :"<< s <<endl;
				return 0;
			}		

		- Reverse String
			https://leetcode.com/problems/reverse-string/description/
			class Solution {
			public:
				void reverseString(vector<char>& s) {
					// reverse(s.begin(), s.end());
					int start=0,end=s.size()-1;
					while(start<end)
						swap(s[start++],s[end--]);
				}
			};

			// or
				class Solution {
					public:
					void reverseString(vector<char>& s) {
						int n = s.size();
						for(int i=0; i<n/2; i++)
							swap(s[i], s[n-1-i]);
					}
				};
			
			// or
				class Solution {
					public:
					void reverseString(vector<char>& s) {
						reverse(s.begin(), s.end());
					}
				};

		- Check If The String Is A Palindrome
			#include <bits/stdc++.h> 
			bool checkPalindrome(string s){
				string ans;
				for(int i=0;i<s.length();i++){
					if(('a' <= s[i] && s[i] <= 'z') || 
						('A'<=s[i] && s[i] <='Z') || ('0'<=s[i] && s[i] <='9'))
						ans += s[i];


					//or for above if condition,
						//after converting to lowercase
						//if((isalpha(s[i])) || isdigit(s[i]))	 //to check isalphabate or not and isdigit or not.
						//	ans += s[i];
				}

				//or to check is Alphabet or number,
				//for(int i=0;i<s.length();i++){
				//     if(isalnum(s[i]))
				//         ans += s[i];
				// }

				transform(ans.begin(), ans.end(), ans.begin(), ::tolower);
				string temp = ans;
				reverse(temp.begin(), temp.end());
				if(ans == temp)
					return 1;
				return 0;
			}

			//converting Uppercase char to lower
				char toLowerCase(char ch) {
					if(ch >='a' && ch <='z')
						return ch;
					else
						char temp = ch - 'A' + 'a';
					return temp;
				}

			//upper to lower or viceversa,
				#include <iostream>
				using namespace std;
				int main(){
					char ch1 = 'u', ch2='v', ch3='D';
					std::cout << char(ch1-32) << std::endl;             //U
					std::cout << char(ch2-32) << std::endl;             //V
					std::cout << char(ch3+32) << std::endl;             //d
					
					return 0;
				}

				//or
					#include <iostream>
					using namespace std;
					char TOLOWER(char);
					char TOUPPER(char);
					int main(){
						char ch1 = 'A', ch2 = 'b';
						
						cout<<TOLOWER(ch1)<<endl;
						cout<<TOUPPER(ch2)<<endl;
						return 0;
					}

					char TOLOWER(char ch){
						return ch - 'A' + 'a';
					}

					char TOUPPER(char ch){
						return ch - 'a' + 'A';
					}

			//Palindrome:
				#include<string>
				#include<iostream>
				#include<vector>
				using namespace std;
				class Solution {
					private:
					bool valid(char ch) {
						if( (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
							return 1;
						}
						
						return 0;
					}
					
					char toLowerCase(char ch) {
						if( (ch >='a' && ch <='z') || (ch >='0' && ch <='9') )
							return ch;
						else{
							char temp = ch - 'A' + 'a';
							return temp;
						}
					}

					bool checkPalindrome(string a) {
						int s = 0;
						int e = a.length()-1;

						while(s<=e) {
							if(a[s] != a[e])
							{
								return 0;       
							}
							else{
								s++;
								e--;
							}
						}
						return 1;
					}
					public:
					bool isPalindrome(string s) {
						
						//faltu character hatado
						string temp = "";
						
						for(int j=0; j<s.length(); j++) {   
							if(valid(s[j])) {
								temp.push_back(s[j]);
							}
						}
						
						//lowercase me kardo
						for(int j=0; j<temp.length(); j++) { 
							temp[j] = toLowerCase(temp[j]);
						}
						
						//check palindrome
						return checkPalindrome(temp);	
					}
				};

			//without using extra space or temp string:
				#include <bits/stdc++.h> 
				bool checkPalindrome(string s){
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					int i=0, j = s.size()-1;
					while(i<j){
						if(!isalnum(s[i])){
							i++;
							continue;
						}
						if (!isalnum(s[j])) {
							j--;
							continue;
						}
						if (s[i] != s[j])
							return false;
						i++;
						j--;
					}
					return true;
				}

			//or
				#include <bits/stdc++.h> 
				bool checkPalindrome(string s){
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					int i=0, j = s.size()-1;
					while(i<j){
						if (isalnum(s[i])) {
							if(isalnum(s[j])){
								if(s[i] == s[j]){
									i++;j--;
									continue;    
								}else{
									return false;
								}
							}else{
								j--;
							}
						}else{
							i++;
						}
					}
					return true;
				}

		- simple Palindrome checker:
			#include <iostream>
			using namespace std;
			int main(){
				string s;
				cout<<"Enter string to check Palindrome or not?"<<endl;
				cin>>s;
				
				int i=0;
				for(i;i<s.length()/2;i++)
					if(s[i] != s[s.length()-1-i]){
						cout<<"Not Palindrome";
						break;
					}
					
				if(i == s.length()/2)
					cout<<"Palindrome";
				return 0;
			}

		- Valid Palindrome
			https://leetcode.com/problems/valid-palindrome/description/
			 class Solution {
				public:
				bool isPalindrome(string s) {		
					transform(s.begin(), s.end(), s.begin(), ::tolower);
					string ans;

					for(int i=0;i<s.length() ; i++){
						if((s[i] >= 'a' && s[i] <= 'z') || (s[i]>='0' && s[i] <='9'))
							ans += s[i];
					}
					s = ans;
					reverse(ans.begin(), ans.end());
					return (ans == s)? true:false;
				}
			};

			//or
				class Solution {
					public:
					bool isPalindrome(string s) {
						transform(s.begin(), s.end(), s.begin(), ::tolower);
						int i=0,j=s.length()-1;
						while(i<j){
							if(!isalnum(s[i])){
								i++;
								continue;
							}
							if(!isalnum(s[j])){
								j--;
								continue;
							}
							if(s[i] != s[j])
								return false;
							i++;j--;
						}
						return true;
					}
				};

		//String Operations:
			#include <iostream>
			using namespace std;

			int main(){
			
				string s = "Hello World";
				cout<<s<<endl;
				
				s.pop_back();
				cout<<s<<endl;                      //removing element from last.
				
				s.push_back('V');                   //adding element at last or s = s + 'V';
				cout<<s<<endl;
				
				cout<<s.front()<<endl;              //first element of string
				cout<<s.back()<<endl;               //last element of string
				
				cout<<s.at(4)<<endl;                //char at 4th index (0-based index)
				
				cout<<"String length is :: "<<s.length()<<endl;

				s.erase(2,3);
				cout<<s<<endl;                  //from index 2nd remove 3 char here llo got removed.

				cout<<"String length After erasing :: "<<s.length()<<endl;
				return 0;
			}

		// upper/lower case char conversion
			#include <iostream>
			#include <algorithm>
			using namespace std;
			int main(){
				string s = "Hello World";
				
				std::cout << s << std::endl;

				std::cout << char(tolower('A')) << std::endl;
				
				//string upper to lower case
				transform(s.begin(), s.end(), s.begin(), ::tolower);
				// transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
				std::cout << s << std::endl;
				
				transform(s.begin(), s.end(), s.begin(), ::toupper);
				std::cout << s << std::endl;
				
				return 0;
			}

		//convert string to uppercase or lowercase
			#include <iostream>
			#include <algorithm>
			using namespace std;

			int main(){
				string s1 = "VIVEK", s2="nikate", s3 = "third", s4 = "this is first letter capital sentence.";
				
				transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
				std::cout << s1 << std::endl;
				
				transform(s2.begin(), s2.end(), s2.begin(), ::toupper);
				std::cout << s2 << std::endl;
				
				s3[0] = toupper(s3[0]);
				std::cout << s3 << std::endl;
				
				int i=0;
				while(s4[i] != '\0'){
					if(i==0) s4[i] = toupper(s4[i]);
					if(isblank(s4[i])) s4[i+1] = toupper(s4[i+1]);
					i++;
				}

				std::cout << s4 << std::endl;	
				return 0;
			}

		Char Array:
			#include <iostream>
			int main(){
				char str[] = "sadf\0tyuio";
				std::cout << str[0] << std::endl;
				std::cout << str << std::endl;
				
				char ch[] = {'v','i','\0','v','e','k'};
				cout<<ch;
				return 0;
			}

			differences (string & char array):
				-String refers to a sequence of characters represented as a single data type. 
				-Character Array is a sequential collection of data type char.

			  Characteristic					String					Char array
				Data type						Class				 	 Array
				Size							Dynamically allocated		 Fixed size
				Null terminator				Automatically appended		 Not automatically appended
				Memory management				Automatic					 Manual
				Operations					Supported					 Not supported
				Speed						Slower					 Faster
				Safety						Safer					 Less safe

		// Reverse sentence:
			Sample Input 1 :
				Welcome to Coding Ninjas
				Sample Output 1:
				Ninjas Coding to Welcome
				Explanation For Sample Input 1:
				You need to reduce multiple spaces between two words to a single space in the reversed string and observe how the multiple spaces, leading and trailing spaces have been removed.
			Sample Input 2 :
				I am a star
				Sample Output 2:
				star a am I
				Explanation For Sample Input 2:
				Your reversed string should not contain leading or trailing spaces.

			string reverseString(string &str){
				vector<string> ans;
				int i=0;

				while(i<str.length()){
					if(str[i] == ' '){
						i++;
						continue;
					}

					string temp;
					while(str[i] != ' ' && str[i] !='\0'){
						temp += str[i];

						i++;
					}
					ans.push_back(temp);
				}

				i=ans.size()-1;
				str = "";
				while(i>=0){
					str += ans[i];
					if( i!=0)
						str += ' ';
					i--;
				}
				return str;	
			}

		// Reverse Words in a String III
			Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
				Example 1:

				Input: s = "Let's take LeetCode contest"
				Output: "s'teL ekat edoCteeL tsetnoc"
				Example 2:

				Input: s = "God Ding"
				Output: "doG gniD"
			https://leetcode.com/problems/reverse-words-in-a-string-iii/description/
			class Solution {
			public:
				string reverseWords(string s) {
					string temp;
					vector<string> holder;

					int i=0;
					while(i<s.length()){
						if(s[i] == ' '){
							i++;
							continue;
						}

						while(s[i] != ' ' && s[i] != '\0'){
							temp += s[i];
							i++;
						}
						holder.push_back(temp);
						temp="";
						i++;
					}

					s="";
					
					for(int a=0;a<holder.size();a++){
						string st =  holder[a];
						reverse(st.begin(), st.end());
						s += st;
						if(a != holder.size()-1)
							s += " ";               // s = s + ' ' or s = s + " ";
					}
					return s;
				}
			};

			//or
				class Solution {
					public:
					string reverseWords(string s) {
						string revSentence;
						string word;
						for(int i=0; i<s.length(); i++){
							if(s[i] == ' '){
								reverse(word.begin(), word.end());
								revSentence += word + " ";
								word = "";
								continue;
							}
							word += s[i];
						}

						//code to add last word
						reverse(word.begin(), word.end());
						revSentence += word;

						return revSentence;
					}
				};

		// Print first n Fibonacci Numbers
			Given a number N, find the first N Fibonacci numbers. The first two number of the series are 1 and 1.
				Example 1:

				Input:
				N = 5
				Output: 1 1 2 3 5
				Example 2:

				Input:
				N = 7
				Output: 1 1 2 3 5 8 13
				Your Task:
				Your task is to complete printFibb() which takes single argument N and returns a list of first N Fibonacci numbers.

				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(N).
				Note: This space is used to store and return the answer for printing purpose.

				Constraints:
				1<= N <=84

			class Solution{
				public:
				//Function to return list containing first n fibonacci numbers.
				vector<long long> printFibb(int n){
					long long prev=1, curr =1;
					vector<long long> ans;
					ans.push_back(curr);
					
					if(n == 1)
						return ans;
						
					ans.push_back(prev);
					if(n ==2)
						return ans;
					
					for(int i=2;i<n;i++){
						long long fib = curr + prev;
						prev = curr;
						curr = fib;
						ans.push_back(fib);
					}
					return ans;
				}
			};

		// Nth Fibonacci Number:
			class Solution {
				public:
				int nthFibonacci(int n){
					int cur=1,prev=0;
					int mod = 1e9+7;
					if(n == 0)
						return prev;
					else if(n==1)
						return cur;
					else
						for(int i=2;i<=n;i++){
							int fib = (cur +prev) % mod;
							prev = cur;
							cur = fib;
						}

					return cur;
				}
			};

		// Maximum Occuring Character
			Given a string str of lowercase alphabets. The task is to find the maximum occurring character in the string str. 
			 If more than one character occurs the maximum number of time then print the lexicographically smaller character.
				Example 1:

				Input:
				str = testsample
				Output: e
				Explanation: e is the character which
				is having the highest frequency.
				Example 2:

				Input:
				str = output
				Output: t
				Explanation:  t and u are the characters
				with the same frequency, but t is
				lexicographically smaller.
				Your Task:
				The task is to complete the function getMaxOccuringChar() which returns the character which is most occurring.

				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(Number of distinct characters).
				Note: N = |s|

				Constraints:
				1 ≤ |s| ≤ 100
			class Solution{
				public:
				//Function to find the maximum occurring character in a string.
				char getMaxOccuringChar(string str){
					int cnt=1,prev=cnt;
					char mainCh = str[0];
					for(int i=0;i<str.length();i++){
						for(int j=0;j<str.length();j++){
							if(str[i] == str[j])
								cnt++;
						}
						
						if(cnt> prev || (cnt >= prev && str[i] < mainCh)){
							mainCh = str[i];
							prev=cnt;
						}
						cnt=1;
					}
					
					return mainCh;
				}
			};

			//or
				class Solution{
					public:
					//Function to find the maximum occurring character in a string.
					char getMaxOccuringChar(string str){
						int arr[26] = {0};
						for(int i=0; i<str.length();i++){
							int num;
							//between lowercase     
							if(str[i]>='a' && str[i]<='z'){
								num = str[i] - 'a';
							}else{      //between uppercase
								num = str[i] - 'A';
							}
							arr[num]++;
						}
						
						int mx=arr[0], index=0;
						for(int i=0;i<26;i++){
							if(mx<arr[i]){
								mx = arr[i];
								index = i;
							}
						}
						return char('a'+index);
					}
				};

		// WAP to take string as input
			#include <iostream>
			using namespace std;
			int main(){
				
				string s;
				std::cout << "Enter name: (stop taking input when we hit enter) " << std::endl;
				getline(cin, s);                //getline function works for string datatype only.
				cout<<s<<endl;
				
				
				// for character datatype use cin.getline(char_array_name, max_size) function,
				char str[100];
				std::cout << "Enter name again:" << std::endl;
				cin.getline(str, 50);
				std::cout << str << std::endl;
				
				//ending string with some particular delimiter
				//$
				//when user enter $ it stop taking input
				//whatever comes after $ it will not consider it.
				std::cout << "Enter name : delimiter" << std::endl;
				cin.getline(str,100, '$');
				std::cout << str << std::endl;
				
				
				std::cout << "Enter name: delimit by * " << std::endl;
				getline(cin, s, '*');                //getline function works for string datatype only.
				cout<<s<<endl;
				
				//delimiter by [
				std::cout << "Enter name: delimiter [ : " << std::endl;
				cin.getline(str, 100, '[');
				std::cout << str << std::endl;
				
				s="";
				//delimiter with string, stop taking input when you encounter ^.
				std::cout << "Enter name for string delimiter :" << std::endl;
				getline(cin,s,'^');
				std::cout << s << std::endl;
				return 0;
			}

		// char array Operation:
			#include <iostream>
			#include<cstring>
			using namespace std;

			int main(){
				char s1[] ="Vivek_Mahesh_Nikate";
				char s2[] ="Nikate";
				char s3[] ="Vivek";
					
				std::cout << strlen(s1) << std::endl;           //strlen function works with char array only.
				
				std::cout << strcmp(s2,s1) << std::endl;        //s1-s2 first string is smaller so -ve answer
				std::cout << strcmp(s1,s2) << std::endl;        //s2-s1 first string is larger so +ve answer
				
				//if both are equal then 0
				std::cout << strcmp(s3,s1) << std::endl;
				
				std::cout << s1 << std::endl;
				
				//after copying s1 is:
				strcpy(s1,"New_String");        //strcpy(source, destination), strcpy(place_to_take_new_value, new_value),
				std::cout << s1 << std::endl;
				
				char s4[] = "Cat ";
				char s5[] = "Meow ";
				std::cout << s4 << std::endl;
				std::cout << s5 << std::endl;
				strcat(s4,s5);      // s4 = s4 + s5;
				
				std::cout << s4 << std::endl;
				return 0;
			}

		// string insertion
			#include <iostream>
			using namespace std;

			int main(){
				string s="Hello World";
				string s1("Vivek Nikate");	//we can define string like this also.

				cout<<s<<endl;				//Hello World
				
				s.insert(3," Vivek ");          //after 2nd index insert new string or after 3 char insert this new string
				std::cout << s << std::endl;     //Hel Vivek lo World

				s.insert(1,"Nikate");           //after one character insert new string.
				std::cout << s << std::endl;	  //HNikateel Vivek lo World

				string s5 = "Name:.";
				string s6 = "VivekMaheshNikate";
				
				s5.insert(5, s6,5,6);               //after 5 char insert s6 to s5, but just first 6 char of s6 only. from 5th index (0-index based)
				std::cout << s5 << std::endl;       //Name:Mahesh.
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					string s = "BIG WORLD";
					
					std::cout << s << std::endl;
					s.insert(2,3,';');         //from 2nd index, means after char of s, insert (;) 3 times.
					std::cout << s << std::endl;
					
					string s2 = "SMALL world";
					
					std::cout << s2 << std::endl;
					s2.insert(3,4,'\\');           //After char 'A', means after 3rd char, insert (\) 4 times, 
												// (\) is escape char so need to use twice
					std::cout << s2 << std::endl;
					
					return 0;
				}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					string s = "BIG WORLD";
					
					std::cout << s << std::endl;        //BIG WORLD
					
					//if you want to  insert just a char to string use this method
					s.insert(s.begin()+1,'%'); 
					std::cout << s << std::endl;        //B%IG WORLD

					s = "BIG WORLD";
					s.insert(s.end()-1,'+');      	//from ending of string   
					std::cout << s << std::endl;        //BIG WORL+D

					s = "BIG WORLD";
					s.insert(s.begin()+2,'@');         //from starting of string
					std::cout << s << std::endl;        //BI@G WORLD

					
					//want to insert string to string use below method
					s = "BIG WORLD";
					s.insert(4,"1234");
					std::cout << s << std::endl;		//BIG 1234WORLD
					
					s = "BIG WORLD";
					s.insert(3,"qwerty", 1);         //insert to s after 3 char but just insert first char of qwerty ie. q
					std::cout << s << std::endl;		//BIGq WORLD
					
					s = "BIG WORLD";
					s.insert(0,"qwerty", 2);         //insert to s from start, but just insert first 2 char of qwerty ie. qw
					std::cout << s << std::endl;		//qwBIG WORLD
					
					s = "BIG WORLD";
					s.insert(4,"qwerty", 3);         //insert to s after 4 char, but just insert first 3 char of qwerty ie. qwe
					std::cout << s << std::endl;		//BIG qweWORLD
					
					s = "BIG WORLD";
					s.insert(5,"qwerty", 3,3);         //insert to s after 5 char but just insert 3 char of qwerty, from 3rd index (0-based index).
					std::cout << s << std::endl;		//BIG WrtyORLD
					
					return 0;
				}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					string s1 ("ABCDef");             //length: 4
					string s2 ("//\\\\");           //length: 6, but Actual length: 4 due to escape char \.
					
					std::cout << s1 << std::endl;
					std::cout << s2 << std::endl;

					s2.insert(2,s1);
					std::cout << s2 << std::endl;
					
					//but just AB we need
					s2 = "{{}}";
					std::cout <<endl<< s2 << std::endl;

					//GLITCH
					s2.insert(2,s1,3);                  //sending string as variable s1 to insert function will output, start inserting from 3rd index of s1 till last.(0-based index)
					std::cout << s2 << std::endl;               //{{D}}
					
					s2 = "{{}}";
					s2.insert(2,"ABCDef",3);              //sending string directly to insert function will output, just takes first 3 char of given string.
					std::cout << s2 << std::endl;           //{{ABC}}
					
					
					s2="{{}}";
					
					s2.insert(2,s1,3);                  //start inserting s1 to s2 from 3rd index of s1.
					std::cout << s2 << std::endl;       //{{Def}}
					
					s2="[[]]";
					s2.insert(2,s1,3,2);                 //here we mentioned the start & no.of chars to take. 
													//start index :3, no.of chars to take :2
													//from 3rd of s1 take 2 chars ie. s1 is ABCDef from 3rd index is D
													//from there 2 chars means ie. De
													
					std::cout << s2 << std::endl;           //[[De]].
					
					return 0;
				}

		// Replace Spaces with @40:
			Sample Input 1:
				2
				Coding Ninjas Is A Coding Platform
				Hello World
				Sample Output 1:
				Coding@40Ninjas@40Is@40A@40Coding@40Platform
				Hello@40World
				Explanation Of Sample Output 1:
				In test case 1, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40Is@40A@40Coding@40Platform

				In test case 2, After replacing the spaces with “@40” string is: 

				Hello@40World
				Sample Input 2:
				3
				Hello
				I love coding
				Coding Ninjas India
				Sample Output 2:
				Hello
				I@40love@40coding
				Coding@40Ninjas@40India    
				Explanation For Sample Output 2:
				In test case 1, After replacing the spaces with “@40” string is: 

				Hello

				In test case 2, After replacing the spaces with “@40” string is: 

				I@40love@40coding

				In test case 3, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40India
			#include <bits/stdc++.h> 
			string replaceSpaces(string &str){
				string temp;
				for(int i=0;i<str.length();i++){
					if(str[i] == ' '){
						temp += "@40";
					}else{
						temp += str[i];
					}
				}
				return temp;
			}

			//or without using extra space/ temp string.
				#include <iostream>
				using namespace std;

				int main(){
					string str= "H M M N";
					std::cout << str << std::endl;
					
					int len = str.length(), spaceCount=0;
						for(int i=0;i<len;i++)
							if(str[i] == ' ')
								spaceCount++;
						
						if(!spaceCount){
						std::cout << str << std::endl;
							return 0;
					}

						len -= spaceCount;
						len += (spaceCount*3);
						str.resize(len);

						for(int i=0;i<len;i++){
							if(str[i] == ' '){
								str.replace(i, 1,"@40");
								i +=2;
							}
						}
						
						std::cout << str << std::endl;
					return 0;
				}

		clear():
			The clear() function is used to remove all the elements of the vector container, thus making it size 0.
			Parameters: No parameters are passed.
			Result: All the elements of the vector are removed (or destroyed).

		erase():
			erase() function is used to remove elements from a container from the specified position or range.

			#include <iostream>
			using namespace std;

			int main(){
				string s;
				s=  "Hello World";
				std::cout << s << std::endl;                //Hello World
				
				s.erase(3,4);                       //after 3 chars remove 4 characters
				std::cout << s << std::endl;        //Helorld
				
				//except first 5 characters remove all
				s = "Hello World";
				s.erase(5);
				std::cout << s << std::endl;    //Hello
				
				//just remove 4th character         if we mention iterator then it remove only one character at that iterator index.
				s = "Hello World";
				s.erase(s.begin()+4); 
				std::cout << s << std::endl;        //Hell World
				
				//remove 4 characters from last
				s = "Hello World";
				s.erase(s.end()-4,s.end());             //s.erase(startIndex, endIndex);
				std::cout << s << std::endl;            //Hello W
				
				//remove last char from string
				s = "Hello World";
				s.pop_back();
				std::cout << s << std::endl;            //Hello Worl
				
				//remove last char from string using erase
				s = "Hello World";
				s.erase(s.end()-1);
				std::cout << s << std::endl;            //Hello Worl
				
				//remove 2nd last char from string using erase
				s = "Hello World";
				s.erase(s.end()-2);
				std::cout << s << std::endl;            //Hello Word
				
				//delete complete string
				s = "Hello World";
				s.erase();
				std::cout <<"String is ::" <<s << std::endl;            //Hello Worl
				
				//or
				s = "Hello World";
				s.clear();
				std::cout<<"Clear string :: " << s << std::endl;            //Hello Worl
				
				//append 4 char to end of string
				s = "Hello World";
				string w = s.substr(1,4);           //substr(startIndex, no.of char)
				s += " "  + w;
				std::cout << s  << std::endl;            //Hello World ello
				
				return 0;
			}

			//string operations:
				Example-1:
					#include <iostream>
					using namespace std;

					int main(){
						string s1 = "Vivek Mahesh Nikate";
						string s2 = "Learning is Hobby";
						
						cout<<"one is not present in s1 :: "<<boolalpha<<(s1.find("one") == string::npos)<<endl;
						
						//string::npos means sub string is not found. if s1.find("--") == string::npos, means substring does not exist.
						cout<<string::npos<<endl;
						
						if(s1.find("Vivek") != string::npos){
							std::cout << "SubString found" << std::endl;
						}else{
							std::cout << "SubString Not found" << std::endl;
						}
						
						//find() method returns the index of starting character of substring, & its case sensitive if not found 
						//it return value of string::npos & if(str.find() == string::npos) then you can say that substring not found.
						
						std::cout <<"learning is present in s2 :: " <<(s2.find("learning") != string::npos) << std::endl;
						
						std::cout <<"Hobby is present?  "<<(s2.find("Hobby") != string::npos) << std::endl;
						
						string s3 = "Learning @#@#@&@#@#@@#@#@@#@#@ pro@#@#@blem@#@#@ solving is @#@#@a most impor@#@#@tant skill @#@#@found in the @#@#@interview";
						
						//removing garbase from string,
						std::cout << s3 << std::endl;
						
						string part = "@#@#@";
						
						while(s3.find(part) != string::npos){
							if(s3.find(part) != string::npos)
								s3.erase(s3.find(part), part.length());
						}
						
						std::cout << s3 << std::endl;
						return 0;
					}

					/*
						output:
						one is not present in s1 :: true
						18446744073709551615
						SubString found
						learning is present in s2 :: false
						Hobby is present?  true
						Learning @#@#@&@#@#@@#@#@@#@#@ pro@#@#@blem@#@#@ solving is @#@#@a most impor@#@#@tant skill @#@#@found in the @#@#@interview
						Learning & problem solving is a most important skill found in the interview
					*/

				Example-2:
					#include <iostream>
					using namespace std;

					int main(){
					
						string s= "Hello_World";
						
						std::cout << s << std::endl;                    //Hello_World
						std::cout << s.substr(0,2) << std::endl;        //He    2 character
						std::cout << s.substr(6,2) << std::endl;        //wo    2 character
						std::cout << s.substr(s.length()-1) << std::endl;     //extracting last char    d
						std::cout << s.substr(4,1) << std::endl;            //o, 1 character extracting
						
						//extracting complete string except first 2 character,
						//or from 2nd index taking all character 
						std::cout << s.substr(2) << std::endl;                  //llo_World
						
						// removing l
						std::cout << s << std::endl;
						s.erase(s.begin()+2);
						std::cout << s << std::endl;
						
						//searching substr 'Hell',
						s = "Hello_World";
						string sub = "Hell";
						
						std::cout << "is string contain "<<sub<<"? " <<( (s.find(sub) != string::npos) ? "Yes":"no")<< std::endl;
						
						if(s.find(sub) != string::npos)
							s.erase(s.find(sub),sub.length());
							
						std::cout << "New string after removing : "<< s << std::endl;
						return 0;
					}

					/*
						output
						Hello_World
						He
						Wo
						d
						o
						llo_World
						Hello_World
						Helo_World
						is string contain Hell? Yes
						New string after removing : o_World
					*/

		// Find all occurrences of string in mainString
			#include <iostream>
			using namespace std;

			int main() {
				string mainString = "abcdabcdabcd";
				// string sample="xyz";
				string sample="bcd";
				
				int n=0;        //start search for sample string in mainString from 0th index,
				
				//printing all occurrences of string sample in mainString
				while(mainString.find(sample, n) != string::npos){
					std::cout << mainString.find(sample,n) << std::endl;
					n = mainString.find(sample,n) + 1;
				}
				//1 5 9
				(n==0) ? std::cout << "String not Exist" << std::endl : std::cout << std::endl; ;
				return 0;
			}

		// Remove All Occurrences of a Substring
			https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
			Given two strings s and part, perform the following operation on 
			 s until all occurrences of the substring part are removed:
				Find the leftmost occurrence of the substring part and remove it from s.
				Return s after removing all occurrences of part.

				A substring is a contiguous sequence of characters in a string.
				Example 1:
					Input: s = "daabcbaabcbc", part = "abc"
					Output: "dab"
					Explanation: The following operations are done:
					- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
					- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
					- s = "dababc", remove "abc" starting at index 3, so s = "dab".
					Now s has no occurrences of "abc".
				Example 2:
					Input: s = "axxxxyyyyb", part = "xy"
					Output: "ab"
					Explanation: The following operations are done:
					- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
					- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
					- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
					- s = "axyb", remove "xy" starting at index 1 so s = "ab".
					Now s has no occurrences of "xy".
			class Solution {
				public:
				string removeOccurrences(string s, string part) {
					while(s.length() != 0 && (s.find(part) < s.length())){
						s.erase(s.find(part), part.length());
					}
					return s;
				}
			};

			//or
				class Solution {
					public:
					string removeOccurrences(string s, string part) {
						// Find the starting index of the 'part' substring in 's'
						int pos = s.find(part);

						// Continue looping until 'part' is found in 's'
						while (pos != string::npos) {
							// Remove 'part' from 's' starting at the found position
							s.erase(pos, part.length());

							// Search for the next occurrence of 'part' in the modified 's'
							pos = s.find(part);
						}

						// Return the modified 's' after removing all occurrences of 'part'
						return s;
					}
				};

			//or
				class Solution {
					public:
					string removeOccurrences(string s, string part){

						while(s.find(part) != string::npos){
							s.erase(s.find(part), part.length());
						}
						return s;
					}
				};

		// Permutation in String
			Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
				In other words, return true if one of s1's permutations is the substring of s2.
				Example 1:
					Input: s1 = "ab", s2 = "eidbaooo"
					Output: true
					Explanation: s2 contains one permutation of s1 ("ba").

				Example 2:
					Input: s1 = "ab", s2 = "eidboaoo"
					Output: false
				Constraints:
					1 <= s1.length, s2.length <= 104
					s1 and s2 consist of lowercase English letters.
			
			class Solution {
				public:
				bool areEqual(int a1[26], int a2[26]){
					for(int i=0;i<26;i++)
						if(a1[i] != a2[i])
							return 0;
					return 1;
				}

				bool checkInclusion(string s1, string s2) {
					int count1[26]={0},count2[26]={0};
					int i=0;
					//what are the characters present in s1 mapping them (0-a, 1-b, 2-c) in count1 array & increment their count.
					while(i<s1.length()){
						count1[s1[i]-'a']++;
						i++;
					}
					
					//what are the characters present in s2 mapping them (0-a, 1-b, 2-c) in count2 array & increment their count.
					//& checking that i should not greater that s2 string length
					i=0;
					while(i<s1.length() && i < s2.length()){
						count2[s2[i]-'a']++;
						i++;
					}

					//if both count1 & count2 have same value in them then, you can say that its permutation of string
					if(areEqual(count1,count2))
						return 1;
					
					//else moving for next s1.length() characters
					while(i<s2.length()){
						count2[s2[i]-'a']++;
						count2[s2[i-s1.length()]-'a']--;
						if(areEqual(count1,count2))
							return 1;
						i++;
					}
					return 0;
				}
			};

		// Remove All Adjacent Duplicates In String
			You are given a string s consisting of lowercase English letters. 
			A duplicate removal consists of choosing two adjacent and equal letters and removing them.
			We repeatedly make duplicate removals on s until we no longer can.

			Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
			Example 1:
				Input: s = "abbaca"
				Output: "ca"
				Explanation: 
				For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, 
				and this is the only possible move.  The result of this move is that the string is "aaca", 
				of which only "aa" is possible, so the final string is "ca".
			Example 2:
				Input: s = "azxxzy"
				Output: "ay"
			Constraints:
				1 <= s.length <= 105
				s consists of lowercase English letters.
			
			//not optimized:
				class Solution {
					public:
					string removeDuplicates(string s) {
						int i=1;
						while(i < s.length()){
							if(s[i] == s[i-1]){
								s.erase(i-1,2);
								i=1;
							}else{
								i++;
							}
						}
						return s;
					}
				};

			//optimized:
				class Solution {
					public:
					string removeDuplicates(string s) {
						int i=0;
						string temp;
						while(i<s.length()){
							if( temp.empty() || temp.back() != s[i]){
								temp.push_back(s[i]);
							}else{
								temp.pop_back();
							}
							i++;
						}
						return temp;
					}
				};

		// String Compression
			Given an array of characters chars, compress it using the following algorithm:
				Begin with an empty string s. For each group of consecutive repeating characters in chars:
				If the group's length is 1, append the character to s.
				Otherwise, append the character followed by the group's length.
				The compressed string s should not be returned separately, but instead, 
				be stored in the input character array chars. Note that group lengths that 
				are 10 or longer will be split into multiple characters in chars.

				After you are done modifying the input array, return the new length of the array.
				You must write an algorithm that uses only constant extra space.

				Example 1:
					Input: chars = ["a","a","b","b","c","c","c"]
					Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
					Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
				Example 2:
					Input: chars = ["a"]
					Output: Return 1, and the first character of the input array should be: ["a"]
					Explanation: The only group is "a", which remains uncompressed since it's a single character.
				Example 3:
					Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
					Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
					Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".

				Constraints:
					1 <= chars.length <= 2000
					chars[i] is a lowercase English letter, 
					uppercase English letter, digit, or symbol.

			//NOT optimized.
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string s="";
						for(int i=0;i<chars.size();i++){
							if(isalpha(chars[i])){
								char ch = chars[i];
								s += ch;
								int cnt=1;
								for(int j=i+1;j<chars.size();j++){
									if(ch == chars[j]){
									chars[j] ='0';
									cnt++;
									}
								}
								if(cnt !=1)
									s += to_string(cnt);
							}else{
								continue;
							}
						}
						for(int i=0;i<s.length();i++)
							chars[i] = s[i];
						return s.length();
					}
				};

			//Optimized.. without using extra space 
				class Solution {
					public:
					int compress(vector<char>& chars) {
						int i=0,ansIndex=0;
						while(i<chars.size()){
							int j=i+1;
							while(j<chars.size() && chars[i] == chars[j])
								j++;
						
							chars[ansIndex++] = chars[i];
							int count = j-i;

							if(count > 1){
								string cnt = to_string(count);
								for(char ch: cnt)
									chars[ansIndex++] = ch;
							}
							i=j;
						}
						return ansIndex;
					}
				};
			
			//Optimized..  using extra space temp string,
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string s;
						for(int i=0;i<chars.size();){
							s += chars[i];
							int j=i+1;
							while(j<chars.size() && chars[i] == chars[j]){
								j++;
							}

							int count = j-i;
							// cout<<count<<endl;
							if(count > 1)
								s += to_string(count);
							// cout<<s<<endl;
							i=j;
						}
						
						for(int i=0;i<s.length();i++){
							chars[i] = s[i]; 
						}
						return s.length();
					}
				};

			//Own code:
				class Solution {
					public:
					int compress(vector<char>& chars) {
						int cnt=1;
						string s;
						chars.push_back('-');
						for(int i=0; i<chars.size()-1; i++){
							if(chars[i] == chars[i+1])
								cnt++;
							else{
								s += chars[i];
								if(cnt >1){ 
									string cntr= to_string(cnt);
									for(char k: cntr)
									s += k;
								}
								cnt=1;
							}
						}

						for(int i=0;i<s.length();i++){
							chars[i] = s[i];
						}
						return s.length();
					}
				};

			//or
				class Solution {
					public:
					int compress(vector<char>& chars) {

						// if(chars.size()==1)
						//     return 1;
						int i=0;
						int cnt=1,ansIndex=0;
						chars.push_back('^');       //dummy char to handle insertion in chars to execute else part once for last char.
						while(i < chars.size()-1){
							if(chars[i] == chars[i+1])
								cnt++;
							else{
								chars[ansIndex++] = chars[i];
								if(cnt>1)
									for(char ch: to_string(cnt))
									chars[ansIndex++] = ch;
								cnt=1;
							}
							i++;
						}
						return ansIndex;
					}
				};
						
			//or
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string ans;
						if(chars.size()==1)
							return 1;
						int cnt=1;
						chars.push_back('-');
						for(int i=0;i<chars.size()-1;i++){
							if(chars[i]==chars[i+1])
								cnt++;
							else{
								if(cnt==1)
									ans+=chars[i];
								else
									ans+=chars[i]+to_string(cnt),cnt=1;
							}
						}
						chars.clear();
						for(auto it:ans)                    //for(char it:ans)
						chars.push_back(it);
						return chars.size();      
					}
				};
---------------------------------------------------------------------------------------------------------
	22/09/23
Lecture-23: Introduction to 2D Arrays in C++ LeetCode Questions
		//2D Array Implementation:
			#include <iostream>
			using namespace std;

			//if you are passing the 2D Array to function need to mention column size, else will get the error
			void printArr(int[][4]);
			bool isPresent(int [][4], int);
			int main(){
				//2D Array
				
				//initialization
				int arr1[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};      //3 rows * 4 columns = 12 boxes
				int arr2[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
				
				printArr(arr1);
				std::cout << std::endl;
				printArr(arr2);
				
				//input from user
				int arr3[3][4];
				for(int row=0; row<3; row++)
					for(int col=0; col<4; col++)
						cin>>arr3[row][col];
				
				std::cout << std::endl;
				printArr(arr3);
				
				int trgt1, trgt2;
				std::cout << "Enter trgt1 & trgt2 : " << std::endl;
				cin>>trgt1>>trgt2;
				
				//for trgt1
				if(isPresent(arr1,trgt1))
					cout<<"\nTarget1 :"<<trgt1<<"  is present";
				else
					cout<<"Target1 not present";
				
				(isPresent(arr1,trgt2))?  cout<<"\nTarget2 :"<<trgt2<<"  is present" :  cout<<"\nTarget2 "<<trgt2<<" not present";
				
				return 0;
			}

			//if you are passing the 2D Array to function need to mention column size.
			void printArr(int a[][4]){          
				//printing 2D Array
				for(int row=0; row<3; row++){
					for(int col=0; col<4; col++)
						cout<<a[row][col]<<"\t";
					cout<<"\n";
				}
			}

			//Linear search function
			bool isPresent(int a[][4], int n){
				for(int row=0; row<3; row++)
					for(int col=0; col<4; col++)
						if(a[row][col] == n)
							return 1;
				return 0;
			}

		//wap to find sum of row elements
			#include <iostream>
			using namespace std;
			int main(){
				int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};

				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[i][j];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					sum=0;
				}
				return 0;
			}
				//output
					ROW 1 = 9
					ROW 2 = 15
					ROW 3 = 33

		//wap to find sum of column elements
			#include <iostream>
			using namespace std;
			int main(){
				int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};

				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[j][i];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					sum=0;
				}
				return 0;
			}
				//output
					ROW 1 = 18
					ROW 2 = 19
					ROW 3 = 20

		//wap to find row who has largest sum.
			#include <iostream>
			#include<vector>
			using namespace std;
			int main(){

				int arr[3][3] = {{30,30,3},{5,5,5},{10,11,12}};
				
				vector<int> Lrow;
				
				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[i][j];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					Lrow.push_back(sum);
					sum=0;
				}
				
				//finding max sum row
				int row=0;
				for(int i=1;i<Lrow.size();i++){
					if(Lrow[row] < Lrow[i])
						row=i;
				}
				std::cout << "The maximum sum is present in row "<< row+1 << ", The largest sum is :"<< Lrow[row] << std::endl;
				return 0;
			}

			//or
				int largestRowSum(int arr[][3], int row, int col) {
					int maxi = INT_MIN;
					int rowIndex = -1;

					for(int row=0; row<3; row++) {
						int sum = 0;
						for(int col=0; col<3; col++) {
							sum += arr[row][col];
						}

						if(sum > maxi ) {
							maxi = sum;
							rowIndex = row;
						}
						
					}
					cout << "the maximum sum is " << maxi << endl;
					return rowIndex;
				}

		//wap to print array element in wave format
			Sample Input 1:
				2
				3 4
				1 2 3 4
				5 6 7 8
				9 10 11 12
				4 4
				1 2 4 5
				3 6 8 10
				11 12 13 15
				16 14 9 7
				Sample Output 1:
				1 5 9 10 6 2 3 7 11 12 8 4
				1 3 11 16 14 12 6 2 4 8 13 9 7 15 10 5 
				Explanation For Sample Input 1:
				Here, the elements are printed in a form of a wave, first, the 0th column is printed from top to bottom then the 1st column from bottom to top, and so on. Basically, the even column is printed from top to bottom and the odd column in the opposite direction.
			Sample Input 2:
				2
				1 1
				3
				1 2
				6 5
				Sample Output 2:
				3
				6 5 

			//Program:
				#include <iostream>
				#include<vector>
				using namespace std;
				int main(){

					int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};
					
					vector<int> ans;
					
					int sum=0;
					for(int i=0;i<3;i++){
						for(int j=0;j<3;j++)
							cout<<arr[i][j]<<"\t";
						cout<<"\n";
					}
					
					int r=0,c=0;
					
					while(c<3){
						while(1){
							// cout<<arr[r][c]<<"\t";
							ans.push_back(arr[r][c]);
							if(c%2==0){
								r++;
								if(r>2){
									r--; 
									break;
								}
							}else{
								r--;
								if(r<0){
									r++;
									break;
								}
							}
						}
						c++;
					}
					
					std::cout << std::endl;
					for(int i: ans)
						cout<<i<<" ";
					return 0;
				}

			//or
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					int col=0,row=0;
					vector<int> ans;
					while(col<mCols){
						while(1){
							ans.push_back(arr[row][col]);
							if(col%2==0){
								row++;
								if(row>=nRows){
									row--;
									break;
								}
							}else{
								row--;
								if(row<0){
									row++; 
									break;
								}
							}
						}
						col++;
					}
					return ans;
				}

			//or
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					vector<int> ans;
					for (int j = 0; j < mCols; j++){
						if (j % 2 == 0){
							for (int i = 0; i < nRows; i++){
								ans.push_back(arr[i][j]);
							}
						}else{
							for (int i = nRows - 1; i >= 0; i--){
								ans.push_back(arr[i][j]);
							}
						}
					}

					return ans;
				}

			//shorthand
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					vector<int> ans;
					for (int j = 0; j < mCols; j++)
						if (j % 2 == 0)
							for (int i = 0; i < nRows; i++)
								ans.push_back(arr[i][j]);
						else
							for (int i = nRows - 1; i >= 0; i--)
								ans.push_back(arr[i][j]);
					return ans;
				}
		
		//WAP to print array element in Spiral order (Spiral Matrix):
			https://leetcode.com/problems/spiral-matrix/
			class Solution {
				public:
				vector<int> spiralOrder(vector<vector<int>>& matrix) {
					vector<int> ans;

					//retrived no.of rows & columns
					int row = matrix.size();
					int col = matrix[0].size();

					//get to know the indexes
					int startingRow = 0;
					int startingCol = 0;
					int endingRow = row-1;
					int endingCol = col-1;

					//got to know that how many elements are there.
					int total = row * col;
					int cnt=0;
					//running the loop till we cover the all elements
					while(cnt<total){
						
						//printing starting Row
						for(int index=startingCol; cnt<total && index<=endingCol; index++){
							ans.push_back(matrix[startingRow][index]);
							cnt++;
						}
						startingRow++;

						//printing ending Col
						for(int index=startingRow; cnt<total && index<=endingRow; index++){
							ans.push_back(matrix[index][endingCol]);
							cnt++;
						}
						endingCol--;

						//printing ending Row
						for(int index=endingCol; cnt<total && index>=startingCol; index--){
							ans.push_back(matrix[endingRow][index]);
							cnt++;
						}
						endingRow--;

						//printing starting col
						for(int index=endingRow; cnt<total && index>=startingRow; index--){
							ans.push_back(matrix[index][startingCol]);
							cnt++;
						}
						startingCol++;
					}
					return ans;
				}
			};

			//or
				class Solution {
					public:
					vector<int> spiralOrder(vector<vector<int>>& matrix) {
						int row = matrix.size();
						int col = matrix[0].size();

						//creating vector
						vector<int> ans;
						
						//indexes
						int startingRow = 0;
						int startingCol = 0;
						int endingRow = matrix.size();
						int endingCol = matrix[0].size();

						int totalElements = row * col;
						int cnt=0;

						while(cnt<totalElements){
							//traversing starting Row
							for(int i=startingCol; cnt<totalElements && i<endingCol; i++){
								ans.push_back(matrix[startingRow][i]);
								cnt++;
							}
							startingRow++;

							//traversing last col
							for(int i=startingRow; cnt<totalElements && i<endingRow; i++){
								ans.push_back(matrix[i][endingCol-1]);
								cnt++;
							}
							endingCol--;
							
							//traversing last Row
							for(int i=endingCol-1; cnt<totalElements && i>=startingCol; i--){
								ans.push_back(matrix[endingRow-1][i]);
								cnt++;
							}
							endingRow--;
							
							//traversing starting col
							for(int i=endingRow-1; cnt<totalElements && i>=startingRow; i--){
								ans.push_back(matrix[i][startingCol]);
								cnt++;
							}
							startingCol++;
						}
						return ans;
					}
				};
		
		//WAP Rotate Image (array, column to row)
			https://leetcode.com/problems/rotate-image/
			//taking extra space by creating 2 vectors ans & temp,
				class Solution {
					public:
					void rotate(vector<vector<int>>& matrix) {
						vector<vector<int>> ans;
						vector<int> temp;
						for(int col=0; col<matrix[0].size(); col++){
							for(int row=matrix.size()-1; row>=0; row--){
								temp.push_back(matrix[row][col]);
							}
							ans.push_back(temp);
							temp.clear();
						}
						matrix = ans;
					}
				};
			
			//In-Place (without taking extra space)
				class Solution {
					public:
					void rotate(vector<vector<int>>& matrix) {
						int row = matrix.size();
						for(int i=0; i<row;i++){
							for(int j=0; j<=i;j++){
								swap(matrix[i][j], matrix[j][i]);
							}
						}
						for(int i=0;i<row;i++){
							reverse(matrix[i].begin(), matrix[i].end());
						}
					}
				};

			//in-place
				Sample Input 1:
					2
					3
					1  2  3
					4  5  6
					7  8  9
					4
					1  2  3  4 
					5  6  7  8 
					9 10 11 12 
					13 14 15 16
					Sample Output 1:
					3  6  9 
					2  5  8 
					1  4  7
					4  8 12 16 
					3  7 11 15 
					2  6 10 14 
					1  5  9 13
					Explanation Of Input 1:
					(i) The array has been rotated by 90 degrees in an anticlockwise direction as the first row is now the first column inverted and so on for second and third rows.

					(ii) The array has been rotated by 90 degrees in an anticlockwise direction as the first row is now first column inverted and so on for second, third and fourth rows.
					Sample Input 2:
					2
					3
					7  4  1 
					8  5  2 
					9  6  3
					4
					13  9  5  1 
					14  10  6  2 
					15 11 7 3 
					16 12 8 4
					Sample Output 2:
					1  2  3
					4  5  6
					7  8  9
					1  2  3  4 
					5  6  7  8 
					9 10 11 12 
					13 14 15 16

				#include <bits/stdc++.h> 
				void inplaceRotate(vector<vector<int>> &matrix){
					int row = matrix.size();
					for(int i=0; i<row;i++){
						for(int j=0; j<=i;j++){
							swap(matrix[i][j], matrix[j][i]);
						}
					}
					for(int i=0;i<row;i++){
						reverse(matrix[i].begin(), matrix[i].end());
					};
					reverse(matrix.begin(), matrix.end());
					
					for(int i=0;i<row;i++){
						reverse(matrix[i].begin(), matrix[i].end());
					};
				}

		// Search a 2D Matrix:
			https://leetcode.com/problems/search-a-2d-matrix/description/
			class Solution {
				public:
				bool searchMatrix(vector<vector<int>>& matrix, int target) {

					int row = matrix.size();
					int col = matrix[0].size();

					int start =0;
					int end= row*col -1;
					int total = row*col;
					int mid = (start+end)/2;

					while(start<=end){
						int rowIndex = mid / col;
						int colIndex = mid % col;
						int value = matrix[rowIndex][colIndex];
						if(value == target)
							return 1;
						else if(value < target)
							start = mid + 1;
						else
							end = mid - 1;
						mid = (start + end )/2;
					}
					return false;
				}
			};
	
		// Search a 2D Matrix II:
			https://leetcode.com/problems/search-a-2d-matrix-ii/description/
			-here remember that, YOU ARE STARTING TO SEARCH THE TARGET VALUE FROM LAST COLUMN & STARTING ROW.
			class Solution {
				public:
				bool searchMatrix(vector<vector<int>>& matrix, int target) {
					// int row=0,col=0;
					// for(row;row<matrix.size();row++)
					//     for(col=0;col<matrix[0].size();col++)
					//         if(target == matrix[row][col])
					//             return 1;
					// return 0;
					int row = matrix.size();
					int col = matrix[0].size();

					int rowIndex = 0;
					int colIndex = col -1;

					while(rowIndex<row && colIndex>=0){
						int value = matrix[rowIndex][colIndex];
						if(value == target)
							return 1;
						else if(value<target)
							rowIndex++;
						else
							colIndex--;
					}
					return 0;
				}
			};
	
	❌Pending task,
	# 10 question leet code on 2D array
		1) Spiral Matrix II :
			https://leetcode.com/problems/spiral-matrix-ii/description/
			-Generating Spiral matrix from given n
				#include <iostream>
				#include<vector>
				using namespace std;

				vector<vector<int>> generateMatrix(int n) {

					vector<vector<int>> valueHolder(n,vector<int>(n,0));
					int rows,cols;
					rows = cols = n;

					int totalElements = rows * cols;
					cout<<totalElements<<endl;
					int startRow = 0;
					int startCol = 0;
					int endCol = cols-1;
					int endRow = rows-1;
					int cnt=0;

					while(cnt<totalElements){
						//traversing start row
						for(int i=startCol; cnt<totalElements, i<=endCol; i++){
							valueHolder[startRow][i] = ++cnt;
						}
						startRow++;

						//traversing last Col
						for(int i=startRow; cnt<totalElements, i<=endRow; i++){
							valueHolder[i][endCol] = ++cnt;
						}
						endCol--;

						//traversing last row
						for(int i=endCol; cnt<totalElements, i>=startCol; i--){
							valueHolder[endRow][i] = ++cnt;
						}
						endRow--;

						//traversing start col
						for(int i=endRow; cnt<totalElements, i>=startRow; i--){
							valueHolder[i][startCol] = ++cnt;
						}
						startCol++;
					}
					return valueHolder;
				}

				int main() {
					int n=5;
					vector<vector<int>> ans = generateMatrix(n);
					for(int i=0; i<n; i++){
						for(int j=0; j<n; j++)
							cout<<ans[i][j]<<"\t";
						cout<<endl;
					}
					return 0;
				}
			Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
				class Solution {
					public:
					vector<vector<int>> generateMatrix(int n) {
						vector<vector<int>> valueHolder(n,vector<int>(n,0));
						int rows,cols;
						rows = cols = n;
					
						int totalElements = rows * cols;
						cout<<totalElements<<endl;
						int startRow = 0;
						int startCol = 0;
						int endCol = cols-1;
						int endRow = rows-1;
						int cnt=0;

						while(cnt<totalElements){
							//traversing start row
							for(int i=startCol; cnt<totalElements, i<=endCol; i++){
								valueHolder[startRow][i] = ++cnt;
							}
							startRow++;

							//traversing last Col
							for(int i=startRow; cnt<totalElements, i<=endRow; i++){
								valueHolder[i][endCol] = ++cnt;
							}
							endCol--;

							//traversing last row
							for(int i=endCol; cnt<totalElements, i>=startCol; i--){
								valueHolder[endRow][i] = ++cnt;
							}
							endRow--;

							//traversing start col
							for(int i=endRow; cnt<totalElements, i>=startRow; i--){
								valueHolder[i][startCol] = ++cnt;
							}
							startCol++;
						}
						return valueHolder;
					}
				};

		2) Set Matrix Zeroes
			https://leetcode.com/problems/set-matrix-zeroes/description/
			Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
			You must do it in place.
			Example 1:
				Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
				Output: [[1,0,1],[0,0,0],[1,0,1]]
			Example 2:
				Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
				Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
			Constraints:
				m == matrix.length
				n == matrix[0].length
				1 <= m, n <= 200
				-231 <= matrix[i][j] <= 231 - 1
			Follow up:
				A straightforward solution using O(mn) space is probably a bad idea.
				A simple improvement uses O(m + n) space, but still not the best solution.
				Could you devise a constant space solution?

			//In-Place approach:
				class Solution {
					public:
					void setZeroes(vector<vector<int>>& matrix) {
						//first create bool vector which will store the places of zero present in matrix, default set to 0.
						vector<vector<bool>> isZero(matrix.size(), vector<bool>(matrix[0].size(), 0));

						//this below code will check that if that position contain zero then in bool vector it make changes to 1
						for(int i=0; i<matrix.size(); i++){
							for(int j=0; j<matrix[0].size(); j++){
								if(matrix[i][j] == 0){
									isZero[i][j] = 1;
								}
							}
						}

						//here is isZero vector contain 1 then that complete row & column of matrix set to 0.
						for(int i=0; i<matrix.size(); i++){
							for(int j=0; j<matrix[0].size(); j++){
								if(isZero[i][j] == 1){
									for(int row =0; row<matrix.size(); row++){
										matrix[row][j] = 0;
									}
									
									for(int col =0; col<matrix[0].size(); col++){
										matrix[i][col] = 0;
									}
								}
							}
						}
					}
				};

			//creating new vector & assigning it back to old one,
				class Solution {
					public:
					void setZeroes(vector<vector<int>>& matrix) {
						vector<vector<int>> TEMP(matrix.size(), vector<int>(matrix[0].size(), 0));

						// for(int i=0; i<matrix.size(); i++)
						//     for(int j=0; j<matrix[0].size(); j++)
						//         TEMP[i][j] = matrix[i][j];
						//or instead of above 3 lines of code. you can use below one liner also.
						//copying one vector to other.
						TEMP = matrix;

						//or you can use below line also to copy.
						//TEMP.assign(matrix.begin(), matrix.end());

						for(int i=0; i<matrix.size(); i++){
							for(int j=0; j<matrix[0].size(); j++){
								if(matrix[i][j] == 0){
									for(int row=0; row<matrix.size(); row++){
										TEMP[row][j] = 0;
									}
									for(int col=0; col<matrix[0].size(); col++){
										TEMP[i][col] = 0;
									}
								}
							}
						}
						matrix = TEMP;
					}
				};

		3)
			
		4)

		5)

		6)

		7)
		
		8)

		9)
		
		10)
---------------------------------------------------------------------------------------------------------
	05/10/23
Lecture-24: Basic Maths for DSA || Sieve || Modular Arithmetics || Euclid’s Algorithm
	// Count Primes
		TC - O(n * log(log n))
		https://leetcode.com/problems/count-primes/description/
		Given an integer n, return the number of prime numbers that are strictly less than n.		
			Example 1:
				Input: n = 10
				Output: 4
				Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
			Example 2:
				Input: n = 0
				Output: 0
			Example 3:
				Input: n = 1
				Output: 0

			Constraints:
				0 <= n <= 5 * 106

		//NOT optimized:
			class Solution {
				public:
				bool checkPrime(int x)
				{
					for(int i=2;i<x;i++)
					{
						if(x%i==0) return 0;
					}
					return 1;
				}
				int countPrimes(int n) {
					if(n<=1) return 0;
					else
					{
						int count=0;
						for(int i=2;i<n;i++)
						{
							if(checkPrime(i))
							{
								count++;
							}
						}
						return count;
					}
				}
			};

		//Optimized:
			-The Sieve of Eratosthenes is an algorithm used to find all prime numbers less than a number. 
			The way it works is that, starting from 2, it creates a list of all integers from there until n. 
			Then, starting with 2 (which is the smallest prime), every multiple of 2 is marked as not a prime
			class Solution {
				public:
				int countPrimes(int n) {
					
					int cnt=0;
					vector<int> prime(n,1);
					if(n >=0 && n<=2)
						return cnt;

					prime[2] = 1;								//no need.

					
					for(int i=2; i<n; i++)
						if(prime[i] == 1){						// if(primes[i])
							for(int j=i+i; j<n; j += i)			//for(int j=i*2; j<n; j += i)
								prime[j] = 0;
							cnt++;
						}
					return cnt;
				}
			};
			
	❌Segmented sieve:
		https://www.codingninjas.com/studio/library/segmented-sieve

	//Euclid’s Algorithm:
		LCM(A,B) * HCF(A,B) = A*B;
		-computing the Greatest Common Divisor (GCD) of two positive integers
		
		#include <iostream>
		using namespace std;
		int gcd(int a, int b){
			if(a==0)
				return b;
			
			if(b==0)
				return a;
				
			while(a!=b){
				
				if(a>b){
					a-=b;
				}else{
					b-=a;
				}
			}
			return a;
		}

		int main(){
			int a,b;
			std::cout << "Enter 2 nums: " << std::endl;
			cin>>a>>b;
			
			int ans = gcd(a,b);
			
			std::cout << "The gcd of "<<a<<" "<<b<<" is : "<< ans << std::endl;
			return 0;
		}

	//Finding the GCD of 2 nums:
		•Flow:
			-take 2 nums input from user
			-if any of the nums is zero, then other number is GCD.
				eg.
					a = 10, b = 0
					then GCD = 10

					a = 0, b = 33
					then GCD = 33
			
			-keep maximum value in first variable. (in var a) //not necessary
			-take modulus of a % b
			-if remainder came zero, stop there & whatever maximum value is there in 
			-after taking modulus, assign value of b to a,
			-& value of modulus to b.
			-if modulus operations ans came zero, then whatever value is there in a is the GCD.	

		code:
			#include <iostream>
			using namespace std;

			int main() {
				cout<<"Enter 2 values: ";
				int a,b;
				cin>>a>>b;
				
				//std::cout << a%b << std::endl;
				if(a==0)
					std::cout << "GCD is "<< b << std::endl;
				else if(b == 0)
					std::cout << "GCD is "<< a << std::endl;
				
				// if(a<b)
				//     swap(a,b);
					
				while(a % b != 0){
					int temp = a;
					a = b;
					b = temp % b;
				}
				
				std::cout << "GCD is " << b << std::endl;
				return 0;
			}
	
	//Coding ninja Problem:
		Greatest Common Divisor
		 	Problem statement
				You are given two numbers, ‘X’ and ‘Y’. 
				Your task is to find the greatest common divisor of the given two numbers.
				The Greatest Common Divisor of any two integers is the largest number that divides both integers.
				For Example:
					You are given ‘X’ as 20 and ‘Y’ as 15. The greatest common divisor, 
					which divides both 15 and 20, is 5. Hence the answer is 5.
				Constraints:
					1 <= T <= 10
					1 <= X, Y <= 10^9
				Sample Input 1:
					2
					20 15
					8 32
					Sample Output 1:
					5
					8
					Explanation:
					For the first test case, the greatest common divisor which divides both 15 and 20 is 5. 
					Hence the answer is 5.

					For the second test case, the greatest common divisor which divides both 8 and 32 is 8. 
					Hence the answer is 8.
					Sample Input 2:
					2
					98 56
					36 60
					Sample Output 2:
					14
					12

			#include <bits/stdc++.h> 
			int findGcd(int a, int b) {
				while(a % b != 0){
					int temp = a;
					a = b;
					b = temp % b;
				}
				return b;
			}

			//or
			#include <bits/stdc++.h> 
			int findGcd(int a, int b) {
				if(b == 0)
					return a;
				return findGcd(b, a % b);
			}

	//modularExponentiation:
		-refer this program again in POTD section or search once with this name modularExponentiation.
		#include <bits/stdc++.h>
		int modularExponentiation(int x, int n, int m) {
			long long power=1;
			long long base = x;
			if(n==0)
				return power;
			int i=1;
			while(n>0){
				if(n&1)
					power = (power%m * base%m) % m;

				base = (base * base)%m ;
				n/=2;
			}
			/*
				while(n>0){
					if(n&1)
						power = (1ll * power * x%m)%m;		
					n/=2;
					x = (1ll * x%m * x%m)%m;		//or
													//x = (1LL * x%m * x%m)%m; //type casting to long
				}
			*/
			return power;
		}

	//calculating exponents of any number by any number
		optimized way
		#include <iostream>
		using namespace std;

		int main(){
			
			//here calculating 2¹⁰. for this method requre 10 iteration
			int a=2;
			int ans=1;
			std::cout << "10th power " << std::endl;
			for(int i=0; i<10; i++){
				cout<<"Pass-"<<i+1<<"\n";
				ans = ans * a;
			}
			std::cout << "ANS: "<<ans << std::endl;
			
			//for this method require 4 to 5 iterations
			ans=1;
			int cnt=1;
			for(int i=10; i>0;){
				cout<<"Pass-"<<cnt++<<" ";
				if(i&1)
					ans = ans * a;
				a = a * a;
				i /=2;
			}
			cout<<"ANS:"<<ans;
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;

			int main() {
			
				int ans=1;
				int n=3, power = 10;
				int cnt=0;
				while(power > 0){
					cout<<"pass "<<++cnt<<"\n";
					if(power&1)
						ans = ans * n;
					
					a = a * a;
					power /= 2;
				}
				std::cout << ans << std::endl;
				return 0;
			}
	
	❌
	https://codeforces.com/blog/entry/72527
	https://www.codingninjas.com/studio/library/gcd-euclidean-algorithm
	pigeon hole principle 4 question
	catalan number
	inclusion-exclusion principle.
	-factorial of num 212!%mod , mod = 1e9+7;
---------------------------------------------------------------------------------------------------------
	09/10/23
Lecture-25: Pointers in C++ || Part-1
	-Symbol Table is an important data structure created and maintained by the compiler in
	 order to keep track of semantics of variables i.e. it stores information about the scope and
	 binding information about names, information about instances of various entities such as
	 variable and function names. classes. obiects. etc.
	syntax:
		dataType * pointer_name = &(var_name);

	-By default the name of array contains the address of the first element of the array.
		int myArray[5] = {1, 2, 3, 4, 5};
		int* ptr = myArray;  // This sets ptr to point to the first element of myArray
		
		//no need of & sign, if you want you can use like this,
		int* ptr = &myArray[0];

		//compilation error:
			int* ptr = &myArray;
				You will get a compilation error. 
				This is because myArray is an array, 
				and when you try to take the address of the entire array using &myArray, 
				it is not directly convertible to a pointer-to-int (int*) because it's a pointer-to-array.

	eg. pointer to double.
		double d = 90.8978;
		double * ptr = &d;

	//BAD PRACTICE:
		-never create pointer like this, just declared, un-initialized.
		int *p;			//this will point to random location & make random changes to memory.
	
	//don't know where to point, initialize with 0.
		int * p = 0;		//null pointer.
		//or
		int *p = NULL;		//null pointer, symbolic constant increases readability of code.
		-if pointing to memory location which is not exist, this will create a segmentation fault.

	#include <iostream>
	using namespace std;

	int main() {

		int num = 90;           //this num name is mapped to some memory address where 90 is stored. (symbol table)
		std::cout << num << std::endl;

		//memory address is hexadecimal value contains 0-9 & A-F.
		//memory address is retrived by using &(ampersand operator).
		std::cout << "Address of num : " << &num << std::endl;
		
		//storing that memory address, we can store the memory address in pointer.
		//defining different way of declaring pointer.  
		//1. star is in the middle
		int * ptr1 = &num;
		std::cout << ptr1 << std::endl;      //memory location
		std::cout << *ptr1 << std::endl;     //value at that memory location
		
		std::cout << std::endl;
		int a=1;
		//2. star is attched to pointer name.
		int *ptr2 = &a;
		std::cout << ptr2 << std::endl;      //memory location
		std::cout << *ptr2 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)
		
		std::cout << std::endl;
		int b=23;
		//3. star is attched to datatype of pointer
		int* ptr3 = &b;
		std::cout << ptr3 << std::endl;      //memory location
		std::cout << *ptr3 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)
		
		//4. star is attched to both, datatype & pointer:
		int*ptr4 = &b;
		std::cout << ptr3 << std::endl;      //memory location
		std::cout << *ptr3 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)

		return 0;
	}

	-Here, in above program num has some address & num is a variable name, mapped to that address.
	eg.
		int n=43;
		int* ptr1 = &n;
		cout<<*ptr1;		//* act as dereferencing operator
			-pointer to int
			-you must create pointer of same datatype as that of variable on right side (n).
		
		char ch = 'Z';
		char* ptr2 = &ch;
			-pointer to character.

		
		double d = 4.545;
		double* ptr3 = &d;
			-pointer to double.
	
	-Pointer is used to store the addresses of variable so the size of pointer for any
		dataType will be 8.

	-A string in Solidity is length prefixed with its 256-bit (32 byte) length.
	eg.
			#include <iostream>
			using namespace std;

			int main() {
				int n=43;
				int* ptr1 = &n;
				cout<<"n="<<*ptr1<<endl;		//* act as dereferencing operator
				
				std::cout << "n size : "<< sizeof(n) << std::endl;
				std::cout << "n pointer size "<< sizeof(ptr1) << std::endl;
					
				char ch = 'Z';
				char* ptr2 = &ch;
				std::cout << std::endl;
				std::cout << "ch = "<< *ptr2 << std::endl;
				std::cout << "ch size "<< sizeof(ch) << std::endl;
				std::cout << "ch pointer size "<< sizeof(ptr2) << std::endl;
				
				double d = 4.545;
				double* ptr3 = &d;
				std::cout << std::endl;
				std::cout << "d = "<< *ptr3 << std::endl;
				std::cout << "d size "<< sizeof(d) << std::endl;
				std::cout << "d pointer size "<< sizeof(ptr3) << std::endl;
				
				string s = "Vivek Mahesh Nikate";
				string * str_ptr = &s;
				std::cout << std::endl;
				std::cout << "string = "<< *str_ptr << std::endl;

				std::cout << "s size "<< sizeof(s) << std::endl;
				std::cout << "s pointer size "<< sizeof(ptr2) << std::endl;

				return 0;
			}
			//output:
				n=43
				n size : 4
				n pointer size 8

				ch = Z
				ch size 1
				ch pointer size 8

				d = 4.545
				d size 8
				d pointer size 8

				string = Vivek Mahesh Nikate
				s size 32
				s pointer size 8

	//pointer declararing, afterwords initializing
		-when you declare the pointer, then on next line initializing that pointer
		 no need to give * again,
		 eg.
			int i=99;
			int *p;
			p = &i;
		#include <iostream>
			using namespace std;
			int main() {
				
				int n=43;
					int* ptr1 = NULL;          //null pointer  
					
				// 	or
				// 	int* ptr1 = 0;
					
					cout<<ptr1<<endl;					//0
				// 	std::cout << *ptr1 << std::endl;            //segmentation fault
					
					ptr1 = &n;          //re-initialized to address of n.
				std::cout << *ptr1  << std::endl;				//43

				return 0;
			}

		#include <iostream>
			int main() {
				char ch = 'K';
				char* ptrCH = nullptr; // Use nullptr instead of 0
				//char* ptrCH = 0

				if (ptrCH == nullptr) {
					std::cout << "0" << std::endl;			//0
				} else {
					std::cout << *ptrCH << std::endl;
				}

				ptrCH = &ch;
				std::cout << *ptrCH << std::endl;				//K
				return 0;
			}

	//Pointer increment:
		#include <iostream>
		using namespace std;

		int main(){
		
			int a = 45;
			
			int *p = &a;
			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address of a: "<< p << std::endl;
			std::cout << "Address of a: "<< &a << std::endl;
			
			//integer is of 4 bytes so,
			(*p)++;             //use brackets to increment value at that location,
			std::cout <<"value : " <<*p << std::endl;
			
			p++;                                               // nextAddress = prevAddress + 4
			//increment pointing Address use above syntax. Here pointer p incremented by 4 bytes coz int is of 4 bytes.
			std::cout << "Address of ptr : "<< p << std::endl;
			
			return 0;
		}
		//output:
			A : 45
			*p : 45
			Address of a: 0x7fff5dd4ba7c
			Address of a: 0x7fff5dd4ba7c				(prev Address)
			value : 46
			Address of ptr : 0x7fff5dd4ba80			(new Address)

			prevAddress last 2 digit = 7c after incremeting by 1 ie. 4 bytes, last digit c after c ,d, e, f, 0.
			after 7, there is 8,
			so new address will be like this 7c+4 => 80 and store in the pointer variable.

	//Operations:
		#include <iostream>
		using namespace std;
		int main() {
			int num =5;
			std::cout << num << std::endl;              //5
			
			int a = num;
			std::cout << a << std::endl;                //5
			a++;
			std::cout << a << std::endl;                //6          
			std::cout << num << std::endl;              //a doesn't affect to num, coz its copy.    //5
			
			int * p1 = &num;
			std::cout << "pointer works: " << std::endl;
			std::cout << "num using pointer : "<< *p1 << std::endl;         //5
			std::cout << "normal num "<< num << std::endl;                  //5
			
			//increment p1, will affect on normal num
			std::cout << "Address before :" << p1 << std::endl;
			*p1++;                              //use brackets here else it will change the pointing address
			std::cout <<"Address After : "<< p1 << std::endl;
			
			p1 = &num;
			std::cout << num << std::endl;
			std::cout << *p1 << std::endl;
			
			(*p1)++;
			std::cout << *p1 << std::endl;
			
			num++;
			std::cout << num << std::endl;
			std::cout << *p1 << std::endl;
			
			return 0;
		}

	//Call By Value & Call by Reference:

		#include <iostream>
		using namespace std;

		void callByValue(int n){
			n++;
			std::cout << "inside function : "<< n << std::endl;
		}

		void callByReference(int &n){
			n++;
			std::cout << "Inside ref function : "<< n << std::endl;
		}

		int main() {
			int a = 88;
			
			//call by value, it makes copy of original variable
			std::cout << "Before "<<a << std::endl;
			callByValue(a);
			std::cout << "After "<<a << std::endl;
			
			//call by reference makes changes in (modify) original variable.
			int *p = &a;
			std::cout << "Before : "<< a << std::endl;
			callByReference(*p);
			std::cout << "After : "<< a << std::endl;
			
			return 0;
		}
		// output:
				Before 88
				inside function : 89
				After 88
				Before : 88
				Inside ref function : 89
				After : 89

	//Call by Reference:
		#include <iostream>
		using namespace std;

		void swapper(int &y, int &z){
			int t;
			t = y;
			y = z;
			z = t;
		}

		int main(){
			int a =20, b = 30;
			std::cout << "Before : "<<a<<" " <<b << std::endl;
			int*pa,*pb;
			pa = &a;
			pb = &b;
			
			swapper(*pa,*pb);
			std::cout << "After "<<a<<" "<<b<< std::endl;
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;
			void fun(int &f, int &s){           //we can use pointer also, else directly accessing the address of variables
				int t;
				t = f;
				f = s;
				s = t;
			}
			int main() {
				int a=90, b=101;
				std::cout << a<<"       "<<b << std::endl;
				fun(a,b);
				std::cout << a<<"       "<<b << std::endl;
				return 0;
			}

	//Copying a pointer to Another pointer:
		#include <iostream>
		using namespace std;
		int main(){
			
			int a = 45;
			int *p = &a;

			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address using &a : "<< &a << std::endl;
			std::cout << "Address using p : "<< &a << std::endl;
			
			// copying pointer
			int *q = p;
			std::cout << "*q : "<< *q << std::endl;
			std::cout << "Address of q " << q << std::endl;
			return 0;
		}
		//output:
			A : 45
			*p : 45
			Address using &a : 0x7ffe389b3f14
			Address using p : 0x7ffe389b3f14
			*q 45
			Address of q 0x7ffe389b3f14
		
	//Double Pointer: pointer to pointer
		#include <iostream>
		using namespace std;

		int main(){
			int a = 45;
			
			int *p = &a;
			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address of a: "<< p << std::endl;
			std::cout << "Address of a: "<< &a << std::endl;
			
			int **ptrTOptr = &p;
			std::cout << "pointer to pointer : " <<**ptrTOptr << std::endl;
			std::cout << "Address pointer p:"<< ptrTOptr << std::endl;
			std::cout << "Address pointer p:"<< &p << std::endl;
			return 0;
		}

	//Types of pointer:
		Here are the different types of pointers in C++:
		1) Normal pointers
			are the most common type of pointer. They are declared using the asterisk (*) operator, 
			followed by the data type of the pointer's target. For example, int *ptr is a pointer to an integer.
			
		2) Void pointers
			can point to any type of data. They are declared using the void* keyword.
			
		3) Null pointers
			are pointers that do not point to any data. 
			They are used to indicate that a pointer is not currently pointing to anything. 
			They are declared using the nullptr keyword.

		4) Dangling pointers
			are pointers that point to data that has been deallocated. 
			They can cause undefined behavior if they are dereferenced.

		5) Wild pointers
			are pointers that point to memory that is not part of a program's memory space. 
			They can cause undefined behavior if they are dereferenced.

		●It is important to use pointers correctly to avoid undefined behavior. 
		 Undefined behavior can cause your program to crash, produce unexpected output, 
		 or behave in other unpredictable ways. 
		 
		◉Here are some tips for using pointers correctly:
		-Always initialize pointers before using them.
		-Never dereference a null pointer.
		-Never dereference a dangling pointer.
		-Never dereference a wild pointer.
		-Always use the correct type of pointer for the data you are pointing to.
		By following these tips, you can avoid undefined behavior and keep your programs running smoothly.
---------------------------------------------------------------------------------------------------------
	10/10/23
Lecture-26: Pointers in C++ || Part-2
	-Intro:
		int arr[10];
		-Declaring integer array with name arr with 10 elements.
		-total size is 40 (sizeof(int)*10)
		-name of array stores the first elements memory block address.  
	NOTE:
		-gives the value.
		arr[i] = *(arr+i)				//or
		i[arr] = *(i+arr);
		//or
		arr[i] = *(arr+i) = i[arr];
	eg.
		#include <iostream>
		using namespace std;

		int main(){
			int arr[10] = {45,2,3,4,5};
			
			std::cout << "Address first element: " << arr << std::endl;
			std::cout << "Address first element: " << &arr[0] << std::endl;
			std::cout << arr[0] << std::endl;
			
			//dereference, value at that location.
			std::cout << "Value at 0th index : " << *arr << std::endl;
			std::cout << "Value at 4th index : " << *(arr+4) << std::endl;
			std::cout << "Value at 4th index + 2 : " << *(arr+4) + 2 << std::endl;
			
			std::cout << "Index inside: arr[0]" << arr[0] << std::endl;
			std::cout << "Index outside: 0[arr]" << 0[arr] << std::endl;
			std::cout << "Index outside: 2[arr] " <<  2[arr] << std::endl;

			return 0;
		}

	//Array Pointer:
		#include <iostream>
		using namespace std;

		int main() {
			int temp[10] = {12,3,4,5,6,7,324};
			
			std::cout << "Size of array : "<< sizeof(temp) << std::endl;
			std::cout << "value at first : "<< *temp << std::endl;
			std::cout << "Address of first "<< temp << std::endl;
			std::cout << "Address of first "<< &temp << std::endl;
			std::cout << "Address of first "<< &temp[0] << std::endl;
			std::cout << "Address of second "<< &temp[1] << std::endl;
			
			std::cout << "Size of pointer : "<< sizeof(&temp) << std::endl;
			
			// int *ptr = &temp;           //no need to use & (ampersand) here, directly stores the address.
			int *ptr = temp;
			
			std::cout << "size of first element: which is int "<< sizeof(*ptr) << std::endl;
			std::cout << "pointer size: "<< sizeof(ptr) << std::endl;
			std::cout << "pointer address " << &ptr << std::endl;
			std::cout << "pointer's address size: (its also a pointer only)  "<< sizeof(&ptr) << std::endl;
			
			return 0;
		}

	◉ Symbol table can't be changed.	
	
	//Char Array:

		#include <iostream>
			using namespace std;
			int main() {
				int arr[] = {1,2,3,4,5};
				char ch[] = "Hello World";

				std::cout << arr << std::endl;  //this will print the first element address
				std::cout << ch << std::endl;   //this will print all content of char array.

				char ch2[] = {'a','b','c','d','e','f','g','h'};
				std::cout << ch2 << std::endl;
				
				
				char ch3[] = {'2','4','8'};
				std::cout << ch3 << std::endl;


				// output: there is no null char at the end so it goes on printing the character in char array
				//          to avoid this keep reading below...
				//     0x7ffd483ffa50
				//     Hello World
				//     abcdefghHello World
				//     248abcdefghHello World
				return 0;
			}

		#include <iostream>
		using namespace std;
		int main() {
			int arr1[] = {1,2,3,4,5};
			char ch4[] = "Hello World\0";
			
			std::cout << arr1 << std::endl;  //this will print the first element address

			//ATTENTION HERE
			std::cout << ch4 << std::endl;   //this will print all content of char array.

			char ch5[] = {'a','b','c','d','e','f','g','h','\0'};
			std::cout << ch5 << std::endl;
			
			char ch6[] = {'2','4','8','\0'};
			std::cout << ch6 << std::endl;
			return 0;
		}
		output:
			0x7ffce665c580
			Hello World
			abcdefgh
			248

	//pointer char:
		#include <iostream>
		using namespace std;
		int main() {
			int arr[] = {1,2,3,4,5};
			char ch[] = "Hello World";
			
		
			std::cout << arr << std::endl;  //this will print the first element address
			std::cout << arr[0] << std::endl;   //first element
			
			std::cout << ch << std::endl;   //this will print all content of char array.
		
			int*intPtr = arr;
			std::cout << "Int pointer : " <<intPtr << std::endl;
			
			char *ptr = ch;             //pointer will store adress of first character.
			std::cout << &ch << std::endl;      //prints the address of array.
			std::cout << ch[0] << std::endl;        //first character
			std::cout << ptr << std::endl;          //prints all content
			std::cout << ch << std::endl;
			
			char*ptr2 = &ch[0];             //points to first character.
			std::cout << ptr2 << std::endl;     //start from 0th index
			
			char*ptr3 = &ch[2];                 //points to 3rd char, ptr3 contains everything after 3rd char.
			std::cout << ptr3 << std::endl;     //start from 2nd index
			
			char ch2[] = {'g','o','o','d'};
			std::cout << ch2 << std::endl;              //goodHello World
			
			char*ch2PTR = &ch2[2];
			std::cout << ch2PTR << std::endl;           //odHello World
			
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;

			int main() {
				char c[] = "asdfqwerty";
				
				std::cout << c[0] << std::endl;         //a
				std::cout << 3[c] << std::endl;         //f
				std::cout << c << std::endl;            //asdfqwerty
				
				char* ptr = c;
				std::cout << ptr << std::endl;          //asdfqwerty
				
				std::cout << ptr[1] << std::endl;       //s
				std::cout << *(ptr+2) << std::endl;     //d
				std::cout << (ptr+2) << std::endl;      //dfqwerty
				std::cout << (c+2) << std::endl;        //this prints all content from 2nd index        //dfqwerty
				std::cout << *(c+2) << std::endl;       //this prints the value at 2nd index           //d
				
				return 0;
			}

	//char pointer:
		-When you create a pointer to single character, then use & operator to give the address,
		-if you are creating a pointer to char array or int array then no need to use & operator (ampersand).
		#include <iostream>
		using namespace std;
		int main() {
			char ch = 's';
			
			char * ptr = &ch;           //pointer prints random things
			std::cout << ptr << std::endl;          //s?���
			std::cout << ch << std::endl;           //s

			return 0;
		}

	//ATTENTION here
		do's
		char ch[] = "abcd"; 		//fine

		don't
		char *chPTR = "abcd";		//works, but risky

	//Function:
		#include <iostream>
		using namespace std;

		void update(int *p){
			(*p)++;
		}

		int main() {
			
			int n = 50;
			int*ptr = &n;
			
			std::cout << "before: " <<n<< std::endl;            //50
			//passing pointer to function
			update(ptr);
			std::cout << "After: " <<n<< std::endl;     //51
			
			update(&n);         //passing direct variable address

			std::cout << "After After : "<< n << std::endl;			//52
			
			return 0;
		}

	//Passing Array to Function:
		-when we passing array to function, actually we are passing pointer to that function or array's first element
		 address to function.
		 eg.
		 	int getSum(int arr[], int size)		//or
		 	int getSum(int *arr, int size)			

			-both are same, calling above function,
				int arr[] = {1,2,3,4,5},n=5;
				getSum(arr, n);
			
			//Sum array element

				#include <iostream>	
				using namespace std;

				// int sum(int *array, int size){          //or
				int sum (int array[], int size){
					int s=0;
					for(int i=0; i<size; i++)
						s += array[i];
					return s;
				}

				int main() {
					int arr[] = {1,2,3,4,5,6,7,8,9,10};
					int n=10;
					
					//calculate sum from 6 to 10; sendig array partially
					std::cout<< "Sum is: " << sum(arr+5,5) << std::endl;            //6+7+8+9+10 = 40
						
					//calculate sum from 1 to 5;
					std::cout << "2 to 4 sum : "<< sum(arr+1, 3) << std::endl;  //2+4+5=9
					
					std::cout << "Whole SUM: "<< sum(arr,10) << std::endl;      //55
					return 0;
				}

	//char array practice:
		#include <iostream>
		using namespace std;
		int main() {	
			char ch2[] = "abcdef";          //by default it considered the last null character so sizeof is 7
			std::cout << "ch2 "<< ch2 << " " <<sizeof(ch2) << std::endl;            //7
			
			char ch[] = {'a','b','c','d','e','f','\0'};
			std::cout << "ch "<< ch <<" " << sizeof(ch)<< std::endl;            
			//here in ch if we don't mention last \0 (null) character then sizeof will be 6 else it will be 7 only.
			
			std::cout << "ch contents are :: " << std::endl;
			for(char c : ch)
				std::cout << c << "\t";
				
			cout<<"\nch2 contents are :: "<<endl;
			for(char c: ch2)
				std::cout << c << "\t";
				
			std::cout << std::endl;
			char ch3[] = {'a','b','c','d','e','f'};
			std::cout << "ch3 ="<< sizeof(ch3) << std::endl;         //6 coz \0 not given at the end.
			
			return 0;
		}
---------------------------------------------------------------------------------------------------------
	02/11/23
Lecture-27: Double Pointers in C++
	1)int*ptr = &i;
		why syntax is like this?
		why not
		pointer ptr = &num;
	->
		coz in the first expression int*ptr = &i, we can get to know that this is integer pointer pointing to int
		value.

		in the 2nd expression "pointer ptr = &num", we just know that its just a pointer pointing to nums address,
		but we don't know the datatype of that pointer.

	2) integer pointer increment its self by 4 byte after increment operation.
	   float pointer increment its self by 4 byte after increment operation.
	   double pointer increment its self by 8 byte after increment operation.
	   but, if we used the second expression (pointer ptr = &num), if we want to perform
	   any operation like (ptr = ptr + 1;) if it is int datatype pointer will point to next by 4byte 
	   if double then will point to next data after 8byte
	   if float then will point to next data after 4byte, but in 2nd expression pointer ptr = &num; we are not getting 
	   which type of pointer is this, we don't get to know this pointer where will points next, coz we don't know
	   the datatype, to it is pointing. that's why we don't use the 2nd (pointer ptr = &num) this expression.

	//Double Pointer:-
		int i = 5;
		int* ptr = &i;			//pointer to integer
		int** ptr2 = &ptr;		//pointer to pointer
		int*** ptr3 = &ptr2;		//pointer to pointer to pointer chain of pointer
	eg.
		#include <iostream>
		using namespace std;

		int main() {
			
			int i =90;
			int* p = &i;
			int** p2 = &p;
			
			std::cout << "Address of i "<< &i << std::endl;
			std::cout << "Address of i using pointer: "<< p << std::endl;
			
			std::cout << "Value of i "<< i << std::endl;
			std::cout << "Value of i using pointer: "<< *p << std::endl;
			std::cout << "Value of i using double pointer: "<< **p2 << std::endl;
			
			std::cout << "Address of p: using & operator "<< &p << std::endl;
			std::cout << "Address of p: using pointer "<< p2 << std::endl;
			
			std::cout << "Value of p:  "<< p << std::endl;
			std::cout << "Value of p: using pointer "<< *p2 << std::endl;
			
			return 0;
		}
		//output:
			Address of i 0x7fff421cdce4
			Address of i using pointer: 0x7fff421cdce4
			Value of i 90
			Value of i using pointer: 90
			Value of i using double pointer: 90
			Address of p: using & operator 0x7fff421cdce8
			Address of p: using pointer 0x7fff421cdce8
			Value of p:  0x7fff421cdce4
			Value of p: using pointer 0x7fff421cdce4

	//DATE: 19/11/2023
		p = p + 1
			//NO ANY CHANGES.
				#include <iostream>
				using namespace std;

				void update(int **p){           //parameter you will pass in future should be double pointer, ie. pointer pointing to pointer.
					p = p + 1;            
				}

				int main() {
					int i=90;
					int * p1 = &i;
					int ** p2 = &p1;
					
					std::cout << "BEFORE:" << std::endl;
					cout<<"Value of i = "<<i <<endl;
					cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
					cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
					
					update(p2);     
					
					std::cout << "AFTER:" << std::endl;
					cout<<"Value of i = "<<i <<endl;
					cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
					cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
				}
		
		*p = *p + 1
			//p2 is pointing to p1, so here we manipulating the address of p1 so p1 will only changed
			#include <iostream>
			using namespace std;

			void update(int **p){           //parameter you will pass in future should be double pointer, ie. pointer pointing to pointer.
				*p = *p + 1;              
			}

			int main() {				
				int i=90;
				int * p1 = &i;
				int ** p2 = &p1;
				
				std::cout << "BEFORE:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
				
				update(p2);     
				
				std::cout << "AFTER:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
			}
		
		**p = **p + 1;
			//changes the value of i
			#include <iostream>
			using namespace std;

			void update(int **p){           //parameter you will pass in future should be double pointer, ie. pointer pointing to pointer.
				** p = ** p + 1;           // 
			}
			int main() {
				
				int i=90;
				int * p1 = &i;
				int ** p2 = &p1;
				
				std::cout << "BEFORE:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
				
				update(p2);     
				
				std::cout << "AFTER:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
			}

	//MCQ:
		1)
			#include <iostream>
			using namespace std;

			int main() {
				
				int first = 20;
				int second = 30;
				
				int * p = &second;
				std::cout << first << "\t" << second << std::endl;
				
				*p = 99;
				
				std::cout << first << "\t" << second << std::endl;
				return 0;
			}
			//output:
				20      30
				20      99
		
		2)
			#include <iostream>
			using namespace std;

			int main() {
				int first = 8;
				int *p = &first;
				
				int *q = p;
				
				std::cout << first << std::endl;        //8
				(*q)++;
				
				std::cout << first << std::endl;        //9
				return 0;
			}

		3)
			#include <iostream>
			using namespace std;
			int main() {
				
				int first = 8;
				int *p = &first;
				
				std::cout << ++(*p) << std::endl;   	//9
				std::cout << first << std::endl;    	//9
				
				std::cout << (*p)++ << std::endl;       //9
				std::cout << first << std::endl;        //10
				return 0;
			}
		
		4)
			#include <iostream>
			using namespace std;

			int main() {
				
				int *p = 0;				//This pointer don't have any memory address, currently pointer no where, null pointer.
				int first = 110;
				
				*p = first;             //segmentation fault. for null pointer after declaring initialize like this (p = &first)
									//but here we are giving value of 110 to a particular memory address where the pointer is
									//pointing, but pointer is pointing no where, so this cause error.
									//we need to give a memory address to a pointer to point & then you can change its value.
				std::cout << *p << std::endl;
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					int first = 4;
					int second = 101;
					
					int *p = &second;
					
					std::cout << *p  << std::endl;
					std::cout << second << std::endl;
					std::cout << p << "\t"<< &second << std::endl;
					
					
					*p = first;         //if it is not null pointer then only you can use this line.
					std::cout << second << std::endl;
					
					p = &first;
					
					std::cout << "Second sec" << std::endl;
					first = 10;
					std::cout << second << std::endl;
					std::cout << first << std::endl;
					std::cout << *p << std::endl;
					std::cout << p << "\t" << &first << std::endl;
					
					return 0;
				}

		5)
			#include <iostream>
			using namespace std;

			int main() {
				int first = 10;
				int second = 20;
				int *third = &second;
				
				first = *third;
				*third = *third + 2;
				
				std::cout << first << "\t" << second <<  std::endl;             //20        22
				
				return 0;
			}

		6)
			#include <iostream>
			using namespace std;

			int main() {
				float f = 12.5;
				float p = 21.5;
				float *ptr = &f;
				
				(*ptr)++;

				*ptr = p;
				
				std::cout << f << "\t" << p  << "\t" << *ptr << std::endl;      //21.5    21.5    21.5
				
				return 0;
			}

		7)
			#include <iostream>
			using namespace std;

			int main() {
				int *ptr;
				int arr[5];			//sizeof int is 4, so 4*5=20.
				
				std::cout << sizeof(arr) << "\t" << sizeof(ptr) << std::endl;       //20        8
				return 0;
			}

		8)
			#include <iostream>
			using namespace std;

			int main() {
				int arr[] = {11,222,333,444};
				
				std::cout << *arr <<"\t"<< *arr+1 << "\t" << arr[0] << std::endl;           //11    12      11
				std::cout << *(arr+2) << std::endl;         //333
				
				return 0;
			}
		
		9)
			#include <iostream>
			using namespace std;

			int main() {
			
				int arr[6] = {11,222,333};
				
				std::cout << arr << "\t" << &arr << "\t" << &arr[0] << std::endl;       //0x7ffed7c23010  0x7ffed7c23010  0x7ffed7c23010
				
				//arr is equal to &arr is equal to &arr[0]
				//all will print same 
				//arr = &arr = &arr[0]
				
				return 0;
			}

		10)
			#include <iostream>
			using namespace std;

			int main() {
				
				int arr[6] = {11,222,333};
				
				std::cout << (arr+1) << std::endl;      //prints the address of 222 element
				
				return 0;
			}

		11)
			#include <iostream>
			using namespace std;

			int main() {
				int arr[6] = {11,222,333};
				
				int *ptr = arr;
				std::cout << ptr[2] << std::endl;      //p[2] = *(p+2)      //333
				
				return 0;
			}

		12)
			#include <iostream>
			using namespace std;
			int main() {
				int arr[6] = {11,222,333,14,15};
				std::cout << *arr << "\t" << *(arr+3) << std::endl;      // 11          14	
				return 0;
			}
		
		13)
			#include <iostream>
			using namespace std;

			int main() {
				int arr[] = {11,222,333,14,15};
			
				int *ptr = arr++;           	//you can increment pointer but not the arr, base address of array you can not change.
										//ERROR.
				std::cout << *ptr << std::endl;
				return 0;
			}

		14)
			#include <iostream>
			using namespace std;
			int main() {
				char ch = 'a';
				char *ptr = & ch;           //you can keep space between '&' and variable name.
				ch++;
				std::cout << *ptr << std::endl;	//b
				return 0;
			}

		15)
			#include <iostream>
			using namespace std;

			int main() {
				char arr[] = "abcdef";
				char *ptr = &arr[0];        //char array & int array difference is there when pointer is used.
				
				std::cout << ptr << std::endl;          //abcdef
				
				ptr = &arr[2];
				std::cout << ptr << std::endl;      //cdef
				
				return 0;
			}
		
		16)
			#include <iostream>
			using namespace std;
		
			int main() {
				char arr[] = "abcdef";
				char *ptr = &arr[0];        //char array & int array behave differently with pointer.
				
				std::cout << ptr << std::endl;          //abcdef
				std::cout << *ptr << std::endl;         //a
				std::cout << *(++ptr) << std::endl;     //b
				
				ptr++;
				std::cout << ptr << std::endl;      //cdef
				
				std::cout << *ptr << std::endl;     //c					for printing one char
		
				return 0;
			}

		17)
			#include <iostream>
			using namespace std;
			int main() {
				char str[] = "abcdef";
				char * ptr = str;
				
				std::cout << str[0] <<"\t"<< ptr[0] << std::endl;           //a     a
				return 0;
			}

		18)
			#include <iostream>
			using namespace std;

			void update(int *n){			//pointer n.
				(*n) = (*n) * 20;
				std::cout << "n inside function: "<< *n << std::endl;			//200
			}
			int main() {
				int i=10;
				std::cout <<"Before: "<< i << std::endl;				//10

				update(&i);				//passing address, it must be received by pointer only.
				
				std::cout <<"After: "<< i << std::endl;					//200
				return 0;
			}
		
		19)
			#include <iostream>
			using namespace std;

			void func(int a[]){
				std::cout << a[0] << std::endl;
				std::cout << a[1] << std::endl;
			}

			int main() {
				int arr[] = {11,222,333,444,555};
				
				std::cout << arr[0] << std::endl;
				
				//passing array from 1st index
				func(arr+1);
				
				std::cout << arr[0] << std::endl;
				
				return 0;
			}

			//or updating value:
				#include <iostream>
				using namespace std;

				void func(int a[]){
					std::cout << a[0] << std::endl;
					std::cout << a[1] << std::endl;
					
					a[0] = 1001;
					a[1] = 1001;
				}

				int main() {
					int arr[] = {11,222,333,444,555};
					
					//passing array from 1st index
					std::cout << arr[0] << std::endl;
					
					func(arr+1);
					
					
					for(int i: arr)
						std::cout << i << "\t";
					return 0;
				}
		
		20)
			#include <iostream>
			using namespace std;

			void sqr(int *p){
				int b = 90;
				
				p = &b;         //here we changed the pointer pointing. now pointer is pointing to another variable
				
				*p = (*p) * (*p);
				std::cout << "pointer inside function : "<< *p << std::endl;            //8100
			}

			int main() {	
				int a = 70;
				sqr(&a);                                //passing address 
				std::cout << a << std::endl;            //70
				
				return 0;
			}

		21)
			#include <iostream>
			using namespace std;

			int main() {
				
				int first = 110;
				int * ptr = &first;
				int ** qtr = &ptr;
				
				int second = (**qtr)++ + 9;
				
				std::cout << first << "\t" << second << std::endl;          //111       119
				return 0;
			}

		22)
			#include <iostream>
			using namespace std;

			int main() {
			
				int first = 100;
				int * ptr = &first;
				int ** qtr = &ptr;
				
				int second = ++(**qtr);
				
				int * rtr = *qtr;
				
				++(*rtr);
				
				std::cout << first << "\t" << second << std::endl;          //102       101
				return 0;
			}
			
		23)
			#include <iostream>
			using namespace std;

			int main() {
				
				int first = 100;
				int * ptr = &first;
				int ** qtr = &ptr;
				
				int second = ++(**qtr);
				
				int * rtr = *qtr;
				
				++(*rtr);
				
				std::cout << first << "\t" << second << std::endl;          //102       101
				return 0;
			}

		24)
			#include <iostream>
			using namespace std;

			void increment(int **doubler){
				++(**doubler);
			}

			int main() {
				int num = 110;
				int * ptr = &num;
				
				increment(&ptr);
				
				std::cout << num << std::endl;      //111
				return 0;
			}

		25)
		25)
		25)
		25)❌Pending
---------------------------------------------------------------------------------------------------------
	07/12/2023
Lecture-28: Reference Variable | Static vs Dynamic Memory | Part-1
	-Reference Variable:
		-Reference variable has same memory location but different names;
		-single variable/ memory location has multiple names means reference variable.
		eg.
			int i=5;
			int& j = i;		//& you can attach it to int (dataType).
			int & k = i;		//& you can keep space in between also.
			int &l = i;		//& you can attach it to variable also. NO error

			-j, k, l are the example of reference variable.
		eg.
			
			#include <iostream>
			using namespace std;

			int main() {
				int i=90;
				
				int& j =i;          //reference variable
				int & k = i;
				int &l = i;
				
				std::cout << i << std::endl;            //90
				
				//reference variable also has same value as i.
				std::cout << "Ref var j "<< j << std::endl;         //90
				std::cout << "Ref var k "<< k << std::endl;         //90
				std::cout << "Ref var l "<< l << std::endl;         //90
				
				//if we change any of the value from i, j, k or l it will affect to other also
				
				k = 99;
				std::cout << i << std::endl;            //99
				
				//After updation.
				std::cout << "Ref var j "<< j << std::endl;         //99
				std::cout << "Ref var k "<< k << std::endl;         //99
				std::cout << "Ref var l "<< l << std::endl;         //99
				
				i++;
				
				std::cout << i << std::endl;            //100
				
				//After i increment. affected to all variable
				std::cout << "Ref var j "<< j << std::endl;         //100
				std::cout << "Ref var k "<< k << std::endl;         //100
				std::cout << "Ref var l "<< l << std::endl;         //100
				return 0;
			}

		-Why?
			-When we pass a variable to function it takes it & create its copy.
			 but when we use reference variable, it don't create copy of variable, 
			 it makes changes to same variable.
			
			eg.
				#include <iostream>
				using namespace std;

				void passValue(int u){
					u++;
				}

				void passRef(int &z){			//z is reference variable, which is another name for i from main function.
					z++;
				}

				int main() {
					int i=90;
					
					//passing Value
					std::cout << "Before " << i << std::endl;   //90
					passValue(i);   
					std::cout << "After " << i << std::endl;    //90
					
					std::cout << std::endl;
					//passing Reference
					std::cout << "Before " << i << std::endl;       //90
					passRef(i);
					std::cout << "After " << i << std::endl;        //91
					return 0;         
				}
	
		//BAD PRACTICE:
			int& RefFunction(){

			}

			//or
			int* RefFunction(){

			}
				
			//returntype is Reference of variable/ memory address of variable.
			//program runs but warning will be there, coz its returning the memory address
			//of 'a' which is local variable of RefFunction, & as soon as function ends the variable gets deleted
			//so that's why.

			int& RefFunction(){                 
				std::cout << "Reference function" << std::endl;
				int a =90;
				return a;           // will not get passed by to main function.
			}

			eg.
				//BAD Practice int*:
					you can write it return type like below, it won't give error
					
					int *functionName(){		
						//* attached to functionName
					}
					
					//or
					int* functionName(){
						//* attached to returnType
					}

					//or
					int*functionName(){
						//* attached to both
					}

					//or
					int * functionName(){
						//* not attached to anything.
					}

					#include <iostream>
						using namespace std;

						int* pointerReturningFunction(){
						//int*pointerReturningFunction(){
						//int *pointerReturningFunction(){

							int a =12;
							int * p = &a;
							
							std::cout << a << std::endl;		//12
							std::cout << p << std::endl;		//memory address
							
							return p;
						}

						int main() {
							int *ptr = pointerReturningFunction();

							//Ask any one thing here either value of its address if you ask both,
							//it prints the correct address but wrong value.

							//if you want to ask both address & value then you need to 
							//allocate the memory to HEAP.
							//for previous case we are allocating memory to stack that's why giving wrong value.		
							// Refere below program also. IMPORTANT.

							//std::cout << ptr << std::endl;
							std::cout << *ptr << std::endl;			//12
							
							return 0;               
						}

					//below program works perfectly fine.
					#include <iostream>
						using namespace std;

						int*pointerReturningFunction(){
							int * p = new int(20);				//Memory allocated on HEAP.
							
							std::cout << p << std::endl;			//0x56105a3ffeb0
							std::cout << *p << std::endl;			//20
							
							return p;
						}

						int main() {
							int *ptr = pointerReturningFunction();

							std::cout << ptr << std::endl;			//0x56105a3ffeb0
							std::cout << *ptr << std::endl;			//20
							
							return 0;               
						}

				//BAD Practice int&:
					-you can write it return type like below, it won't give error
						
						int &functionName(){		
							//& attached to functionName
						}
						
						//or
						int& functionName(){
							//& attached to returnType
						}

						//or
						int&functionName(){
							//& attached to both
						}

						//or
						int & functionName(){
							//& not attached to anything.
						}
					//works fine.
						#include <iostream>
						using namespace std;

						int & RefFunction(){
							int i=88;
							int& j = i;
							std::cout << std::endl;
							std::cout << "inside function: " << std::endl;
							std::cout << i << std::endl;        //88
							std::cout << &j << std::endl;       //0x7ffed7a7eefc
							std::cout << &i << std::endl;       //0x7ffed7a7eefc
							std::cout << std::endl;
							return j;
						}

						int main() {
							int a = RefFunction();              //normal variable that's why different memory address is printed
							std::cout << a << std::endl;        //88
							std::cout << &a << std::endl;       //0x7ffcdfee1704
							
							int &z = RefFunction();             //reference variable, printed same memory address as printed in function 
														 //(but sometimes won't be printed same address, if compiler is optimized then only prints the same address)
														 //better should not use this returning reference function.
							std::cout << z << std::endl;        //88
							std::cout << &z << std::endl;       //0x7ffed7a7eefc
							
							return 0;               
						}

	-Array:
		-BAD practice:
			int n;
			cin>>n;
			int arr[n];		//n is not known at compile time.
							//bad never do this, the size should be constant/number should be known at compile time.
							//if the program knows that the array size is large, then before coming for execution
							//it brings extra memory. eg. int arr[10000];
							//if don't know the size & size is larger then it will exceed memory limit, program gets crashed.
			-here in above case we are taking n from user & creating array on stack.
			-stack have limited/less memory than heap & this stack memory program brings
			 before the starting the execution.
			-suppose stack have 20 bytes of memory size, but you given n=25
			 so it is not able store the 25 values, so program crashes/ terminates abnormally.
			-Solution for this, to use Heap memory (Dynamic memory).
						                       +----------------+
				+-----------+				   |                |
				|           |                    |                |
				|           |                    |                |
				|           |                    |                |
				+-----------+ 				   |                |
                  	  Stack size				   +----------------+
				                     	    		    Heap size
			
		-Static memory allocation:
			-memory alloted from stack
			eg.
				int arr[100];
				char ch[1000];			//depends on stack memory
				int a=45;
				string s = "qwerty";
			
		-Dynamic memory allocation: (HEAP memory)
			-need to use 'new' keyword.
			-memory alloted from heap
			-programmer is responsible for freeing the memory.
			-eg.
				//to create a int variable on heap, use this syntax:
					new int;
					-but above created variable don't have any name,
					 it returns the address so we have to store that address, so
					-Actual syntax
						int *p = new int;			//pointer storing address of that variable which is on Heap.
												//pointer is on stack
					
					eg.
						#include <iostream>
						using namespace std;

						int main() {
							int * p = new int;          //memory alloted on heap
							
							std::cout << p << std::endl;        //0x557055e95eb0
							std::cout << *p << std::endl;       //0
							
							*p = 90;
							
							std::cout << p << std::endl;        //0x557055e95eb0
							std::cout << *p << std::endl;       //90  
							delete p;                   //memory freed from heap
							
							
							return 0;
						}

					//to create a int array on heap, use this syntax:
						new int[10];
						eg.
							#include <iostream>
							using namespace std;

							int main() {
								int n;
								cin>>n;                 //creating dynamic array
								
								int * p = new int[n];          //memory alloted on heap
								
								p[1] = 45;
								p[2] = 60;
								p[3] = 23;
								p[4] = 1;
								
								for(int i=0; i<n; i++)
									// std::cout <<*(p+i) << "\t";         //or
									std::cout << p[i] << "\t";
									
								delete[] p;          //syntax works          //memory freed from heap
								// delete [] p;      //syntax works
								// delete []p;       //syntax works   
								// delete[]p;        //syntax works
								return 0;
							}

							//or
								#include <iostream>
								using namespace std;

								int main() {
									int n;
									cin>>n;
									
									int * arr = new int[n];
									
									for(int i=0; i<n; i++)
										cin>>arr[i];
									
									std::cout << "Array elements are : " << std::endl;
									
									for(int i=0;i<n; i++)
										// std::cout << *(arr+i) << "\t";
										std::cout << i[arr] << "\t";
									return 0;
								}

					//to create a string on heap, use this syntax:
						new string;
					
					//to create a string array on heap, use this syntax:
						new string[10];
					
					//to create a char array on heap, use this syntax:
						new char[10];

			-Total memory used by below line
				1)char * ptr = new char;
					where,
						pointer ptr has 8 bytes of size
						char has 1 byte of size
						so total is 8+1= 9 bytes memory used.
					
				2)int *p1 = new int[10];
					where,
					-pointer p1 has 8 bytes of size
					-int has 4 bytes of size & its of 10 elements
					so total is 4*10 = 40 bytes
					-40 + 8 = 48 bytes of total memory used.
			
	-Dynamic allocated memory uses 8 bytes extra, which is a pointer on stack.
	-in stack (static memory allocation) memory gets released automatically
	-in Dynamic memory allocation, manually have to release the memory.

	void pointer
		-A void pointer is a general-purpose pointer. 
		 that can hold the address of any data type, but it is not associated with any data type.
		-A void pointer can hold an address of any type and can be typecasted to any type.
		
		-A void pointer in C++ is a special pointer that can point to objects of any data type. 
		 In other words, a void pointer is a general purpose pointer that can store the address 
		 of any data type and it can be typecasted to any type. 
		-A void pointer is not associated with any particular data type.

		-The size of a void pointer is different in different systems. 
		-In 16-bit systems, the size of a void pointer is 2 bytes. 
		-In a 32-bit system, the size of a void pointer is 4 bytes. 
		-in a 64-bit system, the size of a void pointer is 8 bytes.

		syntax:
			void *ptr;
			void* pointer_name;
			void * pointer_name;
			void*pointer_name;

		
		In C++, we cannot assign the memory address of a variable to the variable of a different data type. 
		Consider the following example:
			int *ptr;  // integer pointer declaration  
			float a=10.2; // floating variable initialization  
			ptr= &a;  // This statement throws an error.
		
		In the above example, we declare a pointer of type integer, i.e., ptr and a float variable, i.e., 'a'. 
		After declaration, we try to store the address of 'a' variable in 'ptr', 
		but this is not possible in C++ as the variable cannot hold the address of different data types.

		#include <iostream.h>  
		using namespace std;  
		int main() {  
			int *ptr;  
			float f=10.3;  
			ptr = &f; // error  
			std::cout << "The value of *ptr is : " <<*ptr<< std::endl;  
			return 0;  
		}
		In the above program, we declare a pointer of integer type and variable of float type. 
		An integer pointer variable cannot point to the float variable, but it can point to an only integer variable.

		-C++ has overcome the above problem by using the C++ void pointer as 
		a void pointer can hold the address of any data type.

		#include <iostream>  
		using namespace std;  
		int main() {  
			void *ptr;   // void pointer declaration  
			int a=9;   // integer variable initialization  
			ptr=&a;   // storing the address of 'a' variable in a void pointer variable.  
			std::cout << &a << std::endl;  
			std::cout << ptr << std::endl;  
			return 0;  
		}
		In the above program, we declare a void pointer variable 
		and an integer variable where the void pointer contains the address of an integer variable.

		Difference between void pointer in C and C++ :-
			In C, we can assign the void pointer to any other pointer type without any typecasting, 
			whereas in C++, we need to typecast when we assign the void pointer type to any other pointer type.
			eg.
				in C:
					#include <stdio.h>  
					int main() {  
						void *ptr; // void pointer declaration  
						int *ptr1;  // integer pointer declaration  
						int a =90;  // integer variable initialization  
						ptr=&a; // storing the address of 'a' in ptr  
						ptr1=ptr; // assigning void pointer to integer pointer type.  		//without typecasting
						printf("The value of *ptr1 : %d",*ptr1);  
						return 0;  
					}
				
				in C++ :
					#include <iostream>  
					using namespace std;  
					int main() {  
						void *ptr; // void pointer declaration  
						int *ptr1; // integer pointer declaration  
						int data=10; // integer variable initialization  
						ptr=&data;  // storing the address of data variable in void pointer variable  
						ptr1=(int *)ptr; // assigning void pointer to integer pointer  
						std::cout << "The value of *ptr1 is : " <<*ptr1<< std::endl;  
						return 0;  
					}
					In the above program, we declare two pointer variables of type void and int type respectively. 
					We also create another integer type variable, i.e., 'data'. 
					After declaration, we store the address of variable 'data' in a void pointer variable, i.e., ptr. 
					Now, we want to assign the void pointer to integer pointer, 
					in order to do this, we need to apply the cast operator, i.e., (int *) to the void pointer variable. 
					This cast operator tells the compiler which type of value void pointer is holding. 
					For casting, we have to type the data type and * in a bracket like (char *) or (int *).

		-void pointer can not be dereferenced.
			#include <iostream>
			using namespace std;

			int main() {
				// C++ Program to demonstrate that a void pointer
				// cannot be dereferenced
				
				//void pointer
				int a=80;
				void * ptr = &a;
				
				std::cout << ptr << std::endl;      //we can print the address, 
												//but can't print value of void pointer pointing value
											
				// std::cout << *ptr << std::endl;         //error
				
				//to print the value ptr is pointing
				// The void pointer 'ptr' is cast to an integer pointer
				// using '(int*)ptr' Then, the value is dereferenced
				// with `*(int*)ptr` to get the value at that memory location
				std::cout << *(int *) ptr << std::endl;
				
				//or
				int * pointer = (int *) ptr;            //need to tell the compiler that it is a int pointer.
				std::cout << *pointer << std::endl;
				return 0;
			}	

	address TypeCasting:
		In C++, address typecasting is the process of converting a pointer of one type to a pointer of another type.
---------------------------------------------------------------------------------------------------------
	12/12/2023
Lecture-29: Dynamic Memory Allocation of 2D Arrays
	-When you use the HEAP memory, always free it once your work is done.	
	//2D Array Using Dynamic memory (HEAP).
		#include <iostream>
		using namespace std;
		int main() {
			//2D array using dynamic memory (heap)
			int rows,cols;
			std::cout << "Enter no.of Rows: ";
			cin>>rows;
			
			std::cout << "Enter no.of Cols: ";
			cin>>cols;
			
			int ** arr = new int*[rows];        
			
			for(int i=0; i<rows; i++)
				arr[i] = new int[cols];
			
			for(int i=0; i<rows; i++)
				for(int j=0; j<cols; j++)
					cin>>arr[i][j];
					
			for(int i=0; i<rows; i++){
				for(int j=0; j<cols; j++)
					cout<<arr[i][j]<<"\t";
				std::cout << std::endl;
			}
			
			for(int i=0; i<rows; i++)
				delete [] arr[i];               //to delete each array individually
				
			delete [] arr;                  //delete main double pointer holdoing other pointers
			
			return 0;
		}

	//2D jagged array (Array having different no.of columns in rows) Using Dynamic Memory (HEAP):
		#include <iostream>
		using namespace std;

		int main() {
			//2D Jagged array, dynamic way
			int rows, cols;
			std::cout << "Enter Rows:" << std::endl;
			cin>> rows;
			
			int ** arr = new int *[rows];
			
			int ttl_elements =0;
			
			int * indiRowSize = new int[rows];
			
			for(int i=0; i<rows; i++){
				std::cout << "Enter cols in : " << i <<"th row: "<< std::endl;
				cin>>cols;
				
				ttl_elements += cols;
				
				arr[i] = new int [cols];
				indiRowSize[i] = cols;
			}
			
			std::cout << "Enter "<< ttl_elements << " array elements." << std::endl;
			for(int i=0; i<rows; i++){
				std::cout << "In "<< i <<"th row, Enter "<< indiRowSize[i] <<" elements." << std::endl;
				for(int j=0; j<indiRowSize[i]; j++)
					cin>>arr[i][j];
			}
			
			std::cout << "The array elements are : " << std::endl;
			for(int i=0; i<rows; i++){
				for(int j=0; j<indiRowSize[i]; j++)
					std::cout << arr[i][j]<<"\t";
				std::cout << std::endl;
			}
			
			for(int i=0; i<rows; i++){
				//deleting individual array
				delete [] arr[i];
			}
			
			//deleting main array
			delete [] arr;
			delete [] indiRowSize;
					
			return 0;
		}
		//output:
			Enter Rows:
				4
				Enter cols in : 0th row: 
					1
				Enter cols in : 1th row: 
					2
				Enter cols in : 2th row: 
					3
				Enter cols in : 3th row: 
					4
				Enter 10 array elements.
				In 0th row, Enter 1 elements.
				1
				In 1th row, Enter 2 elements.
				1
				2
				In 2th row, Enter 3 elements.
				1
				2
				3
				In 3th row, Enter 4 elements.
				1
				2
				3
				4 
				The array elements are : 
				1
				1       2
				1       2       3
				1       2       3       4
---------------------------------------------------------------------------------------------------------
	14/12/23
Lecture-30: Macros, Global Variables, Inline Functions & Default Args
	-#include<iostream>
		-here #include is a preprocessor directive, tell compiler to add built-in functionality in code
		-like, cout<< function we use to print the output on screen but to access this function we have to add iostream.

		double PI = 3.14;
		-affect on performance, very very small(negligible).
		-used storage to for this variable.
		-sometime or by mistake somebody can change the value also.

	-Macros:
		-Macro syntax #define <name> <value>
		-no need of memory, the value gets replaced wherever you mention the name of Macro.
		-& Macro is not modifiable, means PI = PI +1; not possible.
		-Macro is piece of code in program that is replaced by value of Macro.
		eg.
			#include <iostream>
			#define PI 3.14               //Macro
			using namespace std;

			int main() {
				
				int r=5;
				//double PI = 3.14;				//if we define PI as double then we are taking 8 bytes of memory space & its modifiable. like pi =pi+1;
				double area = PI * r * r;
				std::cout << area << std::endl;
				std::cout << PI << std::endl;
				return 0;
			}

		Practice:
			#include <iostream>
			#define VIVEK 4                 //Macro Defined & value
			using namespace std;

			int main() {
				
				std::cout << VIVEK << std::endl;            //Priting value of Macro
				std::cout << VIVEK+1 << std::endl;          //math operation on Macro
				return 0;
			}

		-A macro is a piece of code in a program that is replaced by the value of the macro. 
		 Macro is defined by #define directive. 
		 Whenever a macro name is encountered by the compiler, 
		 it replaces the name with the definition of the macro. 
		-Macro definitions need not be terminated by a semi-colon(;).
		eg.
			#include <iostream>
			#define LIMIT 9
			using namespace std;

			int main() {
				cout<<"The value of LIMIT : "<< LIMIT;			//The value of LIMIT : 9
				return 0;
			}

		eg.
			#include <iostream>
			//Macro definition
			#define AREA(l,b) (l*b)                 //don't give space between AREA & (l,b)
			using namespace std;

			int main() {
				int len, bre;
				
				std::cout << "Enter len & bre :: " << std::endl;
				cin>>len>>bre;
				
				std::cout << "The Area: "<< AREA(len,bre) << std::endl;         //finding area using Macro
				return 0;
			}
			//output:
				Enter len & bre :: 
				9 9
				The Area: 81
		
		eg.you can define macro & var with same name, but good practice is to use
			different names.

			#include <iostream>
			//Macro definition
			#define area(l,b) (l*b)
			using namespace std;

			int main() {
				int len, bre;
				
				std::cout << "Enter len & bre :: " << std::endl;
				cin>>len>>bre;
				
				int area = area(len,bre);
				
				std::cout << "The Area: "<< area <<std::endl;         //finding area using Macro
				return 0;
			}

		#Types of Macros:
			1]Object-Like macro:
				An object-like macro is a simple identifier that will be replaced by a code fragment. 
				It is called object-like because it looks like an object in code that uses it. 
				It is popularly used to replace a symbolic name with numerical/variable represented as constant.
				eg.
					#include<iostream>
					#define DATE 31
					using namespace std;
					int main(){
						std::cout << "Today is :"<< DATE << "st." << std::endl;			//Today is :31st.
						return 0;
					}

			2]Chain Macros:
				-Macro inside macro is termed as chain macro.
				-In chain macros first of all parent macro is expanded then the child macro is expanded.
				eg.
					#include<iostream>
					using namespace std;
					#define Name fname
					#define fname "Vivek"

					//or this also works
					/*
						#define fname "Vivek"		
						#define Name fname
					*/

					int main(){
						std::cout << "My name is (parent Macro):" << Name << std::endl;
						std::cout << "My first name is (child Macro):: " << fname <<std::endl;
						return 0;
					}
					//output:
						My name is (parent Macro):Vivek
						My first name is (child Macro):: Vivek
					
			3]Multi-line Macros: 
				An object-like macro could have a multi-line. 
				So to create a multi-line macro you have to use backslash-newline.
				eg.
					#include<iostream>
					using namespace std;
					#define ELE 1,\
							2,\
							3,\
							4
					int main(){
						int arr[] = {ELE};
						for(int i=0; i<4; i++)
							std::cout << arr[i] << "\t";	
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;
						#define SUM(a,b)    \
							cout<<"A: "<<a<<"\t"; \
							cout<<"B: "<<b<<"\t"; \
							cout<<"Sum : "<<a+b;

						int main(){
							SUM(5,5);
							return 0;
						}
	
			4]Function-like Macro:
				These macros are the same as a function call. 
				It replaces the entire code instead of a function name. 
				Pair of parentheses immediately after the macro name is necessary. 
				If we put a space between the macro name and the parentheses in the macro definition, 
				then the macro will not work. 
				A function-like macro is only lengthened if and only if its name appears with a pair of parentheses after it.
				If we don’t do this, the function pointer will get the address of the real function and lead to a syntax error.
				eg.
					#include<iostream>
					using namespace std;
					#define MINN(a,b) ((a<b)?cout<<a : cout<<b)
					int main(){
						MINN(14,5);
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;
						#define MINN(a,b) ((a<b)?a:b)           //this value you can assign to another variable

						#define LARG(a,b) ((a<b)?cout<<b:cout<<a)                   //this you cant assign to other variable

						int main(){
							int a =MINN(14,5);
							std::cout << a << std::endl;
							LARG(14,5);
							
							return 0;
						}

	-Global Variable:
		-BAD Practice/ don't use
		-all function can changes its value of variable.
		-same variables(memory location) any function can access.
		-you can use Reference Variable concept.

		#include <iostream>
		using namespace std;

		int main() {
			//local variable for main function
			int a=10;
			
			std::cout << "inside main function A: "<< a << std::endl;
			
			{
				//local variable for this block
				//accessible for this block only
				int a =90, b=88;
				std::cout <<"Inside block A: "<< a << std::endl;
				std::cout << "Inside block B: " << b << std::endl;
			}
			
			// std::cout << b << std::endl;    //can't access b here.
			return 0;
		}
	
		eg.
			#include <iostream>
			using namespace std;
			int score = 99;			//Global variable
			void a(){
				std::cout << "in a " << score  << std::endl;
			}

			void b(){
				std::cout << "in b "<< score << std::endl;
			}

			void c(){
				score++;
				std::cout << "in c: " << score << std::endl;
			}

			int main() {
				a();
				b();
				std::cout << "Main function: "<< score << std::endl;
				
				//this c function call affected score in all other function
				c();
				a();
				b();
				std::cout << "Main function: "<< score << std::endl;
				
				return 0;
			}

	-Inline function:
		-Increases the code readability.
		-increases performance, because when we create a normal function then function call takes little time (negligible) 
		 [kind of performance damage very little, but yes performance damages].
		-In Inline function it don't call to function it just replaces the single line code of that function to where you called.
		-don't create extra memory for (pass by value) function argument.
		-its like macro only, when function having one line code then you can use inline keyword, compiler accept this
		-if function is of 2 to 3 lines of code then sometime compiler accept the function as inline or sometime don't.
		-if function is more than 3 lines then compiler don't consider it as inline function, but code executes without any error.
		eg.	
			#include <iostream>
			using namespace std;

			//inline function
			inline int getMax(int a, int b){
				return (a>b)? a: b;
			}

			int main() {
				std::cout << getMax(5,4) << std::endl;              //getMax(5,4) gets replaced by [(a>b)? a: b] this.
				std::cout << getMax(100,104) << std::endl;
				
				return 0;
			}

	-Default Args:
		-A default argument is a value provided in a function declaration that is automatically assigned by the compiler 
		if the calling function doesn’t provide a value for the argument. 
		In case any value is passed, the default value is overridden. 	
		eg.
			#include <iostream>
				using namespace std;
				void sum(int a, int b, int c=0){            //c is optional argument here
					std::cout << a+b+c  << std::endl;
				}

				int main() {

					sum(10,20);         // not passing last argument which is optional
					sum(5,4,3);         //passing last argument
					
					return 0;
				}
			
			#include <iostream>
				using namespace std;

				void printer(int arr[], int size, int start=0){
				for(int i=start; i<size; i++)
					std::cout << arr[i] << "\t";
				}

				int main() {
				
					int a[] = {1,2,3,4,5,6,7,8,9,10};
					int n=10;
					
					printer(a, n);          //keeping last argument as optional
					std::cout << std::endl;
					printer(a,n,3);
					return 0;
				}

		// valid
			int sum(int x, int y, int z = 0, int w=0).

		// Invalid because z has default value, but w after it doesn't have a default value
			int sum(int x, int y, int z = 0, int w).	

	Constant Variables
		-constant variables identified by the const keyword in C++. 
		-As the name suggests, if we declare any keyword as constant, we can’t change its value throughout the program.
		Note: The constant variable needs to be assigned during initialization only,
		 else it will store garbage values that can’t be changed further.
		Syntax:
			const datatype variable_name = value;
		Example:
			const int a = 5;
---------------------------------------------------------------------------------------------------------
	//18/12/2023
Lecture-31: Learning Recursion the Best Way
	Recursion:
		when function calls itself again & again.
		-splitting big problem into smaller same problem.
		-base case is mandatory in recursion
		-when base condition occurs then it stops calling function again.
		-recursive call always lead towards base case.
		-in base case return is mandatory.
		-if we don't give return in base case then 'segmentation fault' will occur.
		#In RECURSION -> Base case is mandatory (return statement in base case).
				    -> Recursive relation is mandatory.
				    -> Processing part
				if in function if recursive relation [return n*fun(n-1)] comes at the end or after some process is called as Tail Recursion.
				if in function if recursive relation comes before processing or at start is called as tail recursion.
	eg.
		//Factorial of num
			#include <iostream>
			using namespace std;

			int fact(int n){
				if(n==0)
					return 1;
				// std::cout << n << std::endl;
				return n* fact(n-1);                //recursive relation
			}

			int main() {
				int n;
				std::cout << "Enter num: " << std::endl;
				cin>>n;
				
				std::cout << "Factorial of "<< n << " is:";
				n = fact(n);
				std::cout << n << std::endl;
				return 0;
			}

		//Power of num:
			#include <iostream>
			using namespace std;

			long long power(int n, int ex) {
				//base case
				if(ex==0)
					return 1;
					
				return n*power(n,ex-1);
			}

			int main() {
				int num;
				cout<<"Enter num:";
				cin>>num;
				
				int expo;
				std::cout << "Enter its power: ";
				cin>>expo;

				std::cout << num << "^" << expo << ": ";
				std::cout << power(num,expo) << std::endl;
				return 0;
			}
			//output:	
				Enter num:2
				Enter its power: 32
				2^32: 4294967296

		//Counting (Reverse Order):
			#include <iostream>
			using namespace std;

			void printer(int z){
				std::cout << z << " ";
				if(z==0)
					exit(0);                //or you can use just return; instead of exit(0);
					// return;
				printer(z-1);
			}

			int main() {
				int n;
				std::cout << "Enter num: " << std::endl;
				cin>>n;
				
				printer(n);
				return 0;
			}
			//output:
				Enter num: 
					5
					5 4 3 2 1 



			//Original Order:
				#include <iostream>
				using namespace std;

				void printer(int z){
					if(z==0)
						return;
					printer(z-1);
					std::cout << z << " ";
				}

				int main() {
					int n;
					std::cout << "Enter num: " << std::endl;
					cin>>n;
					
					printer(n);
					return 0;
				}
				//output:
					Enter num: 
						5
						1 2 3 4 5 
---------------------------------------------------------------------------------------------------------
	//18/12/2023
Lecture-32: Understanding Recursion the easiest way || Day-2
	Examples:
		1) Reaching Home:
			#include <iostream>
			using namespace std;

			void goingHome(int s, int e){
				std::cout << "Start " << s << ", End " << e << std::endl;
				if(s==e){
					std::cout << "||REACHED HOME||" << std::endl;
					exit(0);
					// return;
				}
				goingHome(s+1, e);
			}

			int main() {
				int start, end;
				std::cout << "Enter start : ";
				std::cin >> start;
				
				std::cout << "Enter end : ";
				cin>>end;
				
				goingHome(start, end);
				return 0;
			}
			//output:
				Enter start : 1
				Enter end : 5
				Start 1, End 5
				Start 2, End 5
				Start 3, End 5
				Start 4, End 5
				Start 5, End 5
				||REACHED HOME||

		2) Fibonacci series by Recursion:
			#include <iostream>
			using namespace std;

			int nthNum(int a){
				if(a == 1)
					return 0;
				else if(a == 2)
					return 1;
				else
					return nthNum(a-1) + nthNum(a-2);
			}

			int main() {
			
				//0 1 1 2 3 5 8 13 21 34 55 89
				int n;
				std::cout << "Enter n:" << std::endl;
				std::cin >> n;
				
				std::cout << n << "th num is : " <<nthNum(n);
				return 0;
			}
			//output:
				Enter n: 12
					12th num is : 89

		#LeetCode Question:
			1) Fibonacci:
				https://leetcode.com/problems/fibonacci-number/description/
				using Recursion:
				class Solution {
					public:
					int fib(int n) {
						if(n==0)
							return 0;
						else if(n==1)
							return 1;
						return (fib(n-1) + fib(n-2));
					}
				};

				//using for loop:
					class Solution {
						public:
						int fib(int n) {
							if(n==0)
								return 0;
							else if(n==1)
								return 1;
							int prev = 0, crnt = 1;
							for(int i=2; i<=n; i++){
								int temp = prev + crnt;
								prev = crnt;
								crnt = temp;
							}
							return crnt;
						}
					};

				//Optimized:
					class Solution {
						public:
						int fib(int n) {
							if(n == 0)
								return 0;
							else if(n == 1)
								return 1;

							int prev=0;
							int cur = 1,sum;
							for(int i=2; i<=n; i++){
								sum = prev + cur;
								prev = cur;
								cur = sum;
							}
							return sum;
						}
					};

				//on C++ Compiler (with Recursion):
					#include <iostream>
					using namespace std;

					int fib(int a){
						if(a == 0)
							return 0;
						else if(a == 1)
							return 1;
						return fib(a-1) + fib(a-2);
					}
					int main() {
						int n;
						cin>> n;
						
						std::cout << "nth num :: "<< fib(n) << std::endl;;
						return 0;
					}

				//On C++ Compiler (without Recursion):
					#include <iostream>
					using namespace std;

					int main() {
					
						int n;
						cin>> n;
						
						int prev=0;
						int cur =1;
						for(int i=2; i<=n; i++){
							int sum = prev + cur;
							prev = cur;
							cur = sum;
						}
							
						std::cout << "nth num :: "<< prev << std::endl;;
					}

			2) Count Ways To Reach The N-th Stairs:
				Problem statement
					You have been given a number of stairs. Initially, you are at the Oth stair, and you
					need to reach the Nth stair. Each time you can either climb one step or two
					steps. You are supposed to return the number of distinct ways in which you can
					climb from the Oth step to Nth step.
					Example:
					N=3
					output =3
					We can climb one step at a time i.e. {(0, 1) (1, 2),(2,3)) or we can climb the first
					two-step and then one step i.e. {(0,2). (1, 3)} or we can climb first one step and
					then two step i.e. {(0,1), (1,3)}.
					Constraints:
						1 <= 'T' <= 10
						0 <= 'N' <= 1015
						Where 'T' is the number of test cases, and 'N' is the number of stairs.
					It is guaranteed that sum of 'N' over all test cases is <= 10^5.
				Sample Input 1 :
					2
					2
					3
					Sample Output 1 :
					2
					3
					Explanation Of Sample Input 1 :
					In the first test case, there are only two ways to climb the stairs, 
					i.e. {1,1} and {2}.

					In the second test case, there are three ways to climb the stairs 
					i.e. {1,1,1} , {1,2} and {2,1}.
					Sample Input 2 :
					2
					4
					5
					Sample Output 2 :
					5
					8
					Explanation Of Sample Input 2 :
						In the first test case, there are five ways to climb the stairs 
						i.e. {1,1,1,1} , {1,1,2} , {2,1,1} , {1,2,1} , {2,2}.

						In the second test case, there are eight ways to climb the stairs
						i.e. {1,1,1,1,1} , {1,1,1,2} , {1,1,2,1}, {1,2,1,1}, {2,1,1},{2,2,1},{2,1,2} and {2,2,1}.
				-for nth stair you use the last stair or 2nd last stair.
				-& for that last stair & 2nd last stair the process will be same, again for that last stair
				-call goes last's last stair or last's 2nd last stair. & sum of all ways will be nth stair sum.
				//Not optimized:
					#include <bits/stdc++.h> 
					int countDistinctWays(int nStairs) {
						if(nStairs == 0)
							return 1;
						
						if(nStairs<0)
							return 0;

						return countDistinctWays(nStairs-1) + countDistinctWays(nStairs-2);
					}

		3) Say Digit:
			//Recursion:
				#include <iostream>
				using namespace std;

				void SayDigit(int n) {
					if(n==0)
						return;
					string store[10] = {"zero ", "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine "};
					int digit = n % 10;
					n /= 10;
					SayDigit(n);
					std::cout << store[digit] << " ";
				}

				int main() {
					int num;
					cout<<"Enter num: ";
					cin>>num;

					std::cout << std::endl;
					SayDigit(num);

					return 0;
				}
			
			//or
				#include <iostream>
				using namespace std;

				int main() {
				
					int num;
					std::cout << "Enter num: " << std::endl;
					cin>>num;
					
					string s = to_string(num);
					for(int i=0; i<s.length(); i ++){
						switch(s[i]){
							case '1':
								std::cout << "one ";
								break;
							case '2':
								std::cout << "two ";
								break;
							case '3':
								std::cout << "three ";
								break;
							case '4':
								std::cout << "four ";
								break;
							case '5':
								std::cout << "five ";
								break;
							case '6':
								std::cout << "six ";
								break;
							case '7':
								std::cout << "seven ";
								break;
							case '8':
								std::cout << "eight ";
								break;
							case '9':
								std::cout << "nine ";
								break;
							case '0':
								std::cout << "zero ";
						}
					}
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	25/12/23
Lecture-33: Recursion and Binary Search | Day-3
	1) Check the given array is sorted or not?
		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;
		int main() {
		
			vector<int> v = {1,2,3,4,5,6,7};
			std::cout <<"is V is sorted? "<< boolalpha  << is_sorted(v.begin(), v.end()) << std::endl;
			
			v= {14,5,6};
			std::cout << "is updated V sorted? " << is_sorted(v.begin(), v.end()) << std::endl;

			return 0;
		}

		//using recursion:
			#include <iostream>
			using namespace std;
			bool isSorted(int arr[], int size){         //or this will also works bool isSorted(int *arr, int size)
				if(size ==0 || size == 1)
					return 1;
				
				if(arr[0] > arr[1])
					return 0;
				return isSorted(arr+1, size-1);
			}
			
			int main() {
			
				int arr[] = {1,2,3,4,5,6,70,9};
				int size = 8;
				std::cout << "is Given array arr is sorted? : "<< boolalpha << isSorted(arr,size) << std::endl;

				return 0;
			}
	
	2) Homework, Sum of array elements using recursion:
		#include <iostream>
		using namespace std;
		int Sum(int *ar, int size){
			if(size == 0)
				return 0;
			
			if(size == 1)
				return ar[0];
			
			return ar[0] + Sum(ar+1, size-1);
		}

		int main() {
			int arr[] = {1,2,3,4,5};
			int size=5;
			std::cout <<"The sum is: " << Sum(arr, size)<<endl;
			
			//2nd
			int arr2[] = {6,7,8,9,10,1,2,3,4,5};
			size=10;
			std::cout << "The sum of arr2: " << Sum(arr2, size) << std::endl;
			
			return 0;
		}

	3) Linear Search using recursion:
		#include <iostream>
		using namespace std;

		void printer(int *array, int size){
			std::cout << std::endl;
			std::cout << "The size of array is: "<< size << std::endl;
			for(int i=0; i<size; i++)
				std::cout << *(array+i) <<"\t";
			std::cout << std::endl;
		}

		bool isPresent(int *a, int size, int toFind){
			printer(a, size);
			if(size == 0)
				return false;
			
			if(a[0] == toFind)
				return true;
			return isPresent(a+1, size-1, toFind);
		}

		int main() {
			int arr[] = {1,2,3,4,5,6,7,8,9,10};
			int key=10, size=10;
			std::cout << "is "<< key << " present in arr: "<<boolalpha<< isPresent(arr, size, key) << std::endl;
			
			int arr2[] = {12,3,51,5,4,90};
			key=51, size=6;
			std::cout << "is "<< key << " present in arr2: "<< isPresent(arr2, size, key) << std::endl;
			key=199;
			std::cout << "is "<< key << " present in arr2: "<< isPresent(arr, size, key) << std::endl;
			
			int arr3[] = {};
			key=1, size=0;
			std::cout << "is "<< key << " present in arr3: "<< isPresent(arr3, size, key) << std::endl;
			return 0;
		}

	4) Binary Search using recursion:
		#include <iostream>
		using namespace std;

		void printer(int *a, int s, int e){
			for(int i=s; i<=e; i++){
				std::cout << a[i] << "\t";
			}
		}

		int BinSearch(int *a, int start, int end, int elementToFind){
			if(start > end)
				return 0;
				
			int mid = start + (end - start)/2;
			
			std::cout << "\nCurrent Value mid Value : (key " << elementToFind << "): " <<  a[mid]<<"\n";
			printer(a, start, end);
			std::cout << std::endl;

			if(a[mid] == elementToFind)
				return true;
			else if(a[mid] > elementToFind)
				return BinSearch(a, start, mid-1,elementToFind);
			//else // else if(a[mid] < elementToFind)              if you want to use this statement, use it. or keep in commented.
			return BinSearch(a, mid+1, end, elementToFind);
		}

		int main() {
			int arr[] = {1,2,3,4,5,6,7,8,9,10};
			
			int key = 80, start=0, end=9;
			std::cout << "is " << key << " present in arr? "<< (BinSearch(arr, start, end, key) ? "Yes" : "No") << std::endl;       //No
			std::cout << std::endl;
			
			key=5;
			std::cout << "is " << key << " present in arr? "<< (BinSearch(arr, start, end, key) ? "Yes" : "No") << std::endl;       //Yes
			std::cout << std::endl;
			
			key=8;
			std::cout << "is " << key << " present in arr? "<< (BinSearch(arr, start, end, key) ? "Yes" : "No") << std::endl;       //Yes
			std::cout << std::endl;
			
			key=11;
			std::cout << "is " << key << " present in arr? "<< (BinSearch(arr, start, end, key) ? "Yes" : "No") << std::endl;       //No
			std::cout << std::endl;
			
			return 0;
		}

	Lecture13 to 15 binary search problem using recursion pending to solve.
	Lecture 13:
		1) First and Last Position of an Element In Sorted Array: //USING RECURSION:
			//Not Optimized:
				#include <bits/stdc++.h>
				int FirstOccRecursion(vector<int> a, int start, int end, int key, int index){

					if(start > end)
						return index;
					
					int mid = (start+end)/2;
					
					if(a[mid] == key)
						index = mid;
					else if(a[mid] < key)
						return FirstOccRecursion(a, mid+1, end, key, index);
					return FirstOccRecursion(a, start, mid-1, key, index);
				}

				int LastOccRecursion(vector<int> a, int start, int end, int key, int index){
					if(start > end)
						return index;
					
					int mid = (start+end)/2;
					if(a[mid] == key)
						index = mid;
					else if(a[mid] > key)
						return LastOccRecursion(a, start, mid-1, key, index);
					return LastOccRecursion(a, mid+1, end, key, index);
				}

				pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k) {

					pair<int, int> ans;

					int s = 0;
					int end = arr.size() - 1;
					
					ans.first = FirstOccRecursion(arr, s, end, k, -1);

					if(ans.first == -1)
						return {-1,-1};
					
					ans.second = LastOccRecursion(arr, s, end, k, -1);
					return ans;
				}

		2) Peak Index in a Mountain Array: //USING RECURSION
			class Solution {
				private:
				int peakIndexFinder(vector<int> a, int s, int e, int index){
					if(s == e)
						return e;

					int mid = (s+e)/2;
					if(a[mid] > a[mid+1])
						return peakIndexFinder(a, s, mid, e);
					return peakIndexFinder(a, mid+1, e, e);        
				}
				public:
				int peakIndexInMountainArray(vector<int>& arr) {
					int s = 0, e = arr.size()-1;
					return peakIndexFinder(arr, s, e, -1);
				}
			};

			//Practiced:
				class Solution {
					private:
					int finder(vector<int> v, int s, int e){
						int mid = (s+e)/2;
						// if(s == e)
						//     return s;

						if(v[mid] > v[mid-1] && v[mid] > v[mid+1])
							return mid;
						else if(v[mid] < v[mid+1])
							return finder(v, mid+1, e);
						return finder(v, s, mid);
					}
					public:
					int peakIndexInMountainArray(vector<int>& arr) {
						int s=0, e=arr.size()-1;
						return finder(arr, s, e);
					}
				};

		3) Find Pivot Index: //USING RECURSION
			//MLE (Memory Limit Exceeded)
			-if you want to get rid of MLE then you can declare vector a as reference vector
			eg.
				int ansIndex(vector<int> &a, int excludeInd)				//&
				-this will get rid of memory limit exceeded.
		
			class Solution {
				private:
				int ansIndex(vector<int> a, int excludeInd){
					int LSum=0, RSum=0;

					//for left side
					for(int l=0; l<excludeInd; l++)
						LSum += a[l];
					
					//for right side
					for(int r=excludeInd+1; r<a.size(); r++)
						RSum += a[r];
					
					if(LSum == RSum)
						return excludeInd;

					if(excludeInd+1 >= a.size())
						return -1;
					
					return ansIndex(a,excludeInd+1);
				}
				public:
				int pivotIndex(vector<int>& nums) {
					int exclude=0;
					return ansIndex(nums, exclude);
				}
			};

			//or Practiced:
				class Solution {
					private:
					int indexFinder(vector<int>& a, int s){
						if(s == a.size())
							return -1;
						
						int Lsum=0;
						Lsum = accumulate(a.begin(), a.begin()+s, Lsum);

						int Rsum=0;
						Rsum = accumulate(a.begin() + s +1, a.end(), Rsum);
						
						if(Lsum == Rsum)
							return s;
						return indexFinder(a, s+1);
					}
					public:
					int pivotIndex(vector<int>& nums) {
						// int start=0;
						// return indexFinder(nums, start);
						return indexFinder(nums, 0);
					}
				};

	Lecture 14:

		❌Pending
---------------------------------------------------------------------------------------------------------
	25/12/23 ---> 28/12/23 ---> 31/12/2023 ---> 03/01/24
Lecture-34: Recursion with Strings | Day-4
	// String printing in Reverse order using Recursion:
		#include <iostream>
		using namespace std;

		void Reverser(string &s, int index) {
			if(index == s.length())
				return;
				
			//recursive call.
			Reverser(s, index+1);
			
			std::cout << s[index];          
		}

		int main() {
			string s = "Vivek";
			std::cout << s << std::endl;
			
			Reverser(s,0);
			return 0;
		}
	
	// Reversing string using Recursion (Double Pointer Approach)
		#include <iostream>
		using namespace std;

		void ReverserRecurser(string& s,int start, int end) {
			if(start > end)
				return ;
			swap(s[start++], s[end--]);

			//recursive call
			ReverserRecurser(s, start, end);
		}

		int main() {
			string s = "Hello World";
			std::cout << s << std::endl;
			
			ReverserRecurser(s, 0, s.size()-1);
			
			std::cout << s << std::endl;
			return 0;
		}

	// Reversing string using Recursion (Single Pointer approach)
		TLE (not optimized)
		#include <bits/stdc++.h> 
		void Reverse(string &str, int index){
			if(index < 0)
				return ;

			char ch = str[index];
			str.erase(index,1);
			str.push_back(ch);
			Reverse(str, index-1);
		}

		string reverseString(string str) {
			Reverse(str, str.length()-1);
			return str;
		}

		//or Optimized:
			#include <bits/stdc++.h> 
			void Reverse(string &str, int start){
				if(start == (str.length()/2))		//or if(start >= (str.length()/2))
					return ;

				swap(str[start], str[str.length()-1-start]);
				Reverse(str, start+1);	
			}

			string reverseString(string str) {
				Reverse(str, 0);
				return str;
			}

	// Checking the string is palindrome or not Using Recursion (Double Pointer Approach):
		-Double Pointer approach
		#include <iostream>
		using namespace std;

		bool isPalin(string st, int s, int e){
			if(s==e)                //if(s>e)       
				return 1;
				
			// if(st[s] == st[e])
			//     return isPalin(st, s+1, e-1);
			// return 0;
			
			//or
			if(st[s] != st[e])
				return false;
			return isPalin(st, s+1, e-1);
		}

		int main() {
			string s = "Vivek";
			std::cout<<"For "<<s<<" : "<<(isPalin(s, 0, s.length()-1)? "Yes" : "No") << std::endl;
			
			s = "MadaM";
			std::cout <<"For "<<s<<" : "<< (isPalin(s, 0, s.length()-1)? "Yes" : "No") << std::endl;
			
			return 0;
		}

	// Checking the string is palindrome or not Using Recursion (Single Pointer Approach):
		#include <iostream>
		using namespace std;

		bool isPalinSinglePointer(string st, int s){
			if(s > st.length()/2)
				return 1;
			
			if(st[s] == st[st.length()-1-s])
				return isPalinSinglePointer(st, s+1);
			return 0;
			
			//or
			// if(st[s] != st[st.length()-1-s])
			//     return 0;
				
			// return isPalinSinglePointer(st,s+1);
		}

		int main() {
			string s = "Vivek";
			std::cout<<"For "<<s<<" : "<< (isPalinSinglePointer(s, 0)? "Yes" : "No") << std::endl;
			
			s = "MadaM";
			std::cout <<"For "<<s<<" : "<< (isPalinSinglePointer(s, 0)? "Yes" : "No") << std::endl;
			
			s = "qwertyuioppoiuytrewq";
			std::cout <<"For "<<s<<" : "<< (isPalinSinglePointer(s, 0)? "Yes" : "No") << std::endl;
			
			s = "qwertyuiopp12oiuytrewq";
			std::cout <<"For "<<s<<" : "<< (isPalinSinglePointer(s, 0)? "Yes" : "No") << std::endl;
			
			return 0;
		}
	
	// Find the Exponent of number:
		#include <iostream>
		using namespace std;

		int power(int x, int z) {
			if(z == 0)
				return 1;
				
			else if(z == 1)
				return x;
				
			//below line works but then are calling function recursively twice, skip below 3 lines & use lines afterwords
				// if(z&1)         //if z is od
				//    return x * power(x,z/2) * power(x,z/2);
				// return power(x,z/2) * power(x,z/2);

			int ans = power(x, z/2);
			if(z%2 == 0)
				return ans * ans;
			return x * ans * ans; 
		}

		int main() {	
			int a,b;
			
			std::cout << "Enter A : " << std::endl;
			cin>>a;
			
			std::cout << "Enter exponent: B: " << std::endl;
			cin>>b;
			
			std::cout << a << "^"<< b << ": " << power(a,b) << std::endl;
			return 0;
		}

	// Bubble Sort using recursion:
		-In Bubble sort we place ith largest element at its right position.
		-1st case the largest element gets placed at end.

		#include <iostream>
		using namespace std;

		void BubbleSortArray(int a[], int size){
			if(size == 0 || size ==1)
				return ;
			
			//1st case solved -largest element gets placed at end of array
			for(int i=0; i<size-1; i++)
				if(a[i] > a[i+1])
					swap(a[i],a[i+1]);
			
			BubbleSortArray(a, size-1);
		}

		int main() {
		
			int arr[] = {3,4,1,7,10,5,8,9,6,2};
			int n=10;
			
			std::cout << "Array : ";
			for(int i=0; i<n; i++)
				std::cout << arr[i] << "\t";
			
			std::cout << std::endl;
			
			BubbleSortArray(arr,n);
			
			std::cout << "Sorted: ";
			int i=0;
			while(i<n)
				std::cout << arr[i++] << "\t";
			
			return 0;
		}

			/*  using recursion output:
				Array : 3       4       1       7       10      5       8       9       6       2
				Sorted: 1       2       3       4       5       6       7       8       9       10
			*/
	
	HW: 
	// Selection Sort 
		Practice:
			#include <iostream>
			using namespace std;

			int main() {
				// int a[] = {1,4,2,10,5,6,3,9,7,8};
				// int n=10;
				
				
				int a[] = {8,55,44,22,33,55,11};
				int n=7;
				
				std::cout << "Original Order: " << std::endl;
				for(int o:a)
					std::cout << o << "\t";
				
				//selection sort (sorted in ascending order)
				for(int i=0; i<n; i++){
					
					int minIndx = i;
					for(int j=i+1; j<n; j++){
						if(a[minIndx] > a[j])
							minIndx = j;
					}
					swap(a[minIndx], a[i]);
				}
				
				std::cout << std::endl;
				for(int k: a)
					std::cout << k << "\t";
				
				std::cout << std::endl;
				
				//selection sort (sorted in descending order)
				for(int i=0; i<n-1; i++){
					int mxIndx=i;
					for(int j=i+1; j<n; j++)
						if(a[mxIndx] < a[j])
							mxIndx = j;
					swap(a[mxIndx], a[i]);
				}
				
				
				std::cout << std::endl;
				for(auto ui: a)
					std::cout << ui << "\t";
				
				return 0;
			}
		
		using Recursion:
			#include <iostream>
			using namespace std;

			//SelectionSort for ascending order
			void SelectionSort(int a[], int size){
				if(size == 0 || size ==1)
					return ;
				
				int mxValueIndx = size-1;
				for(int i=0; i<size-1; i++)
					if(a[i] > a[mxValueIndx])
						mxValueIndx = i;
				swap(a[mxValueIndx], a[size-1]);
				SelectionSort(a, size-1);
			}

			//SelectionSort for descending Order
			void SelectionSortDESC(int a[], int size, int start){
				if(start == size)
					return;
				
				int mxValueIndx = start;
				for(int i=start+1; i<size; i++)
					if(a[mxValueIndx] < a[i])
						mxValueIndx = i;
				swap(a[mxValueIndx], a[start]);
				
				SelectionSortDESC(a, size, start+1);
			}

			int main() {
				// int a[] = {1,4,2,10,5,6,3,9,7,8};
				// int n=10;
				
				
				int a[] = {8,55,44,22,33,55,11};
				int n=7;
				
				std::cout << "Original Order: " << std::endl;
				for(auto ui: a)
					std::cout << ui << "\t";
				
				SelectionSort(a, n);
				
				std::cout << std::endl;
				
				for(auto ui: a)
					std::cout << ui << "\t";
				
				SelectionSortDESC(a, n, 0);    
				
				std::cout << std::endl;
				for(auto ui: a)
					std::cout << ui << "\t";

				return 0;
			}

	// Insertion Sort using Recursion:
		#include <iostream>
		using namespace std;
		void InsertSorting(int arr[], int s, int size){
			if(s >= size)
				return;
				
			int crntValue = arr[s];
			int j=s-1;
			
			while(j >=0){
				if(arr[j] < crntValue)
					break;
					
				arr[j+1] = arr[j];
				j--;
			}
			
			arr[j+1] = crntValue;
			InsertSorting(arr, s+1, size);
		}
		int main() {
			
			int a[] = {90,89,23,34,54,67,78,67,34,12,78,89};   //12 23 34 34 54 67 67 78 78 89 89 90
			int n=12;
			
			// int a[] = {1};
			// int n=1;
			
			std::cout << "Original array:: " ;
			for(int l: a)
				std::cout << l << "\t";
			
			int start = 1;
			int stop = n-1;
			
			InsertSorting(a, start, stop);

			std::cout << "\n\nArray after sorting:: ";
			for(int l: a)
				std::cout << l << "\t";
			
			return 0;
		}

	// Insertion Sort ascending order & descending order:
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		void InsertionSortASC(int z[], int s, int size){
			if(s == size)
				return ;
			
			int j = s - 1;
			int temp = z[s];
			
			while(j>=0){
				if(z[j] < temp)
					break;
				z[j+1] = z[j];
				j--;
			}
			
			z[j+1] = temp;
			
			InsertionSortASC(z, s+1, size);
		}

		void InsertionSortDESC(int o[], int s, int size){
			if(s == size)
				return ;
			
			int temp = o[s];
			int j = s-1;
			
			while(j >= 0){
				if(o[j] > temp)
					break;
				o[j+1] = o[j];
				j--;
			}
			o[j+1] = temp;
			InsertionSortDESC(o, s+1, size);
		}

		int main() {
		
			int a[] = {24,90,3,18,8,9,15,30,50,64,12,13,6,7,1,2,0,11,4,5};
			//0 1 2 3 4 5 6 7 8 9 11 12 13 15 18 24 30 50 64 90
			
			int n=20;
			
			// int a[] = {2,1}, n=2;
			
			std::cout << "Original :" << "\t";
			for(int z: a)
				std::cout << z << "\t";
			
			InsertionSortASC(a, 1, n);
			
			std::cout<< "\nASC Order: " << "\t";
			for(int z: a)
				std::cout << z << "\t";
				
			std::cout <<endl << endl;
			
			int b[] = {50,30,24,90,8,9,15,64,3,18,12,13,6,7,1,2,0,11,4,5}, size=20;
			//90 64 50 30 24 18 15 13 12 11 9 8 7 6 5 4 3 2 1 0
			
			std::cout << "Original: " << "\t";
			for(int o: b)
				std::cout << o << "\t";
			
			InsertionSortDESC(b,1,size);
			
			std::cout << "\nDESC Order: " << "\t";
			
			for(int o: b)
				std::cout << o << "\t";
			
			return 0;
		}
---------------------------------------------------------------------------------------------------------
	16/01/24
Lecture-35: Merge Sort using Recursion | Day-5 
	-We implement Merge sort in recursive way.
	-Merge sort is fastest algorithm compared to Bubble sort, Insertion Sort & Selection sort.
	-2 Approaches are there, 
		1) Create new array & copy values
		2) use indexes
	-Space Complexity for mergeSort algorithm is O(n), where n is length of array
	-Time Complexity is O(n log(n))
	1st Approach:
	code:
		#include <iostream>
		using namespace std;

		void SortedMerge(int *tempArr, int s, int e){
			
			int mid = ( s + e ) / 2;
			
			//length of first half array till mid
			int len1 = mid - s + 1;

			//length of second half array from mid+1 to till end.
			int len2 = e - mid;
			
			//creating new array with size of len1 & len2 respectively
			int *firstArr = new int[len1];
			int *secondArr = new int[len2];

			//this is index of start where value is present
			int value = s;
			
			//copying the first half array to firstArr
			for(int i=0; i<len1; i++){
				firstArr[i] = tempArr[value++];
			}
			
			//copying the second half array to secondArr
			value = mid+1;
			for(int i=0; i<len2; i++){
				secondArr[i] = tempArr[value++];
			}
			
			//sorting logic
			int index1=0, index2=0;
			int mainArrIndex = s;
			
			//checking for both array & which value is less prioritising that value first.
			//if you want to make array in decrementing order, then change the condition in if
			while(index1 < len1 && index2 < len2){
				if(firstArr[index1] < secondArr[index2])				// if(firstArr[index1] > secondArr[index2])
					tempArr[mainArrIndex] = firstArr[index1++];
				else
					tempArr[mainArrIndex] = secondArr[index2++];
				mainArrIndex++;
			}

			//checking individually what if first array contains all smaller element
			//& they got placed in the array & above while loop expired,
			// but the second array's all element is remaining to place that's why checking individually.

			//for first array
			while(index1 < len1){
				tempArr[mainArrIndex++] = firstArr[index1++];
			}
			
			//for second array
			while(index2 < len2){
				tempArr[mainArrIndex++] = secondArr[index2++];
			}
			
			//freed up the memory which we used to create the array on heap
			delete [] firstArr;
			delete [] secondArr;
		}

		void mergeSortBreaker(int *a, int s, int e){
			//if both start & end are on same element
			//then stopping the process of breaking/ splitting the array.
			if(s == e)
				return ;
			
			int mid = ( s + e ) / 2;
			
			//breaking the left part of array
			mergeSortBreaker(a, s, mid);
			
			//breaking the right part of array
			mergeSortBreaker(a, mid+1, e);
			
			//merging the parts which are broken
			SortedMerge(a, s, e);
		}

		int main() {
			int arr[] = {4,3,2,1,10,9,8,7,6,5};
			
			int n = 10;
			int s = 0, e = n-1;
			
			for(int i: arr)
				std::cout << i << "\t";
			
			std::cout << std::endl;
			
			mergeSortBreaker(arr, s, e);
			
			for(int i: arr)
				std::cout << i << "\t";
			return 0;
		}

	-Coding ninja Code Merge Sort:
		Problem statement
			Given a sequence of numbers ‘ARR’. 
			Your task is to return a sorted sequence of ‘ARR’ in non-descending order with help of the merge sort algorithm.
			Example :

			Merge Sort Algorithm -
				Merge sort is a Divide and Conquer based Algorithm. 
				It divides the input array into two-parts, until the size of the input array is not ‘1’. 
				In the return part, it will merge two sorted arrays a return a whole merged sorted array.

			The above illustrates shows how merge sort works.
			Note :
				It is compulsory to use the ‘Merge Sort’ algorithm.
			Constraints :
				1 <= T <= 50
				1 <= N <= 10^4
				-10^9 <= arr[i] <= 10^9

				Time Limit : 1 sec
			Sample Input 1 :
				2
				7
				3 4 1 6 2 5 7
				4
				4 3 1 2
				Sample Output 1 :
				1 2 3 4 5 6 7
				1 2 3 4
				Explanation For Sample Input 1:
				Test Case 1 :
				Given ‘ARR’ : { 3, 4, 1, 6, 2, 5, 7 }
				Then sorted 'ARR' in non-descending order will be : { 1, 2, 3, 4, 5, 6, 7 }. 
				Non-descending order means every element must be greater than or equal to the previse element.

				Test Case 2 :
					Given ‘ARR’ : { 4, 3, 1, 2 }
					Then sorted 'ARR' in non-descending order will be : { 1, 2, 3, 4 }. 
				Sample Input 2 :
				2
				4
				5 4 6 7
				3
				2 1 1
				Sample Output 2 :
				4 5 6 7
				1 1 2

		#include <bits/stdc++.h>
		void sortedMergeFunction(vector<int> &z, int s, int e) {
			
			int mid = (s + e) /2;

			int len1 = mid - s + 1;
			int len2 = e - mid;

			int *firstArr = new int[len1];
			int *secondArr = new int[len2];

			int value = s;
			//copying the values first arr
			for(int i=0; i<len1; i++)
				firstArr[i] = z[value++];
			
			//copying the values second arr
			for(int i=0; i<len2; i++)
				secondArr[i] = z[value++];

			int startIndx = s;
			int indx1 = 0;
			int indx2 = 0;

			//checking for both array & which value is less prioritising that value first.
			while(indx1 < len1 && indx2 < len2){
				if(firstArr[indx1] < secondArr[indx2])
					z[startIndx] = firstArr[indx1++];
				else
					z[startIndx] = secondArr[indx2++];
				
				startIndx++;
			}

			//need to check individually
			while(indx1 < len1)
				z[startIndx++] = firstArr[indx1++];
				
			while(indx2 < len2)
				z[startIndx++] = secondArr[indx2++];
				
			delete [] firstArr;
			delete [] secondArr;
		}

		void Splitting(vector<int> &a, int s, int e) {
			if(s == e)
				return ;

			int mid = (s + e)/2;

			//leftArray
			Splitting(a, s, mid);

			//rightArray
			Splitting(a, mid+1, e);

			//the array which i broke need to merge them back
			sortedMergeFunction(a, s, e);
		}

		void mergeSort(vector <int> & arr, int n) {
			int start = 0;
			int end = n-1;
			Splitting(arr, start, end);
		}

	2nd Approach: using just vector
		void mergeBack(vector<int> &b, int s, int e){
			vector<int> H;
			int mid = (s+e)/2, i, j;

			for(i=s, j= mid+1; i<=mid && j<=e;)
				if(b[i] < b[j])
					H.push_back(b[i++]);
				else
					H.push_back(b[j++]);

			while(i<=mid)
				H.push_back(b[i++]);

			while(j<=e)
				H.push_back(b[j++]);

			int cnt=0;
			for(int i=s; i<=e; i++)
				b[i] = H[cnt++];
		}

		void split(vector<int>& a, int s, int e){
			if(s == e)
				return ;

			int mid = (s+e)/2;
			split(a, s, mid);
			split(a, mid+1, e);

			mergeBack(a, s, e);
		}

		void mergeSort(vector < int > & arr, int n) {
			split(arr, 0, n-1);
		}

	-Application:
		Sorting large datasets:
			Merge sort is particularly well-suited for sorting large datasets 
			due to its guaranteed worst-case time complexity of O(n log n).

		External sorting:
			Merge sort is commonly used in external sorting, 
			where the data to be sorted is too large to fit into memory.

		Custom sorting:
			Merge sort can be adapted to handle different input distributions, 
			such as partially sorted, nearly sorted, or completely unsorted data.
	
	Advantages of Merge Sort:
		Stability: 
			Merge sort is a stable sorting algorithm, 
			which means it maintains the relative order of equal elements in the input array.

		Guaranteed worst-case performance: 
			Merge sort has a worst-case time complexity of O(N logN), 
			which means it performs well even on large datasets.

		Parallelizable: 
			Merge sort is a naturally parallelizable algorithm, 
			which means it can be easily parallelized to take advantage of multiple processors or threads.

	Drawbacks of Merge Sort:
		Space complexity: 
			Merge sort requires additional memory to store the merged sub-arrays during the sorting process.
			The Space complexity of merge sort algorithm is O(n).

		Not in-place: 
			Merge sort is not an in-place sorting algorithm, 
			which means it requires additional memory to store the sorted data. 
			This can be a disadvantage in applications where memory usage is a concern.

		Not always optimal for small datasets: 
			For small datasets, Merge sort has a higher time complexity than some other sorting algorithms, 
			such as insertion sort. This can result in slower performance for very small datasets.

	-Dry run + recursion tree :
		#include <iostream>
			using namespace std;

			void SortNmerge(int *p, int s, int e) {
				int mid = (s + e) / 2;
				int len1 = mid - s + 1;
				int len2 = e - mid;
				
				int *firstArr = new int[len1];
				int *secondArr = new int[len2];
				
				int index=s;
				for(int i=0; i<len1; i++)
					firstArr[i] = p[index++];
				
				for(int i=0; i<len2; i++)
					secondArr[i] = p[index++];
				
				int mainIndex = s;
				int index1=0, index2=0;
				
				while(index1 < len1 && index2< len2){
					if(firstArr[index1] < secondArr[index2])
						p[mainIndex] = firstArr[index1++];
					else
						p[mainIndex] = secondArr[index2++];
					mainIndex++;
				}
				
				while(index1 < len1)
					p[mainIndex++] = firstArr[index1++];
				
				while(index2 < len2)
					p[mainIndex++] = secondArr[index2++];
				
				delete [] firstArr;
				delete [] secondArr;
			}

			void Splitter(int a[],int s, int e){
				if(s == e)
					return ;
				
				int mid = (s + e) / 2;
				
				Splitter(a, s, mid);
				Splitter(a, mid+1, e);
				SortNmerge(a, s, e);
			}

			int main() {
				int arr[] = {1,2,3,4,5,10,9,8,7,6};
				int len = 10;
				
				for(int i: arr)
					std::cout << i <<"\t";              //1       2       3       4       5       10      9       8       7       6
					
				std::cout << std::endl;
				
				int start=0, end=len-1;
				Splitter(arr, start, end);
				
				for(int a: arr)
					std::cout << a << "\t";             //1       2       3       4       5       6       7       8       9       10
				return 0;
			}
		=> ❌Pending
		
	-Inversion count problem:
		GFG Problem: Count Inversions
			Given an array of integers. Find the Inversion Count in the array. 
			Inversion Count: For an array, inversion count indicates how far (or close) 
			the array is from being sorted. If the array is already sorted then the inversion count is 0.
			If an array is sorted in the reverse order then the inversion count is the maximum. 
			Formally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.
			Example 1:
				Input: N = 5, arr[] = {2, 4, 1, 3, 5}
				Output: 3
				Explanation: The sequence 2, 4, 1, 3, 5 
				has three inversions (2, 1), (4, 1), (4, 3).

			Example 2:
				Input: N = 5
				arr[] = {2, 3, 4, 5, 6}
				Output: 0
				Explanation: As the sequence is already 
				sorted so there is no inversion count.

			Example 3:
				Input: N = 3, arr[] = {10, 10, 10}
				Output: 0
				Explanation: As all the elements of array 
				are same, so there is no inversion count.

			Your Task:
			You don't need to read input or print anything.
			Your task is to complete the function inversionCount() which takes the array arr[] 
			and the size of the array as inputs and returns the inversion count of the given array.

			Expected Time Complexity: O(NLogN).
			Expected Auxiliary Space: O(N).

			Constraints:
				1 ≤ N ≤ 5*10^5
				1 ≤ arr[i] ≤ 10^18

		//Not Optimized:
			class Solution{
				public:
				// arr[]: Input Array
				// N : Size of the Array arr[]
				// Function to count inversions in the array.
				long long int inversionCount(long long arr[], long long N) {
					long long int cnt=0;
					for(int i=0; i<N-1; i++)
						for(int j=i+1; j<N; j++)
							if(arr[i] > arr[j])
								cnt++;

					return cnt;
				}
			};

		//Optimized: (Merge Sort)
			class Solution{
				public:
				// arr[]: Input Array
				// N : Size of the Array arr[]
				// Function to count inversions in the array.
				long long int merge_helper(long long int arr[], int low, int high, int mid) {
					long long int count = 0;
					int left_size = mid - low + 1;
					int right_size = high - mid;
				
					vector<long long int> left(left_size);
					vector<long long int> right(right_size);
				
					for (int i = 0; i < left_size; i++) {
						left[i] = arr[low + i];
					}
					for (int i = 0; i < right_size; i++) {
						right[i] = arr[mid + 1 + i];
					}
				
					int i = 0;
					int j = 0;
					int k = low;
				
					while (i < left_size && j < right_size) {
						if (left[i] <= right[j]) {
							arr[k] = left[i];
							i++;
						} else {
							arr[k] = right[j];
							j++;
							count += (left_size - i);
						}
						k++;
					}
				
					while (i < left_size) {
						arr[k] = left[i];
						i++;
						k++;
					}
				
					while (j < right_size) {
						arr[k] = right[j];
						j++;
						k++;
					}
				
					return count;
				}
				
				long long int merge_sort_helper(long long int arr[], int low, int high) {
					long long int count = 0;
					if (low < high) {
						int mid = low + (high - low) / 2;
						count += merge_sort_helper(arr, low, mid);
						count += merge_sort_helper(arr, mid + 1, high);
						count += merge_helper(arr, low, high, mid);
					}
					return count;
				}
				
				long long int inversionCount(long long arr[], long long N) {
					return merge_sort_helper(arr, 0, N-1);
				}
			};
---------------------------------------------------------------------------------------------------------
	31/01/24
Lecture-36: Quick Sort using Recursion | Day-6
	Theory:
		QuickSort is a sorting algorithm based on the Divide and Conquer algorithm 
		that picks an element as a pivot and partitions the given array around the picked pivot 
		by placing the pivot in its correct position in the sorted array.

		The key process in quickSort is a partition(). 
		The target of partitions is to place the pivot (any element can be chosen to be a pivot) 
		at its correct position in the sorted array and put all smaller elements to the left of the pivot, 
		and all greater elements to the right of the pivot.

		Partition is done recursively on each side of the pivot after the pivot is placed in its correct position 
		and this finally sorts the array.

		Choice of Pivot:
			There are many different choices for picking pivots. 
			-Always pick the first element as a pivot.
			-Always pick the last element as a pivot.
			-Pick a random element as a pivot.
			-Pick the middle as the pivot.
		
		Partition Algorithm:
			The logic is simple, we start from the leftmost element and 
			keep track of the index of smaller (or equal) elements as i. 
			While traversing, if we find a smaller element, 
			we swap the current element with arr[i]. 
			Otherwise, we ignore the current element.

		Space Complexity Analysis of Quick Sort
			The required space is O(1) as we are not using any extra space in the algorithm. 
			if we don’t consider the recursive stack space. 
			If we consider the recursive stack space then, in the worst case quicksort could make O(N).
		
		Time Complexity:
			Best Case: Ω (N log (N))
				The best-case scenario for quicksort occur when the pivot chosen at the each step divides the array into roughly equal halves.
				In this case, the algorithm will make balanced partitions, leading to efficient Sorting.
			Average Case: θ (N log (N))
				Quicksort’s average-case performance is usually very good in practice, 
				making it one of the fastest sorting Algorithm.
			Worst Case: O(N²)
				The worst-case Scenario for Quicksort occur when the pivot at each step consistently 
				results in highly unbalanced partitions. 
				When the array is already sorted and the pivot is always chosen as the smallest or largest element. 
				To mitigate the worst-case Scenario, various techniques are used such as choosing a good pivot 
				(e.g., median of three) and using Randomized algorithm (Randomized Quicksort ) to shuffle the element before sorting.
			
		Advantages of Quick Sort:
			It is a divide-and-conquer algorithm that makes it easier to solve problems.
			It is efficient on large data sets.
			It has a low overhead, as it only requires a small amount of memory to function.

		Disadvantages of Quick Sort:
			It has a worst-case time complexity of O(N2), which occurs when the pivot is chosen poorly.
			It is not a good choice for small data sets.
			It is NOT a Stable sort, meaning that if two elements have the same key, 
			their relative order will not be preserved in the sorted output in case of quick sort, 
			because here we are swapping elements according to the pivot’s position (without considering their original positions).

		Quick Sort:
			Quick sort is generally preferred for arrays over merge sort,
			because it has better space complexity. 
			
			Quick sort is an in-place sorting algorithm, 
			which means it doesn't require additional memory to sort the elements. 
			
			Merge sort, on the other hand, typically requires additional memory for temporary arrays during the merge phase. 
			
			Quick sort also has good cache locality and can be easily implemented in-place. 
			In Quick Sort, we can use the middle element as the pivot and partition the array into two sub-arrays around the pivot. 
			
			Merge sort is preferred for linked lists over arrays. 
			This is because in a linked list the insert operation takes only O(1) time and 
			space which implies that we can implement merge operation in constant time. 

		HomeWork:
			-Quick sort is not a Stable Algorithm
			-Quick Sort is in-place sorting algorithm.

	Code:
		First element as pivot approach:
			#include<iostream>
			using namespace std;

			int partition( int arr[], int s, int e) {
				int cnt = 0;
				for(int i = s+1; i<=e; i++) {
					if(arr[i] <= arr[s]) {
						cnt++;
					}
				}

				//place pivot at right position
				int pivotIndex = s + cnt;
				swap(arr[pivotIndex], arr[s]);

				//left and right wala part smbhal lete h 
				int i = s, j = e;

				while(i < pivotIndex && j > pivotIndex) {

					while(arr[i] <= arr[pivotIndex]) {
						i++;
					}

					while(arr[j] > arr[pivotIndex]) {
						j--;
					}
					
					if(i < pivotIndex && j > pivotIndex) {
						swap(arr[i++], arr[j--]);
					}
				}
				return pivotIndex;
			}

			void quickSort(int arr[], int s, int e) {

				//base case
				if(s >= e) 
					return ;

				//partitioon karenfe
				int p = partition(arr, s, e);

				//left part sort karo
				quickSort(arr, s, p-1);

				//right wala part sort karo
				quickSort(arr, p+1, e);

			}

			int main() {
				int arr[] = {43,595,348,857,684,94,108,542,732,655,563,434,964,92,680,434,321,966,835,774,65,984};
				int n = 22;

				for(int i: arr)
					std::cout << i << "\t";
					
				std::cout  << std::endl;
				quickSort(arr, 0, n-1);

				for(int i: arr)
					std::cout << i << "\t";

				return 0;
			}

		Last element as pivot approach:
			#include <iostream>
			using namespace std;
			int Partitioner(int *a, int s, int e){
				int pivot = a[e]; // Choose the last element as the pivot
				int i = s - 1; // Index of smaller element
				
				for (int j = s; j <= e - 1; j++) {
					if (a[j] <= pivot) {
						i++; // Increment index of smaller element
						swap(a[i], a[j]);
					}
				}
				swap(a[i + 1], a[e]);
				return i + 1;
			}
			void quickSort(int *a, int s, int e) {
				
				// base condition
				if(s >= e)
					return ;
				
				// make partition
				int partition_index = Partitioner(a, s, e);
				
				
				// handling left part of array
				quickSort(a, s, partition_index-1);
				
				// handling right part of array
				quickSort(a, partition_index+1, e);
			}

			int main() {
				int arr[] = {43,595,348,857,684,94,108,542,732,655,563,434,964,92,680,434,321,966,835,774,65,984};
				for(int o: arr)
					std::cout << o << "\t";
					
				std::cout << std::endl;
				int n = 22;
				quickSort(arr, 0, n-1);
				
				std::cout << std::endl;
				for(int o: arr)
					std::cout << o << "\t";
				return 0;
			}	

	Dry Run:
		❌Pending
---------------------------------------------------------------------------------------------------------
	21/02/24
Lecture-37: Recursion-Subsets/ Subsequences of String
	1) Subsets:
		Given an integer array nums of unique elements, return all possible 
		subsets(the power set).
		The solution set must not contain duplicate subsets. Return the solution in any order.

		Example 1:
			Input: nums = [1,2,3]
			Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

		Example 2:
			Input: nums = [0]
			Output: [[],[0]]
	
		Constraints:
			1 <= nums.length <= 10
			-10 <= nums[i] <= 10
			All the numbers of nums are unique.

		class Solution {
			public:
			void gen(vector<vector<int>> &a, vector<int> sub, vector<int> main, int i){
				if(i == main.size()){
					a.push_back(sub);
					return ; 
				}

				// exclude call first
				gen(a, sub, main, i+1);

				// include call next
				sub.push_back(main[i]);
				gen(a, sub, main, i+1);
			}

			vector<vector<int>> subsets(vector<int>& nums) {
				int index=0;
				vector<int> sub;
				vector<vector<int>> ans;
				gen(ans, sub, nums, index);
				return ans;
			}
		};

	// or the above gives you answer in reverse order, this below approach gives you original	order answer
		#include <iostream>
		#include<vector>
		using namespace std;

		void Generator(vector<int> &main, int i, vector<int> ans, vector<vector<int>> &sub){
			if(i == main.size()){
				sub.push_back(ans);
				return ;
			}
			
			ans.push_back(main[i]);
			
			// include call
			Generator(main, i+1, ans, sub);
			
			ans.pop_back();
			// exclude call
			Generator(main, i+1, ans, sub);
		}

		int main() {
			std::vector<int> v = {1,2,3};
			vector<vector<int>> subSequences;
			vector<int> ans;
			
			Generator(v, 0, ans, subSequences);
			for(auto &row: subSequences){
				if(row.empty()){
					cout<<"empty set";
					continue;
				}
				for(int i: row)
					std::cout << i << "\t";
				std::cout << std::endl;
			}
			return 0;
		}

	2) Subsequences of String
		Problem statement
			You are given a string 'STR' containing lowercase English letters from a to z inclusive. 
			Your task is to find all non-empty possible subsequences of 'STR'.

			A Subsequence of a string is the one which is generated by deleting 0 or 
			more letters from the string and keeping the rest of the letters in the same order.
			Constraints:
				1 <= T <= 10 
				1 <=  |STR| <= 16
				Where |STR| represents the length of the string 'STR'.
				Time Limit: 1 sec

			Sample Input 1:
				1 
				abc
				Sample Output 1:
				a ab abc ac b bc c
				Explanation of sample input 1:
				All possible subsequences of abc are :  
				“a” , “b” , “c” , “ab” , “bc” , “ac”, “abc”
				Sample Input 2:
				1
				bbb
				Sample Output 2:
				b b b bb bb bb bbb

		#include <bits/stdc++.h> 
		void generator(string main, vector<string> &a, string s, int i){
			if(i == main.size()){
				if(s.length()!=0)
					a.push_back(s);
				return ;
			}
			
			// exclude call
			generator(main, a, s, i+1);

			// include call
			s +=main[i];
			generator(main, a, s, i+1);
		}

		vector<string> subsequences(string str){
			vector<string> ans;
			string temp;
			generator(str, ans, temp, 0);
			return ans;
		}

	HomeWork:
		❌Pending  using bit manipulation
---------------------------------------------------------------------------------------------------------
	21/02/24
Lecture-38: Phone Keypad Problem Recursion
	Q. Letter Combinations of a Phone Number
		problem statement:
			Given a string containing digits from 2-9 inclusive, 
			return all possible letter combinations that the number could represent.
			Return the answer in any order.
			A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

			Example 1:
				Input: digits = "23"
				Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

			Example 2:
				Input: digits = ""
				Output: []

			Example 3:
				Input: digits = "2"
				Output: ["a","b","c"]

			Constraints:
				0 <= digits.length <= 4
				digits[i] is a digit in the range ['2', '9'].

		// Own solution:
			class Solution {
				public:
				vector<string> letterCombinations(string digits) {
					map<int, string> mapper = {{2, "abc"},
											{3, "def"},
											{4, "ghi"},
											{5, "jkl"},
											{6, "mno"},
											{7, "pqrs"},
											{8, "tuv"},
											{9, "wxyz"}};
					vector<string> temp;
					string s1 = mapper[digits[0]-'0'];
					for(char ch: s1){
						temp.push_back(string(1,ch));
					}

					for(int i=1; i<digits.size(); i++){
						string s2 = mapper[digits[i]-'0'];
						vector<string> subTempHolder;

						for(int z=0; z<temp.size(); z++){
							for(int j=0; j<s2.length(); j++){
								subTempHolder.push_back(temp[z] + s2[j]);    
							}
						}
						// temp.clear();
						temp = subTempHolder;
					}

					sort(temp.begin(), temp.end());
					return temp;
				}
			};

		// Lecture Solution: (Back-tracking)
			class Solution {
				public:
				string mapper[10] = {"", "", "abc","def","ghi","jkl","mno","pqrs","tuv","wyxz"};

				void Generator(string main, int i, string first_string, vector<string> &output) {
					if(i == main.size()){
						output.push_back(first_string);
						return ;
					}

					string s = mapper[main[i] - '0'];
					for(int z=0; z<s.length(); z++){
						first_string.push_back(s[z]);
						Generator(main, i+1, first_string, output);
						first_string.pop_back();
					}
				}

				vector<string> letterCombinations(string digits) {
					vector<string> ans;

					// means if digit size is 0 then just return empty vector
					// if(!digits.size())
					//     return ans;
					// or
					if(digits.size()==0)
						return ans;

					string tempHolder;
					int index=0;
					Generator(digits, index, tempHolder, ans);
					return ans;
				}
			};
---------------------------------------------------------------------------------------------------------
	23/02/24
Lecture-39: Permutations of a String
	-1st Approach:
		using data structure & map something
		❌Pending

	-2nd Approach:
		Permutations:
			Problem Statement:
				Given an array nums of distinct integers, return all the possible permutations. 
				You can return the answer in any order.
				Example 1:
					Input: nums = [1,2,3]
					Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

				Example 2:
					Input: nums = [0,1]
					Output: [[0,1],[1,0]]

				Example 3:
					Input: nums = [1]
					Output: [[1]]
			
				Constraints:
					1 <= nums.length <= 6
					-10 <= nums[i] <= 10
					All the integers of nums are unique.
			
			// using built in method:
				-built in method need the array should be in sorted order, else next_permutation will not work.
				- Using while loop:
					class Solution {
						public:
						vector<vector<int>> permute(vector<int>& nums) {
							vector<vector<int>> ans;
							sort(nums.begin(), nums.end());
							
							// this line is keep the original sequence
							ans.push_back(nums);

							// this line is gets executes while there are next permutation are present
							while(next_permutation(nums.begin(), nums.end()))
								ans.push_back(nums);
							return ans;
						}
					};
		
				- Using Do-While loop:
					class Solution {
						public:
						vector<vector<int>> permute(vector<int>& nums) {
							vector<vector<int>> ans;

							// array should be sorted before passing for the next permutation method       
							sort(nums.begin(), nums.end());
							
							do{
								ans.push_back(nums);
							}while(next_permutation(nums.begin(), nums.end()));
							return ans;
						}
					};
			
			// without using built in method:
				class Solution {
					private:
					void GenPermute(vector<int> main, vector<vector<int>> &out, int i){
						if(i == main.size()){
							out.push_back(main);
							return ;
						}

						// for every element giving the chance to get placed at index i
						for(int j=i; j<main.size(); j++){
							swap(main[i], main[j]);
							GenPermute(main, out, i+1);
							swap(main[i], main[j]);
						}
					}
					public:
					vector<vector<int>> permute(vector<int>& nums) {
						vector<vector<int>> ans;
						GenPermute(nums, ans, 0);
						return ans;
					}
				};

		Permutations of string:
		Problem statement:
			You are given a string 'STR' consisting of lowercase English letters. 
			Your task is to return all permutations of the given string in lexicographically increasing order.
			String A is lexicographically less than string B, 
			if either A is a prefix of B (and A ≠ B), or 
			there exists such i (1 <= i <= min(|A|, |B|)), 
			that A[i] < B[i], and for any j (1 <= j < i) A[i] = B[i]. 
			Here |A| denotes the length of the string A.

			For example :
				If the string is “bca”, then its permutations in lexicographically increasing order are
				{ “abc”, “acb”, “bac”, “bca”, “cab”, “cba” }.
			Note:
				Given string contains unique characters.
			Constraints :
				1 <= T <= 5
				1 <= |STR| <= 9

				Where |STR| is the length of the string.

				Time Limit: 1 sec
			Sample Input 1:
				3
				abc
				bc
				c
				Sample Output 1:
				abc acb bac bca cab cba
				bc cb
				c
				Explanation for Sample Input 1:
				In the 1st test case, there are 6 permutations of the given string.
				In the 2nd test case, there are 2 permutations of the given string.
				In the 3rd test case, there is only 1 permutation of the given string.
				Sample Input 2:
				1
				xyz
				Sample Output 2:
				xyz xzy yxz yzx zxy zyx 

		#include <bits/stdc++.h>
		void GenPermut(string s, vector<string>& ans, int i){
			if(i == s.size()){
				ans.push_back(s);
				return ;
			}

			for(int j=i; j<s.size(); j++){
				swap(s[i], s[j]);
				GenPermut(s, ans, i+1);

				// This below line is not necessary
				// swap(s[i],s[j]);
			}
		}
		vector<string> generatePermutations(string &str) {
			vector<string> ans;
			GenPermut(str, ans, 0);
			sort(ans.begin(), ans.end());
			return ans;
		}

		// using built in method:
			-The string is must be sorted before passing
			#include <bits/stdc++.h>
			vector<string> generatePermutations(string &str) {
				vector<string> ans;
				sort(str.begin(), str.end());
				
				ans.push_back(str);
				while(next_permutation(str.begin(), str.end()))
					ans.push_back(str);

				return ans;
			}
		
		// with do-while loop
			#include <bits/stdc++.h>
			vector<string> generatePermutations(string &str) {
				vector<string> ans;
				sort(str.begin(), str.end());

				do{
					ans.push_back(str);
				}while(next_permutation(str.begin(), str.end()));
				return ans;
			}
---------------------------------------------------------------------------------------------------------
	01/03/2024
Lecture-40: Rat in a Maze Problem
	Q. Rat in a Maze Problem - I:
		Problem statement:
			Consider a rat placed at (0, 0) in a square matrix of order N * N. It has to reach the destination at (N - 1, N - 1). Find all possible paths that the rat can take to reach from source to destination. The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right). Value 0 at a cell in the matrix represents that it is blocked and rat cannot move to it while value 1 at a cell in the matrix represents that rat can be travel through it.
			Note: In a path, no cell can be visited more than one time. If the source cell is 0, the rat cannot move to any other cell.

			Example 1:
			Input:
			N = 4
			m[][] = {{1, 0, 0, 0},
				{1, 1, 0, 1}, 
				{1, 1, 0, 0},
				{0, 1, 1, 1}}
			Output:
			DDRDRR DRDDRR
			Explanation:
			The rat can reach the destination at 
			(3, 3) from (0, 0) by two paths - DRDDRR 
			and DDRDRR, when printed in sorted order 
			we get DDRDRR DRDDRR.
			Example 2:
			Input:
			N = 2
			m[][] = {{1, 0},
				{1, 0}}
			Output:
			-1
			Explanation:
			No path exists and destination cell is 
			blocked.
			Your Task:  
			You don't need to read input or print anything. Complete the function printPath() which takes N and 2D array m[ ][ ] as input parameters and returns the list of paths in lexicographically increasing order. 
			Note: In case of no path, return an empty list. The driver will output "-1" automatically.

			Expected Time Complexity: O(3^(N^2)).
			Expected Auxiliary Space: O(L * X), L = length of the path, X = number of paths.

			Constraints:
				2 ≤ N ≤ 5
				0 ≤ m[i][j] ≤ 1
		
		class Solution{
			private:
				bool CanIVisit(int r, int c, vector<vector<int>> vis, vector<vector<int>> main){
					if((r >= 0 && r < main.size()) && (c >= 0 && c < main.size()) && (!vis[r][c]) && main[r][c])
						return 1;
					return 0;
				}
			
				void PathFinder(vector<vector<int>> main, int r, int c, vector<string> &ans, vector<vector<int>> vis, string holder){
					if(r == main.size()-1 && c == main.size()-1){
						ans.push_back(holder);
						return ;
					}
					vis[r][c] = 1;
					int newR, newC;
					// for Down
					newR = r+1, newC = c;
					if(CanIVisit(newR, newC, vis, main)){
						holder += "D";
						PathFinder(main, newR, newC, ans, vis, holder);
						holder.pop_back();
					}
					
					// for Right
					newR = r, newC = c+1;
					if(CanIVisit(newR, newC, vis, main)){
						holder += "R";
						PathFinder(main, newR, newC, ans, vis, holder);
						holder.pop_back();
					}
					
					// for Up
					newR = r-1, newC = c;
					if(CanIVisit(newR, newC, vis, main)){
						holder += "U";
						PathFinder(main, newR, newC, ans, vis, holder);
						holder.pop_back();
					}
					
					// for Left
					newR = r, newC = c-1;
					if(CanIVisit(newR, newC, vis, main)){
						holder += "L";
						PathFinder(main, newR, newC, ans, vis, holder);
						holder.pop_back();
					}
					
					vis[r][c] = 0;
				}
			public:
			vector<string> findPath(vector<vector<int>> &m, int n) {
				vector<string> ans;
				if(m[0][0] == 0 || m[n-1][n-1] == 0)
					return ans;
				
				string holder;
				vector<vector<int>> Visited (n, vector<int>(n, 0));
				int row=0,col=0;
				
				PathFinder(m, row, col, ans, Visited, holder);
				return ans;
			}
		};

	// Dry Run ❌Pending
---------------------------------------------------------------------------------------------------------
	09/03/2024
Lecture-41: Time & Space Complexity of Recursive Algorithms: ❌Pending

	1) Factorial: 		TC- O(N)
	2) BinarySearch: 	TC- O(log N)
	3) mergeSort:	 	TC- O(N log N)
	4) Fibonacci:		TC- O(2ⁿ)
---------------------------------------------------------------------------------------------------------
	12/03/2024
Lecture-42: OOPs Concepts in C++ || Part-1
	-Object Oriented Programming
	eg.
		class Hero{
			// empty class, empty class have size is 1byte.
		};

		class Hero{
			int Health;		// class have one attribute
		};
		-here the size of class is 4 bytes coz the size of int is 4 bytes.

		class Hero{
			string Name;
			int Health;
		}
		-here the size is (int(4 bytes) string(32 bytes)) more than 36 bytes in total (considering padding added by compiler).
		-we should arrange the data member of class either in increasing order or in decreasing order, or largest at first then all smaller in any order.

		Padding & Greedy Alignment:
			Padding and greedy alignment are two important concepts in computer programming that are used to optimize the memory usage and performance of programs. In this article, we will discuss these concepts in the context of C++ programming language using classes.
			Padding is the technique of adding extra bytes to a structure or class to align its data members to specific boundaries. This is done to ensure that the data members are accessed efficiently by the processor, which typically fetches data from memory in chunks of fixed sizes, such as 4 or 8 bytes.
			Consider the following example:
			class Example {
				char c;
				int i;
				short s;
			};
			In this example, the char data member requires only 1 byte of memory, while the int and short data members require 4 and 2 bytes, respectively. To align the int data member to a 4-byte boundary, the compiler will add 3 bytes of padding after the char data member, resulting in a total size of 8 bytes for the class.
			Padding can have a significant impact on the memory usage and performance of a program, especially when dealing with large data structures or arrays. By understanding how padding works, we can optimize our code to minimize memory usage and improve performance.
			Greedy Alignment in C++ using Classes
			Greedy alignment is a technique used to minimize padding by ordering the data members of a class in decreasing order of size. This ensures that the largest data members are placed first in the class, minimizing the amount of padding required to align the subsequent data members.
			Consider the following example:

			class Example {
				char c;
				double d;
				int i;
				short s;
			};
			In this example, the double data member requires 8 bytes of memory, which is larger than any of the other data members. If we reorder the data members as follows:

			class Example {
				double d;
				int i;
				short s;
				char c;
			};
			We can eliminate padding between the double and int data members, resulting in a smaller overall size for the class. In general, greedy alignment can help to minimize memory usage and improve the performance of our code.

			Conclusion
				Padding and greedy alignment are important concepts in computer programming, especially when dealing with large data structures or arrays. By understanding how padding works and applying greedy alignment techniques, we can optimize our code to minimize memory usage and improve performance. In C++, we can define data types with padding using classes, and order the data members of a class in decreasing order of size to minimize padding.

		eg.
			// char         1 byte 
			// short int    2 bytes 
			// int          4 bytes 
			// double       8 bytes 
			#include<iostream>
			using namespace std;

			class Example {
			int i;
			double d;
			char c;
			short s;
			};
			// the size of class should be int + double + char + short = 4+8+1+2 = 15
			// but actual is 24, coz int is 4 bytes then double came, which is largest so whatever smaller data member comes after double,
			// it will be given same size as double, if any member came after double which is more in size than double then that member's size will be consider for 
			// upcoming small data member's size.

			// in above case int < double, but char & short came after double so they given size of double which is 8
			// int + double + double + double  = 4+8+8+8 = ~28

			//here the data member is arranged properly
			class Second {
			char c;
			short s;
			int i;
			double d;
			};

			// so the size is (actual + 1) = 15 + 1 = 16

			int main() {
			
			Example e;
			std::cout << sizeof(e) << std::endl;
			
			Second s;
			std::cout << sizeof(s) << std::endl;
			
			return 0;
			}

	-Access Modifiers:
		-by default in class the access modifier in class is private for all data members.
		1) public
		2) private
		3) protected

	-Getter/ Setter:
		#include <iostream>
		using namespace std;
		class Hero {
			
			private:
				int id;
				string num;
			
			public:
				string name;
			
				// getter/setters
				// getters
				int getID(){
					return id;
				}
				
				string getNum(){
					return num;
				}
				
				// setters
				void setID(int n){
					id = n;
				}
				
				void setNum(string s){
					num = s;
				}
			
				// to display
				void printer(){
					std::cout << id << " Hello, My name is "<< name << ", My num : " << num << std::endl;
				}
		};

		int main() {
			Hero h1,h2;
			
			h1.name = "Vivek", h2.name="Nikate";
			
			h1.setID(1);
			h2.setID(2);
			
			h1.setNum("12345");
			h2.setNum("67890");
			
			h1.printer();
			h2.printer();
			return 0;
		}
	
	-Static & Dynamic Memory Allocation:
		#include <iostream>
		class Example {
			public:
				double d = 89.234532d;
				int i = 90;
				float f = 77.3f;
				char c = 'z';
				short s = 2;
		};

		int main() {
			
			// static memory allocation
			Example e;
			std::cout << sizeof(e) << std::endl;
			std::cout << e.i << std::endl;
			std::cout << e.f << std::endl;
			std::cout << e.d << std::endl;
			std::cout << e.c << std::endl;
			std::cout << e.s << std::endl;
			
			// dynamic memory allocation
			std::cout << "DMA: " << std::endl;
			Example *E = new Example;
			std::cout << sizeof(*E) << std::endl;
			std::cout << (*E).i << std::endl;
			std::cout << (*E).f << std::endl;
			std::cout << (*E).d << std::endl;
			std::cout << (*E).c << std::endl;
			std::cout << (*E).s << std::endl;
		}

	-Star Operator:
		-we can use star operator(*) to get & set the value.
		eg.
			#include <iostream>
			using namespace std;
			class person{
				public:
					int id;
					string name;
				
				void print(){
					std::cout << endl << id << "\t" << name << std::endl;
				}
			};

			int main() {
				
				person *p = new person;
				
				//setting the values
				(*p).id = 10;
				(*p).name = "Vivek";
				
				// getting the values
				std::cout << (*p).id << std::endl;
				std::cout << (*p).name << std::endl;
				(*p).print();
			}

	-Arrow Operator:
		-we can use this operator(->) to get & set the value.
		eg.
			#include <iostream>
			using namespace std;
			class person{
				public:
					int id;
					string name;
				
				void print(){
					std::cout << endl << id << "\t" << name << std::endl;
				}
			};

			int main() {
				person *a = new person;
				
				//setting the values
				a->id = 1;
				a->name = "Mahesh";
				
				// getting the values
				std::cout << a->id << std::endl;
				std::cout << a->name << std::endl;
				a->print();
			}

	-Constructor:
		-invokes at the time of  object creation.
		-use it for initializing member variables
		-Constructor don't have return type.
		-if you don't create a constructor then behind the scene default constructor automatically generated.
		-else if you create a constructor the default one will be deleted automatically.
		1) Default constructor:
			#include <iostream>
			class Hero{
				public:
				Hero(){
					std::cout << "Constructor called " << std::endl;
				}  
			};

			int main() {
				// static
				Hero Vivek;

				// dynamic
				Hero * Mahesh = new Hero;
				Hero * Nikate = new Hero();
				
				return 0;
			}

			-this keyword, 'this' stores the address of object, it means that 'this' is a pointer.
			#include <iostream>
			class Hero{
				public:
				Hero(){
					std::cout << "Constructor called " << std::endl;
					std::cout << "This: " << this << std::endl;
				}  
			};

			int main() {
				// static
				Hero Vivek;

				// dynamic
				Hero * Mahesh = new Hero;
				Hero * Nikate = new Hero();
				
				return 0;
			}

		2) Parameterized constructor:
			#include <iostream>
			using namespace std;

			class Hero{
				public:
				int id;
				string name;
				
				// default Constructor
				Hero(){
					std::cout << "default" << std::endl;
				}
				
				// 1 parameter
				Hero(int id){
					std::cout << "1 parameter" << std::endl;
					this-> id = id;
				}
				
				// 2 parameter
				Hero(int id, string name){
					std::cout << "2 parameter " << std::endl;
					std::cout << "This: " << this << std::endl;
					
					// you can use . operator or
					(*this).id = id;
				
					// or you can use (arrow) -> operator also.
					this->name = name;
				}  
				
			};

			int main() {
				// static
				Hero Vivek1;
				
				Hero Vivek2(44);
				std::cout << Vivek2.id << std::endl;

				Hero Vivek(3, "vivek");
				std::cout << "Addres of Vivek : "<< &Vivek << std::endl;
				std::cout << Vivek.id << "\t" << Vivek.name << std::endl;

				// dynamic
				Hero * Mahesh = new Hero(2, "mahesh");
				
				// this keyword address & Mahesh's Heap Addres are same
				std::cout << "Addres of Mahesh in Heap : "<< &(*Mahesh) << std::endl;
				std::cout << "Addres of Mahesh in static : "<< &Mahesh << std::endl;
				std::cout << Mahesh->id << "\t" << Mahesh->name << std::endl;
				std::cout << (*Mahesh).id << "\t" << (*Mahesh).name << std::endl;
				
				Hero * Nikate = new Hero(1, "nikate");
				std::cout << "Addres of Nikate : "<< &(*Nikate) << std::endl;
				std::cout << Nikate->id << "\t" << Nikate->name << std::endl;
				
				return 0;
			}

		3) Copy Constructor:
			-it is created automatically, this is default copy constructor.
			-if you create a copy constructor manually then the default copy constructor will be deleted automatically.
				#include <iostream>
				using namespace std;

				class Hero {
					int Health;
					string name;
					public:
					// Default Constructor
					Hero(){
						std::cout << "Default Constructor!!" << std::endl;
					}
					
					// parameterized Constructor
					Hero(int Health, string name){
						std::cout << "parameterized constructor: " << std::endl;
						(*this).Health = Health;
						this -> name = name;
					}

					void display(){
						std::cout << "My name is "<< name <<" My Health is " << Health << "%." << std::endl;
					}				
				};

				int main() {
					// Default
					Hero Vivek;

					// parameterized
					Hero Person(89, "System");
					Person.display();
					
					// copy
					Hero clone(Person);
					clone.display();
					
					return 0;
				}
			
			-we can create a copy constructor manually also.
			-in copy constructor we should pass the object by pass by reference method
			-if we pass object by pass by value method, it creates a new copy of object and then call the same function again.
			-& we will get stuck in infinite loop of calling the same function itself, that why we should pass by reference.

			#include <iostream>
			using namespace std;

			class Hero {			
				int Health;
				string name;
				
				public:
				// parameterized Constructor
				Hero(int Health, string name){
					std::cout << "parameterized constructor: " << std::endl;
					(*this).Health = Health;
					this -> name = name;
				}
				
				// copy constructor
				Hero (Hero& temp){
					std::cout << "Copy constructor called..." << std::endl;
					Health = temp.Health;
					name = "NA (HardCoded)";
				}

				void display(){
					std::cout << "My name is "<< name <<" My Health is " << Health << "%." << std::endl;
				}	
			};

			int main() {
			
				// parameterized
				Hero Person(89, "System");
				Person.display();
				
				// copy constructor (manually created which just copies the Health)
				Hero clone(Person);
				clone.display();
				
				return 0;
			}

	-Shallow Copy & Deep Copy:
		-Shallow copy will copy the object reference, which will affect both objects if we modify one of them.
		-Deep copy will create a new memory location for object
		-for Shallow copy & Deep copy demonstration we need to use Dynamic memory, else on static memory it won't work.
		-Default copy constructor makes Shallow copy
		-in Shallow copy the original object and the copied objects point to same memory
		-if we changes the value of new object, then it changes the value of original object also.
		-To avoid this issue we can use concept of Deep copy.
		eg.
			Shallow copy on static memory doesn't work
				#include <iostream>
				class Example {
					public:
					int staticValue;
				};

				int main() {
				
					Example ex1;
					ex1.staticValue = 1;
					
					std::cout << ex1.staticValue << std::endl;		//1
					
					Example ex2 = ex1;
					ex2.staticValue = 40;				// this modification doesn't affect ex1.staticValue.
					std::cout << ex2.staticValue << std::endl;		// 40
					std::cout << ex1.staticValue << std::endl;		// 1

					return 0;
				}

			Shallow copy affect on dyamic memory
				#include <iostream>
				using namespace std;

				class one {
					public:
						string *name;	
					void show(){
						std::cout << *name << std::endl;
					}
				};

				int main() {
					one o1;
					o1.name = new string("Vivek");
					o1.show();									//Vivek
					
					std::cout << std::endl;
					one o2 = o1;
					o2.show();								//Vivek
					o1.show();								//Vivek
					
					*o1.name = "Nikate";
					std::cout << std::endl;
					o1.show();								//Nikate
					o2.show();								//Nikate
					return 0;
				}
			
		Deep Copy eg:
			#include <iostream>
			using namespace std;

			class one {
				public:
					string *name;	
				void show(){
					std::cout << *name << std::endl;
				}
			};

			int main() {
				one o1;
				o1.name = new string("Vivek");      
				o1.show();                          //Vivek
				
				std::cout << std::endl;
				one o2 = o1;
				o2.show();                          //Vivek
				o1.show();                          //Vivek
				
			// 	shallow copy
				std::cout << std::endl;
				*o1.name = "G-one";
				o1.show();                  //affected to o2 also          //G-one
				o2.show();                                  //G-one
				
				o2.name = new string("Nikate");         // new memory given to object2 ie. o2
				std::cout << std::endl;
				o1.show();                          //not affected to o1        //Vivek
				o2.show();                          //Nikate
				return 0;
			}

	-Copy Assignment Operator (=):
		#include <iostream>
		using namespace std;

		class Example{
			public:
				int Level;
				string Name;
				float Health;
			
			void show(){
				std::cout << "My Level : " << Level << ", My name: " << Name << ", Health: " << Health << "%" << std::endl;
			}
		};

		int main() {
			
			// static allocation
			Example ex1;
			ex1.Level = 1, ex1.Name = "RED", ex1.Health = 89.8f;
			ex1.show();
			
			// assignment operator
			Example ex2 = ex1;
			ex2.show();
			
			// dynamic allocation
			Example * D_ex1 = new Example;              // or new Example();
			D_ex1 = &ex1;
			
			std::cout << "D_ex1 : " << "\t";
			(*D_ex1).show();
			
			
			std::cout << "D_ex2 : " << "\t";
			Example *D_ex2 = new Example();
			D_ex2 -> Level = 100;
			D_ex2 -> Name = "POWER";
			D_ex2 -> Health = 95.85f;
			D_ex2->show();
			
			
			std::cout << "D_ex3 : " << "\t";
			// assignment operator
			Example *D_ex3 = D_ex2;
			(*D_ex3).show();
			return 0;
		}

	-Destructor:
		-Destructor destroy the object of Class.
		-Destructor is created automatically when class is created.
		-but we can manually also create Destructor.
		-It is a special member function that gets called when an object goes out of scope. 
		It's used to clean up any resources the object may hold, (free up the memory space taken by that obiect).
		-Destructor don't have return type.
		-Destructor is same name as that of class name
		-Destructor don't need parameter/ arguments
		-Constructor (at the time of object creation) & Destructor(at the time of object destruction) both are called once only.
		
		-for static object(static allocation) Destructor will be called Automatically
		-for dyamic object(dyamic allocation) Destructor should be called Manually.
		eg.

			#include <iostream>
			class Example {
				public:
					// constructor
					Example(){
						std::cout << "Constructor called.." << std::endl;
					}
					
					// destrutor
					~Example(){
						std::cout << "De-structor called.." << std::endl;
					}	
			};

			int main() {
				// static object
				Example ex;
				
				// dynamic object
				Example *D_ex = new Example;
				delete D_ex;                             // if we don't write this delete statement then De-structor will not be called for dynamic object
				
				return 0;
			}

	-HomeWork:
		1) const keyword:
			-object creation ❌Pending
			-const functions
			-initialization list
			-Whenever const keyword is attached with any method(), variable, pointer variable, 
			and with the object of a class it prevents that specific object/method()/variable to modify its data items value.

			-The const variable cannot be left un-initialized at the time of the assignment.
				const int var;		❌

			-It cannot be assigned value anywhere in the program.					
				const int var;		
				var = 5;			❌	

			-Explicit value needed to be provided to the constant variable at the time of declaration of the constant variable.
				const int var;		✔
		eg.
			#include <iostream>
			using namespace std;
			int main() {
				int x = 90;
				const int *p = &x;
				
				std::cout << *p << std::endl;
				std::cout << x << std::endl;
				
				std::cout << "After modification: " << std::endl;
				// *p = 12;            //Error coz *p is pointer of const type, but we can change value of p
				
				x=12;           //in-directly
				std::cout << *p << std::endl;
				std::cout << x << std::endl;
				return 0;
			}

	-Static keyword:
		-A static member belongs to a class rather than an object of that class.
		-To access the static member of class you don't need a object of that class, you can access them by using class name.
		-Initialization of static member variable of class outside of class
			syntax:
				dataType ClassName :: varName = value;
				where,
					dataType is datatype of varName
					:: is a scope resolution operator
		eg.
			#include <iostream>
			class Person{
				public:
					static int a;
			};

			int Person :: a = 10;

			int main() {
				
				// static member accessing without creating object of class
				std::cout << Person::a << std::endl;
				
				// with object of class
				Person per;
				std::cout << per.a << std::endl;                //NOT recommended, coz its belongs to class, not object of class
				
				return 0;
			}

	-Static Functions:
		-For Static function no need to create object, we can call them using class name.
		-static functions don't have 'this' keyword, coz 'this' keyword is a pointer, which is holding the address of current object.
			& static functions doesn't belongs to object of class.

		-Static functions can access the static members only. if tried accessing non-static variable, error will occur.
		#include <iostream>
		using namespace std;

		class Person{
			public:
				static int a;
				int c=90;
				string name = "Vivek";
				
				static int random() {
					// std::cout << name << std::endl;         // Error
					// std::cout << c << std::endl;          // Error
					std::cout << a << std::endl;
					return a;
				}
		};

		int Person :: a = 10;
		int main() {	
			std::cout << "The Value of static int a : " << Person::random() << std::endl;
			return 0;
		}
---------------------------------------------------------------------------------------------------------
	15/03/2024
Lecture-43: 4 Pillars of OOPs Concept -Inheritance, Polymorphism, Encapsulation & Abstraction
	Encapsulation:
		Encapsulation in C++ is defined as the wrapping up of data and information in a single unit.
		In Object Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.

		-Fully Encapsulated class:
			the class where all data-member are private.

		- Encapsulation used for Information Hiding / Data Hiding
		- Encapsulation enhances security.
		- using Encapsulation we can mark our class as read-only.
		- Increases Code Resuability
		- Encapsulated code is better for Unit testing.
		eg.
			#include <iostream>
			using namespace std;

			class Student{
				// by default the member are private only
				int id;
				string name;
				
				public:
					int getID(){
						return id;
					}
				
					string getName(){
						return name;
					}
			};

			int main() {
				Student s;
				
				std::cout << s.getID() << std::endl;
				std::cout << s.getName() << std::endl;
				return 0;
			}

	Inheritance:
		The capability of a class to derive properties and characteristics from another class is called Inheritance. 
		Inheritance is one of the most important features of Object-Oriented Programming. 
		syntax:
			class ClassName : accessModifire parentClassName{

			}
									Human	----> parent class/ super class
									 ↙   ↘
			chlid class/ sub class ---> Male 	Female
		eg.
			#include <iostream>
			using namespace std;
			class Human{
				int weight;
				public:
					string name;
				
					void setWeight(int w){
						weight = w;
					}
					
					int getWeight(){
						return weight;
					}
				};

			class Male: public Human{
				char gender = 'M';
				public:
				char getGender(){
					return gender;
				}
			};

			int main() {
				
				Male m;
				// m.weight = 90;          // Error private variable
				m.setWeight(80);
				std::cout << m.getWeight() << std::endl;
				m.name = "Shree";
				std::cout << "name : "<< m.name << std::endl;
				std::cout << "Gender: " << m.getGender() << std::endl;
				
				return 0;
			}

		attribute is in SuperClass			inheriting into Subclass as			then inSubClass that attribute is
			public		--------->			public								public
			public		--------->			protected								protected
			public		--------->			private								private
			
			protected		--------->			public								protected
			protected		--------->			protected								protected
			protected		--------->			private								private

			private		--------->			public								Not-accessible
			private		--------->			protected								Not-accessible
			private		--------->			private								Not-accessible

		-Types of Inheritance:
			1) Single
			2) Multi-level
			3) Multiple
			4) Hierarchical
			5) Hybrid
			6) A special case of hybrid inheritance: Multipath inheritance
			
		1) Single Inheritance:
			class     +-----+
					|  A  |
					+-----+
					   |
					   |
					   v
					+-----+
					|  B  |
					+-----+

			In single inheritance, a class is allowed to inherit from only one class. i.e. one subclass is inherited by one base class only.
			eg.
				#include <iostream>
				class Animal{
					public:
						int age, weight;
						
						void speak(){
							std::cout << "Speaking....!" << std::endl;
						}
				};
				class Dog: public Animal{
				
				};
				int main() {
					Dog d;
					d.speak();
					std::cout << "Age: "<< d.age << "\t" << "Weight: "<< d.weight << std::endl;
				}

		2) Multi-level:
			+-----+
			|  A  |
			+-----+
			   |
			   |
			   v
			+-----+
			|  B  |
			+--+--+
			   |
			   |
			   v
			+-----+
			|  C  |
			+-----+

			a derived class is created from another derived class.
			eg.
				#include <iostream>
				class Animal{
				public:
					int age, weight;
					
					void speak(){
						std::cout << "Speaking....!" << std::endl;
					}
				};

				class Dog: public Animal{
				
				};

				class GoldenRetriver: public Dog{
				
				};

				int main() {
					GoldenRetriver g;
					g.speak();
					std::cout << "Age: "<< g.age << "\t" << "Weight: "<< g.weight << std::endl;
				}

		3) Multiple:
				+-----+    +-----+
				|  A  |    |  B  |
				+-----+    +-----+
			        |          |
			        |          |
			        +----------+
			        	    |
			        	    v
					 +-----+
					 |  C  |
					 +-----+

			a class can inherit from more than one class. i.e one subclass is inherited from more than one base class.
			eg.
				#include <iostream>
				class Animal{
					public:
						int age, weight;
						
						void bark(){
							std::cout << "Speaking....!" << std::endl;
						}
				};

				class Human{
					public:
					
					void speak(){
						std::cout << "Human speaking..." << std::endl;
					}	
				};

				class Hybrid: public Animal, public Human{
				
				};

				int main() {
					Hybrid g;
					g.speak();
					g.bark();
					std::cout << "Age: "<< g.age << "\t" << "Weight: "<< g.weight << std::endl;
				}
		
		4) Hierarchical:
			       +-----+
				  |  A  |
				  +--+--+
					|
					|
				+----+----+
				|         |
				v         v
			  +-----+   +-----+
			  |  B  |   |  C  |
			  +-----+   +-----+

			more than one subclass is inherited from a single base class. i.e. more than one derived class is created from a single base class.
			eg.
				#include <iostream>
				class A{
					public:
					void fun1(){
						std::cout << "Fun1" << std::endl;
					}
				};

				class B: public A{
					public:
					void fun2(){
						std::cout << "Fun2" << std::endl;
					}
				};

				class C: public A{
					public:
					void fun3(){
						std::cout << "Fun3" << std::endl;
					}
				};


				int main() {
					A a;
					a.fun1();
					
					std::cout << std::endl;
					B b;
					b.fun1();
					b.fun2();
					
					std::cout << std::endl;
					C c;
					c.fun1();
					c.fun3();
				}

		5) Hybrid (virtual):
			-combination of more than one type of inheritance, such as single and multiple or multiple and hierarchical.
			Hybrid Inheritance is implemented by combining more than one type of inheritance. 
			For example: Combining Hierarchical inheritance and Multiple Inheritance. 
			eg.
					+-----+        +-----+
					|  A  |        |  Z  |
					+-----+        +-----+
					   |              |\
					   |              | \
					   +------+-------+  \
							|		  \
							v		   \
						   +-----+	    \	+-----+
						   |  C  |		-->	|  R  |
						   +--+--+			+-----+
				
			
				#include <iostream>
				using namespace std;

				class A{
					public:
					A(){
						std::cout << "This is class A" << std::endl;
					}
				};


				class B: A{
					public:
					B(){
						std::cout << "This is class B" << std::endl;
					}
				};

				class C: A{
					public:
					C(){
						std::cout << "This is class C" << std::endl;
					}
				};

				class Z{
					public:
					Z(){
						std::cout << "This is class Z" << std::endl;
					}
				};

				class Hybrid:public A, public Z{
					public:
					Hybrid(){
						std::cout << "This is Hybrid class" << std::endl;
					}
				};

				int main() {
					Hybrid H;
					std::cout << std::endl;
					
					B b;
					std::cout << std::endl;
					
					C c;
					return 0;
				}

		6) A special case of hybrid inheritance: Multipath inheritance:
			A derived class with two base classes and these two base classes have one common base class is called multipath inheritance. 
			Ambiguity can arise in this type of inheritance. 
					+-----+
					|  A  |
					+--+--+
					   |
					   |
				  +-----+-----+
				  |           |
				  v           v
			    +--+--+     +--+--+
			    |  B  |     |  C  |
			    +--+--+     +--+--+
				  |           |
				  |           |
				  +-----------+
					   |
					   v
					+-----+
					|  E  |
					+-----+

			In the above example, both ClassB and ClassC inherit ClassA, they both have a single copy of ClassA. However Class-E inherits both ClassB and ClassC, therefore Class-E has two copies of ClassA, one from ClassB and another from ClassC. 
			If we need to access the data member of ClassA through the object of Class-E, we must specify the path from which a will be accessed, whether it is from ClassB or ClassC, bcoz compiler can’t differentiate between two copies of ClassA in Class-E.

			There are 2 Ways to Avoid this Ambiguity: 
			1) Avoiding ambiguity using the scope resolution operator: Using the scope resolution operator we can manually specify the path from which data member a will be accessed, as shown in statements 3 and 4, in the above example.
				obj.ClassB::a = 10;       // Statement 3
				obj.ClassC::a = 100;      // Statement 4
				eg.
					#include <iostream>
					using namespace std;

					class ClassA {
					public:
						int a;
					};

					class ClassB : public ClassA {
					public:
						int b;
					};

					class ClassC : public ClassA {
					public:
						int c;
					};

					class ClassE : public ClassB, public ClassC {
					public:
						int d;
					};

					int main() {
						ClassE obj;

						// obj.a = 10;				 // Statement 1, Error
						// obj.a = 100;				 // Statement 2, Error

						obj.ClassB::a = 10; // Statement 3
						obj.ClassC::a = 100; // Statement 4

						obj.b = 20;
						obj.c = 30;
						obj.d = 40;

						cout << " a from ClassB : " << obj.ClassB::a;
						cout << "\n a from ClassC : " << obj.ClassC::a;

						cout << "\n b : " << obj.b;
						cout << "\n c : " << obj.c;
						cout << "\n d : " << obj.d << '\n';
					}
			
			Note: Still, there are two copies of ClassA in Class-E.
			2) Avoiding ambiguity using the virtual base class:
				#include<iostream>
				using namespace std;

				class A{
					public:
					int a;
				};

				class B: virtual public A{
					public:
					int b;
				};

				class C: virtual public A{
					public:
					int c;
				};

				class D: public B, public C{
					public:
					int d;
				};

				int main(){
					D d;
					
					// no issues
					d.b=20;
					d.c=30;
					d.d=40;
					
					std::cout << d.b << std::endl;
					std::cout << d.c << std::endl;
					std::cout << d.d << std::endl;
					
					// one copy of class A in class D
					d.a=10;        
					std::cout << d.a << std::endl;
					
					d.a=404;        // this will override the previous value d.a =10 with new value 404
					std::cout << d.a << std::endl;
				}
				
				According to the above example, Class-D has only one copy of ClassA.
				
			eg.
				#include <iostream>
				using namespace std;

				class A {
					public:
						int a;
				};


				class B:public A {
					public:
						int b;
				};

				class C:public A{
					public:
						int c;
				};

				class Z:public B, public C {
					public:
					Z() {
						std::cout << "This is class Z" << std::endl;
					}
				};

				int main () {

					// this works fine.
					A obj1;
					obj1.a = 10;
					std::cout << obj1.a << std::endl;     // 10
					std::cout << std::endl;
					
					// this works fine.
					B obj2;
					obj2.a = 110;
					obj2.b = 120;
					std::cout << obj2.a << std::endl;         // 110
					std::cout << obj2.b << std::endl;         // 120
					std::cout << std::endl;
					
					// this works fine.
					C obj3;
					obj3.a = 210;
					obj3.c = 220;
					std::cout << obj3.a << std::endl;             // 210
					std::cout << obj3.c << std::endl;             // 220
					
					std::cout << std::endl;
					Z obj4;                           // this will invokes the constructor of class Z, ie. This is class Z
					obj4.b = 410;
					obj4.c = 420;
					std::cout << obj4.b << std::endl;             // 410
					std::cout << obj4.c << std::endl;             // 420
					std::cout << std::endl;
					
					// this class Z has 2 copies of class A, means 2 variable of name a
					//here ambuguity comes, obj4.a is not able to understand from which class variable 'a' he should give that value
					
					// obj4.a = 400;                --> ambuguity
					// std::cout << obj4.a << std::endl;
					
					// Resolution - 
					// [1] using scope resolution operator (::)
					
					// this is saying access the variable 'a' from using class B. (this is like path we are providing)
					obj4.B::a = 470;
					obj4.C::a = 480;
					std::cout <<"class B through Z: "<< obj4.B::a <<std::endl;           // 470
					std::cout <<"class C through Z: "<< obj4.C::a <<std::endl;           // 480
					return 0;
				}

		Practice: Multipath inheritance(c++ inheritance ambiguity)
			// using scope resolution operator:
				#include <iostream>
				using namespace std;

				class A{
					public:
					void fun(){
						std::cout << "Inside A" << std::endl;
					}
				};

				class B{
					public:
					void fun(){
						std::cout << "Inside B" << std::endl;
					}
				};

				// here class C holds 2 copies of class A.
				class C: public A, public B{
					public:
				};

				int main() {	
					C c;
					c.A::fun();			//calling from class A
					c.B::fun();			//calling from class A
					
					return 0;
				}

	Polymorphism:
		poly-many
		morphs - forms
		-polymorphism as the ability of a message to be displayed in more than one form.
		-Polymorphism means single entity existing in multiple forms.
		
		A real-life example of polymorphism is a person who at the same time can have different characteristics.
		A man at the same time is a father, a husband, and an employee. 
		So the same person exhibits different behavior in different situations. This is called polymorphism. 

		Types of Polymorphism:
			1) Compile-time Polymorphism
			2) Runtime Polymorphism

		1) Compile-time Polymorphism (static or early binding polymorphism):
			i) Function overloading
			ii) Operator overloading
			
			i) Function overloading:
				Function signature: no.of parameter & type of parameter.

				function overloading means, a function with same name, must have different no.of parameter or
				a function with same no.of parameter but their type of parameters must be different.

				-function with same name can have different return type but their no.of parameter should be different,
				or if they have same no.of parameter then their type of parameter should be different.

				When there are multiple functions with the same name but different parameters,
				then the functions are said to be overloaded, hence this is known as Function Overloading.
				Functions can be overloaded by changing the number of arguments or/and changing the type of arguments. 
				In simple terms, it is a feature of object-oriented programming providing many functions
				that have the same name but distinct parameters when numerous tasks are listed under one function name. 

				-function with same name:
					-with different return type, same no.of parameter, with different dataType of parameter
						#include<iostream>
						using namespace std;

						int add(int a, int b) {
							return (a+b);
						} 

						double add(double a, double b) {
							return a+b;
						} 

						int main() {
							cout<<add(10,2);		// 12
							std::cout << std::endl;
							cout<<add(5.5,6.9);		// 12
							return 0;
						}

					-with same return type, same no.of parameter, with different dataType of parameter
						#include<iostream>
						using namespace std;

						void add(int a, int b) {
							cout<<(a+b);
						} 

						void add(double a, double b) {
							cout<<a+b;
						} 

						int main() {
							add(10,2);
							std::cout << std::endl;
							add(5.4, 6.1);

							return 0;
						}

					
					- with same return type but same dataType of parameter, but different in no.of argument
						#include<iostream>
						using namespace std;

						void add(int a, int b) {
							cout<<(a+b);
						} 

						void add(int a, int b, int c) {
							cout<<a+b+c;
						} 

						int main() {
							add(10,2);
							std::cout << std::endl;
							add(5, 6, 9);

							return 0;
						}

				- This will give error coz function signature is same, 
				 function signature means no.of parameter or type of parameter they should be different to do function overloading
				 -here both function have 0 parameter, so ambiguous
					
					#include <iostream> 
					int fun() { return 10; } 
					char fun() { return 'a'; }

					int main() { 
						char x = fun();
						return 0; 
					}

				//this works
					#include <iostream> 
					int fun(int a) { return 10; } 
					char fun(char a) { return 'a'; } 
					int main() { 
						char x = fun(10);
						return 0; 
					}

			ii) Operator Overloading:
				is a compile-time polymorphism. It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.				
				You can overload any of the following operators:
					+		-		*		⁄		%		‸		&		|		~
					!		=		<		>		+=		-=		*=		⁄=		%=
					‸=		&=		|=		<<		>>		<<=		>>=		==		!=
					<=		>=		&&		||		++		--		,		->*		->
					( )		[ ]		new		delete	new[]	delete[]

				You cannot overload the following operators:
					.		.*		::		?:

				You cannot overload the preprocessor symbols # and ##.
				-All operators except the = operator are inherited.
					returntype operator-- () {
						// task
					}
					-- in this place you can put any operator which we can overload.

					void operator^ (){
						//....
					}

				eg.

					#include <iostream>
					using namespace std;

					class A{
						public:
						int a=10;
						
						// operator overloading
						// overloading % operator
						void operator% (A obj1) {
							std::cout << "This is MOD operator..! working as decrementor" << std::endl;
							std::cout << --obj1.a << std::endl;
						}
						
						void operator* (A obj1) {
							cout<<"This is multiplication operator, working as incrementor" << endl;
							std::cout << ++obj1.a << std::endl;
						}
						
						void operator& (A o){
							std::cout << "Hi Vivek!" << std::endl;
						}
					};

					int main() {
					
						A a;
						a.a = 90;
						
						A b;
						b.a = 100;
						
						b%a;
						a*b;
						
						// this is & operator whenever program see this operator with class obj then it will print the statement
						a&b;
						
						return 0;
					}

				//or
					#include <iostream>
					using namespace std;

					class A {
						public:
						int a;

						// Overloaded [] brackets
						void operator[](int index) {
							std::cout << "I'm Brackets... " << (this->a + index) << std::endl;
						}
						
						void operator() (){
							std::cout << "parenthesis... " << ++(this->a) << std::endl;
						}
					};

					int main() {

						A a, b;
						a.a = 90;
						b.a = 100;

						b[5]; // Example usage of operator[]
						a[10]; // Example usage of operator[]
						
						b();
						a();
						
						return 0;
					}
				
				// Practice:
					#include <iostream>
					using namespace std;
					class A{
						public:
						void operator() (){
							cout<<"Parenthesis called"<< endl;        
						}
						
						void operator! (){
							std::cout << "Not operator called" << std::endl;
						}
					};

					int main() {
						A a;
						a();
						!a;
						return 0;
					}

		2) Run-Time Polymorphism (Dynamic or late binding polymorphism):
			-Method Overriding
			This type of polymorphism is achieved by Function Overriding. Late binding and dynamic polymorphism are other names for runtime polymorphism. The function call is resolved at runtime in runtime polymorphism.
			-Rules:
				-method in parent class & method in child class must have the same name
				-method in parent class & method in child class must have the same parameter
				-this is possible through inheritance only.

			eg.
				#include <bits/stdc++.h>
				using namespace std;

				// base class declaration.
				class Animal {
					public:
						string color = "Black";
				};

				// inheriting Animal class.
				class Dog : public Animal {
					public:
						string color = "Grey";
				};

				// Driver code
				int main(void) {
					// valid
					Dog d;	
					cout << d.color<<endl;
					
					Animal a;
					std::cout << a.color << std::endl;
					
					Animal ab = Dog();
					std::cout << ab.color << std::endl;
					
					// invalid
					// child class calling parent class constructor which is not valid
					// Dog ddd = Animal();		
				}
			
			eg.
				#include <bits/stdc++.h>
				using namespace std;

				class Animal {
					public:
					void speak(){
						std::cout << "Speaking...!" << std::endl;
					}
				
				};

				class Dog : public Animal {
					public:
					void speak(){
						std::cout << "Barking..." << std::endl;
					}
				};

				int main() {
				
					Dog d;
					d.speak();          // Barking
					
					Animal a;
					a.speak();          // Speaking
					
					Animal ad = Dog();
					ad.speak();          // Speaking
				}

	Abstraction:
		-Implementation Hiding
		-Abstraction means displaying only essential information and hiding the details. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation. 
		-Abstraction refers to revealing only the most essential information while hiding the details. Data abstraction refers to exposing only the most essential aspects of the data to the outside world while hiding the implementation details.
		eg 1.
			Consider a real-life example of a man driving a car. The man only knows that pressing the accelerator will increase the speed of the car or applying brakes will stop the car but he does not know how on pressing the accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of the accelerator, brakes, etc in the car. This is what abstraction is.
		   2.
		     After writing the mail when you click on send button, email will sent, but you don't know the behind functionality of that send button that's what the abstraction is.
		Advantages:
			-Helps the user to avoid writing the low-level code
			-Avoids code duplication and increases reusability.
			-Can change the internal implementation of the class independently without affecting the user.
			-Helps to increase the security of an application or program as only important details are provided to the user.
			-It reduces the complexity as well as the redundancy of the code, therefore increasing the readability.

		#include <iostream>
		class car{
			void Piston(){
				std::cout << "Powered by 8 Piston" << std::endl;
			}
			
			void Brakes(){
				std::cout << "Special Disk+Air brakes" << std::endl;
			}
			
			public:
			void color(){
				std::cout << "Black" << std::endl;
			}
			
			void Model(){
				std::cout << "Xi7" << std::endl;
			}
			
			void Brand(){
				std::cout << "BMW" << std::endl;
			}
			
			void price(){
				std::cout << "8M" << std::endl;
			}
		};

		int main() {
			car c;
			c.color();
			c.Model();
			c.Brand();
			c.price();
			
			// not accessible
			// c.Piston();
			// c.Brakes();	
		}
	
	❌Pending:
		-Interface, Friend keyword
		-dedicated OOPs course by Love Babbar
---------------------------------------------------------------------------------------------------------
	02/04/2024
Lecture-44: Linked List & its types- Singly, Doubly, Circular
	Linked List (LL):
		-A linked list is a fundamental data structure in computer science. 
		-It consists of nodes. where each node contains data and a reference (link) to the next node in the sequence. 
		-This allows for dynamic memory allocation and efficient insertion and deletion operations compared to arrays.
		-it is dynamic in nature, so we can increase/decrease its size at runtime so no memory wastage.

		-We already know that the data in Array is stored in contiguous address spots inside the memory.
		 But what if we don't have enough contiguous space to store a large number of elements together?
		 To overcome this problem, we define another data structure which is called Linked List.
		-a linked list is also called dynamic data structure.
		- Its Linear Data Structure.

		- Instead of Linked List we can use vector but if vector has some specified size [vector<int> v(5,0)], then
		  when we exhaust the size of vector then new vector is created with size doubled, and copies all the element into new vector
		  this operation takes times, to reduce this time we can use linked list,

		- in case of array/ vector when we want to insert any element into middle then rest element we have to shift by 1,
		  or if we delete any middle element in array, then we have shift all element forward by 1. this is time consuming operation
		- but in case of Linked List we don't need shifting etc. insertion/ deletion is efficient in linked list.

  		  Node Structure: A node in a linked list typically consists of two components:
  		  Data: It holds the actual value or data associated with the node.
  		  Next Pointer: It stores the memory address (reference) of the next node in the sequence.
  		  Head and Tail: The linked list is accessed through the head node, which points to the first node in the list. The last node in the list points to NULL or nullptr, indicating the end of the list. This node is known as the tail node.

		- Linked list is not contiguous.
		-Difference:
				Linked List:											Array:
			Data Structure: Non-contiguous							Data Structure: Contiguous
			Memory Allocation: Dynamic 								Memory Allocation: Static 
			Insertion/Deletion: Efficient								Insertion/Deletion: Inefficient
			Access: Sequential										Access: Random
			Access Time Complexity: O(n)								Access Time Complexity: O(1)
			Insertion Time Complexity: at start O(1) , not at start O(n)	Insertion Time Complexity: O(n)			
			Deletion Time Complexity: at start O(1) , not at start O(n)		Deletion Time Complexity: O(n)
		
		#Real Life applications of Linked List:
			-Navigation in Browsers:
				The forward and backward navigation in any browser can be implemented by a Doubly Linked List. Here the webpages are taken as a data value, the forward navigation takes us to the next node, the backward navigation takes us to the previous node. Eg - Chrome, Safari, Brave etc.

			-Music and Video Players:
				Most of the video or music playing apps use linked lists to create a playlist, play songs, add to favourite etc. Each song is represented as a node. Users can easily insert, delete any song from the favourites list. Eg - Spotify, Youtube Music, Saavn etc.

			-Undo/Redo Functionality:
				Linked lists are used in applications that require undo/redo functionality, such as text editors and graphic design software. Each node in the list stores the state of the document at a specific point in time. Eg - Google Docs, MS Paint, WhiteBoard etc.

		#Types:
			1) Singly LL
			2) Doubly LL
			3) Circular LL
			4) Circular Doubly LL

		1) Singly LL:
			singly LL consist of data & one pointer, pointing to next element.
			Head --> [ Data: 10 | Next: ] --> [ Data: 20 | Next: ] --> [ Data: 30 | Next: ] --> NULL
			eg.
				#include <iostream>
				class LL_Node{
					public:
						int data;
						LL_Node *next;
						
						LL_Node(){}
						
						LL_Node(int data){
							this->data = data;
							next = NULL;
						}	
				};
				int main() {
				
					// dynamic allocation
					LL_Node * node1 = new LL_Node();
					std::cout << node1 -> data << std::endl;
					std::cout << node1 -> next << std::endl;
						
					LL_Node *node2 = new LL_Node(20);
					std::cout << node2 -> data << std::endl;
					std::cout << node2 -> next << std::endl;
					
						
					return 0;
				}

		// Inserting data at start & at end:
			-Using Static Memory Allocation:
				Note: here Memory is Limited.
				#include <iostream>
				using namespace std;

				class Node {
					public:
						int data;
						Node* next;
					
					Node(int data){
						this->data = data;
						this->next = NULL;
					}
				};

				// inserting at start of Node
				void insertAtStart(Node* &Head, int val) {         // passing references, to avoid making more copies of same LL
					Node * temp = new Node(val);
					temp -> next = Head;
					Head = temp;
				}

				// printing all Node elements
				void printLL(Node* &Head){
					Node* T = Head;
					while(T != NULL){					// while(T){
						std::cout << T->data << "\t";
						T = T->next;
					}
				}

				// inserting at end of Node
				void insertAtEnd(Node * &Tail, int val){
					Node * currentNode = new Node(val);
					Tail->next = currentNode;
					Tail = currentNode;
				}

				int main() {
					// Static memory allocation
					Node n(10);
					
					Node *Starter=0, *Ender=0;
					Starter = Ender = &n;				// this line differ in Static & in Dynamic Memory allocation.
		
					insertAtStart(Starter, 12);
					insertAtStart(Starter, 13);
					insertAtStart(Starter, 14);
					insertAtStart(Starter, 15);
					printLL(Starter);                 // 15      14      13      12      10
					
					std::cout << std::endl;
					
					// Ender is pointing to Node n which has data 10 then all below values will be inserted after 10
					insertAtEnd(Ender, 90);
					insertAtEnd(Ender, 99);
					insertAtEnd(Ender, 909);
					insertAtEnd(Ender, 901);
					insertAtEnd(Ender, 904);
					
					printLL(Starter);       //15      14      13      12      10      90      99      909     901     904
					return 0;
				}

			-Using Dynamic Memory Allocation
				#include <iostream>
				using namespace std;
				class Node {
					public:
						int data;
						Node* next;
					
					Node(int data){
						this->data = data;
						this->next = nullptr;
					}
				};

				// inserting at start of Node
				void insertAtStart(Node* &Head, int val) {         // passing references, to avoid making more copies of same LL
					Node * temp = new Node(val);
					temp -> next = Head;
					Head = temp;
				}

				// printing all Node elements
				void printLL(Node* &Head){
					Node* T = Head;
					while(T != NULL){					// while(T){
						std::cout << T->data << "\t";
						T = T->next;
					}
				}

				// inserting at end of Node
				void insertAtEnd(Node * &Tail, int val){
					Node * currentNode = new Node(val);
					Tail->next = currentNode;
					Tail = currentNode;
				}

				int main() {
					// dynamic memory allocation
					Node * n = new Node(10);

					// this 2 pointer for traversing the Linked List
					Node *Starter=0, *Ender=0;
					Starter = Ender = n;
					
					insertAtStart(Starter, 12);
					insertAtStart(Starter, 13);
					insertAtStart(Starter, 14);
					insertAtStart(Starter, 15);
					printLL(Starter);                 // 15      14      13      12      10
					
					std::cout << std::endl;
					
					// Ender is pointing to Node n which has data 10 then all below values will be inserted after 10
					insertAtEnd(Ender, 90);
					insertAtEnd(Ender, 99);
					insertAtEnd(Ender, 909);
					insertAtEnd(Ender, 901);
					insertAtEnd(Ender, 904);
					
					printLL(Starter);       //15      14      13      12      10      90      99      909     901     904
					return 0;
				}

		// Practice:
			-With class:
				#include <iostream>
				using namespace std;

				class Node{
					public:
						int data;
						Node *next;
						
					Node(int data){
						this->data = data;
						this->next = NULL;
					}
				};

				void insertAtHead(Node* &H, int val){
					Node *newNode = new Node(val);
					newNode->next = H;
					H = newNode;
				}

				void insertAtTail(Node* &T, int val){
					Node *newNode = new Node(val);
					T->next = newNode;
					T = newNode;
				}

				void printLL(Node * &L){
					Node *H = L;
					while(H){
						std::cout << H->data << "\t";
						H = H->next;
					}
					std::cout << std::endl;
				}
				int main() {
					
					Node * n = new Node(10);
					printLL(n);
					
					Node *Header, *Tailer;
					Header =Tailer =n;
					
					insertAtHead(Header, 9);
					insertAtHead(Header, 8);
					insertAtHead(Header, 7);
					insertAtHead(Header, 6);
					insertAtHead(Header, 5);
					
					// passing Header coz we want to print complete LL, if we pass n, then LL will be printed from n to till end.
					printLL(Header);
					
					insertAtTail(Tailer, 11);
					insertAtTail(Tailer, 12);
					insertAtTail(Tailer, 13);
					insertAtTail(Tailer, 14);
					insertAtTail(Tailer, 15);
					insertAtTail(Tailer, 16);
					printLL(n);
					printLL(Header);
					return 0;
				}

			-insertion & deletion:
				#include <iostream>
				class NODE{
					public:
					int data;
					NODE *next = NULL;
					
					// constructor
					NODE(int val){
						data = val;
					}
					
					//de-structor
					~NODE(){
						std::cout << "Releasing Memory for " << data << std::endl;
						delete next;
					}
				};

				void printLL(NODE *H){
					while(H != NULL){
						std::cout << H->data << "\t";
						H = H ->next;
					}
					std::cout << std::endl;
				}

				void insertAtHead(NODE * &H, NODE * &T, int val){
					NODE * n = new NODE(val);
					
					if(H == NULL){
						H = n;
						T = n;
					}else{
						n->next = H;
						H = n;
					}
				}

				void insertAtTail (NODE * &H, NODE * &T, int val){
					NODE * n = new NODE(val);
					
					if(H == NULL){
						H = n;
						T = n;
					}else{
						T->next = n;
						T = n;
					}
				}

				void deleteNode(NODE* &H1, NODE* &T, int val){
					NODE *prev = NULL;
					NODE *H = H1;
					
					if(H == NULL){
						std::cout << "LL is empty" << std::endl;
						return ;
					}
					
					while(H != NULL && H->data != val){
						prev = H;
						H = H -> next;
					}
					
					if(!H){
						std::cout << "value " << val <<" not found" << std::endl;
						return ;
					}
					
					// this indicates the element is first element, update Head.
					if(prev == NULL){
						prev = H;
						H1 = H1 -> next;
						
						prev -> next = NULL;
						delete prev;
						return ;
					}
					
					if(prev == NULL && H->next == NULL) {
						// LL contains only one element & we are deleting that one element so LL becomes empty
						H = NULL;
						delete H1;
						return ;
					}
					
					// this indicates the pointer is pointing to last element
						if(H->next == NULL)
						T = prev;
					
					prev->next = H->next;
					H->next = NULL;
					delete H;
				}


				int main() {
					NODE *H, *T;
					H=T= NULL;
					
					insertAtHead(H, T, 0);
					insertAtHead(H, T, 100);
					insertAtHead(H, T, -1);
					printLL(H);
					
					// insertAtTail(H, T, 1);
					// insertAtTail(H, T, 2);
					// insertAtTail(H, T, 3);
					// insertAtTail(H, T, 4);
					printLL(H);
					
					deleteNode(H, T, -11);         // value not found
					deleteNode(H, T, -1);
					printLL(H);
					
					deleteNode(H, T, 44);         // value not found
					deleteNode(H, T, 4);
					printLL(H);
					
					deleteNode(H, T, 2);
					printLL(H);
					
					if(H){
						std::cout << "Head : " << H->data << std::endl;
						std::cout << "Tail : " << T->data << std::endl;
					}
					std::cout << "Workig fine" << std::endl;
					return 0;
				}

			-With struct: (using static & dyamic memory allocation)
			 in case of static memory allocation the memory is limited, but in dynamic memory allocation we have large memory
				#include <iostream>
				using namespace std;

				struct NODE{
					int data;
					NODE *next;
					
					NODE(int data){
						(*this).data = data;
						next = NULL;
					}
				};


				void PrintLL(NODE * &traverser){
					NODE *temp = traverser;
					while(temp){
						std::cout << (*temp).data << "\t";
						temp = (*temp).next;
					}
					std::cout << std::endl;
				}

				void insertAtHead(NODE* &H, int val){
					NODE *n = new NODE(val);
					(*n).next = H;
					H = n;
				}


				void insertAtTail(NODE* &T, int val){
					NODE *n = new NODE(val);
					(*T).next = n;
					T = n;
				}

				int main() {
					
					// static allocation with structure
					NODE n(10);
					
					NODE *Head = &n;
					NODE *Tail = &n;
					
					PrintLL(Head);
					
					insertAtHead(Head, 80);
					insertAtHead(Head, 1);
					insertAtHead(Head, 2);
					insertAtHead(Head, 3);
					PrintLL(Head);
					
					insertAtTail(Tail, 90);
					insertAtTail(Tail, 100);
					insertAtTail(Tail, 200);
					insertAtTail(Tail, 300);
					insertAtTail(Tail, 400);
					PrintLL(Head);
					
					
					// dynamic memory allocation
					NODE * nn = new NODE(1000);
					
					NODE *H1, *T1;
					
					H1 = T1 = nn;
					
					insertAtHead(H1, 900);
					insertAtHead(H1, 800);
					insertAtHead(H1, 700);
					insertAtHead(H1, 600);
					PrintLL(H1);
					
					insertAtTail(T1, 1100);
					insertAtTail(T1, 1200);
					insertAtTail(T1, 1300);
					insertAtTail(T1, 1400);
					insertAtTail(T1, 1500);
					PrintLL(H1);
					
					return 0;
				}
		
			- in previous/ above example we already created one node before passing calling insertAtHead/insertAtTail function
			- in below example creating LL directly by passing them to function.
				#include <iostream>
				using namespace std;

				class Node{
					public:
						int data;
						Node* next;
					
					Node(int val){
						data = val;
						next = NULL;
					}
				};

				void insertAtHead(Node* &H, Node* &T, int val){
					Node * n = new Node(val);
					
					if(H == NULL){
						H = T = n;
					}else{
						n->next = H;
						H = n;
					}
				}

				void insertAtTail(Node* &T, Node* &H, int val){
					Node * n = new Node(val);
					
					if(T == NULL){
						H = T = n;
					}else{
						T->next = n;
						T = n;
					}
				}

				void printLL(Node * H){
					while(H){
						std::cout << H->data << "\t";
						H = H->next;
					}
					std::cout << std::endl;
				}

				int main() {
					Node *H, *T;
					H = T = NULL;

					insertAtHead(H, T, 12);
					printLL(H);
					
					insertAtTail(T, H, 13);
					printLL(H);
					
					insertAtHead(H, T, 5);
					insertAtHead(H, T, 4);
					insertAtHead(H, T, 3);
					insertAtHead(H, T, 2);
					insertAtHead(H, T, 1);
					printLL(H);
					
					insertAtTail(T, H, 22);
					insertAtTail(T, H, 23);
					insertAtTail(T, H, 24);
					insertAtTail(T, H, 25);
					insertAtTail(T, H, 26);
					insertAtTail(T, H, 27);
					insertAtTail(T, H, 28);
					insertAtTail(T, H, 29);
					insertAtTail(T, H, 30);
					printLL(H);
					
					return 0;
				}

		// Insertion at Middle:
			#include <iostream>
			using namespace std;
			class NODE{
				public:
					int data;
					NODE *next;
				
				NODE(int data){
					(*this).data = data;
					next = NULL;
				}
			};

			// if we don't pass this node as ref, then for creating a copy it consume time, 
			// so to avoid time consumption we used & sign here.
			void printLL(NODE* &Head){
				NODE *T = Head;
				
				while(T)
					std::cout << (*T).data << "\t", T = (*T).next;
					
				/*
					instead of above while loop you can use below simpler to understand loop.
					while(T != NULL){
						std::cout << T -> data << "\t";
						T = T->next;
					}
				*/
					
				std::cout << std::endl;
			}

			void insertAtHead(NODE * &Head, int val){
				NODE *newNode = new NODE(val);
				newNode->next = Head;
				Head = newNode;
			}

			void insertAtTail(NODE* &Tail, int val){
				NODE *newNode = new NODE(val);
				Tail->next = newNode;
				Tail = newNode;
			}

			void insertAt(NODE* &Head, NODE* &Tail, int pos, int val){			
				// handling case of insertion at 1
				if(pos == 1){
					insertAtHead(Head, val);
					return ;
				}
				
				NODE *prev = NULL;
				NODE *cur = Head;
				
				while(--pos){
					// handling case of insertion at end
					// if(!cur)             // if(cur == NULL)
					//     break;
					
					prev = cur;
					cur = cur -> next;
				}
				
				if(!cur){
					insertAtTail(Tail, val);
					return ;
				}
				
				NODE *newNode = new NODE(val);
				newNode->next = cur;
				prev->next = newNode;
			}

			int main() {
				NODE * n = new NODE(1);
				NODE *Head, *Tail;
				Head = Tail = n;
				printLL(Head);
				
				// inserting at Head function
				insertAtHead(Head, 0);
				insertAtHead(Head, -1);
				insertAtHead(Head, -2);
				insertAtHead(Head, -3);
				insertAtHead(Head, -4);
				printLL(Head);
				
				// inserting at Tail function
				insertAtTail(Tail, 2);
				insertAtTail(Tail, 3);
				insertAtTail(Tail, 4);
				insertAtTail(Tail, 5);
				printLL(Head);
				
				// to verify is tail pointing to last value here i.e. 5
				std::cout << Tail->data << std::endl;
				
				// position must be in between start to end of linked list;
				// inserting in middle
				int position = 4;
				insertAt(Head, Tail, position, 44);
				insertAt(Head, Tail, position, 45);
				printLL(Head);
				
				// inserting at start
				position = 1;
				insertAt(Head, Tail, position, 99);
				insertAt(Head, Tail, position, 100);
				printLL(Head);
				
				position=15;
				insertAt(Head, Tail, position, 800);
				insertAt(Head, Tail, position, 844);
				insertAt(Head, Tail, position, 888);
				// insertAtTail(Tail, 89);
				printLL(Head);
				
				cout<< Head->data <<endl;
				cout<< Tail->data <<endl;
				
				return 0;
			}

		// Deletion in Singly LL by Position & by Value:
			#include <iostream>
			using namespace std;

			class NODE{
				public:
					int data;
					NODE *next;
				
				NODE(int data){
					(*this).data = data;
					next = NULL;
				}
				
				// custome destructor, there is default destructor is also present
				~NODE(){
					int value = (*this).data;
					if(this->next != NULL){
						delete next;
						next = NULL;
					}
					std::cout << "Memory freed up for node: " << value << std::endl;
				}
			};

			// if we don't pass this node as ref, then for creating a copy it consume time, 
			// so to avoid time consumption we used & sign here.
			void printLL(NODE* &Head){
				NODE *T = Head;
				
				while(T)
					std::cout << (*T).data << "\t", T = (*T).next;
					
				/*
					instead of above while loop you can use below simpler to understand loop.
					while(T != NULL){
						std::cout << T -> data << "\t";
						T = T->next;
					}
				*/
					
				std::cout << std::endl;
			}

			void insertAtHead(NODE * &Head, int val){
				NODE *newNode = new NODE(val);
				newNode->next = Head;
				Head = newNode;
			}

			void insertAtTail(NODE* &Tail, int val){
				NODE *newNode = new NODE(val);
				Tail->next = newNode;
				Tail = newNode;
			}

			void deleteAtpos(NODE * &Head, NODE * &Tail, int pos){
				NODE* cur = Head;
				NODE* prev = nullptr;
				
				if(pos == 1){
					Head = cur->next;
					cur->next = nullptr;
					delete cur;
					return ;
				}
				
				while(--pos && cur->next != nullptr){
					prev = cur;
					cur = cur->next;
				}
				
				if(pos != 0){
					std::cout << "position limit Exceeded" << std::endl;
					return ;
				}
				
				if(cur->next == nullptr)
					Tail = prev;
					
				prev-> next = cur->next;
				cur->next = nullptr;
				delete cur;
			}

			// HomeWork
			void deleteByValue(NODE * &Head, NODE * &Tail, int val){
				NODE *cur = Head;
				NODE *pre = nullptr;
				
				// considering the starting Element
				if(cur->data == val && pre == nullptr){     // update Head
					Head = cur->next;
					cur->next = nullptr;
					
					delete cur;
					return ;
				}
				
				while(cur->next != nullptr and cur->data != val){
					pre = cur;
					cur = cur->next;
				}
				
				if(cur->data != val){
					std::cout << "Element "<< val <<" not found." << std::endl;
					return ;
				}
				
				// handling the last element case
				if(cur->next == nullptr)                // just to update the Tail.
					Tail = pre;
				
				pre->next = cur->next;
				cur->next = nullptr;
				delete cur;
			}

			int main() {
				
				NODE * n = new NODE(1);
				NODE *Head, *Tail;
				Head = Tail = n;
				printLL(Head);
				
				// inserting at Head function
				insertAtHead(Head, 0);
				insertAtHead(Head, -1);
				insertAtHead(Head, -2); 
				insertAtHead(Head, -3);
				insertAtHead(Head, -4);
				insertAtHead(Head, -5);
				insertAtHead(Head, -6);
				insertAtHead(Head, -7);
				insertAtHead(Head, -8);
				printLL(Head);
				
				// inserting at Tail function
				insertAtTail(Tail, 2);
				insertAtTail(Tail, 3);
				insertAtTail(Tail, 4);
				insertAtTail(Tail, 5);
				insertAtTail(Tail, 6);
				insertAtTail(Tail, 7);
				printLL(Head);
				
				// by position
				deleteAtpos(Head, Tail, 3);
				deleteAtpos(Head, Tail,8);
				
				printLL(Head);
				deleteAtpos(Head, Tail, 1);
				printLL(Head);
				deleteAtpos(Head, Tail, 14);
				deleteAtpos(Head, Tail, 13);
				printLL(Head);
				
				// by value
				deleteByValue(Head, Tail, 1);
				deleteByValue(Head, Tail, 6);
				deleteByValue(Head, Tail, 7);
				deleteByValue(Head, Tail, 70);
				printLL(Head);
				
				deleteByValue(Head, Tail, -8);
				deleteByValue(Head, Tail, -7);
				printLL(Head);
				
				cout<< "Head "<< Head->data <<endl;
				cout<< "Tail "<< Tail->data <<endl;
				return 0;
			}	

		2) Doubly LL (DLL):
			Doubly LL consist of data & 2 pointers (one for previous node and one for next).
			Structure:
				class NODE{
					public:
						int data;
						NODE* next;
						NODE* prev;
					
					NODE(int val){
						data =val;
						next = NULL;
						prev = NULL;
					}
				};

			// Insertion in DLL
				#include <iostream>
				using namespace std;

				class NODE{
					public:
						int data;
						NODE* next;
						NODE* prev;
					
					NODE(int val){
						data =val;
						next = NULL;
						prev = NULL;
					}
				};

				int length_LL(NODE *H){
					int len=0;
					
					while(H){
						len++;
						H = H->next;
					}
					return len;
				}

				void print_D_LL(NODE *H){
				
					while(H){
						cout<< H->data <<"\t";
						H = H->next;
					}
					std::cout << std::endl;
				}

				void insertAtHead_D_LL(NODE * &H, int val){
					NODE * n = new NODE(val);
					n->next = H;
					H->prev = n;
					H = n;
				}

				void insertAtTail_D_LL(NODE * &T, int val){
					NODE * n = new NODE(val);
					
					n->prev = T;
					T->next = n;
					T = n;
				}

				// we can write this below function without using extra NODE name back
				void insertAt_pos(NODE * &H, NODE * &T, int position, int val){
					
					// handling start element case
					if(position == 1){
						insertAtHead_D_LL(H, val);
						return ;
					}
					
					NODE * cur = H;
					NODE * back = NULL;
					
					while(--position && cur){         // or while(--position && cur != NULL)
						back = cur;
						cur = cur -> next;
					}
					
					// this means trying to insert element at the end of list
					// handling end element case
					if(!cur){                // or if(cur == NULL)
						insertAtTail_D_LL(T, val);
						return ;
					}
					
					NODE * n = new NODE(val);
					
					n->next = cur;
					n->prev = back;
					
					back->next = n;
					cur->prev = n;
				}

				void insertAt_pos_no_extra_back(NODE * &H, NODE * &T, int position, int val){
				
					// handling start element case
					if(position == 1){
						insertAtHead_D_LL(H, val);
						return ;
					}
					
					NODE * cur = H;
					
					while(--position && cur)       // or while(--position && cur != NULL)
						cur = cur -> next;
					
					// this means trying to insert element at the end of list
					// handling end element case
					if(!cur){                // or if(cur == NULL)
						insertAtTail_D_LL(T, val);
						return ;
					}
					
					NODE * n = new NODE(val);
					
					n->next = cur;
					n->prev = cur->prev;
					
					cur-> prev -> next = n;
					cur-> prev = n;
				}

				int main() {
					
					NODE * n = new NODE(90);
					
					NODE *H = n;
					NODE *T = n;
					
					print_D_LL(H);
					std::cout << "Length: " << length_LL(H) << std::endl;
					std::cout << "/*********************************************************/" << std::endl;
					
					insertAtHead_D_LL(H, 11);
					insertAtHead_D_LL(H, 10);
					insertAtHead_D_LL(H, 9);
					insertAtHead_D_LL(H, 8);
					print_D_LL(H);
					
					insertAtTail_D_LL(T, 101);
					insertAtTail_D_LL(T, 102);
					insertAtTail_D_LL(T, 103);
					insertAtTail_D_LL(T, 104);
					print_D_LL(H);
					std::cout << "Length: " << length_LL(H) << std::endl;
					std::cout << "/*********************************************************/" << std::endl;

					
					insertAt_pos(H, T, 2, 7);
					print_D_LL(H);
					
					insertAt_pos(H, T, 6, 45);
					print_D_LL(H);
					
					// edge cases
					insertAt_pos(H, T, 1, -8);
					print_D_LL(H);
					
					insertAt_pos(H, T, 1, -9);
					print_D_LL(H);
					
					insertAt_pos(H, T, 20, 107);
					print_D_LL(H);
					
					insertAt_pos(H, T, 30, 110);
					print_D_LL(H);
					
					insertAt_pos(H, T, 15, 56);
					print_D_LL(H);
					
					insertAt_pos_no_extra_back(H, T, 2, -7);
					print_D_LL(H);
					
					std::cout << "Length: " << length_LL(H) << std::endl;
					// verification for Head & Tail
					std::cout << "/*********************************************************/" << "\n";
					std::cout << "Head: " <<  H->data << std::endl;
					std::cout << "Tail: " << T->data << std::endl;
					return 0;
				}

			// Deletion in DLL:
				#include <iostream>
				using namespace std;

				class Node {
					public:
						int data;
						Node *prev;
						Node *next;
						
					Node(int data){
						this->data = data;
						prev = NULL;
						next = NULL;
					}

					~Node(){
						std::cout << "Memory Freed up for "<< data << std::endl;
						delete next;
					}
				};

				void insertAtHead_DLL(Node * &H, Node * &T, int val){
					Node * n = new Node(val);
					
					if(H == NULL){
						H = n;
						T = n;
					}else{
						n->next = H;
						H->prev = n;
						H = n;
					}
				}

				void insertAtTail_DLL(Node * &T, Node * &H, int val){
					Node * n = new Node(val);
					
					if(H == NULL){
						H = n;
						T = n;
					}else{
						n->prev = T;
						T->next = n;
						T = n;
					}
				}

				void printLL(Node *H){
					if(!H)
						std::cout << "LL is empty" << std::endl;
						
					while(H != NULL){
						std::cout << H->data << "\t";
						H = H->next;
					}
					std::cout << std::endl;
				}

				void printingByTail(Node *T){
					while(T){
						std::cout << T->data << "\t";
						T = T->prev;
					}
					std::cout << std::endl;
				}

				void deleteBy_position_DLL(Node * &H, Node * &T, int pos) {
					// H != NULL means LL contains some data, its not empty
					if(H == NULL) {
						std::cout << "LL is empty" << std::endl;
					}
					else if(pos == 1) {
						Node *curr = H;
						H = H->next;
						
						// this means the LL contains only one element & that element also we are deleting, so we can't access the curr elements prev address.
						if(H != NULL)               //  if(H)
							H->prev = NULL;
						
						curr->next = NULL;
						delete curr;
					} else {
						Node * curr = H;
						
						// middle element
						while(--pos && curr != NULL)            // or while(--pos && curr)
							curr = curr->next;
							
						if(curr == NULL)         // if(!curr)
							std::cout << "Position is greater than length of LL" << std::endl;
							
						// it means curr is standing on last element
						// need to update Tail
						else if(curr -> next == NULL){
							T = T -> prev;
							
							// handling edge case contains only one element in LL.
							if(T != NULL)
								T -> next = NULL;
							
							curr -> prev = NULL;
							delete curr;
						}else{
							// middle element case
							
							curr -> prev -> next = curr -> next;
							curr -> next -> prev = curr -> prev;
							
							curr -> next = NULL;
							curr -> prev = NULL;
							delete curr;
						}
					}
				}

				void deleteBy_NODE_Value(Node * &H, Node * &T, int val){
					// this means the LL is empty we can't delete anything
					if(H == NULL)               // if(!H)
						std::cout << "LL is empty, value not found" << std::endl;
					
					Node * temp = H;
					
					while(temp != NULL && temp->data != val)
						temp = temp->next;
					
					if(temp == NULL)
						std::cout << "Node with value "<< val << " is not exist in LL" << std::endl;
					else{
						// this means this is the first element, need to update the Head
						if(temp -> prev == NULL){
							H = H ->next;
							
							// handling only one element case in LL
							if(H != NULL)
								H -> prev = NULL;
							
							temp -> next = NULL;
							delete temp;
							
						}   // this means this is the last element need to update Tail
						else if(temp -> next == NULL){
							
							T = T -> prev;
							// handling only one element case in LL
							if(T != NULL)
								T -> next = NULL;
							
							temp -> prev = NULL;
							delete temp;
						}   // this indicate this is the middle element just need to delete it
						else{
							temp -> prev -> next = temp -> next;
							temp -> next -> prev = temp -> prev;
							
							temp -> next = temp -> prev = NULL;
							delete temp;
						}
					}
				}

				int main() {
				
					Node *H = NULL, *T = NULL;
					
					insertAtHead_DLL(H, T, 1);
					insertAtHead_DLL(H, T, 0);
					insertAtHead_DLL(H, T, -1);
					insertAtHead_DLL(H, T, -2);
					insertAtHead_DLL(H, T, -3);
					insertAtHead_DLL(H, T, -4);
					insertAtHead_DLL(H, T, -5);
					insertAtHead_DLL(H, T, -6);
					printLL(H);
					
					insertAtTail_DLL(T, H, 2);
					insertAtTail_DLL(T, H, 3);
					insertAtTail_DLL(T, H, 4);
					insertAtTail_DLL(T, H, 5);
					insertAtTail_DLL(T, H, 6);
					insertAtTail_DLL(T, H, 7);
					cout<<"LL using Head: \t";
					printLL(H);
					
					// By position
						// start position
						// -in case of deleting node at start should update Head
						deleteBy_position_DLL(H, T, 1);
						printLL(H);
						deleteBy_position_DLL(H, T, 1);
						printLL(H);
						
						// // middle position
						deleteBy_position_DLL(H, T, 2);
						printLL(H);
						
						deleteBy_position_DLL(H, T, 3);
						printLL(H);
						
						// end position
						// -in case of deleting node at end should update Tail
						deleteBy_position_DLL(H, T, 10);
						printLL(H);
						
						deleteBy_position_DLL(H, T, 9);
						printLL(H);
						
						// position is greater than total length of LL, means cur is pointing to NULL
						deleteBy_position_DLL(H, T, 9);
					
					// By value
						deleteBy_NODE_Value(H, T, -4);
						printLL(H);
						
						deleteBy_NODE_Value(H, T, 5);
						printLL(H);
					
						deleteBy_NODE_Value(H, T, 3);
						printLL(H);
						
						deleteBy_NODE_Value(H, T, 3);
						printLL(H);
					
					
					// verifying Head & Tail are at right place
					std::cout << "Head: " << H->data << endl;
					std::cout << "Tail: " << T->data << std::endl;
					
					// // using tail printing LL
					cout<<"Reverse Order LL using Tail: \t";
					printingByTail(T);
					return 0;
				}

		3) Circular Singly LL (C_S_LL):
			The circular linked list is a linked list where all nodes are connected to form a circle. 
			In a circular linked list, the first node and the last node are connected to each other which forms a circle. 
			There is no NULL at the end.

			-Circular linked lists are similar to single Linked Lists with the exception of connecting the last node to the first node.

			-In a circular Singly linked list, the last node of the list contains a pointer to the first node of the list. We traverse the circular singly linked list until we reach the same node where we started. 
			The circular singly linked list has no beginning or end. No null value is present in the next part of any of the nodes.

			- there is no Head in Cicular LL
				#include <iostream>

				class C_S_LL {
					public:
						int data;
						C_S_LL *next = NULL;
					
					C_S_LL(int val){
						data = val;
					}
					
					~C_S_LL(){
						std::cout << "Releasing memory for "<< data << std::endl;
						delete next;
						next = NULL;
					}
				};

				//- insertion in after specific element(assuming that the element we are searching is always present in C_S_LL)
				void insertNode_NextToVal(C_S_LL * &trvrs, int val, int newVal){
					
					C_S_LL * n = new C_S_LL(newVal);
					
					if(trvrs == NULL){
						trvrs = n;
						trvrs ->next = trvrs;
					}else{
						C_S_LL *temp = trvrs;
						
						do{
							if(temp -> data == val){
								n -> next = temp -> next;
								temp -> next = n;
								break;
							}
							temp = temp -> next;
						}while(temp != trvrs);
					}
				}

				void print_C_S_LL(C_S_LL *traversal){
					
					if(!traversal){
						std::cout << "LL is empty" << std::endl;
						return ;
					}
					
					C_S_LL *curr_Addr = traversal;
					
					if(!traversal){
						std::cout << "Cicular Singlly LL is empty" << std::endl;
						return ;
					}
					
					do{
						std::cout << traversal -> data << "\t";
						traversal = traversal -> next;
					}while(traversal != curr_Addr);
					
					std::cout << std::endl;
				}

				//- deletion by value
				void delete_C_S_LL_Node(C_S_LL * &Tail, int val){
					if(Tail == NULL){
						std::cout << "LL is empty" << std::endl;
						return ;
					}
					
					C_S_LL *cur = Tail -> next;
					C_S_LL *prev = Tail;
					
					do{
						if(cur -> data == val)
							break;
						prev = cur;
						cur = cur -> next;
					}while(cur -> data != val && prev != Tail);
					
					if(prev == Tail && cur->data != val)
						std::cout << "Node " << val << " Doesn't Exist" << std::endl;
					else {
						
						// handling the one element case
						if(prev == cur)
							Tail = NULL;
						
						prev -> next = cur -> next;
						// updating the Tail pointer if both item to be deleted(cur pointer) & Tail are pointing to same value
						if(Tail == cur)
							Tail = prev;
						cur -> next = NULL;
						delete cur;
					}
				}

				int main() {
					C_S_LL *Tail = NULL;
					print_C_S_LL(Tail);

					insertNode_NextToVal(Tail, 5, 1);
					print_C_S_LL(Tail);
					
					insertNode_NextToVal(Tail, 1, 2);
					insertNode_NextToVal(Tail, 2, 3);
					insertNode_NextToVal(Tail, 3, 4);
					insertNode_NextToVal(Tail, 4, 5);
					insertNode_NextToVal(Tail, 5, 6);
					print_C_S_LL(Tail);
					
					insertNode_NextToVal(Tail, 2, 33);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 45);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 1);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 2);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 5);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 4);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 33);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 3);
					print_C_S_LL(Tail);
					
					delete_C_S_LL_Node(Tail, 6);
					print_C_S_LL(Tail);
					
					std::cout << "Completion fine" << std::endl;
					return 0;
				}

		4) Circular Doubly LL (C_D_LL):
			Circular Doubly Linked List has properties of both doubly linked list and circular linked list in which two consecutive elements are linked or connected by the previous and next pointer and the last node points to the first node by the next pointer and also the first node points to the last node by the previous pointer.
			- insertion/ deletion
				#include<iostream>

				class C_D_LL_NODE {
					public:
						int data;
						C_D_LL_NODE *next = NULL;
						C_D_LL_NODE *prev = NULL;
					
					C_D_LL_NODE(int data){
						(*this).data = data;
					}
					
					// de-structor
					~C_D_LL_NODE(){
						std::cout << "Releasing Memory for " << data << std::endl;
						delete next;
						delete prev;
						next = NULL;
						prev = NULL;
					}
				};

				// inserting newVal after val element, (assuming that val is always present in LL)
				void insertNode(C_D_LL_NODE * &T, int val, int newVal){
					
					C_D_LL_NODE * n = new C_D_LL_NODE(newVal);
					
					if(T == NULL){
						// it means LL is empty
						T = n;
						
						T -> next = T;
						T -> prev = T;
					}else{
						// it means it has some elements previously, insert new node after val
						C_D_LL_NODE * temp = T;
						
						// while(temp -> data != val)
						//     temp = temp -> next;
						
						// or other while loop
						C_D_LL_NODE * Addr_holder = T;
						
						do{
							if(temp -> data == val)
								break;
							temp = temp -> next;
						}while(temp != Addr_holder);
						
						// this line indicates that the val you entered is doesn't exist in the LL
						if(temp == Addr_holder && temp -> data != val){
							std::cout << "New node "<< newVal <<" can't be inserted" << std::endl;
							delete n;
							return ;
						}

						// the sequence of below lines are important, if we change the sequence we won't gets expected result    
						n -> next = temp -> next;
						n -> prev = temp -> next -> prev;
						
						temp -> next -> prev = n;
						temp -> next = n;
					}
				}

				void print_LL(C_D_LL_NODE *itr){
					// C_D_LL_NODE * temp = itr;
					// std::cout << itr -> data << "\t";
					// itr = itr -> next;
					
					// while(itr != temp){
					//     std::cout << itr -> data << "\t";
					//     itr = itr -> next;
					// }
					// std::cout << std::endl;
					
					// or
					
					if(!itr){           // if(itr == NULL)
						std::cout << "LL is empty" << std::endl;
						return ;
					}
					C_D_LL_NODE * Addr_holder = itr;
					do{
						std::cout << itr -> data << "\t";
						itr = itr -> next;
					}while(itr != Addr_holder);
					std::cout << std::endl;
				}

				void deleteNode_With_Val(C_D_LL_NODE * &T, int val){
					if(T == NULL){
						std::cout << "LL is empty, can't delete anything" << std::endl;
						return ;
					}else{
						// LL  contains one element & we are deleting it
						if(T -> next == T){           // or if((T -> prev == T))
							C_D_LL_NODE * temp = T;
							T = NULL;
							
							temp -> next = NULL;
							temp -> prev = NULL;
							
							delete temp;
						}else{
							C_D_LL_NODE * trvrs = T;
							
							// (trvrs != T) this says we are not came again to same address to check data, if we came then break the loop.
							do{
								if(trvrs -> data == val)
									break;
								trvrs = trvrs -> next;
							}while(trvrs != T);
							
							// this states that we came to same address again, so the element we are searching to delete is not exist
							if(trvrs == T && trvrs -> data != val)
								std::cout << "the Node with value "<< val << " doesn't exist." << std::endl;
							else{
								// this block indicates that element with given value found, and we need to delete it.
								if(T == trvrs)
									T = T -> next;
									
								trvrs -> prev -> next = trvrs -> next;
								trvrs -> next -> prev = trvrs -> prev;
								
								trvrs -> next = trvrs -> prev = NULL;
								delete trvrs;
							}
						}
					}
				}

				int main(){
				
					C_D_LL_NODE *Tail = NULL;
					
					insertNode(Tail, 12, 1);
					insertNode(Tail, 1, 2);
					insertNode(Tail, 2, 3);
					insertNode(Tail, 3, 4);
					insertNode(Tail, 4, 5);
					insertNode(Tail, 4, 12);
					print_LL(Tail);
					
					insertNode(Tail, 12, 34);
					print_LL(Tail);
					
					deleteNode_With_Val(Tail, 0);   // value not present in LL
					print_LL(Tail);
					
					deleteNode_With_Val(Tail, 1);   // deleting first element, updating Tail along with
					print_LL(Tail);
					
					deleteNode_With_Val(Tail, 43);   // value not present in LL
					deleteNode_With_Val(Tail, 12);   // middle element
					print_LL(Tail);
					
					
					std::cout << "Tail :"<< Tail->data << std::endl;
					deleteNode_With_Val(Tail, 5);
					deleteNode_With_Val(Tail, 3);
					deleteNode_With_Val(Tail, 4);
					deleteNode_With_Val(Tail, 34);
					print_LL(Tail);
					
					// deleting last element
					deleteNode_With_Val(Tail, 2);
					print_LL(Tail);
					
					std::cout << std::endl;
					
					if(Tail)            // if(Tail != NULL)
						std::cout << "Tail :"<< Tail->data << std::endl;
						
					std::cout << "Done." << std::endl;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	17/04/24
Lecture-45: Linked List Questions: Reverse LL and find Middle of LL
	Reverse LL:
		Refer Q.693, Q.694 in POTD section.

	HomeWork:
		Reverse a Doubly Linked List:
			Problem statement:
				Given a doubly linked list of n elements. Your task is to reverse the doubly linked list in-place.
				Example 1:
				Input:
				LinkedList: 3 <--> 4 <--> 5
				Output: 5 4 3

				Example 2:
				Input:
				LinkedList: 75 <--> 122 <--> 59 <--> 196
				Output: 196 59 122 75

				Your Task:
					Your task is to complete the given function reverseDLL(), which takes head reference as argument and this function should reverse the elements such that the tail becomes the new head and all pointers are pointing in the right order. You need to return the new head of the reversed list. The printing and verification is done by the driver code.

				Expected Time Complexity: O(n).
				Expected Auxiliary Space: O(1).

				Constraints:
					1 <= number of nodes <= 10^4
					0 <= value of nodes <= 10^4
				
			/*
				struct Node {
					int data;
					Node * next;
					Node * prev;

					Node (int x) {
						data=x;
						next=NULL;
						prev=NULL;
					}
					
				};
			*/
			class Solution {
				public:
				Node* reverseDLL(Node * head) {
					Node* last = NULL;
					Node* cur = head;
					
					while(cur){
						head = head -> next;
						cur -> prev = cur -> next;
						cur -> next = last;
						
						last = cur;
						cur = head;
					}
					return last;
				}
			};

			// or
				class Solution {
					public:
					Node* reverseDLL(Node * head) {
						Node* cur = head, *last = NULL;
						
						while(head){
							head = head -> next;
							
							cur -> next = last;
							cur -> prev = head;
							
							last = cur;
							cur = head;
						}
						return last;
					}
				};

	Middle of LL:
		Refer Q.695 in POTD section
---------------------------------------------------------------------------------------------------------
	19/04/24
Lecture-46: Linked List Questions: Reverse LL in "K group" && Check LL is Circular or not
	Q. Reverse List In K Groups:
		Problem statement
			You are given a linked list of 'n' nodes and an integer 'k', where 'k' is less than or equal to 'n'.
			Your task is to reverse the order of each group of 'k' consecutive nodes, if 'n' is not divisible by 'k', then the last group of nodes should remain unchanged.
			For example, if the linked list is 1->2->3->4->5, and 'k' is 3, we have to reverse the first three elements, and leave the last two elements unchanged. Thus, the final linked list being 3->2->1->4->5.
			Implement a function that performs this reversal, and returns the head of the modified linked list.

			Example:
				Input: 'list' = [1, 2, 3, 4], 'k' = 2
				Output: 2 1 4 3

			Explanation:
				We have to reverse the given list 'k' at a time, which is 2 in this case. So we reverse the first 2 elements then the next 2 elements, giving us 2->1->4->3.

			Note:
				All the node values will be distinct.

			Sample Input 1:
			6
			5 4 3 7 9 2
			4 
			Sample Output 1:
			7 3 4 5 9 2

			Explanation of the Sample Input 1:
			For the given test case, we reverse the nodes in groups of four. But for the last 2 elements, we cannot form a group of four, so leave them as they are. The linked list becomes 7->3->4->5->9->2. Hence the output is 7 3 4 5 9 2
			Sample Input 2:
			4
			4 3 2 8
			4 
			Sample Output 2:
			8 2 3 4

			Expected Time Complexity:
				Try to solve this in O(n). 

			Expected Space Complexity:
				Try to solve this using O(1) extra space.    

			Constraints:
				1 <= n <= 10^4
				1 <= k <= n
				Time Limit: 1 sec

		/**
		* Definition for singly-linked list.
		* class Node {
		* public:
		*     int data;
		*     Node *next;
		*     Node() : data(0), next(nullptr) {}
		*     Node(int x) : data(x), next(nullptr) {}
		*     Node(int x, Node *next) : data(x), next(next) {}
		* };
		*/
		int getLength(Node* head) {
			int length  = 0;
			while(head != NULL) {
				length ++;
				head = head -> next;
			}
			return length;
		}  

		Node* kReverse(Node* head, int k) {
			if(head == NULL  || head -> next == NULL) {
				return head;
			}
			
			if(getLength(head) < k) {
				return head;
			}

			Node* prev = NULL;
			Node* curr = head;
			int count = k;


			while(curr != NULL  && count--) {
				Node* next = curr -> next;
				curr -> next = prev;
				prev = curr;
				curr = next;
			}


			head -> next = kReverse(curr, k);
			return prev;
		}

		// Little Complex:
			int len(Node *temp, int k){
				int l =0;
				while(temp){
					temp = temp -> next;
					l++;
					if(l >= k)
						return 1;
				}
				return 0;
			}

			Node* kReverse(Node* head, int k) {
				if(head == nullptr || head->next == nullptr)
					return head;
				
				if(!len(head, k))
					return head;

				// reversing the k elements

				Node *cur = head;
				Node *prev = nullptr;

				int cnt = k;
				while(cnt-- && cur){
					Node *hold = cur -> next;

					cur -> next = prev;
					prev = cur;

					cur = hold;
				}

				if(cur != nullptr)
					head -> next = kReverse(cur, k);
				return prev;   
			}

	Q. LL is Circular or not:
		#include <bits/stdc++.h> 
		/*************************************************
			Following is the structure of class Node:
			
			class Node{
				public:
					int data;
					Node* next;
				
				Node(int data){
					this->data = data;
					this->next = NULL;
				}
			}
		**************************************************/
		bool isCircular(Node* head) {
			// empty list is considered as circular LL
			if (head == NULL)
				return 1;

			Node* temp = head -> next; 
			while(temp) {
				if(temp == head)
					return 1;
				temp = temp -> next;
			}
			return 0;
		}

		//or
			bool isCircular(Node* head){
				if (head == nullptr)
					return true;

				Node* slow = head;
				Node* fast = head->next;

				while (fast != nullptr && fast->next != nullptr) {
					if (slow == fast)
						return true;

					slow = slow->next;
					fast = fast->next->next;
				}
				return false;
			}
---------------------------------------------------------------------------------------------------------
	20/04/24
Lecture-47: Detect & Remove Loop in Linked List [Approach Discussion + Optimised Implementation]
	-Refer Q.704 & Q.705 Floyd’s Cycle Detection Algorithm in POTD section 
	- Detect Cycle in LinkedList.
	- Return the node from where cycle starts.
	- Remove cycle from LinkedList.

	Q. Detect and Remove Loop:
		Problem statement
			Given a singly linked list, you have to detect the loop and remove the loop from the linked list, if present. You have to make changes in the given linked list itself and return the updated linked list.
			Expected Complexity: Try doing it in O(n) time complexity and O(1) space complexity. Here, n is the number of nodes in the linked list.
			Constraints:
				1 <= N <= 100000.
				1 <= ‘VAL’ <= 1000.
				Time limit: 1 sec

			Sample Input:
			6 2
			1 2 3 4 5 6 
			Sample Output:
			1 2 3 4 5 6
			Explanation:
			For the given input linked list, the last node is connected to the second node as:
			Now, after detecting and removing this loop the linked list will be:

		Node *removeLoop(Node *head) {
			if(head == nullptr)
				return head;

			Node *slow = head, *fast = head;
			// this loop confirms the cycle in LL.
			while(fast){
				fast =  fast -> next;
				if(fast == nullptr)
					return head;
				fast = fast -> next;
				slow = slow -> next;
				if(slow == fast)
					break;
			}

			if(fast == nullptr)
				return head;

			// this loop finds the starting point of that loop
			slow = head;
			while(slow != fast){
				slow = slow -> next;
				fast = fast  -> next;
			}
			
			while(fast -> next != slow )
				fast = fast -> next;

			fast -> next = nullptr;
			return head;
		}	

	HomeWork:
		5 ways to remove loop from linked list:
			1) Floyd’s cycle detection algorithm (hare & tortoise algorithm)
			2)
			3)
			4)
			5)
			❌Pending

		3 ways to detect loop in linked list:
			1) Floyd’s Cycle Detection Algorithm (hare & tortoise algorithm)/(two pointer algorithm)/(slow, fast pointer algorithm)
			2) Using hashMap Refer Q.723 (marking true to visited elements, if we found true again then considering the loop present).
				map<Node*, bool> Vis;
			
			3) using vector & find function				
				vector<Node*> holder;
				-storing the address of every Node, if we found the address of Node which is already present in vector, then we can say that loop present.
			
			4) by changing the structure of Node, keeping a flag=0 element in NODE.
				-firstly checking the flag, if flag = 1, then loop present, else continue iterating over list till NULL.
				-as we visit each element setting that flag=1.
---------------------------------------------------------------------------------------------------------
	23/04/24
Lecture-48: Remove Duplicates from a Sorted/UnSorted Linked List
	Q.1. Remove Duplicates from a Sorted LL:
		-> Refer Q.727 & Q.728 from POTD section
	
	Q.2. Remove Duplicates from a Unsorted LL:
		-> Refer Q.737 from POTD section
	
	HomeWork:
		Q.1. Circular LL split into 2 halves
			Refer Q.738 & Q.739 from POTD section
---------------------------------------------------------------------------------------------------------
	24/04/24
Lecture-49: Merge 2 Sorted Linked Lists || Sort 0s, 1s and 2s in Linked List
	Q.1. Sort linked list of 0s 1s 2s
		-> Refer Q.743 from POTD section

	Q.2. Merge two sorted linked lists
		-> Refer Q.744 from POTD section
---------------------------------------------------------------------------------------------------------
	28/04/24
Lecture-50: Check Palindrome in Linked List
	-> Refer Q.747 from POTD section
---------------------------------------------------------------------------------------------------------
	28/04/24
Lecture 51: Add 2 Numbers represented by Linked Lists
	-> Refer Q.759 && Q.763 from POTD section
---------------------------------------------------------------------------------------------------------
	28/04/24
Lecture 52: Clone a Linked List with Random Pointers
	-> Refer Q.760 from POTD section
---------------------------------------------------------------------------------------------------------
	02/05/24
Lecture-53: Merge Sort in Linked List
	Q.1 Merge Sort in Linked List
		Steps:
		0. find mid of LL.
		1. break LL into 2 halves.
		2. point the first parts end to null ie. mid -> next = null.
		3. do again step 1. till LL contains 0 or 1 element
		4. sort the 2 LL recursively
		5. merge them back.
		-> Refer Q.769 from POTD section

	HomeWork:
		Why Quick Sort preferred for Arrays and Merge Sort for Linked Lists?
		->https://www.geeksforgeeks.org/why-quick-sort-preferred-for-arrays-and-merge-sort-for-linked-lists/

			Quick sort is preferred for arrays because it has a good locality of reference. Merge sort is generally preferred for linked lists because it doesn't require random access to elements.
			Quick Sort is generally preferred for arrays because it has good cache locality and can be easily implemented in-place, which means it doesn’t require any extra memory space beyond the original array. In Quick Sort, we can use the middle element as the pivot and partition the array into two sub-arrays around the pivot. This can be done by swapping elements, and the pivot can be placed in its final position in the sorted array. 
	
			This process of partitioning is done recursively until the entire array is sorted. The cache locality of Quick Sort is beneficial because it minimizes the number of cache misses, which improves performance.
			On the other hand, Merge Sort is generally preferred for linked lists because it doesn’t require random access to elements. In Merge Sort, we divide the linked list into two halves recursively until we have individual elements. Then, we merge the individual elements by comparing and linking them in a sorted order. 
			The advantage of Merge Sort for linked lists is that it doesn’t require random access to elements, which is not efficient for linked lists since we need to traverse the list linearly. Also, Merge Sort is a stable sort, which means it maintains the relative order of equal elements in the sorted list. This is important for linked lists, where the original order of equal elements may be significant. However, Merge Sort requires extra memory space for the merge step, which can be a disadvantage in some cases.
			Quick Sort Advantages:
				Fast and efficient for arrays, especially for large datasets.
				In-place sorting which means it doesn’t require any extra memory space beyond the original array.
				Good cache locality which minimizes the number of cache misses.
				Easy to implement and widely used in practice.
			
			Quick Sort Disadvantages:
				Not stable, which means it may change the relative order of equal elements in the sorted array.
				Worst-case time complexity is O(n^2), which occurs when the pivot is not chosen properly and the partitioning process doesn’t divide the array evenly.
				Not suitable for linked lists, as it requires random access to elements.

			Merge Sort Advantages:
				Suitable for sorting large datasets and linked lists.
				Stable sort which means it maintains the relative order of equal elements in the sorted list.
				Guaranteed worst-case time complexity of O(n*log(n)).
				Memory efficient because it doesn’t require any extra memory space beyond the original data structure.

			Merge Sort Disadvantages:
				Requires extra memory space for the merge step, which can be a disadvantage in some cases.
				Not as efficient as Quick Sort for small datasets.
				Not in-place sorting, which means it requires extra memory space for temporary arrays during the merging process.
		
	Q.2 Flatten A Linked List
		-> Refer Q.770 & 771 from POTD section.
---------------------------------------------------------------------------------------------------------
	05/05/24
Lecture-54: Introduction to Stacks
	Stacks are a type of container adaptors with LIFO(Last In First Out) type of working, where a new element is added at one end (top) and an element is removed from that end only.  Stack uses an encapsulated object of either vector or deque (by default) or list (sequential container class) as its underlying container, providing a specific set of member functions to access its elements. 
	If there is confusion in remembering the basic difference between stack and queue, then just have a real life example for this differentiation, for stack, stacking of books we can take the top book easily and for queue remember when you have to stand in queue front of ATM for taking out the cash, then first person near to ATM has the first chance to take out the money from ATM. So, queue is the FIFO (First In First Out) type working.

	Stack Operations:
		empty() – Returns whether the stack is empty – Time Complexity : O(1) 
		size() – Returns the size of the stack – Time Complexity : O(1) 
		top() – Returns a reference to the top most element of the stack – Time Complexity : O(1) 
		push(g) – Adds the element ‘g’ at the top of the stack – Time Complexity : O(1) 
		pop() – Deletes the most recent entered element of the stack – Time Complexity : O(1) 
	
	eg.
		#include <iostream>
		#include<stack>
		using namespace std;

		int main() {
			std::stack<int> s;
			std::cout << "is Stack empty :" << (s.empty() ? "Yes": "No") << std::endl;
			
			for(int i=1; i<=5; i++)
				s.push(i);

			std::cout << "is Stack empty :" << (s.empty() ? "Yes": "No") << std::endl;
			std::cout << "top element of Stack: " << s.top()  << std::endl;
			std::cout << "Size of Stack : "<< s.size() << std::endl;
			
			s.pop();
			std::cout << "top element of Stack: " << s.top()  << std::endl;
			std::cout << "Size of Stack : "<< s.size() << std::endl;
			
			while(!s.empty()){
				cout<< s.top()<<"\t";
				s.pop();
			}
			return 0;
		}

	Program: Stack using Array
		#include <iostream>
		using namespace std;

		class Stack{
			int top = -1;
			int size, *arr;
			
			public:
			// constructor
			Stack(int size){
				this -> size = size;
				arr =  new int[size];
			}
			
			void push(int val){
				if((top + 1) < size){                       //if(++top < size){
					arr[++top] = val;
				}else{
					std::cout << "Stack Overflow." << std::endl;
				}
			}
			
			void pop(){
				if(top == -1){
					std::cout << "Stack Underflow" << std::endl;
					return ;
				}
				top--;
			}
			
			int peek(){
				if(top == -1){
					std::cout << "Stack is empty" << std::endl;
					return -1;
				}
				return arr[top];
			}
			
			bool isEmpty(){
				if(top == -1)
					return 1;
				return 0;
			}
		};


		int main() {
			Stack s(5);
			std::cout << "Stack empty ? : " << s.isEmpty() << std::endl;
			
			for(int i=1; i<=5; i++)
				s.push(i);
			
			std::cout << "Stack empty ? : " << s.isEmpty() << std::endl;
			std::cout << "top element: "<< s.peek() << std::endl;
			
			s.pop();
			std::cout << "top element: "<< s.peek() << std::endl;
			
			s.push(89);
			std::cout << "top element: "<< s.peek() << std::endl;
			
			s.push(100);            // stack Overflow
			std::cout << "top element: "<< s.peek() << std::endl;
			
			
			std::cout << "Content of Stack" << std::endl;
			while(!s.isEmpty()){
				cout<<s.peek() <<"\t";
				s.pop();
			}
			
			std::cout << "\nStack empty ? : " << s.isEmpty() << std::endl;
			s.pop();
			return 0;
		}

	Stack Using LinkedList:
		❌Pending
	
	Q. Two Stacks:
		Problem statement
			Design a data structure, which represents two stacks using only one array common for both stacks. The data structure should support the following operations:
			push1(NUM) - Push ‘NUM’ into stack1.
			push2(NUM) - Push ‘NUM’ into stack2.
			pop1() - Pop out a top element from stack1 and return popped element, in case of underflow return -1.
			pop2() - Pop out a top element from stack2 and return popped element, in case of underflow return -1.
			There are 2 types of queries in the input
			Type 1 - These queries correspond to Push operation.
			Type 2 - These queries correspond to Pop operation.
			Note:
			1. You are given the size of the array.
			2. You need to perform push and pop operations in such a way that we are able to push elements in the stack until there is some empty space available in the array.
			3. While performing Push operations, do nothing in the situation of the overflow of the stack.
			Constraints:
				0 <= S <= 10^5
				1 <= Q <= 5*10^5
				1 <= type, stackNo <= 2
				0 <= NUM <= 10^9
				Time Limit: 1 sec.   

			Sample Input 1:
			3 5
			1 1 3
			1 2 4
			1 1 5
			2 1
			2 2
			Sample output 1:
			5
			4
			Explanation of sample input 1:

			Here every step shows a snapshot of 2 stacks after each operation.

			Initialising the size of the array to 3, twoStack = new TwoStack(3).
			Then operation on two stacks occurs as follows:
			twoStack.push1(3) // pushing 3 in stack1.
			twoStack.push2(4) // pushing 4 in stack2.
			twoStack.push1(5) // pushing 5 in stack1.
			twoStack.pop1() // popping out from stack2, it returns 5.
			twoStack.pop2() // popping out from stack2, it returns 4.
			Sample Input 2:
			3 10
			1 1 2
			1 1 4
			1 1 3
			1 2 5
			2 2
			2 1
			1 2 6
			2 2
			2 1
			1 2 7
			Sample output 2:
			-1
			3
			6
			4
			Explanation of sample input 2:

			Here every step shows a snapshot of 2 stacks after each operation.

			Initialising the size of the array to 3, twoStack = new TwoStack(3).
			Then operation on two stacks occurs as follows:
			twoStack.push1(2) // pushing 2 in stack1.
			twoStack.push1(4) // pushing 4 in stack1.
			twoStack.push1(3) // pushing 3 in stack1.
			twoStack.push2(5) // pushing 5 in stack2, but 3 elements are already in the array and there is no empty space hence it cannot be added.
			twoStack.pop2() // popping out from stack2, it is already empty hence returns -1.
			twoStack.pop1() // popping out from stack1, it returns 3.
			twoStack.push2(6) // pushing 6 in stack2.
			twoStack.pop2() // popping out from stack2, it returns 6.
			twoStack.pop1() // popping out from stack1, it returns 4.
			twoStack.push2(7) // pushing 7 in stack2.

		#include <bits/stdc++.h> 
		class TwoStack {
			int *arr;
			int top1, top2;
			int size;
			public:
			// Initialize TwoStack.
			TwoStack(int s) {
				size = s;
				top1 = -1, top2 = s;
				arr = new int[s];
			}
			
			// Push in stack 1.
			void push1(int num) {
				if(top2 - top1 > 1)                                                                     //or            // if((top1+1) < size && (top1+1) < top2)
					arr[++top1] = num;
			}

			// Push in stack 2.
			void push2(int num) {
				if(top2 - top1 > 1)                                                                       //or         // if((top2-1) > top1 && (top2-1) >=0)
					arr[--top2] = num;
			}

			// Pop from stack 1 and return popped element.
			int pop1() {
				if(top1 == -1)
					return -1;
				return arr[top1--];
			}

			// Pop from stack 2 and return popped element.
			int pop2() {
				if(top2 == size)
					return -1;
				return arr[top2++];
			}
		};
---------------------------------------------------------------------------------------------------------
	07/05/24
Lecture-55: Stack Interview Questions
	Q.1. Reverse a string using stack
		#include <iostream>
		#include<stack>
		using namespace std;
		int main() {
			string s = "Vivek", ans;
			int i=0;
			stack<char> st;
			
			std::cout << s << std::endl;
			while(i < s.size())
				st.push(s[i++]);
				
			while(!st.empty()){
				ans += st.top();
				st.pop();
			}
			
			std::cout << ans << std::endl;
			return 0;
		}

	Q.2. Delete middle element from stack:
		Problem statement
			You are having a stack "ARR" of size 'N+1', your task is to delete the middlemost element so that the size of resulting stack is 'N'.
			A stack is a linear data structure where both insertion and deletion of elements take place at the top. It follows FILO (First In Last Out) or LIFO (Last In First Out) approaches. Books piled on top of each other is an example of a stack, where you can only remove a single book at a time, which is at the top of the stack. Likewise, you can only add a single book at a time, on the top of the stack only.
			Example :-
			INPUT : ARR [ ] = [ 1 , 2 , 3 , 4 , 5 ] , N = 4
			OUTPUT: ARR [ ] = [ 1 , 2 , 4,  5 ]
			The above example contains an odd number of elements, hence the middle element is clearly the (N+1) / 2th element, which is removed from the stack in the output.
			INPUT : ARR [ ] = [ 5, 6, 7, 8 ] , N = 3
			OUTPUT: ARR [ ] = [ 5, 7, 8 ]
			The above example contains an even number of elements, so out of the two middle elements, we consider the one which occurs first. Hence, the middle element would be ((N+1) / 2 - 1) element, which is 6 and is removed from the stack in the output.
			Constraints:
				1 <= T <= 100    
				1 <= N+1 <= 3000
				0 <= data <= 10^9
				Where ‘T’ is the number of test cases, ‘N+1’ is the number of elements in the input Stack. ‘data’ is the value of each element in the stack.
				Time limit: 1 second
			Sample Input 1:
				2
				4
				1 2 3 4 5
				7
				83 74 67 49 94 8 11 1
				Sample Output 1:
				1 2 4 5
				83 74 67 94 8 11 1
				Explanation for Sample 1:
				In the 1st testcase, there are an odd number of elements, hence the middle element is clearly the (N+1) / 2th element which is 3, and is removed from the stack in the output.

				In the 2nd testcase, there are an odd number of elements, hence the middle element is clearly the (N+1) / 2th element which is 49, and is removed from the stack in the output.
				Sample Input 2:
				3
				1
				5 10    
				4
				1 3 4 2 7
				5
				9 5 2 7 8 6
				Sample Output 2:
				10
				1 3 2 7
				9 5 7 8 6

		#include <bits/stdc++.h>
		void solve(stack<int>& st, int c, int size){
			if((size/2) == c){
				st.pop();
				return ;
			}
			int curEle = st.top();
			st.pop();
			
			solve(st, c+1, size);
			st.push(curEle);
		}

		void deleteMiddle(stack<int>&inputStack, int N){
			// int cnt = 0;
			solve(inputStack, 0, N);
		}

	Q.3. Valid Parentheses:
		Problem statement
			You're given a string 'S' consisting of "{", "}", "(", ")", "[" and "]" .
			Return true if the given string 'S' is balanced, else return false.
			For example:
			'S' = "{}()".
			There is always an opening brace before a closing brace i.e. '{' before '}', '(' before ').
			So the 'S' is Balanced.
			Sample Input 1 :
				[()]{}{[()()]()}
				Sample Output 1 :
				Balanced
				Explanation Of the Sample Input 1 :
				There is always an opening brace before a closing brace i.e. '{' before '}', '(' before '), '[' before ']'.
				So the 'S' is Balanced.
				Sample Input 2 :
				[[}[
				Sample Output 2 :
				Not Balanced
				Constraints:
				1 <= 'N' <= 10^5

				Where 'N' is the length of the input string 'S'.
				Time Limit: 1 sec
		
		// Using map:
			bool isValidParenthesis(string s) {
				stack<char> st;
				map<char, char> mapping = {
										{'}','{'},
										{']','['},
										{')', '('}
									};

				for(char ch: s){
					if(!st.empty() && st.top() == mapping[ch])
						st.pop();
					else
						st.push(ch);
				}
				return st.empty();
			}

		// without using map:
			bool isValidParenthesis(string s) {
				stack<char> st;

				for(char ch: s){
					if(ch == '(' || ch == '[' || ch == '{')
						st.push(ch);
					else{
						if(!st.empty() && ((st.top() == '(' && ch == ')') || (st.top() == '[' && ch == ']') || (st.top() == '{' && ch == '}')))
							st.pop();
						else
							return 0;
					}
				}
				return st.empty();
			}

	Q.4. Insert An Element At Its Bottom In A Given Stack:
		Refer Q. 263 from POTD section

	Q.5. Reverse Stack Using Recursion:
		-> Refer Q. 443 from POTD section
		void pushAtBottom(stack<int> &s, int n){
			if(s.empty()){
				s.push(n);
				return;
			}
			int num = s.top();
			s.pop();

			pushAtBottom(s, n);
			s.push(num);
		}

		void reverseStack(stack<int> &st) {
			if(st.size() == 0)
				return;
			int num = st.top();
			st.pop();
			reverseStack(st);

			pushAtBottom(st, num);
		}

	Q.6. Sort a Stack:
		Problem statement
			You’re given a stack consisting of 'N' integers. Your task is to sort this stack in descending order using recursion.
			We can only use the following functions on this stack S.
			is_empty(S) : Tests whether stack is empty or not.
			push(S) : Adds a new element to the stack.
			pop(S) : Removes top element from the stack.
			top(S) : Returns value of the top element. Note that this function does not remove elements from the stack.
			Note :
			1) Use of any loop constructs like while, for..etc is not allowed. 
			2) The stack may contain duplicate integers.
			3) The stack may contain any integer i.e it may either be negative, positive or zero.
			Constraints:
				1 <= 'T' <= 100
				1 <=  'N' <= 100
				1 <= |'V'| <= 10^9
				Where |V| denotes the absolute value of any stack element.
				Time limit: 1 sec

			Sample Input 1:
				1
				5
				5 -2 9 -7 3
				Sample Output 1:
				9 5 3 -2 -7
				Explanation of Sample Input 1:
				9 Is the largest element, hence it’s present at the top. Similarly 5>3, 3>-2 and -7 being the smallest element is present at the last. 
				Sample Input 2:
				1
				5
				-3 14 18 -5 30
				Sample Output 2:
				30 18 14 -3 -5
				Explanation of Sample Input 2:
				30 is the largest element, hence it’s present at the top. Similarly, 18>14, 14>-3 and -5 being the smallest element is present at the last. 

		// using Recursion: TC: O(n²)
			#include <bits/stdc++.h>
			void pushSorted(stack<int> &stack, int val){
				if(!stack.empty() && stack.top() > val){
					int n1 = stack.top();
					stack.pop();

					pushSorted(stack, val);
					stack.push(n1);
				}else{
					stack.push(val);
				}
			}

			void sortStack(stack<int> &stack) {
				if (stack.size() == 1) {
					return;
				}
				int n = stack.top();
				stack.pop();
				sortStack(stack);
				pushSorted(stack, n);
			}

		// without using Recursion:
			#include <bits/stdc++.h> 
			void sortStack(stack<int> &stack) {
				vector<int> hold;
				while(!stack.empty()){
					hold.push_back(stack.top());
					stack.pop();
				}

				sort(hold.begin(), hold.end());
				int i=0;
				while(i < hold.size())
					stack.push(hold[i++];
			}

	Q.7. Redundant Brackets:
		Problem statement
			Given valid mathematical expressions in the form of a string. You are supposed to return true if the given expression contains a pair of redundant brackets, else return false. The given string only contains ‘(‘, ’)’, ‘+’, ‘-’, ‘*’, ‘/’ and lowercase English letters.
			Note :
			A pair of brackets is said to be redundant when a subexpression is surrounded by needless/ useless brackets.
			For Example :
				((a+b)) has a pair of redundant brackets. The pair of brackets on the first and last index is needless. 
				While (a + (b*c)) does not have any pair of redundant brackets. 
			Constraints :
				1 <= T <= 50
				3 <= |S| <= 10^4
				Time Limit: 1 sec
			Sample Input 1 :
				2
				(a+b)
				(a+c*b)+(c))
				Sample Output 1 :
				No
				Yes
				Explanation of Sample Input 1 :
				In the first test case, there are no redundant brackets. Hence, the output is “No”. 


				In the second test case, the brackets around the alphabet ‘c’( index 8 and index 10) are redundant. Hence the output is “Yes”.
				Sample Input 2 :
				2
				(a*b+(c/d))
				((a/b))
				Sample Output 2 :
				No
				Yes
				Explanation of Sample Input 2 :
				In the first test case, there are no redundant brackets. Hence, the output is “No”. 
				In the second test case, the brackets around the subexpression “(a+b)” ( index 0 and index 6) are redundant. Hence the output is “Yes”.

		// TC: O(n) & SC: O(n)
		#include <bits/stdc++.h> 
		bool findRedundantBrackets(string &s) {
			stack<int> st;
			for(char ch: s){
				if(ch == '(' || ch == '+' || ch == '-' || ch == '*' || ch == '/')
					st.push(ch);
				else{
					if(ch == ')'){
						int isRedundant = 1;
						while(st.top() != '('){
							char top = st.top();
							if(top == '+' || top == '-' || top == '*' || top == '/')
							isRedundant =0;
							st.pop();
						}
						if(isRedundant)
							return 1;
						st.pop();
					}
				}
			}
			return 0;
		}

	Q.8. Minimum Cost To Make String Valid:
		Problem statement
			Ninja has been given a string ‘STR’ containing either ‘{’ or ‘}’. 'STR’ is called valid if all the brackets are balanced. Formally for each opening bracket, there must be a closing bracket right to it.
			For Example:
			“{}{}”, “{{}}”, “{{}{}}” are valid strings while “}{}”, “{}}{{}”, “{{}}}{“ are not valid strings.
			Ninja wants to make ‘STR’ valid by performing some operations on it. In one operation, he can convert ‘{’ into ‘}’ or vice versa, and the cost of one such operation is 1.
			Your task is to help Ninja determine the minimum cost to make ‘STR’ valid.
			For Example:
			Minimum operations to make ‘STR’ =  “{{“ valid is 1.
			In one operation, we can convert ‘{’ at index ‘1’ (0-based indexing) to ‘}’. The ‘STR’ now becomes "{}" which is a valid string.

			Note:
			Return -1 if it is impossible to make ‘STR’ valid.
			Constraints :
				1 <= T <= 100
				0 <= |STR| <= 10^5
				STR[i] = ‘{’ or ‘}’
				Time Limit: 1 sec 
			Sample Input 1:
			2
			{{{}
			{{}{}}
			Sample Output 1:
			1
			0
			Explanation For Sample Input 1:
			For the first test case:
			The two valid strings that can be obtained from  ‘STR’ using minimum operations “{{}}”   and “{}{}”. Ninja can transform ‘STR’ to “{{}}” by performing the following operations:
			Convert ‘{’ at index 2 to ‘}’.

			Ninja can transform ‘STR’ to “{}{}” by performing the following operations:
			Convert ‘{‘ at index 1 to ‘}’.
			The minimum number of operations in transforming ‘STR’ to either of the two valid strings is 1.So, the total cost is 1.

			For the second test case:
			Given ‘STR’ is already valid so the minimum number of 
			operations required is 0.
			So, the total cost is 0.
			Sample Input 2:
			3
			{}}{}}
			{{{{
			{{{}}
			Sample Output 2:
			1
			2
			-1

		#include <bits/stdc++.h>
		int findMinimumCost(string str) {
			if (str.size() % 2)
				return -1;

			stack<char> st;
			for(char ch: str){
				if(ch == '{'){
					st.push('{');
				}else{
					if(!st.empty() && st.top() == '{'){
					st.pop();
					}else{
					st.push(ch);
					}
				}
			}
			
			int OpBrac, CloBrac;
			OpBrac = CloBrac=0;

			while(!st.empty()){
				if(st.top() == '{')
					OpBrac++;
				else
					CloBrac++;
				
				st.pop();
			}

			// General math equation need to look it or need to understand it deeply
			int ans = (OpBrac + 1)/2 + (CloBrac+1)/2;
			return ans;
		}
---------------------------------------------------------------------------------------------------------
	09/05/24
Lecture-56: Largest Rectangular Area in Histogram
	Q.1 Next Smaller Element:
		→ Refer Q.813 & Q.814 from POTD Section
		Problem statement
			You are given an array 'ARR' of integers of length N. Your task is to find the next smaller element for each of the array elements.
			Next Smaller Element for an array element is the first element to the right of that element which has a value strictly smaller than that element.
			If for any array element the next smaller element does not exist, you should print -1 for that array element.
			For Example:
			If the given array is [ 2, 3, 1], we need to return [1, 1, -1]. Because for  2, 1 is the Next Smaller element. For 3, 1 is the Next Smaller element and for 1, there is no next smaller element hence the answer for this element is -1.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10 ^ 5
				0 <= ARR [i] <= 10 ^ 9
				Time Limit: 1sec.
			Sample Input 1:
				2
				4
				2 1 4 3
				3
				1 3 2
				Sample Output 1:
				1 -1 3 -1
				-1 2 -1
				Explanation for Sample Input 1:
				For the first test case : 
				1) For ARR [1] = 2 ,  the next smaller element is 1. 
				2) For ARR [2] = 1 ,  the next smaller element is -1 as no element in the array has value smaller than 1.
				3) For ARR [3] = 4 ,  the next smaller element is 3.
				4) For ARR [4] = 3 ,  the next smaller element is -1 as no element exists in the right of it.
				Hence, we will return the array [ 1, -1, 3, -1] in this case.

				For the second test case :
				1) For ARR [1] = 1 ,  the next smaller element is -1 as no element in the array has value smaller than 1.
				2) For ARR [2] = 3 ,  the next smaller element is 2.
				3) For ARR [3] = 2 ,  the next smaller element is -1 as no element exists in the right of it.
				Hence we will return the array [ -1, 2, -1 ] in this case.
				Sample Input 2:
				2
				4
				1 2 3 4
				2
				5 0
				Sample Output 2:
				-1 -1 -1 -1
				0 -1

		// Not Optimized:
			vector<int> nextSmallerElement(vector<int> &arr, int n) {
				vector<int> ans(n, -1);

				for(int i=0; i<n-1; i++){
					for(int j=i+1; j<n; j++){
						if(arr[i] > arr[j]){
							ans[i] = arr[j];
							break;
						}
					}
				}
				return ans;
			}

		// Optimized:
			#include <stack>
			vector<int> nextSmallerElement(vector<int> &arr, int n) {
				vector<int> ans(n);
				stack<int> st;

				for(int i=n-1; i >=0; i--){
					while(!st.empty() && st.top() >= arr[i] )
						st.pop();

					if(st.empty()){
						ans[i] = -1;
					}else{
						ans[i] = st.top();
					}
					st.push(arr[i]);
				}
				return ans;
			}

	Q.2. Largest Rectangle in Histogram:
		Problem Statement:
			Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.	
			Example 1:
				Input: heights = [2,1,5,6,2,3]
				Output: 10
				Explanation: The above is a histogram where width of each bar is 1.
				The largest rectangle is shown in the red area, which has an area = 10 units.

			Example 2:
				Input: heights = [2,4]
				Output: 4
			
			Constraints:
				1 <= heights.length <= 10^5
				0 <= heights[i] <= 10^4

		// Not Optimized:
			class Solution {
				public:
				int largestRectangleArea(vector<int>& heights) {
					int mxArea = 0;

					for(int i=0; i<heights.size(); i++){
						// to left
						int j = i-1, cnt = 1;
						while(j >=0){
							if(heights[j] >= heights[i])
								cnt++;
							else
								break;
							j--;
						}

						// to right
						j = i+1;
						while(j < heights.size()){
							if(heights[j] >= heights[i])
								cnt++;
							else
								break;
							j++;
						}
						int newArea = cnt * heights[i];
						mxArea = max(mxArea, newArea);
					}        
					return mxArea;
				}
			};

		// Optimized:
			class Solution {
				public:
				vector<int> nextSmaller(vector<int> h, int n){
					vector<int> ans(n,-1);
					stack<int> st;

					for(int i=n-1; i>=0; i--){
						while(!st.empty() && h[st.top()] >= h[i])
							st.pop();

						if(!st.empty())
							ans[i] = st.top();
						st.push(i);
					}        
					return ans;
				}
				
				vector<int> prevSmaller(vector<int> h, int n){
					vector<int> ans(n,-1);
					stack<int> st;

					for(int i=0; i<n; i++){
						while(!st.empty() && h[st.top()] >= h[i])
							st.pop();

						if(!st.empty())
							ans[i] = st.top();
						st.push(i);
					}        
					return ans;
				}

				int largestRectangleArea(vector<int>& heights) {
					int mxArea = 0;
					int n = heights.size();

					vector<int> nxt(n,0);
					vector<int> prev(n,0);

					nxt = nextSmaller(heights, n);
					prev = prevSmaller(heights, n);

					for(int i=0; i<heights.size(); i++){
						int l =  heights[i];
						
						if(nxt[i] == -1)
							nxt[i] = n;

						int b = nxt[i] - prev[i] - 1;
						int newArea = l * b;
						mxArea = max(mxArea, newArea);
					}        
					return mxArea;
				}
			};
---------------------------------------------------------------------------------------------------------
	10/05/24
Lecture-57: Stack - Celebrity Problem && Max Rectangle in Binary Matrix with all 1's
	Q.1. The Celebrity Problem:
		Problem Statement:
			A celebrity is a person who is known to all but does not know anyone at a party. If you go to a party of N people, find if there is a celebrity in the party or not.
			A square NxN matrix M[][] is used to represent people at the party such that if an element of row i and column j  is set to 1 it means ith person knows jth person. Here M[i][i] will always be 0.
			Return the index of the celebrity, if there is no celebrity return -1.
			Note: Follow 0 based indexing.
			Follow Up: Can you optimize it to O(N)

			Example 1:
			Input:
			N = 3
			M[][] = {{0 1 0},
				{0 0 0}, 
				{0 1 0}}
			Output: 1
			Explanation: 0th and 2nd person both
			know 1. Therefore, 1 is the celebrity. 

			Example 2:
			Input:
			N = 2
			M[][] = {{0 1},
				{1 0}}
			Output: -1
			Explanation: The two people at the party both
			know each other. None of them is a celebrity.

			Your Task:
				You don't need to read input or print anything. Complete the function celebrity() which takes the matrix M and its size N as input parameters and returns the index of the celebrity. If no such celebrity is present, return -1.


			Expected Time Complexity: O(N^2)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 3000
				0 <= M[][] <= 1

		// Brute Force:
			class Solution  {
				public:
				//Function to find if there is a celebrity in the party or not.
				int celebrity(vector<vector<int>> &M, int n) {
					int rNum = 0;
					
					// or use "&" 'for(auto &rows: M){'  or 
					// don't use "&" sign for(auto rows: M){ or you can use 1D vector<int>.
					// & sign used:- for(vector<int> &rows: M){ 
					// Without & sign:- for(vector<int> &rows: M){ 
					
					int celRow = -1;
					int secCheck = -1, once = 1;
					for(vector<int> &rows: M){                    
						int f = 1;            
						for(int val: rows){                         
							if(val == 1){
								f = 0;
								break;
							}
						}
						
						if(f){
							celRow = rNum;
							if(once){
								secCheck = celRow;
								once =0;
							}
						}
						if(celRow != secCheck)                  // this condition indicates that there are 2 celebrities, so stop here by -1
							return -1;
						rNum++;
					}
					
					if(celRow == -1)
						return -1;
						
					int curRow = 0;
					for(vector<int> &temp: M){
						if(curRow == celRow)
							continue;
						
						if(temp[celRow] != 1)
							return -1;
						curRow++;
					}
					return celRow;
				}
			};

		// Everything stays same just using Vector
			class Solution  {
				public:
				//Function to find if there is a celebrity in the party or not.
				int celebrity(vector<vector<int>> &M, int n) {
					
					int rNum = 0;
					vector<int> CelRow;
					// or use "&" 'for(auto &rows: M){'  or 
					// don't use "&" sign for(auto rows: M){ or you can use 1D vector<int>.
					// & sign used:- for(vector<int> &rows: M){ 
					// Without & sign:- for(vector<int> &rows: M){ 
					
					for(vector<int> &rows: M){                    
						int f = 1;            
						for(int val: rows){                         
							if(val == 1){
								f = 0;
								break;
							}
						}
						
						if(f){
							CelRow.push_back(rNum);
						}
						if(CelRow.size() >= 2)             // this condition indicates that there are 2 celebrities, so stop here by -1
							return -1;
						rNum++;
					}
					
					if(CelRow.size() == 0)
						return -1;
						
					int curRow = 0, val = CelRow[0];
					for(vector<int> &temp: M){
						if(curRow == val)
							continue;
						
						if(temp[val] != 1)
							return -1;
						curRow++;
					}
					return val;
				}
			};

		// Optimized:
			class Solution {
				public:
				//Function to find if there is a celebrity in the party or not.
				int celebrity(vector<vector<int> >& M, int n) {
					stack<int> st;
					
					for(int i=0; i<n; i++)
						st.push(i);
						
					while(st.size() > 1){
						int a = st.top();
						st.pop();
						
						int b = st.top();
						st.pop();
						
						if(M[a][b] == 1)
							st.push(b);
						else
							st.push(a);
					}
					
					// a might be a potential celebrity candidate.
					int z = st.top(), zeroCnt=0;
					int rowCheck = 0;
				
					for(int i=0; i<n; i++)
						if(M[z][i] == 0)
							zeroCnt++;
						
					if(zeroCnt == n)
						rowCheck = 1;               // this means that the complete row contains zeros so might be celebrity
						
					int colCheck = 0, onesCnt=0;			// we can do without using colCheck and rowCheck, if(zeroCnt != n) return -1 & if(onesCnt != n-1) return -1; & at end return z;
					
					// except celebrity all should be one
					for(int i=0; i<n; i++)
						if(M[i][z] == 1)
							onesCnt++;
						
					if(onesCnt == n-1)              // this means that zth col of every row contains 1 except his own
						colCheck = 1;

					if(rowCheck && colCheck)
						return z;
					return -1;
				}
			};

	// HomeWork:
		more approaches exploration ❌Pending

	Q.2. Max rectangle: 
		Problem Statement:
			Given a binary matrix M of size n X m. Find the maximum area of a rectangle formed only of 1s in the given matrix.
			Example 1:
				Input:
				n = 4, m = 4
				M[][] = {{0 1 1 0},
					{1 1 1 1},
					{1 1 1 1},
					{1 1 0 0}}
				Output: 8
				Explanation: For the above test case the
				matrix will look like
				0 1 1 0
				1 1 1 1
				1 1 1 1
				1 1 0 0
				the max size rectangle is 
				1 1 1 1
				1 1 1 1
				and area is 4 *2 = 8.
			Your Task: 
				Your task is to complete the function maxArea which returns the maximum size rectangle area in a binary-sub-matrix with all 1’s. The function takes 3 arguments the first argument is the Matrix M[ ] [ ] and the next two are two integers n and m which denotes the size of the matrix M. 

			Expected Time Complexity : O(n*m)
			Expected Auixiliary Space : O(m)

			Constraints:
				1<=n,m<=1000
				0<=M[][]<=1

		/* TC: O(n*m) & SC: O(m) */
		class Solution{
			public:
			vector<int> nextSmallers (int *arr, int n){
				vector<int> ans (n, n);
				stack<int> st;
				
				for(int i=n-1; i>=0; i--){
					while(!st.empty() && arr[st.top()] >= arr[i]){
						st.pop();
					}
					
					if(!st.empty())
						ans[i] = st.top();
					st.push(i);
				}
				return ans;
			}
			
			vector<int> prevSmallers (int *arr, int n){
				vector<int> ans (n, -1);
				stack<int> st;
				
				for(int i=0; i < n; i++){
					while(!st.empty() && arr[st.top()] >= arr[i]){
						st.pop();
					}
					
					if(!st.empty())
						ans[i] = st.top();
					st.push(i);
				}
				return ans;
			}
			
			int largetAreaFinder(int *arr, int cols){	
				vector<int> nxt;
				vector<int> prev;
				
				nxt = nextSmallers(arr, cols);
				prev = prevSmallers(arr, cols);
				
				int mxArea = 0;
				
				for(int i=0; i<cols; i++){
					mxArea = max(mxArea, ((nxt[i] - prev[i] - 1) * arr[i]));
				}
				return mxArea;
			}
			
			int maxArea(int M[MAX][MAX], int n, int m) {
				if(n == 0 || m == 0)
					return 0;
				
				int Area = largetAreaFinder(M[0], m);
				
				for(int i=1; i<n; i++){
					for(int j=0; j<m; j++){
						// adding previous row's value
						if(M[i][j])                             //if(M[i][j] != 0)
							M[i][j] += M[i-1][j];
						//else
						//    M[i][j] = 0;
					}
					Area = max(Area, largetAreaFinder(M[i], m));
				}
				return Area;
			}
		};
---------------------------------------------------------------------------------------------------------
	12/05/24
Lecture-58: "N" Stacks in an Array || Stack Hard Question ❌Pending
	#include <bits/stdc++.h>
	class NStack {
		int n, s, freespot;
		int *arr, *next, *top;
		public:
		// Initialize your data structure.
		NStack(int N, int S) {
			n = N;
			s = S;
			arr = new int[s];
			next = new int[s];
			top = new int[n];
			freespot = 0;
			// add -1 to all index of top array
			for (int i = 0; i < n; i++)
				top[i] = -1;

			// add next freespace available index in next array
			for (int i = 0; i < s; i++) 
				next[i] = i + 1;

			next[s - 1] = -1;
		}

		// Pushes 'X' into the Mth stack. Returns true if it gets pushed into the
		// stack, and false otherwise.

		bool push(int x, int m) {
			// overflow case
			if (freespot == -1) 
				return false;

			// create a index;
			int index = freespot;

			// update freespot
			freespot = next[index];

			// update arr
			arr[index] = x;

			// update next
			next[index] = top[m - 1];

			// update top
			top[m - 1] = index;

			return true;
		}
		
		// Pops top element from Mth Stack. Returns -1 if the stack is empty,
		// otherwise returns the popped element.

		int pop(int m) {
			if (top[m - 1] == -1)
				return -1;

			int index = top[m - 1];

			top[m - 1] = next[index];
			next[index] = freespot;
			freespot = index;
			return arr[index];
		}
	};
---------------------------------------------------------------------------------------------------------
	13/05/24
Lecture-59: Design Special Stack Problem
	Q.1. Design a stack that supports getMin() in O(1) time and O(1) extra space: (Refer Q.838 from POTD section).
		Problem statement
			Create a stack data structure that allows operations such as push (adding an element), pop (removing the top element), top (retrieving the top element), and also provides a way to retrieve the minimum element in constant time.
			Implement the following public functions :

			1. push(data) :
			This function should take one argument of type integer. It pushes the element into the stack and returns nothing.

			2. pop() :
			It pops the element from the top of the stack and returns nothing.

			3. top() :
			It returns the element being kept at the top of the stack.

			4.  getMin() :
			It returns the smallest element present in the stack.

			Operations Performed on the Stack:
			Query-1(Denoted by an integer 1): Pushes integer data to the stack. (push function)
			Query-2(Denoted by an integer 2): Pops the data kept at the top of the stack. (pop function)
			Query-3(Denoted by an integer 3): Fetches and returns the data being kept at the top of the stack. (top function)
			Query-4(Denoted by an integer 4): Returns the smallest element present in the stack. (getMin() function)

			Sample Input 1:
			6
			1 13
			1 47
			3
			1 8
			2
			4
			Sample Output 1:
			47
			13
			Explanation of Input 1:
			Here we have six queries in total.

			Query 1: Integer 1 represents the push function. Hence we push element ‘13’ onto the stack.
			Query 2: Integer 1 represents the push function. Hence we push element ‘47’ onto the stack.
			Query 3: Integer 3 represents the top function. Hence we print the top element in stack i.e. '47'.
			Query 4: Integer 1 represents the push function. Hence we push element ‘8’ onto the stack.
			Query 5: Integer 2 represents the pop function. The stack contains element ‘8’ at the top. We remove/pop ‘8’ from the stack and we have 13, 47 left in stack.
			Query 6: Integer 4 represents the getMin function. Hence the min of current stack is '13'.

			Sample Input 2:
			8
			1 45
			2
			1 53
			4
			1 46
			4
			2
			4
			Sample Output 2:
			53
			46
			53
			Constraints:
				1 <= 'Q' <= 1000
				1 <= query type <= 4
				-10^9 <= data <= 10^9 and data != -1
			where 'Q' is the total number of queries being performed on the stack and 'data' represents the integer pushed into the stack.
			Operations like pop, top and getMin  will always be called on non-empty stacks.
			Time Limit: 1 sec

		// TC: O(1) But SC: O(n), used extra space
			-Note: no need to handle the case where stack is empty or not, test cases are in such way that they don't request pop query when stack is empty
			class SpecialStack {
				stack<int> st;
				stack<int> minHolder;
				int mini = INT_MAX;

				public:    
				void push(int data) {
					st.push(data);
					mini = min(mini, data);
					minHolder.push(mini);    
				}

				void pop() {
					st.pop();
					minHolder.pop();

					if(minHolder.empty())
						mini = INT_MAX;
					else
						mini = minHolder.top();
				}

				int top() {
					return st.top();
				}

				int getMin() {
					return mini;
				}  
			};

			//or
				class SpecialStack {
					public:
					stack<int> s, minHold;

					void push(int data) {
						s.push(data);
						if(minHold.empty()){
							minHold.push(data);
						}else{
							if(minHold.top() > data)
								minHold.push(data);
							else
								minHold.push(minHold.top());
						}
					}

					void pop() {
						// if(s.empty())
						//     return ;
						minHold.pop();
						s.pop();
					}

					int top() {
						// if(s.empty())
						//     return  -1;
						return s.top();
					}

					int getMin() {
						return minHold.top();
					}  
				};
			
		// or storing just min element into other stack without repeating it
			class SpecialStack {
				public:
				stack<int> s1, s2;

				void push(int data) {
					if(s1.empty()){
						s2.push(data);
					}else{
						if(s2.top() >= data){
							s2.push(data);
						}
					}
					s1.push(data);
				}

				void pop() {
					if(s1.top() == s2.top())
						s2.pop();
					s1.pop();
				}

				int top() {
					return s1.top();
				}

				int getMin() {
					return s2.top();   
				}
			};

		// TC: O(1) & SC: O(1) ❌Pending
			class SpecialStack {
				public:
				int mini ;
				stack<int> s;

				void push(int data) {
					if(s.empty()){
						mini = data;
						s.push(data);
					}else{
						if(data < mini){
							s.push(2*data - mini);
							mini = data;
						}else{
							s.push(data);
						}
					}
				}

				void pop() {    

					int cur = s.top();
					if(cur < mini)
						mini = 2*mini - cur;

					s.pop();
				}

				int top() {
					if(s.top()  < mini)
						return mini;
					return s.top();
					
				}

				int getMin() {
					return mini;
				}  
			};
				
	#HomeWork: ❌Pending
		Go through 450 DSA LoveBabbar Sheet 
---------------------------------------------------------------------------------------------------------
	16/05/2024
Lecture-60: Queues in C++ [STL + Implementation + Types of Queues]
	Queue:
		Queues are a type of container adaptors that operate in a first in first out (FIFO) type of arrangement. Elements are inserted at the back (end) and are deleted from the front. Queues use an encapsulated object of deque or list (sequential container class) as its underlying container, providing a specific set of member functions to access its elements.
		The time complexity and definition of the following functions are as follows:
		queue::empty()			O(1)
		queue::size()			O(1)
		queue::emplace()		O(1)
		queue::front()			O(1)
		queue::back()			O(1)
		queue::push(g) 		O(1)
		queue::pop() 			O(1)

		Method						Definition
		queue::empty()			Returns whether the queue is empty. It return true if the queue is empty otherwise returns false.
		queue::size()			Returns the size of the queue.
		queue::swap()			Exchange the contents of two queues but the queues must be of the same data type, although sizes may differ.
		queue::emplace()		Insert a new element into the queue container, the new element is added to the end of the queue.
		queue::front()			Returns a reference to the first element of the queue.
		queue::back()			Returns a reference to the last element of the queue.
		queue::push(g) 		Adds the element ‘g’ at the end of the queue.
		queue::pop() 			Deletes the first element of the queue.

	Note:
		push() adds a copy of an already constructed object into the queue as a parameter, it takes an object of the queue's element type.
		eg.
			queue<int> q;
			int val = 10;
			q.push(val);

		emplace() constructs a new object in-place at the end of the queue. It takes as parameters the parameters that the queue's element types constructor takes.
			q.emplace(10);
		
		eg.
			#include <iostream>
			#include<queue>
			using namespace std;

			int main() {
				queue<int> q;
				q.push(10);
				q.emplace(89);
				
				queue<pair<int, char>> qc;
				
				qc.push({10,'c'});                   // we can't push like this qc.push(1, 'c'), need to use emplace method here
				qc.push(make_pair(20, 'b'));
				qc.emplace(1,'A');
				
				while(!q.empty()){
					std::cout << q.front() << "\t";
					q.pop();
				}
				
				std::cout << std::endl;
				while(!qc.empty()){
					std::cout << qc.front().first << "\t" << qc.front().second << endl;
					qc.pop();
				}	
				return 0;
			}

	Example:
		#include <iostream>
		#include<queue>
		using namespace std;
		int main() {
			queue<int> q;
			
			// empty method
			std::cout << "is empty? " <<boolalpha<< q.empty() << std::endl;
			
			// inserting element using push
			q.push(10);
			q.push(90);
			
			// using emplace
			q.emplace(20);
			q.emplace(40);
			q.emplace(30);
			
			std::cout << "is empty? " <<boolalpha<< q.empty() << std::endl;
			
			// accessing the first element of queue
			std::cout << "first/ Front : "<< q.front() << std::endl;
			
			int poped = q.front();
			
			// deleting front element of queue
			q.pop();
			std::cout << "Deleted element : " << poped << std::endl;
			std::cout << "After deleting, first/ Front : "<< q.front() << std::endl;
			
			// accessing the last element of queue
			std::cout << "Last/ end : "<< q.back() << std::endl;
			
			// total element in queue or size of queue
			std::cout << "Size :" << q.size() << std::endl;
			
			// content of queue
			while(!q.empty()){
				std::cout << q.front() << "\t";
				q.pop();
			}
			std::cout << std::endl;
			
			queue<int> q1;
			std::cout << "is empty? q & q1 " <<boolalpha<< q.empty() << "\t" << q1.empty() << std::endl;
			
			q1.push(11);
			q1.push(12);
			q1.push(13);
			q1.push(14);
			std::cout << "is empty? q & q1 " <<boolalpha<< q.empty() << "\t" << q1.empty() << std::endl;
			
			// copying to q
			q = q1;
			std::cout << "is empty? q & q1 " <<boolalpha<< q.empty() << "\t" << q1.empty() << std::endl;
			
			// you can see both queue q & q1 have the contents in it
			// printing the contents of q & q1 queues
			
			std::cout << "Contents of Q : " << std::endl;
			while(!q.empty()){
				std::cout << q.front() << std::endl;
				q.pop();
			}
			
			std::cout << std::endl;
			std::cout << "Contents of Q1 : " << std::endl;
			while(!q1.empty()){
				std::cout << q1.front() << std::endl;
				q1.pop();
			}
			
			// now both queues will be empty
			std::cout << "is empty? q & q1 " <<boolalpha<< q.empty() << "\t" << q1.empty() << std::endl;
			return 0;
		}

	swap:
		#include <iostream>
		#include<queue>
		using namespace std;
		int main() {
			queue<int> q;
			std::cout << "Q :" <<  q.empty() << std::endl;
			
			q.push(1);
			q.push(2);
			q.push(3);
			
			// here q contains some values, if you want to clear complete queue you can pop one by one elements
			// or you can use swap function
			std::cout << "Q :" <<  q.empty() << std::endl;
			
			queue<int> newQ;
			std::cout << "newQ : " << newQ.empty() << std::endl;

			swap(newQ, q);              // now q is completely cleared, in queue we don't have .clear() method to delete all elements in queue.
			
			std::cout << "newQ : " << newQ.empty() << std::endl;
			std::cout << "Q :" <<  q.empty() << std::endl;
			return 0;
		}
	
	Queue Implementation Using LinkedList:
		❌Pending
	
	#Types of Queues:
		1.Input Restricted Queue (this is a Simple Queue)
		2.Output Restricted Queue (this is also a Simple Queue)
		3.Circular Queue
		4.Double Ended Queue (Deque)
		5.Priority Queue
		 a) Ascending Priority Queue
		 b) Descending Priority Queue

	Q.1. Implement a Queue:
		Problem statement
			Implement a Queue Data Structure specifically to store integer data using a Singly Linked List or an array.
			You need to implement the following public functions :
			1. Constructor: It initializes the data members as required.
			2. enqueue(data): This function should take one argument of type integer. It enqueues the element into the queue.
			3. dequeue(): It dequeues/removes the element from the front of the queue and in turn, returns the element being dequeued or removed. In case the queue is empty, it returns -1.
			4. front(): It returns the element being kept at the front of the queue. In case the queue is empty, it returns -1.
			5. isEmpty(): It returns a boolean value indicating whether the queue is empty or not.
			Operations Performed on the Queue :
			Query-1(Denoted by an integer 1): Enqueues integer data to the queue.
			Query-2(Denoted by an integer 2): Dequeues the data kept at the front of the queue and returns it to the caller, return -1 if no element is present in the queue.
			Query-3(Denoted by an integer 3): Fetches and returns the data being kept at the front of the queue but doesn't remove it, unlike the dequeue function, return -1 if no element is present in the queue.
			Query-4(Denoted by an integer 4): Returns a boolean value denoting whether the queue is empty or not.
			Constraints :
				1 <= t <= 5
				1 <= q <= 5000
				1 <= x <= 4
				1 <= data <= 2^31 - 1
				Time Limit: 1 sec

				Sample Input 1 :
				1
				7
				1 17
				1 23
				1 11
				2
				2
				2
				2
				Sample Output 1 :
				17
				23
				11
				-1
				Explanation for Sample Output 1 :
				The first three queries are of enQueue, so we will push 17, 23, and 11 into the queue.

				The next four queries are of deQueue, so we will starting removing elements from the queue, so the first element will be 17, then 23, and then 11. And after the third dequeue query, the queue is now empty so for the fourth query, we will return -1.
				Sample Input 2 :
				1
				3
				2
				1 10
				3
				Sample Output 2 :
				-1 
				10

		// Using array:
			#include <bits/stdc++.h> 
			class Queue {
				int *arr;
				int frnt, rear, size;
				
				public:
				Queue() {
					size = 1e8;
					arr = new int[size];
					frnt = rear = 0;
				}

				/*----------------- Public Functions of Queue -----------------*/

				bool isEmpty() {
					if(frnt == rear)
						return true;
					return 0;
				}

				void enqueue(int data) {
					if(rear == size){
						return ;
					}
					arr[rear++] = data;
				}

				int dequeue() {
					if(frnt == rear)
						return -1;

					int val = arr[frnt];
					arr[frnt++] = -1;
					if(frnt == rear){
						frnt = 0;
						rear = 0;
					}
					return val;
				}

				int front() {
					if(frnt == rear)
						return -1;
					
					return arr[frnt];
				}
			};
	
		// Using Linked List: (class)
			#include <bits/stdc++.h> 
			class Node{
				public:
				int val;
				Node* next =nullptr;
					Node(int val){
						this ->  val = val;
					}
					~Node(){
						delete next;
					}
			};

			// Using LinkedList: (struct)
			/*
				struct Node{
					// public:				// optional
					int val;
					Node* next =nullptr;

					Node(int val){
						this ->  val = val;
					}

					~Node(){
						delete next;
					}
				};
			*/

			class Queue {
				Node* H = NULL;
				Node* T = NULL;
				public:
				Queue() {
					// Implement the Constructor
				}

				/*----------------- Public Functions of Queue -----------------*/

				bool isEmpty() {
					if(!H)
						return 1;
					return 0;
				}

				void enqueue(int data) {
					Node* nn = new Node(data);
					if(!H){
						H = nn;
						T = nn;
					}else{
						T -> next = nn;
						T = nn;
					}
				}

				int dequeue() {
					if(!H)
						return -1;
					Node* temp = H;
					H = H -> next;

					if(!H){
						T = NULL;
					}

					int val = temp -> val;
					temp -> next = NULL;

					delete temp;
					return val;
				}

				int front() {
					if(!H)
						return  -1;
					return H -> val;
				}
			};
	
	3) Cicular Queue:
		A Circular Queue is an extended version of a normal queue where the last element of the queue is connected to the first element of the queue forming a circle.
		The operations are performed based on FIFO (First In First Out) principle. It is also called ‘Ring Buffer’. 

		Complexity Analysis of Circular Queue Operations:
		Time Complexity: 
			Enqueue: O(1) because no loop is involved for a single enqueue.
			Dequeue: O(1) because no loop is involved for one dequeue operation.
			Auxiliary Space: O(N) as the queue is of size N.
		Applications of Circular Queue:
			Memory Management: The unused memory locations in the case of ordinary queues can be utilized in circular queues.
			Traffic system: In computer controlled traffic system, circular queues are used to switch on the traffic lights one by one repeatedly as per the time set.
			CPU Scheduling: Operating systems often maintain a queue of processes that are ready to execute or that are waiting for a particular event to occur.

	Q.2. Circular Queue:
		Problem statement
			You will be given ‘Q’ queries. You need to implement a circular queue according to those queries. Each query will belong to one of these two types
			1 ‘X’: Enqueue element ‘X’ into the end of the nth queue. Returns true if the element is enqueued, otherwise false.
			2: Dequeue the element at the front of the nth queue. Returns -1 if the queue is empty, otherwise, returns the dequeued element.
			Note:
			Enqueue means adding an element to the end of the queue, while Dequeue means removing the element from the front of the queue.
			Constraints:
				1 <= N <= 1000
				1 <= Q <= 10^5 
				1 <= P <= 2
				1 <= X <= 10^5
				Time limit: 1 sec
			Sample Input 1:
				3 7
				1 2 
				1 3 
				2 
				1 4 
				1 6 
				1 7 
				2
				Sample Output 1:
				True 
				True
				2
				True
				True
				False
				3
				Explanation of Sample Output 1:
				For this input, we have the size of the queue, 'N' = 3, and the number of queries, 'Q' = 7.

				Operations performed on the queue are as follows:

				push(2): Push element ‘2’ into the queue. This returns true.
				push(3): Push element ‘3’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 2.
				push(4): Push element ‘4’ into the queue. This returns true.
				push(6): Push element ‘6’ into the queue. This returns true.
				push(7): Push element ‘7’ into the queue. This returns false because the queue is full.
				pop(): Pop the top element from the queue. This returns 3.
				Sample Input 2:
				4 7
				1 11 
				1 51 
				1 26 
				2 
				1 6
				2
				2 
				Sample Output 2:
				True
				True
				True
				11
				True
				51
				26
				Explanation for Sample Output 2:
				For this input, we have the size of the queue, 'N' = 3, and the number of queries, 'Q' = 7.

				Operations performed on the queue are as follows:

				push(11): Push element ‘11’ into the queue. This returns true.
				push(51): Push element ‘51’ into the queue. This returns true.
				push(26): Push element ‘26’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 11.
				push(6): Push element ‘6’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 51.
				pop(): Pop the top element from the queue. This returns 26.
		
		// Using Array:
			#include <bits/stdc++.h> 
			class CircularQueue{
				int *arr;
				int size;
				int frnt, rear;

				public:
				CircularQueue(int n){
					size = n;
					arr = new int[n];
					frnt = rear = -1;
				}

				// Enqueues 'X' into the queue. Returns true if it gets pushed into the stack, and false otherwise.
				bool enqueue(int value){
					if((frnt == 0 && rear == size - 1) || (rear == (frnt-1))) {
						return false;
					}else if(frnt == -1){
						frnt = rear = 0;
					}else if(rear == size -1 && frnt != 0){
						rear =0;
					}else{
						rear++;
					}
					arr[rear] = value;
					return 1;
				} 

				// Dequeues top element from queue. Returns -1 if the stack is empty, otherwise returns the popped element.
				int dequeue(){
					if(frnt == -1)
						return -1;
						
					int ans = arr[frnt];
					arr[frnt] = -1;
					if(frnt == rear)
						frnt = rear = -1;
					else if(frnt == size-1)
						frnt =0;
					else
						frnt++;
					return ans;
				}
			};

		// Using LinkedList:
			#include <bits/stdc++.h> 
			struct Node{
				int data;
				Node *nxt = NULL;
				Node(int val){
					data = val;
				}

				~Node() {
					delete nxt;
				}
			};
			class CircularQueue{
				int cnt, size;
				Node* Head = NULL;
				Node* Tail = NULL;

				public:
				CircularQueue(int n){
					size = n;
					cnt = 0;
				}

				// Enqueues 'X' into the queue. Returns true if it gets pushed into the stack, and false otherwise.
				bool enqueue(int value){
					if(cnt == size)         // this indicates the circular queue is full
						return false;
					
					Node* nn = new Node(value);
					if(Head == NULL){            // this indicates that first element came
						Head = nn;
						Tail = nn;
					}else{
						Tail -> nxt = nn;
						Tail = nn;
					}
					cnt++;
					return 1;
				}

				// Dequeues top element from queue. Returns -1 if the stack is empty, otherwise returns the popped element.
				int dequeue(){
					if(cnt == 0)         // this indicates the circular queue is empty
						return -1;

					int val = Head ->data;
					Head = Head -> nxt;
					cnt--;
					return val;
				}
			};

	1) Input Restricted Queue:
		In this type of Queue, the input can be taken from one side only(rear) and deletion of elements can be done from both sides(front and rear). This kind of Queue does not follow FIFO(first in first out).

	2) Output Restricted Queue:
		In this type of Queue, the input can be taken from both sides(rear and front) and the deletion of the element can be done from only one side(front).  This queue is used in the case where the inputs have some priority order to be executed and the input can be placed even in the first place so that it is executed first. 

	4) Double Ended Queue:
		Double Ended Queue is also a Queue data structure in which the insertion and deletion operations are performed at both the ends (front and rear). 
		That means, we can insert at both front and rear positions and can delete from both front and rear positions.
		Since Deque supports both stack and queue operations, it can be used as both. 
		The Deque data structure supports clockwise and anticlockwise rotations in O(1) time which can be useful in certain applications.
		Also, the problems where elements need to be removed and or added both ends can be efficiently solved using Deque.
		- insert at both start and end
		- delete from both start & end
		- Used in CPU/ Process Scheduling
		eg.
			#include <iostream>
			#include <deque>
			using namespace std;
			int main() {
				
				std::deque<int> d;
				std::cout << d.empty() << std::endl;
				
				d.push_front(1);
				d.push_front(2);
				
				d.push_back(4);
				d.push_back(5);
				
				std::cout << d.empty() << std::endl;
				std::cout <<"current front : " << d.front() << std::endl;
				std::cout <<"current back : " << d.back() << std::endl;
				return 0;
			}

	Q.3. Implement Deque:
		Problem statement
			Design a data structure to implement deque of size ‘N’. It should support the following operations:
			pushFront(X): Inserts an element X in the front of the deque. Returns true if the element is inserted, otherwise false.
			pushRear(X): Inserts an element X in the back of the deque. Returns true if the element is inserted, otherwise false.
			popFront(): Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
			popRear(): Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
			getFront(): Returns the first element of the deque. If the deque is empty, it returns -1.
			getRear(): Returns the last element of the deque. If the deque is empty, it returns -1.
			isEmpty(): Returns true if the deque is empty, otherwise false.
			isFull(): Returns true if the deque is full, otherwise false.
			Following types of queries denote these operations:

			Type 1: for pushFront(X) operation.
			Type 2: for pushRear(X) operation.
			Type 3: for popFront() operation.
			Type 4: for popRear() operation.
			Type 5: for getFront() operation.
			Type 6: for getRear() operation.
			Type 7: for isEmpty() operation.
			Type 8: for isFull() operation.
			Constraints:
				1 <= N <= 1000
				1 <= Q <= 10^5 
				1 <= P <= 8
				1 <= X <= 10^5
				Time Limit: 1 sec

				Where ‘N’ represents the size of the deque, ‘Q’ represents the number of queries, ‘P’ represents the type of operation and ‘X’ represents the element.
			Sample Input 1:
				5 7
				7
				1 10
				1 20
				2 30
				5
				4
				4
				Sample Output 1:
				True 
				True 
				True
				True
				20
				30
				10
				Explanation 1:
				For the given input, we have the number of queries, Q = 7.
				Operations performed on the deque are as follows:

				isEmpty(): Deque is initially empty. So, this returns true.
				pushFront(10): Insert the element ‘10’ in the front of the deque. This returns true.
				pushFront(20): Insert the element ‘20’ in the front of the deque. This returns true.
				pushRear(30): Insert the element ‘30’ in the back of the deque. This returns true.
				getFront(): Returns the front element of the deque i.e. 20
				popRear(): Pop an element from the back of the deque. This returns 30.
				popRear(): Pop an element from the back of the deque. This returns 10.
				The following image shows the snapshots of the deque after each operation:

				Sample Input 2:
				2 5
				1 15
				2 25
				1 20
				8
				6
				Sample Output 2:
				True
				True
				False
				True
				25

		// Using Array:
			#include <bits/stdc++.h>
			class Deque {
				int *arr;
				int size;
				int frnt, rear;

				public:
				// Initialize your data structure.
				Deque(int n) {
					size = n;
					arr = new int[n];
					frnt = rear = -1;
				}

				// Pushes 'X' in the front of the deque. Returns true if it gets pushed into
				// the deque, and false otherwise.
				bool pushFront(int x) {
					if ((frnt == 0 && rear == size - 1) || (rear == (frnt - 1)))				// if(isFull())
						return 0;

					if (frnt == -1) {
						frnt = rear = 0;
					} else if (frnt == 0 && rear != size - 1) {
						frnt = size - 1;
					} else {
						frnt--;
					}
					arr[frnt] = x;
					return 1;
				}

				// Pushes 'X' in the back of the deque. Returns true if it gets pushed into
				// the deque, and false otherwise.
				bool pushRear(int x) {
					if ((frnt == 0 && rear == size - 1) || (rear == (frnt - 1)))					// if(isFull())
						return 0;

					if (frnt == -1) {
						frnt = rear = 0;
					} else if (rear == size - 1 && frnt != 0) {
						rear = 0;
					} else {
						rear++;
					}
					arr[rear] = x;
					return 1;
				}

				// Pops an element from the front of the deque. Returns -1 if the deque is
				// empty, otherwise returns the popped element.
				int popFront() {
					if (frnt == -1)								// if(isEmpty())
						return -1;

					int val = arr[frnt];
					if (frnt == rear)
						frnt = rear = -1;
					else if (frnt == size - 1)
						frnt = 0;
					else
						frnt++;

					return val;
				}

				// Pops an element from the back of the deque. Returns -1 if the deque is
				// empty, otherwise returns the popped element.
				int popRear() {
					if (frnt == -1)				// if(isEmpty())
						return -1;

					int val = arr[rear];
					if (frnt == rear)
						frnt = rear = -1;
					else if (rear == 0)
						rear = size - 1;
					else
						rear--;

					return val;
				}

				// Returns the first element of the deque. If the deque is empty, it returns
				// -1.
				int getFront() {
					if (frnt == -1)					//if(isEmpty())
						return -1;
					return arr[frnt];
				}

				// Returns the last element of the deque. If the deque is empty, it returns
				// -1.
				int getRear() {
					if (frnt == -1)					//if(isEmpty())
						return -1;
					return arr[rear];
				}

				// Returns true if the deque is empty. Otherwise returns false.
				bool isEmpty() {
					if (frnt == -1)
						return 1;
					return 0;
				}

				// Returns true if the deque is full. Otherwise returns false.
				bool isFull() {
					if ((frnt == 0 && rear == size - 1) || (rear == (frnt - 1)))
						return 1;
					return 0;
				}
			};

		// Using LinkedList:
			#include <bits/stdc++.h>
			class Node{
				public:
					int data;
					Node *nxt = NULL;
					Node *prev = NULL;
					
				Node(int val){
					data = val;
				}

				~Node(){
					delete nxt;
					delete prev;
				}
			};

			class Deque {
				int size, cnt=0;
				Node *H = NULL;
				Node *T = NULL;

				public:
				Deque(int n) {
					size = n;
				}

				// Pushes 'X' in the front of the deque. Returns true if it gets pushed into
				// the deque, and false otherwise.
				bool pushFront(int x) {
					if(isFull())
						return false;

					cnt++;
					Node *nn = new Node(x);

					if(H == NULL){
						H = nn;
						T = nn;
					}else{
						H -> prev = nn;
						nn -> nxt = H;

						H = nn;
					}
					return true;    
				}

				// Pushes 'X' in the back of the deque. Returns true if it gets pushed into
				// the deque, and false otherwise.
				bool pushRear(int x) {
					if(isFull())
						return false;

					cnt++;
					Node *nn = new Node(x);

					if(H == NULL){
						H = nn;
						T = nn;
					}else{
						T -> nxt = nn;
						nn -> prev = T;

						T = nn;
					}
					return true;
				}

				// Pops an element from the front of the deque. Returns -1 if the deque is
				// empty, otherwise returns the popped element.
				int popFront() {
					if(isEmpty())
						return -1;

					cnt--;
					int val = H -> data;
					Node *tmp = H;
					H = H -> nxt;

					tmp -> nxt = NULL;
					tmp -> prev = NULL;
					delete tmp;
					
					return val;
				}

				// Pops an element from the back of the deque. Returns -1 if the deque is
				// empty, otherwise returns the popped element.
				int popRear() {
					if(isEmpty())
						return -1;

					cnt--;
					int val = T -> data;
					Node *tmp = T;
					T = T -> prev;

					if(cnt == 0){
						H = NULL;
						T = nullptr;
					}

					tmp -> nxt = NULL;
					tmp -> prev = NULL;
					delete tmp;

					return val;
				}

				// Returns the first element of the deque. If the deque is empty, it returns
				// -1.
				int getFront() {
					if(isEmpty())
						return -1;
					return H -> data;
				}

				// Returns the last element of the deque. If the deque is empty, it returns
				// -1.
				int getRear() {
					if(isEmpty())
						return -1;
					return T -> data;
				}

				// Returns true if the deque is empty. Otherwise returns false.
				bool isEmpty() {
					if(cnt == 0)                        // if(H == NULL)
						return 1;
					return 0;
				}

				// Returns true if the deque is full. Otherwise returns false.
				bool isFull() {
					if(cnt == size)
						return 1;
					return 0;
				}
			};
---------------------------------------------------------------------------------------------------------
	28/05/24
Lecture-61: Queue FAANG Interview Questions
	Q.1. Queue Reversal:
		Problem Statement:
			Given a Queue Q containing N elements. The task is to reverse the Queue. Your task is to complete the function rev(), that reverses the N elements of the queue.

			Example 1:
			Input:
			6
			4 3 1 10 2 6
			Output: 
			6 2 10 1 3 4
			Explanation: 
			After reversing the given elements of the queue , the resultant queue will be 6 2 10 1 3 4.

			Example 2:
			Input:
			4
			4 3 2 1 
			Output: 
			1 2 3 4
			Explanation: 
			After reversing the given elements of the queue , the resultant queue will be 1 2 3 4.
			Your Task: You need to complete the function rev that takes a queue as parameter and returns the reversed queue. The printing is done automatically by the driver code.

			Expected Time Complexity : O(n)
			Expected Auxilliary Space : O(n)

			Constraints:
				1 ≤ N ≤ 10^5
				1 ≤ elements of Queue ≤ 10^5

		class Solution {
			public:
			queue<int> rev(queue<int> q) {
				stack<int> st;
				
				while(!q.empty()){
					st.push(q.front());
					q.pop();
				}
				
				while(!st.empty()){
					q.push(st.top());
					st.pop();
				}
				return q;
			}
		};
	
	Q.2. First negative integer in every window of size k:
		Problem Statement:
			Given an array A[] of size N and a positive integer K, find the first negative integer for each and every window(contiguous subarray) of size K.
			Example 1:
			Input : 
			N = 5
			A[] = {-8, 2, 3, -6, 10}
			K = 2
			Output : 
			-8 0 -6 -6
			Explanation :
			First negative integer for each window of size k
			{-8, 2} = -8
			{2, 3} = 0 (does not contain a negative integer)
			{3, -6} = -6
			{-6, 10} = -6
			
			Example 2:
			Input : 
			N = 8
			A[] = {12, -1, -7, 8, -15, 30, 16, 28}
			K = 3
			Output :
			-1 -1 -7 -15 -15 0 	

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function printFirstNegativeInteger() which takes the array A[], its size N and an integer K as inputs and returns the first negative number in every window of size K starting from the first till the end. If a window does not contain a negative integer , then return 0 for that window.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(K)

			Constraints:
				1 <= N <= 10^5
				-10^5 <= A[i] <= 10^5
				1 <= K <= N
			
		// Not Optimized:
			long long checkFirstNegative(long long int A[], int s, int e){
				for(int i=s; i <= e; i++)
					if(A[i] < 0)
						return A[i];
				return 0;
			}

			vector<long long> printFirstNegativeInteger(long long int A[], long long int N, long long int K) {
				vector<long long> ans;
				
				for(int i=0; i <= N-K; i++){
					long long int firstNeg = checkFirstNegative(A, i, i+K-1);
					ans.push_back(firstNeg);
				}
				return ans;
			}

		// Optimized: Using Deque
			vector<long long> printFirstNegativeInteger(long long int A[], long long int N, long long int K) {
				vector<long long> ans;
				deque<long long int> dq;
				
				// window of size K
				for(int i=0; i<K; i++)
					if(A[i] < 0)
						dq.push_back(i);
				
				if(dq.size()) {          // not empty then
					ans.push_back(A[dq.front()]);
				}else{
					ans.push_back(0);
				}
				
				for(int i=K; i<N; i++){
					if(!dq.empty() && (i - dq.front()) >= K)
						dq.pop_front();
					
					if(A[i] < 0)
						dq.push_back(i);
					
					if(dq.size()) {          // not empty then
						ans.push_back(A[dq.front()]);
					}else{
						ans.push_back(0);
					}
				}
				return ans;
			}

		// Optimized: Using Queue
			vector<long long> printFirstNegativeInteger(long long int A[], long long int N, long long int K) {
			vector<long long> ans;
			queue<int> q;
			
			for(int i=0; i<K; i++)
				if(A[i] < 0)
					q.push(i);
			
			if(q.size())
				ans.push_back(A[q.front()]);
			else
				ans.push_back(0);
			
			for(int i=K; i<N; i++){
				if(!q.empty() && i - q.front() >= K)
					q.pop();
					
				if(A[i] < 0)
					q.push(i);
				
				if(q.size())
					ans.push_back(A[q.front()]);
				else
					ans.push_back(0);
			}    
			
			return ans;
			}

		// More Optimized:
			❌Pending (HomeWork)
	
	Q.3. Reverse First K elements of Queue (Refer Q.173 & Q.280 from POTD)
	
	Q.4. First non-repeating character in a stream:
		Problem Statement:
			Given an input stream A of n characters consisting only of lower case alphabets. While reading characters from the stream, you have to tell which character has appeared only once in the stream upto that point. If there are many characters that have appeared only once, you have to tell which one of them was the first one to appear. If there is no such character then append '#' to the answer.
			NOTE:
			1. You need to find the answer for every i (0 <= i < n)
			2. In order to find the solution for every i you need to consider the string from starting position till ith position.
			
			Example 1:
				Input: A = "aabc"
				Output: "a#bb"
				Explanation: For every ith character we will
				consider the string from index 0 till index i first non
				repeating character is as follow-
				"a" - first non-repeating character is 'a'
				"aa" - no non-repeating character so '#'
				"aab" - first non-repeating character is 'b'
				"aabc" - there are two non repeating characters 'b' and 'c', 
				first non-repeating character is 'b' because 'b' comes before
				'c' in the stream.

			Example 2:
				Input: A = "zz"
				Output: "z#"
				Explanation: For every character first non
				repeating character is as follow-
				"z" - first non-repeating character is 'z'
				"zz" - no non-repeating character so '#'

			Your Task:
				You don't need to read or print anything. Your task is to complete the function FirstNonRepeating() which takes A as input parameter and returns a string after processing the input stream.			

			Expected Time Complexity: O(n)
			Expected Space Complexity: O(n)
			
			Constraints:
			1 <= n <= 10^5
		
		// Not Optimized:
			/* TC: O(n³)  & SC: O(n) */
			class Solution {
				public:
				string FirstNonRepeating(string A){
					string ans(A.size(), '#');
					ans[0] = A[0];
					
					set<char> temp;
					for(int i=1; i<A.size(); i++){
						char ch = '#';
						set<char> hold;
						
						// search window
						for(int x=0; x<i; x++){
							int flag = 1;
							for(int y=x+1; y<=i; y++){
								if(A[x] == A[y]){
									hold.insert(A[x]);
									flag =0;
									break;
								}
							}
							if(flag && hold.find(A[x]) == hold.end()){
								ch = A[x];
								break;
							}
							temp = hold;
						}
						
						if(ch == '#' && temp.find(A[i]) == temp.end())
							ch = A[i];
						
						temp.clear();
						ans[i] = ch;
					}
					return ans;
				}
			};

		// Optimized:
			class Solution {
				public:
				string FirstNonRepeating(string A){
					string ans;
					
					map<char, int> mp;
					queue<int> q;
					
					for(int i=0; i<A.size(); i++){
						char ch =A[i];
						
						mp[ch]++;
						q.push(ch);
						
						while(!q.empty()){
							if(mp[q.front()] > 1){
								q.pop();
							}else{
								ans.push_back(q.front());
								break;
							}
						}
						
						if(q.empty())
							ans.push_back('#');
					}
					return ans;
				}
			};

	Q.5. Circular tour:
		Problem Statement:
			Suppose there is a circle. There are N petrol pumps on that circle. You will be given two sets of data.
			1. The amount of petrol that every petrol pump has.
			2. Distance from that petrol pump to the next petrol pump.
			Find a starting point where the truck can start to get through the complete circle without exhausting its petrol in between.
			Note :  Assume for 1 litre petrol, the truck can go 1 unit of distance.

			Example 1:
				Input:
				N = 4
				Petrol = 4 6 7 4
				Distance = 6 5 3 5
				Output: 1
				Explanation: There are 4 petrol pumps with
				amount of petrol and distance to next
				petrol pump value pairs as {4, 6}, {6, 5},
				{7, 3} and {4, 5}. The first point from
				where truck can make a circular tour is
				2nd petrol pump. Output in this case is 1
				(index of 2nd petrol pump).

			Your Task:
				Your task is to complete the function tour() which takes the required data as inputs and returns an integer denoting a point from where a truck will be able to complete the circle (The truck will stop at each petrol pump and it has infinite capacity). If there exists multiple such starting points, then the function must return the first one out of those. (return -1 otherwise)

			Expected Time Complexity: O(N)
			Expected Auxiliary Space : O(1)

			Constraints:
				2 ≤ N ≤ 10000
				1 ≤ petrol, distance ≤ 1000

		// Not Optimized:
			/*
				The structure of petrolPump is 
				struct petrolPump {
					int petrol;
					int distance;
				};
			*/

			/*You are required to complete this method*/
			class Solution{
				public:
				//Function to find starting point where the truck can start to get through
				//the complete circle without exhausting its petrol in between.
				int tour(petrolPump p[],int n) {
					int ans = -1;
					for(int i=0; i<n; i++){
						if((p[i].petrol - p[i].distance) < 0)
							continue;
						
						int petrolLeft = p[i].petrol - p[i].distance;
						int flag = 1, j = i+1, times = 1;
						
						while(1 && times < n){
							if(j == n)
								j = 0;
							
							times++;
							petrolLeft += (p[j].petrol - p[j].distance);
							if(petrolLeft < 0){
								flag =0;
								break;
							}
							j++;   
						}
						
						if(flag){
							ans = i;
							break;
						}
					}
					return ans;
				}
			};

		// Optimized:
			class Solution{
				public:
				int tour(petrolPump p[],int n) {
					int balance = 0, deficiency = 0;
					int start =0;
					
					for(int i=0; i<n; i++){
						balance += p[i].petrol - p[i].distance;
						if(balance < 0){
							deficiency += balance;
							balance =0;
							start = i+1;
						}
					}
					
					if((deficiency + balance) >=0)
						return start;
					else
						return -1;
				}
			};

	Q.6. Interleave the First Half of the Queue with Second Half:
		Problem Statement:
			You are given a queue Q of N integers of even length, rearrange the elements by interleaving the first half of the queue with the second half of the queue.

			Example 1:
			Input:
			N = 4
			Q = {2,4,3,1}
			Output:
			{2,3,4,1}
			Explanation:
			After the mentioned rearrangement of the first half
			and second half, our final queue will be {2,3,4,1}.
			

			Example 2:
			Input:
			N = 2
			Q = {3,5}
			Output:
			{3,5}
			Explanation:
			After the mentioned rearrangement of the first half
			and second half, our final queue will be {3,5}.
			

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function rearrangeQueue() which takes a queue Q as input and returns the modified queue after the rearrangement.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				2 <= N <= 10^5
				N is even
				1 <= Elements of Queue <= 10^3
				Sum of N over all test cases doesn't exceeds 10^6

		// Using temporary vector
		class Solution{
			public:
			vector<int> rearrangeQueue(queue<int> &q){
				vector<int> ans, temp;
				
				while(!q.empty()){
					temp.push_back(q.front());
					q.pop();
				}
				
				int i=0, n = temp.size(), j = n/2;
				int f = 1;
				while(j < n){
					if(f)
						ans.push_back(temp[i++]), f = 0;
					else
						ans.push_back(temp[j++]), f = 1;
					
					// (f) ? (ans.push_back(temp[i++]), f = 0) : (ans.push_back(temp[j++]), f = 1);

				}
				
				return ans;
			}
		};

		// or Using temporary Queue
		class Solution{
			public:
			vector<int> rearrangeQueue(queue<int> &q){
				vector<int> ans;
				queue<int> temp;
				int val = q.size() / 2;
				
				while(val--){
					temp.push(q.front());
					q.pop();
				}
				
				int f = 1;
				while(!q.empty())
					(f) ? (ans.push_back(temp.front()), temp.pop(), f = 0) : (ans.push_back(q.front()), q.pop(), f = 1);

				return ans;
			}
		};

		// Using stack
			class Solution{
				public:
				vector<int> rearrangeQueue(queue<int> &q){
					stack<int> st;
					
					int val = q.size()/2;
					int temp = val;
					
					while(temp--){
						st.push(q.front());
						q.pop();
					}
					
					while(!st.empty()){
						q.push(st.top());
						st.pop();
					}
					
					temp = val;
					while(temp--){
						q.push(q.front());
						q.pop();
					}
					
					temp = val;
					while(temp--){
						st.push(q.front());
						q.pop();
					}
					
					vector<int> v;
					int f = 1;
					while(!q.empty())
						(f) ? (v.push_back(st.top()), st.pop(), f = 0) : (v.push_back(q.front()), q.pop(), f = 1);
					
					return v;
				}
			};

	Q.7. Implement k Queues in a single array: ❌Pending
		#include <iostream>
		using namespace std;
		class KQueues{
			public:
				int n;              // array size
				int k;              // no.of queues
				int *frnt, *rear, *arr, *nxt;
				int freeSpot = 0;
			
			KQueues(int n, int k){
				this -> n = n;
				this -> k = k;
				frnt = new int[k];
				rear = new int[k];
				nxt = new int[n];
				arr = new int[n];
				
				for(int i=0; i<k; i++)
					frnt[i] = rear[i] = -1;
				
				for(int i=0; i<n; i++)
					nxt[i] = i+1;
				
				nxt[n-1] = -1;
			}
			
			void enQueue(int data, int Qn){
				if(freeSpot == -1){
					cout<<"Queues are full";
					return;
				}
				
				// find first free space
				int curIndex = freeSpot;
				
				// update freeSpot
				freeSpot = nxt[curIndex];
				
				if(frnt[Qn-1] == -1){
					frnt[Qn-1] = curIndex;
				}else{
					nxt[rear[Qn-1]] = curIndex;
				}
				
				nxt[curIndex] = -1;
				rear[Qn-1] = curIndex;
				
				arr[curIndex] = data;
			}
			
			int deQueue(int Qn){
				if(frnt[Qn-1] == -1){
					cout<<Qn<<" Queue is empty" <<"\t";
					return 0;
				}
				int index = frnt[Qn-1];
				
				frnt[Qn-1] = nxt[index];
				
				nxt[index] = freeSpot;
				freeSpot = index;
				return arr[index]; 
			}
		};

		int main() {
			KQueues Q(5,5);
			
			Q.enQueue(1, 1);
			Q.enQueue(2, 1);
			Q.enQueue(3, 2);
			Q.enQueue(4, 3);
			Q.enQueue(5, 3);
			Q.enQueue(100, 5);
			std::cout << std::endl;
			
			std::cout << Q.deQueue(1) << std::endl;
			std::cout << Q.deQueue(1) << std::endl;
			std::cout << Q.deQueue(1) << std::endl;
			std::cout << Q.deQueue(1) << std::endl;
			std::cout << Q.deQueue(5) << std::endl;
			return 0;
		}

	Q.8. Sum of minimum and maximum elements of all subarrays of size k: (Refer Q.886 from POTD section)
		Problem Statement:
			Given an array of both positive and negative integers, the task is to compute sum of minimum and maximum elements of all sub-array of size k.
			Examples: 
			Input : arr[] = {2, 5, -1, 7, -3, -1, -2}  
				K = 4
			Output : 18
			Explanation : Subarrays of size 4 are : 
				{2, 5, -1, 7},   min + max = -1 + 7 = 6
				{5, -1, 7, -3},  min + max = -3 + 7 = 4      
				{-1, 7, -3, -1}, min + max = -3 + 7 = 4
				{7, -3, -1, -2}, min + max = -3 + 7 = 4   

		// Not Optimized:
			#include <iostream>
			#include <climits>
			using namespace std;
			int Solve(int arr[], int k, int n){
				int sum = 0;
				
				for(int i=0; i <= (n-k); i++){
					int val = k, j=i;
					int mn = INT_MAX, mx = INT_MIN;

					while(val--){
						mn = min(mn, arr[j]);
						mx = max(mx, arr[j]);
						j++;
					}
					sum += (mn + mx);
				}
				return sum;
			}

			int main() {
				int arr[] = {2, 5, -1, 7, -3, -1, -2};
				int k = 4, n=7;

				cout << Solve(arr, k, n) << "\t";
				cout << Solve(arr, 3, n);	
				return 0;
			}

		// Optimized:
			❌Pending
---------------------------------------------------------------------------------------------------------
	31/05/24
Lecture 62: Binary Trees & its Representation || Different types of Traversals
	Binary Tree is a non-linear data structure where each node has at most two children [might be 0 or 1 or 2 childrens, but not more than 2. (one on left & one on right).
	figure:
									 1
									 │
					┌────────────────────┴───────────────────────┐
					2               	                  		3
				    	│                   	         	    		│
			 ┌────────┴──────────┐              		┌─────────┴─────────┐
			 4                   5                 		6                   7
			 │                   │                 		│                   │
		 ┌────┴────┐        ┌─────┴─────┐	         ┌─────┴─────┐       ┌─────┴─────┐
		 8         9        10          11          12         13       14	      15

	Terms: Considering above figure..
		1) Node		- is entity which holds information, it contains data & pointer to childrens. (any element of tree is Node)
		2) Root		- Top Node where tree starts (here 1 is root node.)
		3) Children	- 8 and 9 are the childrens of 4 or 2 & 3 are the childrens of 1
		4) Parent		- 1 is parent of 2 & 3, or 5 is parent of 10 & 11
		5) Siblings 	- childs have same parent are called Siblings, here 12 & 13 has same parent(6) so 12 & 13 are Siblings.
		6) Ancestor	- for example consider Node with value 11, here Ancestor of 11 are, 5, 2 & 1. (from bottom to top)
		7) Descendant	- for example consider Node with value 3, here Descendant of 3 are, 6,7 12,13, 14 & 15 (from top to bottom)
		8) Leaf		- The Node which don't have childrens are called Leaf Node.here 8, 9, 10, 11, 12, 13, 14 & 15 are te leaf Nodes.
	-Also Refer image named lect-62.
	#Binary Tree Structure:
		struct Node{
			int data;
			Node* left;
			Node* right;

			Node(int val){
				data = val;
				left = right = NULL;
			}
		}

		// Use any below method to implement Nodes of tree
		// Method 1: Using "struct" to make
		// user-define data type
		struct node {
			int data;
			struct node* left;
			struct node* right;
		};

		// Method 2: Using "class" to make
		// user-define data type
		class Node {
			public:
			int data;
			Node* left;
			Node* right;
		};
	
	#If want to create Tree with multiple childrens called n-nary tree
		struct Node{
			int data;
			Node* child[10];
		}

	#Binary Tree / Level Order Traversal (Breadth First Search or BFS)
		#include <iostream>
		#include<queue>
		using namespace std;
		// inputs
		// 1 3 5 7 -1 -1 11 -1 -1 17 -1 -1 -1
		// 1 2 4 8 -1 -1 9 -1 -1 5 10 -1 -1 11 -1 -1 3 6 12 -1 -1 13 -1 -1 7 14 -1 -1 15 -1 -1

		class Node{
			public:
				int data;
				Node *left, *right;
			
			Node(int data){
				this -> data = data;
				this -> left = NULL;
				this -> right = NULL;
			}
		};

		// Creation:
		Node* buildTree(){
			std::cout << "Enter the data: " << std::endl;
			int data;
			std::cin >> data;
			
			Node* root = new Node(data);
			if(data == -1)
				return NULL;
			
			std::cout << "Enter data for inserting in left: "<< data << std::endl;
			root -> left = buildTree();
			
			std::cout << "Enter data for inserting in right: "<< data << std::endl;
			root -> right = buildTree();
			return root;
		}

		// Level order traversal:
		void LevelOrderTraversal(Node *root){
			std::queue<Node *> q;
			q.push(root);
			q.push(NULL);
			
			while(!q.empty()){
				Node *temp = q.front();
				q.pop();
				
				if(temp == NULL){
					std::cout << std::endl;
					if(!q.empty())
						q.push(NULL);
					
				}else{
					cout<<temp -> data << "\t";
					if(temp -> left)
						q.push(temp -> left);
						
					if(temp -> right)
						q.push(temp -> right);
				}
			}
		}

		int main() {
			Node *root = NULL;
			
			// creating a Tree
			root = buildTree();
			
			// printing the tree
			if(root != NULL)
				LevelOrderTraversal(root);
			
			return 0;
		}

	Q. Level order traversal (Refer Q. 926 from POTD section)

	#Practice:
		#include <iostream>
		#include<queue>
		using namespace std;

		//                  1
		//         2                  3
		//     4           5       6    7

		// 1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1
		// 1 2 4 8 -1 -1 9 -1 -1 5 10 -1 -1 11 -1 -1 3 6 12 -1 -1 13 -1 -1 7 -1 14 -1 -1

		class Node{
			public:
				int data;
				Node *left;
				Node *right;
			
			Node(int data){
				this -> data = data;
				right = left = NULL;
			}
		};

		Node* TreeCreation(){
			std::cout << "Enter data: ";
			int data;
			cin>>data;
			
			if(data == -1)
				return NULL;
			
			Node *n = new Node(data);
			std::cout << "Enter data on left of "<< data << std::endl;
			n -> left = TreeCreation();		
			
			std::cout << "Enter data on right of "<< data << std::endl;
			n -> right = TreeCreation();
			return n;
		}

		void LevelOrderTraversal(Node *r){
			queue<Node *> q;
			q.push(r);
			q.push(NULL);
			
			std::cout << std::endl;
			while(!q.empty()){
				Node *temp = q.front();
				q.pop();
				
				if(temp == NULL){
					std::cout << std::endl;
					if(!q.empty())
						q.push(NULL);
				}else{
					cout<< temp -> data << "\t";
					
					if(temp -> left)
						q.push(temp -> left);
					if(temp -> right)
						q.push(temp -> right);
				}
			}
		}

		int main() {
			Node *root = NULL;
			root = TreeCreation();
			LevelOrderTraversal(root);
			
			return 0;
		}

	HomeWork: #Reverse Level Order Traversal: (Refer Q.927 form POTD section)
		// Using stack & queue
		/*
			struct Node {
				int data;
				Node* left;
				Node* right;
			};
		*/
		void RLOT(Node* r, vector<int> &v){
			queue<Node*> q;
			stack<int> st;
			q.push(r);
			
			while(!q.empty()){
				Node *curNode = q.front();
				st.push(curNode -> data);
				q.pop();
				
				if(curNode -> right)
					q.push(curNode -> right);
				
				if(curNode -> left)
					q.push(curNode -> left);
			}
			
			while(!st.empty()){
				v.push_back(st.top());
				st.pop();
			}
		}

		vector<int> reverseLevelOrder(Node *root) {
			vector<int> ans;
			
			RLOT(root, ans);                // RLOT = Reverse Level Order Traversal
			return ans;
		}

		// or using vector:
			vector<int> reverseLevelOrder(Node *root) {
				queue<Node *> q;
				queue<Node*> hold;
				q.push(root);
				q.push(NULL);
				hold.push(root);
				hold.push(NULL);

				while(!q.empty()){
					Node *cur = q.front();
					q.pop();
					
					if(cur == nullptr){
						if(!q.empty()){
							hold.push(NULL);
							q.push(NULL);
						}
					}else{
						if(cur -> left) q.push(cur -> left), hold.push(cur -> left) ;
						if(cur -> right) q.push(cur -> right), hold.push(cur -> right);
					}
				}

				vector<vector<int>> v;
				vector<int> t;
				while(!hold.empty()){
					Node *cur = hold.front();
					hold.pop();
					
					if(cur == NULL){
						v.push_back(t);
						t.clear();
					}else{
						t.push_back(cur -> data);
					}
				}
				vector<int> ans;
				for(int i = v.size() -1; i>=0; i--)
					for(int j=0; j<v[i].size(); j++)
						ans.push_back(v[i][j]);
				
				// for above for loop
				return ans;
			}
	
		// or using stack & vector:
			vector<int> reverseLevelOrder(Node *root) {
				queue<Node *> q;
				q.push(root);
				q.push(NULL);
				stack<vector<int>> st;
				st.push({root -> data});
				vector<int> t;

				while(!q.empty()){
					Node *cur = q.front();
					q.pop();
					
					if(cur == nullptr){
						if(!q.empty()){
							q.push(NULL);
							st.push(t);
							t.clear();
						}
					}else{
						if(cur -> left) q.push(cur -> left), t.push_back(cur -> left -> data);
						if(cur -> right) q.push(cur -> right), t.push_back(cur -> right -> data);
					}
				}

				vector<int> ans;
				while(!st.empty()){
					ans.insert(ans.end(), st.top().begin(), st.top().end());
					st.pop();
				}
				return ans;
			}

	Tyes of Traversal: (Recursion)
		1) In-Order
		2) Pre-Order
		3) Post-Order
		Code:
			#include <iostream>
			#include<queue>
			using namespace std;
			/* 			  1
						/   \
					    2     3
					   / \   / \
					  4   5 6   7
			*/
			// above tree in input looks like: 1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1
			// Level Order Traversal (Breadth First Search or BFS): 1 2 3 4 5 6 7
			// InOrder Traversal    : 4 2 5 1 6 3 7
			// PreOrder Traversal   : 1 2 4 5 3 6 7
			// PostOrder Traversal  : 4 5 2 6 7 3 1

			struct TreeNode{
				public:
					int data;
					TreeNode *left = NULL;
					TreeNode *right = NULL;
				
				TreeNode(int data){
					this -> data = data;
				}
			};

			TreeNode *GenerateTree(){
				std::cout << "Enter data : " << std::endl;
				int data;
				cin>> data;
				
				if(data == -1) return NULL;

				TreeNode *curNode = new TreeNode(data);
				std::cout << "Enter data on left of " << data << std::endl;
				curNode -> left = GenerateTree();
				
				std::cout << "Enter data on left of " << data << std::endl;
				curNode -> right = GenerateTree();
				
				return curNode;
			}

			void showTree(TreeNode* Root){
				queue<TreeNode *> q;
				q.push(Root);
				q.push(NULL);
				
				while(!q.empty()){
					TreeNode *curNode  = q.front();
					q.pop();
					
					if(curNode){                                //  if(curNode != NULL){
						cout<< curNode -> data <<"\t";
						if(curNode -> left)
							q.push(curNode -> left);
							
						if(curNode -> right)
							q.push(curNode -> right);
					}else{
						std::cout << std::endl;
						if(!q.empty())
							q.push(NULL);
					}
				}
			}

			void InOrderTraversal(TreeNode *Root){
				if(Root == NULL)
					return ;
				InOrderTraversal(Root -> left);
				std::cout << Root -> data << "\t";
				InOrderTraversal(Root -> right);
			}

			void PreOrderTraversal(TreeNode *Root){
				if(Root == NULL)
					return ;
				std::cout << Root -> data << "\t";
				PreOrderTraversal(Root -> left);
				PreOrderTraversal(Root -> right);
			}

			void PostOrderTraversal(TreeNode *Root){
				if(Root == NULL)
					return ;
				PostOrderTraversal(Root -> left);
				PostOrderTraversal(Root -> right);
				std::cout << Root -> data << "\t";
			}

			int main() {
				std::cout << "Enter Root : " << std::endl;
				TreeNode *root = GenerateTree();
				
				// Tree
				showTree(root);
				
				std::cout << "InorderTraversal: \t";                    // 4       2       5       1       6       3       7
				InOrderTraversal(root);
				std::cout << std::endl;
				
				std::cout << "PreOrderTraversal: \t";                   // 1       2       4       5       3       6       7
				PreOrderTraversal(root);
				std::cout << std::endl;
				
				std::cout << "PostOrderTraversal: \t";                  // 4       5       2       6       7       3       1
				PostOrderTraversal(root);                   
				std::cout << std::endl;
				
				return 0;
			}
	
	HomeWork: solve below traversals without using recursion instead use iterative approachdsa
		1) In-Order
		2) Pre-Order
		3) Post-Order
		Code: Iterative Approach
		Q.1. Iterative Inorder:	(POTD 1096)
			Problem Statement:
				Given a binary tree. Find the inorder traversal of the tree without using recursion.
				Example 1
				Input:
					   1
					/    \
				    2     3
				  /   \
				 4     5
				Output: 4 2 5 1 3
				Explanation:
				Inorder traversal (Left->Root->Right) of 
				the tree is 4 2 5 1 3.
				Example 2
				Input:
				  	    8
					/        \
				    1          5
					\       /  \
					 7     10   6
					  \   /
					  10 6
				Output: 1 7 10 8 6 10 5 6
				Explanation:
				Inorder traversal (Left->Root->Right) 
				of the tree is 1 7 10 8 6 10 5 6.
				Your task:
					You don't need to read input or print anything. Your task is to complete the function inOrder() which takes the root of the tree as input and returns a list containing the inorder traversal of the tree, calculated without using recursion.

				Expected time complexity: O(N)
				Expected auxiliary space: O(N)

				Constraints:
					1 <= Number of nodes <= 10^5
					1 <= Data of a node <= 10^5
			/* Tree Node
				struct Node {
					int data;
					Node* left;
					Node* right;
				};
			*/
			class Solution {
				public:
				vector<int> inOrder(Node* root) {
					vector<int> ans;
					stack<Node*> st;
					
					while(root or !st.empty()){                                 // while(root != NULL || !st.empty()){}		//  while(root or not st.empty()){}              // while(root != NULL || st.empty() != true) {}
						while(root){
							st.push(root);
							root = root -> left;
						}
						root = st.top();
						st.pop();
						ans.push_back(root -> data);
						root = root -> right;
					}
					return ans;
				}
			};
						
		Q.2. Preorder traversal (Iterative):
			Problem Statement:
				Given a Binary tree. Find the preorder traversal of the tree without using recursion.
				Example 1:
				Input:
						       1
						     /   \
						    2     3
						  /  \
						 4    5
				Output: 1 2 4 5 3
				Explanation:
				Preorder traversal (Root->Left->Right) of 
				the tree is 1 2 4 5 3.
				Example 2
				Input:
						      8
						  /       \
						 1         5
						  \       /  \
						   7     10   6
						    \   /
						    10 6
				Output: 8 1 7 10 5 10 6 6 
				Explanation:
				Preorder traversal (Root->Left->Right) 
				of the tree is 8 1 7 10 5 10 6 6.
				Your task:
					You don't need to read input or print anything. Your task is to complete the function preOrder() which takes the root of the tree as input and returns a list containing the preorder traversal of the tree, calculated without using recursion.
				Expected time complexity: O(N)
				Expected auxiliary space: O(N)
				Constraints:
					1 ≤ Number of nodes ≤ 10^5
					1 ≤ Data of a node ≤ 10^5

			/* Tree Node
				struct Node {
					int data;
					Node* left;
					Node* right;
				};
			*/
			class Solution{
				public:
				vector<int> preOrder(Node* root) {
					vector<int> ans;
					stack<Node*> st;
					
					while(root or !st.empty()){
						while(root){
							st.push(root);
							ans.push_back(root -> data);
							root = root -> left;
						}
						root = st.top();
						st.pop();
						root = root -> right;
					}
					return ans;
				}
			};

			// Using stack
				class Solution{
					public:
					vector<int> preOrder(Node* root) {
						vector<int> ans;
						if(not root) return ans;
						
						stack<Node*>st;
						st.push(root);
						while(not st.empty()){                  // while(!st.empty()){
							Node* cur = st.top();
							ans.push_back(cur -> data);
							st.pop();
							
							if(cur -> right) st.push(cur -> right);
							if(cur -> left) st.push(cur -> left);
						}
						return ans;
					}
				};

			// Using Morris Traversal
				class Solution{
					public:
					vector<int> preOrder(Node* root) {
						vector<int> ans;
						if(!root) return ans;           // if(root == NULL) return ans;
						
						while(root){
							if(root -> left){
								Node* predecessor = root -> left;
								
								// keep going until you finds NULL or root again.
								while(predecessor -> right && predecessor -> right != root)             // while(predecessor -> right != NULL && predecessor -> right != root)
									predecessor = predecessor -> right;
								
								if(predecessor -> right == root){               	// encountered the cycle (loop) in tree need to disconnect it.
									predecessor -> right = NULL;
									root = root -> right;
								}else{        								// means right of predecessor is NULL, making connection to root
									predecessor -> right = root;
									ans.push_back(root -> data);
									root = root -> left;   
								}
							}else{
								ans.push_back(root -> data);
								root = root -> right;
							}
						}
						return ans;
					}
				};

		Q.3. Postorder traversal (Iterative):
			Problem Statement:
				Given a binary tree. Find the postorder traversal of the tree without using recursion. Return a list containing the postorder traversal of the tree, calculated without using recursion.
				Examples :
				Input:
					           1
					         /   \
					        2     3
					      /  \
					     4    5
				Output: 4 5 2 3 1
				Explanation: Postorder traversal (Left->Right->Root) of the tree is 4 5 2 3 1.
				Input:
				               8
				          /         \
				         1           5
				          \        /   \
				           7      10    6
				            \    /
				             10 6
				Output: 10 7 1 6 10 6 5 8 
				Explanation: Postorder traversal (Left->Right->Root) of the tree is 10 7 1 6 10 6 5 8 .
				Expected time complexity: O(n)
				Expected auxiliary space: O(n)
				Constraints:
					1 <= Number of nodes <= 10^5
					1 <= Data of a node <= 10^5
					
			/* Tree Node
				struct Node {
					int data;
					Node* left;
					Node* right;
				};
			*/
			class Solution{
				public:
				vector<int> postOrder(Node* root) {
					stack<Node*> st1, st2;
					vector<int> ans;
					
					if(!root) return ans;
					st1.push(root);
					
					while(!st1.empty()){
						Node* cur = st1.top();
						st1.pop();
						st2.push(cur);
						if(cur -> left) st1.push(cur -> left);
						if(cur -> right) st1.push(cur -> right);
					}
					
					while(!st2.empty()){
						ans.push_back(st2.top() -> data);
						st2.pop();
					}
					return ans;
				}
			};

	Build from LevelOrderTraversal:
		#include <iostream>
		#include<queue>
		using namespace std;
			//                  1
			//         2                  3
			//     4           5       6    7

			// 1 2 3 4 5 6 7 -1 -1 -1 -1 -1 -1 -1 -1
		class Node {
			public:
				int data;
				Node *left, *right;
				
			Node(int val) {
				data = val;
				left = right = NULL;
			}
		};

		Node *buildTreeFromLevelOrderTraversal(){
			int val;
			std::cout << "Enter root value: " << std::endl;
			cin >> val;
			
			if(val == -1) return NULL;
				
			queue<Node *> q;
			Node *root = new Node(val);
			q.push(root);
			
			while(!q.empty()){
				Node *cur = q.front();
				q.pop();
				
				int vL;
				std::cout << "Enter left data: "<< cur -> data << "\t";
				cin>>vL;
				
				if(vL != -1){
					cur -> left = new Node(vL);
					q.push(cur -> left);
				}
				
				int vR;
				std::cout << "Enter right data: "<< cur -> data << "\t";
				cin>>vR;
				
				if(vR != -1){
					cur -> right = new Node(vR);
					q.push(cur -> right);
				}
			}
			return root;
		}

		void Display(Node* root){
			queue<Node *> q;
			if(root == NULL) return ;
			
			q.push(root);
			q.push(NULL);
			
			while(!q.empty()){
				Node *t = q.front();
				q.pop();
				
				if(t == NULL){
					std::cout << std::endl;
					if(!q.empty())  q.push(NULL);
				} 
				else{
					std::cout << t -> data; 
					if(t -> left != NULL)
						q.push(t -> left);
					if(t -> right) q.push(t -> right);
				}
			}
		}

		int main() {
			Node *root = buildTreeFromLevelOrderTraversal();
			std::cout << "The tree is : " << std::endl;
			
			Display(root);
			return 0;
		}

		#Practice:
			#include <iostream>
			#include<queue>
			using namespace std;

			struct Node{
				int data;
				Node *left, *right;
				
				Node(int val){
					data = val;
					left = right = NULL;
				}
			};

			Node* Build_From_Level_Order_Traversal(){
				int r;
				std::cout << "Enter Root: ";
				cin>>r;
				
				if(r == -1) return NULL;
				
				queue<Node *>q;
				Node *root = new Node(r);
				q.push(root);
				
				while(!q.empty()){
					Node *cur = q.front();
					q.pop();
					
					int v;
					cout<<"Enter left child for "<<cur -> data << "\t";
					cin >> v;
					
					if(v != -1) {
						Node *t = new Node(v);
						cur -> left = t;
						q.push(cur -> left);
					}
					
					cout<<"Enter right child for "<<cur -> data << "\t";
					cin >> v;
					
					if(v != -1){
						Node *t = new Node(v);
						cur -> right = t;
						q.push(cur -> right);
					} 
				}
				return root;
			}

			void Display_Tree(Node *root){
				if(!root) return ;                  // (root == NULL) its same as (!root)
				
				queue<Node *>q;
				q.push(root);
				q.push(NULL);
			
				while(!q.empty()){
					Node *cur =q.front();
					q.pop();
					
					if(cur){            // cur != NULL
						std::cout << cur -> data << "\t";
						if(cur -> left) q.push(cur -> left);
						if(cur -> right) q.push(cur -> right);
					}else{
						if(!q.empty())  q.push(NULL);
						std::cout << std::endl;
					}
				}
			}

			int main() {
				Node *root = Build_From_Level_Order_Traversal();
				Display_Tree(root);
				return 0;
			}

	Q. Count Leaf Nodes:
		https://www.naukri.com/code360/problems/count-leaf-nodes_893055
		Problem statement
			You are given a Binary tree. You have to count and return the number of leaf nodes present in it.
			A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child
			A node is a leaf node if both left and right child nodes of it are NULL.
			Constraints:
				1 <= T <= 100
				1 <= N <=10^3
				1 <= data <= 10^9
				Time Limit : 1 sec
			Sample Input 1:
				3
				1 -1 -1
				1  2  3  -1 -1 -1 4 -1 -1
				1  2 -1 -1 3 -1 4 -1 -1
				Sample Output 1:
				1
				2
				1
				Explanation For Sample Input 1:
				(i) 1 is the only node present in the tree, and hence it is the only leaf node.
				(ii) 2 and 4 are two leaf nodes present in the tree; all other nodes have at least one child (1 has 2 and 3 and 3 has 4).
				(iii) 4 is the only leaf node present in the tree as all other nodes have at least one child node (1 has 2, 2 has 3 and 3 has 4)
				Sample Input 2:
				3
				1 2 3 4 5 6 7 -1 -1 -1 -1 -1 -1 -1 -1
				1 -1 2 -1 3 -1 -1
				1 2 -1 3 4 5 6 7 8 -1 - 1 -1 -1 -1 -1 -1 -1
				Sample Output 2:
				4
				1
				4
				Explanation For Sample Input 2:
				(i) 4, 5, 6 and 7 are 4 leaf nodes present in the tree, all other nodes have at least one child (1 has 2 and 3, 2 has 4 and 5 and 3 has 6 and 7).
				(ii) 3 is the only leaf node present in the tree as all other nodes have at least one child node (1 has 2 and 2 has 3)
				(iii) 5, 6, 7 and 8 are 4 leaf nodes present in the tree, all other nodes have at least one child (1 has 2, 2 has 3 and 4, 3 has 5 and 6 and 4 has 7 and 8).

		/**********************************************************
			Following is the Binary Tree Node class structure:
			template <typename T>
			class BinaryTreeNode {
				public :
					T data;
					BinaryTreeNode<T> *left;
					BinaryTreeNode<T> *right;

				BinaryTreeNode(T data) {
						this -> data = data;
						left = NULL;
						right = NULL;
				}
			};
		***********************************************************/

		void Inorder(BinaryTreeNode<int> *r, int &c){
			if(r == nullptr)
				return;
			
			Inorder(r->left, c);

			if(r -> left == nullptr && r -> right == nullptr){
				c++;
				return ;
			}

			Inorder(r->right, c);

			/* or
				Inorder(r->left, c);
				Inorder(r->right, c);
				if(r -> left == nullptr && r -> right == nullptr)
					c++;
			*/
		}

		int noOfLeafNodes(BinaryTreeNode<int> *root){
			int cnt =0;
			Inorder(root, cnt);
			return cnt;
		}

		// or
			void Counter(BinaryTreeNode<int> *r, int &c){
				if(r == nullptr) return;

				queue<BinaryTreeNode<int> *> q;
				q.push(r);

				while(!q.empty()){
					BinaryTreeNode<int> *n = q.front();
					q.pop();

					if(!n -> left && !n -> right)           // if(n -> left == nullptr && n -> right == nullptr)
						c++;
					
					if(n -> left)   q.push(n -> left);
					if(n -> right)   q.push(n -> right);
				}
			}

			int noOfLeafNodes(BinaryTreeNode<int> *root){
				int cnt =0;
				Counter(root, cnt);
				return cnt;
			}

	Types of Binary Tree
		Binary Tree can be classified into multiples types based on multiple factors:
		On the basis of Number of Children
			Full Binary Tree
			Degenerate Binary Tree
			Skewed Binary Trees
		
		On the basis of Completion of Levels
			Complete Binary Tree
			Perfect Binary Tree
			Balanced Binary Tree
		
		On the basis of Node Values:
			Binary Search Tree
			AVL Tree
			Red Black Tree
			B Tree
			B+ Tree
			Segment Tree

	#Skewed Binary Tree:
		- A skewed binary tree is a type of binary tree in which all the nodes have only either one child or no child.
		#Types of Skewed Binary trees There are 2 special types of skewed tree:
			1) Left Skewed Binary Tree:
				These are those skewed binary trees in which all the nodes are having a left child or no child at all. It is a left side dominated tree. All the right children remain as null.

			2) Right Skewed Binary Tree: 
				These are those skewed binary trees in which all the nodes are having a right child or no child at all. It is a right side dominated tree. All the left children remain as null.
		- In a skewed binary tree, each node has exactly one child, either all left or all right.
---------------------------------------------------------------------------------------------------------
	05/10/2024
Lecture 63: Binary Tree FAANG Interview Questions || Part-1:
	Q.1. Height of Binary Tree:
		Problem Statement:
			Given a binary tree, find its height.
			Example 1:
			Input:
				 1
				/ \
			    2   3
			Output: 2

			Example 2:
			Input:
				2
				 \
				  1
				 /
				3
			Output: 3   
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function height() which takes root node of the tree as input parameter and returns an integer denoting the height of the tree. If the tree is empty, return 0. 

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 <= Number of nodes <= 10^5
				1 <= Data of a node <= 10^9

		//User function template for C++
		/*
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;
				
				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/

		class Solution{
		public:
		void Traverse(Node *node, int cnt, int &mxHT){
			if(!node) return;
			
			mxHT = max(mxHT, cnt);
			Traverse(node -> left, cnt+1, mxHT);
			Traverse(node -> right, cnt+1, mxHT);
		}
		
		//Function to find the height of a binary tree.
		int height(struct Node* node){
			int cnt, mx;
			cnt=mx=1;

			Traverse(node, cnt, mx);
			return mx;
		}
		};

		// or
			class Solution{
				public:
				//Function to find the height of a binary tree.
				int height(struct Node* node){
					
					if(!node)   return 0;
					
					int left, right;
					left = height(node -> left);
					right = height(node -> right);
					
					return max(left, right) + 1;
				}
			};

	Q.2. Diameter of a Binary Tree:
		Problem Statement:
			The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two end nodes. The diagram below shows two trees each with diameter nine, the leaves that form the ends of the longest path are shaded (note that there is more than one path in each tree of length nine, but no path longer than nine nodes).

			Example 1:
			Input:
				 1
				/  \
			    2    3
			Output: 3

			Example 2:
			Input:
				  10
				/   \
			    20    30
			   /  \ 
			  40   60
			Output: 4

			Your Task:
				You need to complete the function diameter() that takes root as parameter and returns the diameter.
			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(Height of the Tree).

			Constraints:
				1 <= Number of nodes <= 10000
				1 <= Data of a node <= 1000

		// Not Optimized:
			/* Tree node structure  used in the program
				struct Node {
				int data;
				struct Node* left;
				struct Node* right;

				Node(int x){
					data = x;
					left = right = NULL;
				}
				}; 
			*/
			class Solution {
				public:
				int height(Node* n){
					if(!n) return 0;
					
					int left = height(n -> left);
					int right = height(n -> right);
					
					return max(left, right) + 1;
				}

				// Function to return the diameter of a Binary Tree.
				int diameter(Node* root) {
					if(!root) return 0;
					
					int leftSide = diameter(root -> left);
					int rightSide = diameter(root -> right);
					int combine = height(root -> left) + height(root -> right) + 1;          // adding 1 for root node

					return max(max(leftSide, rightSide), combine);
				}
			};

		// Optimized:
			class Solution {
				public:
				pair<int, int> diameterFast(Node* root){
					if(!root) return make_pair(0,0);
					
					pair<int, int> leftSide = diameterFast(root -> left);
					pair<int, int> rightSide = diameterFast(root -> right);
					
					int left_diameter = leftSide.first;
					int right_diameter = rightSide.first;
					int height = leftSide.second + rightSide.second + 1;
					
					int diameter = max(max(left_diameter, right_diameter), height);
					int ht = max(leftSide.second, rightSide.second) + 1;
					
					return make_pair(diameter, ht);
				}
			
				// Function to return the diameter of a Binary Tree.
				int diameter(Node* root) {
					return diameterFast(root).first;
				}
			};

	Q.3. Balanced Tree Check:
		Problem Statement:
			Given a binary tree, find if it is height balanced or not.  A tree is height balanced if difference between heights of left and right subtrees is not more than one for all nodes of tree. 
			Examples:
			Input:
				 1
				/
			    2
				\
				 3 
			Output: 0
			Explanation: The max difference in height of left subtree and right subtree is 2, which is greater than 1. Hence unbalanced

			Input:
			  	  10
				/    \
			    20    30 
			   /   \
			  40   60
			Output: 1
			Explanation: The max difference in height of left subtree and right subtree is 1. Hence balanced. 

			Constraints:
				1 <= Number of nodes <= 10^5
				1 <= Data of a node <= 10^9

			Expected time complexity: O(N)
			Expected auxiliary space: O(h) , where h = height of tree

		/* A binary tree node structure
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;
				
				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/

		class Solution{
			public:
			int height(Node* n){
				if(!n) return 0;
				return max(height(n -> left), height(n -> right)) + 1;
			}
			//Function to check whether a binary tree is balanced or not.
			bool isBalanced(Node *root) {
				if(!root)   return 1;
				
				bool left = isBalanced(root -> left);
				bool right = isBalanced(root -> right);
				
				bool diff = abs(height(root -> left) - height(root -> right)) <= 1;

				if(left && right && diff) return 1;
				return 0;
			}
		};

		// More Optimized:
			class Solution{
				public:
				pair<bool, int> check(Node *root){
					if(!root) return {1,0};
					
					pair<bool, int> left = check(root -> left);
					pair<bool, int> right = check(root -> right);
					
					bool leftAns = left.first;
					bool rightAns = right.first;
					bool diff = abs(left.second - right.second) <= 1;
					
					pair<bool, int> ans;
					ans.second = max(left.second, rig   ht.second) + 1;
					
					if(leftAns && rightAns && diff){
						ans.first = 1;
						return ans;
					}
					
					ans.first = 0;
					return ans;
				}
				//Function to check whether a binary tree is balanced or not.
				bool isBalanced(Node *root) {
					return check(root).first;
				}
			};

	Q.4. Identical Trees:
		Problem Statement:
			Given two binary trees, the task is to find if both of them are identical or not.
			Note: You need to return true or false, the printing is done by the driver code.

			Example 1:
			Input:
				  1          1
				/   \      /   \
			    2     3    2     3
			Output: 
			Yes
			Explanation: 
			There are two trees both having 3 nodes and 2 edges, both trees are identical having the root as 1, left child of 1 is 2 and right child of 1 is 3.
			Example 2:

			Input:
				  1        1
				/  \     /  \
			    2    3   3    2
			Output: 
			No
			Explanation: There are two trees both having 3 nodes and 2 edges, but both trees are not identical.

			Your task:
				Since this is a functional problem you don't have to worry about input, you just have to complete the function isIdentical() that takes two roots as parameters and returns true or false. The printing is done by the driver code.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(Height of the Tree).

			Constraints:
				1 <= Number of nodes <= 10^5
				1 <=Data of a node <= 10^9

		/* A binary tree node
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;
				
				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/
		class Solution {
			public:
			//Function to check if two trees are identical.
			bool isIdentical(Node *r1, Node *r2) {
				if(!r1 && !r2) return 1;                      // if(r1 == NULL && r2 == NULL) return 1;
				if((!r1 && r2) || (r1 && !r2)) return 0;      // if((r1 == NULL && r2 != NULL) || (r1 != NULL && r2 == NULL)) return 0;
				if(r1 -> data != r2 -> data) return 0;
				
				return (isIdentical(r1 -> right, r2 -> right) && isIdentical(r1 -> left, r2 -> left));
			}
		};

	Q.5. Sum Tree:
		Problem Statement:
			Given a Binary Tree. Check for the Sum Tree for every node except the leaf node. Return true if it is a Sum Tree otherwise, return false.
			A SumTree is a Binary Tree where the value of a node is equal to the sum of the nodes present in its left subtree and right subtree. An empty tree is also a Sum Tree as the sum of an empty tree can be considered to be 0. A leaf node is also considered a Sum Tree.

			Examples :
			Input:
				  3
				/   \    
			    1     2
			Output: true
			Explanation: The sum of left subtree and right subtree is 1 + 2 = 3, which is the value of the root node. Therefore,the given binary tree is a sum tree.

			Input:
			 	  10
				/    \
			    20	30
			  /   \ 
			 10    10
			Output: false
			Explanation: The given tree is not a sum tree. For the root node, sum of elements in left subtree is 40 and sum of elements in right subtree is 30. Root element = 10 which is not equal to 30+40.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(Height of the Tree)

			Constraints:
				2 ≤ number of nodes ≤ 10^5
				1 ≤ node value ≤ 10^5
				
		/*  Tree node
			struct Node {
				int data;
				Node* left, * right;
			}; 
		*/
		// Should return true if tree is Sum Tree, else false
		class Solution {
		public:
		pair<bool, int> TEST(Node* n){
			pair<bool, int> ans;
			
			if(!n) return {1, 0};               // return {true, 0};  
			if(!n -> left && !n -> right){
				ans.first = 1;
				ans.second = n -> data;
				return ans;
			}
			
			pair<bool, int>  leftSide = TEST(n -> left);
			pair<bool, int>  rightSide = TEST(n -> right);
			
			ans.first = leftSide.first && rightSide.first;
			ans.second = leftSide.second + rightSide.second;
			
			if(ans.second == (n -> data) && ans.first) return {1, ans.second+ans.second};   		// return {true, ans.second+ans.second};   // adding current node's value to compensate the total sum from left & right
			return {0, ans.second};             // return {false, ans.second};
		}
		bool isSumTree(Node* root) {
			return TEST(root).first;
		}
		};
---------------------------------------------------------------------------------------------------------
	06/10/24
Lecture 64: Binary Tree FAANG Interview Questions || Part-2:
	Q.1. ZigZag Tree Traversal:
		Problem Statement:
			Given a binary tree with n nodes. Find the zig-zag level order traversal of the binary tree.
			In zig zag traversal starting from the first level go from left to right for odd-numbered levels and right to left for even-numbered levels.

			Example 1:
			Input:
					  1
					/    \
				    2      3
				   / \    /  \
				  4   5  6    7
			Output:
				1 3 2 4 5 6 7
			Explanation:
				For level 1 going left to right, we get traversal as {1}.
				For level 2 going right to left, we get traversal as {3,2}.
				For level 3 going left to right, we get traversal as {4,5,6,7}.
				Merging all this traversals in single array we get {1,3,2,4,5,6,7}

			Example 2:
			Input:
					    7
					 /     \
				     9       7
			    	   /   \    /   
				  8     8  6     
				/  \
			    10   9 
			Output:
			7 7 9 8 8 6 9 10 
			Explanation:
				For level 1 going left to right, we get traversal as {7}.
				For level 2 going right to left, we get traversal as {7,9}.
				For level 3 going left to right, we get traversal as {8,8,6}.
				For level 4 going right to left, we get traversal as {9,10}.
				Merging all this traversals in single array we get {7,7,9,8,8,6,9,10}.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function zigZagTraversal() which takes the root node of the Binary Tree as its input and returns a list containing the node values as they appear in the zig-zag level-order traversal of the tree.

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(n).

			Constraints:
				1 <= n <= 10^5
		
		//User function Template for C++
		/*Structure of the node of the binary tree is as
		struct Node {
			int data;
			Node *left;
			Node *right;

			Node(int val) {
				data = val;
				left = right = NULL;
			}
		};
		*/

		class Solution{
		public:
		//Function to store the zig zag order traversal of tree in a list.
			vector <int> zigZagTraversal(Node* root) {
				
				queue<Node*> q;
				q.push(root);
				q.push(NULL);
				
				queue<Node*> q2;
				q2.push(root);
				q2.push(NULL);
				
				
				while(!q.empty()){
					Node * cur = q.front();
					q.pop();
					
					if(!cur){
						if(!q.empty()){
							q.push(NULL);
							q2.push(NULL);
						} 
					}else{
						if(cur -> left){
							q.push(cur -> left);
							q2.push(cur -> left);
						}
						
						if(cur -> right){
							q.push(cur -> right);
							q2.push(cur -> right);
						} 
					}
				}
				
				int curCnt = 1;
				vector<int> ans,t;
				
				while(!q2.empty()){
					Node* cur = q2.front();
					q2.pop();
					
					if(!cur){
						if(curCnt % 2 == 0){
							reverse(t.begin(), t.end());
							ans.insert(ans.end(), t.begin(), t.end());
							t.clear();
						}
						curCnt++;
					}else{
						if(curCnt&1){
							ans.push_back(cur -> data);
						}else{
							t.push_back(cur -> data);
						}
					}
				}
				return ans;
			}
		};

		// or
			class Solution{
				public:
				//Function to store the zig zag order traversal of tree in a list.
				vector <int> zigZagTraversal(Node* root) {
					vector<int> ans;
					
					queue<Node*> q;
					if(!root) return ans;
					
					q.push(root);
					bool direction = true;
					
					while(!q.empty()){
						int size = q.size();
						vector<int> t(size);
						
						for(int i=0; i<size; i++){
							Node *cur = q.front();
							q.pop();
							
							int index = direction ? i :size-1-i; 
							t[index] = cur -> data;
							
							if(cur -> left) q.push(cur -> left);
							if(cur -> right) q.push(cur -> right);
						}
						
						direction = !direction;
						ans.insert(ans.end(), t.begin(), t.end());
					}
					return ans;
				}
			};

	Q.2. Tree Boundary Traversal:
		Problem Statement:
			Given a Binary Tree, find its Boundary Traversal. The traversal should be in the following order: 
			Left boundary nodes: defined as the path from the root to the left-most node ie- the leaf node you could reach when you always travel preferring the left subtree over the right subtree. 
			Leaf nodes: All the leaf nodes except for the ones that are part of left or right boundary.
			Reverse right boundary nodes: defined as the path from the right-most node to the root. The right-most node is the leaf node you could reach when you always travel preferring the right subtree over the left subtree. Exclude the root from this as it was already included in the traversal of left boundary nodes.
			Note: If the root doesn't have a left subtree or right subtree, then the root itself is the left or right boundary. 

			Example 1:
			Input:
				  1 
				/   \
			    2     3  
			   / \   / \ 
			  4   5 6   7
				/ \
			    8   9
			
			Output: 1 2 4 8 9 6 7 3
			Example 2:
			Input:
				    1
				   /
				  2
				/   \
			    4     9
			  /  \     \
			 6    5     3
					 / \
					7   8

			Output: 1 2 4 6 5 7 8

			Your Task:
				This is a function problem. You don't have to take input. Just complete the function boundary() that takes the root node as input and returns an array containing the boundary values in anti-clockwise.

			Expected Time Complexity: O(N). 
			Expected Auxiliary Space: O(Height of the Tree).

			Constraints:
				1 ≤ Number of nodes ≤ 10^5
				1 ≤ Data of a node ≤ 10^5

		/* A binary tree Node
			struct Node {
				int data;
				Node* left, * right;
			}; 
		*/

		class Solution {
			public:
			void LeftNodes(Node* n, vector<int> &ans){
				if(!n || (n -> left == NULL && n -> right == NULL)) return ;
				
				ans.push_back(n -> data);
				if(n -> left) 
					LeftNodes(n -> left, ans);
				else
					LeftNodes(n -> right, ans);
			}
			
			void RightNodes(Node* n, vector<int> &ans){
				if(!n || (n -> left == NULL && n -> right == NULL)) return ;
				
				if(n -> right) 
					RightNodes(n -> right, ans);
				else
					RightNodes(n -> left, ans);
				ans.push_back(n -> data);
			}
			
			void LeafNodes(Node* n, vector<int> &ans){
				if(!n) return ;
				
				if(!n -> left && !n -> right)
					ans.push_back(n -> data);
				else{
					LeafNodes(n -> left, ans);
					LeafNodes(n -> right, ans);
				}
			}  
			
			vector<int> boundary(Node *root) {
				// finding the left side nodes
				vector<int> ans;
				
				// we need this condition if we are passing just a root to a LeafNodes function
				// if(!root -> left && !root -> right) return {root -> data};
				
				// ans.push_back(root -> data);
				// LeftNodes(root -> left, ans);
				// LeafNodes(root, ans);
				// RightNodes(root -> right, ans);
				
				// we are passing left side & right side to a LeafNodes function, so we don't need above extra if condition.
				ans.push_back(root -> data);
				LeftNodes(root -> left, ans);
				
				LeafNodes(root -> left, ans);
				LeafNodes(root -> right, ans);
				
				RightNodes(root -> right, ans);
				
				return ans;
			}
		};

	Q.3. Vertical Tree Traversal:
		Problem Statement:
			Given a Binary Tree, find the vertical traversal of it starting from the leftmost level to the rightmost level.
			If there are multiple nodes passing through a vertical line, then they should be printed as they appear in level order traversal of the tree.
			Example 1:
			Input:
                           1
                         /   \
                       2       3
                     /   \   /   \
                   4      5 6      7
                              \      \
                               8      9           
			Output: 
				4 2 1 5 6 3 8 7 9 

			Example 2:
			Input:
                           1
                        /    \
                       2       3
                     /    \      \
                    4      5      6
			Output: 4 2 1 5 3 6
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function verticalOrder() which takes the root node as input parameter and returns an array containing the vertical order traversal of the tree from the leftmost to the rightmost level. If 2 nodes lie in the same vertical level, they should be printed in the order they appear in the level order traversal of the tree.
			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)
			Constraints:
				1 <= Number of nodes <= 3*10^4

		class Solution {
			public:
			//Function to find the vertical order traversal of Binary Tree.
			vector<int> verticalOrder(Node *root) {
				vector<int> ans;
				if(!root) return ans;
				
				// <level, elements>
				map<int, vector<int>> mp;
				
				// <node, horizontalDistance>
				queue<pair<Node*, int>> q;
				q.push(make_pair(root, 0));
				
				while(!q.empty()){
					pair<Node*, int> temp = q.front();
					q.pop();
					
					Node *cur = temp.first;
					int hd = temp.second;
					
					mp[hd].push_back(cur -> data);
					
					if(cur -> left) q.push({cur -> left, hd-1});
					if(cur -> right) q.push(make_pair(cur -> right, hd+1));
				}
				
				for(auto i: mp)
					for(auto j: i.second)
						ans.push_back(j);

				// for(auto i: mp)
				//	ans.insert(ans.end(), i.second.begin(), i.second.end());
				return ans;
			}
		};

	Q.4. Top View of Binary Tree:
		Problem Statement:
			Given below is a binary tree. The task is to print the top view of binary tree. Top view of a binary tree is the set of nodes visible when the tree is viewed from the top. For the given below tree
			       1
			    /     \
			   2       3
			  /  \    /  \
			4    5   6    7

			Top view will be: 4 2 1 3 7
			Note: Return nodes from leftmost node to rightmost node. Also if 2 nodes are outside the shadow of the tree and are at same position then consider the left ones only(i.e. leftmost). 
			For ex - 1 2 3 N 4 5 N 6 N 7 N 8 N 9 N N N N N will give 8 2 1 3 as answer. Here 8 and 9 are on the same position but 9 will get shadowed.

			Example 1:
			Input:
     			  1
     			 / \
     			2   3
			Output: 2 1 3
			
			Example 2:
			Input:
 				       10
 				    /      \
 				  20        30
 				 /   \    /    \
 				40   60  90    100
			Output: 40 20 10 30 100
			Your Task:
				Since this is a function problem. You don't have to take input. Just complete the function topView() that takes root node as parameter and returns a list of nodes visible from the top view from left to right.
			Expected Time Complexity: O(NlogN)
			Expected Auxiliary Space: O(N).

			Constraints:
				1 ≤ N ≤ 10^5
				1 ≤ Node Data ≤ 10^5

		/*
			struct Node {
				int data;
				Node* left;
				Node* right;
			};
		*/
		class Solution {
			public:
			//Function to return a list of nodes visible from the top view 
			//from left to right in Binary Tree.
			vector<int> topView(Node *root) {
				vector<int> ans;
				map<int, int> mp;
				if(!root) return ans;
				
				// <node, horizontalDistance
				queue<pair<Node*, int>> q;
				q.push({root, 0});
				
				while(!q.empty()){
					auto t = q.front();
					q.pop();
					
					Node* cur = t.first;
					int hd = t.second;
					
					if(mp.find(hd) == mp.end()) mp[hd] = cur -> data;
					
					if(cur -> left) q.push({cur -> left, hd-1});
					if(cur -> right) q.push({cur -> right, hd+1});
				}
				
				for(auto i: mp)
					ans.push_back(i.second);
				return ans;
			}
		};

	Q.5. Bottom View of Binary Tree:
		Problem Statement:
			Given a binary tree, return an array where elements represent the bottom view of the binary tree from left to right.
			Note: If there are multiple bottom-most nodes for a horizontal distance from the root, then the latter one in the level traversal is considered. For example, in the below diagram, 3 and 4 are both the bottommost nodes at a horizontal distance of 0, here 4 will be considered.

                            20
                          /    \
                        8       22
                      /   \     /   \
                    5      3 4     25
                           /    \      
                       10       14
			For the above tree, the output should be 5 10 4 14 25.
			Examples :
			Input:
			       1
			     /   \
			    3     2
			Output: 3 1 2
			Explanation: First case represents a tree with 3 nodes and 2 edges where root is 1, left child of 1 is 3 and right child of 1 is 2.
			Thus bottom view of the binary tree will be 3 1 2.
			Input:
			         10
			       /    \
			      20    30
			     /  \
			    40   60
			Output: 40 20 60 30

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)
			Constraints:
				1 <= Number of nodes <= 10^5
				1 <= Data of a node <= 10^5
		
		class Solution {
			public:
			vector <int> bottomView(Node *root) {
				vector <int> ans;
				
				if(!root) return ans;
				map<int, int> mp;
				
				queue<pair<Node*, int>> q;
				q.push(make_pair(root, 0));
				
				while(!q.empty()){
					auto t = q.front();
					q.pop();
					
					Node* cur = t.first;
					int hd = t.second;
					
					mp[hd] = cur -> data;
					
					if(cur -> left) q.push(make_pair(cur -> left, hd-1));
					if(cur -> right) q.push(make_pair(cur -> right, hd+1));
				}
				
				for(pair<int, int> t: mp)
					ans.push_back(t.second);	
				return ans;
			}
		};

	Q.6. Diagonal Tree Traversal:
		Problem Statement:
			Given a Binary Tree, print the diagonal traversal of the binary tree.
			Consider lines of slope -1 passing between nodes. Given a Binary Tree, print all diagonal elements in a binary tree belonging to same line.
			If the diagonal element are present in two different subtress then left subtree diagonal element should be taken first and then right subtree. 
			Example 1:
			Input :
			            8
			         /     \
			        3      10
			      /   \      \
			     1     6     14
			         /   \   /
			        4     7 13
			Output : 8 10 14 3 6 7 13 1 4
			Diagonal Traversal of binary tree : 
			8 10 14 3 6 7 13 1 4
			Your Task:
				You don't need to read input or print anything. The task is to complete the function diagonal() that takes the root node as input argumets and returns the diagonal traversal of the given tree.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(N),	Here N is number of nodes.
			Constraints:
				1 <= Number of nodes<= 10^5
				1 <= Data of a node<= 10^5
	
		// Iterative approach:
			vector<int> diagonal(Node *root) {
				vector<int> ans;
				if(!root) return ans;
				
				queue<Node*> q;
				q.push(root);
				
				while(!q.empty()){
					Node* cur = q.front();
					q.pop();	
					while(cur){
						ans.push_back(cur -> data);
						
						if(cur -> left) q.push(cur -> left);
						cur = cur -> right;
					}
				}
				return ans;
			}

		// Recursive approach:
			void solve(Node* root, map<int, vector<int>> &mp, int lvl){
			if(!root) return;
			
			mp[lvl].push_back(root -> data);
			
			if(root -> left) solve(root -> left, mp, lvl+1);
			if(root -> right) solve(root -> right, mp, lvl);
			}

			vector<int> diagonal(Node *root) {
			vector<int> ans;
			map<int, vector<int>> mp;
			
			// (node, map, level)
			solve(root, mp, 0);
			
			for(auto i: mp)
				ans.insert(ans.end(), i.second.begin(), i.second.end());
			return ans;
			}

	Q.7. Right View of Binary Tree:
		Problem Statement:
			Given a Binary Tree, find Right view of it. Right view of a Binary Tree is set of nodes visible when tree is viewed from right side. Return the right view as a list. 
			Right view of following tree is 1 3 7 8.

				   1
				/     \
			    2       3
			  /   \    / \
			 4     5  6   7
			  \
			   8
			Examples :

			Input:
			   1
			 /   \
			3     2
			Output: 1 2
			Input:
				 10
				/   \
			   20    30
			 /   \
			40   60 
			Output: 10 30 60

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(Height of the Tree).

			Constraints:
				1 ≤ Number of nodes ≤ 10^5
				0 ≤ Data of a node ≤ 10^5

		/* A binary tree node has data, pointer to left child and a pointer to right child 
		struct Node {
			int data;
			struct Node* left;
			struct Node* right;
			
			Node(int x){
				data = x;
				left = right = NULL;
			}
		}; */
		// Iterative approach
			// Should return  right view of tree
			class Solution {
			public:
			//Function to return list containing elements of right view of binary tree.
			vector<int> rightView(Node *root) {
				vector<int> ans;
				queue<Node*> q;
				
				q.push(root);
				q.push(NULL);
				int val;
				
				while(!q.empty()){
					Node* cur = q.front();
					q.pop();
					
					if(!cur){
						if(!q.empty()) q.push(NULL);
						ans.push_back(val);
					}else{
						val = cur -> data;
						if(cur -> left) q.push(cur -> left);
						if(cur -> right) q.push(cur -> right);
					}
				}
				return ans;
			}
			};

		// Recursive approach
			class Solution {
				public:
				void solve(Node* root, vector<int> &ans, int lvl){
					if(!root) return;
					
					if(lvl == ans.size())
						ans.push_back(root -> data);
						
					if(root -> right) solve(root -> right, ans, lvl+1); 
					if(root -> left) solve(root -> left, ans, lvl+1); 
				}
				//Function to return list containing elements of right view of binary tree.
				vector<int> rightView(Node *root) {
					vector<int> ans;
					solve(root, ans, 0);
					return ans;
				}
			};

	Q.8. Left View of Binary Tree:
		Problem Statement:
			Given a Binary Tree, return its Left view. The left view of a Binary Tree is a set of nodes visible when the tree is visited from the Left side. If no left view is possible, return an empty array.
			Examples :
			Input: root[] = [1, 2, 3, 4, 5, 6, 7, N, 8]
				   1
				/     \
			    2       3
			 /    \    /  \
			4      5  6    7
			 \
			  8   
			Output: [1, 2, 4, 8]
			Explanation: When we view the tree from the left side, we can only see the nodes 1, 2, 4, and 8.

			Input: root[] = [1, 3, N, N, 4]
			Output: [1, 3, 4]
			
			Input: root[] = [N]
			Output: []
			
			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				0 <= Number of nodes <= 10^5
				0 <= Data of a node <= 10^5

		/* A binary tree node
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;
				
				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/
		// Iterative approach
			//Function to return a list containing elements of left view of the binary tree.
			vector<int> leftView(Node *root) {
				vector<int> ans;
				queue<Node*> q;
				q.push(root);
				q.push(NULL);
				ans.push_back(root -> data);
				
				while(!q.empty()){
					Node* cur = q.front();
					q.pop();
					
					if(!cur){
						if(!q.empty()){
							ans.push_back(q.front() -> data);
							q.push(NULL);
						}  
					}else{
						if(cur -> left) q.push(cur -> left);
						if(cur -> right) q.push(cur -> right);
					}	
				}
				return ans;
			}

		// Recursive approach
			void solve(Node* root, vector<int> &ans, int lvl){
				if(!root) return;
				if(lvl == ans.size())
					ans.push_back(root -> data);
					
				if(root -> left) solve(root -> left, ans, lvl+1); 
				if(root -> right) solve(root -> right, ans, lvl+1); 
			}
			//Function to return a list containing elements of left view of the binary tree.
			vector<int> leftView(Node *root) {
				vector<int> ans;
				// node, vetor_to_return, level
				solve(root, ans, 0);
				return ans;
			}
---------------------------------------------------------------------------------------------------------
	13/10/24
Lecture 65: Binary Tree FAANG Interview Questions || Part-3:
	Q.1. Sum of nodes on the longest path from root to leaf node:
		Problem Statement:
			Given a binary tree having n nodes. Find the sum of all nodes on the longest path from root to any leaf node. If two or more paths compete for the longest path, then the path having maximum sum of nodes will be considered.
			Example 1:
			Input: 
			         4        
			       /   \       
			      2     5      
			     / \   / \     
			    7   1 2   3    
			       /
			      6
			Output: 13
			Explanation:
			         4        
			       /   \       
			      2     5      
			     / \   / \     
			    7   1 2   3  
			       /
			      6
			The highlighted nodes (4, 2, 1, 6) above are part of the longest root to leaf path having sum = (4 + 2 + 1 + 6) = 13
			Example 2:
			Input: 
			          1
			        /   \
			       2     3
			      / \   / \
			     4   5 6   7
			Output: 
			11
			Explanation:
			Use path 1->3->7, with sum 11.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function sumOfLongRootToLeafPath() which takes root node of the tree as input parameter and returns an integer denoting the sum of the longest root to leaf path of the tree.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 <= n <= 10^5
				0 <= data of each node <= 10^4

		/*
			structure of the node of the binary tree is as
			struct Node {
				int data;
				struct Node *left;
				struct Node *right;

				Node(int x) {
					data = x;
					left = NULL;
					right = NULL;
				}
			};
		*/
		class Solution {
			public:
			void mxLongPathSum(Node* root, int curSum, int &mxSum, int curLen, int &mxLen){
				if(!root) return ;
				
				curSum += root -> data;
				if((!root -> left && !root -> right) && curLen >= mxLen){
					if(curLen > mxLen) mxSum = curSum;
					else mxSum = max(mxSum, curSum);
					mxLen = curLen;
				}
				
				mxLongPathSum(root -> left, curSum, mxSum, curLen+1, mxLen);
				mxLongPathSum(root -> right, curSum, mxSum, curLen+1, mxLen);
			}
			int sumOfLongRootToLeafPath(Node *root) {
				int mxSum, curSum, curLen, mxLen;
				mxSum = curSum = curLen = mxLen = 0;
				
				mxLongPathSum(root, curSum, mxSum, curLen+1, mxLen);
				return mxSum;
			}
		};

	Q.2. LCA in Binary Tree:
		Problem Statement:
			Given a Binary Tree with all unique values and two nodes value, n1 and n2. The task is to find the lowest common ancestor of the given two nodes. We may assume that either both n1 and n2 are present in the tree or none of them are present.
			LCA: It is the first common ancestor of both the nodes n1 and n2 from bottom of tree.
			Example 1:
			Input:
			n1 = 2 , n2 = 3  
			       1 
			      / \ 
			     2   3
			Output: 1
			Explanation:
			LCA of 2 and 3 is 1.
			Example 2:
			Input:
			n1 = 3 , n2 = 4
		           5    
		          /    
		         2  
		        / \  
		       3   4
			Output: 2
			Explanation:
			LCA of 3 and 4 is 2. 
			Example 3:
			Input:
			n1 = 5 , n2 = 4
		           5    
		          /    
		         2  
		        / \  
		       3   4
			Output: 5
			Explanation:
			LCA of 5 and 4 is 5. 
			Your Task:
				You don't have to read, input, or print anything. Your task is to complete the function lca() that takes nodes, n1, and n2 as parameters and returns the LCA node as output. 

			Expected Time Complexity:O(N).
			Expected Auxiliary Space:O(Height of Tree).
			Constraints:
				1 ≤ Number of nodes ≤ 10^5
				1 ≤ Data of a node ≤ 10^5

		/* A binary tree node
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;
				
				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/
		class Solution {
			public:
			//Function to return the lowest common ancestor in a Binary Tree.
			Node* lca(Node* root ,int n1 ,int n2 ) {
				if(root -> data == n1 || root -> data == n2) return root;

				Node* leftAns = NULL;
				Node* rightAns = NULL;
				
				if(root -> left) leftAns = lca(root -> left, n1, n2);
				if(root -> right) rightAns = lca(root -> right, n1, n2);
				
				if(leftAns && rightAns) return root;
				else if(leftAns && !rightAns) return leftAns;
				else if(!leftAns && rightAns) return rightAns;
				else return NULL;
			}
		};

		// Practiced:
			class Solution {
				public:
				//Function to return the lowest common ancestor in a Binary Tree.
				Node* lca(Node* root ,int n1 ,int n2 ) {
					if(!root) return NULL;
					if(root -> data == n1 || root -> data == n2) return root;
					
					Node* left = lca(root -> left, n1, n2);
					Node* right = lca(root -> right, n1, n2);
					
					if(left && right) return root;			// if both side (left & right) are not null then current element (root), will be the answer
					else if(!left && right) return right;		// if left is null then right side will be passed as answer
					else return left;						// else left side is answer		(in short, the side which is not null will passed as answer)
				}
			};

	Q.3. K Sum Paths:
		Problem Statement:
			Given a binary tree and an integer k, the task is to count the number of paths in the tree such that the sum of the nodes in each path equals k. A path can start from any node and end at any node and must be downward only.
			Examples:
			Input: Tree =    1  	
						/   \                          
					    2     3
			k = 3                               
			Output: 2
			Explanation:
			Path 1 : 1 + 2 = 3
			Path 2 : only leaf node 3
			
			Input: Tree = 8  k = 7  
			            /   \
			          4      5
			         /   \       \
			       3     2       2                        
			      /   \     \                    
			    3    -2    1       
			Output: 3
			Input Tree =
					  7 
				     /   \
				    4     5 
				  /   \    \
				 3     2    2 
				/ \   / \  
			    0  -2 N   1 
			k=7
			output: 5

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(height of Tree)
			Constraints:
				1 ≤ number of nodes ≤ 2*10^4
				-10^5 ≤ node value ≤ 10^5
				-10^9 ≤ k ≤ 10^9

		// User function template for C++
		/*
			struct Node {
				int data;
				Node *left;
				Node *right;

				Node(int val) {
					data = val;
					left = right = NULL;
				}
			};
		*/
		class Solution {
			public:
			void solve(Node* root, int k, int &cnt, vector<int> pathValues){
				if(!root)  return ;
				pathValues.push_back(root -> data);
				
				solve(root -> left, k, cnt, pathValues);        // left
				solve(root -> right, k, cnt, pathValues);       // right
				
				int sum = 0;
				for(int i=pathValues.size()-1; i>=0; i--){
					sum += pathValues[i];
					if(sum == k) cnt++;
				}
			}
			int sumK(Node *root, int k) {
				vector<int> pathValues;
				int cnt=0;
				
				solve(root, k, cnt, pathValues);
				return cnt;
			}
		};

	Q.4. Kth Ancestor in a Tree:
		Problem Statement:
			Given a binary tree of size  N, a node, and a positive integer k., Your task is to complete the function kthAncestor(), the function should return the kth ancestor of the given node in the binary tree. If there does not exist any such ancestor then return -1.
			Note:
				1. It is guaranteed that the node exists in the tree.
				2. All the nodes of the tree have distinct values.

			Example 1:
				 1
				/ \
			    2   3
			   / \
			  4	 5
			Input:
			K = 2 Node = 4
			Output: 1
			Explanation:
			Since, K is 2 and node is 4, so we
			first need to locate the node and
			look k times its ancestors.
			Here in this Case node 4 has 1 as his
			2nd Ancestor aka the Root of the tree.
			Example 2:

			Input:
			k=1 
			node=3
				 1
				/ \
			    2   3
			Output:
			1
			Explanation:
			K=1 and node=3 ,Kth ancestor of node 3 is 1.
			Your Task:
				You are asked to complete the function kthAncestor() which accepts root of the tree, k and node as input parameters, and returns the kth ancestor of Node which contains node as its value.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)
			Constraints:
				1<=N<=10^5
				1<= K <= 100
				1 <= Node.data <= N

		    Structure of the node of the binary tree is as
		
		//User function Template for C++
		/*
			struct Node {
				int data;
				struct Node *left, *right;
			};
		*/

		void traverse(Node* root, vector<int> &path, int node){
			if(!root) return;
			path.push_back(root -> data);
			if(root -> data == node)	return ;
		
			traverse(root -> left, path, node);
			traverse(root -> right, path, node);

			if(path.back() != node) path.pop_back();
		}
		int kthAncestor(Node *root, int k, int node) {
			int ans = -1;
			vector<int> pathOfK;
			traverse(root, pathOfK, node);
			
			int i=pathOfK.size()-1;
			while(k--) --i;
			
			if(i>=0) ans = pathOfK[i];
			return ans;
		}

		// Approach-2
			/*
				Structure of the node of the binary tree is as
				struct Node {
					int data;
					struct Node *left, *right;
				};
			*/

			int solve(Node* n, int &k, int search_value){
				if(!n) return -1;

				if(n -> data == search_value) return search_value;

				int left = solve(n -> left, k, search_value);
				int right = solve(n -> right, k, search_value);
			
				if(left != -1 && right == -1){
					k--;
					if(k < 0) return left;
					return n -> data;
				}

				if(left == -1 && right != -1){
					k--;
					if(k < 0) return right;
					return n -> data;
				}
				return -1;
			}

			int kthAncestor(Node *root, int k, int node) {
				// if(!root || (root -> data == node)) return -1;
				int ans = solve(root, k, node);
				return (k > 0) ? -1 : ans;
			}

	Q.5. Maximum sum of Non-adjacent nodes:
		Problem Statement:
			Given a binary tree with a value associated with each node, we need to choose a subset of these nodes such that sum of chosen nodes is maximum under a constraint that no two chosen node in subset should be directly connected that is, if we have taken a node in our sum then we can’t take its any children or parents in consideration and vice versa.
			Example 1:
			Input:
			     11
			    /  \
			   1    2
			Output: 11
			Explanation: The maximum sum is sum of
			node 11.
			Example 2:
			Input:
			        1
			      /   \
			     2     3
			    /     /  \
			   4     5    6
			Output: 16
			Explanation: The maximum sum is sum of
			nodes 1 4 5 6 , i.e 16. These nodes are
			non adjacent.
			Your Task:
				You don't need to read input or print anything. You just have to complete function getMaxSum() which accepts root node of the tree as parameter and returns the maximum sum as described.

			Expected Time Complexity: O(Number of nodes in the tree).
			Expected Auxiliary Space: O(Height of the Tree).
			Constraints:
				1 ≤ Number of nodes in the tree ≤ 10000
				1 ≤ Value of each node ≤ 100000

		//Node Structure
		/*
			struct Node {
				int data;
				Node* left;
				Node* right;
			};
		*/
		class Solution{
			public:
			pair<int, int> solve(Node* root){
				if(!root) return {0,0};
				
				auto left = solve(root -> left);
				auto right = solve(root -> right);
				
				int first = left.second + right.second + root -> data;
				int second = max(left.first, left.second) + max(right.first, right.second);
				return {first, second};
			};
			//Function to return the maximum sum of non-adjacent nodes.
			int getMaxSum(Node *root) {
				auto ans = solve(root);
				return max(ans.first, ans.second);
			}
		};
---------------------------------------------------------------------------------------------------------
	18/10/24
Lecture 66: Construct a Binary Tree from InOrder/PreOrder/PostOrder Traversal:
	Q.1. Construct Tree from Inorder & Preorder:
		Problem Statement:
			Given two arrays of inorder and preorder traversal of size n. Construct a tree using the inorder and preorder arrays and return the root node of the constructed tree.
			Example 1:
			Input:
			n = 4
			inorder[] = {1 6 8 7}
			preorder[] = {1 6 7 8}
			Output: 8 7 6 1

			Example 2:
			Input:
			n = 6
			inorder[] = {3 1 4 0 5 2}
			preorder[] = {0 1 3 4 2 5}
			Output: 3 4 1 5 2 0
			Explanation: The tree will look like
			       0
			    /     \
			   1       2
			 /   \    /
			3    4   5
			Your Task:
				Your task is to complete the function buildTree() which takes 3 arguments(inorder traversal array, preorder traversal array, and size of tree n) and returns the root node to the tree constructed. You are not required to print anything and a new line is added automatically (The post order of the returned tree is printed by the driver's code.)

			Expected Time Complexity: O(n*n).
			Expected Auxiliary Space: O(n).
			Constraints:
				1<= n <=1000
				inorder and preorder arrays contain unique values

		/*Complete the code here.
			Node is as follows:
			struct Node {
				int data;
				Node* left;
				Node* right;
			};
		*/
		class Solution{
			public:
			int findInInorder(int in[], int ele, int n){
				for(int i=0; i<n; i++)
					if(in[i] == ele) return i;
				return -1;
			}
			Node* solve(int in[], int pre[], int n, int start, int end, int &index){
				if(index >= n || end < start) return NULL;
				int element = pre[index++];
				Node* root = new Node(element);
				
				int pos = findInInorder(in, element, n);
				root -> left = solve(in, pre, n, start, pos-1, index);
				root -> right = solve(in, pre, n, pos+1, end, index);
				
				return root;
			}
			Node* buildTree(int in[],int pre[], int n) {
				int index = 0;
				return solve(in, pre, n, 0, n-1, index);
			}
		};

	Q.2. Binary Tree from Inorder and Postorder:
		Problem Statement:
			Given inorder and postorder traversals of a binary tree(having n nodes) in the arrays inorder[] and postorder[] respectively. The task is to construct a unique binary tree from these traversals and return its root.
			Driver code will print the preorder traversal of the constructed tree.

			Note: The inorder and postorder traversals contain unique values, and every value present in the postorder traversal is also found in the inorder traversal.

			Examples:
			Input: inorder[] = [4, 8, 2, 5, 1, 6, 3, 7], postorder[] = [8, 4, 5, 2, 6, 7, 3, 1]
			Output: [1, 2, 4, 8, 5, 3, 6, 7]
			Explanation: For the given postorder and inorder traversal of tree the resultant binary tree will be
			          1
			       /      \
			     2        3
			   /  \      /  \
			  4   5     6    7
			   \
			    8
			Input: inorder[] = [9, 5, 2, 3, 4], postorder[] = [5, 9, 3, 4, 2]
			Output: [2, 9, 5, 4, 3]
			Explanation: The resultant binary tree will be
			      2
			   /     \
			  9      4
			   \     /
			    5   3
			Constraints:
				1 <= number of nodes <= 10^3
				1 <= in[i], post[i] <= 10^6

		/* Tree node structure
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;

				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/

		class Solution {
			public:
			// Function to return a tree created from postorder and inoreder traversals.
			Node* solve(vector<int> &in, vector<int> &post, int s, int e, int &idx){
				if(idx < 0 || s > e) return NULL;
				
				int element = post[idx--], n = in.size();
				Node* root = new Node(element);
				int position = -1;

				for(int i=s; i<=e; i++)
					if(in[i] == element){
						position = i;
						break;
					}
				
				root -> right = solve(in, post, position+1, e, idx);
				root -> left = solve(in, post, s,position-1, idx);
				return root;
			}
			Node* buildTree(vector<int> inorder, vector<int> postorder) {
				int n = postorder.size();
				int index = n-1;
				return solve(inorder, postorder, 0, n-1, index);
			}
		};

	// we can use map for above codes to find the position of element instead of for loop looping for every function call
	Q. From Inorder & Postorder:
		class Solution {
			public:
			map<int, int> positions;
			// Function to return a tree created from postorder and inoreder traversals.
			Node* solve(vector<int> &in, vector<int> &post, int s, int e, int &idx){
				if(idx < 0 || s > e) return NULL;
				
				int element = post[idx--], n = in.size();
				Node* root = new Node(element);
				
				int position = positions[element];
				root -> right = solve(in, post, position+1, e, idx);
				root -> left = solve(in, post, s,position-1, idx);
				return root;
			}
			Node* buildTree(vector<int> inorder, vector<int> postorder) {
				int n = postorder.size(), index = n-1;
				
				for(int i=0; i<n; i++) positions[inorder[i]] = i;
				return solve(inorder, postorder, 0, n-1, index);
			}
		};
---------------------------------------------------------------------------------------------------------
	19/10/24
Lecture 67: Minimum Time to BURN the Entire Binary Tree:
	Q. Burning Tree:
		Problem Statement:
			Given a binary tree and a node data called target. Find the minimum time required to burn the complete binary tree if the target is set on fire. It is known that in 1 second all nodes connected to a given node get burned. That is its left child, right child, and parent.
			Note: The tree contains unique values.
			Examples : 
			Input:      
			         1
			       /   \
			     2      3
			   /  \      \
			  4    5      6
			      / \      \
			     7   8      9
			                  \
			                  10
			Target Node = 8
			Output: 7
			Explanation: If leaf with the value 8 is set on fire. 
			After 1 sec: 5 is set on fire.
			After 2 sec: 2, 7 are set to fire.
			After 3 sec: 4, 1 are set to fire.
			After 4 sec: 3 is set to fire.
			After 5 sec: 6 is set to fire.
			After 6 sec: 9 is set to fire.
			After 7 sec: 10 is set to fire.
			It takes 7s to burn the complete tree.
			Input:      
			          1
			        /   \
			      2      3
			    /  \      \
			   4    5      7
			  /    / 
			 8    10
			Target Node = 10
			Output: 5
			Expected Time Complexity: O(number of nodes)
			Expected Auxiliary Space: O(height of tree)

			Constraints:
				1 ≤ number of nodes ≤ 10^5
				1 ≤ values of nodes ≤ 10^5

		/*
			struct Node {
				int data;
				Node *left;
				Node *right;

				Node(int val) {
					data = val;
					left = right = NULL;
				}
			};
		*/
		class Solution {
			public:
			map<Node*, Node*> nodeTheirParent;
			Node* findTarget_nodeToParentMapping(Node* n, int tar){
				Node* res = NULL;
				
				// Level Order Traversal
				queue<Node*> q;
				q.push(n);
				nodeTheirParent[n] = NULL;		
				while(!q.empty()) {
					Node* front = q.front();
					q.pop();
					
					if(front -> data == tar) res = front;           // finding the position of target in tree 
					if(front -> left){
						nodeTheirParent[front -> left] = front;
						q.push(front -> left);
					}
					
					if(front -> right) {
						nodeTheirParent[front -> right] = front;
						q.push(front -> right);
					}
				}
				return res;
			}
			void burning(Node* targetNode, int &ans){
				map<int, bool> visited;
				queue<Node*> q;
				q.push(targetNode);
				visited[targetNode -> data] = 1;
				
				while(!q.empty()){
					int size = q.size();
					int flag = 0;               // we never pushed anything into queue
					
					for(int i=0; i<size; i++){      
						Node* front = q.front();
						q.pop();
						
						// if left side is present & its not visited then consider it
						if(front -> left && !visited[front -> left -> data]){
							flag = 1;               // pushed, some change happened in queue
							q.push(front -> left);
							visited[front -> left -> data] = 1;
						}
						
						// if right side is present & its not visited then consider it
						if(front -> right && !visited[front -> right -> data]){           
							flag = 1;
							q.push(front -> right);
							visited[front -> right -> data] = 1;
						}
						
						// if parent are NOT visited then consider them also
						if(nodeTheirParent[front] && !visited[nodeTheirParent[front] -> data]){
							flag = 1;
							q.push(nodeTheirParent[front]);
							visited[nodeTheirParent[front] -> data] = 1;
						}
					}
					if(flag) ans++;
				}
			}
			int minTime(Node* root, int target) {
				int time=0;
				Node* targetNode = findTarget_nodeToParentMapping(root, target);
				burning(targetNode, time);
				return time;
			}
		};
---------------------------------------------------------------------------------------------------------
	20/10/24
Lecture 68: Morris Traversal Flatten a Binary tree to Linked List:
	Q. Iterative Inorder:
		Problem Statement:
			Given a binary tree. Find the inorder traversal of the tree without using recursion.
			Example 1
			Input:
			          1
			        /    \
			       2       3
			     /   \
			    4     5
			Output: 4 2 5 1 3
			Explanation:
			Inorder traversal (Left->Root->Right) of 
			the tree is 4 2 5 1 3.
			Example 2
			Input:
				    8
				/        \
			    1          5
				\       /  \
				 7    10   6
			       \   /
				  10 6
			Output: 1 7 10 8 6 10 5 6
			Explanation:
			Inorder traversal (Left->Root->Right) 
			of the tree is 1 7 10 8 6 10 5 6.

			Your task:
				You don't need to read input or print anything. Your task is to complete the function inOrder() which takes the root of the tree as input and returns a list containing the inorder traversal of the tree, calculated without using recursion.

			Expected time complexity: O(N)
			Expected auxiliary space: O(N)

			Constraints:
				1 <= Number of nodes <= 10^5
				1 <= Data of a node <= 10^5

		// Morris Traversal: TC: O(N) & SC: O(1)
			/* Tree Node
				struct Node {
					int data;
					Node* left;
					Node* right;
				};
			*/
			class Solution {
				public:
				vector<int> inOrder(Node* root) {
					vector<int> ans;
					
					while(root){
						if(root -> left){
							Node* pred = root -> left;
							while(pred -> right && pred -> right != root) pred = pred -> right;			// keep going to right till you encounter NULL or same address as root is standing
							
							if(pred -> right){          // if not NULL
								pred -> right = NULL;			// make it NULL
								ans.push_back(root -> data);
								root = root -> right;
							}else{
								pred -> right = root;
								root = root -> left;
							}
						}else{
							ans.push_back(root -> data);
							root = root -> right;
						}
					}
					return ans;
				}
			};

		// Or
			class Solution {
				public:
				vector<int> inOrder(Node* root) {
					vector<int> ans;
					stack<Node*> st;
					while(root or !st.empty()){                                 // while(root != NULL || !st.empty()) {}
						while(root){
							st.push(root);
							root = root -> left;
						}
						root = st.top();
						st.pop();
						ans.push_back(root -> data);
						root = root -> right;
					}
					return ans;
				}
			};

	Q. Flatten binary tree to linked list:
		Problem Statement:
			Given the root of a binary tree, flatten the tree into a "Linked list":
			The "linked list" should use the same Node class where the right child pointer points to the next node in the list and the left child pointer is always null.
			The "linked list" should be in the same order as a pre-order traversal of the binary tree.
			Examples:
			Input: 
			      1
			    /   \
			   2     5
			  / \     \
			 3   4     6
			Output : 1 2 3 4 5 6 
			Explanation: After flattening, the tree looks like this - 
			 1
			  \
			   2
			    \
			     3
			      \
			       4
			        \ 
			         5 
			          \
			           6
			Here, left of each node points to NULL and right contains the next node in preorder.The inorder traversal of this flattened tree is 1 2 3 4 5 6.
			Input :
			   1
			  / \
			 3   4
			    /
			   2
			    \
			     5 
			Output : 
			1 3 4 2 5 
			Explanation : After flattening, the tree looks like this -
			    1
			     \
			      3
			       \
			        4
			         \
			          2
			           \ 
			            5 
			Here, left of each node points to NULL and right contains the next node in preorder.The inorder traversal of this flattened tree is 1 3 4 2 5.
			Expected Time Complexity: O(n)
			Expected Space Complexity: O(1)
			Constraints :
				1<= number of nodes in binary tree <= 10^5
				1<= data of nodes <= 10^5

		// Using Morring Algorithm:
			class Solution {
				public:
				void flatten(Node *root) {
					while(root){
						if(root -> left){
							Node* pred = root -> left;
							
							while(pred -> right) pred = pred -> right;
							
							pred -> right = root -> right;
							root -> right = root -> left;
							root -> left = NULL;
						}
						root = root -> right;
					}
				}
			};
---------------------------------------------------------------------------------------------------------
	23/11/24
Lecture 69: Binary Search Tree & its Implementation || Insertion, Deletion & Searching a Node:
	// Binary Search Tree:
		#include <iostream>
		#include <queue>
		using namespace std;

		class TreeNode {
			public:
				int data;
				TreeNode *left, *right;
		};

		TreeNode* CreateNode(int x){
			TreeNode* node = new TreeNode();
			node -> left = node -> right = NULL;
			node -> data = x;
			return node;
		}

		TreeNode* insertIntoBST(TreeNode* &root, int x) {
			if(root == NULL) {                                    // if(!root)
				root = CreateNode(x);
				return root;
			}
			if(root -> data < x) root -> right = insertIntoBST(root -> right, x);
			else root -> left = insertIntoBST(root -> left, x);
			return root;
		}

		void BinarySearchTree(TreeNode* &root){
			std::cout << "Enter root data: ";
			int n;
			std::cin >> n;

			while(n != -1) {
				insertIntoBST(root, n);
				cin >> n;
			}
		}

		void L_O_T(TreeNode* root){
			if(!root) return;

			queue<TreeNode*> q;
			q.push(root);
			q.push(NULL);

			while(!q.empty()){
				TreeNode* cur = q.front();
				q.pop();

				if(!cur){
					if(not q.empty()) q.push(NULL);
					cout<<endl;
				}else{
					std::cout << cur -> data<<"\t";
					if(cur -> left) q.push(cur -> left);
					if(cur -> right) q.push(cur -> right);
				}
			}
		}

		// Traversals:
		void InOrder(TreeNode* root){
			if(!root) return ;
			
			InOrder(root -> left);
			std::cout << root -> data <<"\t";
			InOrder(root -> right);
		}

		void PreOrder(TreeNode* root){
			if(!root) return ;
			
			std::cout << root -> data <<"\t";
			PreOrder(root -> left);
			PreOrder(root -> right);
		}

		void postOrder(TreeNode* root){
			if(!root) return ;
			
			postOrder(root -> left);
			postOrder(root -> right);
			std::cout << root -> data <<"\t";
		}

		int main() {
			// creating binary search tree
			TreeNode *root = NULL;
			BinarySearchTree(root);
			//           5
			//      3        7
			// 1       4  6     9
			//   2            8  10
			// -1
			
			std::cout << endl << "Level Order Traversal: " << std::endl;
			L_O_T(root);
			
			std::cout << endl << "InOrder Traversal: " << std::endl;            // 1 2 3 4 5 6 7 8 9 10
			InOrder(root);
			
			std::cout << endl << "PreOrder Traversal: " << std::endl;           // 5 3 1 2 4 7 6 9 8 10
			PreOrder(root);
			
			std::cout << endl << "postOrder Order Traversal: " << std::endl;    // 2 1 4 3 6 8 10 9 7 5
			postOrder(root);
			return 0;
		}

	Q. Search In BST:
		Problem Statement:
			There is a Binary Search Tree (BST) consisting of ‘N’ nodes. Each node of this BST has some integer data.
			You are given the root node of this BST, and an integer ‘X’. Return true if there is a node in BST having data equal to ‘X’, otherwise return false.
			A binary search tree (BST) is a binary tree data structure that has the following properties:
			1. The left subtree of a node contains only nodes with data less than the node’s data.
			2. The right subtree of a node contains only nodes with data greater than the node’s data.
			3. The left and right subtrees must also be binary search trees.
			Note:
			It is guaranteed that all nodes have distinct data.
			Sample Input 1:
			7 8
			4 2 6 1 3 5 7 -1 -1 -1 -1 -1 -1 -1 -1
			Sample Output 1:
			False
			Explanation For Sample Input 1:
			There is no node having data 8. See the problem statement for the picture of this BST.
			Sample Input 2:
			4 1
			3 1 5 -1 2 -1 -1 -1 -1
			Sample Output 2:
			True
			Explanation For Sample Input 1:
			There is a left node, and it has data 1. Thus, we should print ‘True’. 
			Constraints:
				1 <= N <= 10000
				0 <= X <= 10^9
				0 <= DATA <=10^9

			Where ‘N’ is the number of nodes in the BST, ‘X’ is a given integer and ‘DATA’ is the data contained in each node of BST.
			Time limit: 1 sec	
		/*
			Following is the Binary Tree node structure:
			template <typename T>
			class BinaryTreeNode {
				public:
					T data;
					BinaryTreeNode<T> *left, *right;
					BinaryTreeNode() : data(0), left(NULL), right(NULL) {}
					BinaryTreeNode(T x) : data(x), left(NULL), right(NULL) {}
					BinaryTreeNode(T x, BinaryTreeNode<T> *left, BinaryTreeNode<T> *right) : data(x), left(left), right(right) {}
			};
		*/
		// Iterative Approach: TC: O(H), SC: O(1), Where 'H' is the height of the given BST.
			bool searchInBST(BinaryTreeNode<int> *root, int x) {
				while(root){
					if(root -> data == x) return 1;
					else if(root -> data < x) root = root -> right;
					else root = root -> left;
				}
				return 0;
			}

		// Recursive Approach: TC O(H), SC: O(H)
			bool searchInBST(BinaryTreeNode<int> *root, int x) {
				if(!root) return 0;

				if(root -> data == x) return 1;
				else if(root -> data < x) return searchInBST(root -> right, x);
				else return searchInBST(root -> left, x);
			}

	- Insertion in BST TC: O(log n)
	- Inorder of BST is sorted
	- min value of BST lies on left side
	- max value of BST lies on right side

	// Practice:
		#include <bits/stdc++.h>
		using namespace std;
		class TreeNode{
			public:
				int data;
				TreeNode *left, *right;
				
				TreeNode(int data){
					this -> data = data;
					left = right = NULL;
				}
		};
		void InsertIntoBST(TreeNode * &root, int data){
			if(!root){
				root = new TreeNode(data);
				return ;
			}
			
			if(root -> data < data) InsertIntoBST(root -> right, data);
			else InsertIntoBST(root -> left, data);
		}
		TreeNode* BuildBST(){
			TreeNode *root;
			std::cout << "Enter root data: " << std::endl;
			int val;
			cin>>val;
			
			while(val != -1){
				InsertIntoBST(root, val);
				cout<<"enter value of TreeNode, Enter -1 to abort :";
				cin>>val;
			}
			return root;
		}
		void LOT(TreeNode *n){
			if(!n) return;          // if(n == NULL)
			queue<TreeNode*> q;
			q.push(n);
			q.push(NULL);
			
			while(!q.empty()){
				TreeNode *cur = q.front();
				q.pop();
				
				if(cur == NULL){
					if(!q.empty()) q.push(NULL);
					std::cout << std::endl;
				}else{
					cout<< cur -> data <<"\t";
					if(cur -> left) q.push(cur -> left);
					if(cur -> right) q.push(cur -> right);
				}
			}
		}
		int minValue(TreeNode *root){
			int val = root -> data;
			while(root){
				val = root -> data;
				root = root -> left;
			}
			return val;
		}
		int maxValue(TreeNode *root){
			int val = root -> data;
			while(root){
				val = root -> data;
				root = root -> right;
			}
			return val;
		}
		int main(){
			TreeNode *root = BuildBST();
			std::cout << std::endl;
			std::cout << "Tree: " << std::endl;
			LOT(root);
			
			std::cout << "Min Value :" << minValue(root) << std::endl;
			std::cout << "Max Value :" << maxValue(root) << std::endl;
			return 0;
		}

	// Homework:
		1) Inorder predecessor
		2) Inorder successor (POTD 1118)
		Code:
			/* BST Node
			struct Node {
				int key;
				struct Node *left, *right;
				Node(int x){
					key = x;
					left = right = NULL;
				}
			};
			*/
			// This function finds predecessor and successor of key in BST.
			// It sets pre and suc as predecessor and successor respectively
			class Solution {
				public:
				void findPreSuc(Node* root, Node*& pre, Node*& suc, int key) {
					while(root){
						if(root -> key < key){
							pre = root;
							root = root -> right;
						}else if(root -> key > key){
							suc = root;
							root = root -> left;
						}else{
							// finding predecessor
							Node* temp = root -> left;
							while(temp){
								pre = temp;
								temp = temp -> right;
							}
							
							// finding successor
							temp = root -> right;
							while(temp){
								suc = temp;
								temp = temp -> left;
							}
							break;
						}
					}
				}
			};

			// or
				class Solution {
					public:
					void findPreSuc(Node* root, Node*& pre, Node*& suc, int key) {
						while(root and root -> key != key){
							if(root -> key < key){
								pre = root;
								root = root -> right;
							}else if(root -> key > key){
								suc = root;
								root = root -> left;
							}
						}
						if(!root) return;
						
						Node* temp = root;
						temp = temp -> left;
						while(temp){
							pre = temp;
							temp = temp -> right;
						}
						
						temp = root;
						temp = temp -> right;
						while(temp){
							suc = temp;
							temp = temp -> left;
						}
					}
				};

	Q. Delete a node from BST:
		Problem Statement:
			Given a Binary Search Tree and a node value x. Delete the node with the given value x from the BST. If no node with value x exists, then do not make any change. Return the root of the BST after deleting the node with value x. Do not make any update if there's no node with value x present in the BST.
			Note: The generated output will be the inorder traversal of the modified tree.
			Examples :
			Input: root = [2, 1, 3]
 			     2
 			   /   \
 			  1     3
			x = 12
			Output: 1 2 3
			Explanation: In the given input there is no node with value 12 , so the tree will remain same.
			Input: root = [1, N, 2, N, 8, 5, 11, 4, 7, 9, 12]
		       1
		        \
		         2
		           \
		            8 
		          /    \
		         5      11
		       /  \    /  \
		      4    7  9   12
			x = 9
			Output: 1 2 4 5 7 8 11 12
			Explanation: In the given input tree after deleting 9 will be
			  1
			   \
			    2
			      \
			       8
			      /   \
			     5     11
			    /  \     \
			   4    7     12 
			Input: root = [2, 1, 3]
			     2
			   /   \
			  1     3
			x = 3
			Output: 1 2
			Constraints:
				1 <= n <= 10^5
		
		// Using successor:
			class Solution {
				public:
				int getSuccessor(Node* n){
					int ans = n -> data;
					while(n){
						ans = n -> data;
						n = n -> left;
					}
					return ans;
				}
				// Function to delete a node from BST.
				Node *deleteNode(Node *root, int X) {
					if(!root) return NULL;
					
					if(root -> data == X){
						// 0 child or 1 child
						if(root -> left == NULL || root -> right == NULL){
							Node* temp = (root -> left) ? root -> left : root -> right; 
							delete root;
							return temp;
						}
						/*
							// 0 child 
							if(root -> left == NULL and root -> right == NULL){
								delete root;
								return NULL;
							}
							
							// 1 child
							if(root -> left and root -> right == NULL){
								Node* temp = root -> left;
								delete root;
								return temp;
							}
							
							if(root -> left == NULL and root -> right){
								Node* temp = root -> right;
								delete root;
								return temp;
							}
						*/
						
						// 2 child
						int successor = getSuccessor(root -> right);
						root -> data = successor;
						root -> right = deleteNode(root -> right, successor);
					}else if(root -> data < X){
						root -> right = deleteNode(root -> right, X);
					}else{
						root -> left = deleteNode(root -> left, X);
					}
					return root;
				}
			};
		
		// Using predecessor:
			class Solution {
				public:
				int getPredecessor(Node* n){
					while(n->right) n = n -> right;
					return n->data;
				}
				// Function to delete a node from BST.
				Node *deleteNode(Node *root, int X) {
					if(!root) return NULL;
					
					if(root -> data < X){
						root -> right = deleteNode(root -> right, X);
					}else if(root -> data > X){
						root -> left = deleteNode(root -> left, X);
					}else{
						// 0 or 1 child
						if(!root -> left or !root -> right){
							Node* temp = (root -> left) ? root -> left : root -> right;
							delete root;
							return temp;
						}
						
						// 2 childs
						int predecessor = getPredecessor(root -> left);
						root -> data = predecessor;
						root -> left = deleteNode(root -> left, predecessor);
					}
					return root;
				}
			};

		// Iterative with successor:
			class Solution {
				public:
				pair<int, Node*> getSuccessor(Node* n){
					Node* parent = n;
					Node* cur = n -> right;
					while(cur -> left){
						parent = cur;
						cur = cur -> left;
					} 
					return {cur->data, parent};
				}

				Node *deleteNode(Node *root, int X) {
					Node* temp = root;
					Node* MainParent = root;
					while(temp and temp -> data != X){
						MainParent = temp;
						if(temp -> data > X) temp = temp -> left;
						else temp = temp -> right;
					}
					
					// if temp == NULL
					if(!temp) return root;

					// key needs to be deleted is found
					// 0 or 1 children
					if(!temp -> left or !temp -> right){
						Node* replacement = (temp->right) ? temp -> right : temp -> left;
						
						// this means the root element is the element needs to be deleted
						// then delete the root node & return its present part which we stored in replacement
						// either left or right
						if(MainParent == temp) {
							delete temp;
							return replacement;
						}
						
						// identifying which side of parent the temp is present
						if(MainParent -> left == temp) MainParent -> left = replacement;
						else MainParent -> right = replacement;
						
						delete temp;
						return root;
					}
					
					// 2 children
					pair<int, Node*> PairValues = getSuccessor(temp);
					temp -> data = PairValues.first;
					Node* parent = PairValues.second;
					
					// for sure there will be leftside of parent present
					Node* deleting = NULL;
					if(parent -> left -> data  == temp -> data){
						deleting = parent -> left;
						parent -> left = deleting -> right;
					}else{
						deleting = parent -> right;
						parent -> right = deleting -> right;
					}
					
					delete deleting;
					return root;
				}
			};

		// Iterative with predecessor:
			class Solution {
				public:
				pair<int, Node*> getPredecessor(Node* n){
					Node* Parent = n;
					n = n -> left;
					while(n -> right){
						Parent = n;
						n = n -> right;
					}
					return {n -> data, Parent};
				}
				Node *deleteNode(Node *root, int X) {
					Node* temp = root;
					Node* MainParent = root;
					while(temp and temp -> data != X){
						MainParent = temp;
						if(temp->data < X) temp = temp -> right;
						else temp = temp -> left;
					}
					
					// key not found
					if(!temp) return root;
					
					if(!temp -> left || !temp->right){
						Node* replace = (temp->left) ? temp-> left : temp -> right;
						
						if(MainParent == temp) {
							delete temp;
							return replace;
						}
						
						(MainParent -> left == temp) ?  MainParent -> left = replace : MainParent -> right = replace;
						delete temp;
					}else{
						// to find the Predecessor we need to send the MainParent
						pair<int, Node*> PairValues = getPredecessor(temp);
						int predecessor = PairValues.first;
						temp -> data = predecessor;
						Node* Parent = PairValues.second;
						
						Node* deletingNode = NULL;
						if(Parent -> right -> data == predecessor){
							deletingNode = Parent -> right;
							Parent -> right =  deletingNode -> left;
						}else{
							deletingNode = Parent -> left;
							Parent -> left = deletingNode -> left;
						}
						delete deletingNode;
					}
					return root;
				}
			};

	Q. Delete Node in a BST:
		Problem Statement:
			Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.
			Basically, the deletion can be divided into two stages:
			Search for a node to remove.
			If the node is found, delete the node.
			Example 1:
			Input: root = [5,3,6,2,4,null,7], key = 3
			Output: [5,4,6,2,null,null,7]
			Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
			One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
			Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.

			Example 2:
			Input: root = [5,3,6,2,4,null,7], key = 0
			Output: [5,3,6,2,4,null,7]
			Explanation: The tree does not contain a node with value = 0.
			Example 3:

			Input: root = [], key = 0
			Output: []		

			Constraints:
				The number of nodes in the tree is in the range [0, 104].
				-10^5 <= Node.val <= 10^5
				Each node has a unique value.
				root is a valid binary search tree.
				-10^5 <= key <= 10^5
		//  Definition for a binary tree node.
		//  struct TreeNode {
		//     int val;
		//     TreeNode *left;
		//     TreeNode *right;
		//     TreeNode() : val(0), left(nullptr), right(nullptr) {}
		//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
		//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
		// };

		class Solution {
			public:
			int getSuccessor(TreeNode* n){
				n = n -> right;
				while(n -> left) n = n -> left;
				return n->val;
			}
			TreeNode* deleteNode(TreeNode* root, int key) {
				if(!root) return NULL;

				if(root -> val < key){
					root -> right = deleteNode(root -> right, key);
				}else if(root -> val > key){
					root -> left = deleteNode(root -> left, key);
				}else{
					// 0 or 1 child 
					if(!root -> left || !root -> right){
						TreeNode* replace = (root -> left) ? root -> left : root -> right;
						delete root;
						return replace;
					}else{
						// 2 childs
						int suc = getSuccessor(root);
						root -> val = suc;
						root -> right = deleteNode(root -> right, suc);
					}
				}
				return root;
			}
		};		
--------------------------------------------------------------------------------------------------------
	24/11/24
Lecture 70: Binary SearchTree FAANG Interview Questions || Part-1:
	Q.1. Partial BST:
		https://www.naukri.com/code360/problems/validate-bst_799483
		Problem statement
			Given a binary tree with N number of nodes, check if that input tree is Partial BST (Binary Search Tree) or not. If yes, return true, return false otherwise.
			A binary search tree (BST) is said to be a Partial BST if it follows the following properties.
			• The left subtree of a node contains only nodes with data less than and equal to the node’s data.
			• The right subtree of a node contains only nodes with data greater than and equal to the node’s data.
			• Both the left and right subtrees must also be partial binary search trees.
			Example:
			Input:
			Answer:
			Level 1: 
			All the nodes in the left subtree of 4 (2, 1, 3) are smaller 
			than 4, all the nodes in the right subtree of the 4 (5) are 
			larger than 4.
			Level 2 :
			For node 2:
			All the nodes in the left subtree of 2 (1) are smaller than 
			2, all the nodes in the right subtree of the 2 (3) are larger than 2.
			For node 5:
			The left and right subtree for node 5 is empty.
			Level 3:
			For node 1:
			The left and right subtree for node 1 are empty.
			For node 3:
			The left and right subtree for node 3 are empty.
			Because all the nodes follow the property of a Partial binary 
			search tree, the above tree is a Partial binary search tree.
			Sample Input 1:
			2
			3 1 5 -1 2 -1 -1 -1 -1
			3 2 5 1 4 -1 -1 -1 -1 -1 -1
			Sample Output 1:
			true
			false
			Explanation of the Sample Input1:
			Here we have 2 test cases, hence there are 2 binary trees
			Test Case 1: 
			Level 1: 
			For node 3 all the nodes in the left subtree (1,2) are 
			less than 3 and all the nodes in the right subtree (5) 
			are greater than 3. 
			Level 2:
			For node 1:
			The left subtree is empty and all the nodes in the right 
			subtree (2) are greater than 1.  
			For node 5:
			Both right and left subtrees are empty.
			Level 3:
			For node 2, both right and left subtrees are empty.
			Because all the nodes follow the property of a Partial binary 
			search tree, the function should return true.
			Test Case 2: 
			For the root node, all the nodes in the right subtree (5) are greater than 3. But node with data 4 in the left subtree of node 3 is greater than 3, this does not satisfy the condition for the Partial binary search tree. Hence, the function should return false. 
		#include <bits/stdc++.h> 
		/*************************************************************
			Following is the Binary Tree node structure
			class BinaryTreeNode {
				public : 
				T data;
				BinaryTreeNode<T> *left, *right;
				BinaryTreeNode(T data) {
					this -> data = data;
					left = right = NULL;
				}
			};
		*************************************************************/
		bool isBST(BinaryTreeNode<int> *root, int start, int end){
			if(!root) return 1;
			// if(root -> data < start or root -> data > end) return 0;
			if(!(root-> data >= start and root->data <=end)) return 0;

			// bool isLeftSafe = isBST(root -> left, start, root-> data);
			// bool isRightSafe = isBST(root -> right, root-> data, end);
			// if(isLeftSafe  and isRightSafe) return 1;
			if(isBST(root -> left, start, root -> data) and isBST(root -> right, root -> data, end)) return 1;
			return 0;
		}
		// or
		bool isValid(BinaryTreeNode<int> *n, int mn, int mx){
			if(!n) return 1;
			if(n -> data < mn or n->data > mx) return 0;
			return isValid(n->left, mn, n->data) and isValid(n-> right, n->data, mx);
		}
		bool validateBST(BinaryTreeNode<int> *root) {
			return isBST(root, INT_MIN, INT_MAX);
		}

		// or
			void inorder(BinaryTreeNode<int> *n, vector<int> &a){
				if(!n) return;

				inorder(n -> left, a);
				a.push_back(n -> data);
				inorder(n -> right, a);
			}

			bool validateBST(BinaryTreeNode<int> *root) {
				vector<int> hold;
				inorder(root, hold);
				if(is_sorted(hold.begin(), hold.end())) return 1;
				return 0;
			}
	
	Q.2. Predecessor And Successor In BST: (refer POTD: 1133)
		void inorder(TreeNode *n, vector<int> &a){
			if(!n) return;

			inorder(n -> left, a);
			a.push_back(n -> data);
			inorder(n -> right, a);
		}

		pair<int, int> predecessorSuccessor(TreeNode *root, int key) {
			int pre, succ;
			pre = succ = -1;
			vector<int> hold;
			inorder(root, hold);
			int n = hold.size();

			// finding the pred
			for(int i=0; i<n; i++)
				if(hold[i] < key) pre = hold[i];

			// finding the succ
			for(int i=n-1; i>=0; i--){
				if(hold[i] <= key) break;
				succ = hold[i];
			}  
			return {pre, succ};
		}

	Q.3.1. Find K-th smallest Element in BST:
		https://www.naukri.com/code360/problems/find-k-th-smallest-element-in-bst_1069333
		Problem statement
			Given a binary search tree and an integer ‘K’. Your task is to find the ‘K-th’ smallest element in the given BST( binary search tree).
			BST ( binary search tree) -
			If all the smallest nodes on the left side and all the greater nodes on the right side of the node current node.
			Example -
			Order of elements in increasing order in the given BST is - { 2, 3, 4, 5, 6, 7, 8, 10 }
			Suppose given ‘K = 3’ then 3rd smallest element is ‘4’.
			Suppose given ‘K = 8’ then 8th smallest element is ‘10’.
			Note:
				1. You are not required to print the output explicitly, it has already been taken care of. Just implement the function and return the ‘K-th’ smallest element of BST.
				2. You don’t need to return ‘K-th’ smallest node, return just value of that node. 
				3. If ‘K-th’ smallest element is not present in BST then return -1.
			Sample Input 1:
			2
			3
			3 1 4 -1 -1 -1 5 -1 -1
			4
			5 2 -1 -1 4 3 -1 -1 -1
			Sample output 1:
			4   
			5
			Explanation of sample input 1:
			Test case 1:
			Order of elements in the increasing order in the given BST is - { 1, 3, 4, 5 }.
			‘K = 3’, so the 3’rd smallest element is ‘4’, return ‘4’.

			Test case 2:
			Order of elements in increasing order in the given BST is - { 2, 3, 4, 5 }.
			‘K=4’, so the 4’rd smallest element is ‘5’, return ‘5’.
			Sample Input 2:
			2
			1
			3 2 -1 1 -1 -1 -1
			4
			3 1 4 -1 -1 -1 -1
			Sample output 2:
			1
			-1
			Constraint :
				1 <= T <= 100
				1 <= N, K <= 3000
				-10^9 <= data <= 10^9
				Where ‘T’ represents the number of test cases, ‘N’ is the number of nodes in the tree, ‘K’ denotes given integer and ‘data’ denotes data contained in the node of a binary tree.
				Time Limit: 1 sec
		
		// Using extra space:
			#include <bits/stdc++.h> 
			/*************************************************************
				Following is the Binary Tree node structure
				class BinaryTreeNode {
					public:
					T data;
					BinaryTreeNode<T> *left, *right;
					BinaryTreeNode(T data) {
						this -> data = data;
						left = right = NULL;
					}
				};
			*************************************************************/
			void inorder(BinaryTreeNode<int> *r, vector<int> &hold){
				if(!r) return;
				inorder(r->left, hold);
				hold.push_back(r -> data);
				inorder(r->right, hold);
			}
			int kthSmallest(BinaryTreeNode<int>* root, int k) {
				vector<int> hold;
				inorder(root, hold);
				return (k > hold.size()) ? -1 : hold[k-1];
			}

		// Using K's value:
			void inorder(BinaryTreeNode<int> *n, int &k, int &value){
				if(!n) return;
				inorder(n->left, k, value);
				if(k == 0) return;
				k--;
				value = n -> data;
				inorder(n->right, k, value);
			}

			int kthSmallest(BinaryTreeNode<int>* root, int k) {
				int value=0;
				inorder(root, k, value);
				return (k > 0) ? -1 : value;
			}
	
		// OR
			int inorder(BinaryTreeNode<int> *n, int &k){
				if(!n) return -1;

				int left = inorder(n->left, k);
				if(left != -1) return left;
				k--;
				if(k == 0) return n -> data;
				return inorder(n->right, k);
			}
			int kthSmallest(BinaryTreeNode<int>* root, int k) {
				return inorder(root, k);
			}
	
		// Using Morris Traversal:
			❌Pending

	Q.3.2: K-th largest Number BST: (refer POTD: 1134)
		https://www.naukri.com/code360/problems/k-th-largest-number_920438
		Problem statement
			You are given a binary search tree of integers with 'N' nodes. Your task is to return the K-th largest element of this BST.
			If there is no K-th largest element in the BST, return -1.
			A binary search tree (BST) is a binary tree data structure which has the following properties.
			• The left subtree of a node contains only nodes with data less than the node’s data.
			• The right subtree of a node contains only nodes with data greater than the node’s data.
			• Both the left and right subtrees must also be binary search trees.
			Constraints:
				1 <= T <= 100
				1 <= N <= 5000
				1 <= K <= 5000
				0 <= Data <= 10^6 and Data != -1
				Time Limit: 1sec
			Sample Input 1 :
			2
			3
			3 1 5 -1 2 -1 6 -1 -1 -1 -1 
			2
			2 1 -1 -1 -1 
			Sample Output 1:
			3
			1
			Explanation for Sample 1:
			Test Case 1:
			The sorted array corresponding to the first test case will be [1, 2, 3, 5, 6]. The 3rd largest element will be 3.
			Test Case 2:
			The sorted array corresponding to the second test case will be [1, 2]. The 2nd largest element will be 1.
			Sample Input 2 :
			1
			5
			10 -1 20 -1 30 -1 40 -1 -1
			Sample Output 2:
			-1

		// using extra space
			#include <bits/stdc++.h> 
			/************************************************************
				Following is the Binary Search Tree node structure
				template <typename T>
				class TreeNode {
					public :
					T data;
					TreeNode<T> *left, *right;

					TreeNode(T data) {
						this -> data = data;
						left = right = NULL;
					}
					~TreeNode() {
						if(left) delete left;
						if(right)delete right;
					}
				};
			************************************************************/
			void inorder(TreeNode<int> *n, vector<int> &a){
				if(!n) return;
				inorder(n->left, a);
				a.push_back(n->data);
				inorder(n->right, a);
			}

			int KthLargestNumber(TreeNode<int>* root, int k) {
				vector<int> hold;    
				inorder(root, hold);
				int n = hold.size();
				// (n-1) which is first largest
				// (n-2) which is second largest
				// (n-3) which is third largest
				// similarly kth largest is
				// (n-k) which is k-th largest
				return (k > n) ? -1 : hold[n-k];        
			}

			// or reverse traversal:
				void inorder(TreeNode<int> *n, vector<int> &a){
					if(!n) return;
					inorder(n->right, a);
					a.push_back(n->data);
					inorder(n->left, a);
				}
				int KthLargestNumber(TreeNode<int>* root, int k) {
					vector<int> hold;    
					inorder(root, hold);
					int n = hold.size();
					return (k > n) ? -1 : hold[k-1];        
				}

		// without using extra space:
			int Traverse(TreeNode<int> *n, int &k){
				if(!n) return -1;
				int right = Traverse(n->right, k);
				if(right != -1) return right;
				k--;
				if(k == 0) return n -> data;
				return Traverse(n->left, k);
			}
			int KthLargestNumber(TreeNode<int>* root, int k) {
				return Traverse(root, k);
			}

		// Morris traversal:
			❌Pending

	Q.4. LCA of Two Nodes In A BST:
		problem Statement:
			You are given a binary search tree of integers with N nodes. You are also given references to two nodes 'P' and 'Q' from this BST.
			Your task is to find the lowest common ancestor(LCA) of these two given nodes.
			The lowest common ancestor for two nodes P and Q is defined as the lowest node that has both P and Q as descendants (where we allow a node to be a descendant of itself)
			A binary search tree (BST) is a binary tree data structure which has the following properties.
			• The left subtree of a node contains only nodes with data less than the node’s data.
			• The right subtree of a node contains only nodes with data greater than the node’s data.
			• Both the left and right subtrees must also be binary search trees.
			For example:
			'P' = 1, 'Q' = 3
			tree = 2 1 4 -1 -1 3 -1 -1 -1,
			The BST corresponding will be- 
			Here, we can clearly see that LCA of node 1 and node 3 is 2.
			Sample Input 1 :
			3 5
			2 1 3 -1 -1 -1 5 -1 -1
			Sample Output 1:
			3
			Explanation for Sample 1:
			The BST corresponding will be-
			Here, we can clearly see that LCA of node 3 and node 5 is 3.
			Sample Input 2 :
			1 2
			3 2 -1 1 -1 -1 -1
			Sample Output 2:
			2
			Constraints:
				1 <= 'N' <= 10^5
				1 <= Data <= 10^6
				Time Limit: 1sec

		/************************************************************
			Following is the Binary Search Tree node structure
			class TreeNode {
				public:
				int data;
				TreeNode *left, *right;
				TreeNode() : data(0), left(NULL), right(NULL) {}
				TreeNode(int x) : data(x), left(NULL), right(NULL) {}
				TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
			};
		************************************************************/
		TreeNode *LCAinaBST(TreeNode *root, TreeNode *P, TreeNode *Q) {
			while(root){
				if(root -> data < P -> data and root -> data < Q -> data )
					root = root -> right;
				else if(root -> data > P -> data and root -> data > Q -> data)
					root = root -> left;
				else break;
			}
			return root;
		}

		// Recursive approach:
			TreeNode *LCAinaBST(TreeNode *root, TreeNode *P, TreeNode *Q) {
				if(!root) return NULL;
				if(root->data < P->data && root->data < Q->data) return LCAinaBST(root->right, P, Q);
				if(root->data > P->data && root->data > Q->data) return LCAinaBST(root->left, P, Q);
				return root;
			}
---------------------------------------------------------------------------------------------------------
Lecture 71: Binary SearchTree FAANG Interview Questions || Part-2:
	Q.1. Two Sum IV - Input is a BST: (refer POTD:1063)

	Q.2.  

---------------------------------------------------------------------------------------------------------
Lecture-138: Maximum Rectangle with all 1's || DP Series
	Q.1. Maximal Rectangle:
		Problem Statement:
			Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
			Example 1:
				Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
				Output: 6
				Explanation: The maximal rectangle is shown in the above picture.

			Example 2:
				Input: matrix = [["0"]]
				Output: 0

			Example 3:
				Input: matrix = [["1"]]
				Output: 1
			
			Constraints:
				rows == matrix.length
				cols == matrix[i].length
				1 <= row, cols <= 200
				matrix[i][j] is '0' or '1'.

		class Solution {
			public:
			vector<int> nextSmallerIndexes(vector<int> v, int n){
				vector<int> ans (n, n);
				stack<int> st;

				for(int i=n-1; i>=0; i--){
					while(!st.empty() && v[st.top()] >= v[i])
						st.pop();

					if(!st.empty())
						ans[i] = st.top();
					st.push(i);
				}
				return ans;
			}

			vector<int> prevSmallerIndexes(vector<int> v, int n){
				vector<int> ans (n, -1);
				stack<int> st;

				for(int i=0; i<n; i++){
					while(!st.empty() && v[st.top()] >= v[i])
						st.pop();

					if(!st.empty())
						ans[i] = st.top();
					st.push(i);
				}
				return ans;
			}

			int largestAreaFinder(vector<int> v, int n){
				int mxArea=0;
				vector<int> nxt = nextSmallerIndexes(v, n);
				vector<int> prev = prevSmallerIndexes(v, n);

				for(int i=0; i<n; i++)
					mxArea = max(mxArea, (nxt[i] - prev[i] - 1) * v[i]);
				return mxArea;
			}

			int maximalRectangle(vector<vector<char>>& matrix) {
				vector<vector<int>> M (matrix.size(), vector<int>(matrix[0].size(), 0));

				for(int i=0; i<matrix.size(); i++)
					for(int j=0; j<matrix[0].size(); j++)
						if(matrix[i][j] == '1')
							M[i][j] = 1;

				int Area = largestAreaFinder(M[0], matrix[0].size());

				for(int i=1; i<matrix.size(); i++){

					for(int j=0; j<matrix[0].size(); j++)
						if(M[i][j])
							M[i][j] += M[i-1][j];
					
					int tempArea = largestAreaFinder(M[i], matrix[0].size());
					Area = max(Area, tempArea);
				}
				return Area;
			}
		};
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
#miscellaneous:
	//Ternary Operator
		#include <iostream>
		using namespace std;
		int main(){
			//both ways work
			//cout function within ternary operator
			(1==1)? cout<<"Right 1==1"<<endl : cout<<"Wrong X"<<endl;
			
			//ternary operator within cout function
			std::cout << ((2==20)? "Yes True.. 2==20" :"No Wrong 2!=20") << std::endl;
			
			return 0;
		}

	//Extracting words from string:
		#include <iostream>
		#include <sstream>
		#include <vector>

		using namespace std;

		int main() {
			// Input string
			string str = "Hello 1 2 3 World, Going on Live now!";

			// Vector to store individual words
			vector<string> sentenceWords;

			// String to temporarily store each word
			string s;

			// Create an istringstream object and initialize it with the input string
			istringstream iss(str);

			// Loop to extract words from the stringstream and store them in the vector
			while (iss >> s) {
				sentenceWords.push_back(s);
			}

			// Loop to print each word from the vector on a new line
			for (const string& st : sentenceWords) {
				cout << st << endl;
			}

			return 0;
		}
		//output:
			Hello
			1
			2
			3
			World,
			Going
			on
			Live
			now!

	//Curly braces related..
		#include <iostream>
		using namespace std;

		int main()
		{
			if(0)
				if(0)
					std::cout << "nested if" << std::endl;
			else
				cout<<"nested else";					//if this else block is not present then outside else block got attached to inner if block
			else										//works like putting curly braces around if-else block.
				cout<<"outside if main IF got FALSE";
					
			return 0;
		}
	
	//If-else without using {}
		#include <iostream>
		using namespace std;
		int main() {
			int n = 91,cnt=80;
			if (n == 90)
				cout << "It's 90.. ayyyyye.." <<  endl,
				cout << "Another sentence" <<  endl;
			else
				cout << "Wrong, it's not 90" <<  endl, 
				cout << "It's the else part without using {} braces" <<  endl, 
				cnt = 10, 
				cout << "The count in the else block is " << cnt <<  endl;

			return 0;
		}

		#include <iostream>
		using namespace std;

		int main() {
			
			int n =5;
			int a = 10;
			int b = 20;
			
			std::cout << a << "\t" << b << "\t" << n << std::endl;
			if(n==5)
				a = 1, 
				b= 3;
			
			std::cout << a <<"\t"<< b << std::endl;
			return 0;
		}
		
	//Label
		if() can accept any non-zero or -ve value considered as true 
		if 0 then false.
		#include <iostream>
		using namespace std;
		int main(){
		
			if(2)					//if(-2)			this is also true.
				goto L2;

			L1: 
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			
			L2:
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			
			L3:
			return 0;
		}

	//Factorial:
		//fact program
		//position of increment decrement operator matters a LOTTTTTTTTT.
		#include <iostream>
		using namespace std;
		int main(){
			int n,t;
			cin>>n;
			t=n-1;
			
			while(t)
				n *= t--;
			
			std::cout <<endl<< n << std::endl;
			return 0;
		}

	//SWAP function:
		#include <iostream>
		using namespace std;

		int main(){
			int a = 10;
			int b = 20;
			cout << "Value of a before: " << a << endl;
			cout << "Value of b before: " << b << endl;

			// swap values of the variables
			swap(a, b);			//takes 2 values.

			//or
			a = a + b;	//a^b		//10+20=30
			b = a - b;	//a^b		//30-20=10
			a = a - b;	//a^b		//30-10=20

			cout << "Value of a now: " << a << endl;
			cout << "Value of b now: " << b << endl;
			return 0;
		}

	//while loop:
		#include <iostream>
		using namespace std;

		int main(){
			int i=0,j=0;
			
			while(i<5 && j<10){
				
				std::cout << i<<" "<<j << std::endl;			// and Operator is there so both condition must be true.
				i++;j++;									//output will be 0 to 4,
			}
			return 0;
		}

		//or if we used || or (,) then 0 - 9 will be printed.
		#include <iostream>
		using namespace std;

		int main(){
			int i=0,j=0;
			while(i<5 , j<10){          //while(i<5 || j<10)
				std::cout << i<<" "<<j << std::endl;
				i++;j++;
			}

			return 0;
		}

	//Remain 
		//Line 4499 Triplet sum didn't understand❌ (come back here later.).
		-Check TLE again (Time Limit Exceeded). https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/

	//Self Solved:
		1. Two Sum
			vector<int> twoSum(vector<int>& nums, int target){
				vector<int> ans;
				
				for(int i=0;i<nums.size(); i++){
					for(int j=i+1; j<nums.size(); j++){
						if(nums[i]+nums[j] == target){
							ans.push_back(i);
							ans.push_back(j);
						}
					}
				}
				return ans;
			}

		2. Coding Ninja Content:
			Container with Maximum Water:
				#include <bits/stdc++.h> 
				int maxAreaContainer(vector<int> &arr){
					int n = arr.size();
					int area, mainMax=0;

					for(int i=0; i<n-1;i++){
						for(int j=i+1; j<n; j++){
							area = min(arr[i], arr[j]) * (j-i);

							if(mainMax < area)
								mainMax = area;
						}    
					}
						return mainMax;
				}

				//optimized:
					#include <bits/stdc++.h> 
					int maxAreaContainer(vector<int> &arr){
						int n = arr.size();
						int left = 0;
						int right = n - 1;
						int mainMax = 0;

						while (left < right) {
							int width = right - left;
							int height = min(arr[left], arr[right]);
							int area = width * height;

							mainMax = max(mainMax, area);

							if (arr[left] < arr[right]) {
								left++;
							} else {
								right--;
							}
						}
						return mainMax;
					}

		3. Subarray with given sum
			vector<int> subarraySum(vector<int>arr, int n, long long s){
				
				int start = 0;
				long long sum = 0;
				vector<int> v;
			
				if (s == 0) // Handle the case where target sum is 0
				{
					v.push_back(-1);
					return v;
				}
				
				for (int i = 0; i < n; i++)
				{
					sum += arr[i];
			
					while (sum > s && start <= i)
					{
						sum -= arr[start];
						start++;
					}
			
					if (sum == s)
					{
						v.push_back(start + 1);
						v.push_back(i + 1);
						return v;
					}
				}
				v.push_back(-1); // If no subarray found
				return v;
			}

			//or
				vector<int> subarraySum(vector<int>arr, int n, long long s){
					// Your code here
					vector<int> res;
					bool bl = false;
					for (int i = 0; i < n; i++) {
						int currentSum = arr[i];
					
						if (currentSum == s) {
							res.push_back(i+1);
							res.push_back(i+1);
							bl=true;
							break;
						}
						else {
							// Try all subarrays starting with 'i'
							for (int j = i + 1; j < n; j++) {
								currentSum += arr[j];
					
								if (currentSum == s) {
									res.push_back(i+1);
									res.push_back(j+1);
									bl=true;
									break;
								}
							}
							if(bl) break;
						}
					}
					if(bl) return res;
						return {-1};
				}

		4. Smaller and Larger:
			vector<int> getMoreAndLess(int arr[], int n, int x) {
				int GreaterCount=0, LessCount=0;
				
				for(int i=0;i<n; i++){
					if(arr[i]>= x)
						GreaterCount++;
					
					if(arr[i]<=x)
						LessCount++;
				}
				
				vector<int> v;
				v.push_back(LessCount);
				v.push_back(GreaterCount);
				return v;
			}
		
		-Refer few programs from here also...
			https://auth.geeksforgeeks.org/user/viveknikate/practice

	//Char extraction & string addition:
		int main (){
			string firstName = "John ";
			char lastName =firstName[0];
			char n = 'f';
			string s;
			s+= n;
			s+= lastName;
			cout << s;
			return 0;
		}

	//CHAR_BIT:
		-This C++ program will output the value of the `CHAR_BIT` constant, 
		 which represents the number of bits in a `char` data type on the particular platform and compiler being used.
		-In most systems, a `char` data type is 8 bits (1 byte), but it's not guaranteed to be the same on all platforms. 
		 The `CHAR_BIT` constant is defined in the `<climits>` header in C++ and specifies 
		 the number of bits in the smallest addressable unit of the machine's memory.
		-So, when you run this program, it will likely output `8`, indicating that a `char` consists of 8 bits on your platform.
		eg.
			#include <iostream>
			#include <climits>
			using namespace std;
			int main(){
				cout<<CHAR_BIT<<"\n";
				cout<<CHAR_BIT * sizeof(int)<<"\n";
				return 0;
			}
			//output:
				8
				32

	//String initialization:
		#include <iostream>
		using namespace std;

		int main(){
			string s(10, 'V');
			std::cout << s << std::endl;			//VVVVVVVVVV
			return 0;
		}
	
		//or
			#include <iostream>
			using namespace std;

			int main() {
				string s1 ("asdf"), s2 ("wertwret");
				
				std::cout << s1 << std::endl;		//asdf
				std::cout << s2 << std::endl;		//wertwret
				
				return 0;
			}

	//String front() back() method:

		#include <iostream>
		using namespace std;

		int main() {
			string s= "Hello World";
			std::cout << s << std::endl; 			//Hello World
			s.front() = 'V';
			s.back() = 'N';
			std::cout << s << std::endl;			//Vello WorlN
			return 0;
		}

	//String length calculate:
		-use size() or length function.
		#include <iostream>
		using namespace std;

		int main(){
			string s ="Vivek";
			std::cout << s.size() << std::endl;         //11
			std::cout << s.length() << std::endl;       //11

			return 0;
		}

	//Max of integer:
		int max_of_four(int a, int b, int c, int d){
			return max(max(a,b),max(c,d));
		}

	//String assinging value at specific index:
		#include <iostream>
		using namespace std;
		int main(){
			string a,b;
			cin>>a;
			cin>>b;
			
			cout<<a.length()<<" "<<b.length()<<endl;
			cout<<(a+b)<<endl;

			swap(a[0],b[0]);
			cout<<a<<" "<<b<<endl;
			
			a[0]='Z';
			b[2]='Q';
			
			cout<<a<<" "<<b;
			return 0;
		}
		//output:
			Vivek 
			Rohini
			5 6
			VivekRohini
			Rivek Vohini
			Zivek VoQini

	//Local variables are stored in an area called a stack. Global variables, static variables, and program instructions 
	 are stored in the permanent storage area. The memory space between these two regions is known as a heap.

	#modulus operator:
		-when you take mod operation on any num with x, then output
		 will be inbetween 0 to (x-1);
		 eg.
		 	with 5: output will be 0 to 4.	|	with 10: output will be 0 to 9.
			1 % 5 = 1						|		1 % 10 = 1
			2 % 5 = 2						|		2 % 10 = 2
			3 % 5 = 3						|		3 % 10 = 3
			4 % 5 = 4						|		4 % 10 = 4
			5 % 5 = 0						|		5 % 10 = 5
			6 % 5 = 1						|		6 % 10 = 6
			7 % 5 = 2						|		7 % 10 = 7
			8 % 5 = 3						|		8 % 10 = 8
			9 % 5 = 4						|		9 % 10 = 9
			10 % 5 = 0					|		10 % 10 = 0
		
		Properties:
			◎  (a % m) + (b % m) = (a + b) % m
			◎  (a % m) - (b % m) = (a - b) % m
			◎  (a % m) * (b % m) = (a * b) % m

	//to find the datatype of variable in c++ 
		//use typeid(varName).name() function.
		#include <bits/stdc++.h> 
		#define M 32
		using namespace std; 
		int main() { 
			auto x = 5;    //i for integer
			auto y = 3.37; //D for double
			auto ptr = &x; //Pi for pointer
			auto z = "Hello";//PKc for string
			auto ch = 'Z';      //c for char
			bitset <M> bset(2);
			auto k = bset; //bitset :: St6bitsetILm32EE 
			
			cout << typeid(x).name() << endl 
				<< typeid(y).name() << endl 
				<< typeid(k).name() << endl 
				<< typeid(ptr).name() << endl 
				<< typeid(z).name() << endl 
				<< typeid(ch).name() << endl; 

			return 0; 
		} 
		
		//type of struct with name:
			#include <iostream>
			using namespace std;
			
			//struct name one having 3 letters in it, so datatype of this is - 3one & its outside of main function
			//so the datatype is just 3one.
			//if it is inside the main function then the dataType will be Z4mainE3one
			struct one{         
				int a;
				string b;
			} st1;

			struct four{        //struct name four having 4 letters in it, so datatype of this is - 4four
				int x;
				float ft;
			} st2;

			struct {
				int age;
				string name;
				float Salary;
				bool isFine;
			} st3;

			int main() {
				struct {
					int age;
					string name;
					float Salary;
					bool isFine;
					int arr[10];
				} st4;

				//datatype finding
				std::cout << typeid(st1).name() << std::endl;           //3one
				std::cout << typeid(st2).name() << std::endl;           //4four
				std::cout << typeid(st3).name() << std::endl;           //9._anon_89        anon- indicates its outside of main function & its anonymous
				std::cout << typeid(st4).name() << std::endl;           //Z4mainEUt_        main- indicates inside of main function
				
				struct InSideMainKnow{
					int age;
					string name;
					float Salary;
					bool isFine;
				} st5;
				
				std::cout << typeid(st5).name() << std::endl;       //struct with name InSideMainKnow having 14 letters
				//so datatype is Z4mainE14InSideMainKnow
				
				return 0;
			}


		//or
			#include <iostream>
			using namespace std;

			int main() {
				
				struct {
					int age;
					string name;
					float Salary;
					bool isFine;
				} p1;
				
				
				std::cout << typeid(p1).name() << std::endl;        //Z4mainEUt_        variable of type struct
				//this type is for anonymous struct, Z4mainEUt_ here main indicate its inside main function.
				
				float arr[] = {1.2, 2.3, 3.4, };        //actually it should throw error, but it just works fine.
				std::cout << typeid(arr).name() << std::endl;       //A3_f   
				// where, A- indicates array
				// 3 - indicates 3 elements are there in array, & trailling comma is fine. compiler ignores it.
				// f - indicates its floating array.
				
				int *ptr;
				std::cout << typeid(ptr).name() << std::endl;           //Pi datatype of pointer
				
				string strArr[] = {"abc","def"};
				std::cout << typeid(strArr).name() << std::endl;        //A2_NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE  datatype of string array
				// where, A- indicates array
				// 2 - indicates 2 elements are there in array, 
				// Nst - indicates string array.
				
				int intArr[] = {1,2,3,4,5,6,};              //here also extra comma at end.
													//actually it should throw error, but it just works fine.
				std::cout << typeid(intArr).name() << std::endl;
				//A6_i          
				// where, A- indicates array
				// 6 - indicates 6 elements are there in array, 
				// i - indicates integer array.
				
				double doubleArr[] = {1.22,3.44,6.90,7.88,};              //here also extra comma at end.
													//actually it should throw error, but it just works fine.
				std::cout << typeid(doubleArr).name() << std::endl;    
				//A4_d
				// where, A- indicates array
				// 4 - indicates 4 elements are there in array, 
				// d - indicates this array contains values of type double
				
				return 0;
			}
	
	//Structure:
		//You can define the struct outside of main function
		//struct without having name (anonymous), with single variable p1.

			#include <iostream>
			using namespace std;

			struct {
				int age;
				string name;
			} p1;

			int main() {
				//priting the values
				std::cout << p1.age << std::endl;			//0
				std::cout << p1.name << std::endl;			//		(nothing will be printed)
				return 0;
			}

		//You can define the struct inside of main function with 2 variable p1, p2.
		//struct without having name (anonymous).
			#include <iostream>
			using namespace std;

			int main() {
				struct {
					int age;
					string name;
				} p1, p2;
			
				//priting the values
				std::cout << p1.age << std::endl;			//0
				std::cout << p1.name << std::endl;			//		(nothing will be printed)
				
				std::cout << p2.age << std::endl;			//0
				std::cout << p2.name << std::endl;    		//		(nothing will be printed)
				return 0;
			}

		// struct inside & outside of main function assinging value to it.
		// anonymous structures
			#include <iostream>
			using namespace std;

			struct {
				int age;
				string name;
			}p1,p2;

			int main() {
				
				struct {
					int id;
					string sub;
				} std1, std2;
				
				p1.age = 12;
				p1.name = "Twelth";
				
				p2.age = 15;
				p2.name = "Fifteen";
				
				//priting the values
				std::cout << p1.age << std::endl;
				std::cout << p1.name << std::endl;
				
				std::cout << std::endl;
				std::cout << p2.age << std::endl;
				std::cout << p2.name << std::endl;

				std::cout << std::endl;
				
				std1.id = 101;
				std1.sub = "Science";
				
				std2.id = 201;
				std2.sub = "Computer Graphics";
				
				std::cout << std1.id << std::endl;
				std::cout << std1.sub << std::endl;
				
				std::cout << std::endl;
				std::cout << std2.id << std::endl;
				std::cout << std2.sub << std::endl;
				return 0;
			}

		//structure outside of main function with some default value
			#include <iostream>
			using namespace std;

			struct {
				int age = 1000;
				string name = "SAMPLE";
			}p1,p2;

			int main() {
			
				//priting the values
				std::cout << p1.age << std::endl;
				std::cout << p1.name << std::endl;
				
				std::cout << std::endl;
				std::cout << p2.age << std::endl;
				std::cout << p2.name << std::endl;    
				return 0;
			}
		
		// changing the default of structure
		// anonymous structure
			#include <iostream>
			using namespace std;
			//This default values gets printed if we don't assign values manually
			// if we assign values to it, the default values gets overriden/ replaced with new values we assigned.
			// if you want, you can keep this structure declaration inside main function also.

			struct {
				int age = 1000;
				string name = "SAMPLE";
			} p1,p2;

			int main() {
				//priting the values
				std::cout << p1.age << std::endl;
				std::cout << p1.name << std::endl;
				
				p2.age = 22;
				p2.name = "Ram";
				
				std::cout << std::endl;
				std::cout << p2.age << std::endl;
				std::cout << p2.name << std::endl;    
				return 0;
			}
		
		// Named structure:			
			#include <iostream>
			using namespace std;

			struct first {
				// default values
				int age = 12;       
				string name = "test";
			}s1;

			int main() {
				
				std::cout << typeid(s1).name() << std::endl;
				std::cout << s1.age << std::endl;
				
				s1.age=24;
				std::cout << s1.age << std::endl;
				
				//creating variable with custom datatype
				// variable of type first
				
				std::cout << std::endl;
				first s2;
				std::cout << s2.age << std::endl;
				std::cout << s2.name << std::endl;
				
				std::cout << std::endl;
				s2.age =24;
				s2.name = "Nikate";
				std::cout << s1.age << std::endl;
				std::cout << s2.name << std::endl;
				
				std::cout  << std::endl;
				
				struct second {
					string name = "Sample";
					int arr[3] = {20,29,100};
				};
				
				second my;
				std::cout << typeid(my).name() << std::endl;
				std::cout << my.name << std::endl;
				std::cout << my.arr[0] << std::endl;
				
				//updating values
				std::cout  << std::endl;
				my.name = "Second Structure";
				my.arr[0] = 89;                 //first values i want to be 89. 
				std::cout << my.name << std::endl;
				std::cout << my.arr[0] << std::endl;
				std::cout << my.arr[1] << std::endl;
				
				return 0;
			} 

	//Class Structure are same?
		-Yes, they are almost same, but there are some differences.
		-the main difference between them is that struct members are public by default, 
		-while class members are private by default. 
		-Structs can contain member functions, just like classes.

		-in below program struct with int x, y & Sum function is public, so we can access them in main directly.
			#include <iostream>
			using namespace std;
			struct {
				int x=10, y=20;
				
				void Sum(){
					std::cout << "Sum is:: "<< x+y << std::endl;
				}
			} s ;

			int main() {
				
				s.Sum();			//30
				
				//after updating
				s.x = 100;
				s.y = 10;
				s.Sum();			//110
				return 0;
			}

		-Using class:
			-here int x, y & Sum function is private by default we can't access them in main function.
			-need to change the visibility.
			//ERROR  
				#include <iostream>
				using namespace std;
				class Operation {
				
					int x=10, y=20;
					
					void Sum(){
						std::cout << "Sum is:: "<< x+y << std::endl;
					}
				};

				int main() {
				
					Operation ops;
					ops.Sum();
					
					return 0;
				}
			
			//Working:
				#include <iostream>
				using namespace std;
				class Operation {
					public:
						int x=10, y=20;
						
						void Sum(){
							std::cout << "Sum is:: "<< x+y << std::endl;
						}
				};

				int main() {
					Operation ops;
					ops.Sum();              //30
					
					ops.x = 100, ops.y = 10;        
					ops.Sum();              //110
					
					Operation ops2;
					ops2.Sum();             //30
					
					return 0;
				}

	//Size of structure:
		#include <iostream>
		using namespace std;

		int main() {
			struct st{
				int a;          //size-4
				double d;        //size-8
				int arr[10];    //size - 40
				string s;       //size - 32
			};
			
			// sizeof(datatypeName)
			std::cout << sizeof(string) << std::endl;   //32
			std::cout << sizeof(double) << std::endl;   //8
			
			std::cout << sizeof(int) << std::endl;      //4
			std::cout << "Size of struct st: " << sizeof(st) << std::endl;       //88            extra bytes added by compiler when we use double or int or string at same time.

			return 0;
		}

	//Finding maximum num from vector
		-using max_element function.
		-we need to take iterator for this.
		-max_element function found in algorithm header file sp include algorithm.
			#include <iostream>
			#include<vector>
			#include<algorithm>
			using namespace std;

			int main(){
				vector<int> ans = {1,2,3,4,5,6,7,8,9,910};
				
				auto maxer = max_element(ans.begin(), ans.end());
				std::cout << *maxer << std::endl;
				
				//max element from 3rd position to 7th position, 0-index based. means between 4 & 8.
				//both index inclusive 3rd & 7th also, but max_element function exclude the last index that's why we added 1 manually
				maxer = max_element(ans.begin()+3, ans.begin()+7+1);        
				std::cout <<*maxer << std::endl;

				//To know the type of particular variable:

				auto maxer = max_element(ans.begin(), ans.end());
				std::cout << *maxer << std::endl;
				std::cout << typeid(maxer).name() << std::endl;
				std::cout << typeid(ans).name() << std::endl;
				
				int c;
				std::cout << typeid(c).name() << std::endl;
				string s="asdf";
				std::cout << typeid(s).name() << std::endl;

				return 0;
			}

	//Finding maximum & minimum num from vector:
		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;

		int main(){
			vector<int> v = {1,2,3,-9,5,6,707,8,9,10};
			
			auto mx = max_element(v.begin(), v.end());
			std::cout << *mx << std::endl;              //707
			
			auto mn = min_element(v.begin(), v.end());			//endIndex is excluded.
			std::cout << *mn << std::endl;      //-9
			
			return 0;
		}

	//Dynamic array Creation:
		#include<iostream>
		using namespace std;
		int main() {
			int x, n;
			cout << "Enter the number of items:" << "\n";
			cin >>n;
			int *arr = new int(n);				//or
			//int * arr = new int[n];

			cout << "Enter " << n << " items" << endl;
			for (x = 0; x < n; x++) {
				cin >> arr[x];
			}
			cout << "You entered: ";
			for (x = 0; x < n; x++) {
				cout << arr[x] << " ";
			}
			return 0;
		}
		1. Include the iostream header file into our program to use its functions.
		2. Include the std namespace in our program in order to use its classes without calling it.
		3. Call the main() function. The program logic should be added within the body of the function.
		4. Declare two integer variables x and n.
		5. Print some text on the console prompting the user to enter the value of variable n.
		C++ Dynamic Allocation of Arrays with Example
		6. Read user input from the keyboard and assigning it to variable n.
		7. Declare an array to hold a total of n integers and assigning it to pointer variable *arr.
		8. Print a message prompting the user to enter n number of items.
		9. Use a for loop to create a loop variable x to iterate over the items entered by the user.
		10. Read the elements entered by the user and storing them in the array arr.
		11. End of the body of the for loop.
		12. Print some text on the console.
		13. Use a for loop to create a loop variable x to iterate over the items of the array.
		14. Print out the values contained in the array named arr on the console.
		15. End of the body of the for loop.
		16. The program must return value upon successful completion.
		17. End of the body of the main() function.

		//Another example
			Dynamically Deleting Arrays:
				A dynamic array should be deleted from the computer memory once its purpose is fulfilled. 
				The delete statement can help you accomplish this. 
				The released memory space can then be used to hold another set of data. 
				However, even if you do not delete the dynamic array from the computer memory, 
				it will be deleted automatically once the program terminates.

			Note:
				To delete a dynamic array from the computer memory, you should use delete[], 
				instead of delete. The [] instructs the CPU to delete multiple variables rather than one variable. 
				The use of delete instead of delete[] when dealing with a dynamic array may result in problems. 
				Examples of such problems include memory leaks, data corruption, crashes, etc.

			#include<iostream>
			using namespace std;
			int main() {
				int x, n;
				cout << "How many numbers will you type?" << "\n";
				cin >>n;
				int *arr = new int(n);
				cout << "Enter " << n << " numbers" << endl;
				for (x = 0; x < n; x++) {
					cin >> arr[x];
				}
				cout << "You typed: ";
				for (x = 0; x < n; x++) {
					cout << arr[x] << " ";
				}
				cout << endl;
				delete [] arr;
				return 0;
			}
			Summary
				-Regular arrays have a fixed size. You cannot modify their size once declared.
				-With these types of arrays, the memory size is determined during compile time.
				-Dynamic arrays are different. Their sizes can be changed during runtime.
				-In dynamic arrays, the size is determined during runtime.
				-Dynamic arrays in C++ are declared using the new keyword.
				-We use square brackets to specify the number of items to be stored in the dynamic array.
				-C++ Dynamic Allocation of Arrays with Example
				-Once done with the array, we can free up the memory using the delete operator.
				-Use the delete operator with [] to free the memory of all array elements.
				-A delete without [] frees the memory of only a single element.
				-There is no built-in mechanism to resize C++ arrays.

	//count the no.of digit in number:
		#include <iostream>
		#include<cmath>
		using namespace std;

		int main() {
			//get no.of digit in n;
			long n= 123456789;
			
			std::cout << n << std::endl;
			std::cout << "no.of digit : "<< static_cast<int>(log10(n)+1)<< std::endl;
			
			std::cout << "no.of digit : "<< (int) log10(n)+1<< std::endl;
			std::cout << "no.of digit : "<< static_cast<int>(log10(n)+1)<< std::endl;    
			
			//static_cast<int> used to convert from double or float to int.
			// or to count the no.of digit in n, you can use this also...
			int cnt=0;
			while(n>0){
				cnt++;
				n/=10;
			}
			std::cout << "The CNT : "<< cnt << std::endl;
			return 0;
		}

	//string erase practice:

		#include <iostream>
		using namespace std;

		int main() {
		
			//erasing last single characters
			string s = "Hello World";
			std::cout << s << std::endl;            //Hello World
			
			s.erase(s.end()-1);
			std::cout << s << std::endl;            //Hello Worl
			
			s.erase(s.length()-1);
			std::cout << s << std::endl;            //Hello Wor
			
			//erasing starting characters
			s.erase(s.begin());
			std::cout << s << std::endl;            //ello Wor
			
			// erase 4th character from start
			s = "Hello World";
			std::cout << s << std::endl;            //Hello World
			s.erase(s.begin()+4);
			std::cout << s << std::endl;            //Hell World
			
			//erase all except first character
			s.erase(1);
			std::cout << s << std::endl;            //H

				//delete all except first 4  character
			s = "Hello World";
			std::cout << s << std::endl;    //Hello World
			s.erase(4);
			std::cout << s << std::endl;        //Hell
			
			//erase starting 3 character
			s = "Hello World";
			s.erase(s.begin(),s.begin()+3);             //Hello World
			std::cout << s << std::endl;                //lo World
			
			//delete everything except last 3 character
			s = "Hello World";
			s.erase(s.begin(), s.end()-3);      //Hello World
			std::cout << s << std::endl;        //rld
			
			//delete everything except last 5 character
			s = "Sveri college of Engineering";
			std::cout << s << std::endl;            //Sveri college of Engineering
			s.erase(s.begin(), s.end()-5);          
			std::cout << s << std::endl;            //ering

			return 0;
		}

	//Substring:

		#include <iostream>
		using namespace std;

		int main() {
			
			string s="Hello World";
			
			//extracting last char.
			std::cout << s << std::endl;            //Hello World
			cout<<s.substr(s.length()-1)<<endl;     //d     //stringName.substr(starIndex,(optional, how many character you want));
			
			//extracting first char using substr method
			std::cout << s.substr(0,1) << std::endl;        //H  //from startIndex, extract 1 char.
			
			//extract all from 2nd index
			std::cout << s.substr(2) << std::endl;          //llo World
			
			return 0;
		}

	//Array to Vector:
		//using range in vector:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main() {
				int arr[] = { 1,3,5,7,9,11,7,8,9,10 };

				vector<int> vec(arr, arr+3);			(3-0 = 3 elements)

				for (int i = 0; i < 3; i++) 
					cout << vec[i] << " ";                  //1, 3, 5

				
				// from 4th index to till last 0-based
				vector<int> vec1(arr+4,arr+10);             //9,11,7,8,9,10      (10-4=6 elements will be there in vec1)
				std::cout << std::endl;
				for(int z: vec1)
					cout<<z<<" ";
				
					return 0;
			}

		//copying array to vector using insert
			#include <iostream>
			#include <vector>
			using namespace std;
			int main(){
				
				int arr[] = {0,9,8,7,6,5,4,3,2,10};
				
				//copying array to vector;
				
				for(int i=0; i<10; i++)
					cout<<arr[i]<<" ";
					
				std::cout << std::endl;
				vector<int> copied;
				
				//copying
				copied.insert(copied.begin(), arr, arr+10);         //vectorName.insert(startIndex, arrayStartIndex, arrayEndIndex)
				
				for(int z: copied)
					cout<<z<<" ";
				
				return 0;
			}

		//using assign:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main() {
				int arr[] = {0,9,8,7,6,5,4,3,2,10};
				
				//copying array to vector;
				
				for(int i=0; i<10; i++)
					cout<<arr[i]<<" ";          //0,9,8,7,6,5,4,3,2,10
					
				std::cout << std::endl;
				vector<int> copied;
				
				//copying complete array
				copied.assign(arr,arr+10);          //vectorName.insert(startIndex, arrayStartIndex, arrayEndIndex)
									
				for(int z: copied)
					cout<<z<<" ";               //0,9,8,7,6,5,4,3,2,10
					
				copied.clear();
				
				//copying 4 elements from 3rd index (0-based)
				copied.assign(arr+3, arr+7);
				std::cout << std::endl;
				
				for(int z: copied)
					cout<<z<<" ";               //7,6,5,4 (last index excluded 7th which is 3.)
				
				return 0;
			}

	//Vector Practice:
		#include <iostream>
		#include<vector>
		using namespace std;
		int main() {
			int arr[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
			std::cout << "Main ARR: "<< "\t\t";
			for(int i: arr){
				std::cout << i << " ";
			}
			std::cout << std::endl;
			
			//array to vector using insert method
			vector<int> vecIns;
			
			std::cout << "vecIns : " <<"\t\t";
			vecIns.insert(vecIns.begin(), arr, arr+10);         //first 10 elements
			
			for(int h: vecIns)
				std::cout << h <<"\t";
				
			std::cout << std::endl;
			std::cout << std::endl;
			
			//array to vector using assign method,
			// 10th to 20th elements            (20-10=10 elements will be there in new vector)
			vector<int> vecAssign;
			vecAssign.assign(arr+10, arr+20);
			std::cout << "vecAssign : "<< "\t\t";
			for(int h: vecAssign)
				std::cout << h <<"\t";
				
			std::cout  << std::endl;
			std::cout << "vecAssign Whole array: " <<" ";
			//assigning whole array to vecAssign,
			vecAssign.assign(arr, arr+20);
			for(int h: vecAssign)
				std::cout << h <<" ";
				
			
			std::cout << std::endl;
			std::cout << std::endl;
			
			//array to vector using range, first 5 elements
			vector<int> vec1(arr, arr+5);        //(5-0=5 elements)
			
			for(int i=0; i<5; i++)
				cout<<vec1[i]<<" ";
			
			//or
			std::cout << std::endl;
			for(int z: vec1)
				cout<<z<<" ";
				
			
			std::cout << std::endl;
			std::cout << std::endl;
			//creating vector of specific size & specific value,
				std::cout << std::endl;
				vector<int> vec2 (8, 127);          //size=8, default value= 127.
				for(auto aa: vec2)
					std::cout << aa << " ";
					
				std::cout << std::endl;
				std::cout << std::endl;
				
			//creating 2D char vector with specific size, & default value.
				vector<vector<char>> vec2D (4, vector<char>(5,'$'));        //2D char vector of 4 rows & 5 cols of default value is $ dollar sign.
				//vector<vector<char>> vec2D (4, vector<char>(5));          //2D char vector of 4 rows & 5 cols with no default values. (but by default all values will be 0 for int vector).
																// for char vector the default value is space (not visible).
				
				for(int i=0; i<vec2D.size(); i++){
					for(int j=0; j<vec2D[0].size(); j++)
						cout<<vec2D[i][j]<<" ";
					std::cout << std::endl;
				}
			
			std::cout << std::endl;
			//create 3D vector of int type with default value 9.
				//row =3
				//cols =4
				//height =2
				
				vector<vector<vector<int>>> vec3D (3, vector<vector<int>>(4, vector<int>(2,0)));
				
				for(int i=0; i<3; i++){
					for(int j=0; j<4; j++){
						for(int k=0; k<2; k++){
							cout<<vec3D[i][j][k]<<" ";
						}
						std::cout << "\t";
					}
					std::cout << std::endl;
				}
			
			return 0;
		}
		output:
			Main ARR:               1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
			vecIns :                1       2       3       4       5       6       7       8       9       10

			vecAssign :             11      12      13      14      15      16      17      18      19      20
			vecAssign Whole array:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 

			1 2 3 4 5 
			1 2 3 4 5 


			127 127 127 127 127 127 127 127 

			$ $ $ $ $ 
			$ $ $ $ $ 
			$ $ $ $ $ 
			$ $ $ $ $ 

			0 0     0 0     0 0     0 0 
			0 0     0 0     0 0     0 0 
			0 0     0 0     0 0     0 0 

	//Static variables are stored in the memory in
		Heap
		Permanent storage area
		Free memory
		Stack
		( Correct Answer
				#### Local variables are stored in an area called a stack. Global variables, static
				variables, and program instructions are stored in the permanent storage area. The
				memory space between these two regions is known as a heap.

	//Repeated num in array
		Sample Input:
			2
			10
			1 2 3 4 5 5 5 6 7 7
			15
			1 1 1 1 1 2 2 2 2 2 3 3 3 3 3
		Output:
			1->1
			2->1
			3->1
			4->1
			5->3
			6->1
			7->2

			1->5
			2->5
			3->5

		#include <iostream>
		#include<unordered_map>
		using namespace std;

		int main() {
			int arr[] = {1,2,3,4,5,4,4,2,2,2};
			int n=10;
			unordered_map<int, int> countRepetition;
			
			cout<<"arr: ";
			for(int i: arr)
				cout<<i<<" ";
				
			std::cout << std::endl;
			for(int i=0; i<n; i++)
				countRepetition[arr[i]]++;
			
			for(auto itr = countRepetition.begin(); itr != countRepetition.end(); itr++)        //use -> (arrow) operator in traditional for loop.
				cout<<itr->first<<" repeated\t"<<itr->second<<" times\n";
			
			std::cout << std::endl;
			std::cout << std::endl;
			
			//to print the conent of map
			for(const auto i: countRepetition)            //use . (dot) operator in advance for loop
				cout<<i.first<<" repeated "<<i.second<<" times\n";

			return 0;
		}

		//counting frequency using unordered_map ❌Pending

	//Map:
		#include <iostream>
		#include<vector>
		#include<map>
		// #include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> v {1,1,2,2,1,1,2,2,1,1,2,2,3,4,4,3,3,3,4,4,4,4};
			
			//Frequency counter
			map<int,int> FreqCnt;
			for(int i=0; i<v.size(); i++)
				FreqCnt[v[i]]++;
				
			//using advance for loop, when you use advance for loop syntax is dot first for key, 
			//dot second for value (var.first, var.second);
			for(auto i: FreqCnt)
				std::cout << i.first << " \t "<< i.second << std::endl;
			
			std::cout << std::endl;
			
			//printing the FreqCnt map
			for(auto [key, value]: FreqCnt)
				std::cout << key << "\t" << value << std::endl;
				
			std::cout << std::endl;
			
			//or printing in tradition way old for loop, when you use tradition for loop syntax will 
			//be like (-> first) to access key & (-> second) to access the value.
			
			for(auto itr = FreqCnt.begin(); itr != FreqCnt.end(); itr++){
				std::cout << itr -> first << "\t" << itr -> second << std::endl;
			}
			return 0;
		}

	//Map Sorting:
		// #include <iostream>
		#include<bits/stdc++.h>
		// #include<vector>
		// #include<map>
		// #include<unordered_map>
		// #include<algorithm>
		using namespace std;

		bool valuesCmp(pair<int, int> a, pair<int, int> b){
			return a.second < b.second;
		}

		bool valuesCmpDesc(pair<int, int> a, pair<int, int> b){
			if(a.second == b.second)
				return a.first > b.first;
			return a.second < b.second;
		}

		bool value_KEY_DESC(pair<int, int> a, pair<int, int> b){
			// if(a.second == b.second)
			//     return a.first > b.first;
			return a.second > b.second;
		}

		bool valueDESC_KeyASC(pair<int, int> a, pair<int, int> b){
			if(a.second == b.second)
				return a.first < b.first;
			return a.second > b.second;
		}

		int main() {
			
			vector<int> v {12,9,10,1,1,1,1,1,3,3,3,3,5,5,5,4,4,0,0,2,2,11};
			std::cout << v.size() << std::endl;
			
			// frequency of element
			// keys are in increasing order by default in map, & if you sort the map based on value
			map<int, int> Freq;
			for(int i: v)
				Freq[i]++;
			
			// printing Freq map
			for(auto i=Freq.begin(); i!=Freq.end(); i++)
				std::cout << i->first <<"\t"<< i->second << std::endl;
				
			// sorting the Freq map based on values in increasing order
			// if values are same then based on keys, in increasing order
			vector<pair<int, int>> holder;
			for(auto i: Freq){
				// pair<int, int> temp = {i.first, i.second};       //or
				pair<int, int> temp;
				temp = make_pair(i.first, i.second);
				holder.push_back(temp);
			}
			
			std::cout << std::endl;
			// printing the holder vector
			//key & values are in ascending order
			for(int i=0; i<holder.size(); i++)
				std::cout << holder[i].first << "\t" << holder[i].second << std::endl;
				
			sort(holder.begin(), holder.end(), valuesCmp);
			
			std::cout << std::endl<<"After sorting: \n";
			for(int i=0; i<holder.size(); i++)
				std::cout << holder[i].first << "\t" << holder[i].second << std::endl;
				
				
			// if values are same based on keys in descending order & values are in ascending order
			std::cout << std::endl << "Descending Order: \n";
			sort(holder.begin(), holder.end(), valuesCmpDesc);
			
			for(int i=0; i<holder.size(); i++)
				std::cout << holder[i].first << "\t" << holder[i].second << std::endl;

			// values are in descending order with keys are in descending order
			std::cout << "\nValues and keys all are in descending order: " << std::endl;
			sort(holder.begin(), holder.end(), value_KEY_DESC);
			for(int i=0; i<holder.size(); i++)
				std::cout << holder[i].first << "\t" << holder[i].second << std::endl;
						
			// values are in descending order but key are in ascending order
			std::cout << "\nValues are in descending order but keys are in ascending order : " << std::endl;
			sort(holder.begin(), holder.end(), valueDESC_KeyASC);
			for(int i=0; i<holder.size(); i++)
				std::cout << holder[i].first << "\t" << holder[i].second << std::endl;

			return 0;
		}

	//Pointer function practice:
		#include <iostream>
		using namespace std;

		//function receives address
		void function1(int *p){          //storing passed address into pointer p.
			(*p)++;                     //incrementing the value at that address.
		}

		//function receives value. make copy of it & as soon as function
		//ends it delete the new value & in main come back to original value.
		void function2(int a){
			a++;
			std::cout << "inside "<< a << std::endl;
		}

		//here receiving value's address & modifying the address value,
		//so updated value will be preserved.
		void function3(int &a){
			a++;
			std::cout << "inside :"<< a << std::endl;
		}


		int main() {
			// passing pointer to the function
			int a=90;
			int*ptr = &a;
			
			std::cout << "before ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;
			function1(ptr);          //passing address indirectly, then function receiver must be pointer only coz we're passing address
			std::cout << "After ptr: "<< *ptr << std::endl;
			std::cout << "After A: "<< a << std::endl;
			std::cout << std::endl;
			
			*ptr = 90;
			std::cout << "before ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;
			function2(*ptr);          //passing values directly(pointer). 
									// so function receiver must be either simple datatype variable or address of that variable
			std::cout << "After ptr: "<< *ptr << std::endl;
			std::cout << "After A: "<< a << std::endl;
			std::cout << std::endl;
			
			*ptr = 90;
			std::cout << "before ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;
			function3(*ptr);          //passing values directly.
			std::cout << "After ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;

			return 0;
		}
		//output
			before ptr: 90
			before A: 90
			After ptr: 91
			After A: 91

			before ptr: 90
			before A: 90
			inside 91
			After ptr: 90
			After A: 90

			before ptr: 90
			before A: 90
			inside :91
			After ptr: 91
			before A: 91

	//Array Practice:
		#include <iostream>
		using namespace std;
		int main() {
			int a[l={5,6,7,8};
			cout<< * (a + 2) <<  " " << a[1];		//	7 6
			return 0;
		}

	//Binary to decimal & decimal to binary:
		using built-in function
		#include <iostream>
		#include<bitset>
		using namespace std;

		int main() {
			int num = 21;
			
			std::cout << num << std::endl;    
			//decimal to binary, binary to string & storing it into s
			string s = bitset<32>(num).to_string();			//converting bitset output to string.
			std::cout << s << std::endl;
			
			//decimal to binary
			// changing last 4 bits
			s[31] = '1';
			s[30] = '1';          
			s[29] = '1';          
			s[28] = '1'; 
			s[27] = '0';
			std::cout << s << std::endl;
			
			//string binary to decimal
			num = stoi(s,0,2);
			std::cout << num << std::endl;          //15
			std::cout << s << std::endl;

			return 0;
		}
		//output:
			21
			00000000000000000000000000010101
			00000000000000000000000000001111
			15
			00000000000000000000000000001111

	//Finding maximum/ minimum element from array & its index
		using built in function:
		#include <iostream>
		#include <algorithm>

		int main() {
			int arr[] = {3, 7, 1, 9, 4, 2, 6, 8, 5};
			int n = sizeof(arr) / sizeof(arr[0]);

			// Use std::max_element to find the iterator to the maximum element
			auto maxElementIter = std::max_element(arr, arr + n);

			if (maxElementIter != arr + n) {				//(arr+n) indicate its end of array
													//meaning of (maxElementIter != arr + n) is iterator is not reached to the end, 
													//if its reaches to the end then else block will gets executed
				int maxIndex = std::distance(arr, maxElementIter);
				int maxElement = *maxElementIter;					//using * operator getting value at that iterator.
				std::cout << "Maximum element: " << maxElement << std::endl;
				std::cout << "Index of maximum element: " << maxIndex << std::endl;
			} else {
				std::cout << "Array is empty" << std::endl;
			}

			return 0;
		}

		//if its vector then in max_element function parameter will be like (arr.begin(), arr.end())

		-auto keyword is automatically determine the type of variable we are creating.
		-here auto, we used for creating iterator.

		//or

			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {   
				//for array finding max & min & their indexes
				int arr[] = {1,2,3,4,-5,90,7,8,9,10};           //min=-5, minIndx = 4 & max = 90, maxIndx = 5
				
				std::cout << "In Array: " << std::endl;
				
				auto mx = max_element(arr, arr+10);         //traversing complete Array.
				int maxIndx = distance(arr, mx);            //using distance method also you can find the index of element.
				
				std::cout << "maximum num in array: "<< *mx << " maxIndex: "<< maxIndx << std::endl;
				std::cout << "index of max num : "<< (mx-arr) << std::endl;             //
				
				auto mn = min_element(arr,arr+10);
				int minIndx = distance(arr, mn);
				std::cout << "minimum num in array: "<< *mn << " minIndx: "<< minIndx << std::endl;
				//or finding index be like
				std::cout << "index of min num : "<< (mn-arr) << std::endl;             //min num address - base address will be index of that min num.
				
				return 0;
			}
	
		//or using pointer you can create a iterator for array
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {   
				//for array finding max & min & their indexes
				int arr[] = {1,2,3,4,-5,90,7,8,9,10};           //min=-5, minIndx = 4 & max = 90, maxIndx = 5
				
				std::cout << "In Array: " << std::endl;
				
				std::cout << "maximum element is : "<< *max_element(arr,arr+10) << std::endl;
				
				//or
				int * ptr = max_element(arr,arr+10);
				std::cout << "maximum element using pointer : "<< *ptr << std::endl;
				std::cout << "index of max element : "<< (ptr-arr) << std::endl;            //elements address - base address.
				
				ptr = min_element(arr,arr+10);
				std::cout << "manimum element using pointer : "<< *ptr << std::endl;
				std::cout << "index of min element : "<< (ptr-arr) << std::endl;            //elements address - base address.
				
				//or using distance
				std::cout << "index of min element : "<< distance(arr, min_element(arr,arr+10)) << std::endl;
				return 0;
			}
	
	//Vector max/min element & its index
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {  
			//for vector finding max & min & their indexes
			vector<int> vec = {10,9,8,7,6,5,4,3,2,1};           //maxElement = 10 , maxIndex = 0
														//minElement= 1, minIndex = 9.
			
			for(int i: vec)
				cout<<i<<"\t";
			std::cout << std::endl;
			std::cout << "In vector: " << std::endl;
			
			//using auto keyword which is like iterator
			auto mx = max_element(vec.begin(), vec.end());
			int maxIndex = distance(vec.begin(), mx);				//for vector passing parameter is base address is (vectorName.begin(), iterator)
			std::cout << "maxElement : "<< *mx << ", maxIndex : "<< maxIndex << std::endl;
			
			//using iterator (in vector iterator is like pointer only easy to create, you can create actual/basic pointer also but no need)
			// in array you have to create pointer instead of iterator, 
			// iterator for vector & pointer for array
			
			vector<int>::iterator ptr = max_element(vec.begin(), vec.end());
			maxIndex = distance(vec.begin(), ptr);
			std::cout << "using POINTER, maxElement : "<< *ptr << ", maxIndex : "<< maxIndex << std::endl;
			
			std::cout << "minElement : "<< *min_element(vec.begin(), vec.end())<< ", minIndex : "<< distance(vec.begin(), min_element(vec.begin(), vec.end())) << std::endl;
			std::cout << "minElement: "<< *min_element(vec.begin(), vec.end()) <<", min element index: "<< (min_element(vec.begin(), vec.end())-vec.begin()) << std::endl;              //(element address - base address) = index of element
			
			return 0;
		}

	//auto iterator, extracting value using * & value to iterator
		#include<bits/stdc++.h>             //all header file include in this #include<bits/stdc++.h>
		#include <iostream>
		using namespace std;
		int main() {
			vector<int> vec = {1,2,3,4,5,6,707,8,9,10,11,12};       //maximum=707 index=6
			int n = vec.size();
			std::cout << "vec1 size: "<< n << std::endl;
			
			//traditional way,
			int mx = INT_MIN;                   //for INT_MIN  climits header file should be added. #include<climits>
			int indx;
			for(int i=0; i<n; i++){
				if(vec[i] > mx){
					mx = vec[i];
					indx = i;
				}
			}
			
			std::cout << "Traditional way, maximum element: "<< mx << ", At index: "<< indx << std::endl;
			
			//using built-in function.
			//finding maximum element
			auto maxer = max_element(vec.begin(), vec.end());
			cout<<"built-in function, Maximum element : "<<*maxer<<",\t";
			
			//finding index of Maximum element
			int index = distance(vec.begin(), maxer);
			std::cout << "At index: "<< index << std::endl<< std::endl;
			
			//other way to create a iterator for vector,
			vector<int> vec2 = {10,90,20,0,40};                     //min_element=0, index=3
			std::cout << "vec2 size: "<< vec2.size() << std::endl;
			
			//iterator
			vector<int>::iterator IT_vec2;
			IT_vec2 = min_element(vec2.begin(), vec2.end());
			
			//Minimum element from 2nd vector
			std::cout <<"Minimum element of vec2: "<< *IT_vec2 << ", ";
			
			//extracting the index of minimum element
			int indx_vec2_min_elmnt = distance(vec2.begin(), IT_vec2);
			std::cout << "At index: "<< indx_vec2_min_elmnt << std::endl;
			
			std::cout << "Address of minimum element: "<< &vec2[indx_vec2_min_elmnt] << std::endl;
			std::cout << "Address of minimum element using iterator: "<< &(*IT_vec2) << std::endl;
			
			std::cout << "Address of iterator IT_vec2: "<< &IT_vec2 << std::endl;           //stays constant
			
			IT_vec2++;
			
			std::cout << "Address of iterator IT_vec2 after updating: "<< &IT_vec2 << std::endl;        //same as previous
			std::cout << "Value at iterator IT_vec2: "<< *IT_vec2 << std::endl;
			
			//reseting the iterator to start of vec2
			IT_vec2 = vec2.begin();
			std::cout << "Value at iterator IT_vec2: after resetting "<< *IT_vec2 << std::endl;
			std::cout << "Address of iterator IT_vec2 after resetting: "<< &IT_vec2  << std::endl;      //still same as previous
			
			//updating value of vec2 using iterator
			//currently IT_vec2 is pointing to first element of vec2 which is 10
			//update it to 44
			*IT_vec2 = 4;
			std::cout <<"using vec2 index: "<< vec2[0] << std::endl;          //or
			std::cout << "using iterator: "<< *IT_vec2 << std::endl;
			
			std::cout << "vec2: ";
			for(int i: vec2)
				std::cout << i << " ";
			
			return 0;
		}
			//output:
				vec1 size: 12
				Traditional way, maximum element: 707, At index: 6
				built-in function, Maximum element : 707, At index: 6

				vec2 size: 5
				Minimum element of vec2: 0, At index: 3
				Address of minimum element: 0x55a4b02f730c
				Address of minimum element using iterator: 0x55a4b02f730c
				Address of iterator IT_vec2: 0x7ffc266acae0							//Address of iterator won't change
				Address of iterator IT_vec2 after updating: 0x7ffc266acae0				//Address of iterator won't change
				Value at iterator IT_vec2: 40
				Value at iterator IT_vec2: after resetting 10
				Address of iterator IT_vec2 after resetting: 0x7ffc266acae0				//Address of iterator won't change
				using vec2 index: 4
				using iterator: 4
				vec2: 4 90 20 0 40 

	//bitset, substr, extracting some char from starting or ending
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			int i= 8, len=4;
			string startS = bitset<32>(i).to_string();
			std::cout << startS  << std::endl;
			
			std::cout << startS.substr(startS.length()-5) << std::endl;         //extracting last 5 char
			
			int n=15;
			string second =  bitset<32>(n).to_string();
			
			std::cout << n << " = ";
			std::cout <<second << std::endl;

			second = second.substr(second.length()-8);
			std::cout << second << std::endl;           //extracting last 8 char

			//extracting 1st 5 char 00001
			std::cout << second.substr(0,5) << std::endl;
			return 0;
		}

	//string array sorting
		Practice-1:
			#include <iostream>
			#include<vector>
			#include<algorithm>
			using namespace std;

			int main() {
				vector<string> vec ={"Vivek", "Mahesh", "Nikate"};
				for(auto i: vec)
					std::cout << i << "\t";     //Vivek   Mahesh  Nikate
				
				std::cout << std::endl;
				
				sort(begin(vec), end(vec));         //Mahesh Nikate Vivek
				for(auto i: vec)
					std::cout << i << "\t";
					
				std::cout << std::endl;
				vector<string> vec2= {"ABC","ABCD","ABCDE","ABCDEF","ABCDEFG"};
				for(auto i: vec2)
					std::cout << i << "\t";     //ABC     ABCD    ABCDE   ABCDEF  ABCDEFG
				
				std::cout << std::endl;
				
				//sorting string array
				sort(begin(vec2),end(vec2));
				for(auto i: vec2)
					std::cout << i << "\t";     //ABC     ABCD    ABCDE   ABCDEF  ABCDEFG

				std::cout  << std::endl;
				vector<string> vec3 = {"vivek","Vivek"};
				for(auto i: vec3)
					std::cout << i << "\t";     //vivek Vivek               //ascii value of V is less than v.
				
				std::cout << std::endl;
				sort(begin(vec3),end(vec3));
				for(auto i: vec3)
					std::cout << i << "\t";     //Vivek   vivek
				
				std::cout << std::endl;
				// sorted in alphabetical order
				vector<string> vec4 = {"FG","GH","HI","CD","AB","BC","DE","EF"};    
				for(auto i: vec4)
					std::cout << i << "\t";     // "FG","GH","HI","CD","AB","BC","DE","EF"
				
				std::cout << std::endl;
				// after sorting
				sort(begin(vec4),end(vec4));
				for(auto i: vec4)
					std::cout << i << "\t";             //"AB","BC","CD","DE","EF","FG","GH","HI"
				
				return 0;
			}

		Practice-2:
			-you can replace all header files with <bits/stdc++.h>
			// #include <iostream>
			// #include<vector>
			// #include<algorithm>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				vector<string> vec1 = {"ABC", "ABCD", "ABCE", "ABCA"};
				for(string i: vec1)
					std::cout << i << "\t";         //"ABC", "ABCD", "ABCE", "ABCA"
					
				// after sorting
				std::cout << std::endl;
				sort(begin(vec1),end(vec1));
				for(auto i: vec1)
					std::cout << i << "\t";     // ABC     ABCA    ABCD    ABCE
					
				std::cout << std::endl;
				vector<string> vec2 = {"ABCD", "ABCE", "ABCA","ABC"};
				
				for(auto i: vec2)
					std::cout << i << "\t";     //"ABCD", "ABCE", "ABCA","ABC"
					
				std::cout << std::endl;
				
				sort(begin(vec2),end(vec2));
				for(auto i: vec2)
					std::cout << i << "\t";     //ABC     ABCA    ABCD    ABCE

				return 0;
			}

		Practice-3:
			sorting string elements.
			#include <iostream>
			#include<algorithm>
			using namespace std;

			int main() {
				string s ="ABCDEZZBA";
				std::cout << s << std::endl;		// ABCDEZZBA
				
				// increasing order
				// sort(begin(s),end(s));
				// or
				sort(s.begin(), s.end());
				
				std::cout << s << std::endl;		// AABBCDEZZ
				
				// decreasing order
				// sort(begin(s),end(s), greater<int>());
				// or
				sort(s.begin(), s.end(), greater<int> ());
				
				std::cout << s << std::endl;		// ZZEDCBBAA
				return 0;
			}

	// Sorting static array:
		#include <iostream>
		#include<vector>
		#include<algorithm>

		using namespace std;

		int main() {
				
			int a[] = {4,3,2,1,10,9,8,7,55};
			int n=9;
			
			for(int I: a)
				std::cout << I << "\t";
			
			// increasing order
			sort(begin(a), end(a));
			// or
			// sort(a, a+n);
			
			
			std::cout << std::endl;
				
			for(int I: a)
				std::cout << I << "\t";
			
			// Decreasing Order
			// sort(begin(a), end(a), greater<int>());
			// or
			sort(a, a+n, greater<int> ());			
			std::cout << std::endl;
				
			for(int I: a)
				std::cout << I << "\t";
				
			return 0;
		}

	//Iterator:
		-ContainerType should be replaced with the type of your container (e.g., std::vector<int>, std::list<double>, etc.).
		-container is the container you want to search within.
		-value is the value you want to find within the container.
		-std::find returns an iterator pointing to the found element. 
		-You can compare it to container.end() to determine if the element was found. 
		 If the iterator is not equal to container.end(), the element was found, and you can access it using *result.

		Here's an example using std::find with a std::vector:
		eg.
			#include <algorithm> // Include the algorithm header for std::find
			#include <iterator>  // Include the iterator header for iterator types

			// Using std::find to search for an element in a container
				ContainerType::iterator result = std::find(container.begin(), container.end(), value);

			// Check if the element was found
			if (result != container.end()) {
				// Element found, you can access it using *result
			} else {
				// Element not found
			}


		#include <iostream>
		#include <vector>
		// #include<bits/stdc++.h>
		#include<algorithm>
		using namespace std;
		int main() {
			std::vector<int> numbers = {1, 2, 3, 4, 5};

			// Obtain an iterator to a specific element.
			std::vector<int>::iterator it = std::find(numbers.begin(), numbers.end(), 3);

			// Check if the element was found before accessing it.
			if (it != numbers.end()) {
				// Calculate the position using std::distance.
				int position = std::distance(numbers.begin(), it);
				std::cout << "Element 3 found at position " << position << std::endl;
			} else {
				std::cout << "Element not found" << std::endl;
			}
			return 0;
		}

	//vector sorting & finding their indexes using find() & distance() method
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> vec = {40,50,30,60,20,70,10};
			
			for(int i: vec)
				std::cout << i << " ";
			std::cout << std::endl;
			
			//printing the vector element in reverse order
			for(auto i = vec.rbegin(); i != vec.rend(); i++)
				std::cout << *i << std::endl;
			
			vector<int> sortedVec = vec;    
			//index of element sorted way
			sort(sortedVec.begin(), sortedVec.end());
			std::cout << std::endl;
			std::cout << "Address of element in vec: " << std::endl;
			for(int i=0; i<vec.size(); i++){
				// std::cout <<"index of " << sortedVec[i] <<" at "<< abs(vec.begin() - find(vec.begin(), vec.end(), sortedVec[i])) << std::endl;
				std::cout <<"index of " << sortedVec[i] <<" at "<< distance(vec.begin(), find(vec.begin(), vec.end(), sortedVec[i])) << std::endl;
			}
			return 0;
		}

		//or
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				int ans=0;
				vector<int> h = {20, 2, 3, 4, 1};
				for(int i: h)
					std::cout << i << " ";
				std::cout << std::endl;
				
				//using find method showing the index
				for(int i: h){
					std::cout << i << " is present at index: "<< abs(find(h.begin(), h.end(), i)- h.begin()) << std::endl;
				}
			}

	//unordered_map mapping indexes with respective element
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> h = {100, 200, 300, 400};
			int n=5;

			unordered_map<int, int> indexMap;
			for (int i = 0; i < n; i++) {
				indexMap[h[i]] = i;
			}
			
			cout<<"unordered_map : "<<endl;
			for(auto i: indexMap){
				std::cout << "key " << i.first <<" at index "<< i.second << " indexMap[i.first] inserting key outputing value :"<< indexMap[i.first];
				std::cout << "\tindexMap[i.second] inserting value : " << indexMap[i.second]  << std::endl;
				//if that value is present in keys list then it will output as the value associated with that key, else it will be 0.
			}			
			
			return 0;
		}

	//unordered_map
		-if you use advance for loop then you have to use . (dot) Syntax.
		eg.
			for(auto i: unMP){
				std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
			}
		
		-if you use traditional/ normal for look then you have to use -> (arrow) syntax.
		eg. 
			normal for loop, to access the data use -> syntax, for map data type should be auto.
			for(auto i = unMP.begin(); i!= unMP.end(); i++)
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;

		eg.
			-when we pass key to unordered_map like unMP[i] (key), then it will print the corresponding value of it.
			 if value is not present for that key, then it will considered as 0.
			for(int i: sortedVersion)
				std::cout << "Key: "<< i << "  Value: "<< unMP[i] << std::endl;
				

		eg.
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				vector<int> vec = {600,700, 100 ,800, 900, 1,400,200,300,500};
				std::cout << "Toal "<< vec.size()<< " elements present in vector" << std::endl;
				
				std::cout << "The vector elements are :: " << std::endl;
				for(int i: vec)
					std::cout << i << " ";
				cout<<endl;
				
				vector<int> sortedVersion = vec;
				sort(sortedVersion.begin(), sortedVersion.end());
				
				std::cout << "vector elements in sorted order : " << std::endl;
				for(int i: sortedVersion)
					std::cout << i << " ";
				cout<<endl;
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i] = cnt++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				for(auto i = unMP.begin(); i!= unMP.end(); i++)
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
					
				//using advance for loop
				std::cout << endl << "using advance for loop printing key value of unordered_map : " << std::endl;
				for(auto i: unMP){
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				}
				std::cout << std::endl;
				
				std::cout <<endl<< "printing using unordered_map with sortedVersion : " << std::endl;
				for(int i: sortedVersion)
					std::cout << "Key: "<< i << "  Value: "<< unMP[i] << std::endl;
				
				return 0;
			}

		// unordered_map keys ascending order:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			bool keyASC(pair<int, int> a, pair<int, int> b){
				return a.first < b.first;
			}

			int main() {
				vector<int> vec = {600,7, 7, 7,0, 100, 500 ,500,600};
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i]++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				vector<pair<int, int>> holder;
				for(auto i = unMP.begin(); i!= unMP.end(); i++){
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
				holder.push_back({i->first, i->second});
				}
				
				sort(holder.begin(), holder.end(), keyASC);
				
				//using advance for loop
				std::cout << endl << "Holder : " << std::endl;
				for(auto i: holder)
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				std::cout << std::endl;
				
				return 0;
			}
		
		// unordered_map keys descending order:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			bool keyDESC(pair<int, int> a, pair<int, int> b){
				return a.first > b.first;
			}

			int main() {
				vector<int> vec = {600,7, 7, 7, 0, 100, 500 ,500,600};
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i]++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				vector<pair<int, int>> holder;
				for(auto i = unMP.begin(); i!= unMP.end(); i++){
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
				holder.push_back({i->first, i->second});
				}
				
				sort(holder.begin(), holder.end(), keyDESC);
				
				//using advance for loop
				std::cout << endl << "Holder : " << std::endl;
				for(auto i: holder)
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				std::cout << std::endl;
				
				return 0;
			}

		// unordered_map value ascending order:
			-if values are same, then it just put the keys in any random order smaller or larger before or after
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			bool valuASC(pair<int, int> a, pair<int, int> b){
				return a.second < b.second;
			}

			int main() {
				vector<int> vec = {600,7, 7, 7, 0,400, 100, 500 ,500,600,400};
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i]++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				vector<pair<int, int>> holder;
				for(auto i = unMP.begin(); i!= unMP.end(); i++){
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
					holder.push_back({i->first, i->second});
				}
				
				sort(holder.begin(), holder.end(), valuASC);
				
				//using advance for loop
				std::cout << endl << "Holder : " << std::endl;
				for(auto i: holder)
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				std::cout << std::endl;
				return 0;
			}

		// unordered_map values are ascending order, if values are same then keys also should be in ascending order:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			bool valuASC(pair<int, int> a, pair<int, int> b){
				if(a.second == b.second)
					return a.first < b.first;
				return a.second < b.second;
			}

			int main() {
				vector<int> vec = {600,7, 7, 7, 0,400, 100, 500 ,500,600,400};
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i]++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				vector<pair<int, int>> holder;
				for(auto i = unMP.begin(); i!= unMP.end(); i++){
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
					holder.push_back({i->first, i->second});
				}
				
				sort(holder.begin(), holder.end(), valuASC);
				
				//using advance for loop
				std::cout << endl << "Holder : " << std::endl;
				for(auto i: holder)
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				std::cout << std::endl;
				
				return 0;
			}

		// unordered_map values are in descending order:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			bool valueDESC(pair<int, int> a, pair<int, int> b){
				return a.second > b.second;
			}

			int main() {
				vector<int> vec = {600,7, 7, 7, 0,400, 100, 500 ,500,600,400};
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i]++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				vector<pair<int, int>> holder;
				for(auto i = unMP.begin(); i!= unMP.end(); i++){
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
				holder.push_back({i->first, i->second});
				}
				
				sort(holder.begin(), holder.end(), valueDESC);
				
				//using advance for loop
				std::cout << endl << "Holder : " << std::endl;
				for(auto i: holder)
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				std::cout << std::endl;
				
				return 0;
			}

		// unordered_map values are in descending order if values are same then keys also should be in descending order:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			bool valueDESC(pair<int, int> a, pair<int, int> b){
				if(a.second == b.second)
					return a.first > b.first;
				return a.second > b.second;
			}

			int main() {
				vector<int> vec = {600,7, 7, 7, 0,400, 100, 500 ,500,600,400};
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i]++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				vector<pair<int, int>> holder;
				for(auto i = unMP.begin(); i!= unMP.end(); i++){
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
				holder.push_back({i->first, i->second});
				}
				
				sort(holder.begin(), holder.end(), valueDESC);
				
				//using advance for loop
				std::cout << endl << "Holder : " << std::endl;
				for(auto i: holder)
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				std::cout << std::endl;
				
				return 0;
			}

	//Sorting unordered_map:
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		bool functionSortingByValue (pair<int, int> a, pair<int, int> b){
			return a.second < b.second;             //in ascending Order
			
			// return a.second > b.second;          // in descending Order
		}

		int main() {
			unordered_map<int, int> umap;
			
			umap[10] = 1;
			umap[200] = 20;
			umap[3] = 11;
			umap[40] = 25;
			umap[500] = 4;
			umap[1] = 35;
			
			std::cout << "Original Map: " << std::endl;
			
			vector<pair<int, int>> sorted;
			
			for(auto i: umap){
				std::cout << i.first << "\t" << i.second << std::endl;
				sorted.push_back({i.first, i.second});
			}
				
			std::cout << "\nSorted Order by keys: " << std::endl;
			
			//simple sort function
			sort(sorted.begin(), sorted.end());
			
			for(pair<int, int> i: sorted){
				std::cout << i.first << "\t" << i.second << std::endl;
			}
			std::cout << std::endl;
			
			std::cout << "\nSorted Order by value : " << std::endl;
			//sort function to sort based on key's value.
			
			// sort(sorted.begin(), sorted.end(), functionSortingByValue);
			
			//or
			/*
				sort(sorted.begin(), sorted.end(),[](pair<int, int> a, pair<int, int> b){
					return a.second > b.second;         //in Descending order.      function within another function
				});

			*/
			
			for(pair<int, int> i: sorted){
				std::cout << i.first << "\t" << i.second << std::endl;
			}
			return 0;
		}

	// Sorting vector of pairs in ASC & DESC based on keys
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;
		bool compByValueASC(pair<int, int> a, pair<int, int> b);
		bool compByValueDESC(pair<int, int> &a, pair<int, int> &b);

		int main() {
			int n = 5;
			int arr[] = {6,4,7,1,9};
			int brr[] = {1,2,5,4,3};
			
			// sorting pair based on keys
			vector<pair<int, int>> v;
				for(int i=0; i<n; i++)
					v.push_back({arr[i], brr[i]});
					
			for(pair<int, int> p: v)
				cout<< p.first << "\t" << p.second << "\n";
				
			sort(v.begin(), v.end());
			std::cout << "Sorted in ASC: " << std::endl;
			for(pair<int, int> p: v)
				cout<< p.first << "\t" << p.second << "\n";
				
			sort(v.begin(), v.end(), greater<pair<int, int>>());
			std::cout << "Sorted in DESC: " << std::endl;
			for(pair<int, int> p: v)
				cout<< p.first << "\t" << p.second << "\n";
			
			
			// sorting pair based on key's value
			sort(v.begin(), v.end(), compByValueASC);
			std::cout << "Sorted in ASC by values: " << std::endl;
			for(pair<int, int> p: v)
				cout<< p.first << "\t" << p.second << "\n";
			
			sort(v.begin(), v.end(), compByValueDESC);
			std::cout << "Sorted in DESC by values: " << std::endl;
			for(pair<int, int> p: v)
				cout<< p.first << "\t" << p.second << "\n";
			
			return 0;
		}

		bool compByValueASC(pair<int, int> a, pair<int, int> b){
			if(a.second < b.second)
				return 1;
			return 0;
		}

		bool compByValueDESC(pair<int, int> &a, pair<int, int> &b){
			if(a.second > b.second)
				return 1;
			return 0;
		}

	//Accumulator in c++:
		#include <numeric> 
		sum = accumulate(arr.begin(), arr.end(), 0);			//accumulate(startAddressArray, endAddressArray, initialSum);
		where 0, initialSum is in int type ie. 32 bit

		if you want sum of array of containing long long int values then accumulate function's initialSum = 0LL
		eg.
			sum = accumulate(v.begin(),v.end(),0LL);
			//or
			sum = accumulate(v.begin(),v.end(),0ll);
			//or
			long long value=0;
			sum = accumulate(v.begin(),v.end(),value);

		The accumulate function is used to calculate the sum of all elements 
		in the specified range (in this case, the range is defined by arr.begin() and arr.end()). 
		The result is then added to the sum variable, which holds the running sum of the elements in the array. 
		After this line of code is executed, sum will contain the total sum of all elements in the array.

		#include <iostream>
		#include<numeric>
		#include<vector>
		using namespace std;

		int main() {
			vector<int> v = {1,2,3,4,5,6,7,8,9,10};
			int sum = accumulate(v.begin(), v.end(), 0);
			
			std::cout << accumulate(v.begin()+1,v.begin()+3,0) << std::endl;    //5     //exclude last index, means 3-1 = 2, total no.of elements to be added will be 2 only
			
			std::cout << "complete array summation : "<< sum << std::endl; //55
			
			std::cout << "sum of first 5 elements :"<< accumulate(v.begin(), v.begin()+5,0) << std::endl;           //15
			
			std::cout << "sum of 4 elements from 2nd index: "<< accumulate(v.begin()+1,v.begin()+5,0) << std::endl;     //14
			
			std::cout << "Sum of 3rd index & 4th index:" << accumulate(v.begin()+3, v.begin()+5,0) << std::endl;        //9
			
			std::cout << "sum of first 5 elements initial sum 3 :"<< accumulate(v.begin(), v.begin()+5, 3) << std::endl;           //18
		}

	//C++ OOPS:
		-In C++, the default access specifier for members of a class is private. 
		 This means that if you don't explicitly specify an access specifier for 
		 your class members (methods or variables), they will be private by default.

	//TimeConversion 12 hour to 24 hour format:
		#include <iostream>
		#include<bits/stdc++.h>

		using namespace std;

		int main() {
			string s = "12:15:06 AM";
			
			string AmPm = s.substr(s.length()-2,2);
			// std::cout << AmPm << std::endl;
			string hour = s.substr(0,2);
			// std::cout << hour << std::endl;
			
			if(AmPm == "PM" && hour != "12"){
				hour = to_string(stoi(hour)+12);
			}else if(AmPm == "AM" && hour == "12"){
				hour ="00";
			}
			
			string timeString = hour + s.substr(2,6);
			
			std::cout << timeString  << std::endl;
			return 0;
		}

	//is_sorted:
		-The is_sorted function is part of the C++ Standard Template Library (STL), 
		 specifically provided by the <algorithm> header. 
		 This function is used to check whether a range of elements is sorted in non-decreasing order. 
		-It returns a boolean value indicating whether the elements in the specified range are sorted.
		
		#include <iostream>
		#include <algorithm>
		#include <vector>

		int main() {
			std::vector<int> numbers = {1, 2, 3, 5, 4, 6};

			if (std::is_sorted(numbers.begin(), numbers.end())) {
				std::cout << "The vector is sorted.\n";
			} else {
				std::cout << "The vector is not sorted.\n";
			}

			return 0;
		}

	//All DataTypes MIN MAX values:
		#include <iostream>
		#include <climits>
		#include <cfloat>

		int main() {
			std::cout << "For int:" << std::endl;
			std::cout << "INT_MIN: " << INT_MIN << std::endl; // Minimum value for int: -2147483648
			std::cout << "INT_MAX: " << INT_MAX << std::endl; // Maximum value for int: 2147483647

			std::cout << "\nFor unsigned int:" << std::endl;
			std::cout << "0 (min) - UINT_MAX: " << UINT_MAX << std::endl; // Maximum value for unsigned int: 4294967295

			std::cout << "\nFor short:" << std::endl;
			std::cout << "SHRT_MIN: " << SHRT_MIN << std::endl; // Minimum value for short: -32768
			std::cout << "SHRT_MAX: " << SHRT_MAX << std::endl; // Maximum value for short: 32767

			std::cout << "\nFor unsigned short:" << std::endl;
			std::cout << "0 (min) - USHRT_MAX: " << USHRT_MAX << std::endl; // Maximum value for unsigned short: 65535

			std::cout << "\nFor long:" << std::endl;
			std::cout << "LONG_MIN: " << LONG_MIN << std::endl; // Minimum value for long: -9223372036854775808
			std::cout << "LONG_MAX: " << LONG_MAX << std::endl; // Maximum value for long: 9223372036854775807

			std::cout << "\nFor unsigned long:" << std::endl;
			std::cout << "0 (min) - ULONG_MAX: " << ULONG_MAX << std::endl; // Maximum value for unsigned long: 18446744073709551615

			std::cout << "\nFor long long int:" << std::endl;
			std::cout << "LLONG_MIN: " << LLONG_MIN << std::endl; // Minimum value for long long int: -9223372036854775808
			std::cout << "LLONG_MAX: " << LLONG_MAX << std::endl; // Maximum value for long long int: 9223372036854775807

			std::cout << "\nFor unsigned long long int:" << std::endl;
			std::cout << "0 (min) - ULLONG_MAX: " << ULLONG_MAX << std::endl; // Maximum value for unsigned long long int: 18446744073709551615

			std::cout << "\nFor float:" << std::endl;
			std::cout << "FLT_MIN: " << FLT_MIN << std::endl; // Minimum value for float: 1.17549e-38
			std::cout << "FLT_MAX: " << FLT_MAX << std::endl; // Maximum value for float: 3.40282e+38

			std::cout << "\nFor double:" << std::endl;
			std::cout << "DBL_MIN: " << DBL_MIN << std::endl; // Minimum value for double: 2.22507e-308
			std::cout << "DBL_MAX: " << DBL_MAX << std::endl; // Maximum value for double: 1.79769e+308

			std::cout << "\nFor long double:" << std::endl;
			std::cout << "LDBL_MIN: " << LDBL_MIN << std::endl; // Minimum value for long double: 3.3621e-4932
			std::cout << "LDBL_MAX: " << LDBL_MAX << std::endl; // Maximum value for long double: 1.18973e+4932

			return 0;
		}

	//For Loop:
		#include <iostream>
		using namespace std;

		int main() {
			//using comma (,) works like or,
			//you can use || (pipe operator) this also
			//you can use direct or keyword also or.
			for(int i=0,j=2; i<5 || j<10; i++,j++)
				std::cout << i <<"\t"<< j << std::endl;
			
			std::cout << std::endl;
			//using and keyword ()
			for(int i=11,j=11; i<105 and j<20; i++,j++)
				std::cout << i <<"\t"<< j << std::endl;
				
			std::cout << std::endl;
			//using && operator
			for(int i=1000,j=10; i<1005 && j>=1; i++,j--)
				std::cout << i <<"\t"<< j << std::endl;

		return 0;
		}

		//updating values in loop
			#include <iostream>
			using namespace std;
			int main() {
				int n=5;
				
				//updating the value during running loop
				for(int i=0; i<n; i++){
					if(i&1)
						n++;
					std::cout << i << "\t";			//1 2 3 4 5 6 7 8
				}
				return 0;
			}

	//initialization {}:
		#include<climits>
		#include <iostream>
		using namespace std;

		int main() {
			
			int i {INT_MAX}, j{};               //i = INT_MAX, j=0;
			std::cout << i << std::endl;
			
			for(int eight{}; eight<8; ++eight)
				std::cout << eight << std::endl;
			
			std::cout << std::endl;
			for(int eight{}; eight<8; eight++)
				std::cout << eight << std::endl;
			
			return 0;
		}

	//one-liner (single line code) for 
		1) vector to set
		2) set to vector

		#include <iostream>
		#include<vector>
		#include<set>
		#include<map>
		#include<algorithm>
		#include<unordered_set>

		using namespace std;

		int main() {
			// vector<int> v = {1,2,3,4,5,6,11,12,11,12,7,8,9,0,1,2,3,4,5,6,7,8,9,0};       //or
			vector<int> v {1,2,3,4,5,6,13,11,12,11,12,7,8,9,0,1,2,3,4,5,6,7,8,9,0};
			int n=25;
			
			for(int i: v)
				std::cout << i << " ";
			
			//vector to unordered_set
			std::cout << std::endl;
			unordered_set<int> us (v.begin(), v.end());
			//for above line is a shorthand for below code
			/*
				for(int i=0; i<v.size(); i++)
					us.insert(v[i]);
			*/
			
			for(int i: us)
				std::cout << i << " ";
				
			std::cout << std::endl;
			//vector to set
			set<int> ss (v.begin(), v.end());
			for(int i: ss)
				std::cout << i << " ";
				
			
			std::cout << std::endl;
			std::cout << std::endl;
			//converting unordered_set to vector
			vector<int> v1 (us.begin(), us.end());
			for(int i: v1)
				std::cout << i << " ";
				
			
			std::cout << std::endl;
			std::cout << std::endl;
			// converting set to vector
			vector<int> v2 (ss.begin(), ss.end());
			for(int i: v2)
				std::cout << i << " ";
			
				
			//map
			map<int, int> mp;
			for(int i=0; i<v.size(); i++)
				mp[v[i]]++;
			
			std::cout << std::endl;
			std::cout <<"MP "<< std::endl;
			//printing
			for(auto itr: mp)
				std::cout << itr.first << "\t" << itr.second << std::endl;
				
			//or shorthand for above code, to apply map on vector
			map<int, int> mp1;
			std::for_each(v.begin(), v.end(), [&mp1](const int& element) { mp1[element]++; });

			std::cout << std::endl;
			std::cout <<"MP2 "<< std::endl;
			//printing
			for(auto itr: mp1)
				std::cout << itr.first << "\t" << itr.second << std::endl;
				
			
			//map values into vector
			vector<int> mp1_to_vec;
			
			for(auto i: mp)
				mp1_to_vec.push_back(i.second);
			
			std::cout << std::endl;
			for(auto i: mp1_to_vec)
				std::cout << i << " ";
				
			return 0;
		}

	//short names for datatype with 'using' keyword
		long long myVariable = 42;

		//or
			using ll = long long;
			ll myVariable = 42;
		eg.
			#include <iostream>
			using n = int;
			using f = float;
			using ll = long long;
			using namespace std;

			int main() {
				int b=8;
				std::cout << b << std::endl;
				
				n a=90;                                 //int -> n
				std::cout << a << std::endl;
				
				f ft = 70.89f;
				std::cout << ft << std::endl;
				
				ll myLL = 123456789876432;
				std::cout << myLL << std::endl;
				
				return 0;
			}

	//Set Advance Method:
		//WAP to	1. Create a set & print all its element.
				2. Access the first & last element of set.
				3. Demonstrate Advance method.
			
			#include <iostream>
			#include<set>
			using namespace std;
			int main() {
				set<int> s;
				
				// inserting 15 to 0 elements into set s
				// in whatever order you insert the elements into set, the set by default arrange them in increasing order
				for(int i=15; i>=0; i-=2)
					s.insert(i);
					
				//printing the set elements
				for(auto i = s.begin(); i != s.end(); i ++)
					std::cout << *i << "\t";						//1       3       5       7       9       11      13      15
				
				// we can not access elements of set using index like this s[0] or s[4]
				// we need to use the iterator for it.
				// std::cout << s[0] << std::endl;          Error
				
				// to print the first element of set
				std::cout << std::endl;
				auto it = s.begin();
				std::cout << "Starting value of set: " << *it << std::endl;    //1   // we have to use dereference operator(*) to display the value.
				
				// to print the last element of set
				it = s.end(), it--;
				std::cout <<  "Ending value of set: " << *it << std::endl;	//15
				
				// to print the 2nd last element of set
				it--;
				std::cout <<  "2nd last value of set: " << *it << std::endl;	//13
				
				std::cout << std::endl;
				
				// to access the second element of set, we can use advance operator (0-based index)
				auto it1 = s.begin();
				advance(it1,1);
				std::cout << "Second advance(it1,1) element of set: " << *it1 << std::endl;     //3
				
				it1 = s.begin();
				advance(it1,2);
				std::cout << "Third element advance(it1,2) of set: " << *it1 << std::endl;      //5
				
				it1 = s.begin();
				advance(it1, 4);
				std::cout << "fifth element advance(it1,4) of set: " << *it1 << std::endl;      //9
				
				// to access the middle element of set
				it1 = s.begin();
				advance(it1, s.size()/2);
				std::cout << "middle element of set: " << *it1 << std::endl;		//9
				
				// to access last element & 2nd last element of set
				it1 = s.begin();
				advance(it1, -1);               //prints the size of set
				std::cout <<"advance(it1, -1) Last element using begin operation: "<< *it1 << std::endl;        //8
				
				it1 = s.begin();
				advance(it1, -2);               //last element
				std::cout <<"advance(it1, -2) Last element using begin operation: "<< *it1 << std::endl;        //15
				
				it1 = s.begin();
				advance(it1, -3);               //last 2nd element
				std::cout <<"advance(it1, -3) Last element using begin operation: "<< *it1 << std::endl;         //13
				
				
				it1 = s.begin();
				advance(it1, -4);           //last 3rd element
				std::cout <<"advance(it1, -4) Last element using begin operation: "<< *it1 << std::endl;         //13
				
				it1 = s.begin();
				advance(it1, -5);           //last 4th element
				std::cout <<"advance(it1, -5) Last element using begin operation: "<< *it1 << std::endl;         //9
				
				it1 = s.begin();
				advance(it1, -6);
				std::cout <<"advance(it1, -6) Last element using begin operation: "<< *it1 << std::endl;         //7
	
				auto it2 = s.begin();
				advance(it2, 20);
				std::cout <<"Size: "<< *it2 << std::endl;     // size crossed so, prints 8 as size of set.
				
				it2 = s.end();                      //s.end() this indicate the complete end or this is index where it2 is at (actualEnd + 1) index.
				std::cout << "This crossed the size so prints the size of set: " << *it2 << std::endl;
				
				
				return 0;
			}

	//Advance Method in Vector:
		#include <iostream>
		#include<vector>
		using namespace std;
		int main() {
			vector<int> vec {400, 21, 34, 56, 78, 99, 44, 22};
			
			// starting element
			auto it = vec.begin();
			std::cout << *it << std::endl;
			
			// starting element
			int start = vec.front();
			std::cout << start << std::endl;
			
			std::cout << std::endl;
			//ending element
			int end = vec.back();
			std::cout << end << std::endl;
			
			//ending element
			it = vec.end();             // need to go back one place 
			it--;
			std::cout << *it << std::endl;
			
			
			// Advance method
			it = vec.begin();
			
			// to print the 5th element from starting (0-based indexing)
			advance(it,4);
			std::cout << "advance(it,4): "<< *it << std::endl;
			
			// or without using advance method.
			std::cout <<"without using advance: "<< vec[4] << std::endl;
			
			return 0;
		}

	// begin() & cbegin():
		-begin() is non-constant iterator. returns the value which we can modifiable.
		-cbegin() is constant iterator. returns the value which we can not modify.

		begin(): This function returns an iterator to the beginning of the container. 
				If the container is non-const, the returned iterator allows modification of the elements in the container. 
				If the container is const-qualified, the returned iterator is a constant iterator, 
				meaning it does not allow modification of the elements in the container.

		cbegin(): This function returns a constant iterator to the beginning of the container 
				regardless of whether the container itself is const-qualified or not. 
				It always returns a constant iterator, 
				meaning it does not allow modification of the elements in the container.
		eg.
			begin() & end():
				#include <iostream>
				#include<vector>
				using namespace std;

				int main() {
					vector<int> v = {1,32,3,4,5,6};
					
					// array elements
					for(int i: v)
						std::cout << i << " ";

					cout<<endl;
					// printing vector using iterator in reverse order
					for(auto i = v.begin(); i != v.end(); i++)
						std::cout << *i  << " ";
					
					//this is vector iterator
					vector<int>::iterator it = v.begin()+3;     //pointing to 4
					
					//or you can create vector iterator using auto keyword
					auto it2 = v.begin()+1;           //pointing to second element ie. 32
					std::cout << std::endl;
					std::cout <<"Auto keyword: "<< *it2 ;
					
					// printing the value of iterator to where it is pointing
					std::cout << std::endl<<endl;
					std::cout <<"Value of iterator before modification : "<< *it << std::endl;
					
					// this is normal iterator so we can change its value also
					*it = 99;
					std::cout << "Value of iterator After modification : "<< *it << endl;
					
					// array elements after modification (4 replaced by 99)
					std::cout << std::endl;
					for(int i: v)
						std::cout << i << " ";

					return 0;
				}
				/*
					output:
					1 32 3 4 5 6 
					1 32 3 4 5 6 
					Auto keyword: 32
					
					Value of iterator before modification : 4
					Value of iterator After modification : 99
					
					1 32 3 99 5 6 
				*/

			cbegin() & cend():
				#include <iostream>
				#include<vector>
				using namespace std;

				int main() {
					vector<int> v = {1,32,3,4,5,6};
			
					// array elements
					std::cout << "Using foreach loop: " << "\t";
					for(int i: v)
						std::cout << i << " ";
						
					std::cout << std::endl;
					std::cout <<"Using iterator : \t";
					// printing vector using iterator in reverse order
					for(auto i = v.cbegin(); i != v.cend(); i++)
						std::cout << *i  << " ";
					
					// this is iterator which returns the value of array as constant, you can't change that
					vector<int>::const_iterator cItr = v.cbegin()+1;            //pointing to the second element of array
					
					std::cout << std::endl<<endl;
					std::cout << "2nd element of v: " << *cItr << std::endl;
					
					// *cItr = 89;          //Error we can't do this.
					
					//or you can use auto keyword to create const_iterator for vector
					auto cItr2 = v.cbegin()+5;          //6
					
					std::cout << "Auto keyword : "<< *cItr2 << std::endl;
					
					
					// array elements after modification (4 replaced by 99)
					std::cout << std::endl;
					for(int i: v)
						std::cout << i << " ";

					return 0;
				}
				/*
					output:
					Using foreach loop:     1 32 3 4 5 6 
					Using iterator :        1 32 3 4 5 6 

					2nd element of v: 32
					Auto keyword : 6

					1 32 3 4 5 6 
				*/

		rbegin() and rend():
			are functions used to obtain reverse iterators to the beginning and the end of a container, 
			respectively. On the other hand, crbegin() and crend() are similar functions, 
			but they return constant reverse iterators, which do not allow modification of the elements in the container.

			rbegin(): Returns a reverse iterator pointing to the last element of the container, which is the reverse beginning.
			rend(): Returns a reverse iterator referring to the position just before the first element of the container, which is the reverse end.
			crbegin(): Returns a constant reverse iterator pointing to the last element of a const-qualified container.
			crend(): Returns a constant reverse iterator referring to the position just before the first element of a const-qualified container.
		eg.
			rbegin() & rend():
				#include <iostream>
				#include<vector>
				using namespace std;

				int main() {
					vector<int> v = {40,50, 90, 10, 5, 2, 3, 1};
					
					std::cout << "Actual array: " << "\t";
					for(int i: v)
						std::cout << i << " ";
					
					std::cout << std::endl;
					std::cout << std::endl << "Array using reverse iterator: ";
					
					// printing vector using iterator in reverse order
					for(auto i = v.rbegin(); i != v.rend(); i++)
						std::cout << *i  << " ";
						
					std::cout  << std::endl;
					
					// this is pointing to last element ie. 1 (using reverse_iterator)
					vector<int>::reverse_iterator itr1 = v.rbegin();
					std::cout << "starting element from last (0-index based): " << *itr1 << std::endl;
					
					
					// changing the value at 3 place using rbegin iterator
					// using auto keyword
					auto itr2 = v.rbegin()+3;
					std::cout << "3rd element from last (0-index based): " << *itr2 << std::endl;
					
					*itr2 = 78;
					std::cout << "3rd element from last modfied (0-index based): "<< *itr2 << std::endl;
					
					std::cout  << std::endl;
					std::cout << "Actual Array: ";
					for(int i: v)
						std::cout << i << " ";
					
					return 0;
				}
				/*
					output:
						Actual array:   40 50 90 10 5 2 3 1 

						Array using reverse iterator: 1 3 2 5 10 90 50 40 
						starting element from last (0-index based): 1
						3rd element from last (0-index based): 5
						3rd element from last modfied (0-index based): 78

						Actual Array: 40 50 90 10 78 2 3 1 
				*/

			crbegin() & crend():
				#include <iostream>
				#include<vector>
				using namespace std;

				int main() {
					vector<int> v = {1,32,3,4,5,6};
					
					// array elements
					std::cout << "Using foreach loop: " << "\t";
					for(int i: v)
						std::cout << i << " ";
						
					std::cout << std::endl;
					
					//last element
					vector<int>:: const_reverse_iterator crt = v.crbegin();
					std::cout << "last element: " << *crt << std::endl;
					
					//2nd last element
					crt = v.crbegin() + 1;
					std::cout << "2nd last element: " <<*crt << std::endl;
					
					// *crt =  12;                          //ERROR:assignment of read-only, this is constant reverse iterator, so you can't modify the value  
						std::cout << *crt << std::endl;	
						
					// printing in reverse order using constant reverse iterator
					std::cout << "printing in reverse order using constant reverse iterator : " << "\t";
					for(auto i = v.crbegin(); i != v.crend(); i++)
						std::cout << *i << " ";
						
					return 0;
				}
			
		practice string vector:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main() {
				vector<string> vec {"ABC", "DEF", "GHI", "JKL", "MNO"};

				std::cout << "using foreach loop: ";
				for(string s: vec)
					std::cout << s << " ";

				std::cout << std::endl<<endl<< "using iterator: ";
				for(auto i=vec.begin(); i!= vec.end(); i++)
					std::cout << *i <<" ";
					
				std::cout<<endl;
				std::cout << std::endl << "Using reverse iterator: ";
				for(auto i=vec.rbegin(); i!= vec.rend(); i++)
					std::cout << *i  << " ";
					
				std::cout<<endl;
				std::cout << std::endl << "Using constant iterator: ";
				for(auto i=vec.cbegin(); i!= vec.cend(); i++)
					std::cout << *i  << " ";

				std::cout<<endl;
				std::cout << std::endl << "Using constant reverse iterator: ";
				for(auto i=vec.crbegin(); i!= vec.crend(); i++)
					std::cout << *i  << " ";
						
				return 0;
			}
			/*
			output:
				using foreach loop: ABC DEF GHI JKL MNO 

				using iterator: ABC DEF GHI JKL MNO 
				
				Using reverse iterator: MNO JKL GHI DEF ABC 
				
				Using constant iterator: ABC DEF GHI JKL MNO 
				
				Using constant reverse iterator: MNO JKL GHI DEF ABC
			*/

	// Rotate method: ❌Pending
		1) using rotate method, by default rotate to left by specific number

		2) using rotate method, to rotate right by specific number

		3) without using rotate method

		4) in-place rotation:

		5) rotated using loops:
			#include <iostream>
			using namespace std;
			int main() {
				
				string s = "ABCDEFG";
				int d = 3;
				std::cout << s << std::endl;            // ABCDEFG
					
				// rotating left by d Digits
				for(int i=0; i<d; i++){
					char ch = *(s.begin());         // s.begin() returns the iterator at the char so access the value/ char we need to use * there.
					s.erase(s.begin());
					s.push_back(ch);
				}
				
				std::cout << s << std::endl;        // DEFGABC
				
				s = "Vivek";
				
				// rotating right by d digits
				while(d--){
					char lastCh = *(s.end()-1);         //we used * here to access the value at that iterator, s.end() returns the iterator memory address.
					s.erase(s.end()-1);
					s.insert(s.begin(), lastCh);
				}
				
				std::cout << s << std::endl;            // vekVi
				return 0;
			}
	
		6) rotated using substr method
			// Left
				#include <iostream>
				using namespace std;
				int main() {
					string s = "ABCDEFGH";
					int d = 5;
					std::cout << s << std::endl;        // ABCDEFGH

					// rotating left by d
					s = s.substr(d) + s.substr(0,d);
					
					std::cout << s << std::endl;        // FGHABCDE
					return 0;
				}
			
			// Right
				#include <iostream>
				using namespace std;
				int main() {
					string s = "ABCDEFGH";
					int d = 5;
					std::cout << s << std::endl;        // ABCDEFGH

					// rotating right by d
					int len = s.length();
					s = s.substr(len-d) + s.substr(0,len-d);            // DEFGH  + ABC
					
					std::cout << s << std::endl;        // FGHABCDE
					return 0;
				}
		Tip: Also refer POTD problem num. 382

	//Optional Beeping Sound char ascii value 7 & Delay functionality:
		#include <iostream>
		// #include<bits/stdc++.h>
		using namespace std;

		//for Delay functionality
		#include<chrono>
		#include<thread>
		int main() {
		
			std::cout <<char(7)<< std::endl;
			this_thread::sleep_for(chrono::milliseconds(400));
			
			std::cout <<char(7)<< std::endl;
			this_thread::sleep_for(chrono::milliseconds(400));
			
			std::cout <<char(7)<< std::endl;
			this_thread::sleep_for(chrono::milliseconds(400));
			
			std::cout <<char(7)<< std::endl;
			this_thread::sleep_for(chrono::milliseconds(400));
			
			std::cout <<char(7)<< std::endl;
			return 0;
		}

	//Name printer:
		#include <iostream>
		// #include<ctime>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			string s = "Vivek Nikate";
			
			int pointer = 1;
			
			string printer;
			
			for(int i=0; i<s.length(); i++){	
				pointer=1;
				
				while(1){
					printer += char(pointer);
					
					std::cout << printer <<endl;
					
					printer.pop_back();
					
					if(pointer == s[i]){
						printer+= char(pointer);
						break;
					}
					pointer++;
					this_thread::sleep_for(chrono::milliseconds(10));       //1000 means 1 second
				}        
			}	
			return 0;
		}

	// Transpose of matrix: (in-place)
		#include <iostream>
		using namespace std;
		int main() {
			int arr[][3] = {
				{1,2,3},
				{4,5,6},
				{7,8,9}
			};
			
			for(int i=0; i<3; i++){
				for(int j=0; j<3; j++)
					cout<<arr[i][j]<<"\t";
				std::cout << std::endl;
			}
			
			// logic to shift row to col & vice-versa
			for(int i=0; i<3; i++){
				for(int j=i; j<3; j++)
					swap(arr[i][j], arr[j][i]);
				
			}
			
			std::cout  << std::endl << std::endl;
			for(int i=0; i<3; i++){
				for(int j=0; j<3; j++)
					cout<<arr[i][j]<<"\t";
				std::cout << std::endl;
			}
			return 0;
		}

	// To print the 2D matrix with advance for loop (need to use & sign else error will occur)
		#include <iostream>
		using namespace std;
		int main() {
			
			int arr[][5] = {
							{1,2,3,4,5},
							{6,7,8,9,10},
							{11,12,13,14,15},
							{16,17,18,19,20},
							{21,22,23,24,25},
						};
						
			for(auto& i: arr){					//here & operator is must, this indicate the beginning of array
				for(auto j: i)
					std::cout << j <<"\t";
			
				std::cout << std::endl;    
			}
			return 0;
		}

	// Reversin the columns of array:
		#include <iostream>
		using namespace std;
		int main() {
			// reversing the cols of matrix
			int arr[][5] = {
							{1,2,3,4,5},
							{6,7,8,9,10},
							{11,12,13,14,15},
							{16,17,18,19,20},
							{21,22,23,24,25},
						};
						
			for(auto& i: arr){
				for(auto j: i)
					std::cout << j <<"\t";
			
				std::cout << std::endl;    
			}
			
			int n=5;
			for(int i=0; i<(n/2); i++)
				for(int j=0; j<n; j++)
					swap(arr[i][j], arr[n-i-1][j]);
					
				
			std::cout  << std::endl;
			for(auto &partiallArr: arr){
				for(auto value: partiallArr)
					std::cout << value << "\t";
				std::cout << std::endl;
			}
			return 0;
		}

	// vector assign method (replacing all element of array with new ones):
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			vector<int> a ={1,2,3,4,5};
			vector<int> b ={1,100};
			
			for(int i: a)
				std::cout << i << "\t";             //1       2       3       4       5
			std::cout << std::endl;
			
			a.assign(b.begin(),b.end());
			for(int i: a)
				std::cout << i << "\t";             // 1    100
			return 0;
		}

	// vector insert method (appending the all element to end of vector):
		#include <iostream>
		#include <vector>
		using namespace std;

		int main() {
			vector<int> a = {1, 2, 3, 4, 5};
			vector<int> b = {1,100};
			for (int i : a)
				cout << i << "\t";				// 1       2       3       4       5
			cout << endl;

			a.insert(a.end(), b.begin(), b.end());
			for (int i : a)
				cout << i << "\t";				// 1       2       3       4       5       1       100
			return 0;
		}

	// Accessin the inner vectors of 2D vector:
		#include <iostream>
		#include <vector>
		#include <algorithm>

		using namespace std;

		int main() {
			// Define a 2D vector of strings
			vector<vector<string>> vec2D = {{"banana", "apple", "orange"},
										{"grape", "kiwi", "pear"},
										{"strawberry", "blueberry", "raspberry"}};

			// Sort each inner vector
			for (auto& innerVec : vec2D) {
				sort(innerVec.begin(), innerVec.end());
			}

			// Output the sorted 2D vector
			for (const auto& innerVec : vec2D) {
				for (const auto& str : innerVec) {
					cout << str << " ";
				}
				cout << endl;
			}

			return 0;
		}

	// sorting of 2d Vector:
		#include <iostream>
		#include <vector>
		#include <algorithm>

		using namespace std;

		int main() {
			// Define a 2D vector of integers
			vector<vector<int>> vec2D = {{1, 2, 3},
									{1, 5, 9},
									{1, 6, 5}};

			// Sort the 2D vector
			sort(vec2D.begin(), vec2D.end());

			// Output the sorted 2D vector
			for (const auto& innerVec : vec2D) {
				for (const auto& num : innerVec) {
					cout << num << " ";
				}
				cout << endl;
			}

			return 0;
		}
		//output:
			1 2 3 
			1 5 9 
			1 6 5 

		//or (run this code on compiler to check output)
			#include <iostream>
			#include <vector>
			#include <algorithm>
			using namespace std;

			int main() {
				// Define a 2D vector of integers
				vector<vector<int>> vec2D = {{1, 4, 0},
										{1, 4, 9},
										{1, 2, 5}};
										
				// Output the sorted 2D vector
				for (const auto& innerVec : vec2D) {
					for (const auto& num : innerVec) {
						cout << num << " ";
					}
					cout << endl;
				}

				// Sort the 2D vector using the custom comparison function
				sort(vec2D.begin(), vec2D.end());
				
				std::cout << std::endl;
				std::cout << "Sorted in Increasing order every vector also: " << std::endl;
				// Output the sorted 2D vector
				for (const auto& innerVec : vec2D) {
					for (const auto& num : innerVec) {
						cout << num << " ";
					}
					cout << endl;
				}
				
				
				std::cout << endl<< "sorted 2D vector in drecreasing order: " << std::endl;
				sort(vec2D.begin(), vec2D.end(), greater<vector<int>>());
					for (const auto& innerVec : vec2D) {
						for (const auto& num : innerVec) {
							cout << num << " ";
						}
					cout << endl;
				}
				
				// re-ordering every inner vector in drecreasing order
				// don't forget to use the & sign here else this change will not 
				// if you do like this then change will not be visible coz its just create the copy of vector
				// for(auto innerVec : vec2D)
				for(auto& innerVec : vec2D)
					sort(innerVec.begin(), innerVec.end(), greater<int>());
					
				std::cout << "re-ordering every inner vector in drecreasing order :" << std::endl;
				sort(vec2D.begin(), vec2D.end(), greater<vector<int>>());
					for (const auto& innerVec : vec2D) {
						for (const auto& num : innerVec) {
							cout << num << " ";
						}
					cout << endl;
				}
				return 0;
			}

	// vector string, printing the first char of every string
		#include <iostream>
		#include<vector>
		using  namespace std;
		int main() {
			
			// printing the first letter of all strings
			vector<string> s = {"+1A","+3E","-1A","+4F","+1A","-3E"};
			
			// using advance for loop
			for(string str: s)
				std::cout << str[0] << "\t";
			std::cout << std::endl;
			
			// using tradition for loop
			for(int i=0; i<s.size(); i++)
				std::cout << s[i][0] << "\t";
			std::cout << std::endl;
			return 0;
		}

	// sort function passing extra parameter:
		// this is the syntax for passing extra parameter to DESCbyValues function
		// usually in sort function the last argument which is function, takes only 2 parameter for comparison.

		[&] this represents that we are passing extra parameter (here nums) by pass by reference method, use [&]
			sort(holder.begin(), holder.end(), [&](pair<int, int> a, pair<int, int> b){
				return DESCbyValues(a, b, nums);
			});
		
		// [=] this represents that we are passing extra parameter (here nums) by pass by value method
		//to pass more than 2 arguments by pass by value method, use [=]
			sort(holder.begin(), holder.end(), [=](pair<int, int> a, pair<int, int> b){
				return DESCbyValues(a, b, nums);
			});


		// if we use just [] (empty brackets) its represents that we are not passing any extra parameter
		//just to pass 2 argument
			sort(holder.begin(), holder.end(), [](pair<int, int> a, pair<int, int> b){
				return DESCbyValues(a, b);
			});

		eg.
			sort(holder.begin(), holder.end(), [=](pair<int, int> a, pair<int, int> b){
				return DESCbyValues(a, b, nums);
			});

	// To count the no.of digits in N use log10() function
		#include <iostream>
		#include <cmath>
		int main() {
			int n = 909;
			std::cout << int(log10(n)+1) << std::endl;
			std::cout << (int)log10(n)+1 << std::endl;			// you can (int) or int() both works to typecast.
			return 0;
		}

	// we can use this find method for searching string in word or char in word
		#include <iostream>
		using namespace std;
		int main() {
			
			string s = "Hello World";
			std::cout << s << std::endl;
			std::cout << "Index of char H: ( first occurrence) " << s.find('H') << std::endl;
			std::cout << "Index of char 0: ( first occurrence) "<< s.find('0') << std::endl;                // if char not found then it will print the value of string::npos ie. 18446744073709551615 
			std::cout << string::npos << std::endl;                 //18446744073709551615
			std::cout << "Index of string 'orl' :" << s.find("orl") << std::endl;                // 7
			return 0;
		}

	// vector front() & back() function:
		#include <iostream>
		#include <vector>
		using namespace std;
		int main() {
			vector<int> v {1,2,3,4};
			vector<vector<int>> V2 {{1,2,3}, {4, 5, 6}, {7,8,9}};
			
			std::cout << "The first element of v : " << v.front() << std::endl;
			std::cout << "The last element of v : " << v.back() << std::endl;
			
			std::cout << "first vector of V2 : " << std::endl;
			for(int i: V2.front())
				std::cout << i << "\t";
			
			std::cout << std::endl;
			std::cout << "last vector of V2 : " << std::endl;
			for(int i: V2.back())
				std::cout << i << "\t";
				
			std::cout << std::endl;
			std::cout << "The first element of first vector in V2" << std::endl;
			std::cout << V2.front().front() << std::endl;
			
			std::cout << "The last element of first vector in V2" << std::endl;
			std::cout << V2.front().back() << std::endl;
			
			std::cout << std::endl;
			std::cout << "The first element of last vector in V2" << std::endl;
			std::cout << V2.back().front() << std::endl;
			
			std::cout << "The last element of last vector in V2" << std::endl;
			std::cout << V2.back().back() << std::endl;
			
			// modifying the last elements
			std::cout << "The first element of last vector in V2" << std::endl;
			V2.back().front() = 909;
			std::cout << V2.back().front() << std::endl;
			
			std::cout << "The last element of last vector in V2" << std::endl;
			V2.back().back() = 404;
			std::cout << V2.back().back() << std::endl;
			
			// any middle element of first or last vector
			std::cout << "middle element of first vector in V2: " << V2.front()[1] << std::endl;
			std::cout << "middle element of last vector in V2: " << V2.back()[1] << std::endl;
			
			// modifying the middle elements
			V2.front()[1] = 1755;
			std::cout << "Updated middle element of first vector in V2: " <<  V2.front()[1] << std::endl;
			V2.back()[1] = 1945;
			std::cout << "Updated middle element of last vector in V2: " << V2.back()[1] << std::endl;

			
			for(auto at: V2){
				for(int i: at)
					cout<<i<<"\t";
				cout<<endl;
			}
			return 0;
		}

	// find_if method to confirm the given value is present or not.
	// if present returns iterator at that point else it will equals to end() of container
		#include <iostream>
		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			vector<pair<int, int>> v { {1,11}, {2,22}, {3,33},
									{4,44}, {5,55}, {6,66},
									{7,77}, {8,88}, {9,99}, {10,100100}
								};
			
			for(auto i: v)
				std::cout << i.first << "\t" << i.second << std::endl;
			
			int n= 10;
			auto it = find_if(v.begin(), v.end(), [n](pair<int, int> p){                // here [n] is a element to find
				return p.first ==  n;
			});
			
			std::cout << "is vector have key 10? : " << ((it != v.end()) ? "Yes" : "No" ) << std::endl;
			
			int value = 100100;
			auto it2 = find_if(v.begin(), v.end(), [value](pair<int, int> p){
				return p.second == value;
			});
			std::cout << "is vector have value 100100? " << ((it2 != v.end()) ? "Yes" : "No") << std::endl;
			
			
			value = 100;
			auto it3 = find_if(v.begin(), v.end(), [value](pair<int, int> p){
				return p.second == value;
			});
			std::cout << "is vector have value 100? " << ((it3 != v.end()) ? "Yes" : "No") << std::endl;
			return 0;
		}

	// typedef, using & #define
		- smaller syntax for larger things
		using MinHeap = priority_queue<int, vector<int>, greater<int>>;			// Or
		#define MinHeap priority_queue<int, vector<int>, greater<int>>			// or
		typedef priority_queue<int, vector<int>, greater<int>> MinHeap;

		MinHeap pq;  // Simpler syntax for min-heap
---------------------------------------------------------------------------------------------------------
POTD:-[Problem of the Day]
	1) Minimum Difference in an Array
		#include <bits/stdc++.h> 
		int minDiff(int n, vector < int > arr) {
			sort(arr.begin(), arr.end());
			// int minDiffHold = abs(arr[0] - arr[1]);      //or you can assign INT_MAX here also

			int minDiffHold =INT_MAX; 
			for (int i = 0; i < n - 1; i++) {
				if (arr[i] == arr[i + 1])
				return 0;

				int value = abs(arr[i] - arr[i + 1]);

				// assigning minimum value to mindiffhold variable.
				minDiffHold = min(value, minDiffHold);
			}
			return minDiffHold;
		}

	2) Reverse Coding:
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int row = mat.size();
			int column = mat[0].size();
			
			vector<vector<int>> v;

			for (int i = 0; i < row; i++) {

				vector<int> second;
				for (int j = column - 1; j >= 0; j--){
					int value = mat[i][j];
					second.push_back(value);
				}
				v.push_back(second);
			}

			return v;
		}

		//or
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int i=0,n = mat.size();

			while(i<n){
				reverse(mat[i].begin(), mat[i].end());
				i++;
			}
			return mat;
		}

	3) Planet Division:
		vector<int> planetDivision(int n) {
			vector<int> v;
			(n % 2 == 0)?(v.push_back(n/2), v.push_back(n/2)):(v.push_back((n/2)+1), v.push_back(n/2));
			return v;
		}

	4) Missing number in array:
		class Solution{
			public:
			int missingNumber(vector<int>& array, int n) {
				//(TLE)
				// for(int i=1;i<=n;i++){
				//     int j;
				//     for(j=0;j<n;j++){
				//         if(array[j] == i)
				//             break;
				//     }
				//         if(j == n)
				//             return i;
				// }
				
				/or (TLE)
				// int counter = 1, i=0;
				// while(i<n){
				//     if(array[i++] == counter){
				//         i=0;
				//         counter++;
				//     }
				// }
				// return counter; 
				
				//or (optimized)
				sort(array.begin(), array.end());
				for(int i=0;i<n;i++){
					if(array[i] != i+1)
						return i+1;
				}
			}
		};

		//more optimized:
			class Solution{
				public:
				int missingNumber(vector<int>& array, int n) {
					// sort(array.begin(), array.end());
					// for(int i=0; i<n; i++){
					//     if(array[i] != i+1)
					//         return i+1;
					// }
					long long actSum = (n*(n+1))/2;
					long long SumArr =0;
					for(int z: array){
						SumArr += z;
					}
					return actSum - SumArr;
				}
			};

	5) Count Odd Even
		void countOddEven(int arr[], int sizeof_array)
		{
			int odd=0, even=0;
			for(int i=0; i<sizeof_array;i++){
				(arr[i] % 2)? odd++ : even++;
			}
			cout<<odd<<" "<<even<<"\n";
		}

	6) Pattern 11
		void printTriangle(int n) {
			int bit = 0;
			for(int i=0;i<n; i++){
				int tempBit = bit;
				for(int j=0; j<=i; j++){
					(tempBit)?(tempBit =0):(tempBit = 1);
					cout<<tempBit<<" ";
				}
				if(bit == 0)
					bit =1;
				else
					bit = 0;
				printf("\n");
			}
		}
		//output
			Input: 5
			Output:
				1 
				0 1 
				1 0 1
				0 1 0 1 
				1 0 1 0 1

	7) Boring Factorial:
		Problem statement
			You are given an integer ‘N’ and a prime number ‘P’. 
			Your task is to find the N! modulo P.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^9
				1 <= P <= 10^9
				|N - P| <= 1000
				Time Limit: 1 sec

			Sample Input 1 :
				2
				5 3
				4 5
				Sample Output 1 :
				0
				4
				Explanation For Sample Input 1 :
				Test Case 1:
				5! = 5*4*3*2*1 = 120 and and it will give remainder as 0 when divided by 3.

				Test Case 2:
				4! = 4*3*2*1 = 24 and it will give the remainder 4 when divided by 5.
				Sample Input 2 :
				2
				5 11
				10 7
				Sample Output 2 :
				10
				0

		// just for integer, else gets overflow.
			#include <bits/stdc++.h> 
			int boringFactorials(int n, int p) {
				for(int i=n-1; i>0; i--){
					n *= i;
				}
				return n % p;
			}
		
		// for any value, won't get overflowed. coz we are taking mod repetitively
			#include <bits/stdc++.h> 
			int boringFactorials(int n, int p) {
				for(int i=n-1; i>0; i--){
					n = (n * i) % p;
				}
				return n % p;
			}

		Input:
			3
			2 5			(2!) % 5 =2
			5 11			(5!) % 11 =10
			21 71		(21!) % 71 =6

		Output:
			2
			10
			6
		#include <iostream>
		using namespace std;

		int main(){
			int fact=1;
			int n=23,p=29;
			if(n >= p)
				return 0;

			for(int i=1;i<=n; i++){
				fact = (fact * i) % p; 
				cout<< fact<<"\t";
			}
			return 0;
		}

		Problem statement
			You are given an integer ‘N’ and a prime number ‘P’. Your task is to find the N! modulo P.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^9
				1 <= P <= 10^9
				|N - P| <= 1000
				Time Limit: 1 sec
			Sample Input 1 :
				2
				5 3
				4 5
				Sample Output 1 :
				0
				4
				Explanation For Sample Input 1 :
				Test Case 1:
				5! = 5*4*3*2*1 = 120 and and it will give remainder as 0 when divided by 3.

				Test Case 2:
				4! = 4*3*2*1 = 24 and it will give the remainder 4 when divided by 5.
				Sample Input 2 :
				2
				5 11
				10 7
				Sample Output 2 :
				10
				0

		#include <bits/stdc++.h> 
		int boringFactorials(int n, int p) {
			int a = n--;
			while(n){
				a = (a * n) % p;
				n--;
			}
			return a % p;
		}

	8) Class Test:
		Sample Input 1 :
			2
			3
			1
			3 4 4
			4
			3
			1 1 2 2 
		Sample Output 1 :
		4
		1
		Explanation Of Sample Input 1 :
		For test case 1 we have, 

		To get a Rank 1, Ninja must have scored maximum marks in the class.
		Hence, Ninja scored 4 marks.
		For test case 2 we have,
		Students with marks = 2 will achieve ranks 1 and 2 respectively.
		Students with marks = 1 will achieve ranks 3 and 4 respectively.
		So, Ninja scored 1 mark.
		Sample Input 2 :
			test cases : 3
			i.	2
				1
				20 9 

			ii.	2
				1
				9 17 

			iii.	7
				2
				9 6 0 2 20 10 5 
		Sample Output 2 :
			20
			17
			10

		#include <bits/stdc++.h> 
		int classTest(int n, vector<int> &a, int k) {
			sort(a.begin(), a.end());
			reverse(a.begin(), a.end());

			int mark=a[0], temp =1;
			for(int i=0;i<n;i++){
				if(temp == k){
						mark = a[i];
					}
				temp++;
			}
			return mark;
		}

	9) Find the lone set bit & return its index.
		#include <iostream>
		#include <bitset>
		using namespace std;

		int main(){
			int N = 136;
			cout<<"binary form 136 "<<bitset<32>(N);
			std::cout << std::endl;
			if(N == 0){
				cout<<-1;
				return 0;
			}

			int count=0;
			if(N&1){
				cout<<-1;
				return 0;
			}else{
				int setBit =0;
				while(N>0){
					if(setBit == 1 && N >0){
						cout<<-1;
						return 0;
					}
					
					if(N & 1)
						setBit++;       //111010
					
					count++;
					N>>=1;
				}
			}
			cout<<count;
			return 0;
		}
	
	10) String Count:
		Sample Input 1:-
			2
			4 
			##**    
			3
			***
			Sample Output 1:-
			1
			0
			Explanation Of Sample Input 1:-
			First test case:- 
			We have three substrings of size 2 for the string 'S', which are "##", "#*" and "**".
			Only one of them is good(#* or *#) . So, the total number of good substrings of 'S' is 1.

			Second test case:-
			There is no good substring in 'S', so the answer is 0.
			Sample Input 2:-
			2
			4
			#*#*
			2
			*#
			Sample Output 2:-
				3
				1

			int stringCount(int n, string &s) {
				int ttl=0;
				int len = s.length();
				
				for(int i=0; i<len; i++){
					
					char first = s[i];
					char sec = s[i+1];
					string str = "";
					str += first;
					str += sec;
					
					if(str == "#*" || str == "*#")
						ttl++;
				}

				return ttl;
			}

			//or
			int stringCount(int n, string &s) {
				int cnt=0;
				for(int i=1; i<n; i++){
					string str = s.substr(i-1, 2);
					if(str == "#*" || str == "*#")
						cnt++;
				}
				return cnt;
			}

	11) Sequence Query:
		Sample Input 1:
			start value, diff, target
			1 2 7
		Sample Output 1 :
			1
		Explanation For Sample Input 1:
		The sequence here is 1, 3, 5, 7, .... As 7 is present in the sequence, the output is 1.

		Sample Input 2:
		5 0 3
		Sample Output 2 :
		0
		Explanation For Sample Input 2:
		The sequence here is 5, 5, 5, .... As 3 is not present in the sequence, the output is 0.

		int checkSequence(int a, int d, int x) {
			// Write your code here.
			if(a == x || (d==1 && a<x))
				return 1;
			
			if((a > x && d>0) || (a < x && d<0))
				return 0;

			int counter=0;

			for(int start=a; ;start+=d)
			{

				a += d;
				if(a == x)
					return 1;

				counter++;
				if(counter>30)
					return 0;
			}
		}

		//or
			int checkSequence(int a, int d, int x) {
				if(a == x || (d==1 && a<x))
					return 1;
				
				if((a > x && d>0) || (a < x && d<0))
					return 0;

				if(d==0){
					if(a==x)
						return 1;
					else
						return 0;
				}


				while(a <= x){
					if(a == x)
						return 1;
					else if(a < x){
						if(a+d < a)
							break;
						a += d;
					}
					else
						break;        
				}

				while(a >= x){
					if(a == x)
						return 1;
					else if (a > x){
						if(a+d > a)
							break;
						a += d;
					}else{
						break;
					}
				}
				return 0;
			}

	12) min & max:
		without using conditional operator, ternary operator
		eg.
			pair<int,int> ans= {a,b};
			for(int i=b;i<a;i++) {
				ans = {b,a};
				break;
			}
			return ans;		//returning minimum, maximum.

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				pair<int,int>pr;

				int max = (a>=b)*a+(b>a)*b;
				int min = (a<=b)*a+(b<a)*b;

				pr.first = min;
				pr.second = max;

				return pr;
			}

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				int mini = min(a,b);
				int maxi = max(a,b);
				
				pair<int,int> pr;
				// pr.first = mini;
				// pr.second = maxi;
				//or

				pr = {mini, maxi};
				return pr;
			}

		eg.
			#include <bits/stdc++.h>
			pair < int , int > findMinMax(int a , int b){
				return {min(a,b),max(a,b)};
			}
	
	13) Fibonacci series nums addition within given range:❌
		#include <bits/stdc++.h> 
		int fiboSum(int n , int m){
			int sum = 0;
			if(n<2) sum = 1;

			int a = 0, b = 1, mod = 1e9+7;

			for(int i=2;i<=m;i++){
				int c = (a+b)%mod;
				a = b;
				b = c;
				if(i>=n && i<=m)sum = (sum+c)%mod;
			}

			return sum;
		}

		#include <bits/stdc++.h> 
		long long int fiboSum(int n , int m){
			long long int prev =0, cur =1, fib=0;
			long long int sum=0;
			
			for(int i=0; i<=m; i++){
				
				// if(i>=n)
				// 	sum += prev;


				sum += prev;

				if(i<n)
					sum -= prev;
					
				fib = cur + prev;		 
				prev = cur;
				cur = fib;				 
			}
			return sum;	
		}

	14) Water Glass
		Sample Input 1:
		2
		2 2 2 3
		1 1 1 3
		Sample Output 1:
		normal
		cold
		##### Explanation Of Sample Input 1:

		For test case 1:
		The arrangement of glasses looks like,
		W W N N C C W W N N C C …………..
		Here the 3rd glass is N means it contains normal water.

		Hence, the answer for this case is "normal".


		For test case 2:
		The arrangement of glasses looks like,
		W N C W N C …………..
		Here the 3rd glass is C means it contains cold water.

		Hence, the answer for this case is "cold".
		Sample Input 2:
		2
		5 6 8 15
		9 3 3 12
		Sample Output 2:
		cold
		normal

		string waterGlass(long long x, long long y, long long z, long long n){
			// Write your code here.
			long long i,wrm, nrm, cld;
			vector<int> v;

			back:
			for(wrm=0; wrm<x; wrm++)
				v.push_back(1);

			for(nrm=0;nrm<y;nrm++)
				v.push_back(2);
			
			for(cld=0; cld<z;cld++)
				v.push_back(3);
			
			if(v.size() < n)
				goto back;


			// for(i=0;i<n;i++){
			// 	if(v[i] == )
			// }
			if(v[n-1] == 1){
				return "warm";
			}else if (v[n-1] == 2){
				return "normal";
			}else{
				return "cold";
			}
		}

	15) Toggle K bits:
		Sample Input 1:
			2
			21 3
			40 4
			Sample Output 1:
			18
			39
			Explanation For Sample Input 1:
			In example 1, the binary representation of 21 is '10101'. After toggling rightmost 3 bits, it becomes ‘10010’ which is equal to 18.
			In example 2, the binary representation of 40 is ‘101000’. After toggling rightmost 4 bits, it becomes ‘100111’ which is equal to 39.
			Sample Input 2:
			2 
			20 2
			85 5
			Sample Output 2:
			23
			74
			Explanation For Sample Input 2:
			In example 1, the binary representation of 20 is '10100'. After toggling rightmost 2 bits, it becomes ‘10111’ which is equal to 23.
			In example 2, the binary representation of 85 is ‘1010101’. After toggling rightmost 5 bits, it becomes ‘1001010’ which is equal to 74.

		#include <bits/stdc++.h> 
		using namespace std;
		int toggleKBits(int n, int k) {

			vector<int> v;
			for(int i=0;i<k;i++){
				int bit = n&1;
				n >>= 1;
				v.push_back(bit);
			}

			for(int i=0;i<v.size();i++)
				if(v[i] == 1){
					v[i] = 0;
				}else{
					v[i] = 1;
				}

			for(int i=0; i<k; i++){
				n <<= 1;
				n = n | v[v.size()-i-1];
			}
			return n;
		}

		//or
			#include <bits/stdc++.h>
				int toggleKBits(int n, int k) {
					return n^((1<<k)-1);
				}

	16) Unlucky Number:
		Num consist of 1 or 3 or 1 & 3 only. not other number;
			Sample Input 1
				1
				Sample Output 1
				1
				Sample Input 2
				2
				Sample Output 2
				3
				Sample Input 3
				5
				Sample Output 3
				31
			eg.
				1, 3, 11, 13, 31, 33, 111, 113, 131, 133, 311, 313, 331, 333.
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
			//Write your code here
			int n;
			cin>>n;

			vector<int> v;
			int IStore=0, checker;

				for(int j=1;j<2000000;j++){
					IStore = j;
					checker = j;
					while(checker>0){
						int temp = checker % 10;

						if(temp == 1 || temp ==3){
							checker /= 10;
							continue;
						}else{
							break;
						}
					}

					if(checker == 0)
						v.push_back(IStore);
				}
				cout<<v[n-1];
				return 0;
			} 

	17) Digit Count In Range:
		Sample Input 1:
			2
			3
			1 15
			2
			2 12
			Sample Output 1:
			2
			2
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [1, 13] = 2 (3, 13). Return 2


			In the second test case, 
			Number of occurrences of 2 in range [2, 12] = 2 (2, 12). Return 2
			Sample Input 2:
			2
			1 
			1 15
			3
			3 33
		
		Sample Output 2:
			8
			8
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 1 in range [1, 15] = 8 (1, 10, 11, 12, 13, 14, 15). Return 8

			In the second test case, 
			Number of occurrences of 3 in range [3, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int digitCount(int K, long long int A, long long int B){
			long long int counter = 0,i,JStorer;
			while(A<=B){
				JStorer = A;
				while(JStorer>0){
					int temp = JStorer % 10;
					if(temp == K)
						counter++;
					JStorer/=10;
				}
				A++;
			}
			return counter;	
		}

	18) Minimum Difference Of Subarrays:
		int minimumDifference(int n, vector<int> arr){
			//Declaring totalSum to store the sum of all elements of arr.
			int totalSum = 0;
			for (int idx = 0; idx < n; idx++)
				totalSum += arr[idx];

			// currentSum stores the sum of first subarray.
			int currentSum = 0, minDiff = INT_MAX;

			for (int idx = 0; idx < n - 1; idx++){

				// updating the sum of the current subarray.
				currentSum += arr[idx];

				// Updating the mininmum difference.
				minDiff = min(minDiff, abs(currentSum - (totalSum - currentSum)));
			}
			return minDiff;
		}

	19) Ninja And The Triangle:
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
			int Istorer, sum=0, i;
			for(i=1; i<n; i++)
				if((sum+i) <= n){
					sum += i;
					Istorer = i;
				}
				else
					break;
			
			return Istorer;
		}
		//or
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
		    int k = (int)(sqrt(2*n));
			while(k*(k+1)/2 > n)
				k--;
			return k;
		}

		//or
			#include <bits/stdc++.h> 
			int ninjaAndTriangle(int n) {
				int d = 1 + 8 * n;
				int x = (1 + sqrt(d))/2;
				return x-1;
			}

	20) Amazing Strings
		Sample Input 1:
			2
			HI HEY EIHYH
			ALL GOOD ADOLLG
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined has 1 A, 2 L, 1 G, 2 O and 1 D. While the string ‘THIRD’ has 1 A, 2 L, 1 G, 1 O and 1 D and So, it has one character less than the combined ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.
			Sample Input 1:
			2
			CODING NINJA NINCODINGJA
			YES NO NEEOOYS
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined have 1 N, 1 Y, 1 E, 1 S and 1 O. While the string ‘THIRD’ has 1 N, 1 Y, 2 E, 1 S and 2 O and So, it has one character more than ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.

		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size(),i=0;

			if((firLen + secLen) != len)
				return "NO";

			while(i<firLen){
				char tempCh = first[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}
			i=0;
			while(i<secLen){
				char tempCh = second[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}

			return "YES";
		}

		//or
		#include <algorithm>
		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size();
			int i=0;

			if((firLen + secLen) != len)
				return "NO";
			
			string full = first + second;
			sort(full.begin(), full.end());

			sort(third.begin(), third.end());
			
			if(full == third)
				return "YES";
			else
				return "NO";
		}

		//optimized:
			string amazingStrings(string first, string second,string third) {
				// Write your code here.
				if((first.length() + second.length()) == third.length())
					return "YES";
				else
					return "NO";
			}

	#Weekend Problem:
		21) Chocolate Removal Challenge:
			Explanation:
				You are given an array 'A' of size 'N'. Each element 'A[i]' represents the number of chocolates in the 'i-th' pile. 
				In a single move, you are allowed to perform the following operation: 
				If a pile contains more than 23 chocolates, you can take out all the chocolates leaving only 23 in the pile.

				Input: A = [25, 24, 29, 15]
				Output: 9

				First pile: Contains 25 chocolates, remove 2 to leave 23. Chocolates removed = 2.
				Second pile: Contains 24 chocolates, remove 1 to leave 23. Chocolates removed = 1.
				Third pile: Contains 29 chocolates, remove 6 to leave 23. Choclates removed = 6
				Fourth pile: Contains 15 chocolates, no chocolates removed as the pile already has less than or equal to 23 chocolates.
				Total chocolates removed = 2 + 1 + 6 = 9.

			Sample Input 1:
				2
				4
				25 24 10 15
				3
				30 20 40
				Sample Output 1 :
				3
				24
				Explanation For Sample Input 1:
				For test case 1:
				We remove 2 chocolates from the first pile and 1 from the second pile. Hence the total chocolates removed = 2 + 1 = 3.

				For test case 2:
				We remove 7 chocolates from the first pile, none from the second pile and 17 from the third pile. Hence the total chocolates removed = 7 + 17 = 24.
				Sample Input 2:
				2
				5
				100 200 300 400 500
				1
				23
				Sample Output 2 :
				1385
				0

			long long totalChocolates(int n, vector<int> a) {
				long long sum =0;
				for(int i=0;i<n;i++){
					if(a[i]> 23)
						sum += (a[i]-23);
				}
				return sum;
			}

		22) Odd Product:
			Ninja loves the odd numbers. He gives you an array 'A' of size 'N'. Help Ninja to find numbers of pairs '(L, R)' 
			such that products of array elements in the range 'L' to 'R' have an odd number of divisors.
			eg.
				'N' = 2
				'A' = [1, 4]

				There are total three possible pairs of '(L, R)':
				L = 1, R = 1, 'product = 1', divisors = [1]
				L = 1, R = 2, 'product = 1*4 = 4', divisors = [1, 2, 4]
				L = 2, R = 2 , 'product = 4', divisors = [1, 2 , 4]

				All three pairs have an odd number of divisors, so the answer is '3'.

			eg.
				Sample Input 1:
					2
					4
					1 2 4 2
					2
					1 2
					Sample Output 1:
					4
					1
					Explanation Of Sample Input 1:
					For test case 1:
					There are total '10' possible pairs of '(L, R)':

					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2', divisors = [1, 2]
					L = 1, R = 3, 'product = 1*2*4 = 8', divisors = [1, 2, 4, 8]
					L = 1, R = 4, 'product = 1*2*4*2 = 16', divisors = [1, 2, 4, 8, 16]
					L = 2, R = 2, 'product = 2', divisors = [1, 2]
					L = 2, R = 3, 'product = 2*4 = 8', divisors = [1, 2, 4, 8]
					L = 2, R = 4, 'product = 2*4*2 = 16', divisors = [1, 2, 4, 8]
					L = 3, R = 3, 'product = 4', divisors = [1, 2, 4]
					L = 3, R = 4, 'product = 4*2 = 8', divisors = [1, 2, 4, 8]
					L = 4, R = 4, 'product = 2', divisors = [1, 2]

					We can see that only '4' pairs have an odd number of divisors, so the answer is '4'.

					For test case 2:
					There are total three possible pairs of '(L, R)':
					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2 = 2', divisors = [1, 2]
					L = 2, R = 2 , 'product = 2', divisors = [1, 2]

					Only one pair has an odd number of divisors, so the answer is '1'.
					Sample Input 2:
					2
					4
					4 4 4 4
					5
					4 2 8 10 16
					Sample Output 2:
					10
					4
			
			long long oddProducts(int n, vector<int> &a){
				int counter=0;
				long long MainCounter=0;
				for(int b=0; b<n; b++){

					int prod=1,j;
					for(int c=b; c<n; c++){
						prod *= a[c];

						j=1;
						while(j<=prod){
							if(prod % j == 0)
								counter++;
							j++;
						}

						if(counter&1)
							MainCounter++;
						
						counter=0;
					}
				}
				return  MainCounter;
			}

	23) Strobogrammatic Number ll:
		Problem statement:
			Given a length ‘N’, you need to find all the strobogrammatic numbers of length ‘N’.
			A strobogrammatic number is a number that looks the same when rotated by 180.
			In other words, a number that on rotating right side up and upside down appears the same is a strobogrammatic number.
			‘986’ is a strobogrammatic number because on rotating ‘986’ by 180 degrees, ‘986’ will be obtained.
			If N = 2, all the strobogrammatic numbers of length = 2 are “11”, “88”, “69”, “96”.
			Sample Input 1:
				2
				3
				1
				Sample Output 1:
				101 111 181 609 619 689 808 818 888 906 916 986 
				0 1 8 
				Explanation For Sample Input 1:
				Test Case 1: All the possible Strobogrammatic numbers of length = 3 are “101”, “111”, “181”, “609”, “619”, “689”, “808”, “818”, “906”, “916”, “986”.

				Test Case 2: Strobogrammatic numbers of length = 1 are “0”, “1”, and “8”.
				Sample Input 2:
				2
				4
				2
				Sample Output 2:
				1001 1111 1691 1881 1961 6009 6119 6699 6889 6969 8008 8118 8698 8888 8968 9006 9116 9696 9886 9966 
				11 69 88 96 
				Explanation For Sample Input 2:
				Test Case 1: All the possible Strobogrammatic numbers of length = 4 are printed.

				Test Case 2: All the possible Strobogrammatic numbers of length = 2 are printed.

		//Not optimized:
			#include <bits/stdc++.h> 
			bool checker(string st){

				int temp = stoi(st);
				int rev = 0;
				while(temp>0){
					rev = (temp % 10) + rev * 10; 
					temp /=10;
				}

				string tempStr = to_string(rev);
				int index=0;
				while(tempStr[index] != '\0'){
					if(tempStr[index] == '6')
						tempStr[index] = '9';
					else if(tempStr[index] == '9')
						tempStr[index] = '6';
					index++;
				}

				if(st == tempStr)
					return true;
				return false;
			}

			vector<string> findStrobogrammatic(int n){
				vector<string> s;
				if(n == 1)
					return {"0","1","8"};
				
				if(n == 2)
					return {"11","69","88","96"};

				int Digit = 1;
				Digit = pow(10,n-1);

				for(int i = Digit; i<(Digit*10); i++){
					int temp = i;
					while(temp > 0){
						int singleBit = temp % 10;
						if(singleBit == 0 || singleBit == 1 || singleBit == 6 || singleBit == 8 || singleBit == 9)
							temp /=10;
						else
							break;
					}
					if(temp == 0)
						s.push_back(to_string(i));
				}

				vector<string> Upgraded;

				for(int i=0; i<s.size(); i++){
					string tempStr = s[i];
					
					if(checker(tempStr))
						Upgraded.push_back(tempStr);
				}
				return Upgraded;
			}

		//or
			#include <bits/stdc++.h> 
			vector<string> findStrobogrammatic(int n) {
				vector<string> ans;
				int start = pow(10,n-1);
				if(n == 1)
					start =0;
				int end = pow(10,n);
				for(int i=start; i<end; i++){
					string s = to_string(i);
					string temp = to_string(i);

					int f=0;
					for(int g=0; g<s.length(); g++)
						if(s[g] == '2' || s[g] == '3' || s[g] == '4' || s[g] == '5' || s[g] == '7'){
							f=1;
							break;
						}
					if(f)
						continue;
					
					reverse(s.begin(), s.end());
					for(int a=0; a<s.length(); a++)
						if(s[a] == '9')
							s[a] = '6';
						else if(s[a] == '6')
							s[a] = '9';
					
					if(temp == s)
						ans.push_back(s);
				}
				return ans;
			}

		//or
			#include <bits/stdc++.h> 
			bool checkStrobogrammatic(string z){
				if( z.find('2') != string::npos ||
					z.find('3') != string::npos ||
					z.find('4') != string::npos ||
					z.find('5') != string::npos ||
					z.find('7') != string::npos)
						return 0;
					
				string holder = z;
				for(int t=0; t<holder.length(); t++){
					if(holder[t] == '9')
						holder[t] = '6';
					else if(holder[t] == '6')
						holder[t] = '9';
				}

				reverse(holder.begin(), holder.end());
				if(holder != z)
					return 0;
				return true;
			}

			vector<string> findStrobogrammatic(int n) {
				int start = 1, end;
				while(--n){
					start *= 10;
				}
				end = start * 10;

				vector<string> ans;
				if(start==1)
					ans.push_back("0");

				for(int i=start; i<end; i++){
					int crntNum = i;
					string s = to_string(crntNum);
					if(checkStrobogrammatic(s))
						ans.push_back(s);
				}
				return ans;
			}

		//optimized:
			vector < string > findStrobogrammaticHelper(int n, int len) {
				// If len = 0, return empty string.
				if (len == 0) {
					return vector < string > ({ "" });
				}

				if(len == 1){
					return vector < string > ({"0", "1", "8" });
				}

				// Recursively call for len = len - 2.
				vector < string > prev = findStrobogrammaticHelper(n, len - 2);

				// Initialize vector of strings to store resulting strings.
				vector < string > res;

				// Iterate through all strings in "prev".
				for (int i = 0; i < prev.size(); i++) {

					// Add digits around string prev[i].
					if (len != n) {
						res.push_back("0" + prev[i] + "0");
					}

					res.push_back("1" + prev[i] + "1");
					res.push_back("6" + prev[i] + "9");
					res.push_back("8" + prev[i] + "8");
					res.push_back("9" + prev[i] + "6");
				}
				return res;
			}

			vector < string > findStrobogrammatic(int n) {
				// Recursive function to find all strobogrammatic numbers.
				vector < string > ans = findStrobogrammaticHelper(n, n);
				return ans;
			}

	24) Set Matrix Ones:
		Note:
			when you know the vector size like (vector<int> ans), then don't use push_back method to insert 
			element into it.
			directly use index to insert 
			like 
			at 3rd index you want to insert 4;
				ans[3] = 4;
		//basics to know:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main(){
				//2d vector with 4; 10 rows 5 columns initialized with 4 (default value).
				vector<vector<int>> ans (10, vector<int> (5,4));
				
				for(int i=0;i<10; i++){
					for(int j=0;j<5; j++)
						cout<<ans[i][j]<<"\t";
					cout<<endl;
				}
				
				std::cout << "End" << std::endl;
				return 0;
			}

		//not optimized:	
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<vector<int>> ans(n, vector<int>(m,0));
				for(int i=0;i<n; i++){
					for(int j=0;j<m;j++){
						if(MAT[i][j] == 1){
							for(int b=0;b<m;b++)
								ans[i][b] =1;                
							for(int a =0;a<n;a++)
								ans[a][j] = 1;
						}
					}
				}
				MAT = ans;
			}

		//optimized:
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<pair<int, int>> ones;
				vector<bool> rowHasOne(n, false);
				vector<bool> colHasOne(m, false);

				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (MAT[i][j] == 1) {
							rowHasOne[i] = true;
							colHasOne[j] = true;
						}
				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (rowHasOne[i] || colHasOne[j]) 
							MAT[i][j] = 1;
			}

	25) Count Distinct Element in Every K Size Window
		you are given an array ‘ARR’ of size ‘N’ and an integer ‘K’. Your task is to find the total
		number of distinct elements present in every ‘K’ sized window of the array. A ‘K’ sized
		window can also be viewed as a series of continuous ‘K’ elements present in the
		sequence.
		Note:
			1. The size of ‘ARR’ will always be greater than or equal to the ‘K’.
			2. Here window refers to a subarray of ‘ARR’. Hence ‘K’ sized window means a subarray of size ‘K’.
			3. You are not required to print the output explicitly. It has already been taken care of. Just
			 implement the function and return an array of the count of all distinct elements in the ‘K’ size window.
		eg.
			consider ARR = [ 1, 2, 1, 3, 4, 2,3 ] and K = 3.

			As per the given input, we have a sequence of numbers of length 7, and we need to find the number of
			distinct elements present in all the windows of size 3.
			Window-1 has three elements { 1,2, 1 } and only two elements { 1,2 } are distinct because 1 is repeating two times.
			Window-2 has three elements { 2,1, 3 } and all three elements are distinct { 2, 1, 3 }.
			Window-3 has three elements { 1,3, 4 } and all three elements are distinct { 1, 3, 4 }.
			Window-4 has three elements { 3,4, 2 } and all three elements are distinct { 3, 4, 2 }.
			Window-5 has three elements { 4,2, 3 } and all three elements are

			Hence, the count of distinct elements in all K sized windows is { 2, 3, 3, 3, 3 }.
		eg.
			Sample Input 1:
				2
				7 4
				1 2 1 3 4 2 3
				5 3
				1 1 2 1 3
				Sample Output 1:
				3 4 4 3
				2 2 3
				Explanation Of Sample Input 1:
				Test Case 1:

				Window-1 has four elements { 1, 2, 1, 3 } and only three elements { 1, 2, 3 } are distinct because 1 is repeating two times.
				Window-2 has four elements { 2, 1, 3, 4 } and all four elements { 2, 1, 3, 4 } are distinct.
				Window-3 has four element { 1, 3, 4, 2 } and all four elements { 1, 3, 4, 2 } are distinct. 
				Window-4 has four element { 3, 4, 2, 3 } and only three elements { 3, 4, 2 } are distinct because 3 is repeating two times.

				Hence, the count of distinct elements in all windows is { 3, 4, 4, 3}.

				Test case 2: 

				Window-1 has three elements { 1, 1, 2 } and only two elements { 1, 2 } are distinct because 1 is repeating two times.
				Window-2 has three elements { 1, 2, 1 } and only two elements { 2, 1 } are distinct.
				Window-3 has three elements { 2, 1, 3 } and all three elements { 2, 1, 3 } are distinct.

				Hence, the count of distinct elements in all windows is { 2, 2, 3 }.
				Sample Input 2:
				2
				4 1
				2 3 1 2
				5 2
				2 2 3 2 1
				Sample Output 2:
				1 1 1 1
				1 2 2 2

		#include <bits/stdc++.h> 
		vector<int> countDistinctElements(vector<int> &arr, int k) {
			vector<int> DistinctCount;
			int len = arr.size();
			int Lind =k-1;
			int i=0,j;
			int windowHolder = k;
			while(Lind < len){
				set<int> temp;
				j = i;
				while(windowHolder){
					temp.insert(arr[j++]);
					windowHolder--;
				}
				i++;
				windowHolder = k;
				DistinctCount.push_back(temp.size());
				temp.clear();
				Lind += 1;
			}
			return DistinctCount;
		}

		//optimized:
			#include <bits/stdc++.h> 
			vector<int> countDistinctElements(vector<int> &arr, int k) {
				std::vector<int> distinctCount;
				int len = arr.size();
				
				if (k <= 0 || k > len) {
					return distinctCount;  // Handle invalid input.
				}
				
				std::unordered_map<int, int> elementCount;
				int distinct = 0;
				
				// Calculate distinct elements in the first window.
				for (int i = 0; i < k; ++i) {
					if (elementCount[arr[i]] == 0) {
						distinct++;
					}
					elementCount[arr[i]]++;
				}
				
				distinctCount.push_back(distinct);
				
				// Slide the window and update distinct count.
				for (int i = k; i < len; ++i) {
					int leftElement = arr[i - k];
					int rightElement = arr[i];
					
					// Remove the leftmost element from the window.
					if (elementCount[leftElement] == 1) {
						distinct--;
					}
					elementCount[leftElement]--;
					
					// Add the rightmost element to the window.
					if (elementCount[rightElement] == 0) {
						distinct++;
					}
					elementCount[rightElement]++;
					
					distinctCount.push_back(distinct);
				}
				return distinctCount;	
			}
		
		// Simpler: (Sliding Window)
			#include <bits/stdc++.h> 
			vector<int> countDistinctElements(vector<int> &arr, int k)  {
				vector<int> ans;
					
				int temp  = k, i=0;
				map<int, int> mp;

				while(temp--)
					mp[arr[i++]]++;
				
				ans.push_back(mp.size());

				int j = 0;
				for(; i < arr.size(); i++){
					mp[arr[i]]++;
					mp[arr[j]]--;
					if(mp[arr[j]] == 0)
						mp.erase(arr[j]);

					j++;     
					ans.push_back(mp.size());
				}
				return ans;
			}

	26) Tweaked Array:
		Sample Input 1 :
			2
			3
			1 4 1
			3
			5 2 -5
			Sample Output 1 :
			5 2 5
			-3 0 7
			Explanation Of Sample Input 1 :
			For test 1:
			TotalSum = 1 + 4 + 1 = 6
			Tweaked array = {6 - 1,  6 - 4,  6 - 1} = {5, 2, 5}

			For test 2:
			TotalSum = 5 + 2 + (-5) = 2
			Tweaked array = {2 - 5,  2 - 2,  2 - (-5)} = {-3, 0, 7}
			Sample Input 2 :
			2
			2
			1 2
			3
			-1 -2 -4
			Sample Output 2 :
			2 1
			-6 -5 - 3

		#include <bits/stdc++.h> 
		vector<int> tweakTheArray(vector<int> arr, int n){
			int sum=0;
			for(int i=0; i<arr.size(); i++){
				sum += arr[i];
			}

			for(int i=0;i<arr.size();i++)
				arr[i] = sum - arr[i];

			return arr;
		}

	27) Lucky String:
		You are given a string 'S' of length 'N' consisting of lowercase latin letters. If
		there is a letter occurring consecutively three times (at least three times), the
		string becomes unlucky for you. Your task is to erase some characters
		from the string such that it becomes lucky for you. A string which is not unlucky, is considered as lucky.
		Output the minimum number of removals (of characters) required to make the given
		string lucky.
		Sample Input 1 :
			2
			7
			abcccca
			5
			cbazz
			Sample Output 1 :
			2
			0
			Explanation For Sample Input 1 :
			For test case 1:
			If a substring "cc" is deleted from any position, the remaining string becomes lucky. Hence a minimum removal of 2 characters is required. 

			For test case 2:
			Given string is already lucky. No removal is required.
			Sample Input 2 :
			3
			5
			bbbbb
			2
			xy
			9
			abcccbaaa
			Sample Output 2 :
			3
			0
			2

		#include <bits/stdc++.h> 
		int makeLucky(string s, int n){
			int i=0,cnt=0;
			while(i<s.length()-1){
				if(s[i] == s[i+1])
					if(s[i+1] == s[i+2])
						cnt++;
				i++;
			}
			return cnt;
		}

	28) Minimize Bill:
		Sample Input 1 :
			2
			5
			-2 0 5 2 -1
			4
			5 8 7 9
			Sample Output 1 :
			-6
			11
			Explanation For Sample Input 1 :
			For test case 1:
			The optimal way is to make change at A[2]. Minimum sum of array (after change) becomes -2+0+(-5)+2-1 = -6.

			For test case 2:
			Make change at A[3]. Minimum sum becomes 5+8+7+(-9) = 11.
			Sample Input 2 :
			3
			4
			3 -1 0 2
			2
			0 -1
			5
			5 5 5 5 5
			Sample Output 2 :
			-2
			-1
			15

		#include <bits/stdc++.h> 
		long long totalBill(int n, vector<int>& a){
			int mxValInd=0;

			for(int i=0;i<a.size();i++)
				if(a[mxValInd] < a[i])
					mxValInd = i;
			
			a[mxValInd] = -1 * (a[mxValInd]);

			int sum=0;
			for(int i=0;i<a.size(); i++)
				sum += a[i];
			return sum;
		}

	29) Encode The String:
		Sample Input 1 :
			2
			3
			dog
			4
			cazz
			Sample Output 1 :
			cpf
			bbyy
			Explanation Of Sample Input 1 :
			For the first test case :

			Character ‘d’ gets changed to ‘c’.
			Character ‘o’ gets changed to ‘p’.
			Character ‘g’ gets changed to ‘f’.

			Encoded string = “cpf”.


			For the second test case :

			Character ‘c’ gets changed to ‘b’.
			Character ‘a’ gets changed to ‘b’.
			Character ‘z’ gets changed to ‘y’.
			Sample Input 2 :
			2
			4
			gjmf
			3
			abc
			Sample Output 2 :
			file
			bab

		#include <bits/stdc++.h> 
		string encodeString(string &s, int n) {
			for(int i=0;i<s.length();i++){
				if(s[i] == 'a'){
					s[i] = 'b';
				}else if(s[i] == 'e'){
					s[i] = 'f';
				}else if(s[i] == 'i'){
					s[i] = 'j';
				}else if(s[i] == 'o'){
					s[i] = 'p';
				}else if(s[i] == 'u'){
					s[i] = 'v';
				}else{
					s[i] = s[i] - 1;
				}     
			}
			return s;
		}

	30) Next Greater Element:
		Problem Statement
			You are given an array 'a' of size 'n'
			Print the Next Greater Element(NGE) for every element.
			The Next Greater Element for an element 'x' is the first element on the right side of 'x' in the array, which is
			greater than 'x'.
			If no greater elements exist to the right of 'x', consider the next greater element as - 1.
			For Example:
			Input: 'a' • [7, 12, 1, 20]
			Output: NGE = [12, 20, 20, -1]
			Explanation: For the given array,
			- The next greater element for 7 is 12.
			- The next greater element for 12 is 20.
			- The next greater element for 1 is 20.
			- There is no greater element for 20 on the right side. So we consider NGE as
		
			Sample Input 1:
				5
				1 5 3 4 2

				Sample Output 1:
				5 -1 4 -1 -1

				Sample Input 2:
				5
				5 5 5 5 5

				Sample Output 2:
				-1 -1 -1 -1 -1

				Expected Time Complexity :
				The expected time complexity is O(n).

				Constraints :
					1 <= 'n' <= 10^5
					1 <= 'a[i]' <= 10^9
					Time Limit: 1 sec

		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			for(int i=0;i<n;i++){
				if(i == (n-1)){
					arr[i] = -1;
					return arr;
				}
				int j=i+1;
				for(j; j<n;j++){
					if(arr[i] < arr[j]){
						arr[i] = arr[j];
						break;
					}
				}
				if(j==n)
					arr[i] = -1;
			}
		}
		
		//optimized
		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			vector<int> res(n, -1);
			stack<int> st;

			for(int i=0;i<n;i++){
				while(!st.empty() && arr[i] > arr[st.top()]){
					res[st.top()] = arr[i];
					st.pop();
				}
				st.push(i);
			}
			return res;
		}

	31) Implement Deque:
		-https://www.codingninjas.com/studio/problems/deque_1170059
		#include <bits/stdc++.h>
		#include<queue>
		using namespace std;
		class Deque
		{
			public:
				// Initialize your data structure.
				int size;
				deque<int> d;
				Deque(int n){
					// Write your code here.
					size = n;
				}

				// Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushFront(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_front(x);
						return true;
					}
					return false;
				}

				// Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushRear(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_back(x);
						return true;
					}
					return false;
				}

				// Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popFront(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.front();
						d.pop_front();
						return temp;
					}
					return -1;
				}

				// Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popRear(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.back();
						d.pop_back();
						return temp;
					}
					return -1;
				}

				// Returns the first element of the deque. If the deque is empty, it returns -1.
				int getFront(){
					// Write your code here.
					if(!d.empty()){
						return d.front();
					}
					return -1;
				}

				// Returns the last element of the deque. If the deque is empty, it returns -1.
				int getRear(){
					// Write your code here.
					if(!d.empty()){
						return d.back();
					}
					return -1;
				}

				// Returns true if the deque is empty. Otherwise returns false.
				bool isEmpty(){
					// Write your code here.
					if(d.empty())
						return true;
					
					return false;
				}

				// Returns true if the deque is full. Otherwise returns false.
				bool isFull(){
					// Write your code here.
					if(d.size() == size)
						return true;
					return false;
				}
		};
	
	32) Direction Game:
		Ninja is currently facing North. An instructor gives him 'N' instructions in the
		form of a binary string 'S'. If 'S[ i ]' is '0', then Ninja will turn clockwise by ‘90’
		degrees. Otherwise, Ninja will turn counterclockwise by ‘90’ degrees.
		Ninja is lazy and doesn't feel like doing all 'N' instructions. So, he decides to just face
		the final direction. Find the final direction of Ninja, which will be one of the
		following: 'NORTH', 'SOUTH', 'EAST', or 'WEST
		Sample Input 1:
			2
			4
			1111
			4
			1101
			Sample Output 1:
			NORTH
			SOUTH
			Explanation Of Sample Input 1:
			For test case 1:
			Ninja’s direction will change in the following order:
			North → West → South  → East → Noth
			So, the answer is 'NORTH'.

			For test case 2:
			Ninja’s direction will change in the following order:
			North → West → South → West → South
			So, the answer is 'SOUTH'.
			Sample Input 2:
			2
			8
			10011101
			7
			0101011
			Sample Output 2:
			SOUTH
			WEST

		string directionGame(int n, string &s){
			vector<string> dire = {"NORTH","WEST","SOUTH","EAST"};
			int index=0;
			for(int i=0;i<n;i++){
				if(s[i] == '1')
					index = (index+1)%4;
				else
					index = (index+3)%4;
			}
			return dire[index];
		}

	33) Apple Harvest:
		Sample Input 1:
			2
			20 15 5
			7 4 6
			Sample Output 1 :
			25
			18
			Explanation For Sample Input 1:
			For test case 1:
			The tree produces 20 apples daily. The basket can hold up to 15 apples. So, every day 5 apples are wasted. Over 5 days, 25 apples are wasted.

			For test case 2:
			The tree produces 7 apples daily. The basket can hold up to 4 apples. So, every day 3 apples are wasted. Over 6 days, 18 apples are wasted.
			Sample Input 2:
			2
			50 25 10
			12 5 7
			Sample Output 2 :
			250
			49

		long long wastedApples(int n, int m, int x) {
			return static_cast<long long>(max(0,(n-m)))*x;
		}

	34) Ninja wants Holiday:
		Ninja is a corporate employee, and like
			other corporate employees, he also wants
			to visit his home on long holidays. He
			wants to spend at least 'K' consecutive
			days at his home.
			You are given an array 'A' of length 'N'
			denoting the list of holidays. Ninja can
			only take leave on holidays.
			You have to find if it's possible for Ninja to
			spend at least 'K' consecutive days at his
			home.
			Example:
			'N' = 4
			'K' = 3
			'A' = [1, 3, 4, 5]
			Ninja can take leave on '1',
			'3', '4', and '5'. Therefore,
			he can take leave consecutively
			for at most 3 days, which are
			from '3' to '5'.
			Thus, minimum requirement of 'K= 3' is satisfied in this case. Hence, the final output will be 'YES'.

		Sample Input 1:
			2
			5 3
			1 3 7 5 8
			4 2
			2 4 8 3
			Sample Output 1:
			NO
			YES
			Explanation Of Sample Input 1:
			For test case 1:
			Holidays cannot be taken for three days in a row.
			Hence, the answer for this case is "NO".

			For test case 2:
			Ninja can take holidays on days '2' and '3', thus satisfying requirement of holiday on two consecutive days.
			Hence, the answer for this case is "YES".
			Sample Input 2:
			2
			5 3
			2 3 5 8 7
			4 2
			4 5 2 3
			Sample Output 2:
			NO
			YES


		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;

		string ninjaWantsHoliday(int n, int k, vector<int> &a) {
			sort(a.begin(), a.end());
			int cnt=1;
			for(int i=0;i<n; i++){      //1 4 5 8 10
				if(a[i]+1 == a[i+1]){
					cnt++;
					if(cnt == k)
						return "YES";
				}else{
					cnt=1;
					continue;
				}
			}
			return "NO";
		}
		int main(){
			int n=5, k=2;

			vector<int>a {5, 10, 1 ,8, 4};
			string s = ninjaWantsHoliday(n,k,a);
			std::cout << s << std::endl;
			return 0;
		}

	35) Vaccination Drive:
		Problem statement
			The Indian government recently launched the world's largest vaccination drive for COVID-19. Dr Ritesh has been appointed as a nodal officer for vaccinating a locality. There are ‘N’ houses numbers from 1 to ‘N’ in that locality. Dr Ritesh will visit each house one by one and vaccinate all the people in the house. He has already covered ‘K’ number of houses. Since ‘N’ is a very large number, ‘L’ bits are required to represent the number. You are supposed to help Dr Ritesh and find the maximum possible number of houses that are yet to be covered under the vaccination drive.
			Input Format :
			The first line contains an integer ‘T’ denoting the number of test cases. Then each test case follows.
			The first input line of each test case contains two space-separated integers ‘K’ and ‘L’ as described in the problem.

			Output Format :
			For each test case, print the maximum possible number of houses that are yet to be covered under the vaccination drive.
			The output of each test case will be printed in a separate line.
			Note:
			You are not required to print the expected output, it has already been taken care of. Just implement the function.
			Constraints :
				1 <= T <= 50
				1 <= ‘K’ <= N
				1 <= ‘L’ <= 30
				Where ‘T’ is the number of test cases, ‘K’, ‘N’ and ‘L’ are described in the problem statement.
				Time limit: 1 sec
			Sample Input 1 :
				2
				3 5
				5 3
				Sample output 1 :
				29
				3
				Explanation of Sample output 1 :
				For the first test case, since the number of bits required is 5, the maximum possible value for ‘N’ is 32. So the maximum possible number of remaining houses are 32 - 3 = 29.

				For the second test case, since the number of bits required is 3, the maximum possible value for ‘N’ is 8. So the maximum possible number of remaining houses are 8 - 3 = 5.
				Sample Input 2 :
				2
				1 1
				2 3
				Sample output 2 :
				1
				6

		#include <bits/stdc++.h> 
		int getMaximumHouses(int k, int l){
			return (pow(2,l))-k;
		}

		// or
			#include <bits/stdc++.h> 
			int getMaximumHouses(int k, int l) {
				// int n = pow(2, l);
				// return n-k;

				return (1 << l) - k; 			// left Shift operator to generate the power of 2.
			}

	36) Factorial of Larger nums:
		void multiply(vector<int> &result, int x) {
			int carry = 0;
			for (int i = 0; i < result.size(); i++) {
				int product = result[i] * x + carry;
				result[i] = product % 10;
				carry = product / 10;
			}
			
			while (carry) {
				result.push_back(carry % 10);
				carry /= 10;
			}
		}

		void factorial(int n){
			vector<int> result;
			result.push_back(1); // Initialize the result as 1
			
			for (int i = 2; i <= n; i++) {
				multiply(result, i);
			}
			
			// Print the result in reverse order
			for (int i = result.size() - 1; i >= 0; i--) {
				cout << result[i];
			}
			cout << endl;   
		}

	37) Print all Divisors of a number
		Given an integer 'N', return all the divisors of 'N' in ascending order.
		For Example:
		'N' = 5.
		The divisors of 5 are 1, 5.
		Sample Input 1 :
			10
			Sample Output 1 :
			1 2 5 10
			Explanation Of Sample Input 1:
			The divisors of 10 are 1,2,5,10.
			Sample Input 1 :
			6
			Sample Output 1 :
			1 2 3 6

		vector<int> printDivisors(int n) {
			vector<int> ans;
			for(int i=1;i<=n/2;i++)
				if(n % i == 0)
					ans.push_back(i);

			ans.push_back(n);
			return ans;
		}
	
	38) Rotate array
		Problem Statement:
			Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative.
			Example:
			'arr '= [1,2,3,4,5]
			'k' = 1  rotated array = [2,3,4,5,1]
			'k' = 2  rotated array = [3,4,5,1,2]
			'k' = 3  rotated array = [4,5,1,2,3] and so on.
			Detailed explanation ( Input/output format, Notes, Images )
			Sample Input 1:
			8
			7 5 2 11 2 43 1 1
			2
			Sample Output 1:
			2 11 2 43 1 1 7 5
			Explanation of Sample Input 1:
			Rotate 1 steps to the left: 5 2 11 2 43 1 1 7
			Rotate 2 steps to the left: 2 11 2 43 1 1 7 5
			Sample Input 2:
			4
			5 6 7 8
			3
			Sample Output 2:
			8 5 6 7
			Explanation of Sample Input 2:
			Rotate 1 steps to the left: 6 7 8 5
			Rotate 2 steps to the left: 7 8 5 6
			Rotate 2 steps to the left: 8 5 6 7
			Expected Time Complexity:
			O(n), where ‘n’ is the size of the array ‘arr’ and ‘k’ is the number of rotations.
			Constraints:
			1 <= 'n' <= 10^3
			1 <= 'arr'[i] <= 10^9
			1 <= 'k' < 'n'
			Hints:
				1. For an index ‘i’, find where it lands after k swaps.
				2. When performing rotation once observe how the positions of all elements change.

		vector<int> rotateArray(vector<int>arr, int k) {
			vector<int> ans;
			for(int i=k;i<arr.size();i++)
				ans.push_back(arr[i]);
			
			for(int i=0;i<k;i++)
				ans.push_back(arr[i]);
			
			return ans;
		}

		// or
			vector<int> rotateArray(vector<int>arr, int k) {
				int n = arr.size();
				if(k == n)
					return arr;
				
				reverse(arr.begin(), arr.end());
				reverse(arr.begin(), arr.begin()+(n-k));
				reverse(arr.begin()+(n-k), arr.end());
				return arr;
			}

	39) Generate Binary Numbers:
		Sample Input 1:
			2
			2
			6
			Sample Output 1:
			1 10
			1 10 11 100 101 110
			Explanation 1:
			For the first test case when N = 2. 
			We need all the binary numbers from 1 to 2:
			1 -> 1
			2 -> 10
			Thus, the output is 1, 10.

			For the second test case when N = 6
			We need all the binary numbers from 1 to 6:
			1 -> 1
			2 -> 10
			3 -> 11
			4 -> 100
			5 -> 101
			6 -> 110
			Thus, the output is 1, 10, 11, 100, 101, 110.
			Sample Input 2:
			2
			8
			4
			Sample Output 2:
			1 10 11 100 101 110 111 1000
			1 10 11 100

		#include <bits/stdc++.h>
		string binConvert(int); 
		vector<string> generateBinaryNumbers(int n){
			vector<string> ans;
			for(int i=1;i<=n;i++){
				string s = binConvert(i);
				ans.push_back(s);
			}
			return ans;
		}

		string binConvert(int n){
			string temp;
			while(n>0){
				int t = n % 2;
				temp += to_string(t);
				n/=2;
			}
			reverse(temp.begin(), temp.end());
			return temp;
		}

	40) Sum Of Zeroes
		#include <bits/stdc++.h> 
		int coverageOfMatrix(vector<vector<int>> &matrix) {
		int rows = matrix.size();
		int cols = matrix[0].size();
		int coverage = 0;

		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				if (matrix[i][j] == 0) {
					int adjacent = 0;

					// Check top neighbor
					if (i > 0 && matrix[i - 1][j] == 1) {
						adjacent += 1;
					}

					// Check bottom neighbor
					if (i < rows - 1 && matrix[i + 1][j] == 1) {
						adjacent += 1;
					}

					// Check left neighbor
					if (j > 0 && matrix[i][j - 1] == 1) {
						adjacent += 1;
					}

					// Check right neighbor
					if (j < cols - 1 && matrix[i][j + 1] == 1) {
						adjacent += 1;
					}

					coverage += adjacent;
				}
			}
		}
		return coverage;
		}

	41) Add One To Number
		Sample Input 1
			3
			3
			1 2 3
			2
			9 9
			1
			4
			Sample Output 1
			1 2 4
			1 0 0
			5
			Explanation For Sample Input 1
			In the 1st test case, the number is 123 after adding 1 number becomes 124, hence the output will be {1,2,4}.

			In the 2nd test case, the number is 99 after adding 1 number becomes 100, hence the output will be {1,0,0}.

			In the 3rd test case, the number is 4 after adding 1 number becomes 5, hence the output will be {5}.
			Sample Input 2
			3
			4
			2 4 6 8 
			1
			0
			2
			0 2
			Sample Output 2
			2 4 6 9
			1
			3

		#include <bits/stdc++.h> 
		vector<int> addOneToNumber(vector<int> arr){
			int n = arr.size();
			
			// Add 1 to the least significant digit (rightmost)
			arr[n - 1] += 1;
			
			// Handle carry
			int carry = 0;
			for (int i = n - 1; i >= 0; i--) {
				int sum = arr[i] + carry;
				arr[i] = sum % 10;  // Update the current digit
				carry = sum / 10;   // Calculate the carry for the next digit
			}
			
			// If there is still a carry after processing all digits, insert it at the beginning
			if (carry > 0) {
				arr.insert(arr.begin(), carry);
			}
			//removing leadig zeros
			while(!arr.empty() && arr[0]==0){
				arr.erase(arr.begin());
			}
			return arr;
		}

		//optimized:
			#include <bits/stdc++.h> 
			vector<int> addOneToNumber(vector<int> arr){
				int n= arr.size();
				arr[n-1] += 1;

				int carry=0;
				for(int i= n-1; i>=0; i--){
					arr[i] += carry;
					carry = arr[i] / 10;
					if(!carry)					//if(carry == 0)
						break;					//	break;
					arr[i] = arr[i] % 10;  // Update the current digit
				}

				if(carry>0)
				arr.insert(arr.begin(), carry);

				
				// //removing leading 0 zeros
				while(!arr.empty() && arr[0] == 0)
					arr.erase(arr.begin());

				return arr;
			}

			//or
				#include <bits/stdc++.h> 
				vector<int> addOneToNumber(vector<int> arr) {
					arr[arr.size()-1]++;
					reverse(arr.begin(), arr.end());

					int c = 0, i=0;
					while(i < arr.size()){
						arr[i] += c;
						c = arr[i] / 10;
						if(c == 0)
							break;
						arr[i] %= 10;
						i++;
					}
					if(c != 0)
						arr.push_back(c);
					reverse(arr.begin(), arr.end());

					// removing leading zeros
					while(arr[0] == 0)
						arr.erase(arr.begin());
						
					return arr;
				}
		
		//or
			#include <bits/stdc++.h> 

				// long long ConvertToNum(vector<int> a){
				//     long long num=0;
				//     for(int i=0;i<a.size();i++){
				//         num = num * 10 + a[i];
				//     }
				//     return num+1;
				// }

			vector<int> addOneToNumber(vector<int> arr){
				// long long n = ConvertToNum(arr);
				// vector<int> ans;
				// string s = to_string(n);
				
				// for(int i=0;i<s.length();i++)
				//     ans.push_back(s[i]-48);
				
				// return ans;

				for(int i=arr.size()-1; i>=0; i--){
					if(i == arr.size()-1)
						arr[i] = arr[i]+1;
					if(arr[i]>9 && i>0){
						int l = arr[i] % 10;
						int s = arr[i] /10;
						arr[i] = l;
						arr[i-1] = arr[i-1] + (s);
					}
				}

				if(arr[0]> 9){
					int n = arr[0] % 10;
					int s = arr[0] / 10;
					arr[0] = n;
					arr.insert(arr.begin(),s);
				}

				//to remove trailing zeros
				int i=0;
				while(arr[i] == 0){
					arr.erase(arr.begin());
				}

				return arr;
			}

	42) Find (indexes) All Anagrams in a String:
		Sample Input 1 :
			2
			10 3
			CBAEBABACD
			ABC
			5 2
			ABADE
			BA
			Sample Output 1 :
			0 6
			0 1
			Explanation For Sample Output 1:
			Test Case 1:

			'STR' is ‘CBAEBABACD’ and ‘PTR’ is ‘ABC’.

			0-2 in 'STR' index 0,1,2 are ‘CBA’, and it is an anagram with ‘ABC’.
			1-3 in 'STR' index 1,2,3 are ‘BAE’, and it is not anagram with ‘ABC’.
			2-4 in 'STR' index 2,3,4 are ‘AEB’, and it is not anagram with ‘ABC’.
			3-5 in 'STR' index 3,4,5 are ‘EBA’, and it is not anagram with ‘ABC’.
			4-6 in 'STR' index 4,5,6 are ‘BAB’, and it is not anagram with ‘ABC’.
			5-7 in 'STR' index 5,6,7 are ‘ABA’, and it is not anagram with ‘ABC’.
			6-8 in 'STR' index 6,7,8 are ‘BAC’, and it is an anagram with ‘ABC’.
			7-9 in 'STR' index 7,8,9 are ‘ACD’, and it is not anagram with ‘ABC’.

			Hence, there are only two substrings in the given string 'STR'  that are anagram with given string  ‘PTR’ which are ‘CBA’, and ‘BAC’ and starting indices of respective anagram substrings are 0 and 6.


			Test case 2:

			'STR' is ‘ABADE’ and ‘PTR’ is ‘BA’.

			In the given string ‘ABADE’ the substring of length 2 starting with index 0 is ‘AB’ which is an anagram with the string ‘BA’ and a substring of length 2 starting with index 1 is ‘BA’ which is also an anagram with the string ‘BA’. Because 0 and 1 are starting indices of the substrings, we print 0 and 1.
			Sample Input 2:
			2
			10 4
			BACDGABCDA
			ABCD
			7 1
			ABABABA
			A
			Sample Output 2:
			0 5 6
			0 2 4 6

		#include <bits/stdc++.h>
		vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
			vector<int> ans;
			unordered_map<char, int> charCountPtr, charCountWindow;

			// Initialize the character counts for ptr
			for (char c : ptr) {
				charCountPtr[c]++;
			}

			for (int i = 0; i < n; i++) {
				// Expand the window
				charCountWindow[str[i]]++;

				// Shrink the window if it's larger than m characters
				if (i >= m) {
					char leftChar = str[i - m];
					if (charCountWindow[leftChar] > 1) {
						charCountWindow[leftChar]--;
					} else {
						charCountWindow.erase(leftChar);
					}
				}

				// Check if the current window is an anagram of ptr
				if (i >= m - 1 && charCountWindow == charCountPtr) {
					ans.push_back(i - m + 1);
				}
			}
			return ans;
		}

	43) Armstrong Number
		You are given an integer ‘NUM’ . Your task
		is to find out whether this number is an
		Armstrong number or not.
		A k-digit number ‘NUM’ is an Armstrong
		number if and only if the k-th power of
		each digit sums to ‘NUM
		eg.
			153 = 1^3 + 5^3 + 3^3.
			Therefore 153 is an Armstrong number
		Sample Input 1:
			1
			13
			Sample Output 1:
			NO
			Explanation For Sample Input 1:
			As 1^2 + 3^2 = 10 which is not equal to 13.So we can say it is not an Armstrong number.
			Sample Input 2:
			1
			371
			Sample Output 2:
			YES

		#include <bits/stdc++.h> 
		bool isArmstrong(int num) {
			string s = to_string(num);
			int len = s.length();
			int sum=0;
			int temp = num;
			while(num){
				sum += pow(num%10, len);
				num /=10;
			}
			if(temp == sum)
				return true;
			return false;
		}

	44) Power of 2:
		Given a non-negative integer N. The task is to check if N is a power of 2. 
			More formally, check if N can be expressed as 2x for some integer x.
			Example 1:

			Input: 
			N = 8
			Output: 
			YES
			Explanation:
			8 is equal to 2 raised to 3 (23 = 8).
			Example 2:

			Input: 
			N = 98
			Output: 
			NO
			Explanation: 
			98 cannot be obtained by any power of 2.
			Your Task:Your task is to complete the function isPowerofTwo() which takes n as a parameter and returns true or false by checking if the given number can be represented as a power of two or not.

			Expected Time Complexity:O(log N).
			Expected Auxiliary Space:O(1).

			Constraints:
			0 ≤ N ≤1018
		class Solution{
			public:
			// Function to check if given number n is a power of two.
			bool isPowerofTwo(long long n){
				long long i;
				for(i=0; i<=n/2, pow(2,i)<=n; i++){       //n = 1001, loop will go to till 500 if pow(2,i) <=n condition was not there,
					if(pow(2,i) == n)
						return true;
				}
				return false;
			}
		};

	44) Find position of set bit
		Given a number N having only one ‘1’ and all other ’0’s in its binary representation, 
			find position of the only set bit. If there are 0 or more than 1 set bit the answer should be -1. 
			Position of  set bit '1' should be counted starting with 1 from LSB side in binary representation of the number.
				Example 1:

				Input:
				N = 2
				Output:
				2
				Explanation:
				2 is represented as "10" in Binary.
				As we see there's only one set bit
				and it's in Position 2 and thus the
				Output 2.
				Example 2:

				Input:
				N = 5
				Output:
				-1
				Explanation:
				5 is represented as "101" in Binary.
				As we see there's two set bits
				and thus the Output -1.
				Your Task:
				You don't need to read input or print anything. Your task is to complete the function findPosition() which takes an integer N as input and returns the answer.

				Expected Time Complexity: O(log(N))
				Expected Auxiliary Space: O(1)

				Constraints:
				0 <= N <= 108
		class Solution {
			public:
			int findPosition(int N) {
				if(N==0)
					return -1;
				
				int cnt=0,pos=0;
				while(N){
					pos++;
					if(N&1)
						cnt++;

					if(cnt>1)
						return -1;
					N>>=1;
				}
				return pos;
			}
		};

	45) Check set bits:
		Given a number N. You have to check whether every bit in 
		 the binary representation of the given number is set or not.
			Example 1:
				Input:
				N = 7
				Output:
				1
				Explanation:
				Binary for 7 is 111 all the
				bits are set so output is 1
			Example 2:
				Input:
				N = 8
				Output:
				0
				Explanation:
				Binary for 8 is 1000 all the
				bits are not set so output is 0.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function isBitSet() 
				which takes an integer N as input parameters and returns 1 if 
				all the bits in N's binary representation is set or return 0 otherwise.

			Expected Time Complexity: O(1)
			Expected Space Complexity: O(1)

			Constraints:
				0<=N<=100000
		class Solution{
			public:
			int isBitSet(int N){
				if(N==0)
					return 0;
				
				while(N){
					if(!(N&1)){
						return 0;
					}
					N>>=1;
				}
				return 1;
			}
		};

	46) Admission in Ninja Gram
		Sample Input 1:
			2

			12
			toosmallword
			35
			TheQuickBrownFoxJumpsOverTheLazyDog
			
			Sample Output 1:
			NO
			YES
			Explanation For Sample Input 1:
			In the first test case, the given string is “toosmallword” which contains 
			the characters [‘t’,’o’,’s’,’m’,’a’,’l’,’w’,’r’,’d’], which doesn’t contain 
			all the 26 alphabetic characters. Hence the answer is “NO”.

			In the second test case, the given string is “TheQuickBrownFoxJumpsOverTheLazyDog” 
			which contains the characters: [‘t’,’h’,’e’,’q’,’u’,’i’,’c’,’k’,’b’,’r’,’o’,’w’,’n’,’f’,’x’,’j’,’m’,’p,’’s’,’v’,’l,’a’,’z’,’y’,’ d’,’g’], 
			which contains all the 26 alphabetic characters. Hence the answer is “YES”.
		Sample Input 2:

			2
			16
			CodingNinjas
			10
			CodeStudio
			Sample Output 2:
			NO
			NO
			Explanation For Sample Input 2:
			In the first test case, the given string is “CodingNinjas” which contains the characters 
			[‘c’,’o’,’d’,’i’,’n’,’g’,’i’,’j’,’a’,’s’], which doesn’t contain all the 26 
			alphabetic characters. Hence the answer is “NO”.


			In the first test case, the given string is “CodeStudio” which contains the characters 
			[‘c’,’o’,’d’,’e’,’s’,’t’,’u’,’i’], which doesn’t contain all the 26 alphabetic characters. 
			Hence the answer is “NO”.

		#include <bits/stdc++.h> 
		bool ninjaGram(string &str){
			//to convert string to lower-case,
			transform(str.begin(),str.end(), str.begin(), ::tolower);
			
			char ch = 'a';
			int i=0;
			while(i<str.length()){
				if(str[i] == ch){
					ch++;
					i=0;
				}
				i++;
			}
			if(ch > 'z')
				return 1;
			return 0;
		}
		
		//or
		#include <bits/stdc++.h> 
		bool ninjaGram(string &str) {
			//convert all letter of string into lowercase
			transform(str.begin(), str.end(), str.begin(), ::tolower);
			char ch = 'a';
			int i;
			for(i=0; i<str.length(); i++){
				if (ch == str[i]) {
				ch++;
				i = 0;
				}
			}
			if (ch > 'z')
				return 1;
			return 0;
		}

		//or
		#include <bits/stdc++.h> 
		bool ninjaGram(string &str){
			
			string lowerStr = "";
			for (int i  = 0; i < str.length(); i++){
				lowerStr += tolower(str[i]);
			}
			
			int count[26]  = {0};
			
			for (int i  = 0 ; i < lowerStr.length(); i++){
				count[lowerStr[i] - 'a']++;
			}
			for (int i = 0 ; i < 26; i++){
				if(count[i] == 0){
					return false;
				}
			}
			return true;
		}

	47) Find All Anagrams in a String
		https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
		Given two strings s and p, return an array of all the start 
		 indices of p's anagrams in s. You may return the answer in any order.

			An Anagram is a word or phrase formed by rearranging the letters of 
			a different word or phrase, typically using all the original letters exactly once.
			Example 1:
				Input: s = "cbaebabacd", p = "abc"
				Output: [0,6]
				Explanation:
				The substring with start index = 0 is "cba", which is an anagram of "abc".
				The substring with start index = 6 is "bac", which is an anagram of "abc".
			Example 2:
				Input: s = "abab", p = "ab"
				Output: [0,1,2]
				Explanation:
				The substring with start index = 0 is "ab", which is an anagram of "ab".
				The substring with start index = 1 is "ba", which is an anagram of "ab".
				The substring with start index = 2 is "ab", which is an anagram of "ab".
			
			Constraints:
				1 <= s.length, p.length <= 3 * 104
				s and p consist of lowercase English letters.
		class Solution {
			public:
			bool areTheyEqual(int a1[26], int a2[26]){
				for(int i=0;i<26;i++){
					if(a1[i] != a2[i])
						return 0;
				}
				return 1;
			}

			vector<int> findAnagrams(string s, string p) {
				vector<int> ans;

				int count1[26]={0}, count2[26]={0}, i=0;
				//count1 array is for s
				//count2 array is for p

				//mapping for p string
				while(i<p.length()){
					// int ind = p[i]-'a';
					count2[p[i]-'a']++;
					i++;
				}

				//mapping for s string
				i=0;
				while(i<p.length() && i< s.length()){
					// int ind = s[i] - 'a';
					count1[s[i] - 'a']++;
					i++;
				}

				if(areTheyEqual(count1,count2))
					ans.push_back(i-p.length());

				while(i<s.length()){
					// int ind = s[i] - 'a';
					count1[s[i] - 'a']++;
					count1[s[i-p.length()]-'a']--;

					i++;
					if(areTheyEqual(count1,count2))
						ans.push_back(i-p.length());
				}
				return ans;
			}
		};

		//own solution found char array used here
			class Solution {
				public:
				bool areSame(char a[], char b[]){
					for(int i=0;i<26;i++)
						if(a[i] != b[i])
							return 0;
					return 1;
				}
				vector<int> findAnagrams(string s, string p) {
					vector<int> ans;
					if(s.size()<p.size())
						return ans;
					//mapping p's letters
					char forP[26] ={0};
					for(int i=0;i<p.length();i++){
						forP[p[i] - 'a']++;
					}

					int i=0;
					while(i<=s.length()-p.length()){
						string temp = s.substr(i,p.length());
						//mapping here for temp
						char forS[26] = {0};
						for(int l=0; l<temp.length(); l++)
							forS[temp[l]-'a']++;

						if(areSame(forS,forP))
							ans.push_back(i);
						i++;
					}
					return ans;
				}
			};

		//vector used here.
			class Solution {
				public:
				bool areSame(vector<char> a, vector<char> b){
					for(int i=0;i<a.size();i++)
						if(a[i] != b[i])
							return 0;
					return 1;
				}
				vector<int> findAnagrams(string s, string p) {
					vector<int> ans;
					if(s.size()<p.size())
						return ans;
					//mapping p's letters
					vector<char> forP(26,0);
					for(int i=0;i<p.length();i++){
						forP[p[i] - 'a']++;
					}

					int i=0;
					while(i<=s.length()-p.length()){
						string temp = s.substr(i,p.length());
						//mapping here for temp
						vector<char> forS(26,0);
						for(int l=0; l<temp.length(); l++)
							forS[temp[l]-'a']++;

						if(areSame(forS,forP))
							ans.push_back(i);
						i++;
					}
					return ans;
				}
			};

	48) Find first set bit
		Given an integer N. The task is to return the position of first set bit 
			found from the right side in the binary representation of the number.
			Note: If there is no set bit in the integer N, then return 0 from the function.  

			Example 1:
				Input: 
				N = 18
				Output: 
				2
				Explanation: 
				Binary representation of 18 is 010010,the first set bit from the right side is at position 2.
			Example 2:
				Input: 
				N = 12 
				Output: 
				3 
				Explanation: 
				Binary representation of  12 is 1100, the first set bit from the right side is at position 3.
			Your Task:
				The task is to complete the function getFirstSetBit() that 
				takes an integer n as a parameter and returns the position of first set bit.

			Expected Time Complexity: O(log N).
			Expected Auxiliary Space: O(1).

			Constraints:
				0 <= N <= 108
		class Solution{
			public:
			//Function to find position of first set bit in the given number.
			unsigned int getFirstSetBit(int n){
				int cnt=0;
				if(n==0)
					return cnt;
				while(n){
					cnt++;
					if(n&1){
						break;
					}
					n>>=1;
				}
				return cnt;
			}
		};

	49) Duplicate In Array
		Sample Input 1:
			2
			5
			4 2 1 3 1
			7
			6 3 1 5 4 3 2
			Sample Output 1:
			1
			3
			Explanation Of Sample Input 1:
			For the first test case, 
			The duplicate integer value present in the array is 1. Hence, the answer is 1 in this case.

			For the second test case,
			The duplicate integer value present in the array is 3. Hence, the answer is 3 in this case.
			Sample Input 2:
			2
			6 
			5 1 2 3 4 2  
			9
			8 7 2 5 4 7 1 3 6
			Sample Output 2:
			2
			7
		
		#include <bits/stdc++.h>
		int findDuplicate(vector<int> &arr) {
			// for (int i = 0; i < arr.size(); i++)
			//     for (int j = i + 1; j < arr.size(); j++)
			//         if (arr[i] == arr[j])
			//             return arr[i];

			unordered_set<int> seen;

			for(int i:arr){
				if(seen.find(i) != seen.end())
					return i;
				seen.insert(i);
			}
		}
		
		//Or
		#include <bits/stdc++.h>
		int findDuplicate(vector<int> &arr){
			map<int, int> mp;
			for(int o: arr){
				mp[o]++;
				if(mp[o] >=2)
					return o;
			}
		}

	50) Different Bits Sum Pairwise:
			Sample Input 1 :
				2
				2
				1 2
				2
				6 6
				Sample Output 1 :
				4
				0
				Explanation For Sample Input 1 :
				Test Case 1:
				All the possible pairs in the given array are:-
				f(1, 1) - as both numbers are same, no. of bit differences is 0
				f(1, 2) - 1 in binary is (0001) and 2 in binary is (0010). There are 2 bits which are different in both the numbers. Hence, no. of bit differences is 2.
				f(2, 2) - as both numbers are the same, no, of bit differences is 0
				f(2, 1) - same as (1, 2), hence no. of bit differences is 2.
				Summing the above values (0+2+0+2) we get 4. Hence, the output is 4.

				Test Case 2:
				There is only one possible pair (6,6). As both the numbers are sum, the output is 0.
			Sample Input 2 :
				2
				3 
				1 3 5
				4
				4 6 7 8
				Sample Output 2 :
				8
				26

		//NOT Optimized
			#include <bits/stdc++.h> 
			int differentBitsSumPairwise(vector<int> &arr, int n){
				int sum=0;
				for(int i=0;i<n;i++){
					for(int j=0;j<n;j++){
						
						if(arr[i] == arr[j]){
							continue;
						}else{
							int cnt=0;
							int outer = arr[i],inner=arr[j];
							while(outer !=0 || inner !=0){
								int LBout = outer&1;
								int LBinn = inner&1;
								if(LBout ^ LBinn == 1){
								cnt++;
								}
								outer>>=1;
								inner>>=1;
							}
							sum += cnt;
						}
					}
				}
				return sum;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int differentBitsSumPairwise(vector<int> &arr, int n){
				int sum = 0;
				// Count the number of set bits at each position
				for (int i = 0; i < 32; i++) { 
					// Assuming integers are 32 bits
					int countOnes = 0;
					
					for (int j = 0; j < n; j++) {
						if ((arr[j] >> i) & 1) {
							countOnes++;
						}
					}
					
					int countZeros = n - countOnes;
					
					// For each position, add the count of different bits to the sum
					// Multiply by 2 to count both 0->1 and 1->0 transitions
					sum += countOnes * countZeros * 2; 
				}
				return sum;
			}

	51) First Unique Character in a String
		Sample Input 1:
			2
			bbabcbcb
			babaabea
			Sample Output 1:
			a
			e

			Explanation Of Sample Input 1:
				For the first test case, 
				the first non-repeating character is ‘a’. As depicted the character 
				‘b’ repeats at index 1, 3, 5, 7, and character ‘c’ repeats at index 6. Hence we return the character ‘a’ present at index 2.
				
				For the second test case, 
				the character ‘e’ is the first non-repeating character. As depicted the character ‘b’ repeats at 
				index 2, 5, and character ‘a’ repeats at index 3, 4, and 7. Hence we return the character ‘e’ present at index 6.
		
		Sample Input 2:
			3
			cbbd
			bebeeed
			abcd
			Sample Output 2:
			c
			d
			a

		#include <bits/stdc++.h> 
		char findNonRepeating(string str) {
			int cnt=1;
			for(int i=0;i<str.length();i++){
				if(isalpha(str[i])){
					char ch = str[i];
					int j=i+1;
					cnt=1;
					while(j < str.length()){
						if(isalpha(str[j]))
							if(str[i] == str[j]){
							str[j] = '0';
							cnt++;
							}
						j++;
					}
				}
				if(cnt == 1)
					return str[i];
			}
			return '#';
		}	

	52) MegaPrime Numbers:
		Sample Input 1 :
			2
			2 15
			11 24
			Sample Output 1 :
			4
			1
			Explanation Of Sample Input 1 :
				Test Case 1:
					‘Left’ = ‘2’ and ‘Right’ = ‘15’ 
				All prime numbers from ‘2’ to ‘15’ are 2, 3, 5, 7, 11, 13

					2 is ‘megaprime’ number because its individual digit ‘2’ is prime.
					3 is ‘megaprime’ number because its individual digit ‘3’ is prime.
					5 is ‘megaprime’ number because its individual digit ‘5’ is prime.
					7 is ‘megaprime’ number because its individual digit ‘7’ is prime.
					11 is not ‘megaprime’ number because its individual digits ‘1’ and ‘1’ both are not prime.
					13 is not ‘megaprime’ number because its individual digits ‘1’ is not prime.
					Hence because there are four ‘megaprime’ numbers 2, 3, 5, 7 out of 2, 3, 5, 7, 11, 13, we return four.
				Test case 2:
					‘Left’ = 11 and ‘Right’ = 24 
				All prime numbers from ‘11’ to ‘24’ are 11, 13, 17, 19, 23
					11 is not a ‘megaprime’ number because its individual digit ‘1’ is not prime.
					13 is not ‘megaprime’ number because its individual digit ‘1’ is not prime.
					17 is not ‘megaprime’ number because its individual digit ‘1’ is not prime.
					19 is not ‘megaprime’ number because its individual digits ‘1’ and ‘9’ both are not prime.
					23 is ‘megaprime’ number because its individual digits ‘2’ and ‘3’ both are prime.

				Since there is only one ‘megaprime’ number, 23 out of 11 13, 17, 19, 23, we return one.
		Sample Input 2 :
			2
			1 11
			1 100
			Sample Output 2 :
			4
			8
		#include <bits/stdc++.h> 
		bool isPrime(int num){
			if(num ==1)
				return 0;
			else if(num == 2 || num ==3){
				return 1;
			}else{
				int i=2;
				for(; i<= num/2; i++){
					if(num % i == 0)
						return 0;
				}
				if(i > (num/2))
					return 1;
			}
			return 0;
		}
		int countMegaPrimeNumber(int left, int right) {
			vector<int> megaPrime;
			vector<int> primeNums;
			for(int i=left; i<=right; i++){
				int num = i, start=2;
				while(start <= num/2){
					if(num % start == 0){
						break;
					}
					start++;
				}
				if(start > (num/2))
					primeNums.push_back(num);
			}

			for(int i=0; i<primeNums.size(); i++){
				int n = primeNums[i];
				while(n){
					int lastDigit = n % 10;
					if(lastDigit == 0)
						break;
					else if(isPrime(lastDigit)){
						n/=10;
					}else{
						break;
					}
				}

				if(n == 0)
					megaPrime.push_back(primeNums[i]);
			}
			return megaPrime.size();
		}

		//or

			#include <iostream>
			#include <bits/stdc++.h> 
			using namespace std;

			bool isPrime(int num){
				if(num ==1)
					return 0;
				else if(num == 2 || num ==3){
					return 1;
				}else{
					int i=2;
					for(; i<= num/2; i++){
						if(num % i == 0)
							return 0;
					}
					if(i > (num/2))
						return 1;
				}
				return 0;
			}
			int countMegaPrimeNumber(int left, int right) {
				vector<int> megaPrime;
				vector<int> primeNums;
				for(int i=left; i<=right; i++){
					int num = i, start=2;
					while(start <= num/2){
						if(num % start == 0){
							break;
						}
						start++;
					}
					if(start > (num/2))
						primeNums.push_back(num);
				}

				for(int i=0; i<primeNums.size(); i++){
					int n = primeNums[i];
					while(n){
						int lastDigit = n % 10;
						if(lastDigit == 0)
							break;
						else if(isPrime(lastDigit))
							n/=10;
						else
							break;
					}
					if(n == 0)
						megaPrime.push_back(primeNums[i]);
				}
				cout<<endl<<"Megaprimes are "<<endl;
				for(int j=0; j<megaPrime.size(); j++)
					cout<<megaPrime[j]<<" ";
				cout<<"\n";
				return megaPrime.size();
			}

			int main()
			{
				cout<<countMegaPrimeNumber(7,2547)<<endl;
				return 0;
			}

	53) (moderate) Predict the Winner:
		Description:
			Sample Input 1:
				2
				5
				2
				4
				3
				Sample Output 1:
					3
					1
				Explanation Of Sample Input 1:
				For the first test case:
					The game starts with Person 1. He passes the ball to person 2. 
					The game pauses here. Person 2 passes the ball to person 3 and leaves the game. 
					Then the game resumes. Person 3 passes the ball to person 4. The game pauses here. 
					Person 4 passes the ball to person 5 and leaves the game. 
					Then the game resumes with person 5 having the ball in his hand. 
					He passes the ball to person 1. The game pauses here. Person 1 passes the ball 
					to person 3 and leaves the game. Then the game resumes with person 3 having the ball in his hand. 
					He passes the ball to person 5. The game pauses here. Person 5 passes the ball to person 3 
					and leaves the game. Now only person 3 remains and the game stops here.

				Hence, the winner of the game will be Person 3 and the answer will be 3.
				For the second test case:
					The game starts with Person 1. He passes the ball to person 2. Person 2 passes the ball to Person 3. 
					The game pauses here. Person 3 passes the ball to Person 4 and leaves the game. Then the game resumes. 
					Person 4 passes the ball to person 1. Person 1 passes the ball to person 2.The game pauses here. 
					Person 2 passes the ball to person 4 and leaves the game. Then the game resumes with Person 4 
					having the ball in his hand. He passes the ball to person 1. Person 1 passes the ball to Person 4. 
					The game pauses here. Person 4 passes the ball to person 1 and leaves the game. 
					Now only person 1 remains and the game stops here.
					Hence, the winner of the game will be Person 1 and the answer will be 1.
			Sample Input 2:
				1
				4
				1
				Sample Output 2:
				4
		//not optimized
			#include <bits/stdc++.h> 
			int predictTheWinner(int n, int k) {
				vector<int> v;
				for(int i=1; i<=n; i++)
					v.push_back(i);

				if(v.size() == 1)
					return v[0];

				if(k==1)
					return n;

				int pointer=0;
				while(v.size() > 1){
					pointer = (pointer+k-1) % v.size();
					v.erase(v.begin()+pointer);
				}
				return v[0]; 
			}

		//Optimized
			#include <bits/stdc++.h> 
			int predictTheWinner(int n, int k) {
				if (k == 1) {
					return n;
				}

				int winner = 0;
				for (int i = 2; i <= n; i++) {
					winner = (winner + k) % i;
				}

				return winner + 1;
			}

	54) Ninja And The Nested Ranges:
		//Not Optimized:
			Sample Input 1 :
				2
				3
				3 8
				1 3
				7 8
				4
				4 9
				9 10
				4 10
				2 3
				Sample Output 1 :
				1 0 0
				0 0 1
				0 0 1 0
				1 1 0 0
				Explanation Of Sample Output 1 :
				Test Case 1 :  
				For ‘RESULT[ 0 ]’ array:
				Since the range [3, 8] contains the range [7, 8], the output corresponding to [3, 8] is 1.
				The range [1, 3] does not contain any of the ranges. Therefore, the output corresponding to [1, 3] is 0.
				The range [7, 8] does not contain any of the ranges. Therefore, the output corresponding to [7, 8] is 0.

				For ‘RESULT[ 1 ]’ array:
				The range [3, 8] is not contained by any of the ranges. Therefore, the output corresponding to [3, 8] is 0.
				The range [1, 3] is not contained by any of the ranges. Therefore, the output corresponding to [1, 3] is 0.
				Since the range [7, 8] is contained by the range [3, 8], the output corresponding to [7, 8] is 1.

				Test Case 2 :     
				For ‘RESULT[ 0 ]’ array:
				The range [4, 9] does not contain any of the ranges. Therefore, the output corresponding to [4, 9] is 0.
				The range [9, 10] does not contain any of the ranges. Therefore, the output corresponding to [9, 10] is 0.
				Since the range [4, 10] contains the ranges [4, 9] and [9, 10], the output corresponding to [4, 10] is 1.
				The range [2, 3] does not contain any of the ranges. Therefore, the output corresponding to [2, 3] is 0.

				For ‘RESULT[ 1 ]’ array:
				Since the range [4, 9] is contained by the range [4, 10], the output corresponding to [4, 9] is 1.
				Since the range [9, 10] is contained by the range [4, 10], the output corresponding to [9, 10] is 1.
				The range [4, 10] is not contained by any of the ranges. Therefore, the output corresponding to [4, 10] is 0.
				The range [2, 3] is not contained by any of the ranges. Therefore, the output corresponding to [2, 3] is 0.
				Sample Input 2 :
				2
				5
				5 8
				8 11
				5 13
				13 14
				3 15
				4
				22 91
				25 40
				66 85
				57 83
				Sample Output 2 :
				0 0 1 0 1
				1 1 1 1 0
				1 0 0 0
				0 1 1 1

			#include <iostream>
			#include <bits/stdc++.h> 
			using namespace std;
			vector<vector<int>> nestedRangesCheck(vector<vector<int>> &ranges, int n){
				vector<vector<int>> ans;
				vector<int> temp;

				int i=0;

				//for first array checking contains or not?
				while(i<n){
					int root1 = ranges[i][0];
					int root2 = ranges[i][1];
					int inner=0;
					bool flag = true;
					while(inner<n){
						if(inner == i){
							inner++;
							continue;
						}
						int check1 = ranges[inner][0];
						int check2 = ranges[inner][1];

						if(root1<= check1 && root2>=check2){
							temp.push_back(1);
							flag = false;
							break;
						}
						inner++;
					}
					if(flag)
						temp.push_back(0);
					i++;
				}
				ans.push_back(temp);
				temp.clear();
				
				//for second array checking contained by any of ranges
				i=0;
				while(i<n){
					int root1 = ranges[i][0];
					int root2 = ranges[i][1];
					bool flag = true;
					int inner = 0;
					while(inner<n){
						if(inner == i){
							inner++;
							continue;
						}
						
						int check1 = ranges[inner][0];
						int check2 = ranges[inner][1];
						
						if(check1<=root1 && check2>=root2){
							temp.push_back(1);
							flag = false;
							break;
						}
						inner++;
					}
					if(flag)
						temp.push_back(0);
					i++;
				}
				ans.push_back(temp);
				return ans;
				}

			int main(){
				vector<vector<int>> ans;
				// int n=4;
				// vector<vector<int>> temp = {{4,9},{9,10},{4,10},{2,3}};
				int n=3;
				vector<vector<int>> temp = {{3,8},{1,3},{7,8}};
				ans = nestedRangesCheck(temp, n);
				
				for(int i=0;i<2;i++){
					for(int j=0;j<n;j++)
						cout<<ans[i][j]<<" ";
					cout<<"\n";
				}
				return 0;	
			}

	55) Count unsorted columns
		You are given an array ‘STRINGS’ having
				‘N’ number of strings. The strings are
				assumed to be arranged such that there
				is one string in one line.
				You need to return the number of columns
				that are not sorted lexicographically.
				Note:
				The length of all the string in the array is the same
		Sample Input 1:
			2
			3
			bccde
			dehrt
			gabzy
			2
			wr
			yz
			Sample Output 1:
			2
			0
			Explanation Of Sample Input 1:
			Test Case 1: In the given strings -
			Column 0 - b, d, g is sorted
			Column 1 - c, e, a is not sorted
			Column 2 - c, h, b is not sorted
			Column 3 - d, r, z is sorted
			Column 4 - e, t, y is sorted.

			Column 1, column 2 is not sorted, so the required answer is ‘2’.

			Test Case 2: Both the columns (‘w’, ‘y’) and (‘r’, ‘z’ ) are sorted. So the answer is ‘0’.
			Sample Input 2:
			2
			4
			u
			e 
			y 
			b
			2
			cterub
			aybsgn
			Sample Output 2:
			1
			3
		
		//checks the strings columns wise, are they sorted or not? 
		//length of all string in vector are same
		#include <iostream>
		#include<vector>
		using namespace std;

		int main(){
			int unsortedCnt=0;
			int col=0;
			
			vector<string> strings = {"cterub","aybsgn"};
			while(col<strings[0].size()){
				for(int i=0; i< strings.size()-1; i++){
					string word1 = strings[i];
					string word2 = strings[i+1];
					
					if(word1[col]>word2[col]){
						unsortedCnt++;
						break;
					}
				}
				col++;
			}
			
			cout<<unsortedCnt;
			return 0;
		}

	56) Wave Array:
		Example 1:
			Input:
			n = 5
			arr[] = {1,2,3,4,5}
			Output: 2 1 4 3 5
			Explanation: Array elements after 
			sorting it in wave form are 
			2 1 4 3 5.

		Example 2:
			Input:
			n = 6
			arr[] = {2,4,7,8,9,10}
			Output: 4 2 8 7 10 9
			Explanation: Array elements after 
			sorting it in wave form are 
			4 2 8 7 10 9.
		Your Task:
			The task is to complete the function convertToWave(), which converts the given array to a wave array.

		Expected Time Complexity: O(n).
		Expected Auxiliary Space: O(1).

		Constraints:
			1 ≤ n ≤ 106
			0 ≤ arr[i] ≤107
		#include <iostream>
		#include<vector>
		using namespace std;

		void toWaveForm(vector<int> a){
			cout<<"Wave form array:\t";
			for(int i=0;i<a.size()-1; i +=2)
				swap(a[i],a[i+1]);
			
			for(int i:a)
				cout<<i<<"\t";
				
			cout<<"\n";
		}

		void normalArray(vector<int> a){
			std::cout << "Normal array :\t\t";
			for(int i: a)
				cout<<i<<"\t";
			cout<<"\n";    
		}

		int main(){
			vector<int> a = {1,2,3,4,5,6,7,8,9,10};
			normalArray(a);
			
			toWaveForm(a);
			
			vector<int> b = {22,33,44,5,66,77,88,99,12,90,89};
			normalArray(b);
			
			toWaveForm(b);
			
			return 0;
		}

	57) Monotonic Array
		An array is monotonic if it is either monotone increasing or monotone decreasing.
			An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. 
			An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
			Given an integer array nums, return true if the given array is monotonic, or false otherwise.
			
			Example 1:
				Input: nums = [1,2,2,3]
				Output: true

			Example 2:
				Input: nums = [6,5,4,4]
				Output: true
			Example 3:
				Input: nums = [1,3,2]
				Output: false
			Constraints:
				1 <= nums.length <= 105
				-105 <= nums[i] <= 105
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {
				int i=0, n=1;
				back:
				if( (i+n)<nums.size() && nums[i] <= nums[i+n]){
					if(nums[i] == nums[i+n]){
						n++;
						goto back;
					}
					for(int j=i+1; j<nums.size()-1; j++)
						if(nums[j] > nums[j+1])
							return 0;
				}else{
					for(int j=i+1; j<nums.size()-1; j++)
						if(nums[j] < nums[j+1])
							return 0;
				}
				return 1;
			}
		};

		//or
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {
				bool increasing = true;
				bool decreasing = true;

				for (int i = 1; i < nums.size(); ++i) {
					if (nums[i] > nums[i - 1]) {
						decreasing = false;
					}
					if (nums[i] < nums[i - 1]) {
						increasing = false;
					}
				}
				return increasing || decreasing;
			}
		};

		//or
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {

				if(nums.size()==1)
					return 1;
				
				bool increORdecre= false;
				int i=0;
				while(i<nums.size()-1){
					if(nums[i]<= nums[i+1]){
						increORdecre = true;
					}
					else{
						increORdecre = false;
						break;
					}
					i++;
				}
				
				if(increORdecre)
					return 1;

				i=0;
				while(i<nums.size()-1){
					if(nums[i]>=nums[i+1]){
						increORdecre = true;
					}else{
						increORdecre = false;
						break;
					}
					i++;
				}
				return increORdecre;
			}
		};

	58) Mirror String :
		-The String which contains the letter A,H,I,M,O,T,U,V,W,X,Y etc are the same looks in mirror.
		-& check for string is palindrome or not,
		Sample Input 1:
			1
			ITATI
			Sample Output 1:
			YES
			Explanation Of Sample Input 1:
			String “ITATI” is the same as its reflection in the mirror.
			Sample Input 2:
			2
			MMMM
			MZM
			Sample Output 2:
			YES
			NO

		#include <bits/stdc++.h> 
		bool isPalindrome(string &s){
			for(int i=0;i<s.length()/2;i++)
				if(s[i] != s[s.length()-i-1])
					return 0;
			return 1;
		}

		bool isReflectionEqual(string &s){
			for(int i=0; i<s.length(); i++){
				if(s[i] == 'A' || s[i] == 'H' || s[i] == 'I' ||
					s[i] == 'M' || s[i] == 'O' || s[i] == 'T' ||
					s[i] == 'U' || s[i] == 'V' || s[i] == 'W' || 
					s[i] == 'X' || s[i] == 'Y'){
						continue;
					}
				else{
					return false;
				}
			}

			bool check = isPalindrome(s);
			return check;
		}

	59) Detect Odd:
		You are given an array of ‘N’ nonnegative integers where all elements
			appear an even number of times except
			two, print the two odd occurring
			elements in increasing order. It may be
			assumed that the size of the array is atleast two and there will always be
			exactly two numbers which appear an
			odd number of times in the given array.
			EXAMPLE:
			Input: 'N' = 6, 'NUMS' = [1,
			1, 2, 3, 4, 4]
			Output: 2 3
			Here in the given array we can
			see that 2 and 3 occur 1 time
			which is an odd number. Hence,
			the output will be 2 and 3.
		Sample Input 1 :
			2
			6
			1 1 2 3 4 4
			2
			1 2
			Sample Output 1 :
			2 3
			1 2
			Explanation Of Sample Input 1 :
			For the first test case,
			'N' = 6 and 'NUMS' = [1, 1, 2, 3, 4, 4]
			Here in the given array we can see that 2 and 3 occur 1 time which is an odd  number. Hence, the output will be 2 and 3.

			For the second test case,
			'N' = 2 and 'NUMS' = [1, 2]
			Here in the given array we can see that 1 and 2 occur 1 time which is an odd  number. Hence, the output will be 1 and 2.
		Sample Input 2 :
			2
			4
			8 2 2 7
			4
			3 1 3 5
			Sample Output 2 :
			7 8   
			1 5
		
		//not Optimized:
			#include <bits/stdc++.h> 
			vector <int> detectOdd(int n, vector <int> nums) {
				if(nums.size()==2)
					return nums;
				
				vector<int> ans;
				for(int i=0;i<nums.size(); i++){
					int cnt=1,j;
					if(nums[i] == INT_MIN){
						continue;
					}
					
					for(j=0; j<nums.size(); j++){
						if(i==j || nums[j] == INT_MIN)
							continue;
						else if(nums[i] == nums[j]){
							nums[i] = INT_MIN;
							nums[j] = INT_MIN;
							cnt++;
							break;
						}
					}
					if(cnt==1)
						ans.push_back(nums[i]);
				}

				sort(ans.begin(), ans.end());
				return ans;
			}
		
		//Optimized:
			#include <bits/stdc++.h> 
			vector <int> detectOdd(int n, vector < int > nums) {
				if(nums.size()==2)
					return nums;
				
				vector<int> ans;
				unordered_set<int> doublChecker;

				for(int i=0; i<nums.size(); i++){
					if(doublChecker.count(nums[i]) == 0)
						doublChecker.insert(nums[i]);
					else
						doublChecker.erase(nums[i]);
				}

				ans.assign(doublChecker.begin(), doublChecker.end());				//assigning unordered_set to vector
				sort(ans.begin(), ans.end());
				return ans;
			}
		
	60) Ninja and Range Max
		Sample Input 1:
			2
			6 0 3
			3 2 2 4 5 2
			6 4 4
			2 4 6 8 9 10
			Sample Output 1:
			4
			9
			Explanation Of Sample Input 1:
			For test case 1:
			The maximum element in the range [0, 3] is 4.
			Hence, the answer for this case is 4.

			For test case 2:
			The maximum element in the range [4, 4] is 9.
			Hence, the answer for this case is 9.
			Sample Input 2:
			2
			5 2 3
			6 6 8 5 1
			5 3 4
			2 4 5 3 1
			Sample Output 2:
			8
			3

		int ninjaAndRangeMax(int n, int x, int y, vector<int> &a) {
			int maxer = a[x];
			for(int i=x+1; i<=y; i++)
				maxer = max(maxer, a[i]);
			return maxer;
		}

		//more optimized:
			int ninjaAndRangeMax(int n, int x, int y, vector<int> &a) {
				auto max_iter = std::max_element(a.begin() + x, a.begin() + y + 1);
				return *max_iter;
			}

	61) 132 Pattern:
		Given an array of n integers nums, a 132 pattern is a subsequence of three 
		integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
		Return true if there is a 132 pattern in nums, otherwise, return false.
			Example 1:
				Input: nums = [1,2,3,4]
				Output: false
				Explanation: There is no 132 pattern in the sequence.
			Example 2:
				Input: nums = [3,1,4,2]
				Output: true
				Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
			Example 3:
				Input: nums = [-1,3,2,0]
				Output: true
				Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
			Constraints:
				n == nums.length
				1 <= n <= 2 * 105
				-109 <= nums[i] <= 109
		//Not Optimized:
			class Solution {
				public:
				bool find132pattern(vector<int>& nums) {
					if(nums.size() < 3)
						return 0;

					//checking that more than 3 different nums present in vector or not?
					set<int> checking;
					for(int i: nums)
						checking.insert(i);
					
					if(checking.size()<3)
						return 0;

					//reducing 2 coz its subarray of 3 elements.
					int iRange = nums.size()-2;
					int jRange = nums.size()-1;

					for(int i=0; i< iRange; i++){
						for(int j=i+1; j< jRange; j++){
							for(int k=j+1; k<nums.size(); k++){
								if((nums[i] < nums[k])  && (nums[k] < nums[j]))
									return 1;
							}                
						}
					}
					return 0;  
				}
			};
		
		//optimized:
			class Solution {
				public:
				bool find132pattern(vector<int>& nums) {
					int n = nums.size();
					if (n < 3) {
						return false;
					}

					vector<int> minSoFar(n);
					minSoFar[0] = nums[0];

					// Calculate the minimum element so far for each index
					for (int i = 1; i < n; i++) {
						minSoFar[i] = min(minSoFar[i - 1], nums[i]);
					}

					stack<int> s;

					for (int j = n - 1; j >= 0; j--) {
						// If nums[j] is greater than the minimum element so far, we have a candidate for 'k'
						if (nums[j] > minSoFar[j]) {
							// Find the maximum 'i' that is less than nums[j]
							while (!s.empty() && s.top() <= minSoFar[j]) {
								s.pop();
							}

							// If we found a valid 'i', return true
							if (!s.empty() && s.top() < nums[j]) {
								return true;
							}
							// Push nums[j] onto the stack as a potential 'k'
							s.push(nums[j]);
						}
					}
					return false; 
				}
			};

	62) Maximum Value of F(x) - VI:
		problem Statement
			You are provided with a sorted array of integers
			‘ARR’ having length ‘N’ and a function ‘F(X)’, such
			that:
			F(X) = S + G
			Where:
			‘X’ = Any integer that belongs to array
			‘ARR’.
			‘S’ = Number of integers in ‘ARR’ that
			are strictly smaller than ‘X’.
			‘G’ = Number of integers in ‘ARR’ that
			are strictly greater than ‘X’.
			For Example:
			‘ARR’ = {1, 1, 1, 2, 2, 3, 4}
			Let, ‘X’ = 1
			F(X) = 0 + 4 = 4 (as ‘0’ numbers of
			elements are smaller than ‘1’ and ‘4’
			elements that are ‘2’, ‘2’, ‘3’, and ‘4’
			are greater than ‘1’.
			Let ‘X’ = 2
			F(X) = 3 + 2 = 5 (as ‘3’ numbers
			(‘1’, ‘1’, and ‘1’) are smaller than ‘2’
			and ‘2’ numbers that are ‘3’, and ‘4’ are
			greater than ‘2’.
			Let ‘X’ = 3
			F(X) = 5 + 1 = 6 (as ‘5’ numbers
			(three times ‘1’ and two times ‘2’) are
			smaller than ‘3’ and ‘1’ number that is
			‘4’ is greater than ‘3’.
			Let ‘X’ = 4
			F(X) = 6 + 0 = 6 (as ‘6’ numbers
			(three times ‘1’, two times ‘2’, and one
			time ‘3’) are smaller than ‘4’ and ‘0’
			numbers are greater than ‘3’.
			All you have to do is to find the maximum value of
			‘F(X)’.

		Sample Input 1 :
			1
			7
			1 1 1 2 2 3 4
			Sample Output 1 :
			6
			Explanation For Sample Input 1 :
			For the first test case, an explanation is given in the description.
			Sample Input 2 :
			2
			5
			10 20 30 40 40
			2
			3 4
			Sample Output 2 :
			4
			1
		//not optimized:
			#include <bits/stdc++.h> 
			int maxFXVI(int n, vector<int> &arr){
				vector<int> maxer;
				for(int i=0;i<n; i++){
					int cnt=0;
					for(int j=0; j<n; j++){
						if(i==j)
							continue;
						if(arr[i] != arr[j])
							cnt++;
					}
					maxer.push_back(cnt);
				}
				auto mxValue = max_element(maxer.begin(), maxer.end());
				return *mxValue;
			}

	63) Find the length of last word:
		https://leetcode.com/problems/length-of-last-word/
		#include <iostream>
		#include<algorithm>
		using namespace std;
		int main(){
			// string s = "Vivek Mahesh Nikate";
			string s = "Hello world";
			string Lword;
			
			for(int i=s.length()-1; i>=0;i--){
				if(s[i] != ' ')
					Lword += s[i];
				else
					break;

				//or you can use this also instead of above if checking condition
					//if(isblank(s[i]))
					//	break;
					//Lword += s[i];
			}
			reverse(Lword.begin(), Lword.end());
			std::cout << Lword<<" & the length of its is :: "<< Lword.length() << std::endl;
			return 0;
		}

		//ignoring the trailing spaces also,
		class Solution {
			public:
			int lengthOfLastWord(string s) {
				int i=s.length()-1;
				while(i>=0){
					if(isblank(s[i]))
						s.erase(i,1);
					else 
						break;
					i--;
				}
					
				i = s.size()-1;
				string temp;
				while(i>=0){
					if(isblank(s[i]))
						break;
					temp += s[i];
					i--;
				}
				return temp.length();
			}
		};
		
		//or 0ms second
			class Solution {
				public:
				int lengthOfLastWord(string s) {
					int count=0;
					for(int i=s.length()-1; i>=0; i--){
						while(int(s[i])==32){
							i--;
						}
						while(int(s[i])!=32){
							count++;
							i--;
							if(i<0){
								break;
							}
						}
						break;
					}
					return count;
				}
			};

	64) Column name from a given column number:
		Problem Statement:
			Given a positive integer, return its corresponding column title as appear in an Excel sheet.
			Excel columns has a pattern like A, B, C, … ,Z, AA, AB, AC,…. ,AZ, BA, BB, … ZZ, AAA, AAB ….. etc. In other words, column 1 is named as “A”, column 2 as “B”, column 27 as “AA” and so on.
			Example 1:
				Input:
				N = 28
				Output: 
				AB
				Explanation: 1 to 26 are A to Z.
				Then, 27 is AA and 28 = AB.

			Example 2:
				Input: 
				N = 13
				Output: 
				M
				Explanation: M is the 13th character of
				alphabet.

			Example 3:
				Input:
				N = 5473578
				Output: 
				KYJZF

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function colName() which takes the column number N as input and returns the column name represented as a string.
			Expected Time Complexity: O(LogN).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <= 10^18
		
		class Solution{
			public:
			string colName (long long int n){
				
				string s;
			
				while (n > 0) {
					int GenNum = (n-1) % 26;  // Subtract 1 to get the correct column name
					char ch = 'A';
			
					for (int i =0; i < GenNum; i++) {
						ch++;
					}
					s += ch;
					n = (n-1) / 26;  // Subtract 1 here as well
				}
				reverse(s.begin(), s.end());
				return s;
			}
		};

		// or
			class Solution{
				public:
				string colName (long long int n) {
					string res;
					
					while(n){
						int inc = (n-1) % 26;
						char crntCh = 'A' + inc;
						
						res += crntCh;
						n = (n-1) / 26;
					}
					
					// reverse the string
					int i=0, j=res.size()-1;
					while(i < j)
						swap(res[i++], res[j--]);
					return res;
				}
			};

	65) Roman Number to Integer:
		Given a string in roman no format (s)  your task is to convert it to an integer . 
		Various symbols and their values are given below.
			I 1
			V 5
			X 10
			L 50
			C 100
			D 500
			M 1000

			Example 1:
			Input:
				s = V
				Output: 5
			Example 2:
				Input:
				s = III 
				Output: 3
			Your Task:
				Complete the function romanToDecimal() which takes a string as input parameter and returns the 
				equivalent decimal number. 

			Expected Time Complexity: O(|S|), |S| = length of string S.
			Expected Auxiliary Space: O(1)

			Constraints:
				1<=roman no range<=3999
			class Solution {
				public:
				int romanToDecimal(string &str) {
					int i=str.length()-1;
					int num=0;

					while (i >= 0) {
						char val = str[i];
						int temp, prev = 0;
				
						if (val == 'I') {
							temp = 1;
						} else if (val == 'V') {
							temp = 5;
						} else if (val == 'X') {
							temp = 10;
						} else if (val == 'L') {
							temp = 50;
						} else if (val == 'C') {
							temp = 100;
						} else if (val == 'D') {
							temp = 500;
						} else if (val == 'M') {
							temp = 1000;
						}
				
						if (i > 0) {
							char prevVal = str[i - 1];
							if (prevVal == 'I') {
								prev = 1;
							} else if (prevVal == 'V') {
								prev = 5;
							} else if (prevVal == 'X') {
								prev = 10;
							} else if (prevVal == 'L') {
								prev = 50;
							} else if (prevVal == 'C') {
								prev = 100;
							} else if (prevVal == 'D') {
								prev = 500;
							} else if (prevVal == 'M') {
								prev = 1000;
							}
						}
				
						if (prev > 0 && prev < temp) {
							temp -= prev;
							i--; // Skip the previous character
						}
				
						num += temp;
						i--;
					}
					return num;
				}
			};

			//or
				int mapRomanToDecimal(char ch){
					if(ch == 'I'){
						return 1;
					}else if(ch == 'V'){
						return 5;
					}else if(ch == 'X'){
						return 10;
					}else if(ch == 'L'){
						return 50;
					}else if(ch == 'C'){
						return 100;
					}else if(ch == 'D'){
						return 500;
					}else if(ch == 'M'){
						return 1000;
					}
				}

				int romanToInt(string s) {
					int i=s.length()-1;
					int num = 0;
					while(i>=0){
						char curVal = s[i];
						int temp = mapRomanToDecimal(curVal);
						int prev=0;

						if(i>0){
							char prevVal = s[i-1];
							prev = mapRomanToDecimal(prevVal);
						}

						if(prev< temp){
							temp -= prev;
							i--;
						}

						num += temp;
						i--;

					}
					return num;
				}

			// or using Swith case:
				class Solution {
					public:
					int valueFinder(char ch){
						switch(ch){
							case 'I':
								return 1;
							case 'V':
								return 5;
							case 'X':
								return 10;
							case 'L':
								return 50;
							case 'C':
								return 100;
							case 'D':
								return 500;
							case 'M':
								return 1000;
						}
					}
					int romanToDecimal(string &str) {
						int ans = valueFinder(str[str.size()-1]);
						int prev = ans;
						// pointing the last 2nd character
						int i = str.size() - 2;
						
						while(i >=0){
							int value = valueFinder(str[i]);
							if(value >= prev)
								ans += value;
							else
								ans -= value;
							
							prev = value;
							i--;
						}
						return ans;
					}
				};

	66) Modular Exponentiation :
		You are given a three integers 'X','N', and 'M'. Your task is to find ('X'^ 'N') % 'M'. A ^ B is defined 
		as X raised to power N and X % M is the remainder when X is divided by M.

			Constraints :
			1 <= T <= 100
			1 <= X, N, M <= 10^9
			Time limit: 1 sec
		Sample Input 1 :
			2 
			3 1 2
			4 3 10
			Sample Output 1 :
			1
			4
			Explanation For Sample Output 1:
			In test case 1, 
			X = 3, N = 1, and M = 2 
			X ^ N = 3 ^ 1 = 3 
			X ^ N % M = 3 % 2 = 1. 
			So the answer will be 1.

			In test case 2,
			X = 4, N = 3, and M = 10 
			X ^ N = 4 ^ 3 = 64 
			X ^ N % M = 64 % 10 = 4. 
			So the answer will be 4.
			Sample Input 2 :
			2
			5 2 10 
			2 5 4
		Sample Output 2 :
			5
			0
			Explanation For Sample Output 2:
			In test case 1, 
			X = 5, N = 2, and M = 10 
			X^N = 5^2 = 25 
			X^N %M = 25 % 10 = 5. 
			So the answer will be 5.

			In test case 2,
			X = 2, N = 5, and M = 4 
			X^N = 2^5 = 32 
			X^N %M = 32 % 4 = 0. 
			So the answer will be 0.

			//NOT Optimized:
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;
					
					for(int i=0; i<n; i++){
						power = (power * x) % m;
					}
					return power;
				}
			
			//Optimized:
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;

					if(n==0)
						return power;

					long long base = x % m;
					while(n>0){
						if(n&1)
							power = (power * base) %m;
						base = (base*base)%m;
						n/=2;
					}
					return (int)((power+m)%m);
				}
			
			//or
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;
					long long base = x;
					if(n==0)
						return power;
					int i=1;
					while(n > 0){
						if(n&1)
							power = (power % m * base % m) % m;

						base = (base * base) % m ;
						n /= 2;
					}
					return power;
				}

	67) Largest Element in the Array
		Given an array ‘arr’ of size ‘n’ find the largest element in the array.
		Example:
		Input: 'n' = 5, 'arr' = [1, 2,3, 4, 5]
		Output: 5
		Explanation: From the array {1,2, 3, 4, 5}, the largest element is 5.

		Sample Input 1:
			6
			4 7 8 6 7 6 
			Sample Output 1:
			8
			Explanation Of Sample Input 1: The answer is 8. From {4 7 8 6 7 6}, 8 is the largest element.
		Sample Input 2:
			8
			5 9 3 4 8 4 3 10 
			Sample Output 2:
			10
			Expected Time Complexity:
			O(n), Where ‘n’ is the size of an input array ‘arr’.
			Constraints :
			1 <= 'n' <= 10^5
			1 <= 'arr[i]' <= 10^9

			Time Limit: 1 sec

		#include <bits/stdc++.h> 
		int largestElement(vector<int> &arr, int n) {
			// auto mxr = max_element(arr.begin(), arr.end());
			// return *mxr;
			int mx = arr[0];
			for(int i=1;i<n;i++)
				mx = max(mx,arr[i]);
			return mx;
		}

	68) Sum Of Even Numbers Till N:
		Sample Input 1 :
			2
			6
			2
			Sample Output 1 :
			12
			2
			Explanation For Sample Input 1 :
			For test case 1 :
			Sum of all even numbers till 6 will be : 2 + 4 + 6 = 12

			For test case 2 :
			Sum of all even numbers till 2 will be : 2
			Sample Input 2 :
			2
			4
			5
			Sample Output 2 :
			6
			6
			Explanation For Sample Input 2 :
			For test case 1 :
			Sum of all even numbers till 4 will be : 2 + 4 = 6

			For test case 2 :
			Sum of all even numbers till 5 will be : 2 + 4 = 6

		#include <bits/stdc++.h> 
		long long evenSumTillN(int n) {
			long long sum =0;
			for(int i=2; i<=n; i+=2)
				sum += i;
			return sum;
		}

	69) Find Character Case
		You are given a character ‘CH’ as input, return either 1,
		0 or -1 according to the following rules:
		1, if the character is an uppercase alphabet (A - Z).
		0, if the character is a lowercase alphabet (a - z).
		-1, if the character is not an alphabet.
		For Example :
			If ‘CH’ = ‘a’, then since it is a
			lowercase letter, your program should return 0
		Sample Input 1:
			2
			A
			t
			Sample Output 1:
			1
			0
			Explanation For Sample Input 1:
			For sample case 1, ‘A’ is an uppercase letter, hence output is 1.
			For sample case 2, ‘t’ is a lowercase letter, hence output is 0.
			Sample Input 2:
			2
			#
			P
			Sample Output 2:
			-1
			1
			Explanation For Sample Input 2:
			For sample case 1, ‘#’ is not an alphabet, hence output is -1.
			For sample case 2, ‘P’ is an uppercase letter, hence output is 1.

		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(islower(ch))
				return 0;
			else if(isupper(ch))
				return 1;
			else
				return -1;
		}

		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(!isalpha(ch))
				return -1;
			else if(isupper(ch))
				return 1;
			return 0;
		}

	70) Two Repeated Elements:
		You are given an array of N+2 integer elements. 
			All elements of the array are in the range 1 to N. 
			Also, all elements occur once except two numbers which occur twice. 
			Find the two repeating numbers.

			Note: Return the numbers in their order of appearing twice. 
			So, if X and Y are the repeating numbers, and X repeats twice before Y 
			repeating twice, then the order should be (X, Y).

			Example 1:
				Input:
				N = 4
				array[] = {1,2,1,3,4,3}
				Output: 1 3
				Explanation: In the given array, 
				1 and 3 are repeated two times.
				
			Example 2:
				Input:
				N = 2
				array[] = {1,2,2,1}
				Output: 2 1
				Explanation: In the given array,
				1 and 2 are repeated two times 
				and second occurence of 2 comes 
				before 1. So the output is 2 1.

			Your Task:
				The task is to complete the function repeatedElements() which takes array arr[] and 
				an integer N as inputs (the size of the array is N + 2 and elements are in the range[1, N]) 
				and finds the two repeated element in the array and return them in a list.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1). 

			Constraints:
				2 ≤ N ≤ 105
				1 ≤ array[i] ≤ N

		class Solution {
			public:
			//Function to find two repeated elements.
			vector<int> twoRepeated (int arr[], int n) {
				
				vector<int> ans;
				vector<int> counts(n+2, 0);
				
				for(int i=0; i<n+2; i++){
					counts[arr[i]]++;
					if(counts[arr[i]] == 2)
						ans.push_back(arr[i]);
					
					if(ans.size()==2)
						break;
				}
				return ans;
			}
		};

		// or 
			class Solution {
				public:
				//Function to find two repeated elements.
				vector<int> twoRepeated (int arr[], int n) {
					vector<int> ans;
					
					map<int, int> F;
					for(int i=0; i<n+2; i++){
						F[arr[i]]++;
						if(F[arr[i]] == 2)
							ans.push_back(arr[i]);
						
						if(ans.size()==2)
							break;
					}
					return ans;
				}
			};

	71) String Mania
		Rohit love strings. But he has many strings with him,
			and he is confused about which one he loves more. So
			he decided to come up with a scoring system for the
			strings. The scoring system took two strings as input,
			let's call them ‘STR1’ and ‘STR2’ of length ‘N’ and
			length ‘M’ respectively.
			The system will return ‘1’ if ‘STR1’ is better than ‘STR2’.
			The system will return ‘0’ if ‘STR1’ is the same as ‘STR2’.
			The system will return ‘-1’ if ‘STR2’ is better than ‘STR1’.
			To decide which string is better he followed the below steps.
			Let’s suppose there exists a index ‘i’ such that ‘0’ <= ‘i’ < ‘min(N,M)’ and for all ‘j<i’, ‘STR1[j]’ is equal to
			‘STR2[j]’, and ‘STR1[i] != STR2[i]’.
			Then if ‘STR1[i]>STR2[i]’, ‘STR1’ is better otherwise if
			‘STR2[i]>STR1[i]’, ‘STR2’ is better,
			And if there doesn’t exist any such ‘i’ then if ‘N>M’,
			‘STR1’ is better,
			And if ‘N<M’, ‘STR2’ is better, and if ‘N’ is equal to ‘M’,
			both strings are the same.
			But Rohit has so many strings, so he doesn’t have time
			to go through all strings, So being his friend can you
			help him automate this process?.

		Sample Input 1 :
			2
			1 3
			a
			abc
			3 3
			abz
			abc
		Sample Output 1 :
			-1
			1
		Explanation Of Sample Input 1 :
			For the first test case, ‘STR2’ is better than ‘STR1’, 
			as they are the same until the ‘0th’ index and then string ‘STR1’ ends and 
			as explained in the statement for ‘M>N’, the answer is ‘-1’.

			Hence, the output will be: -1

		For the second test case, ‘STR1’ is better than ‘STR2’, as they are the same until 
		the ‘1st’ index and then ‘STR1[2]>STR2[2]’.

		Hence, the output will be: 1
			Sample Input 2 :
				3
				2 3
				ez
				ehz
				5 5
				acefi
				acefi
				3 5
				ags
				agtaa
			Sample Output 2 :
				1
				0
				-1
		#include <bits/stdc++.h> 
		int stringMania(int n, int m, string str1, string str2) {
			if(str1 == str2)
				return 0;
			int i=0;
			while(i<n && i<m){
				if(str1[i] == str2[i]){
					i++;
					continue;
				}else if(str1[i] > str2[i]){
					return 1;
				}else{
					return -1;
				}
				i++;
			}
			return -1;
		}

		// or
			#include <bits/stdc++.h> 
			int stringMania(int n, int m, string str1, string str2) {
				if(str1 == str2)
					return 0;
				
				int minLen = min(n,m);
				for(int i=0; i<minLen; i++)
					if(str1[i] == str2[i])
						continue;
					else if(str1[i] > str2[i])
						return 1;
					else
						return -1;
				
				return (str1.length() > str2.length()) ? 1 : -1;
			}
		
		#include <bits/stdc++.h> 
		int stringMania(int n, int m, string str1, string str2) {
			return str1<str2?-1:str1!=str2;     
		}

		// or
			#include <bits/stdc++.h> 
			int stringMania(int n, int m, string str1, string str2) {
				if(s1 == s2) return 0;

				for(int i=0; i<min(n, m); i++){
					if(str1[i] > str2[i] )
						return 1;
					else if (str1[i] < str2[i])
						return -1;
					else
						continue;
				}
				if(n > m)
					return 1;
				else if(m > n)
					return -1;
				else
					return 0;
			}

	72) Count Of 3s:
		You are given an integer ‘N’. You simply need to find out the number of occurrences of 3 as a digit in the
			range of numbers from [0, N]. 
			Note: You need to count occurrences at every place of the number.
			For Example :
				You are given N = 13, then the number of occurrences 
				of 3 in range [0, 13] = 2 (3,13), you need to return 2.
			Sample Input 1:
				2
				13
				24
			Sample Output 1:
				2
				3
			Explanation For Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [0, 13] = 2 (3, 13). Return 2

			In the second test case, 
			Number of occurrences of 3 in range [0, 24] = 3 (3, 13, 23). Return 3
			Sample Input 2:
				2
				10
				33
			Sample Output 2:
				1
				8
			Explanation For Sample Input 2:
			In the first test case, 
			Number of occurrences of 3 in range [0, 10] = 1 (3). Return 1

			In the second test case, 
			Number of occurrences of 3 in range [0, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int countOf3(int x) {
			long long int cnt=0;
			for(int i=3; i<=x; i++){
				int curNum = i;
				while(curNum>0){
					int lastDigit = curNum%10;
					if(lastDigit == 3)
						cnt++;
					curNum/=10;
				}
			}
			return cnt;
		}

	73) Valid String:
		There is a town named Chefland where Chef lives.
			One can only enter the Chefland through visa which is
			granted by head Chef of the town named Chef
			Sanjeev Kapoor. Chef Sanjeev is very interested in the
			validation of string.
			Hence he devised a test to get into the Chefland. Chef
			Sanjeev Kapoor considers a string to be valid if all
			characters of the string appear the same number of
			times. It is also valid if he can remove just 1 character
			at 1 index in the string, and the remaining characters
			will occur the same number of times. Given a string S,
			determine if it is valid. If so, return YES, otherwise
			return NO.
			For example, if S="abc", it is a valid string because
			frequencies are {a:1, b:1,c:1}. So is S="abcc" because
			we can remove one c and have 1 of each character in
			the remaining string. If S="abccc" however, the string
			is not valid as we can only remove 1 occurrence of c.
			That would leave character frequencies of {a:1, b:1,c:2}.
		
			Input Format:
				A single string S.
			Constraints:
				1 ≤ |S| ≤ 100000
				Each character s[i] belongs to [a-z]
			Time limit = 1 sec
			Output Format:
				Print YES if string S is valid, otherwise, print NO.
			
			Sample Input 1:
				aabbcd
			Sample Output 1:
				NO
			Sample Input 2:
				abcdefghhgfedecba
			Sample Output 2:
				YES
				Explanation:
				For testcase 2:
				All characters occur twice except for e which occurs 3 times. We can delete one instance of e to have a valid string.

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			string s;
			cin>>s;
			int charCountArr[26] = {0};
			
			//counting the characters..
			for(int i=0; i<s.length(); i++){
				charCountArr[s[i]-'a']++;
			}

			//checking count
			int cnt=0;
			int num = charCountArr[0];

			for(int i=1; i<26; i++){
				if(charCountArr[i] == num || charCountArr[i] == 0){
					continue;
				}else{
					cnt++;
				}
			}

			if(cnt<=1 || s.length()==1)
				cout<<"YES";
			else
				cout<<"NO";
			return 0;
		}

	74) Find the correct password:
		Mike is an evil plotting genius and has gotten hold of a
			list of all possible passwords for a certain user
			account. The first thing he noticed was all the
			passwords are of odd length. Mike assumes that the
			correct password is the one which can be found in
			both the original and reverse order in the list. For
			example, if the word “tulipan” would be the correct
			password, the word “napilut” has to also appear in the
			list. Given that both words are correct passwords,
			Mike will try to use both, one at a time.
			Help Mike discover what the correct password is and
			output its length and central character.
			Input Format:
				The first line of input contains the integer N, the number of possible
				passwords. Each of the following N lines contains a single word S, its length being an odd
				number. All characters are lowercase letters of the English alphabet.
			Constraints:
				1 ≤ N ≤ 100
				2 < S < 14
				Time limit = 1 sec
			Output Format:
				The first and only line of output must contain the length of the correct password
				and its central letter. The solution will be unique.
			
			Sample Input 1:
				4
				las
				god
				psala
				sal 
			Sample Output 1:
				3 a
			Sample Input 2:
				4
				kisik
				ptq
				tttrp
				tulipan 
			Sample Output 2:
				5 s
			Explanation:
				For testcase 1:
				The required pair of words is “las” and “sal”. Their length is 3 letters and the central character is 'a'.

				For testcase 2:
				The word “kisik” can be found in both the original and reverse order on the list (the word is a palindrome), so it is a valid correct password. 

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			int n;
			cin>>n;

			vector<string> s(n);
			for(int i=0; i<n; i++){
				string temp;
				cin>>temp;
				s[i] = temp;
			}
			int len=0,flg=0;
			char midL;
			for(int i=0; i<n; i++){
				string f1 = s[i];
				reverse(f1.begin(), f1.end());

				for(int j=0; j<n; j++){
					if(f1 == s[j]){

						len = f1.length();
						midL = f1[len/2];
						flg = 1;
						break;
					}
				}
				if(flg)
					break;
			}

			cout<<len<<" "<<midL;
			return 0;
		}

	75) Self Dividing Numbers:
		A Ninja wants to collect all possible self-dividing numbers from a given range of numbers.
			A self-dividing number is a number that is divisible by every digit it contains.
			For Example:
				128 is a self-dividing number because
				128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
			Given a ‘LOWER’ and ‘UPPER’ number bound, your
			task is to find all possible self-diving numbers in
			the range of ‘LOWER’ to ‘UPPER’.
			Note:
				A self-dividing number is not allowed to contain the digit zero.
				You do not need to print anything, it has already been taken care of. Just
				implement the given function.
			Sample Input 1:
				2
				10 30
				15 45
				Sample Output 1:
				11 12 15 22 24
				15 22 24 33 36 44
				Explanation For Sample Input 1:
				Test Case 1:

				For the first test case, the output [11, 12, 15, 22, 24] is the required list of self-dividing numbers containing only those numbers that have all the digits that can divide the number and do not contain the digit ‘0’ in it.

				Test Case 2:

				For the first test case, The output [15, 22, 24, 33, 36, 44] is the required list of self-dividing numbers containing only those set of numbers that have all the digits which can divide the number and that do not contain the digit ‘0’ in it.
			Sample Input 2:
				2
				1 22
				100 150
				Sample Output 2:
				1 2 3 4 5 6 7 8 9 11 12 15 22
				111 112 115 122 124 126 128 132 135 144

		#include <bits/stdc++.h> 
		vector < int > findAllSelfDividingNumbers(int lower, int upper) {

			//vector for storing the ans
			vector<int> ans;

			for(int i=lower; i<= upper; i++){
				int currentDigitHolder = i;
				int currentDigit = i;
				while(currentDigit>0){
					int lastDigit = currentDigit % 10;
					if(lastDigit == 0 || (currentDigitHolder % lastDigit != 0))
						break;
					currentDigit /=10;
				}
				if(currentDigit == 0)
					ans.push_back(i);
			}
			return ans;
		}

		// or
			#include <bits/stdc++.h> 
			vector <int> findAllSelfDividingNumbers(int lower, int upper) {
				vector <int> ans;

				for(int i=lower; i <= upper; i++){
					string s = to_string(i);
					if(s.find('0') != string::npos)
						continue;
					
					int flag = 1;

					int z=0;
					while(z < s.size()){
						int val = s[z] - '0';
						if(i % val != 0){
							flag=0;
							break;
						}
						z++;
					}

					if(flag)
						ans.push_back(i);
				}

				return ans;
			}

	76) Rearrange in Zig-Zag Order:
		https://www.codingninjas.com/studio/problems/zig-zag-array_1698577
		-just returned the empty vector (GLITCHED QUESTION).
		#include <bits/stdc++.h> 
		vector<int> zigZag(vector<int> arr, int n){
			vector<int> ans;
			return ans;
		}

	77) Fourth Largest Element in the Array:
		You are given an array consisting of 'N' integers. You have to find the fourth
			largest element present in the array. If there is no such number present in the
			array, then print the minimum value of an integer which is -2147483648.
			Follow Up: 
				Constraints :
				1 <= N < 10^6
				-10^6 <= element <= 10^6
			Time Limit: 1 sec
			Sample Input 1:
				5
				3 5 1 3 1
				Sample Output 1:
				1
				Explanation Of Sample Input 1:
				5 is the largest element, 3 is the second-largest element, again we have a 3 so it's the third largest and 1 is the fourth-largest, hence the answer 1.
				Sample Input 2:
				4
				9 9 9 9
				Sample Output 2:
				9
		//not optimized:
			#include <bits/stdc++.h>
			int getFourthLargest(int arr[], int n){
				if(n<4)
					return -2147483648;

				vector<int> ans(n);

				for(int i=0; i<n;i++){
					ans.push_back(arr[i]);
				}

				sort(ans.begin(), ans.end());
				reverse(ans.begin(), ans.end());
				return ans[3];
			}

	78) Next Smaller Element / Nearest Smaller Element:
		https://www.codingninjas.com/studio/problems/next-smaller-element_1112581

		//NOT Optimized:
			#include <bits/stdc++.h>
			vector<int> nextSmallerElement(vector<int> &arr, int n){
				int i=0;
				vector<int> ans;
				while(i<n){
					int currentNum = arr[i];
					int currentIndex = i+1;

					while(currentIndex < n){
						if(currentNum > arr[currentIndex]){
							ans.push_back(arr[currentIndex]);
							break;
						}
						currentIndex++;
					}
					if(currentIndex == n)
						ans.push_back(-1);
					i++;
				}
				return ans;
			}
		
		// or
			vector<int> nextSmallerElement(vector<int> &arr, int n) {
				vector<int> ans(n, -1);
				for(int i=0; i<n-1; i++){
					for(int j=i+1; j<n; j++){
						if(arr[i] > arr[j]){
							ans[i] = arr[j];
							break;
						}
					}
				}
				return ans;
			}	

		// Optimized:
			#include <bits/stdc++.h>
			vector<int> nextSmallerElement(vector<int> &arr, int n){
				vector<int> ans(n, -1);  // Initialize the result vector with -1.
				stack<int> st;  // Create a stack to keep track of indices.

				for (int i = 0; i < n; i++) {
					while (!st.empty() && arr[i] < arr[st.top()]) {
						ans[st.top()] = arr[i];  // Update the result for elements in the stack.
						st.pop();
					}
					st.push(i);  // Push the current index onto the stack.
				}
				return ans;   
			}

		#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				int n;
				cin>>n;
				vector<int> holder(n);
				
				for(int i=0;i<n;i++){
					cin>>holder[i];
				}
				
				for(int a: holder)
					cout<<a<<" ";
					
				std::cout << std::endl;
				
				vector<int> MainAns(n);
				
				for(int i=n-1;i>=0;i--){
					int currentElement = holder[i];
					int index = i-1;
					
					while(index>=0){
						if(currentElement > holder[index]){
							MainAns.push_back(holder[index]);
							break;
						}
						index--;
					}
					if(index<0)
						MainAns.push_back(-1);
				}
				
				std::cout << std::endl;
				reverse(MainAns.begin(), MainAns.end());
				for(int i=0; i<n; i++)
					cout<<MainAns[i]<<" ";
				
				return 0;
			}
			output:
			5
			11
			4
			24
			32
			32
			11 4 24 32 32 

			-1 -1 4 24 24 

	79) Added Character:
		You are given a string 'S'. Now one more additional character is introduced in this string, which turns 'S'
			into new string 'T'. You have to find out this newly added character.
			Note:
			1. All the characters in string 'S' and 'T' consist of uppercase English
			alphabets.
			2. Length of string 'T' is always 1 more than the length of string 'S'.
			Constraints:
				1 <= TEST <= 100
				1 <= |S|, |T| <= 10^4
				Where '|S|' and '|T|' denotes the length
				of he strings 'S' and 'T' respectively.
			Time Limit: 1 sec.

			Sample Input 1:
				2
				APPLE 
				APPHLE
				CODE
				CODER
				Sample Output 1:
				H
				R
				Explanation For Sample Output 1:
				In test case 1, As only character which is present in “APPHLE” but didn’t present in “APPLE” is ‘H’.

				In test case 2, As only character which is present in “CODER” but didn’t present in “CODE" is ‘R’.
				Sample Input 2:
				2
				MANGO 
				MANNGO
				NINJA
				NIINJA
				Sample Output 2:
				N
				I
				Explanation For Sample Output 2:
				In test case 1, As “MANGO” contains only 1 occurrence of ‘N’ but “MANNGO” contains 2 occurrences of ‘N’.

				In test case 2, As “NINJA” contains only 1 occurrence of ‘I’ but “NIINJA" contains 2 occurrences of ‘I’.

		#include <bits/stdc++.h> 
		char findAddedCharacter(string &s, string &t) {
			int i=0;
			while(i<s.length()){
				if(s[i] != t[i])
					return t[i];
				i++;
			}
			if(i==s.length())
				return t[t.length()-1];
		}
	
	80) Three Pointer:
		You are given three arrays X, Y and Z of size A,B and C
			respectively.Also, all three arrays are sorted in nondecreasing order. Find i, j, k such that : 0 <= i < A, 0 <=
			j < B, 0 <= k < C and max(abs(X[i] - Y[j]), abs(Y[j] - Z[k]), abs(Z[k] - X[i])) is minimized. 
			Your task is to return the minimum of all the max(abs(X[i] - Y[j]), abs(Y[j] - Z[k]), abs(Z[k] - X[i]))
			Note:
				1. All the arrays are sorted in nondecreasing order.
				2. abs(x) denotes the absolute value of x, i.e. if x<0, the abs function returns (-x)
					so that the final value of x becomes positive.
			Constraints:
				1 <= T <= 100
				1 <= A,B,C <= 10^4
				1 <= X[i] <= 10^4
				1 <= Y[i] <= 10^4
				1 <= Z[i] <= 10^4
				Time Limit: 1 sec
			
			Sample Input 1:
				1
					5
					1 2 3 4 5
					5
					1 3 5 7 9
					3
					2 4 6
					Sample Output 1:
					1 
					Explanation For Sample Input 1:
					For firstestcase :
					One of the possible answer is choose i = 0, j = 0 and k = 1.
					Thus it will 1 answer.
					Sample Input 2:
					1
					4
					1 1 1 1
					4
					2 2 2 2
					5
					7 7 7 7 7
					Sample Output 2:
					6

		//NOT Optimized:
			#include <bits/stdc++.h> 
			int threePointer(vector<int>& X, vector<int>& Y, vector<int>& Z){   
				int i,j,k,currentMax = INT_MAX;
				for(i=0;i<X.size(); i++){
					for(j=0; j<Y.size(); j++){
						for(k=0; k<Z.size();k++){
							int temp = max(abs(X[i]-Y[j]), max(abs(Y[j]-Z[k]), abs(Z[k]-X[i])));
							if(temp < currentMax)
								currentMax=temp;
						}
					}
				}
				return currentMax;
			}
		
		// Partially Optimized:
			#include <bits/stdc++.h> 
			int threePointer(vector<int>& X, vector<int>& Y, vector<int>& Z){	
				std::sort(X.begin(), X.end());
				std::sort(Y.begin(), Y.end());
				std::sort(Z.begin(), Z.end());

				int i = 0, j = 0, k = 0;
				int currentMax = INT_MAX;

				while (i < X.size() && j < Y.size() && k < Z.size()) {
					int maxX = X[i], maxY = Y[j], maxZ = Z[k];
					int minX = X[i], minY = Y[j], minZ = Z[k];

					int temp = std::max({abs(maxX - minY), abs(maxY - maxZ), abs(maxZ - minX)});
					currentMax = std::min(currentMax, temp);

					// Move the pointer associated with the minimum value
					if (X[i] <= Y[j] && X[i] <= Z[k]) {
						i++;
					} else if (Y[j] <= X[i] && Y[j] <= Z[k]) {
						j++;
					} else {
						k++;
					}
				}
				return currentMax;
			}

	81) Row Wave Form:
		Problem Statement
			You are given a 2D array with dimensions "N*M'. You need to read the array elements
			row-wise and return a linear array that stores the elements like a wave ie the 1st-
			row elements are stored from left to right, 2nd-row elements are stored from right to
			left, and so on.
			Constraints:
				1 <= (T' <= 10
				1 <= 'N', 'M' <= 10^3
				1 <= 'ARR[i][g] <= 10^5
			Where ARR[i][j] is the array element in the ith row of the jth column.
				Time limit: 1 second
			Sample Input 1:
				2
				2 2 
				1 2
				0 5
				2 3
				5 1 2
				7 0 1
			Sample Output 1:
				1 2 5 0
				5 1 2 1 0 7
				Explanation Of Input 1:
				For test case 1, the array is traversed as:
				The first row is traversed from left to right. -> [1, 2]
				The second row is traversed from right to left. -> [5, 0]
				Therefore the final answer is [1, 2, 5, 0].

				For test case 2, the array is traversed as:
				First row is traversed from left to right. -> [5, 1, 2]
				Second row is traversed from right to left. -> [1, 0, 7]
				Therefore the final answer is [5, 1, 2, 1, 0, 7]
			Sample Input 2:
				1
				3 3
				0 1 1
				8 0 9
				5 4 1
			Sample Output 2
				0 1 1 9 0 8 5 4 1
				Explanation Of Input 1:
				For test case 1, the array is traversed as:
				The first row is traversed from left to right. -> [0, 1, 1]
				The second row is traversed from right to left. -> [9, 0, 8]
				The third row is traversed from left to right -> [5, 4, 1]
				Therefore the final answer is [0, 1, 1, 9, 0, 8, 5, 4, 1]
		#include <bits/stdc++.h> 
		vector<int> rowWaveForm(vector<vector<int>> &mat) {
			vector<int> ans;
			for(int i=0; i<mat.size(); i++){
				int j;
				if(i&1){
					j=mat[0].size()-1;
					for(;j>=0;j--)
						ans.push_back(mat[i][j]);
				}else{            
					j=0;
					for(;j<mat[0].size();j++)
						ans.push_back(mat[i][j]);
				}
			}
			return ans;
		}

	82) Move Zeroes To End:
		Problem Statement
			Given an unsorted array of integers, you have to move the array elements in a way
			such that all the zeroes are transferred to the end, and all the non-zero elements are
			moved to the front. The non-zero elements must be ordered in their order of
			appearance.
			For example, if the input array is: [0, 1, -2, 3, 4, 0, 5, -27, 9, 0], then the output array
			must be:
			[1, -2, 3, 4, 5, -27, 9, 0, 0, 0].
			Expected Complexity: Try doing it in O(n) time complexity and O(1) space complexity.
			Here, 'n' is the size of the array.
			Sample Input 1:
				2
				7
				2 0 4 1 3 0 28
				5
				0 0 0 0 1
			Sample Output 1:
				2 4 1 3 28 0 0
				1 0 0 0 0
			The Explanation For Sample Output 1 :
				-In the first testcase, All the zeros are moved towards the end of the array, 
				and the non-zero elements are pushed towards the left, maintaining their order with respect to the original array.
				-In the second testcase, All zero are moved towards the end, 
				hence the only non-zero element i.e 1 is in the starting of the array 
			Sample Input 2:
				2
				5
				0 3 0 2 0
				4
				0 0 0 0
			Sample Output 2:
				3 2 0 0 0
				0 0 0 0

		void pushZerosAtEnd(vector<int> &arr) {
			int cnt=0;
			vector<int> ans;
			for(int i=0; i<arr.size() ; i++)
				if(arr[i] != 0)
					ans.push_back(arr[i]);
				else
					cnt++;
			
			for(int i=0; i<cnt; i++)
				ans.push_back(0);
			
			arr = ans;
		}

		//or in-place optimization:
			void pushZerosAtEnd(vector<int> &arr) {
				int nonZeroPos = 0;  // Initialize a pointer to track the position for non-zero elements

				for (int i = 0; i < arr.size(); i++)
					if (arr[i] != 0) {
						// Swap the current element with the element at nonZeroPos
						swap(arr[i], arr[nonZeroPos]);
						nonZeroPos++;
					}
			}
		
		//or
			void pushZerosAtEnd(vector<int> &arr)  {
				int cnt =0;
				for(int i: arr)
					if(i == 0)
						cnt++;

				int j=0;
				for(int i=0; i<arr.size(); i++)
					if(arr[i] != 0)
						arr[j++] = arr[i];

				while(cnt--)
					arr[j++] = 0;
			}

	83) Minimum and Maximum Cost to buy N Candies:
		Problem Statement
			Ram went to a specialty candy store in Ninjaland which has 'N' candies with different costs.
			The Candy shop gives a special offer to its customers. A customer can buy a single candy from
			the store and get at most 'K' different candies for free. Now, Ram is interested in knowing the
			maximum and the minimum amount he needs to spend for buying all the candies available in
			the store.
			Note: In both cases, Ram must utilize the offer i.e. if 'K' or more candies are available, he must
			take 'K' candies for every candy purchase. If less than K candies are available, he must take all
			candies for a candy purchase.
			For Example
				For 'N'= 5 and 'K' = 2
				Let the cost of different candies in the store be: [9 8 2 6 4]
				For the minimum amount:
				Ram can buy a candy with cost 2 and take candies with costs 9 and 8 for free.
				Then, he can buy a candy with cost 4 and take candy with cost 7 for free.
				Thus, the minimum cost will be 6 i.e. 2 + 4.
				For the maximum amount:
				Ram can buy a candy with cost 9 and take candies with costs 2 and 6 for free.
				Then, he can buy candy at cost 8 and take candy at cost 4 for free.
				Thus, the minimum cost will be 17 i.e. 9 + 8.
			Thus, Minimum = 6 and Maximum = 17.
			Sample Input 1:
				1
				4 2
				3 2 1 4
				Sample Output 1 :
				3 7
				Explanation :
				For the minimum amount: 
				Ram can buy candy with cost 1 and take candies with costs 3 and 4 for free. 
				Then, he can buy candy with cost 2.
				Thus, the minimum cost will be 3 i.e. 1 + 2. 

				For the maximum amount: 
				Ram can buy candy with cost 4 and take candies with costs 1 and 2 for free. 
				Then, he can buy candy with cost 3. 
				Thus, the minimum cost will be 7 i.e. 4 + 3.
			Sample Input 2:
				2
				5 2
				9 8 2 6 4
				3 0
				1 5 4
				Sample Output 2 :
				6 17
				10 10

		#include <bits/stdc++.h>
		long long minimumCost(vector<int> &cost, int n, int k){
			long long sum=0;
			// if(k==0){
			//     for(int i=0; i<n;i++)			//we can ignore these lines of code
			//         sum += cost[i];
			//     return sum;
			// }

			sort(cost.begin(), cost.end());
			int cnt=0, i=0;
			while(cnt<n){
				cnt += k+1;
				sum += cost[i++];
			}
			return sum;
		}

		// Function to calculate maximum cost.
		long long maximumCost(vector<int> &cost, int n, int k){
			long long sum=0;

			// if(k==0){
			//     for(int i=0; i<n;i++)			//we can ignore these lines of code
			//         sum += cost[i];
			//     return sum;
			// }

			sort(cost.begin(), cost.end());  //increasing order sorted
			reverse(cost.begin(), cost.end());  //decreasing order sorted
			int cnt=0, i=0;
			while(cnt<n){
				cnt += k+1;
				sum += cost[i++];
			}
			return sum;
		}

	84) Number of Good Indices:
		Problem statement:
			You are given an array 'A' of length 'N' consisting of positive integers. 
			Your task is to tell the number of 'good indices' in the array 'A'.
			An index 'X' is called a 'good index' if and only if:
			There are at least 2 indices 'i != X' and 'j != X', such that 'A[X] % A[i] = 0' and 'A[X] % A[j] = 0'.
			Your task is to return the number of 'good indices'.
			Example:
				'N' = 5
				'A' - [4, 2, 2, 6, 7]
				Here, index '9' is a good index because its value '4' is divisible by values
				present at the indices *1' and '2'. Similarly, index '3' is a good index.
				Therefore, the answer is '2
			Sample Input 1:
				2
				6
				4 8 6 3 7 1
				6
				4 1 10 4 5 9
				Sample Output 1:
				2
				3
				Explanation Of Sample Input 1:
				For test case 1:
				The good indices are '1' and '2' because, for index '1', there are two indices whose value perfectly divides the value present at the index '1', i.e., index '0' and index '5'. Similarly, for index '2', the two indices are '3' and '5'.

				For test case 2:
				The good indices are '0', '2' and '3'. For index '0', the two indices are '1' and '3', whose value at those indices in the array perfectly divides the array. Similar is the case for index '2' and '3'.
				Sample Input 2:
				2
				6
				3 10 7 4 2 10
				6
				4 5 4 8 1 4
				Sample Output 2 :
				2
				4
		
		int numberOfGoodIndices(int n, vector<int>& a) {
			int MainCNT=0;
			for(int i=0; i<n; i++){
				int currentNum= a[i],cnt=0;
				for(int j=0; j<n; j++){
					if(i==j)
						continue;
					if(currentNum%a[j] == 0)
						cnt++;
					if(cnt>=2){
						MainCNT++;
						break;
					}
				}
			}
			return MainCNT;
		}

	85) Find First and Last Position of Element in Sorted Array:
		https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
		Given an array of integers nums sorted in non-decreasing order, 
		     find the starting and ending position of a given target value.
			If target is not found in the array, return [-1, -1].
			You must write an algorithm with O(log n) runtime complexity.

			Example 1:
				Input: nums = [5,7,7,8,8,10], target = 8
				Output: [3,4]
			Example 2:
				Input: nums = [5,7,7,8,8,10], target = 6
				Output: [-1,-1]
			Example 3:
				Input: nums = [], target = 0
				Output: [-1,-1]
			Constraints:
				0 <= nums.length <= 105
				-109 <= nums[i] <= 109
				nums is a non-decreasing array.
				-109 <= target <= 109
		//Brute Force Tech, Optimized.
			class Solution {
				public:
				vector<int> searchRange(vector<int>& nums, int target) {
					vector<int> ans;
					//traversing from start
					for(int i=0; i<nums.size(); i++){
						if(nums[i] == target){
							ans.push_back(i);
							break;
						}
					}
				
					if(ans.size()==0)
						ans = {-1,-1};

					/* or
						if(ans.size()==0){
							ans = {-1,-1};
							return ans;
						}

						if(ans.size()==0)
							return {-1,-1};					
					*/
				
					//traversing from end
					for(int i=nums.size()-1; i>=0; i--){
						if(nums[i] == target){
							ans.push_back(i);
							break;
						}
					}
					return ans;
				}
			};
		
		//Binary Search Tech. Optimized
			class Solution {
				public:
				vector<int> searchRange(vector<int>& nums, int target) {
					int start=0,end=nums.size()-1;
					int mid = (start+end)/2;
					int found;
					while(start<=end){
						if(nums[mid] == target){
							found = mid;
							break;
						}else if(target<nums[mid]){
							end = mid-1;
						}else{
							start = mid+1;
						}
						mid = (start+end)/2;
					}

					if(start>end)
						return {-1,-1};

					int left = found, right = found;
					leftCheck:
					if(left>0 && nums[left] == nums[left-1]){
						left--;
						goto leftCheck;
					}

					rightCheck:
					if(right<nums.size()-1 && nums[right] == nums[right+1]){
						right++;
						goto rightCheck;
					}
					return {left, right};
				}
			};

	86) Minimum Maximum Value❌
		Sample Input 2:
			2
			2*3+4
			2*3+1*5*4
			Sample Output 2:
			10 14
			26 160

	87) Product Array Puzzle:
		Problem Statement
			You are given an array of 'N' integers. You need to return another array 'product' such that 'product[i]
			contains the product of all the arrays except the element at the ith position in the given array.
			Note
			As the product of elements can be very large you need to return the answer in mod (10^9+7).
			Follow Up
			Try to do this without using the division operator '/', in constant space. The output
			array does not count as extra space for the purpose of space complexity analysis
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints:
			1 <= T <= 10^2
			2 <= N<= 10^4
			1 <= A[i] <= 10^9
			Where 'T' is the number of test cases, 'N' is the size of the array, 'A[i]' is the size
			of the array elements.
			Time Limit: 1 sec
			Sample Input 1:
				2
				5 
				1 3 3 10 2
				6 
				2 4 6 3 1 1
				Sample Output 1:
				180 60 60 18 90
				72 36 24 48 144 144
				Explanation For Sample Input 1:
				Test case 1:
				Product of elements except 1 = 3 * 3 * 10 * 2 = 180       
				Product of elements except 3 = 1  * 3 * 10 * 2 = 60       
				Product of elements except 3 = 1 * 3  * 10 * 2 = 60       
				Product of elements except 10 = 1 * 3 * 3 * 2 = 18       
				Product of elements except 2 = 1 * 3 * 3 * 10 = 90       

				Test case 2:
				Product of elements except 2 = 4 * 6 * 3 * 1 * 1 = 72   
				Product of elements except 4 = 2 * 6 * 3 * 1 * 1 = 36   
				Product of elements except 6 = 2 * 4 * 3 * 1 * 1 = 24   
				Product of elements except 3 = 2 * 4 * 6 * 1 * 1 = 48  
				Product of elements except 1 = 2 * 4 * 6 * 1 * 1 = 144   
				Product of elements except 1 = 2 * 4 * 6 * 3 * 1 = 144  
				Sample Input 2:
				2
				5 
				1 10 1 2 2
				6
				2 12 1 1 20 1 
				Sample Output 2:
				40 4 40 20 20
				240 40 480 480 24 480
				Explanation For Sample Input 2:
				Test case 1:
				Product of elements except 1 = 10 * 1 * 2 * 2 = 40      
				Product of elements except 10 = 1  * 1 * 2 * 2 = 4      
				Product of elements except 2 = 1 * 10 * 1 * 2 = 20
				Product of elements except 2 = 1 * 10 * 1 * 2 = 20       

				Test case 2:
				Product of elements except 2 = 12 * 1 * 1 * 20 * 1 = 240
				Product of elements except 12 = 2 * 1 * 1 * 20 * 1 = 40 
				Product of elements except 1 = 2 * 12 * 1 * 20 * 1 = 480   
				Product of elements except 1 = 2 * 12 * 1 * 20 * 1 = 480
				Product of elements except 20 = 2 * 12 * 1 * 1 * 1 = 24  
				Product of elements except 1 = 2 * 12 * 1 * 1* 20 = 480

		//NOT Optimized:
			#include <bits/stdc++.h> 
			vector <int> productPuzzle(vector <int> & arr, int n) {
				vector <int> ans;
				int mod = 1e9+7;
				for(int i=0; i<n; i++){
					long long sum = 1;
					for(int j=0; j<n; j++){
						if(i==j)
							continue;
						sum *= arr[j];
						sum %= mod;
					}
					ans.push_back(sum);
				}
				return ans;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			vector <int> productPuzzle(vector <int> & arr, int n) {
				vector<int> ans(n, 1); // Initialize ans with 1's
				int mod = 1e9 + 7;

				// Calculate the prefix product from the left
				long long left_product = 1;
				for (int i = 0; i < n; i++) {
					ans[i] = (ans[i] * left_product) % mod;
					left_product = (left_product * arr[i]) % mod;
				}

				// Calculate the suffix product from the right
				long long right_product = 1;
				for (int i = n - 1; i >= 0; i--) {
					ans[i] = (ans[i] * right_product) % mod;
					right_product = (right_product * arr[i]) % mod;
				}
				return ans;
			}
		
	88) Swap Adjacent Bit Pairs:
		Problem Statement
			You are given an integer 'N'. Your task is to find the number formed after swapping each even bit of 'N' in its binary
			representation with its adjacent bit on the right, assuming that the least significant bit is an odd bit.
			For example:
				Consider the integer N = 45 whose binary representation is 101101. The resulting number formed
				after swapping each even bit with its adjacent bit to the right will be 30 (011110) in this case.
				Detailed explanation ( Input/output format, Notes, Images )
			Input Format :
				The first line of the input contains an integer, 'T,' denoting the number of test cases.
				The first and only line of each test case contains the integer 'N'
				Output Format :
				For each test case, print the resulting integer formed after swapping each even bit.
				Print the output of each test case in a new line.
				Note:
				You do not need to print anything. It has already been taken care of. Just implement the given function.
			Constraints:
				1 <= T <= 10^5
				1 <= N <= 10^9
			Time Limit: 1 sec
			Sample Input 1 :
				2
				9
				2
				Sample Output 1 :
				6 
				1
				Explanation For Sample Input 1 :
				For the first test case : 
				The binary representation of 9 is 1001. Here, we will swap the 2nd bit with the 1st bit and the 4th bit with 3rd bit. The resulting binary number will be 0110. Hence, the answer is 6 in this case.

				For the second test case : 
				The binary representation of 2 is 10. Here, we will swap the 2nd bit with the 1st bit. The resulting binary number will be 01 or 1. Hence, the answer is 1 in this case.
				Sample Input 2 :
				2
				7
				10
				Sample Output 2 :
				11
				5
		#include <bits/stdc++.h> 
		int swapAdjacentBits(int n){ 
			
			//creating empty string
			string s;

			//converting num to binary representation & storing it in string
			s = bitset<32>(n).to_string();

			//removing trailing zeros
			while(1){
				if(s[0] != '0')
					break;
				s.erase(0,1);
			}

			//its the length is odd then adding extra 0 char at beginning of string
			if(s.length() % 2 !=0)
				s.insert(s.begin(),'0');

			// cout<<s<<"\n";
			//swapping even bits with right
			for(int i= s.length()-1; i>=0; i-=2){
				swap(s[i],s[i-1]);
			}
			// cout<<s<<"\n";

			//to Binary Conversion,
			//converting the binary string back to num
			int cnt=0;
			int newNum=0;
			for(int i=s.length()-1; i>=0; i--){
				// newNum += (s[i]-48)*pow(2,cnt++);
				//or
				newNum += (s[i]- '0')*pow(2,cnt++);
			}
			return newNum;
		}

	89) Smallest number divisible by K:
		Problem Statement
			Ninja's favorite numbers are the numbers whose all digits are '1' So Let's consider numbers that have only the digit
			'1'. For example, ('1', '11' '111'...].
			You are given an integer 'K' Your task is to find the number of digits in the Ninja's smallest favorite number that is
			divisible by 'K'. If there is no such number that is divisible by 'K', then return -1.
			Detailed explanation (Input/output format, Notes, Images )
			Input Format:
				The first line contains an integer 'T' which denotes the number of test cases or queries to be
				The first line of each test case contains an integer denoting the value of 'K'.
			Output Format:
				For each test case, print a single line containing a single integer denoting the number of digits
				in the smallest number that is divisible by given 'K' if it exists else print -1°
				The output of each test case will be printed in a separate line.
			Note:
			You do not need to input or print anything, and it has already been taken care of. Just implement
			the given function.
			Constraints:
				142 T/= 5
				1 <= K <= 10 ^ 5
			Where 'T' is the total number of test cases, and 'K' is the given integer.
			Sample Input 1:
				2
				1
				8
				Sample Output 1:
				1
				-1
				Explanation of Sample Input 1:
				Test case 1:
				‘1’ is itself divided by one, that has only 1 digit, hence the answer will be 1.

				Test case 2:
				There is no number whose all digits are ‘1’ and divisible 8 , so the answer will be -1.
				Sample Input 2:
				1
				11
				Sample Output 2:
				2
				Explanation of Sample Input 2:
				Test case 1:
				‘11’ is itself divided by 11 which have 2 digits hence the answer will be 2.

		#include <bits/stdc++.h> 
		int lengthOfNumber(int k){

			//it will work till 18 digit checks,
			// long long arr[] = {1,11,111,1111,11111, 111111, 1111111, 11111111, 111111111, 1111111111, 11111111111, 111111111111,
			// 			 1111111111111, 11111111111111, 111111111111111, 1111111111111111, 11111111111111111, 111111111111111111 };
			// int digit=0;
			// for(int i=0;; i++){
			// 	if(arr[i] % k ==0){
			// 		return i+1;
			// 	}
			// }
			// return -1;

			unordered_set<int> remainders;
			int currentRemainder = 1 % k;
			int num_digit = 1;
			while(currentRemainder !=0 ){
				currentRemainder = (currentRemainder*10 +1)%k;
				num_digit++;
				if(remainders.find(currentRemainder) != remainders.end())
					return -1;
				remainders.insert(currentRemainder);
			}
			return num_digit;
		}

	90) Check If Given Words Are Present In A String:
		Problem Statement
			Given a string 'S' and a list 'wordList' that consists of 'N' distinct words. Let 'Wi' denote word at index 'i in 'wordList'.
			For each word 'Wi' in 'wordList', you need to determine whether it is present in string 'S' or not. Return a boolean
			array, where a boolean value at index ' represents whether the word 'Wi' is present in the string 'S' or not.
			Detailed explanation (Input/output format, Notes, Images
			Constraints:
				1 < T <= 50
				1 <= |S| <= 10^3
				1 <• N <= 10^3
				1 <= |W| <= 10
			Where |S|' denotes the length of string and |w| denotes the maximum length of the word present in 'wordList'
			Time limit: 1 sec
			Sample Input 1 :
				2
				This is a large String
				4
				This this is age 
				ILikeCodingNinjas
				3
				Ninja Coding Code
				Sample Output 1 :
				True False True False
				True True False
				Explanation Of Sample Input 1 :
				Test case 1:

				Here String ‘S’ is “This is a large String” and ‘wordList’ is [“This”, “this”, “is”, “age”] 

				The word “This” is present from index ‘0’ to index ‘3’ in ‘S’.
				The word “this” is not present in ‘S’.
				The word “is” is present from index ‘2’ to index ‘3’’ and from  ‘5’ to index ‘6’  in ‘S’. 
				The word  “age” is not present in ‘S’.
				Note:  All words are case sensitive and we consider 0 based indexing in 'S'.

				Test case 2:

				Here String ‘S’ is “ILikeCodingNinjas” and ‘wordList’ is [“Ninja” “Coding” “Code”] 

				The word “Ninja” is present from index ‘11’ to index ‘15’ in ‘S’.
				The word “Coding” is present from index ‘5’ to index ‘10’ in ‘S’.
				The word “Code” is not present in  ‘S’. 
				Sample Input 2 :
				3
				This is String
				2
				This String
				Code Infy
				3
				C I F
				coding
				1
				CodingNinjas
				Sample Output 2 :
				True True 
				True True False 
				False 
				Explanation Of Sample Input 2 :
				Test case 1:
				Here String ‘S’ is “This is String” and ‘wordList’ is [“This”, “String” ] 

				The word “This” is present from index ‘0’ to index ‘3’ in ‘S’.
				The word  “String” is present from index ‘8’ to index ‘13’’ in ‘S’. 

				Test case 2:

				Here String ‘S’ is “Code Infy” and ‘wordList’ is [“C” “I” “F”] 

				The word “C” is present at index ‘0’ ’ in ‘S’.
				The word “I”  is present at index ‘5’ in ‘S’.
				The word “F” is not present in  ‘S’. 

				Test case 3:

				Here String ‘S’ is “Coding” and ‘wordList’ is [“ CodingNinjas”] 

				The word “CodingNinjas” is not in ‘S’.
		#include <bits/stdc++.h> 
		vector<bool> checkWordsInString(string &s, int n, vector<string> &wordList) {
			vector<bool> ans(n);
			for(int i=0; i<n; i++){
				string sub = wordList[i];
				if(s.find(sub) != string::npos)
					ans[i]=1;
				else
					ans[i]=0;
			}
			return ans;
		}	

	91) Find Peak Element
		Problem Statement
			You are given an array 'arr' of length 'n' Find the index(0-based) of a peak element in the array. 
			If there are multiple peak numbers, return the index of any peak number.
			Peak element is defined as that element that is greater than both of its neighbors. 
			If 'arr[i]' is the peak element, 'arr[i -1]' < 'arrfil' and 'arr[i + 1]' < 'arril'
			Assume 'arr[-1]' and 'arr[n]' as negative infinity.
			Note:
				1. There are no 2 adjacent elements having same value (as mentioned in the constraints).
				2. Do not print anything, just return the index of the peak element (0 - indexed).
				3. 'True'/'False' will be printed depending on whether your answer is correct or not.
			Example:
			Input: 'arr' = [1, 8, 1, 5, 3]
			Output: 3
			Explanation: There are two possible answers. Both 8 and 5 are peak elements, so the correct
			answers are their positions, 1 and 3.
			Sample Input 1:
				5
				1 8 1 5 3
				Expected Answer:
					1

				Output On Console:
					True

				Explanation Of Sample Input 1 :
				There are two possible answers. Both 8 and 5 are peak elements, so the correct answers are their positions, 1 and 3. Any of these 2 numbers will print 'True'.

				Sample Input 2:
					3
					1 2 1 

				Expected Answer:
					1

				Output On Console:
					True

				Expected Time Complexity:
					The expected time complexity is O(log 'n').


				Constraints:
					1 <= 'n' <= 10^5
					1 <= 'arr[i]' <= 10^5
					'arr[i]' != 'arr[i + 1]' for all 'i' in range 0 <= 'i' < 'n' - 1

		int findPeakElement(vector<int> &arr) {

			//this not working for edge test case like arr[-1] & arr[n];
			//  for(int i=1; i<arr.size()-1; i++){
			//     if((arr[i]> arr[i-1]) && (arr[i]>arr[i+1]))
			//         return i;
			// }
			// return 0;
			int left = 0;
			int right = arr.size() - 1;

			while (left < right) {
				int mid = (left + right) / 2;
				if (arr[mid] > arr[mid + 1]) {
					right = mid;
				} else {
					left = mid + 1;
				}
			}

			return left;
		}

		//or Not Optimized:
			#include <bits/stdc++.h>
			int findPeakElement(vector<int> &arr) {
				auto mx = max_element(arr.begin(), arr.end());
				return mx - arr.begin();
			}

	92) Container With Most Water:
		Given a sequence of 'N' space-separated non-negative integers A [1], A [2], A [3]…....A [i].....A[n]. Where each
		number of the sequence represents the height of the line drawn at point '. Hence on the cartesian plane,
		each line is drawn from coordinate (I',O) to coordinate ('i', 'A[i]'), here 'i' ranges from 1 to 'N'. Find two lines,
		which, together with the x-axis forms a container, such that the container contains the most area of water.
		Note:
			1. You can not slant the container i.e. the height of the water is equal to the minimum
			height of the two lines which define the container.
			2. Do not print anything, you just need to return the area of the container with maximum
			water
		
		Sample Input 1 :
			2
			5
			4 3 2 1 4
			3
			1 2 1
			Sample Output 1 :
			16
			2 
			Explanation Of The Sample Input 1:
			For the first case: 
			We can create ‘n(n+1)/2’ different containers using ‘N' containers for example with 1st and 3rd line we can create a container of area = (3-1)*min(4,2)=4.

			All Possible Containers:  


			Lines used          Area
			4,3         area=min(4,3)*1=3
			4,2         area=min(4,2)*2=4
			4,1         area=min(4,1)*3=3
			4,4         area=min(4,4)*4=16
			3,2         area=min(3,2)*1=2
			3,1         area=min(3,1)*2=2
			3,4         area=min(3,4)*3=9
			2,1         area=min(2,1)*1=1
			2,4         area=min(2,4)*2=4
			1,4         area=min(1,4)*1=1

			But among all such containers the one with the maximum area will be formed by 
			using the first and last line, the area of which is : (5-1)*min(4,4)=16.
			Hence we return 16.

			For the second case: 
			We can take the first and third line to get an area of 
			(3-1)*min(1,1)=2 which is the maximum possible area in this sequence.
			Sample Input 2 :
				2
				5
				12 4 6 8 1
				3
				1 2 3
				Sample Output 2 :
				24
				2


		//Not Optimized:
			int maxArea(vector<int>& height) {
				int ans=0;
				for(int i=0; i<height.size(); i++){
					int dist = 1;
					for(int j=i+1; j<height.size(); j++){
						int minn = (min(height[i],height[j]))* dist;
						ans = max(ans, minn);
						dist++;
					}
				}
				return ans;
			}

		//Optimized:
			int maxArea(vector<int>& height) {
				int left=0;
				int right=height.size()-1;
				int mxArea=0;

				while(left < right){
					int minH = min(height[left],height[right]);
					int dist = right-left;
					
					int newArea = minH * dist;
					mxArea = max(mxArea,newArea);

					if(height[left] < height[right]){
						left++;
					}else{
						right--;
					}
				}
				return mxArea;
			}
			
	93) Interesting Alphabets:
		As a part of its competition, the school will conduct a codeathon, Lock the Code, where it has been given a
		value, and the participants have to decode it.
		The participants are given a value denoting the number of rows in the matrix; they need to print the pattern.
		Example:
			For N=5, Pattern:
			E
			DE
			CDE
			BCDE
			ABCDE
			Among the participants, Ninja is new to programming and doesn't have much experience; he asks you to
			solve the problem. Can you help solve this problem?
		Sample Input 1:
			2
			5
			4
			Sample Output 1:
			E
			DE
			CDE
			BCDE
			ABCDE

			D
			CD
			BCD
			ABCD
			Explanation For Sample Input 1:
			In the first test case, value of ‘N’ is 5, so print the ‘N’ rows from 1 to ‘N’ where in each row start from (N - i - 1)the character which goes on till ‘Nth character. Hence the answer is [‘E’,’DE’,’CDE,’ BCDE’,’ABCDE’].

			In the second test case, the value of ‘N’ is 4, so print the ‘N’ rows from 1 to ‘N’ where each row starts from (N - i - 1)the character, which goes on till ‘Nth character. Hence the answer is [‘D’,’CD’,BCD’,’ABCD’].
			Sample Input 2:
			2
			3
			2
			Sample Output 2:
			C
			BC
			ABC

			B
			AB

		#include <bits/stdc++.h> 
		vector<vector<char>> interestingPattern(int n){
			vector<vector<char>> ans;
			vector<char> temp;
			char ch1 = 'A'+ (n-1);
			for(int j=n-1; j>=0; j--){
				char ch = ch1;
				for(int i=n-1; i>=j; i--){
					temp.push_back(ch++);
				}
				ans.push_back(temp);
				temp.clear();
				ch1--;
			}
			return ans;
		}

		#include <bits/stdc++.h> 
		vector<vector<char>> interestingPattern(int n){
			char ch = 64+n;
			vector<vector<char>> ans;
			for(int i=0; i<n; i++){
				char currentCh = ch--;
				vector<char> temp;
				for(int j=0; j<=i; j++){
					temp.push_back(currentCh++);
				}
				ans.push_back(temp);
			}
			return ans;
		}

	94) Isomorphic Strings:
		Problem Statement
			You have been given two strings, 'str1'and 'str2'
			Your task is to return true if the given two strings are isomorphic to each other, else return false.
			Note :
			Two strings are isomorphic if a one-to-one mapping is possible for every character of the
			first string 'str1' to every character of the second string 'str2' while preserving the
			order of the characters.
			All occurrences of every character in the first string 'str1' should map to the same
			character in the second string, 'str2'
			For Example:
			If stri = "aab" and str2 = "xxy" then the output will be 1. 'a' maps to 'x' and 'b' maps
			to 'y'.
			If stri = "aab" and str2 = "xyz" then the output will be 0. There are two different
			characters in 'strl', while there are three different characters in 'str2'. so there won't
			be one to one mapping between 'stri' and 'str2'
			Sample Input 1 :
				aab 
				xxy
				Sample Output 1 :
				1
				Explanation Of Sample Input 1:
				The character ‘a’ maps to ‘x’ and ‘b’ maps to ‘y’. Hence, the answer is 1 in this case.
				Sample Input 2 :
				aab
				xyz
				Sample Output 2 :
				0
				Constraints :
				1 <= |str1|, |str2| <= 10^3

				|str1| is the length of the string str1, and |str2| is the length of the string str2.
				Follow Up:
				Can you solve this in O(N) time?

		bool areIsomorphic(string &str1, string &str2){
			
			if(str1.length() !=  str2.length())
				return 0;

			vector<int> countStr1(26,0);
			vector<int> countStr2(26,0);

			//mapper for str1;
			for(int i=0; i<str1.length(); i++)
				countStr1[str1[i]-'a']++;
			
			//mapper for str2;
			for(int i=0; i<str2.length(); i++)
				countStr2[str2[i]-'a']++;

			sort(countStr1.begin(), countStr1.end());
			sort(countStr2.begin(), countStr2.end());
			
			for(int i=0; i<26; i++)
				if(countStr1[i] != countStr2[i])
					return 0;
			return 1;
		}
		
	95) Cyclically Rotate An Array By One:
		You are given an integer array of size N. Your task is to rotate the array by one position in the clockwise direction.
		For Example:
			If N = 5 and arr[ ] = (1, 2, 3, 4, 5} then output will be 5 1 2 3 4.
			If N = 8 and arr[ ] = {9, 8, 7, 6, 4, 2, 1, 3] then output will be 3 9 8 7 6 4 2 1.
		Sample Input 1 :
			5
			1 2 3 4 5
			Sample Output 1 :
			5 1 2 3 4
			Explanation For Sample Input 1 :
			The first four elements are shifted towards the right by one position, and the last element i.e. 5 is shifted to the first position.
			Sample Input 2 :
			1
			8
			9 8 7 6 4 2 1 3
			Sample Output 2 :
			3 9 8 7 6 4 2 1

		//Optimized:
			#include <bits/stdc++.h> 
			void rotate(vector<int>& arr, int n) {
				int lastDigit = arr[n-1];
				for(int i=n-1; i>0; i--){
					arr[i] = arr[i-1];
				}
				arr[0] = lastDigit;
			}
		
		//more optimized:
			#include <bits/stdc++.h> 
			void rotate(vector<int>& arr, int n) {
				int lastDigit = arr.back();
				arr.pop_back();
				arr.insert(arr.begin(), lastDigit);    
			}

	96) Program to check the validity of a Password:
		problem statement:
			Ninjas are trying to hack a system of a terrorist organization so that they can know where they will be going
			to attack next. But to hack the system and to get access to data they need a password that must satisfy
			certain conditions as described below:
			1) Length of the password must be between 8 to 15 characters.
			2) At least one digit (0-9), one lowercase letter (a-z), one uppercase letter (A-Z) and
			one special character (%, ^, &, #, *, %, etc) must be present.
			3) Password must not contain any space.
			You are given a string 'STR', help ninjas to find whether it's a valid password or not.
			For example:
			Given 'STR' = "Codingninja#" As it satisfies all the above conditions so it is a valid
			password and therefore you have to return true.
			Sample Input 1:
				3
				CODiNGNinja+1
				abcXyz 123
				itsnotValid1
				Sample Output 1:
				Valid
				Not Valid
				Not Valid
				Explanation of Sample Input 1:
				Test Case 1 :  
				Given ‘STR’ = CODiNGNinja+1
				As we can see that this string satisfies all the given conditions in the problem.
				Therefore, it's a valid password.

				Test Case 2 : 
				Given ‘STR’ = abcXyz 123 
				As the given string contains a space, so it's not a valid password.

				Test Case 3:
				Given ‘STR’ =  itsnotValid1
				As the string does not contain any special character, so it’s not a valid password.
				Sample Input 2:
				3
				&1CodingISBest
				Ab@3
				HEllo@World#0
				Sample Output 2:
				Valid
				Not Valid
				Valid

		//optimized
			bool isValid(string &str) {
				if(str.length()<8 || str.length()>15)
					return 0;

				//checking contain digit
				int cnt=0;
				for(int i=0; i<str.length(); i++){
					if(isdigit(str[i])){
						cnt++;
						break;
					}
				}
				if(cnt==0)
					return 0;
				
				//checking lowercase char
				cnt=0;
				for(int i=0; i<str.length(); i++){
					if(islower(str[i])){
						cnt++;
						break;
					}
				}
				if(cnt==0)
					return 0;

				//checking uppercase char
				cnt=0;
				for(int i=0; i<str.length(); i++){
					if(isupper(str[i])){
						cnt++;
						break;
					}
				}
				if(cnt==0)
					return 0;

				//checking contain space?
				for(int i=0; i<str.length(); i++){
					if(isblank(str[i])){
						return 0;
					}
				}
				return 1;		
			}

		//more optimized:
			bool isValid(string &str) {
				int length = str.length();
				
				// Check length
				if (length < 8 || length > 15) {
					return false;
				}

				bool hasDigit = false;
				bool hasLowercase = false;
				bool hasUppercase = false;

				for (int i = 0; i < length; i++) {
					if (isdigit(str[i])) {
						hasDigit = true;
					} else if (islower(str[i])) {
						hasLowercase = true;
					} else if (isupper(str[i])) {
						hasUppercase = true;
					}
					
					if (str[i] == ' ') {
						return false;  // Check for spaces
					}
				}

				// Check for at least one digit, lowercase, and uppercase
				return hasDigit && hasLowercase && hasUppercase;	
			}

		//or
			bool isValid(string &str){
				if(str.length()<8 || str.length()>15)
					return 0;
				
				bool atLeastOneDigit, atLeastOneLowercase, atLeastOneUppercase, atLeastOneSpecialChar;
				atLeastOneDigit = atLeastOneLowercase = atLeastOneUppercase = atLeastOneSpecialChar = 0;

				for(int i=0; i<str.length(); i++){
					if(str[i] ==  ' ')
						return 0;

					if(isdigit(str[i]))
						atLeastOneDigit=1;
					else if(islower(str[i]))
						atLeastOneLowercase=1;
					else if(isupper(str[i]))
						atLeastOneUppercase =1;
					else
						atLeastOneSpecialChar=1;	
				}
				return atLeastOneSpecialChar && atLeastOneDigit && atLeastOneLowercase && atLeastOneUppercase;
			}

		// Or
			bool isValid(string &str) {
				// constains space
				if((str.find(' ') !=  string::npos) || str.size() < 8 || str.size() >15)
					return false;

				int flagUpper=0, flagLower=0, flagSpecial=0, flagDigit=0;
				for(int i=0; i<str.size(); i++)
					if(islower(str[i]))
						flagLower=1;
					else if(isupper(str[i]))
						flagUpper = 1;
					else if(isdigit(str[i]))
						flagDigit=1;
					else if(ispunct(str[i]))
						flagSpecial=1;
					else{
						// default
					}

				return flagLower && flagUpper && flagSpecial && flagDigit;
			}

	97) Pascal's Triangle II:
		https://leetcode.com/problems/pascals-triangle-ii/description/
			#include <iostream>
			#include<vector>
			using namespace std;

			vector<int> getRow(int rowIndex) {
				vector<int> ans;
				if(rowIndex == 0)
					return {1};
				else if(rowIndex == 1)
					return {1,1};
				else{
					ans = {1,1};
					for(int i=1; i<rowIndex; i++){
						vector<int> temp;
						temp.push_back(1);
						for(int j=0; j<rowIndex-1; j++){
							int num = ans[j]+ans[j+1];
							temp.push_back(num);
						}
						temp.push_back(1);
						ans.clear();
						ans = temp;
					}
					// ans.pop_back();
					}
					return ans;
				}
			int main(){
				
				vector<int> ansss;
				ansss = getRow(4);
				for(int z: ansss)
					std::cout << z << "\t";
				return 0;
			}

		//leetcode working code:
			class Solution {
				public:
				vector<int> getRow(int rowIndex) {
					vector<int> ans(rowIndex + 1, 0);  // Initialize the result vector with 0s.
					ans[0] = 1;  // The first element of each row is always 1.

					for (int i = 1; i <= rowIndex; i++) {
						for (int j = i; j >= 1; j--) {
							ans[j] += ans[j - 1];
						}
					}
					return ans;
				}
			};

		//GFG Pascal Triangle:
			class Solution{
				public:
				vector<long long> nthRowOfPascalTriangle(int n) {
					vector<long long> ans;
					int mod = 1e9+7;
					if(n == 1)
						return {1};
					else if(n==2)
						return {1,1};
					else{
						ans = {1,1};
						for(int i=1; i<n-1; i++){
							vector<long long> temp;
							temp.push_back(1);
							for(int j=0; j<ans.size()-1; j++){
								int num = (ans[j] + ans[j+1]) % mod;
								temp.push_back(num);
							}
							temp.push_back(1);
							ans.clear();
							ans = temp;
						}
						return ans;
					}
				}
			};

	98) Count Squares:
		Problem Statement
			You are given a matrix of size N* M. Can you count the number of squares in it?
			As the count will be very large, so compute it with modulo 10^9 + 7.(1e9+7)
			For Example:
				Let N = 3 and M = 5
				The number of squares of size 1 will be 15.
				The number of squares of size 2 will be 8.
				The number of squares of size 3 will be 3
				Thus the answer will be 26.
			Constraints:
				1 <= T <= 10^5
				1 <= N <= 10^9
				1 <= M <= 10^9
			Time limit: 1 sec
			Sample Input 1:
				2		
				3 5
				2 3
				Sample Output 1:
				26
				8
				Explanation
				Test Case 1: Refer to the example described above.

				Test Case 2:
				The number of squares of size 1 will be 6.
				The number of squares of size 2 will be 2.
				Thus, the answer will be 8.
				Sample Input 2:
				3
				1 8
				6 4
				3 3
				Sample Output 2:
				8
				50
				14
		//not Optimized:
			#include <bits/stdc++.h> 
			int countSquares(int n, int m){
				long long SUM=0;
				int mod = 1e9+7;

				int iterator = n;
				for(int i=0; i< iterator; i++){
					SUM = (SUM + (n*m)%mod)%mod;
					n--; m--;
					if(m==0)
						break;
				}
				return SUM;
				
					//or
				// int mod = 1e9 + 7;
				// long long SUM = 0;
				// int iterator = std::min(n, m); // Use the minimum of n and m to determine the number of squares.

				// for (int i = 1; i <= iterator; i++) {
				//     SUM = (SUM + 1LL*(n) * m) % mod;            //or we can use static_cast<long long> to convert int to long long instead of 1ll or 1LL
				//                                             //SUM = (SUM + static_cast<long long>(n) * m) % mod;
				//     n--;
				//     m--;
				// }
				// return SUM;
			}

	99) Win or Lose
		Problem Statement
			You and your friends are playing a turn-based game. You will make the first move. 
			Initially, you have an integer 'N'. On each player's turn, that player makes a move consisting of two steps.
				1) Choose an integer 'i such that 0 < 'ї < 'N' and 'N" is divisible by 'ї.
				2) Update number 'N' to 'N -ї.
			If a player cannot make a move, they lose the game.
			You are given the initial number 'N: You have to print "YES" if you win the game; otherwise, print "NO".
			For example:
			If the number 'N' = 6 and you select "i to be 2, then the new number N' will be 6 - 2 = 4.

		Sample Input-1
			2
			2
			3
			Sample Output-1
			YES
			NO
			Explanation For Sample Input 1:
			For test case 1:
			You can choose only ‘1’; the new number becomes 2 - 1 = 1.
			Your friend can’t make any move. Hence you win the game.
			For test case 2:
			You can choose only ‘1’; the new number becomes 3 - 1 = 2.
			Your friend can choose only ‘1’; the new number becomes 2 - 1 = 1.
			You can’t make any move. Hence you lose the game.
			Sample Input -2
			2
			13
			16
			Sample Output -2
			NO
			YES
		
		#include <bits/stdc++.h>
		string winOrLose(int N) {
			if(N&1)
				return "NO";
			return "YES";
		}

	100) Leaders in an array:
		Problem Statement
			Given a sequence of numbers. Find all leaders in sequence. An element is a leader if it is strictly greater than
			all the elements on its right side.
			Note:
				1. Rightmost element is always a leader.
				2. The order of elements in the return sequence must be the same as the given sequence
			Example:
				The given sequence is 13, 14, 3, 8, 2 •
				13 Not a leader because on the right side 14 is greater than 13.
				14 lt is a leader because no one greater element in the right side.
				3 Not a leader because on the right side 8 are greater than 3.
				8 It is a leader because no one greater element on the right side.
				2 It is a leader because it is the rightmost element in a sequence.
			Hence there are 3 leaders in the above sequence which are 14, 8, 2.
			Sample Input 1:
				2
				6
				6 7 4 2 5 3
				4
				11 10 9 8
				Sample Output 1:
				7 5 3
				11 10 9 8
				Explanation Of Sample Output 1:
				In test case 1,
					6 Not a leader because on the right side 7 is greater than 6.
					7 lt is a leader because no one greater element in the right side.
					4 Not a leader because on the right side 5 are greater than 4.
					2 Not a leader because on the right side 5, 3 are greater than 2.
					5 lt is a leader because no one greater element in the right side.
					3 It is a leader because it is a rightmost element in a sequence.
					Hence there are 3 leaders in sequence 7, 5, 3. 

				In test case 2,
					Given sequence is in descending order, so all elements are leaders

				Sample Input 2:
					2
					6
					5 10 11 12 -1 -2
					4
					10 -11 -3 -2
					Sample Output 2:
					12 -1 -2
					10 -2
				Explanation Of Sample Output 2:
				In test case 1,
					5 Not a leader because on the right side 10 is greater than 5.
					10 Not a leader because on the right side 11 is greater than 10.
					11 Not a leader because on the right side 12 are greater than 11.
					12 lt is a leader because no one greater element in the right side.
					-1 lt is a leader because no one greater element in the right side.
					-2 It is a leader because it is a rightmost element in a sequence.
				Hence there are 3 leaders in sequence 12, -1, -2. 
				In test case 2,
					10 lt is a leader because no one greater element in the right side.
					-11 Not a leader because on the right side -3 are greater than -11.
					-3 Not a leader because on the right side -2 are greater than -3.
					-2 It is a leader because it is a rightmost element in a sequence.
				Hence there are 2 leaders in sequence 10, -2. 

		#include <bits/stdc++.h> 
		vector<int> findLeaders(vector<int> &elements, int n) {
			vector<int> leaders;
			leaders.push_back(elements[n-1]);
			for(int i=n-2; i>=0; i--){
				int j;
				for(j=i+1; j<n; j++){
					if(elements[i] <= elements[j])
						break;
				}
				if(j==n)
					leaders.push_back(elements[i]);
			}
			reverse(leaders.begin(), leaders.end());
			return leaders;
		}

	101) Reverse the String:
		Problem Statement
			You are given a string 'STR'. The string contains [a-z] [A-Z] [0-9] [special characters]. You have to find the
			reverse of the string.
			For example:
			If the given string is: STR = "abcde". You have to print the string "edcba
			Follow Up:
			Try to solve the problem in 0(1) space complexity.
			Detailed explanation (Input/output format, Notes, Images )
			Constraints:
				1 ≤ T ≤ 10
				1 < STR| ≤ 10 ^ 5
				Where STR is the length of the string STR.
				Time limit: 1 sec.
			Sample Input 1:
				3
				abcde
				coding
				hello1
				Sample Output 1:
				edcba
				gnidoc
				1olleh
				Explanation Of The Sample Input 1:
				For the first test case, STR = "abcde". We need to reverse the string, that is the first element becomes the last element and the last element becomes the first element, the second element becomes the second last element and the second last element becomes the second element and so on. So we get, "edcba".
				Sample Input 2:
				3
				a
				1det@Z
				$1xYuP
				Sample Output 2
				a
				Z@ted1
				PuYx1$

		#include <bits/stdc++.h> 
		string reverseString(string str){
			// string rev;
			// int i=str.length()-1;
			// while(i>=0){
			// 	rev += str[i];
			// 	i--;
			// }
			// return rev;
			
			//or

			reverse(str.begin(), str.end());
			return str;
		}

		//or
			#include <bits/stdc++.h> 
			string reverseString(string str) {
				int i=0, j=str.size()-1;
				
				while(i < j)
					swap(str[i++], str[j--]);
				return str;
			}

		//using Recursion:
			#include <bits/stdc++.h> 
			void reverse(string &z, int s, int e){
				if(s>e)
					return ;

				swap(z[s],z[e]);
				reverse(z, s+1, e-1);
			}

			string reverseString(string str){
				reverse(str,0, str.size()-1);
				return str;
			}
	
	102) Check whether second string can be formed from characters of first string:
		Problem Statement
			You are given two strings STR1 and STR2. You need to check whether STR2 can be
			formed from the characters of STR1. Both the strings can contain any characters.
			For Example:
				If STR1 = "codingninjas" and STR2 = "sing". We can form the second
				string using the characters of the first string. This is because "s",
				"i", "n", "g" are present in the string STR1.
			Constraints:
				1 ≤ T ≤ 100
				1 ≤ STR1|, STR2| ≤ 1000
			Where 'T' is the number of test cases, ISTR1| and [STR2| are the lengths of the strings STR1 and STR2 respectively.
			Time Limit: 1 sec.
			Sample Input 1:
				3
				codingninjas
				sing
				good human
				14good
				coder
				code
				Sample Output 1:
				YES
				NO
				YES
				Explanation Of Input 1:
				The first test case has already been explained in the problem statement.

				For the second test case, STR1 = “good human” and STR2 = “14good”. We cannot form the second string using the characters of the first string. This is because “1” and “4” are not present in the string STR1.

				For the third test case, STR1 = “coder” and STR2 = “code. We can form the second string using the characters of the first string. This is because “c”, “o”, “d”, “e” are present in the string STR1.
				Sample Input 2:
				3
				madam
				adam
				H#LLO
				hello
				orange
				orange
				Sample Output 2
				YES
				NO
				YES
		
		#include <bits/stdc++.h> 
		string canFormSecondString(string str1, string str2){
			if(str2.length() >  str1.length())
				return "NO";
				
			for(int s2=0; s2<str2.length(); s2++){
				int s1;
				for(s1=0; s1<str1.length(); s1++){
					if(str2[s2] == str1[s1]){
						str1[s1] = '>';
						break; 
					}
				}
				if(s1 == str1.length())
					return "NO";
			}
			return "YES";
		}

	103) Base 58:
		Problem Statement
			You are given a number N. Your goal is to convert the number into base 58.
			The Base58 alphabet consists of the following characters:
			"123456789ABCDEFGH|KLMNPORSTUVWXYZabcdefghijkmnopqrstuvwxyz"
			Each byte value from 0 to 57 maps to the alphabet above.
			Conversion Eg: ( according to above mapping).
			Base 10   |	Base 58
			0		|		1
			1		|		2
			10		|		A
			20		|		L
			30		|		W
			53		|		u
			Sample Input 1:
				2
				10
				67
				Sample Output 1:
				B
				2A
				Explanation For Sample Input 1:
				In test case 1:

				If we represent 10 in powers of 58, it will be, 10 = 10*(58^0)
				10 in base 10 corresponds to B in base 58 ( according to the above mapping).
				Thus our answer is: B

				In test case 2:

				If we represent 66 in powers of 58, it will be, 67 = 1*(58^1) + 9*(58^0)
				1 in base 10 corresponds to 2 in base 58, 9 in base 10 corresponds to A in base 58.
				Thus our answer is: 2A
				Sample Input 2:
				3
				4364
				1786
				6978
				Sample Output 2:
				2JF
				Xo
				35K
		#include <bits/stdc++.h> 
		string encodeBase58(int N) {
			string ans;
			string mapper = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
			if(N == 0)
				return "1";
			while(N){
				ans += mapper[N%58];
				N /= 58;
			}
			reverse(ans.begin(), ans.end());
			return ans;
		}

	104) Find Palindromes:
		Problem Statement
			You are given an integer 'N' Your task is to find all palindromic numbers from 1 to 'N'
			Palindromic integers are those integers that read the same backward or forwards.
			Note: Order of numbers should be in the non-decreasing matter.
			For Example:
				You are given 'N' as 12, so the output should be [1, 2, 3, 4, 5, 6, 7, 8, 9, 11], as all
				single-digit numbers are palindromic, and 11 is also a palindromic number.
			Sample Input 1:
					2
					12
					5
				Sample Output 1:
					1 2 3 4 5 6 7 8 9 11
					1 2 3 4 5
				Explanation:
				For the first test case, all the single-digit numbers are palindromic, 
				and the number 11 is also palindromic. Hence the output is [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].

				For the second test case, N is less than 9. Therefore all the numbers from 1 to N 
				are palindromes. Hence the output is [1, 2, 3, 4, 5].
				Sample Input 2:
					2
					15
					22
				Sample Output 2:
					1 2 3 4 5 6 7 8 9 11
					1 2 3 4 5 6 7 8 9 11 22

		// Not Optimized:
			#include <bits/stdc++.h> 
			bool isPalin(string s){
				for(int i=0; i<s.size()/2; i++)
					if(s[i] != s[s.size()-1-i])
						return 0;
				return 1;
			}

			vector<int> getPalindromes(int n) {
				vector<int> ans;

				int i=1;
				while(i <= n){
					if(i < 10)
						ans.push_back(i);
					else{
						string s = to_string(i);
						if(isPalin(s))
							ans.push_back(i);
					}
					i++;
				}
				return ans;
			}

		// Optimized:
			#include <bits/stdc++.h> 
			vector<int> getPalindromes(int n){
				vector<int> palidromes;

				for(int i=1; i<=n; i++) {
					//this will work we used so many built in function,
					//so TLE will be there.
					// string s = to_string(i);
					// reverse(s.begin(), s.end());
					// int rev = stoi(s);
					// if(rev == i){
					// 	palidromes.push_back(i);
					// }
					int num = i;
					int reversed = 0;

					while (num > 0) {
						reversed = reversed * 10 + num % 10;
						num /= 10;
					}

					if (reversed == i) {
						palidromes.push_back(i);
					}
				}
				return palidromes;
			}

			// or
				#include <bits/stdc++.h> 
				vector<int> getPalindromes(int n) {
					vector<int> ans;
					int i=1;
					while(i <= n){
						if(i < 10)
							ans.push_back(i);
						else{
							int reverse = 0, temp = i;
							while(temp){
								reverse = reverse * 10 + temp % 10;
								temp /= 10;
							}

							if(reverse == i)
								ans.push_back(i);
						}
						i++;
					}
					return ans;
				}

	105) Mindbending Product:
		Problem Statement
			You are given an array 'ARR' of size N. You have to construct a Product Array 'P' of the same size such that
			P[i] is equal to the product of all the elements of ARR except ARR[i]. The constraint is that you are not
			allowed to use the division operator.
			For Example:
			For an array {1, 2, 3, 4, 5}:
			The required product array generated from the given array is {120, 60, 40, 30, 24 }
			This can be generated in the following manner:
			For generating 120 we have 2 * 3 * 4 * 5 i.e. the product of other array elements except 1.
			For generating 60 we have 1 * 3 * 4 * 5 i.e. the product of other array elements except 2.
			For generating 40 we have 1 * 2 * 4 * 5 i.e. the product of other array elements except 3.
			For generating 30 we have 1 * 2 * 3 * 5 i.e. the product of other array elements except 4.
			For generating 24 we have 1 * 2 * 3 * 4 i.e. the product of other array elements except 5.
		Sample Input 1:
			2
			5
			10 3 5 6 2
			2
			12 20
			Sample Output 1:
			180 600 360 300 900
			20 12
			Explanation:
			Test Case 1: 
			For the product array P,
			At i=0 we have 3*5*6*2 = 180.
			At i=1 we have 10*5*6*2 = 600. 
			At i=2 we have 10*3*6*2 = 360. 
			At i=3 we have 10*3*5*2 = 300. 
			At i=4 we have 10*3*5*6 = 900
			So, the P array is 180 600 360 300 900

			Test Case 2: 
			For the product array P, 
			At i=0, we have 20. 
			At i=1, we have 12.
			So, the P array is 20 12. 
		vector<long long> getProductArray(int arr[], int n){
			vector<long long> ans;
			if(n==1)
				return {0};
			
			for(int i=0; i<n; i++){
				long long pro =1;
				for(int j=0; j<n; j++){
				if(i==j)
					continue;
				pro *= arr[j];         
				}
				ans.push_back(pro);
			}
			return ans;
		}

	106) Count Even Odd:
		Problem Statement
			You have been given an array/list of integers 'ARR' of size 'N'. Your task is to find two things-
			1. The number of elements that are occurring an Odd number of times.
			2. The number of elements that are occurring Even a number of times.
			For Example:
				ARR = [2, 1, 2, 1, 5, 5, 2]
				Output: 1 2
				2 occurs three(odd) times.
				1 occurs two(even) times.
				5 occurs two(even) times.
			So, the total 1 element is occurring an odd number of times and 2 elements are occurring
			an even number of times.
			Detailed explanation (Input/output format, Notes, Images )
			Constraints:
				1 <= T <= 10^2
				0 <= N <= 5 * 10^3
				1 <= ARR[i] <= 10^9
				Time Limit: 1 sec
		Sample Input 1:
			2
			5
			4 5 1 2 1
			4
			2 1 2 1 
			Sample Output 1:
			3 1
			0 2
			Explanation For Sample 1:
			In the first test case, three integers(4, 5 and 2) occur odd times and the only integer 1 occurs even times.

			In the second test case, no integer occurs odd times and two integers(1 and 2) occurs even times.
			Sample Input 2:
			1
			8
			5 2 9 9 7 5 1 3
			Sample Output 2:
			4 2

		#include <bits/stdc++.h> 
		vector<int> countEvenOdd(vector<int> &arr, int n){
			//NOT optimized
			// int oddOccs=0, evenOcc=0;
			// for(int i=0; i<n; i++){
			// 	int cnt=1;
			// 	if(arr[i] != -1){
			// 		for(int j=i+1; j<n; j++){
			// 			if(arr[i] == arr[j]){
			// 				arr[j] =-1;
			// 				cnt++;
			// 			}
			// 		}
			// 		if(cnt&1)
			// 			oddOccs++;
			// 		else
			// 			evenOcc++;
			// 	}
			// }
			// return {oddOccs, evenOcc};
			unordered_map<int, int> occurrenceMap;
			int oddOccs = 0, evenOcc = 0;

			for (int i = 0; i < n; i++) {
				occurrenceMap[arr[i]]++;
			}

			for (auto const& entry : occurrenceMap) {
				if (entry.second % 2 == 1) {
					oddOccs++;
				} else {
					evenOcc++;
				}
			}
			return {oddOccs, evenOcc};
		}
	
	107) Flip given bits:
		Problem Statement
			You have been given an integer 'NUM' (32 bits) and an array of size 'N'.
			Your task is to flip all the bits of 'NUM' at position 'ARR[i]' where 0<= i <= N-1.
				Constraints:
				1 <= 'T' <= 10
				1 <= 'NUM' <= 10^9
				1 <= 'N' <= 10^5
				1 <= 'ARR[il' <= 31
				Time Limit: 1 sec
			Sample Input 1:
				2
				21
				3
				4 2 1
				40
				1
				4
			Sample Output 1:
				30
				32
			Explanation For Sample Input 1:
				Before flipping
				21 => 10101
				After flipping the 4th, 2nd and 1st bit from the end we get 
				30 => 11110

				Before flipping
				40 => 101000
				After flipping the 4th bit from the end we get 
				32 => 100000
			Sample Input 2:
				1
				5
				3
				6 2 5
				Sample Output 2:
				55
		#include <bits/stdc++.h> 
		int flipSomeBits(int num, vector<int> &arr, int n){
			string s = bitset<32>(num).to_string();
			reverse(s.begin(), s.end());
			
			for(int i=0; i<n; i++){
				if(s[arr[i]-1]=='1'){
					s[arr[i]-1] = '0';
				}else{
					s[arr[i]-1] = '1';
				}
			}
			reverse(s.begin(), s.end());

			//removing leading zeros
			while(s[0] == '0')
				s.erase(0,1);

			// cout<<s<<endl;
			//binary to decimal conversion
			int ans=0, cnt=0;
			for(int i=s.length(); i>=0; i--){
				if(s[i] == '1')
					ans += pow(2,cnt);
				cnt++;
			}

			//or
			// return stoi(s, 0, 2);
			return ans/2;
		}
		//or
			#include <bits/stdc++.h> 
			int flipSomeBits(int num, vector<int> &arr, int n){
				string s = bitset<32>(num).to_string();
				reverse(s.begin(), s.end());
				
				for(int i=0; i<n; i++){
					if(s[arr[i]-1]=='1'){
						s[arr[i]-1] = '0';
					}else{
						s[arr[i]-1] = '1';
					}
				}
				reverse(s.begin(), s.end());
				return stoi(s,0,2);
			}
	
		// Or:
			#include <bits/stdc++.h> 
			int flipSomeBits(int num, vector<int> &arr, int n) {
				string s = bitset<32>(num).to_string();
				// reverse(s.begin(), s.end());
				// cout<<s<<endl;

				for(int i: arr)
					s[32-i] = (s[32-i] == '0') ? '1' : '0';

				// cout<<s;
				// reverse(s.begin(), s.end());
				return stoi(s, 0, 2);
			}

	108) Maximum In Sliding Windows Of Size K:
		Problem Statement
			Given an array/list of integers of length 'N', there is a sliding window of size 'K' which moves from the
			beginning of the array, to the very end. You can only see the 'K' numbers in a particular window at a
			time. For each of the 'N'-'K'+1 different windows thus formed, you are supposed to return the
			maximum element in each of them, from the given array/list.
			Constraints :
				1 <= T <= 50
				1 <= N <= 10^4
				1 <= K <= N
				0 <= ARR[i] <= 10^5
				Where, ARR[i] denotes the i-th element in the array/list.
					Time Limit: 1 sec.
			Sample Input 1 :
				2
				3 1
				1 2 2
				5 2
				4 2 1 4 4
				Sample Output 1 :
				1 2 2
				4 2 4 4
				Explanation To Sample Input 1 :
				In the first test case, 
				The maximum of window {1} is 1.
				The maximum of window {2} is 2.
				The maximum of window {2} is 2.
				So the output will be {1, 2, 2}.

				In the second test case, 
				The maximum of window {4,2} is 4.
				The maximum of window {2,1} is 2.
				The maximum of window {1,4} is 4.
				The maximum of window {4,4} is 4.
				So the output will be {4, 2, 4, 4}.
				Sample Input 2 :
				2
				5 3
				2 2 2 3 3
				7 4
				2 3 1 4 5 1 5
				Sample Output 2 :
				2 3 3
				4 5 5 5
				Explanation To Sample Input 2 :
				In the first test case, 
				The maximum of window {2,2,2} is 2.
				The maximum of window {2,2,3} is 3.
				The maximum of window {2,3,3} is 3.
				So the output will be {2, 3, 3}.

				In the second test case, 
				The maximum of window {2,3,1,4} is 4.
				The maximum of window {3,1,4,5} is 5.
				The maximum of window {1,4,5,1} is 5.
				The maximum of window {4,5,1,5} is 5.
				So the output will be {4, 5, 5, 5}.
		
		//not optimized
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				for (int i = 0; i <= nums.size() - k; i++) {
					// parsing window of size k.
					vector<int> temp(nums.begin() + i, nums.begin() + k + i);
					int mx = *max_element(temp.begin(), temp.end());
					ans.push_back(mx);
				}
				return ans;
			}

		//or
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				for(int i=0; i<nums.size()-k+1; i++){
					vector<int> temp;
					int cnt=k;          //window size
					for (int j = i; cnt > 0; cnt--) {
						temp.push_back(nums[j++]);
					}
					ans.push_back(*max_element(temp.begin(), temp.end()));
				}
				return ans;
			}

		//or
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				for(int i=0; i<nums.size()-k+1; i++){
					vector<int> temp;
					for (int j = i; j < i + k; j++) {
						temp.push_back(nums[j]);
					}
					ans.push_back(*max_element(temp.begin(), temp.end()));
				}
				return ans;
			}
		
		//optimized:
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				std::deque<int> maxDeque;

				for (int i = 0; i < nums.size(); i++) {
					// Remove elements that are out of the current window
					while (!maxDeque.empty() && maxDeque.front() < i - k + 1) {
						maxDeque.pop_front();
					}

					// Remove elements that are less than the current element
					while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
						maxDeque.pop_back();
					}

					// Add the current element to the deque
					maxDeque.push_back(i);

					// The front element of the deque is the maximum in the current window
					if (i >= k - 1) {
						ans.push_back(nums[maxDeque.front()]);
					}
				}
				return ans;
			}

	109)	Day 1: ENG vs NZ: Interesting Toss
		Problem Statement
			In the inaugural match between ENG and NZ, the ICC has replaced the traditional coin flip with a unique game.
			The ICC has provided a set of coins, where 'X" coins are valued at 10 rupees and Y' coins are valued at 75 rupees.
			Each captain, on their turn, selects coins with a total value of exactly 105 rupees and removes them from the
			set. The captain who fails to do so loses the toss. As ENG is the home team for this match, they make the first move.
			Your task is to return 1 if ENG wins this special toss game; otherwise, return 0.
			Example :
				Input: 'X' = 15, 'y' = 1
				Output: 1
			The captain of ENG starts the game and picks one 75 rupee coin and three 10 rupee coins,
			making a total of 105 rupees.
			Now, the captain of NZ cannot make 105 rupees with the remaining coins (12 ten rupee coins). Hence, ENG wins the special toss game.
		// wrong  (not optimized)
			int coinGame(int x, int y) {
				int turn=0;
				int sum;
				sum = x*10 + y*75;
				while(sum>=105){
					sum -= 105;
					turn++;
				}
				if(turn&1)
					return 1;
				return 0;
			}
		
		//wrong (little optimized)
			int coinGame(int x, int y) {
				int cn=0;
				while(y>0){
					y-=1;
					if (x >= 3) {
						x-=3;
						cn++;
					}
				}
				if(cn!=0 && cn%2!=0){
					return 1;
				}
				return 0;
			}

	110) Day 1: ENG vs NZ: Jersey Quest:
		Problem Statement
			The batting lineup of the England cricket team for their match against New Zealand consists of 'N' players standing
			in a line. You have an array 'A' of length 'N' such that 'A[i]' represents the 'i-th player's jersey number.
			In one operation, you can swap any two adjacent players.
			Return the minimum difference between the jersey numbers of any two adjacent players after performing the
			For Example:-
			Let 'N' =5, 'A'= [1, 5, 11, 2, 7].
			We first swap the third and fourth players, "A' becomes [1, 5, 2, 11, 7]. We then swap the second
			and third players, 'A' becomes [1, 2, 5, 11, 71.
			Now, the difference between the first and second jersey numbers is "1'
			It can be shown that this is the minimum possible difference. Thus, the answer is '1'.
			Constraints:-
				1 <= 'T' ‹= 10
				2 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
			The Sum of 'N' overall test cases does not exceed 10^5.
			Time Limit: 1 sec
			Sample Input 1:-
				2
				3 
				4 1 7
				4
				1 4 2 3
				Sample Output 1:-
				3
				1
				Explanation Of Sample Input 1:-
				First test case:-
				Here, the difference between the first and second jersey numbers is 3, which is the minimum possible.
				Thus, the answer is '3'.

				Second test case:-
				Here, the difference between the third and fourth jersey numbers is 1, which is the minimum possible.
				Thus, the answer is '1'.
				Sample Input 2:-
				2
				2
				4 6
				5 
				9 12 5 16 2
				Sample Output 2:-
				2
				3

		#include<bits/stdc++.h>
		int minDifference(vector<int> &a) {
			sort(a.begin(), a.end());
			int minN = INT_MAX;
			for(int i=0; i<a.size()-1; i++){
				int n = a[i+1] - a[i];
				minN = min(minN, n);
			}
			return minN;
		}

	111) Take Away The Bottle:❌
		Problem Statement
			There is a row of numbered bottles, and now you need to take them all away. 
			You can only take several consecutive bottles at a time, and you need to make sure that 
			the bottle number is a palindrome string. Palindrome string refers to the same string read 
			in both forward and reverse directions 
			For example:
				"4664" when read forward and backward will give the same result. Hence it is a palindrome.
				Your task is to find the minimum number of times it takes to remove all bottles.
			Constraints:
				1 <= N <= 500
				1<= bottles[i] <= 1000|
				Time limit: 1 sec
			Sample Input 1 :
				2
				5
				1 3 4 1 5
				3
				4 6 4
				Sample Output 1 :
				3
				1     
				Explanation For Sample Output 1 :
				For test case 1 :
				We can take bottle number 4, then the bottle array will be: 1 3 1 5

				Then we can take 1 3 1 at the same time since it is a palindrome and the array will be: 5
				Then we will take bottle number 5

				For test case 2 :
				We can take all the bottles at once since they form a palindrome
				Sample Input 2 :
				2
				6
				1 2 3 5 3 1
				6
				1 1 2 3 1 1
				Sample Output 2 :
				2
				2

				sample input 3:
					4
						5 
						5 5 20 17 12 
						6 
						13 16 20 17 18 12 
						5 
						16 18 16 3 13 
						4 
						12 13 11 15 
				sample output:
					4
					6
					3
					4

	112) Day 2: PAK vs NED: Run Rate Lift
		Problem Statement
			Pakistan is playing a crucial match against the Netherlands. 
			Pakistan is currently batting and needs to lift their run
			rate from '0' to exactly 'D' runs per over to secure victory.
			Pakistan has two types of batsmen:
			- Explosive Hitters: These batsmen lift the run rate by '3' runs per over.
			- Steady Accumulators: These batsmen lower the run rate by "2' runs per over.
			In one over, Pakistan can send in either an Explosive Hitter or a Steady Accumulator.
			Return the minimum number of overs Pakistan needs to play in order to reach the required run rate of 'D' and secure
			a win against the Netherlands?
			Example:
			'D' = 6
			They can send Explosive Hitter in each of the first two 
			overs and reach the required run rate of '6' per over.
			So, the answer is '2'.
			Constraints :
				1 <= T <= 10
				1 ‹= D <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				0
				12
				Sample Output 1:
				0
				4
				Explanation Of Sample Input 1:
				For test case 1:
				The current run rate is already at '0', so they don't need any more overs.
				So, the answer is '0'. 

				For test case 2:
				They can send Explosive Hitter in each of the first four overs and reach the required run rate of '12' per over.
				So, the answer is '4'. 
				Sample Input 2:
				2
				25
				30
				Sample Output 2:
				10
				10

		int liftStruggle(int d) {
			int over=0;
			if(d%3 ==0)
				return d/3;

			over = d/3;
			int run= over*3;

			while(run != d){
				run +=1;
				over+=2;
			}
			return over;
		}

		//or
		int liftStruggle(int d) {
			int over=0;
			int run=0;
			while(run != d){
				if(run<d){
					run+=3;
					over++;
				}else{
					run-=2;
					over++;
				}
			}
			return over;
		}

	113) Check N numbers:
		Problem Statement
			Given an array 'arr' of 'N' integers, make a number from those set of all integers from the 'arr' such that if number of
			'ith' set bits are greater than the number of 'ith' unset bits then make that 'ith' bit of the new number as set bi
			otherwise make that 'ith' bit as unset bit.
			For Example:
			There are three numbers, say 8, 5 and 10.
			8 can be written as 1000.
			5 can be written as 0101.
			10 can be written as 1010.
			So we can see majority bit at ith position are set bits so ith bit will be 1. Similarly for
			positions of j, kand 1 are set as 0 0 0 respectively.
			Detailed explanation (Input/output format, Notes, Images)
			Input Format:
				The first line contains a single integer 'T' representing the number of test cases.
				Then 'T' test cases follows:
				First line of each test case contains an integer 'N' representing the size of the input array "arr'.
			Next line contains 'N' space separated integers denoting the elements in the 'arr'.
			Output format :
				Output of each test case an integer as per the condition.
			Constraints:
				1 ‹= T <= 5
				1 ‹= N ‹= 10 ^ 3
				1 <= arr[i] <= 5 * (10 ^ 3)
				Time Limit: 1sec
		Sample Input 1:
			2
			3
			8 4 2
			3
			8 8 2
			Sample Output 1:
			0
			8
			Explanation For Sample Test Case 1:
			Test Case 1 :
			Numbers can be represented in bits as:
			1 0 0 0
			0 1 0 0
			0 0 1 0
			i j k l
			Number of set bits for ith index is 1. Number of unset bits for ith index is 2. 
			Therefore the number of unset bits for ith index is greater than the number 
			of set bits for ith index. So ith bit for the number will be 0.

			Similarly for jth, kth and lth bit will be 0. As the number of unset bits is greater than 
			the number of set bits. Answer will be 0 0 0 0 which represents number 0.

			Test Case 2:
			Numbers can be represented in bits as
			1 0 0 0
			1 0 0 0
			0 0 1 0
			i j k l

			Number of set bits for ith index is 2. Number of unset bits for ith index is 1. 
			Therefore the number of set bits for ith index is greater than the number of unset 
			bits for ith index. So ith bit for the number will be 1.

			Similarly for jth, kth and lth bit will be 0. As the number of unset bits is greater 
			than the number of set bits. Answer will be 1 0 0 0 which represents the number 8.
			Sample Input 2:
			2
			5
			1 2 3 4 5
			4
			6 7 8 9
			Sample Output 2:
			1
			0

			Sample Input 3:
				5
				1 
				87
				10 
				64 92 77 36 61 93 45 56 97 81 
				10 
				11 47 65 58 45 76 26 93 13 24 
				10 
				3 87 68 41 84 0 74 39 47 29 
				10 
				36 30 6 65 82 69 89 74 27 96
				Sample Output 3:
					87
					77
					9
					5
					64
 
		#include <bits/stdc++.h> 
		int getNewNum(vector<int> arr, int n) {
			string s;

			for(int j=0; j<32; j++){
				int cnt=0;
				for(int i=0; i<n; i++){
					if(arr[i]&1)
						cnt++;
					arr[i] >>=1;
				}

				int numsOfzero = n - cnt;
				int numsOfone = cnt;

				if(numsOfone> numsOfzero)
					s += '1';
				else
					s += '0';
			}
			reverse(s.begin(), s.end());
			// cout<<s<<endl;
			return stoi(s,0,2);				//converting string from binary to decimal
		}

	114) Day 27 : Magician and Chocolates:
		Problem Statement
			In a magic event, you are given 'N' bags, each bag containing 'A[i]' chocolates. In one unit of time, you can choose
			any bag 'ї and eat all the chocolates 'A[i]' in that bag and then the magician fills the ith bag with floor('A[i]' / 2)
			chocolates. Your task is to find the maximum number of chocolate you can eat in 'K' units of time.
			Since the answer could be large, return answer modulo 10^9 + 7.
			For Example:
			For the array [ 4, 7, 9, 10] and 'k'=2
			In the first step, we can choose the last bag. So the answer will be 10 and the array will be [4,7, 9, 5].
			In the second step, we can choose the second last bag. So the answer will be 19 and the array
			will be [4, 7, 4, 5].
			So the final output will be 19.
			Constraints:
				1 <= Т ‹= 100
				1 ‹= N <= 10^5
				1 ‹= ARR[i] ‹= 10^5]
				Time Limit: 1 sec.
			Sample Input 1:
				2
				4 1
				3 8 2 4
				4 2
				10 4 7 22
				Sample Output 1:
				8
				33
				Explanation For Sample Output 1:
				For the first test case,
				In the first step, we can choose the second bag. So the answer will be 8 and the array will be [3, 4, 2, 4].
				So, the final answer will be 8.

				For the second test case,
				In the first step, we can choose the last bag. So the answer will be 22 and the array will be [10, 4, 7, 11].
				In the second step, we can choose the last bag. So the answer will be 33 and the array will be [10, 4, 7, 5].
				So, the final answer will be 33.
				Sample Input 2:
				2
				5 3
				3 6 10 12 8
				4 1
				2 10 4 3
				Sample Output 2:
				30
				10
		
			Sample Input 3:
			5
			6 100
			1 1 1 1 1 1
			6 2
			1 1 1 1 1 1
			6 10
			1 2 3 4 5 6
			6 6
			6 5 4 3 2 1
			6 4
			1 3 4 6 10 200
			Sample Output 3:
				6
				2
				29
				23
				375
		
		#include <bits/stdc++.h> 
		int maximumChocolates(vector<int> &arr, int k){
			long long sum=0;
			while(k>0){
				auto mx = max_element(arr.begin(), arr.end());
				sum +=*mx;
				int index = distance(arr.begin(),mx);
				arr[index] /= 2;
				k--;
			}
			return sum;
		}

	115) Distinct Enemies:
		Problem Statement
			Ninja has somehow got the list of enemies and their strength. Now ninja wants to make a plan according to enemies
			on the basis of their strength. But ninja wants to first count the distinct type of enemies as some of them have the
			same strength.
			So help our ninja in counting the distinct type of enemies from the given array where 'ARR[i]' represents the strength
			of the i-th enemy.
			Note:
				Two enemies are distinct if their strengths are different.
			Constraints:
				1 <= T <= 5
				1 <= N <= 5000
				0 <= ARR[i] < 10 ^ 6
				Where 'ARR[i]' represents the elements of the array.
			Time Limit: 1 sec
			Sample Input 1 :
				2
				5
				2 3 5 3 2
				5
				2 2 2 2 3
				Sample Output 1 :
				3
				2
				Explanation For Sample Input 1 :
				Test Case 1:
				For the first test case, the given array is { 2, 3, 5, 3, 2 } so we return ‘3’ 
				as we can say ‘3’ distinct values are present in the array i.e { 2, 3, 5}.

				Test Case 2:
				For this test case, the given array is { 2, 2, 2, 2, 3 } so we return ‘2’ 
				as we can say ‘2’ distinct values are present in the array i.e { 2, 3}.
				Sample Input 2 :
				2
				2
				5 5
				5
				1 6 7 9 4
				Sample Output 2 :
				1
				5
		#include <bits/stdc++.h> 
		int distinctEnemies(vector<int> &arr, int n) {
			set<int> DifferentValues;
			for (int i = 0; i < n; i++) {
				DifferentValues.insert(arr[i]);
			}
			return DifferentValues.size();
		}

	116) Find Minimum Number Of Coins:
		Problem Statement
			Given an infinite supply of Indian currency i.e. [1, 2, 5, 10, 20, 50, 100, 500, 1000] valued coins and an amount 'N'.
			Find the minimum coins needed to make the sum equal to 'N'. You have to return the list containing the value of coins
			required in decreasing order.
			For Example
				For Amount = 70, the minimum number of coins required is 2 i.e an Rs. 50 coin and a Rs. 20 coin.
			Note
			It is always possible to find the minimum number of coins for the given amount. So, the answer
			will always exist.
			Sample Input 1
				13
				Sample Output 1
				10 2 1
				Explanation Of Sample Input 1
				The minimum number of coins to change is 3 {1, 2, 10}.
				Sample Input 2
				50
				Sample Output 2
				50
				Constraints
				1 <= 'N' <= 10^5

				Time Limit: 1 sec

		//optimized
			vector<int> MinimumCoins(int n){
				int sum =0;
				vector<int> ans;
				int total = n;

				while(sum != total){
					//check by 1000
					if(n>=1000){
						ans.push_back(1000);
						sum += 1 * 1000;
						n -= 1000;
					}
					//check by 500
					else if (n >= 500) {
						ans. push_back(500);
						sum += 1 * 500;
						n -= 500;
					}

					//check by 100
					else if (n >= 100) {
						ans. push_back(100);
						sum += 1 * 100;
						n -= 100;
					}
					
					//check by 50
					else if (n >= 50) {
						ans. push_back(50);
						sum += 1 * 50;
						n -= 50;
					}
					
					//check by 20
					else if (n >= 20) {
						ans. push_back(20);
						sum += 1 * 20;
						n -= 20;
					}

					//check by 10
					else if (n >= 10) {
						ans.push_back(10);
						sum += 1 * 10;
						n -= 10;
					}
					//check by 5
					else if (n >= 5) {
						ans. push_back(5);
						sum += 1 * 5;
						n -= 5;
					}
					//check by 2
					else if (n >= 2) {
						ans.push_back(2);
						sum += 1 * 2;
						n -= 2;
					}
					//check by 1
					else{
						ans.push_back(1);
						sum +=1 * 1;
						n -= 1;
					}
				}
				return ans;
			}

		//much more optimized
			vector<int> MinimumCoins(int n) {
				vector<int> ans;
				const std::vector<int> coinDenominations = {1000, 500, 100, 50, 20, 10, 5, 2, 1};

				for (const int denomination : coinDenominations) {
					while (n >= denomination) {
						ans.push_back(denomination);
						n -= denomination;
					}
				}

				return ans;
			}
	
	117) Product Of Array Except Self:
		Problem Statement
			You have been given an integer array/list (ARR) of size N. You have to return an array/list PRODUCT such
			that PRODUCT[] is equal to the product of all the elements of ARR except ARR[i].
			Note:
				Each product can cross the integer limits, so we should take modulo of the operation.
				Take MOD = 10^9 + 7 to always stay in the limits.
			Follow Up:
			Can you try solving the problem in 0(1) space?
			Constraints:
				1 <= Т <= 100
				0 <= N <= 10^5
				0 <= ARRi1 <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				1 2 3
				3
				5 2 2
				Sample Output 1 :
				6 3 2
				4 10 10
				Explanation For Sample Output 1 :
				Test case 1 : Given array = {1, 2, 3] 
				Required array = [2 * 3, 1 * 3, 1 * 2] = [6, 3, 2]
				Test case 2 : Given array = {5, 2, 2] 
				Required array = [2 * 2, 5 * 2, 5 * 2] = [4, 10, 10]
				Sample Input 2 :
				2
				1
				100
				2
				1 2
				Sample Output 2 :
				1
				2 1

		// Not Optimized:
			int *getProductArrayExceptSelf(int *arr, int n) {
				int MOD = 1e9+7;
				int *newArr = new int[n];
				for(int i=0; i<n; i++){
					int prod = 1;
					for(int j =0; j<n; j++){
						if(i == j)
							continue;
						prod = (prod*arr[j]) %MOD;
					}
					newArr[i] = prod;
				}

				return newArr;
			}

		int *getProductArrayExceptSelf(int *arr, int n) {
			int *ans = new int[n];
			long long temp = 1;
			int mod = 1e9 + 7;

			for (int i = 0; i < n; i++) {
				ans[i] = temp;
				temp = (temp * arr[i]) % mod;
			}

			temp = 1;
			for (int i = n - 1; i >= 0; i--) {
				ans[i] = (ans[i] * temp) % mod;
				temp = (temp * arr[i]) % mod;
			}

			return ans;
		}
	
	118) Factorial of a Number:
		Problem Statement
			You are given an integer 'N'. You have to print the value of Factorial of 'N' The Factorial of a number 'N' is
			defined as the product of all numbers from 1 to 'N'
			For Example:
			Consider if 'N' = 4, the Factorial of 4 will be the product of all numbers from 1 to 4,
			which is 1 * 2 * 3 * 4 = 24. 
			Hence, the answer is 24.
			Input Format:
				The first line of the input contains an integer, 'T,' denoting the number of test cases.
				The first and only line of each test case contains one single integer 'N' representing the given integer.
			Output Format:
				For each test case, print the value of factorial of 'N'.
				Print the output of each test case in a separate line.
			Constraints:
				1 <= T <= 10
				1 <= N <= 100
				Time limit: 1 sec
			Sample Input 1:
				2
				4
				3
				Sample Output 1:
				24
				6
				Explanation Of Sample Input 1:
				For the first test case, 
					The Factorial of 4 is the product of all numbers from 1 to 4, 
					which is 1 * 2 * 3 * 4 = 24. Hence, the answer is 24.

				For the second test case,
					The Factorial of 3 is the product of all numbers from 1 to 3, which is 1 * 2 * 3 = 6. 
					Hence, the answer is 6.
				Sample Input 2:
				2
				8
				11
				Sample Output 2:
				40320
				39916800

		//Partially Accepted
			void factorial(int n) {
				vector<int> factAns;
				int originalNum = n;
				while(n>9){
					//num spliting
					factAns.insert(factAns.begin(), n%10);
					n/=10;
				}
				
				//inserting last digit manually
				factAns.insert(factAns.begin(), n%10);

				n = originalNum;
				int prod, carry=0, lastDigit;

				while(--n) {
					vector<int> temp;
					for(int i=factAns.size()-1; i>=0; i--){
						prod = factAns[i] * n + carry;
						lastDigit = prod %10;
						carry = prod/10;
						temp.insert(temp.begin(), lastDigit);
					}
					while(carry){
						temp.insert(temp.begin(), carry%10);
						carry /=10;
					}
					factAns = temp;
				}

				for(int i=0; i<factAns.size(); i++) {
					cout<<factAns[i];
				}
				cout<<endl;
			}
	
		//more optimized:
			void factorial(int n) {
				if (n <= 1) {
					std::cout << "1" << std::endl;
					return;
				}

				std::vector<int> factAns;
				factAns.push_back(1);  // Initialize the result with 1

				for (int i = 2; i <= n; ++i) {
					int carry = 0;
					for (int j = 0; j < factAns.size(); ++j) {
						int prod = factAns[j] * i + carry;
						factAns[j] = prod % 10;
						carry = prod / 10;
					}
					while (carry) {
						factAns.push_back(carry % 10);
						carry /= 10;
					}
				}

				// Print the result in reverse order
				for (int i = factAns.size() - 1; i >= 0; --i) {
					std::cout << factAns[i];
				}
				std::cout << std::endl;
			}

	119) Find the Winner:
		Problem Statement
			You have been given an array/list of "VOTES" which contains the name of the candidates where each entry
			represents the name of the candidate who got the vote.
			You are supposed to find the name of the candidate who received the maximum number of votes. If there is a
			tie, then print the lexicographically smaller name.
			Input Format:
				The first line contains an integer 'T' denoting the number of test cases. Then each test
				case follows.
				The first input line of each test case contains an integer 'N' denoting the total number
				of votes cast.
				Each of the next 'N' lines contains the name of the candidate who received the vote.
			Output Format :
				For each test case, print the name of the candidate who received the maximum number of
				votes.
			Print the output of each test case in a separate line.
			Note:
				You are not required to print the expected output; it has already been taken care of. Just
				implement the function.
			Constraints :
				1 <= T <= 50
				1 <= 'N' <= 10^3
				1 <= NAME <= 20
				Where N' is the number of votes cast and |NAME| denotes the length of the candidate's
				name.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				John
				Tim
				Marry
				John
				2
				Rahul
				Ankur
				Sample Output 1 :
				John
				Ankur
				Explanation For Sample Intput 1 :
				For the first test case, “John” has received the maximum number of votes (2 votes).

				For the second test case, both “Rahul” and “Ankur” has received one vote each since “Ankur” is lexicographically smaller than “Rahul”, print “Ankur”.
				Sample Input 2 :
				2
				1
				Arya
				2
				Atul
				Atul    
				Sample Output 2 :
				Arya
				Atul
				Explanation For Sample Intput 2 :
				For the first test case, “Arya” is the only candidate in the election who has received the maximum number of votes.  

				For the second test case, “Atul” has received all the votes.

		#include <bits/stdc++.h> 
		string getWinner(vector <string> & votes) {
			int mx = 1;
			vector<string> mxString = {votes[0]};
			for(int i=0; i<votes.size(); i++){
				int cnt =1;
				for(int j=i+1; j<votes.size(); j++){
					if(votes[i] == votes[j]){
						cnt++;
					}
				}
				if(cnt == mx){
					mxString.push_back(votes[i]);
				}

				if(cnt > mx){
					mx = cnt;
					mxString.clear();
					mxString.push_back(votes[i]);
				}
			}
			sort(begin(mxString), end(mxString));
			return mxString[0];
		}

	120) Day 10 : Minimum Operations:
		Problem Statement
			You are given an array 'ARR' of 'N' positive integers. You need to find the minimum number of operations
			needed to make all elements of the array equal. You can perform addition, multiplication, subtraction or
			division with any element on an array element.
			Addition, Subtraction, Multiplication or Division on any element of the array will be considered as a single
			operation.
			Example:
				If the given array is [1,2,3] then the answer would be 2. One of the ways to make all the
				elements of the given array equal is by adding 1 to the array element with value 1 and
				subtracting 1 from the array element with value 3. So that final array would become
				[2,2, 2].
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5
				0 <= ARR[il <= 10^5
			Where 'ARR[i]' is the element of the array 'ARR' at index 'i'.
				Time Limit: 1 sec
			Sample Input 1:
				1
				4
				1 2 3 4
				1
				5
				Sample Output 1:
				3
				0
				Explanation For Sample Output 1:
				In test case 1, There can be many ways by which we can convert the array elements equal, one of the way is:

				1 + 2 = 3
				2 + 1 = 3
				4 - 1 = 3

				Here the first operand is the element of the array and the second operand is the operation that we did for making all the numbers of the array equal.

				Hence, we did 3 operations to change the elements of the array to 3. Hence the answer is 3.

				In test case 2, There is only 1 element and hence no need to make equal and so answer is 0.
				Sample Input 2:
				2
				3
				2 4 2
				5
				1 2 1 4 1
				Sample Output 2:
				1
				2
				Explanation For Input 2:
				In test case 1, by dividing 4 by 2 (i.e. 4 / 2) we can have all the elements equal to 2. Thus only 1 operation is performed and so answer is 1.

				In test case 2, There can be many ways by which we can convert the array elements equal, one of the way is:

				2 / 2 = 1
				4 / 4 = 1

				Here the first operand is the elements of the array and the second operand is the operation that we did for making all the numbers of the array equal.

				Hence, we did 2 operations to change the elements of the array to 2. Hence the answer is 2.

		//own solution:
			#include <bits/stdc++.h> 
			int minimumOperation(vector<int> &arr, int n) {
				if(n == 1)
					return 0;
				
				unordered_map<int, int> occs;
				for(int i=0; i<n; i++){
					occs[arr[i]]++;			//storing the frequency of Elements
				}
				vector<int> maxOccurenceStorer;
				for(auto i=occs.begin(); i!= occs.end(); i++){
					maxOccurenceStorer.push_back(i->second);		//storing the repetition of element
				}
				int mxRepetFromOccs = *max_element(maxOccurenceStorer.begin(), maxOccurenceStorer.end());		//extracting the element repeated maximum no.of times.
				return n-mxRepetFromOccs;
			}
		
		//or
			#include <bits/stdc++.h> 
			int minimumOperation(vector<int> &arr, int n) {
				unordered_map<int,int>mpp;
				for(int i=0;i<n;i++)
				{
					mpp[arr[i]]++;			//storing the occurrences of element
				}
				int max_freq=INT_MIN;
				for(auto it:mpp)
				{
					max_freq=max(max_freq,it.second);		//picking the element which is occurred maximum times

				}
				return n-max_freq;
			}

	121) Day 3: AFG vs BAN: Team Selection:
		Problem Statement
			As a team selector for the upcoming matches, you are given an array 'A' of 'N' players, where 'A[i] represents
			the skill level of the "i-th' player.
			To maximize your chances of winning, you are tasked with selecting a team of exactly 'K' players, each with
			a skill level of "9".
			If it is possible to select such a team, return 1. Otherwise, return 0.
			For Example :
				Let 'N' = 5, 'A' = [ 1, 9, 2, 3, 9 ], 'K' = 2.
				The team consisting of the "1-st' and '4-th' players has a skill level array of [ 9, 9 ].
				Therefore, it is possible to select a team of 'K = 2' players, each with a skill level of
				"9".
			Constraints :
				1 <= 'T' <= 10
				1 <= 'K' <= 'N' <= 10^5
				0 <= 'A[i]' <= 9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4 1
				9 6 0 9
				5 3
				1 1 0 3 7
				Sample Output 1 :
				1
				0
				Explanation Of Sample Input 1 :
				First test case:-
				The team consisting of only the ‘0-th’ player has a skill level array of [ 9 ]. 
				Therefore, it is possible to select a team of ‘K = 1’ players, each with a skill level of ‘9’. 

				Thus, the answer is '1'.

				Second test case:-
				None of the players have a skill level of ‘9’. 
				Therefore, it is impossible to select a team of ‘K = 3’ players, each with a skill level of ‘9’. 
				Thus, the answer is '0'.
				Sample Input 2 :
				2
				4 2
				0 0 9 1
				6 6
				9 9 9 9 9 9
				Sample Output 2 :
				0
				1
		int nines(int n, vector<int> &a, int k) {
			int cnt=0;
			for(int i=0; i<n; i++){
				if(a[i] == 9)
					cnt++;
			}
			if(cnt>=k)
				return 1;

			return 0;
		}

	122) Power of Four:
		https://leetcode.com/problems/power-of-four/description/
		Given an integer n, return true if it is a power of four. Otherwise, return false.
				An integer n is a power of four, if there exists an integer x such that n == 4x.
				Example 1:
					Input: n = 16
					Output: true
					Example 2:

					Input: n = 5
					Output: false
					Example 3:

					Input: n = 1
					Output: true

				Constraints:
					-231 <= n <= 231 - 1

		class Solution {
			public:
			bool isPowerOfFour(int n) {
				if(n==1)
					return 1;
				
				for(int i=1; ;i++){
					long long currPOW = pow(4,i);
					if(currPOW == n)
						return 1;
					if(currPOW>n)
						return 0;
				}
				return 0;
			}
		};
	
	123) Power of Three:
		https://leetcode.com/problems/power-of-three/description/
		Given an integer n, return true if it is a power of three. Otherwise, return false.
		An integer n is a power of three, if there exists an integer x such that n == 3^x.
		Example 1:
		Input: n = 27
		Output: true
		Explanation: 27 = 33

		Example 2:
		Input: n = 0
		Output: false
		Explanation: There is no x where 3x = 0.
		Example 3:

		Input: n = -1
		Output: false
		Explanation: There is no x where 3x = (-1).
	
		Constraints:
			-231 <= n <= 231 - 1

		Follow up: 
			Could you solve it without loops/recursion?


		class Solution {
			public:
			bool isPowerOfThree(int n) {
				if(n<1)
					return 0;
				for(int i=0; ;i++){
					long long currPOW = pow(3,i);
					if(n == currPOW)
						return 1;
					
					if(currPOW>n)
						return 0;
				}
				return 0;
			}
		};

		//without using loops or recursion:
			class Solution {
				public:
				bool isPowerOfThree(int n) {
					if(n<1)
						return 0;
					double p = log10(n)/ log10(3);

					if(p - (int)p == 0)
						return 1;
					return 0;
				}
			};

	124) Binary strings with no consecutive 1s
		Problem Statement
			You have been given an integer N. Your task is to generate and return all binary strings of length 'N' such
			that there are no consecutive 1's in the string.
			A binary string is that string which contains only '0' and '1'
			For Example:
				Let 'N'=3, hence the length of the binary string would be 3.
				We can have the following binary strings with no consecutive 1s:
				000 001 010 100 101.
			Sample Input 1:
				4
				Sample Output 1:
				0000 0001 0010 0100 0101 1000 1001 1010 
				Explanation Of Sample Input 1:
				For N = 4 we get the following Strings:

				0000 0001 0010 0100 0101 1000 1001 1010 

				Note that none of the strings has consecutive 1s. Also, note that they are in a lexicographically increasing order.
				Sample Input 2:
				2
				Sample Output 2:
				00 01 10
				Constraints:
				1 <= 'N' <= 20

				Time limit: 1 second

		//own
			bool checkIfConsecutive(string inString){
				char frstChar = inString[0];
				for(int i=1; i<inString.length(); i++)
					if(inString[i-1]=='1' && inString[i]=='1')
						return 0;
				return 1;
			}
			vector<string> generateString(int N) {
				vector<string> ans;
				for (int i = 0; i < (1 << N); i++) {
					string startS = bitset<32>(i).to_string().substr(32 - N);
					if (checkIfConsecutive(startS)) {
						ans.push_back(startS);
					}
				}
				return ans;
			}

		//or (optional)
			bool checkIfConsecutive(const string& inString) {
				char prevChar = '0'; // Initialize prevChar to '0'
				for (char currentChar : inString) {
					if (prevChar == '1' && currentChar == '1') {
						return false;
					}
					prevChar = currentChar; // Update prevChar
				}
				return true;
			}

			vector<string> generateString(int N) {
				vector<string> ans;
				string startS(N, '0'); // Initialize with N '0's
				
				while (true) {
					if (checkIfConsecutive(startS)) {
						ans.push_back(startS);
					}

					// Increment startS manually (simulating binary addition)
					int carry = 1;
					for (int i = N - 1; i >= 0; i--) {
						if (startS[i] == '0' && carry == 1) {
							startS[i] = '1';
							carry = 0;
						} else if (startS[i] == '1' && carry == 1) {
							startS[i] = '0';
						}
					}

					// If carry is still 1, we've reached the end
					if (carry == 1) {
						break;
					}
				}

				return ans;
			}
	
	125) Overlapping ABBA
		-Simple words checking that string should contain 'AB' then 'BA' in any order.
		-if the string contain "AB" then "BA" or "BA" then "AB", & they are not Overlapping with each other then 
		 return true else false.
		Problem Statement
			Anish is given a string S and has been asked to determine if the given string S contains two non-overlapping
			substrings "AB" and "BA" (the substrings can go in any order).
			As a friend of Anish, your task is to return "True" if the string S contains two non-overlapping substrings "AB"
			and "BA" (the substrings can go in any order) otherwise return "False" (without quotes).
			Example:-
				The string "ABBA" has two non-overlapping substrings "AB" and
				will be printed(without quotes)
				respectively. So "True"
			Constraints :
				1 <= T <= 10
				1 <= |S| <= 10^4
				The string S contains uppercase Latin letters only.
				Time Limit = 1 sec
		Sample Input 1 :
			2
			ABA
			BACFAB
			Sample Output 1 :
			False
			True
			Explanation For Sample Output 1 :
			In the first test case, there are no two non-overlapping substrings, so “False” is printed.

			In the second test case, there are two non-overlapping substrings (BACFAB), so “True” is printed. 
			Sample Input 2 :
			2
			ABBA
			AXBYBXA
			Sample Output 2 :
			True
			False

		// Correct:
			bool findOverlap(string &s){
				int ABcnt =0, BAcnt=0;
				for(int i=0; i<s.size()-1; i++){
					if(s[i] == 'A' && s[i+1] == 'B'){
						ABcnt = 1;
						s[i] = '0';
						s[i+1] = '0';
					}else if(s[i] == 'B' && s[i+1] == 'A'){
						BAcnt=1;
						s[i] = '0';
						s[i+1] = '0';
					}

					if(ABcnt && BAcnt)
						return 1;
				}
				return 0;
			}

		// Wrong wont work on Test Case 'ABAB'
			bool findOverlap(string &s){
				int cnt=0;
				for(int i=1; i<s.length(); i++){
					if(s[i] == 'A' && s[i-1] == 'B'){
						// s[i] = '0';						//replacing A, B with 0, so that it should not match again with A, B.
						// s[i-11] = '0';
						i++;
						cnt++;
					}
					if(s[i] == 'B' && s[i-1] == 'A'){
						// s[i] = '0';
						// s[i-11] = '0';
						i++;
						cnt++;
					}
				}
				if(cnt >= 2)
					return 1;
				return 0;
			}

			//or
			bool findOverlap(string &s){
				int cnt=0;
				for(int i=0; i<s.length(); i++)
					if((s[i] == 'A' && s[i+1] == 'B') ||(s[i] == 'B' && s[i+1] == 'A'))
						s[i] = '0', s[i+1]='0',i++, cnt++;

				if(cnt >= 2)
					return 1;
				return false;
			}

	126) K-th Symbol in Grammar:
		We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, 
			we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
			For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
			Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

			Example 1:
				Input: n = 1, k = 1
				Output: 0
				Explanation: row 1: 0
				Example 2:

			Input: n = 2, k = 1
				Output: 0
				Explanation: 
				row 1: 0
				row 2: 01

			Example 3:
				Input: n = 2, k = 2
				Output: 1
				Explanation: 
				row 1: 0
				row 2: 01
			Constraints:
				1 <= n <= 30
				1 <= k <= 2n - 1

		//Not optimized:
			class Solution {
				public:
				int kthGrammar(int n, int k) {
					string s="0", newString;
					for(int i=2; i<=n; i++){
						int a=0;
						while(a<s.length() && a<k){
							if(s[a] == '0'){
								newString += "01";
							}else{
								newString += "10";
							}
							a++;
						}
						s = newString;
						newString = "";
					}
					return s[k-1]-48;
				}
			};

		//optimized:	
			class Solution {
				public:
				int kthGrammar(int n, int k) {
					if (n == 1 && k == 1) 
							return 0;

						// Calculate the midpoint of the previous row
						int mid = 1 << (n - 2);

						// If k is in the first half of the row, we can recursively find it in the previous row
						if (k <= mid) 
							return kthGrammar(n - 1, k);

						// If k is in the second half, we flip the bit from the previous row's result
						return 1 - kthGrammar(n - 1, k - mid);
				}
			};

	127) Reverse Words In A String:
		Problem Statement
			You are given a string 'str'of length 'N' Your task is to reverse the original string word by word.
			There can be multiple spaces between two words and there can be leading or trailing spaces but in the
			output reversed string you need to put a single space between two words, and your reversed string should
			not contain leading or trailing spaces.
			Example :
				If the given input string is "Welcome to Coding Ninjas", then you should return "Ninjas
				Coding to welcome" as the reversed string has only a single space between two words and
				there is no leading or trailing space.
			Sample Input 1 :
				Welcome to Coding Ninjas
				Sample Output 1:
					Ninjas Coding to Welcome
				Explanation For Sample Input 1:
					You need to reduce multiple spaces between two words to a single space 
					in the reversed string and observe how the multiple spaces, leading and trailing spaces have been removed.
				Sample Input 2 :
					I am a star
				Sample Output 2:
					star a am I
				Explanation For Sample Input 2:
					Your reversed string should not contain leading or trailing spaces.
				Constraints :
					0 <= N <= 10^5
					Time Limit: 1 sec
				Follow-Up:
					If the string data type is mutable in your language, can you solve it in place with O(1) extra space?

		string reverseString(string &str){
			vector<string> holder;
			string temp;
			for(int i=0; i<str.length(); i++){
				if(str[i] == ' '){
					if(!temp.empty()){
						holder.push_back(temp);
						temp.clear();
					}
					continue;
				}
				temp += str[i];	
			}
			
			//inserting last strig manually
			holder.push_back(temp);

			reverse(holder.begin(), holder.end());
			string ans;
			for(int i=0; i<holder.size(); i++){
				ans += holder[i];
				if(i!= holder.size()-1)
					ans += ' ';
			}

			//removing leading spaces
			while(ans[0] == ' '){
				ans.erase(0,1);
			}

			return ans;
		}

	128) Strobogrammatic Number (Problem no-23 Refer):
		Problem Statement
			Given a string 'N' that represents a number, you need to check if the given number is a strobogrammatic number or not.
			A strobogrammatic number is a number that looks the same when rotated by 180.
			In other words, a number that on rotating right side up and upside down appears the same is a strobogrammatic number.
			For Example:
				'986' is a strobogrammatic number because on rotating 986' by 180, "986' will be obtained.
			986		---180॰--> 986
			8008		---180॰--> 8008
			Constraints:
				1 <= T ‹= 50
				0 < = N <= 10^5
				Time limit: 1 sec
			Sample Input 1:
				2
				191
				8008
				Sample Output 1:
				False
				True
				Explanation Of Sample Input 1:
				Test Case 1: On rotating ‘191’ by 180, ‘161’ will be formed. So ‘191’ is not a strobogrammatic number.

				Test Case 2: On rotating ‘8008’, ‘8008’ will be obtained. So ‘8008’ is a strobogrammatic number.

				Sample Input 2:
				2
				8888
				543
				Sample Output 2:
				True
				False
		#include <bits/stdc++.h> 
		bool isStrobogrammatic(string &n) {
			for(int i=0; i<n.length(); i++)
				if(n[i] == '2' || n[i] == '3' || n[i] == '4' || n[i] == '5' || n[i] == '7')
					return 0;

			string revrs = n;
			reverse(revrs.begin(), revrs.end());

			for(int i=0; i<revrs.length(); i++){
				if(revrs[i] == '9'){
					revrs[i] = '6';
					continue;
				}
				if(revrs[i] == '6'){
					revrs[i] = '9';
				}
			}

			if(n == revrs)
				return 1;
			return 0;
		}

		// or
			#include <bits/stdc++.h> 
			bool isStrobogrammatic(string &n) {
				if(n.find('2') != string::npos || 
					n.find('3')!= string::npos || 
					n.find('4')!= string::npos || 
					n.find('5')!= string::npos ||
					n.find('7')!= string::npos)
						return 0;
					
				string s;
				for(int i=0; i<n.length(); i++){
					// you can use either += this operator of push_back syntax to add value into string s
					if(n[i] == '1')
						s += '1';
					else if(n[i] == '6')
						s += '9';
					else if(n[i] == '8')
						s.push_back('8');
					else if(n[i] == '9')
						s.push_back('6');
					else                            //default case for n[i] == '0'
						s.push_back('0');
				}

				// reverse the new string s
				// if reversed string is same as that of n, then we can say that its Strobogrammatic
				reverse(s.begin(), s.end());
				if(s == n)
					return true;
				return 0;
			}
	
	129) Day 21: AUS vs NED: Sub-Squad
		-just have to return the total distinct number present in vector
		Problem Statement
			For the preparation of the upcoming Australia vs Netherlands world cup match, Australia is in the process of
			rearranging their squad. They have a squad of 'N' players represented by the array 'A', where the "ith' player
			has A[i] skill level.
			In one operation, you can rearrange the squad by swapping any two players. 
			Return the maximum length of any sub-squad after performing some operations such that all skill levels in
			that sub-squad are different.
			Example:-
				Let 'N' = 5, 'A' = [1, 3, 2, 3, 4].
				We can swap players at indexes 4 and 5 (1-based indexing)-
				So, our answer is 4.
				-here total 5 elements are there in vector but distinct elements are 1,2,3 & 4 ie. total 4 element unique.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' ‹= 10^5
				1 <= 'A[i]' <= 10^5
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				5
				1 4 1 3 1
				3
				2 5 1
				Sample Output 1:-
				3
				3
				Explanation Of Sample Input 1:-
				First test case:-
				Sub-squad from index 2 to 4 can be our answer.
				So, our answer is 3.

				Second test case:-
				All the players of the squad have distinct skill level.
				So, our answer is 3.
				Sample Input 2:-
				2
				2
				1 1
				4
				9 6 6 9
				Sample Output 2:-
				1
				2

		#include<bits/stdc++.h>
		int subsquad(vector<int> &a) {
			set<int> unique;
			for(int i=0; i<a.size(); i++)
				unique.insert(a[i]);
			return unique.size();
		}

	130) Day 20: SA vs BAN: Best Team:
		Problem Statement
			During this World Cup, brawls arise among fans about which team is the best. Since the strength of the team
			is a subjective matter, the ICC decided the strength by the number of fans a team has.
			You are given an array 'A' of length 'N' denoting the number of fans of each of the 'N' teams.
			Tension between two teams is minimum when the difference between the strengths of the teams is
			maximum because the weaker team just accepts the fact that the other team is better than them.
			Since they are underdog supporters, the weaker team switch sides and become fans of the stronger team
			when tension is minimum. After switching sides, the strength of the weaker team will be added to the
			strength of the stronger team, and the strength of the weaker team will become '0'.

			Return the strength of the stronger team before the last switch. The last switch is the one after which all fans
			support only one team.
			For Example :
				Let 'N' = 3, 'A' = [ '7, 4, 1' ].
				First, 'A[ 2 ]' will be added to 'A[ 0 ]' as their absolute difference between their
				strength is '7 - 1 = 6'.
				Then 'A[ 0 ]' becomes equal to '7 + 1 = 8'.
				Thus 'A' becomes [ '8, 4, 0' ].
				Now, 'A[ 1 ]' will be added to 'A[ 0 ]', changing 'A' to [ '12, 0, 0' ].
				Thus, '8' is the strength of the stronger team before last switch.
				Therefore, the answer is '8'.
			Constraints :
				1 <= 'T' ‹= 10
				2 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
				All elements of 'A' are unique.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				7 16 6
				2
				11 100
				Sample Output 1 :
				22
				100
				Explanation Of Sample Input 1 :
				First test case:-
					First, 'A[ 2 ]' will be added to 'A[ 1 ]' as their absolute difference is '16 - 6 = 10'.
					Then 'A[ 1 ]' becomes equal to '16 + 6 = 22'.
					Thus 'A' becomes [ '7, 22, 0' ].
					Now, 'A[ 0 ]' will be added to 'A[ 1 ]', changing 'A' to [ '0, 29, 0' ].
					Therefore the strength of the stronger team before last switch is '22'.
					Thus, the answer is '22'.

				Second test case:-
				Since we start with '2' teams, the last and only switch is between '11' and '100'.
				Therefore the strength of the stronger team before last switch is '100'.
				Thus, the answer is '100'.
				Sample Input 2 :
				2
				6
				101 267 953 764 11 690
				7
				123 456 789 1011 1213 1415 1617
				Sample Output 2 :
				2022
				5209

		//own solution:
			#include<bits/stdc++.h>
			long long gunDevil(int n, vector<int> &a) {
				long long mxer = *max_element(a.begin(), a.end());          //1.finding the first maximum element from vector
				int rep = a.size()-1;
				while(--rep){
					//2.then finding the min element from vector size()-1 times, 
					//  ie. if size=5 then 4 times, but but (in while loop it decrement the value first then uses it so) actual its for 3 time,
					//  we finding the min element & adding it to mxer variable.
					mxer += *min_element(a.begin(), a.end());     
					
					//3.changing the value to max at index where min element is there,
					//  coz it should not get caught again this, as min element
					// int index = min_element(a.begin(), a.end()) - a.begin();
					int index = distance(a.begin(), min_element(a.begin(), a.end()));
					a[index] = INT_MAX;
				}
				return mxer;
			}

		//Other solution:
			#include<bits/stdc++.h>
			long long gunDevil(int n, vector<int> &a) {
				long long mxer = *max_element(a.begin(), a.end()); // Find the maximum element.

				for (int i = 1; i < a.size() - 1; ++i) {            //adding the num till size()-
					int min_val = *min_element(a.begin(), a.end()); // Find the minimum element.

					mxer += min_val; // Add the minimum element to mxer.

					// Change the value to INT_MAX at the index where the minimum element is found.
					auto it = std::find(a.begin(), a.end(), min_val);			//syntax to find the iterator in vector with that min_val var name
					if (it != a.end()) {
						*it = INT_MAX;
					}
				}

				return mxer;
			}

	131) Day 17: ENG VS SA: Gear Selection:
		-just have to return n * (n-1);
		Problem Statement
			A cricket player is gearing up for the Cricket World Cup match between ENG and SA. He has 'N' jerseys and
			'N' track pants. The 'i-th' jersey and 'i-th' track pants have a color of type 'ї.
			A cricket gear consists of a single jersey and a single track pant. The player will like their gear if the color of
			the jersey and track pant is different.
			Return the number of cricket gears the player would like.
			Example:
				'N' - 3
				Let's assume the player has jerseys and track pants of colors 'Red', 'Green', and 'Blue'.
				The player will like cricket gears with:
				'Red jersey and Green track pant'
				'Red jersey and Blue track pant'

				'Green jersey and Red track pant'
				'Green jersey and Blue track pant'
				
				'Blue jersey and Red track pant'
				'Blue jersey and Green track pant'
				 So, the player will like '6' outfits.
			Constraints :
				1 <= T <= 10
				2 <= 'N' <= 2023
				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				3    
				Sample Output 1:
				4
				6
				Explanation Of Sample Input 1:
				For test case 1:
				Let's assume the player has jersey and track pants of colors 'Red', and 'Green'.

				The player will like cricket gears with:
				'Red jersey and Green track pant'
				'Green jersey and Red track pant'

				So, the player will like '2' cricket gears.

				For test case 2:
				Let's assume the player has jerseys and track pants of colors 'Red', 'Green', and 'Blue'.

				The player will like cricket gears with:
				'Red jersey and Green track pant'
				'Red jersey and Blue track pant'
				'Green jersey and Red track pant'
				'Green jersey and Blue track pant'
				'Blue jersey and Red track pant'
				'Blue jersey and Green track pant'

				So, the player will like '6' outfits.
				Sample Input 2:
				2
				14
				20
				Sample Output 2:
				182
				380

		int gearSelection(int n) {
			return n*(n-1);
		}

	132) Day 13: SA vs NED: Super Spell:
		-this problem mean to say, after sorting the array 2 element should not be same, 
		 if same return 0, not single element is repeated return 1.
		Problem Statement
			You have an array 'A' of length 'N' representing speeds of 'N' balls thrown in a spell.
			A spell is called 'Super Spell' if the balls thrown can be arranged in a way such that one of the following
			conditions is satisfied for each ball thrown:
			• It is the first ball thrown in the spell.
			• The speed of previous ball is strictly less than the speed of the current one.
			Return '1' if 'A' represents a super spell and return '0' otherwise.
			For Example:-
				Let 'N' = 5, 'A' = [ 5, 1, 2, 4, 8 ].
				Here, the spell can be arranged as [ 1, 2, 4, 5, 8 ].
			For the first ball, first condition is satisfied while the second condition is satisfied
			for next four balls.
			Hence, the answer is 1.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' ‹= 10^5
				1 <= 'A[i]' ‹= 10^5
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			
			Sample Input 1:-
				2
				4
				3 4 1 4
				2
				6 3
				Sample Output 1:-
				0
				1
				Explanation Of Sample Input 1:-
				First test case:-
				It can be shown that there is no such arrangement where this spell can be called super spell.
				So the answer is 0.

				Second test case:-
				Here, the spell can be arranged as [ 3, 6 ], making this spell a super spell.
				So the answer is 1.
				Sample Input 2:-
				2
				3
				3 2 1
				6
				3 6 1 4 3 6
				Sample Output 2:-
				1
				0

		//Approach-1
			#include<bits/stdc++.h>
			int candies(vector<int> &a) {
				sort(a.begin(), a.end());
				for(int i=1; i<a.size(); i++){
					if(a[i] == a[i-1])
						return 0;
				}
				return 1;
			}

		//Approach-2
			#include<bits/stdc++.h>
			int candies(vector<int> &a) {
				unordered_map<int, int> OCCScnt;
				for(int i = 0; i < a.size(); i++) {
					OCCScnt[a[i]]++;					//storing the cnt of occurrences of element in unordered_map.
				}
				for(auto it = OCCScnt.begin(); it != OCCScnt.end(); ++it) {
					if(it->second >= 2) {					//checking if the occurrence count, if its >= 2 
														//then you can say current spell ball has same power of previous spell ball 
														//so here 2 spell balls has same power.
						return 0;
					}
				}
				return 1;				//didn't found same power for spell ball, all balls have different power.
			}
	
	133) Odds Matter:
		Problem Statement
			You are given an array 'A' of length 'N'. You want to focus on its odd indices, so you delete all the elements on even indices.
			Return the final array.
			For Example :
				Let 'N' = 5, 'A' = [ 7, 2, 1, 3, 10 ]-
				The 'O-th', '2-nd', and '4-th' elements are deleted.
				Thus, the answer is [ 2, 3 ].
			Constraints :
				1 <= 'T' <= 10
				2 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				1 10 3 7
				2
				9 6
				Sample Output 1 :
				10 7
				6
				Explanation Of Sample Input 1 :
				First test case:-
				The '0-th' and '2-nd' elements are
				deleted. Thus, the answer is [ 10, 7 ].
				Second test case:-
					Only the '0-th' element is deleted Thus, the answer is [ 6 ].
				Sample Input 2
					2
					6
					4 3 4 9 19
					5
					8 9 7 11 14
					Sample Output 2 :
					3 9 9
					9 11

		vector<int> oddsMatter(int n, vector<int> &a) {
			vector<int> oddIndexElements;
			for(int i=1; i<a.size(); i+=2)
				oddIndexElements.push_back(a[i]);
			return oddIndexElements;
		}
				
	134) Ninja and String Conversion
		Problem Statement 
			Ninja has a string 'S' of length 'N' consisting of both  lowercase and uppercase letter.
			He has to perform these tasks: 
				If the letter is in lowercase, then replace it with
				the next letter e.g. replace 'a' with 'b', 'b' with 'c',
				and 'z' with 'a'.

				If the letter is in uppercase, then replace it with
				the previous letter e.g. replace 'B' with 'A', 'C'
				with 'B', and 'A' with 'Z'.
				
				Return the updated string after performing these tasks.
		Example:
			'N' = 4
			'S' = "bDcF"
			Here, 'b' and 'c' are two lowercase
			letters in the string, so we replace
			them with letters after that i.e. 'c'
			and 'd', respectively.
			'D' and 'F' are two uppercase letters in
			the string, so we replace them with
			letters before that i.e. 'C' and 'E'
			respectively.
			Hence the updated string is "cCdE".

			Constraints:
				1 <= T <= 100
				2 <= N <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				3
				Aad
				3
				Pqr
				Sample Output 1:
				Zbe
				Ors

			Explanation Of Sample Input 1:
				For test case 1:
					Here 'a' and 'd' are two lowercase
					letters in the string so we replace them
					with letters after that i.e. 'b' and 'e'
					respectively.
					'A' is an uppercase letter in the string
					so we replace them with letters before
					that i.e. 'Z'.
					Hence the updated string is "Zbe".
				For test case 2:
					Here 'q' and 'r' are two lowercase
					letters in the string so we replace them
					with letters after that i.e. 'r' and 's'
					respectively.
					'P' is an uppercase letter in the string so we replace them with letters before that i.e. 'o'.
					Hence the updated string is "Ors"
				Sample Input 2:
					xyz
					hEx
					Sample Output 2:
					yza
					iDy

		string ninjaAndStringConversion(int n, string &s){
			string ans;
			for(int i=0; i<n; i++){
				if(s[i] == 'A'){
					ans += 'Z';
				}else if(s[i] == 'z'){
					ans += 'a';
				}else if(s[i]>= 'a' && s[i] <= 'y'){
					ans += ++s[i];
				}else if(s[i]>= 'B' && s[i] <= 'Z'){
					ans += --s[i];
				}
			}
			return ans;
		}
	
	135) Division:
		Problem Statement
			Alice has an integer, 'N'. He recently learned division. Alice says an integer is good if it satisfies the following
			conditions:
				1. It lies within the range '[1, N]' both inclusive.
				2. It is divisible by '2' and not by '3'.
			Determine the number of such good integers for the given 'N'.
			Example:
			'N' = 6
			Only '2' and '4' will satisfy both the conditions.
			The First is '2', which is divisible by '2' and not divisible by "3'.
			The second is '4', which is also divisible by '2' and not divisible by "3'.
			"6" does not satisfy the condition since it is divisible by '2' but is also divisible by "3".
			So the answer is '2'.

			Constraints :
				1 <= T <= 10
				1 <= N <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				14
				Sample Output 1:
					2
					5
			Sample Output 1 :
				Explanation Of Sample Input 1
				For test case 1:
				Only '[2,4]' will satisfy the conditions '1' and '3' are not divisible by "2'
				Both '2' and '4' are divisible by "2' and not by "3'.

				For test case 2:
					In this case, only '[2,4,8,10,14]' will satisfy the conditions.
					Here, "6" will not satisfy the conditions as it is divisible by "3".
					[1,3,5,7,9,11,13] will not satisfy as they are not divisible by "2".
					Only [2,4,8,10,14] will satisfy both conditions. The answer will be 5.
					Sample Input 2:
						2
						17
						23
					Sample Output 2:
						6
						8

		//solution:
			int division(int n) {
				int cnt=0;
				// for(int i=1; i<=n; i++){
				// 	if(i % 2 == 0)
				// 		if(i % 3 != 0)
				// 			cnt++;
				// }
				// return cnt;

				//or
				// vector<int> holder;
				for(int i=2; i<=n; i+=2)
					if(i % 3 != 0)
						cnt++;	
				return cnt;
				
			}

		//or
			int division(int n) {
				vector<int> holder;
				for(int i=1; i<=n; i++){
					if(i % 2 == 0)
						if(i % 3 != 0)
							holder.push_back(i);
				}
				return holder.size();

				//or
				// vector<int> holder;
				// for(int i=2; i<=n; i+=2)
				// 	if(i % 3 != 0)
				// 		holder.push_back(i);
				
				// return holder.size();
			}

	136) Odd To Even:
		❌Pending

		//Not Optimized:
			#include <bits/stdc++.h> 
			string oddToEven(string &num) {
				vector<string> evenNumHolder;
				int i;
				for(i=0; i<num.length(); i++){
					if((num[i]-48)%2 == 0)				//here instead subtracting 48 you can subtract '0' as char, coz 0 has ascii value of 48.
						break;
				}
				if(i==num.length())
					return "-1";

				//finding the first even num;
				for(int i=0; i<num.length(); i++){
					string temp = num;
					if((num[i]-48) % 2 == 0){					//like ((num[i] - '0')%2 == 0)
						swap(temp[i], temp[temp.length()-1]);
						evenNumHolder.push_back(temp);
					}
				}

				if(evenNumHolder.size()==1)
					return evenNumHolder[0];


				string ans =  evenNumHolder[0];
				for(int i=1; i<evenNumHolder.size(); i++){

					string two = evenNumHolder[i];
					for(int j=0; j<two.length(); j++){
						if(ans[j] == two[j])
							continue;
						if((ans[j]-48) > (two[j]-48)){
							ans;
							break;
						}
						else{
							ans = two;
							break;
						}
					}
				}
				return ans;
			}

			//or
			string oddToEven(string &num) {
				int n = num.length();
				int firstEvenIndex = -1;

				for (int i = 0; i < n; i++) {
					if (num[i] % 2 == 0) {
						firstEvenIndex = i;
						break;
					}
				}

				if (firstEvenIndex == -1) {
					return "-1";
				}

				vector<string> evenNumHolder;

				for (int i = 0; i < n; i++) {
					if (num[i] % 2 == 0) {
						string temp = num;
						swap(temp[i], temp[n - 1]);
						evenNumHolder.push_back(temp);
					}
				}

				if (evenNumHolder.size() == 1) {
					return evenNumHolder[0];
				}

				sort(evenNumHolder.begin(), evenNumHolder.end(), greater<string>()); // Sort in descending order

				return evenNumHolder[0];
			}

	137) Minimum Operations:
		Given a number N. Find the minimum number of operations required to reach N starting from 0.
		 You have 2 operations available:

			◈Double the number
			◈Add one to the number

			Example 1:
				Input:
				N = 8
				Output: 4
				Explanation: 
					0 + 1 = 1 --> 1 + 1 = 2 --> 2 * 2 = 4 --> 4 * 2 = 8.
			Example 2:

				Input: 
				N = 7
				Output: 5
				Explanation: 
					0 + 1 = 1 --> 1 + 1 = 2 --> 1 + 2 = 3 --> 3 * 2 = 6 --> 6 + 1 = 7.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function minOperation() 
				which accepts an integer N and return number of minimum operations required to reach N from 0.

			Expected Time Complexity: O(LogN)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 106

		//Optimized:
			class Solution {
				public:
				int minOperation(int N){
					if(N == 1)
						return 1;
					else if(N == 2)
						return 2;
					else{
						int OPcnt=0;
						while(N!=0){
							if(N&1){
								OPcnt++;
								N--;
								continue;
							}
							N/=2;
							OPcnt++;
						}
						return OPcnt;
					}
				}
			};

		//or more optimized:
			class Solution {
				public:
				int minOperation(int N){
					int OPcnt=0;
					while(N!=0){
						if(N&1){
							OPcnt++;
							N--;
							continue;
						}
						N/=2;
						OPcnt++;
					}
					return OPcnt;
				}
			};

	138) Different Subsequences GCD:
		-just have to return the count of different gcd nums.
		Problem Statement
			You are given an array "ARR" of positive integers. Your task is to find the number of different GCD's in all the
			non-empty subsequences of the given array.
			Note:
				The GCD of a list of numbers is defined as the greatest number that perfectly divides all
				the members of the given list. For example, the GCD of 6, 8, and 10 is 2.
				A subsequence of the array is a list that can be made by using some elements of the given array. All the
				elements can also be part of a subsequence.
			For example: 
				the array [1, 2] has subsequences: [1], [2] and [1, 2]. Similarly for the
				array [1, 2, 3], one of the subsequences is [1, 3].
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^4
				1 <= ARR[i] ≤= 10^5
				Where "T' is the number of test cases, 'N', denotes the size of the array 'ARR', and
				'ARR[i]' denotes the elements of the array
				Time limit: 1 sec

			Sample Input 1:
				2
				3
				6 8 10
				3
				1 2 1
				Sample Output 1:
				4
				2
				Explanation For Sample Input 1:
				In the first test case, 
					subsequence 		|			GCD
					  6				|			6
					  8				|			8
					  10				|			10
					  6,8 			|			2
					  6,10			|			2
					  8,10			|			2
					  6,8,10			|			2
				The subsequences and their GCD’s are:
				The different GCD’s from the above table are 6, 8, 10, 2. So, the answer is 4.    

				In the second test case, 
					subsequence 		|			GCD
					  1				|			1
					  2				|			2
					  1				|			1
					  1,2 			|			1
					  1,1			|			1
					  2,1			|			1
					  1,2,1			|			1
				The subsequences and their GCD’s are:
				The different GCD’s from the above table are 1, 2. So, the answer is 2.  

				Sample Input 2:
				2
				4
				5 10 15 20
				3
				2 5 10
				Sample Output 2:
				4
				4
	
		//using online compiler c++ GDB
			#include <iostream>
			#include <bits/stdc++.h>
			using namespace std;
			int differentGCDSubsequence(vector<int> &arr) {
				vector<vector<int>> GCDstore;
				for(int i=0; i<arr.size(); i++){
					vector<int> temp;
					temp.push_back(arr[i]);
					GCDstore.push_back(temp);
				}

				//setting one to many relation 
				for(int i=0; i<arr.size()-1; i++){
					vector<int> temp;
					for(int j=i+1; j<arr.size(); j++){
						temp.push_back(arr[i]);
						temp.push_back(arr[j]);
						GCDstore.push_back(temp);
						temp.clear();               //making vector empty again.
					}
				}

				GCDstore.push_back(arr);

				set<int> uniqGCDs;
				//now finding the total no.of GCDs
				for(int i=0; i<GCDstore.size(); i++){
					if(GCDstore[i].size() ==1)
						uniqGCDs.insert(GCDstore[i][0]);
					else{
						int start = 2;
						int minValueFromCurrentArray = *min_element(GCDstore[i].begin(), GCDstore[i].end());
						int a;

						//traversing current vector only.
						int currentMAX = 1; 
						while(start <= minValueFromCurrentArray){
							for(a=0; a<GCDstore[i].size(); a++){
								if(GCDstore[i][a]%start == 0)
								continue;
								else
								break;
							}
							if(a == GCDstore[i].size() && start > currentMAX){
								currentMAX = start;
							}
							start++;
						}
						uniqGCDs.insert(currentMAX);
					}
				}
				for(int i: uniqGCDs){
					std::cout << i << std::endl;
				}
				return uniqGCDs.size();
			}

			int main() {   
				vector<int> arr = {5,10,15,20};
				std::cout << differentGCDSubsequence(arr) <<endl;
				return 0;
			}
	
		//Coding ninja platform (not optimized):
			#include <bits/stdc++.h>
			int differentGCDSubsequence(vector<int> &arr) {
				vector<vector<int>> GCDstore;
				for(int i=0; i<arr.size(); i++){
					vector<int> temp;
					temp.push_back(arr[i]);
					GCDstore.push_back(temp);
				}

				//setting one to many relation 
				for(int i=0; i<arr.size()-1; i++){
					vector<int> temp;
					for(int j=i+1; j<arr.size(); j++){
						temp.push_back(arr[i]);
						temp.push_back(arr[j]);
						GCDstore.push_back(temp);
						temp.clear();               //making vector empty again.
					}
				}

				GCDstore.push_back(arr);

				set<int> uniqGCDs;
				//now finding the total no.of GCDs
				for(int i=0; i<GCDstore.size(); i++){
					if(GCDstore[i].size() ==1)
						uniqGCDs.insert(GCDstore[i][0]);
					else{
						int start = 2;
						int minValueFromCurrentArray = *min_element(GCDstore[i].begin(), GCDstore[i].end());
						int a;

						//traversing current vector only.
						int currentMAX = 1; 
						while(start <= minValueFromCurrentArray){
							for(a=0; a<GCDstore[i].size(); a++){
								if(GCDstore[i][a]%start == 0)
								continue;
								else
								break;
							}
							if(a == GCDstore[i].size() && start > currentMAX){
								currentMAX = start;
							}
							start++;
						}
						uniqGCDs.insert(currentMAX);
					}
				} 
				return uniqGCDs.size();
			}

			//less code:
					#include <bits/stdc++.h>
					int differentGCDSubsequence(vector<int> &arr) {
						set<int> uniqGCDs;
						for (int num : arr) {
							set<int> newGCDs; // Store GCDs for current number
							newGCDs.insert(num); // Add the number itself

							// Combine GCDs from previous numbers
							for (int gcd : uniqGCDs) {
								newGCDs.insert(__gcd(num, gcd));
							}

							// Add the new GCDs to the set
							uniqGCDs.insert(newGCDs.begin(), newGCDs.end());
						}

						return uniqGCDs.size();

						//or below code
						// const int MAX_VALUE = 100001; // Adjust this based on the maximum possible value in the input array
						// vector<int> dp(MAX_VALUE, 0);
						// dp[0] = 1;

						// for (int num : arr) {
						//     for (int gcd = MAX_VALUE - 1; gcd >= 0; gcd--) {
						//         if (dp[gcd]) {
						//             int new_gcd = __gcd(gcd, num);
						//             dp[new_gcd] = 1;
						//         }
						//     }
						// }

						// int distinct = count(dp.begin(), dp.end(), 1) - 1; // Subtract 1 to exclude GCD 0
						// return distinct;

					}
	
			//or
				#include<bits/stdc++.h>
				int differentGCDSubsequence(vector<int> &arr) {

					set<int> GCD_Unique_maker (arr.begin(), arr.end());
					vector<int> GCD_Holder (GCD_Unique_maker.begin(), GCD_Unique_maker.end());
					
					for(int i=0; i < GCD_Holder.size()-1; i++){
						for(int j=i+1; j < GCD_Holder.size(); j++){
							int gcdValue = __gcd(GCD_Holder[i], GCD_Holder[j]);
							GCD_Unique_maker.insert(gcdValue);
						}
					}

					// checking gcd for complete array
					vector<int> holder (GCD_Unique_maker.begin(), GCD_Unique_maker.end());
					
					int value = holder[0];
					for(int i=1; i<holder.size(); i++){
						value = __gcd(value, holder[i]);
					}

					GCD_Unique_maker.insert(value);
					return GCD_Unique_maker.size();
				}

		//Optimized:
			#include<bits/stdc++.h>
				int gcd(int a, int b) {
					if(a == 0) return b;
					return gcd(b%a, a);
				}

				int differentGCDSubsequence(vector<int> &arr)  {

					int maxElement = *max_element(arr.begin(), arr.end());
					int total = maxElement + 1;
					bool *checkNumber;
					checkNumber = new bool[total];
					for(int i : arr) 
						checkNumber[i] = true;
						
					int count = 0;
					for(int i = 1; i <= maxElement; i++) {  
						int calcGCD = 0;
						for(int j = i; j < total; j += i) {
							if(checkNumber[j] == true)
								calcGCD = gcd(calcGCD, j);
								
							if(calcGCD == i) {
								++count;
								break;
							}
						}
					}
					return count;
				}

	139) Shortest Word Distance II:
		Problem Statement
			You have a bookshelf in the form of an array 'arr' in which names of the books(single word name) are given.
			You are also given names of two books, 'book1' and 'book2'. You are supposed to find the minimum distance
			between 'book1' and book2'.
			Distance between two books is defined as the absolute difference between the indices of the books i.e for
			two books at index 'i' and 'j' the distance is equal to |i-j|.
			Note:
				1. There may be multiple occurrences of any book.
				2. book1 and book2 are present on the bookshelf.
				3. The name of the books is in lower-case.
				4. book is not equal to book2.
			Constraints:
				1<= T <= 50
				2 <= N <= 10^4
				1 <= arr[i].length <= 10^4
				All strings consist of lowercase letters only.
				Where 'T' is the number of test cases, and N denotes the number of elements in the array
				'arr', arr[i] denotes the element at index 'i'
				Time Limit: 1 sec
			Sample Input 1:
				2
				8
				coding ninjas help to crack product based companies
				coding product
				8
				eat code sleep repeat eat code sleep repeat 
				eat repeat
				Sample Output 1:
				5
				1
				Explanation For Sample Input 1:
				In the first test case, there are 8 books on the bookshelf.
				book1 = “coding”, book2 = “product”. The distance between book1 and book2 is 5. So, the answer is 5.
				In the second test case, there are 8 books on the bookshelf. and there are 2 occurrences in every book.
				book1 = “eat”, book2 = “repeat”.  book1 is present at indices 0 and 4. book2 is present at indices 3 and 7. The distances are 3, 7, 1, 4. The minimum of these is 1. So, the answer is 1.
				Sample Input 2:
				2
				5
				alpha beta gamma theta beta
				theta beta
				6
				be cool whatever the situation is
				situation cool
				Sample Output 2:
				1
				3

		#include <bits/stdc++.h> 
		int minimumDistance(vector<string> &arr, string book1, string book2) {
			int minDist = INT_MAX;
			//storing the indexes of book1 & book2
			vector<int> indexesB1;
			
			vector<int> indexesB2;
			for(int i=0; i<arr.size(); i++){
				if(book1 == arr[i])
					indexesB1.push_back(i+1);

				if(book2 == arr[i])
					indexesB2.push_back(i+1);
			}

			for(int i=0; i<indexesB1.size(); i++){
				for(int j=0; j<indexesB2.size(); j++){
					int tempNum = abs(indexesB1[i] - indexesB2[j]);
					if(tempNum < minDist)
						minDist = tempNum;
				}
			}

			return minDist;
		}
	
	140) Product Of Array Except Self (difficult):
		Problem Statement
			You have been given an integer array/list (ARR) of size N. You have to return an array/list PRODUCT such
			that PRODUCT[i] is equal to the product of all the elements of ARR except ARR[i]
			Note:
				Each product can cross the integer limits, so we should take modulo of the operation.
				Take MOD = 10^g + 7 to always stay in the limits.
			Follow Up:
				Can you try solving the problem in 0(1) space?
			Constraints :
				1 <= T <= 100
				0 <= N <= 10^5
				0 < = ARR[i] <= 10^5
				Time Limit: 1 sec	
			Sample Input 1 :
				2
				3
				1 2 3
				3
				5 2 2
				Sample Output 1 :
				6 3 2
				4 10 10
				Explanation For Sample Output 1 :
				Test case 1 : Given array = {1, 2, 3] 
				Required array = [2 * 3, 1 * 3, 1 * 2] = [6, 3, 2]
				Test case 2 : Given array = {5, 2, 2] 
				Required array = [2 * 2, 5 * 2, 5 * 2] = [4, 10, 10]
				Sample Input 2 :
				2
				1
				100
				2
				1 2
				Sample Output 2 :
				1
				2 1

		int *getProductArrayExceptSelf(int *arr, int n) {
			int *brr = new int[n];
			int *leftProducts = new int[n];
			int *rightProducts = new int[n];
			int mod = 1000000007; // 1e9 + 7

			// Calculate the product of elements to the left of each element.
			leftProducts[0] = 1;
			for (int i = 1; i < n; i++) {
				leftProducts[i] = (1LL * leftProducts[i - 1] * arr[i - 1]) % mod;
			}

			// Calculate the product of elements to the right of each element.
			rightProducts[n - 1] = 1;
			for (int i = n - 2; i >= 0; i--) {
				rightProducts[i] = (1LL * rightProducts[i + 1] * arr[i + 1]) % mod;
			}

			// Calculate the final result by multiplying leftProducts and rightProducts.
			for (int i = 0; i < n; i++) {
				brr[i] = (1LL * leftProducts[i] * rightProducts[i]) % mod;
			}
			return brr;
		}
	
	141) Day 22: ENG vs SL: All Caps :
		Problem Statement
			Given an array 'A' of length 'N' representing 'N' caps, the score required to win 'i-th' cap is 'A[i]'. Because you
			want to become the greatest cricket player alive, you challenge yourself to win all of these 'N' caps.
			But there is an issue: you can only achieve the score to win a particular cap if you have already won all caps
			with a lower score.
			If you have won the 'i-th' cap most recently and you want the 'j-th' cap, you must have won all caps with a
			score lower than the 'j-th' cap, and you have to work for '|j-i|' hours.
			Return the minimum number of hours you have to work to win all 'N' caps if, initially, you are at the first cap.
			For Example :
			Let 'N' = 3, 'A' = [ 4, 1, 2 ].
			Initially, you can win second cap by working for | 0 - 1 | = 1' hour.
			Then, your score allows you to win the third cap by working for '| 1 - 2 | = 1' hour.
			Finally, your score allows you to win the first cap by working for '| 2 - 0 | = 2' hours.
			The total hours you worked are '1 + 1 + 2 = 4' hours. It can be shown that this is the
			minimum work possible
			Thus, the answer is '4'.
			Constraints :
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				1 < 'A[i]' ‹= 10^9|
				The elements of 'A' are pairwise
				distinct.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				10 37 1
				2
				8 9
				Sample Output 1 :
				5
				1
				Explanation Of Sample Input 1 :
				First test case:-
				Initially, you can win the third cap by working for '| 0 - 2 | = 2' hours.
				Then, your score allows you to win the first cap by working for '| 2 - 0 | = 2' hours.
				Finally, your score allows you to win the second cap by working for '| 0 - 1 | = 1' hour.
				The total hours you worked are '1 + 2 + 2 = 5' hours. It can be shown that this is the minimum work possible.
				Thus, the answer is '5'.

				Second test case:-
				First, you can win the first cap by working for '| 0 - 0 | = 0' hour.
				Then, your score allows you to win the second cap by working for '| 0 - 1 | = 1' hour.
				Thus, the answer is '1'.
				Sample Input 2 :
				2
				4
				11 9 5 6
				5
				20 2 3 4 1
				Sample Output 2 :
				6
				12

		//NOT optimized:
			#include <bits/stdc++.h>
			long long underwaterValves(int n, vector<int> &h) {
				long long ans=0;
				int currentMinElementIndex = abs(h.begin() - min_element(h.begin(), h.end()));
				int prevMinElementIndex;

				ans += currentMinElementIndex;
				
				vector<int> sortedVec = h;
				sort(sortedVec.begin(), sortedVec.end());

				for(int i=1; i<h.size(); i++){
					prevMinElementIndex = currentMinElementIndex;
					currentMinElementIndex = abs(h.begin() - find(h.begin(), h.end(), sortedVec[i]));
					ans += abs(prevMinElementIndex - currentMinElementIndex);
				}
				return ans;
			}

		//Optimized:
			#include <bits/stdc++.h>
			long long underwaterValves(int n, vector<int> &h) {
				long long ans = 0;
				
				vector<int> sortedVec = h;
				sort(sortedVec.begin(), sortedVec.end());
				
				unordered_map<int, int> indexMap;
				for (int i = 0; i < n; i++) {
					indexMap[h[i]] = i;
				}
				
				int currentMinElementIndex = distance(h.begin(), min_element(h.begin(), h.end()));
				ans += currentMinElementIndex;
				
				for (int i = 1; i < n; i++) {
					int prevMinElementIndex = currentMinElementIndex;
					currentMinElementIndex = indexMap[sortedVec[i]];
					ans += abs(prevMinElementIndex - currentMinElementIndex);
				}
				
				return ans;
			}

		(optional) bit similar,
			#include <iostream>
			#include<bits/stdc++.h>

			using namespace std;
			int main() {
				// vector<int> vec = {20,25,3,4,1};
				// vector<int> vec = {20,2,3,4,1};
				vector<int> vec = {8,9};
				
				// vector<int> vec = {11,5,9,6};
				// vector<int> vec = {10,37,1};
				
				if(vec.size() ==2){
					cout<<"Final ans :"<<1;
					return 0;
				}
				
				for(int i: vec)
					std::cout << i << " ";

				std::cout << std::endl;
				vector<int> sortedVec = vec;
				
				sort(sortedVec.begin(), sortedVec.end());
				
				int ans =0;
				auto prevIndex = abs(vec.begin() - max_element(vec.begin(), vec.end()));
				
				for(int i=0; i<vec.size(); i++){
					int currentIndex = abs(vec.begin()- find(vec.begin(), vec.end(), sortedVec[i]));
					cout<<prevIndex << "  "<< currentIndex<<" ";
					int dist = abs(currentIndex - prevIndex);
					cout<<"Dist "<< dist<<" \t";
					ans +=  dist;
					prevIndex = currentIndex;
					cout<<ans<<"\n";
					
				}

				std::cout << endl<< "Final ans "<< ans << std::endl;
				return 0;
			}
	
	142) Split String:
		Problem Statement
			You are given a string 'str' of even length. Your task is to find out if we divide the 'str' from the middle, will
			both the substrings contain an equal number of vowels or not.
			For Example:
				You are given, 'str'= 'codingninjas', when we split this string we get, "coding' and
				'ninjas' which both contain 2 vowels each. Hence the answer is "True'…
			Constraints:
				1 <= T <= 10
				1 <= str ‹= 10^6
				"str' will contain upper and lower case characters of the English alphabet. |str| is even.
				Time Limit: 1 sec.
			Note :
				You do not need to print anything. It has already been taken care of. Just implement the given function.
		Sample Input 1:
			2
			codingninjas
			helloworld
			Sample Output 2:
			True
			False
			Explanation:
			For the first test case, ‘str’= ‘codingninjas’, when we split this string we get, ‘coding’ and ‘ninjas’ which both contain 2 vowels each. Hence the answer is ‘True’.

			For the second test case, ‘str’= ‘helloworld’, when we split this string we get ‘hello and ‘world’, which contain 2 and 1 vowels respectively. Hence the answer is ‘False’.
			Sample Input 2:
			2
			Aa
			AbbaaA
			Sample Output 2:
			True
			False
		#include <bits/stdc++.h> 
		bool splitString(string &str){
			//converting original string to lower case
			transform(str.begin(), str.end(), str.begin(), ::tolower);
			
			string s1 = str.substr(0, str.length()/2);          //from start till mid.
			string s2 = str.substr(str.length()/2);             //from (mid+1) to till end
			int cnt1 =0, cnt2=0;
			for(int i=0; i<s1.length(); i++){
				if(s1[i] == 'a' || s1[i] == 'e' || s1[i] == 'i' || s1[i] == 'o' || s1[i] == 'u')
					cnt1++;

				if(s2[i] == 'a' || s2[i] == 'e' || s2[i] == 'i' || s2[i] == 'o' || s2[i] == 'u')
					cnt2++;
			}

			if(cnt1 == cnt2)
				return 1;
			return 0;
		}
	
	143) Check whether K-th bit is set or not: (0-based indexing)
		Practice:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			void binaryRepresentation_NthBit(int num, int bit){
				std::cout <<"The binary num of "<< num << " " <<bitset<32>(num) <<" & "<<bit<<"s bit is : "<< ((num & (1<<bit))!=0) << std::endl;
			}

			int main() {
				int num = 4, nthBit=0;          //0-index
				binaryRepresentation_NthBit(num, nthBit);
				
				
				binaryRepresentation_NthBit(4, 1);
				binaryRepresentation_NthBit(4, 2);
				
				std::cout << std::endl;
				binaryRepresentation_NthBit(15, 0);
				binaryRepresentation_NthBit(15, 1);
				binaryRepresentation_NthBit(15, 2);
				binaryRepresentation_NthBit(15, 3);
				binaryRepresentation_NthBit(15, 4);
				
				return 0;
			}

		Problem Statement
			Given a number N and a bit number K, check if Kth index bit of N is set or not. 
			A bit is called set if it is 1. Position of set bit '1' should be indexed 
			starting with 0 from LSB side in binary representation of the number.
			Note: 
				Index is starting from 0. You just need to return true or false, 
				driver code will take care of printing "Yes" and "No".

			Example 1:
				Input: 
				N = 4
				K = 0
				Output: 
				No
				Explanation: 
					Binary representation of 4 is 100, in which 0th index bit from LSB is not set. So, return false.

			Example 2:
				Input: 
				N = 4
				K = 2
				Output: 
				Yes
				Explanation: 
					Binary representation of 4 is 100, in which 2nd index bit from LSB is set. So, return true.
		
			Example 3:
				Input: 
				N = 500
				K = 3
				Output: 
				No
				Explanation: 
					Binary representation of 500 is 111110100, in which 3rd index bit from LSB is not set. So, return false.
			Your task:
				You don't have to read input or print anything. 
				Your task is to complete the function checkKthbit that takes n and k as parameters 
				and returns either true(if kth bit is set) or false(if kth bit is not set).

			Expected Time Complexity: O(1).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ N ≤ 10^9
				0 ≤ K ≤ 31

		class Solution {
			public:
				// Function to check if Kth bit is set or not.
				bool checkKthBit(int n, int k) {
					while(k>0){					//or while(k!=0)
						k--;
						n>>=1;
					}
					if(n&1)
						return 1;
					return 0;
				}
		};

		class Solution {
			public:
				// Function to check if Kth bit is set or not.
				bool checkKthBit(int n, int k) {
					string s = bitset<32>(n).to_string();
					int i;
					for(i=s.length()-1; k>0; k--, i--){
						
					}
					//or
					//for(i=s.length()-1; k>0; k--, i--);

					if(s[i] == '1')
						return 1;
					return 0;
				}
		};

		//or for loop changed:
			class Solution {
				public:
					// Function to check if Kth bit is set or not.
					bool checkKthBit(int n, int k) {
						string s = bitset<32>(n).to_string();
						int i;
						for(i=s.length()-1; k>0; k--, i--);
						
						if(s[i] == '1')
							return 1;
						return 0;
					}
			};
	
		//or	string modified:
			class Solution {
				public:
					// Function to check if Kth bit is set or not.
					bool checkKthBit(int n, int k) {
						string s = bitset<32>(n).to_string();
						reverse(s.begin(), s.end());
						
						int i;
						for(i=0; i<k ;i++);			//checking till k. if k=4 then i incremented till 4 only.
						if(s[i] == '1')
							return 1;
						return 0;
					}
			};

		//or OPTIMIZED/ Advance:
			(1 << n) means 2ⁿ
			eg.
				1) n=2
					result=4 (because 2²=4)
					explanation:
						1 << 2		(left shift by 2)
						-> 1		initially
						->10		1st left shift	
						->100		2nd left shift	
						= 100 which is 4
				2) n = 5
					result = 32 (because 2⁵=32)
					explanation:
					1 << 5		(left shift by 5)
					-> 1		initially
					->10		1st left shift
					->100		2nd left shift
					->1000		3rd left shift
					->10000		4th left shift
					->100000		5th left shift
					= 1000000 which is 32

			class Solution {
			public:
				// Function to check if Kth bit is set or not.
				bool checkKthBit(int n, int k) {
					return ((n&(1<<k)) != 0);			//making kth bit directly 1 & checking. if its zero, 0 != 0 which is false & all expression leads to false
													//if its not zero then non-zero value, leads to true.
				}
			};

	144) Odd Even:
		Problem Statement
			Alice has two numbers, 'X' and 'Y'. He is asked to perform the following operations any number of times.
			Alice adds 1 to 'X' if 'X' is odd. Alice adds 2 to 'X' if 'X' is even. Will he be able to make 'X' equal to 'Y?
			Return 1 if 'X' can be made equal to 'Y' using the above operations any number of times(possibly 0) and 0 otherwise.
			Note: Assume 1-based indexing.
			For Example:
				Let 'X' = 3 and '' =6, Alice adds 1 to 'X' since 'X' is odd. Now 'X' will become 4.
				Then, Alice will add 2 to 'X', since 'X' is even, and it will become 6. 'X' becomes equal
				to 'Y'. Hence we will return 1 as the answer.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'X', 'Y' <= 10^9
				Time Limit: 1 sec
			Sample Input 1:-
					2
					4 8
					1 1
					Sample Output 1:-
					1
					1
					Explanation Of Sample Input 1:-
					First test case:- 
					In 1st operation, Alice will add 2 to 'X' as 'X' is even. Now, 'X' is 6. Again, in the 2nd operation, Alice will add 2 to 'X'. Now 'X' is 8, which is equal to 'Y'. So, the answer is 1.

					Second test case:-
					'X' is already equal to 'Y'. So, the answer is 1.
					Sample Input 2:-
					2
					4 9 
					7 8
					Sample Output 2:-
					0
					1
	
		int isPossible(int x, int y) {
			if(x==y)
				return 1;
			else if(x<=y && y%2==0)
				return 1;
			else
				return 0;	
		}
	
	145) EvenlySame:
		Problem Statement
			You are given two strings 'A', and 'B' of length 'N'. These strings are 'EvenlySame' if there are an even
			number of indices 'ї' such that 'A[i] == B[i]'
			Return 1, if 'A' and 'B' are 'EvenlySame' otherwise return 0.
			For Example:-
				Let 'N' = 5, 'A' = "abcde", 'B' = "xbfge".
				There are two indexes, 2, and 5 (1-based indexing) such that characters at these indexes are the same.
				So our answer is 1.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				'A' and 'B' consist of 'N' lowercase English letters
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				5
				pfeyu
				zuegh
				4
				pqrs
				pqrs
				Sample Output 1:-
				0
				1
				Explanation Of Sample Input 1:-
				First test case:-
				There is 1 index, 3 (1-based indexing) such that characters at this index are the same.
				So our answer is 0.

				Second test case:-
				There are four indexes, 1, 2, 3, and 4 (1-based indexing) such that characters at these indexes are the same.
				So our answer is 1.
				Sample Input 2:-
				2
				4
				abcc
				ajjc
				5
				uvvhy
				cddhi
				Sample Output 2:-
				1
				0

		int evenlySame(string a, string b) {
			int cnt=0;
			for(int i=0; i<b.length(); i++){
				if(a[i] == b[i])
					cnt++;
			}
			if(cnt&1)
				return 0;
			return 1;
		}
	
	146) Cut Array:
		Problem Statement
			You are given an array 'A' of length 'N'. You can cut an array at an index 'i' to split the array into two arrays,
			one containing elements from indices 0 to 'i - 1' and the other containing the rest.
			Your goal is to make all arrays sorted in non-decreasing order. You can perform cuts on 'A' and all
			subsequent arrays formed from cuts.
			Return the minimum number of cuts you have to perform.
			For Example:
				Let 'N' = 3, 'A' = [ 2, 5, 3 ].
				We perform a cut at index '2' to obtain the arrays: [2, 5] and [3 ]. All arrays are now
				sorted in non-decreasing order
				It can be shown that this is the minimum number of cuts needed. Thus, the answer is '1'.
			Constraints :
				1 <= 'T' <= 10
				3 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				100 7 11 3
				3
				3 9 13
				Sample Output 1 :
				2
				0
				Explanation Of Sample Input 1 :
				First test case:-
				We perform a cut at index '3' to obtain the arrays: [ 100, 7, 11 ] and [ 3 ].
				We perform another cut at index '1' of the first array to obtain the arrays: [ 100 ], [ 7, 11 ], and [ 3 ]. All arrays are now sorted in non-decreasing order.
				It can be shown that this is the minimum number of cuts needed.
				Thus, the answer is '2'.

				Second test case:-
				The array is already sorted in non-decreasing order.
				Thus, the answer is '0'.
				Sample Input 2 :
				2
				5
				3 2 1 2 3
				6
				8 9 2 30 20 17
				Sample Output 2 :
				2
				3

		int cutArray(int n, vector<int> &a) {
			int cnt=0;
			for(int i=1; i<a.size(); i++){
				if(a[i] >= a[i-1])
					continue;
				else
					cnt++;
			}
			return cnt;
		}
	
	147) Square Root Of An Integer:
		Problem Statement
			You are given an integer 'A: Your task is to find the greatest non-negative integer whose square is less than
			or equal to 'A.
			Square of a number is the product of the number with itself. 
			For e.g. square of 3 is 9.
			Constraints
				1 <= T <= 10^4
				0 <= A <= 10^5
				Time Limit: 1 sec
			Sample Input 1
				2
				8
				9
				Sample Output 1
				2
				3
				Explanation Of Input 1
				The greatest non-negative integer for test case 1 whose square is less than equal to 8 is 2 
				as the square of 3 is 9 which is greater than 8.

				The greatest non-negative integer for test case 2 whose square is less than equal to 9 is 3 
				as the square of 4 is 16 which is greater than 9. 
				Sample Input 2
					2
					1
					0
					Sample Output 2
					1
					0

		//not optimized:
			#include <bits/stdc++.h> 
			int squareRoot(int a) {
				int i=0;
				int ans =i;
				while(i<=a){
					if(pow(i,2) <= a)
						ans = i;
					i++;		
				}
				return ans;
			}
		
		//Optimized:
			#include <bits/stdc++.h> 
			int squareRoot(int a) {
					if (a <= 1) {
					return a;
				}

				int left = 1;
				int right = a;
				int result = 0;

				while (left <= right) {
					int mid = left + (right - left) / 2;
					if (mid <= a / mid) {
						left = mid + 1;
						result = mid;
					} else {
						right = mid - 1;
					}
				}

				return result;
			}
	
	148) (Ninja) Ninja's Frustrating Homework:
		Problem Statement
			Ninja got a summer vacation homework in which he got a booklet containing a very long string and some set
			of words written in his diary for which he had to search all these words in that string booklet.
			His teacher asked him to write all the starting indices for all the words written in the diary after searching
			that from the string booklet.
			Ninja finds this work very frustrating. He tries to find some help from his neighbor and currently, you are the
			one who is his neighbor.
			It is very time consuming to find every word in the string booklet manually. So you decide to design a code
			for that. Help Ninja!
			Note:
				Follow 0 based indexing
				Print the indices in sorted order
			
			Sample Input 1 :
				2
				abcab
				3
				a cab abca
				ninjasmart
				3
				jas art nin 
				Sample Output 1:
				0 1 2
				0 3 7 
				Explanation For Sample Input 1:
				Test Case 1 :
				The given string is “abcab”. The word “a” is present in the string starting from index 0 and ending at index 0, The word “cab” has starting index 2 and ending index 4 , “abca” has starting index 0 ending index 3.

				Test Case 2:
				The given string is “ninjasmart”. “Jas” has starting index 3 ending index 5, “art” has starting index 8 ending index 10, “nin” has starting index 0 ending index 2.
				Sample Input 2:
				2
				ahishers
				4
				he she his hers
				bheythis
				2
				hey this 
				Sample Output 2:
				1 3 4 4
				1 4

		#include <bits/stdc++.h> 
		vector<int> searchWords(string booklet, vector<string> &diary) {
			vector<int> ans;
			for (int i = 0; i < diary.size(); i++) {
				int pos = booklet.find(diary[i]);
				while (pos != string::npos) {
					ans.push_back(pos);
						
						//finding the next occurrenece of that word
					pos = booklet.find(diary[i], pos + 1);
				}
			}

			sort(ans.begin(), ans.end());
			return ans;
		}

	149) Russian Doll Envelopes:
		Problem Statement
			You are given a set of 'N' rectangular envelopes. The height and width of each envelope are given by arrays,
			'height' and 'width' respectively, each consisting of 'N' positive integers. The height, width of the ith envelope
			is given by 'height[i]' and 'width[i]" respectively.
			You can put one envelope inside another envelope if and only if both the height and width of one envelope is
			strictly greater than the height and width of the other envelope.
			What is the maximum number of envelopes you can Russian doll? (put one inside other)|
			Note
				Rotation of envelope is not allowed, that is, height and width can't be exchanged
			Constraints:
				1 <= T <= 50
				1 <= n <= 10^4
				1 <= height[i] <= 10^9
				1 <= width[i] <= 10^9
				Time Limit: 2 sec
		
		Sample Input 1:
			2
			4
			5 6 6 2
			4 4 7 3
			2
			2 1 
			2 1
			Sample Output 1:
			3 
			2
			Explanation For Sample Output 1:
			Test Case 1:
			The number envelopes, ‘N’ = 4 
			‘height’ = {5, 6, 6, 2}
			‘width’= {4, 4, 7, 3}
			Let denote dimensions of the envelope in (Height, Width) manner then, one way of Russian Doll envelopes in outermost to the innermost manner is as follow:

			Select the third envelope, i.e., envelope with dimensions (6, 7) as the outermost envelope.

			Place the first envelope i.e envelope with dimensions (5, 4) inside the outermost envelope. You can do this because both the height and width of this envelope is strictly less than the outermost envelope.

			Place the fourth envelope i.e envelope with dimensions (2, 3) inside the previous envelope.

			In this way, we can Russian Doll 3 envelopes. 

			No other way can Russian Doll more than 3 envelopes.

			Test Case 2:
			You can put the second envelope inside the first envelope because both the height and width of the second envelope are strictly less than the first envelope.
			Sample Input 2:
			2
			1
			2
			3
			3
			1 1 1
			1 1 1
			Sample Output 2:
			1
			1

		//Not optimized:
			#include <bits/stdc++.h>
			int findMaxEnvelopes(vector<int> &height, vector<int> &width, int n) {
				vector<pair<int, int>> envelopes;
				for (int i = 0; i < n; i++) {
					envelopes.push_back({height[i], width[i]});
				}

				// Sort the envelopes based on height and then width in ascending order.
				sort(envelopes.begin(), envelopes.end());

				// Create an array to store the longest increasing subsequence ending at each index.
				vector<int> dp(n, 1);

				for (int i = 1; i < n; i++) {
					for (int j = 0; j < i; j++) {
						if (envelopes[i].first > envelopes[j].first && envelopes[i].second > envelopes[j].second) {
							dp[i] = max(dp[i], dp[j] + 1);
						}
					}
				}

				// Find the maximum value in the dp array, which represents the maximum number of nested envelopes.
				int maxEnvelopes = *max_element(dp.begin(), dp.end());

				return maxEnvelopes;
			}
	
		//Optimized:
			#include <bits/stdc++.h>
			bool envelopeComparator(const pair<int, int> &a, const pair<int, int> &b) {
				return (a.first < b.first) || (a.first == b.first && a.second > b.second);
			}

			int findMaxEnvelopes(vector<int> &height, vector<int> &width, int n) {
				vector<pair<int, int>> envelopes;
				for (int i = 0; i < n; i++) {
					envelopes.push_back({height[i], width[i]});
				}

				sort(envelopes.begin(), envelopes.end(), envelopeComparator);

				vector<int> dp;
				for (const auto &env : envelopes) {
					auto it = lower_bound(dp.begin(), dp.end(), env.second);
					if (it == dp.end()) {
						dp.push_back(env.second);
					} else {
						*it = env.second;
					}
				}

				return dp.size();
			}

	150) Bleak Numbers: ❌Pending
		Given an integer, check whether it is Bleak or not.
			A number n is called Bleak if it cannot be represented as sum of 
			a positive number x and set bit count in x, i.e., x + countSetBits(x) is 
			not equal to n for any non-negative number x.

			Example 1:
				Input: 
				4
				Output: 
				1
				Explanation: 
				There is no x such that x + countSetbit(x) = 4

			Example 2:
				Input: 
				3
				Output: 
				0
				Explanation: 
				3 is a Bleak number as 2 + countSetBit(2) = 3.

			Your Task:
			You don't need to read or print anything. Your task is to complete the 
			function is_bleak() which takes n as input parameter and returns 1.
			if n is not a Bleak number otherwise returns 0.

			Expected Time Complexity: O(log(n) * log(n))
			Expected Space Complexity: O(1)
			
			Constraints:
				1 <= n <= 10^9

		//Not Optimized:
			class Solution {
				public:
				int bitCounter(int n){
					int cnt=0;
					while(n!=0){
						if(n&1)
						cnt++;
						n >>=1;
					}
					return cnt;
				}
				
				int is_bleak(int n) {
					//counting the set bit in given num
					int cnt =0,sum=0;
					while(n > sum){
						sum = cnt + bitCounter(cnt);
						
						if(sum == n)
							return 0;
						cnt++;
					}
					return 1;
				}
			};

	151) Sort Integers by The Number of 1 Bits:
		Problem Statement:
			You are given an integer array arr. Sort the integers in the array in ascending order 
			by the number of 1's in their binary representation and in case of two or more 
			integers have the same number of 1's you have to sort them in ascending order.
			Return the array after sorting it.

			Example 1:
				Input: arr = [0,1,2,3,4,5,6,7,8]
				Output: [0,1,2,4,8,3,5,6,7]
				Explantion: [0] is the only integer with 0 bits.
					[1,2,4,8] all have 1 bit.
					[3,5,6] have 2 bits.
					[7] has 3 bits.
					The sorted array by bits is [0,1,2,4,8,3,5,6,7]

			Example 2:
				Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
				Output: [1,2,4,8,16,32,64,128,256,512,1024]
				Explantion: All integers have 1 bit in the binary representation, 
					you should just sort them in ascending order.
			
			Constraints:
				1 <= arr.length <= 500
				0 <= arr[i] <= 104

		class Solution {
			public:
			vector<int> sortByBits(vector<int>& arr) {
				vector<pair<int, int>> manipulator;

				for(int i=0; i<arr.size(); i++){
					int currentElementCnt = __builtin_popcount(arr[i]);
					pair<int, int> temp = {arr[i], currentElementCnt};
					manipulator.push_back(temp);
				}

				
				// need to sort manipulator vector
				// firstly based on total setBits, if num1's set bits are 1 & num2's set bits are 0
				// then num2 will be placed before num1.

				sort(manipulator.begin(), manipulator.end(), [](pair<int,int> &a, pair<int,int> &b){
					if(a.second != b.second)
						return a.second < b.second;
					return a.first < b.first;
				});

				vector<int> ans;

				for(int i=0; i<arr.size(); i++){
					int value = manipulator[i].first;
					ans.push_back(value);
				}
				return ans;
			}
		};

		//or without using pair:
			class Solution {
				public:
				vector<int> sortByBits(vector<int>& arr) {
					vector<int> ans;
					int tracker=0;
					sort(arr.begin(), arr.end());
					
					while(tracker<32){				//32 is because of size of integer is 4bytes ie. 32 bit. (0 to 31 = 32bits).
						for(int i=0; i<arr.size(); i++){
							int single_bit = __builtin_popcount(arr[i]);
							if(single_bit == tracker)
								ans.push_back(arr[i]);
						}
						tracker++;
					}
					return ans;
				}
			};

	152) Beautiful Xor Pairs:
		Problem Statement
			Ninja has an array 'ARR' consisting of 'N' positive integers. He also has two positive integers 'LOW', 'HIGH'
			such that 'HIGH' >= 'LOW'.
			According to Ninja, a pair of integers (i, j) is considered beautiful if 0 <i <j < 'N' and 'LOW' <= ('ARR[i]' XOR
			'ARRI]') <= 'HIGH'.
			Ninja wants to count beautiful pairs in 'ARR'. Find and return the number of beautiful pairs in 'ARR' on behalf
			of Ninja.
			Note:
				1. Consider 0 based indexing in "ARR'

		Constraints:
			1 <= T <= 50
			1 <= N <= 10000
			1 <= ARR[i] <= 20000
			1 <= LOW <= HIGH <= 20000
			Where "T' is the number of test cases, 'N' is the size of "ARR', and 'LOW', "HIGH' are
			the integers that Ninja have, "ARR[i]' is the 'i-th' element of arraylist "ARR'
			Time limit: 1 sec
		Sample Input 1:
			2
			1 1 2
			1
			4 6 8
			3 4 5 2
			Sample Output 1:
			0
			4
			Explanation Of Sample Input 1:
			In the first test case, there is only one integer in ‘ARR’ so no pair is possible.

			In the second test case, There are 6 pairs as follow -:
			1. (0, 1):  ‘ARR[0]’ XOR ‘ARR[1]’ = 3 XOR 4 = 7
			2. (0, 2):  ‘ARR[0]’ XOR ‘ARR[2]’ = 3 XOR 5 = 6
			3. (0, 3):  ‘ARR[0]’ XOR ‘ARR[3]’ = 3 XOR 2 = 1
			4. (1, 2):  ‘ARR[1]’ XOR ‘ARR[2]’ = 4 XOR 5 = 1
			5. (1, 3):  ‘ARR[1]’ XOR ‘ARR[3]’ = 4 XOR 2 = 6
			6. (2, 3):  ‘ARR[2]’ XOR ‘ARR[3]’ = 5 XOR 2 = 7
			Clearly, there are 4 beautiful pairs i.e (0, 1), (0, 2), (1, 3) and (2, 3)
			Sample Input 2:
			2
			4 2 6
			1 4 2 7
			5 5 14
			9 8 4 2 1
			Sample Output 2:
			6
			8

		//Not Optimized:
			#include <bits/stdc++.h> 
			int countBeautifulPairs(vector<int> &arr, int low, int high) {
				int cnt=0;
				for(int i=0; i < arr.size(); i++){
					for(int j=i+1; j<arr.size(); j++){
						int checker = arr[i] ^ arr[j];
						if((low <= checker) && (checker <= high)){
							cnt++;
						}
					}
				}
				return cnt;
			}
		
		// Optimized: ❌Pending
			/*
				Time Complexity : O(N)
				Space Complexity : O(N)

				Where 'N' is the size of ‘ARR’.
			*/

			struct TrieNode {
				TrieNode *children[2];
				int value = 0;
			};

			void insert(TrieNode *root, int num) {
				TrieNode *ptr = root;
				ptr->value += 1;
					
				for(int i = 15; i >= 0; i--) {
					int curBit = ((num & (1 << i)) == 0) ? 0 : 1;

					if(ptr->children[curBit] == NULL) {
						ptr->children[curBit] = new TrieNode();
					}
					
					ptr->children[curBit]->value += 1;
					ptr = ptr->children[curBit];
				}
			}
			
			int helper(TrieNode *root, int cur, int num) {
				/*
					*   This function count number of integers in trie
					*   having bitwise xor with 'cur' less than 'num'.
				*/

				int count = 0;
				TrieNode *ptr = root;

				for(int i = 15; i >= 0; i--) {
					int curBit = (((cur & (1 << i)) ^ (num & (1 << i))) == 0) ? 0 : 1;
					
					if((num & (1 << i)) != 0) {
					
						if(ptr->children[1-curBit] != NULL) {
							count += ptr->children[1-curBit]->value;
						} 
					}

					if(ptr->children[curBit] == NULL) {
						break;
					}

					ptr = ptr->children[curBit];
				}
				return count;   
			}
			
			int countBeautifulPairs(vector<int> &arr, int low, int high) {
				//  Size of array
				int n = arr.size();
				int counter = 0;
				
				TrieNode *root = new TrieNode();

				//  Counting number of beautiful pairs.
				for(int i = 0; i < n; i++) {
					counter = counter + helper(root, arr[i], high+1) - helper(root, arr[i], low);
					insert(root, arr[i]);
				}
				return counter;
			}

	153) Move all zeroes to end of array: (Lecture-20 Problem-4)
		Given an array arr[] of n positive integers.
			Push all the zeros of the given array to the right end of the array 
			while maintaining the order of non-zero elements. 
			Do the mentioned change in the array in-place.

			Example 1:
				Input:
				N = 5
				Arr[] = {3, 5, 0, 0, 4}
				Output: 3 5 4 0 0
				Explanation: The non-zero elements
				preserve their order while the 0
				elements are moved to the right.

			Example 2:
				Input:
				N = 4
				Arr[] = {0, 0, 0, 4}
				Output: 4 0 0 0
				Explanation: 4 is the only non-zero
				element and it gets moved to the left.

			Your Task:
				You don't need to read input or print anything. 
				Complete the function pushZerosToEnd() which takes the array 
				arr[] and its size n as input parameters and modifies arr[] 
				in-place such that all the zeroes are moved to the right.  

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 105
				0 ≤ arri ≤ 105

		class Solution{
			public:
				void pushZerosToEnd(int arr[], int n) {
				
					vector<int> storer;
					for(int i=0; i<n; i++){
						if(arr[i] != 0)
							storer.push_back(arr[i]);
					}
					
					int i;
					for(i=0; i<storer.size(); i++){
						arr[i] = storer[i];
					}
					
					for(i;i<n; i++){
						arr[i] = 0;
					}
				}
		};

		//in-place(without using extra space, O(1)):
			class Solution{
				public:
					void pushZerosToEnd(int arr[], int n) {
						int cnt=0;
						for(int i=0; i<n; i++){
							if(arr[i] != 0)
								arr[cnt++] = arr[i];
						}
						for(int i=cnt;i<n; i++){
							arr[i] = 0;
						}
					}
			};

			//or
				class Solution{
					public:
						void pushZerosToEnd(int arr[], int n) {
							int cnt=0;
							for(int i=0; i<n; i++){
								if(arr[i] != 0)
									swap(arr[cnt++], arr[i]);
							}
						}
					};

	154) Missing Number:
		Given an array nums containing n distinct numbers in the range [0, n], 
			return the only number in the range that is missing from the array.		

			Example 1:
				Input: nums = [3,0,1]
				Output: 2
				Explanation: n = 3 since there are 3 numbers, 
				so all numbers are in the range [0,3]. 
				2 is the missing number in the range since 
				it does not appear in nums.

			Example 2:
				Input: nums = [0,1]
				Output: 2
				Explanation: n = 2 since there are 2 numbers, 
				so all numbers are in the range [0,2]. 
				2 is the missing number in the range since 
				it does not appear in nums.

			Example 3:
				Input: nums = [9,6,4,2,3,5,7,0,1]
				Output: 8
				Explanation: n = 9 since there are 9 numbers, 
				so all numbers are in the range [0,9]. 
				8 is the missing number in the range since 
				it does not appear in nums.

			Constraints:
				n == nums.length
				1 <= n <= 104
				0 <= nums[i] <= n
				All the numbers of nums are unique.

		// Brute force solution
			class Solution {
				public:
				int missingNumber(vector<int>& nums) {
					int maxValue = *max_element(nums.begin(), nums.end());
					int cnt=0;
					for(int i: nums){
						if(find(nums.begin(), nums.end(), cnt) == nums.end())
							return cnt;
						cnt++;
					}
					return cnt;
				}
			};

		class Solution {
			public:
			int missingNumber(vector<int>& nums) {
				int n = nums.size();

				//finding sum of n num.
				int Actualsum = n*(n+1)/2;

				int FakeSum = 0;
				for(int i: nums){
					FakeSum += i;
				}
				return Actualsum-FakeSum;
			}
		};
	
	155) Frequencies of Limited Range Array Elements:
		Given an array arr[] of N positive integers which can contain integers from 1 to P 
			where elements can be repeated or can be absent from the array. 
			Your task is to count the frequency of all numbers from 1 to N. 
			Make in-place changes in arr[], such that arr[i] = frequency(i). Assume 1-based indexing.
			Note: The elements greater than N in the array can be ignored for counting and do modify the array in-place. 

			Example 1:
				Input:
				N = 5
				arr[] = {2, 3, 2, 3, 5}
				P = 5
				Output:
				0 2 2 0 1
				Explanation: 
				Counting frequencies of each array element
				We have:
				1 occurring 0 times.
				2 occurring 2 times.
				3 occurring 2 times.
				4 occurring 0 times.
				5 occurring 1 time.

			Example 2:
				Input:
				N = 4
				arr[] = {3,3,3,3}
				P = 3
				Output:
				0 0 4 0
				Explanation: 
				Counting frequencies of each array element
				We have:
				1 occurring 0 times.
				2 occurring 0 times.
				3 occurring 4 times.
				4 occurring 0 times.

			Example 3:
				Input:
				N = 2
				arr[] = {8,9}
				P = 9
				Output:
				0 0
				Explanation: 
				Counting frequencies of each array element
				We have:
				1 occurring 0 times.
				2 occurring 0 times.
				Since here P=9, but there are no 9th Index present so can't count the value.
			
			Your Task:
				You don't need to read input or print anything. 
				Complete the function frequencyCount() that takes the array arr, and integers n, 
				and p as input parameters and modify the array in-place to denote the frequency count of each element from 1 to N.

			Expected time complexity: O(N)
			Expected auxiliay space: O(1)

			Constraints:
				1 ≤ N ≤ 105
				1 ≤ P ≤ 4*104 
				1 <= arr[i] <= P

		//Not Optimized:
			class Solution{
				public:
				//Function to count the frequency of all elements from 1 to N in the array.
				void frequencyCount(vector<int>& arr,int N, int P) { 
					int value = 1;
					vector<int> ans;
					for(int i=0; i<N; i++){
						int cnt=0;
						for(int j=0; j<N; j++){
							if(arr[j] == value)
								cnt++;
						}
						ans.push_back(cnt);
						value++;
					}
					arr = ans;
				}
			};

		//Optimized:
			class Solution{
				public:
				//Function to count the frequency of all elements from 1 to N in the array.
				void frequencyCount(vector<int>& arr,int N, int P) {

					//using unordered_map to keep the frequency of element
					unordered_map<int, int> FreqCounter;
					for(int i=0; i<N; i++){
						FreqCounter[arr[i]]++;				//mapping that element count, if the element found then we are incrementing their value in map.
					}									//& default in map, if key has corresponding value then it takes that value, else the default value is zero only.
					
					int value=1;
					for(int i=0; i<N; i++){
						arr[i] = FreqCounter[value];				//here checking for that key what's the value is there in map. 
						value++;								//if found takes that value else default is zero only
					}
				}
			};

	156) Special Sum of Array:
		Problem Statement
			You have been given an array/list 'arr' of length 'N', which contains single digit elements at every index. Your
			task is to return the sum of all elements of the array. But the final sum should also be a single digit.
			To keep the output single digit - you need to keep adding the digits of the output number till a single digit is left.
			For Example:
				For the given array [5, 8, 4, 9]
				The sum of the elements of the array will be
				5 + 8 + 4 + 9 = 26
				Since 26 is not a single-digit number, we will again take the sum of the digits of 26.
				2 + 6 = 8.
				Now 8 is a single-digit number. So we will stop here and return 8.
			Constraints:
				1 <= Т <= 100
				1 <= N <= 10^3
				0 <= arr[i] <= 9
				It is guaranteed that the sum of 'N' over all test cases doesn't exceed 10^5.
				Time Limit: 1 sec.

			Sample Input 1:
				2
				5
				8 7 0 1 2
				4
				4 2 1 1
				Sample Output 1:
				9
				8
				Explanation For Sample Output 1:
				Test Case 1:

				For the given array [8, 7, 0, 1, 2]
				The sum of the elements of the array will be
				8 + 7 + 0 + 1 + 2 = 18.

				Since 18 is not a single-digit number, we will again take the sum of the digits of 18. 
				1 + 8 = 9.
				Now 9 is a single-digit number. So we will stop here and return 9.

				Test Case 2:

				For the given array [4, 2, 1, 1]
				The sum of the elements of the array will be
				4 + 2+ 1 + 1 = 8.
				Since 8 is a single-digit number, we will just return 8.
				Sample Input 2:
				2
				4
				3 1 2 1
				9
				1 9 4 6 2 8 2 0 1
				Sample Output 2:
				7
				6

		#include <bits/stdc++.h> 
		int specialSum(vector<int>& arr, int n){
			int sum =0;
			for(int i=0; i<n; i++){
				sum += arr[i];
			}
			check:
			if(sum <= 9)
				return sum;

			vector<int> ans;
			while(sum != 0 ){
				ans.push_back(sum%10);
				sum /= 10;
			}
			sum =0;
			for(int i=0; i<ans.size(); i++){
				sum += ans[i];
			}
			goto check;
		}
	
	157) Left Rotate an Array by One:
		Problem Statement
			Given an array 'arr' containing 'n' elements, rotate this array left once and return it.
			Rotating the array left by one means shifting all elements by one place to the left and moving the first
			element to the last position in the array.
			Example:
				Input: 'a' = 5, 'arr' = [1, 2, 3, 4, 5]
				Output: [2, 3, 4, 5, 1]
				Explanation: We moved the 2nd element to the 1st position, and 3rd element to the 2nd
				position, and 4th element to the 3rd position, and the 5th element to the 4th position,
				and move the 1st element to the 5th position.
			Expected Time Complexity:
				O( n ), Where ‘n’ is the size of an input array ‘arr’.

			Constraints :
				1 <= 'n' <= 10^5
				1 <= 'arr[i] <= 10^9
				Time Limit: 1 sec

			Sample Input 1:
				4
				5 7 3 2 
				Sample Output 1:
				7 3 2 5
				Explanation Of Sample Input 1:
				Move the first element to the last and rest all the elements to the left.
				Sample Input 2:
				5
				4 0 3 2 5 
				Sample Output 2:
				0 3 2 5 4
				Explanation Of Sample Input 2:
				Same as sample input 1, Move the first element to the last and rest all the elements to the left

		#include <bits/stdc++.h> 
		vector<int> rotateArray(vector<int>& arr, int n) {
			int value = arr[0];
			arr.erase(arr.begin());
			arr.push_back(value);
			return arr;
		}

		//or
			#include <bits/stdc++.h> 
			vector<int> rotateArray(vector<int>& arr, int n) {
				int value = arr[0];
				for(int i=0; i<n-1; i++){
					arr[i] = arr[i+1];
				}
				arr[n-1] = value;
				return arr;
			}

	158) Digit Count In Range:
		Problem Statement
			You are given an integer "K', and two numbers 'A' and 'B'. You need 
			to count the occurrences of the given digit 'K', in the range [A, B].
			Note:
				You need to count occurrences at every place of the number. You also need to include the
				lower and higher limits of the given range
			For Example:
				Given K = 3, A = 1, B = 15, then 3 occurs 2 times(3, 13) in the range [1, 15], so you need
				to print 2.
			Constraints:
				1 ‹= T ‹= 100
				0 <= K <= 9
				0 ‹= А, В ‹= 10^18
				where "T' is the number of test cases, "K' is the digit and "A' and "B"  are the two integers.
				Time limit: 1 sec
			Sample Input 1:
				2
				3
				1 15
				2
				2 12
				Sample Output 1:
				2
				2
				Explanation Of Sample Input 1:
				In the first test case, 
				Number of occurrences of 3 in range [1, 13] = 2 (3, 13). Return 2


				In the second test case, 
				Number of occurrences of 2 in range [2, 12] = 2 (2, 12). Return 2
				Sample Input 2:
				2
				1 
				1 15
				3
				3 33
				Sample Output 2:
				8
				8
				Explanation Of Sample Input 1:
				In the first test case, 
				Number of occurrences of 1 in range [1, 15] = 8 (1, 10, 11, 12, 13, 14, 15). Return 8

				In the second test case, 
				Number of occurrences of 3 in range [3, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8
		
		//Not Optimized:
			#include <bits/stdc++.h> 
			long long int digitCount(int K, long long int A, long long int B) {
				// Write your code here
				long long int cnt=0;
				for(long long int i = A; i<=B; i++){
					long long int currentValue = i;
					while(currentValue != 0){
						if(K == (currentValue%10))
							cnt++;
						currentValue /=10;
					}
				}
				return cnt;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			long long int dp[2][2][20][20];

			long long int solve(string &x, bool is_started, bool is_smaller, long long int sum, int ind, int k){
				if(ind == x.size())return sum;
				if(dp[is_started][is_smaller][sum][ind]!=-1)return dp[is_started][is_smaller][sum][ind];

				int range = is_smaller?9:(x[ind]-'0');
				long long int ans = 0LL;

				for(int i=0;i<=range;i++){
					bool newIs_smaller = is_smaller?true: (i!=range);
					bool newIs_started = is_started?true: (i!=0);
					if(newIs_started)ans +=solve(x,newIs_started,newIs_smaller,sum+(i==k),ind+1,k);
					else ans +=solve(x,newIs_started,newIs_smaller,sum,ind+1,k);
				}

				return dp[is_started][is_smaller][sum][ind] = ans;
			}

			long long int helper(long long int n, int k) {
				memset(dp,-1,sizeof(dp));
				string num = to_string(n);
				return solve(num,0,0,0,0,k);
			}

			long long int digitCount(int K, long long int A, long long int B) {
				return helper(B,K)-helper(A-1,K);
			}
	
	159) Alternate Positive and Negative:
		Problem Statement
			You are given an array 'arr' that contains an equal number of positive and negative elements. Rearrange the
			given array such that positive and negative numbers are arranged alternatively. Also, the respective relative
			order of positive and negative should be maintained.
			For example:
				For the given arr[ ] = { -1, 3, 5, 0, -2, -5 }
				arr[ ] = {3, -1, 5, -2, 0, -5 } is valid rearrangement.
				arr[ ] - {3, -1, 0, -2, 5, -5 } is invalid rearrangement; order of 0 and 5 is changed.
				arr[ ] - {3, -1, 5, 0, -2, -5 } is invalid rearrangement; positive and negative elements are not alternative.
			Note:
				Make changes in the same array and no returning or printing is needed.
				Consider zero(0) as a positive element for this question.
				
			It is guaranteed that an answer always exists.
			Constraints:
				1 <= T <= 5
				1 <= N <= 5 * 10 ^ 3
				-10 ^ 9 <= arr[i] <= 10 ^ 9
				Time Limit: 1 sec.
			
			Sample Input 1:
				2
				6
				1 2 3 -1 -2 -3
				8
				1 -10 5 -1 2 -3 0 -2
				Sample Output 1:
				1 -1 2 -2 3 -3 
				1 -10 5 -1 2 -3 0 -2 
				Explanation Of Sample Input 1:
				In the first test case, the output is an array of alternative positive and negative numbers, 
				and also order is maintained (relative order of positive numbers are 1 -> 2 -> 3 and for negative numbers are -1 -> 2 -> -3 )

				In the first test case, it is already in valid arrangement.
				Sample Input 2:
				1
				4
				-1 0 0 -1
				Sample Output 2:
				0 -1 0 -1 
				Explanation Of Sample Output 2:
				In the first test case, the output is an array of alternative positive and negative numbers and also order is maintained.

		#include <bits/stdc++.h> 
		void posAndNeg(vector<int> &arr) {
			vector<int> negativeStorer;
			vector<int> postiveStorer;
			int n = arr.size();
			for(int i=0; i<n; i++){
				if(arr[i] < 0 )
					negativeStorer.push_back(arr[i]);
				else
					postiveStorer.push_back(arr[i]);
			}

			int cntPOS=0, cntNEG=0;
			for(int i=0; i<n; i++){
				if(i&1)
					arr[i] = negativeStorer[cntNEG++];
				else
					arr[i] = postiveStorer[cntPOS++];
			}
		}
	
	160) Minimum distance between two numbers:
		You are given an array a, of n elements. 
			Find the minimum index based distance between two distinct elements of the array, x and y. 
			Return -1, if either x or y does not exist in the array.

			Example 1:
				Input:
				N = 4
				A[] = {1,2,3,2}
				x = 1, y = 2
				Output: 1
				Explanation: x = 1 and y = 2. There are
				two distances between x and y, which are
				1 and 3 out of which the least is 1.

			Example 2:
				Input:
				N = 7
				A[] = {86,39,90,67,84,66,62}
				x = 42, y = 12
				Output: -1
				Explanation: x = 42 and y = 12. We return
				-1 as x and y don't exist in the array.

			Your Task:
				Complete the function minDist() which takes the array a, and 3 integers n, x and y 
				as input parameters and returns the minimum distance between x and y in the array. 
				Return -1, if either x or y does not exist in the array.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 105
				0 <= a[i], x, y <= 105
				x != y

		class Solution{
			public:
			int minDist(int a[], int n, int x, int y) {
				vector<int> ans(a, a+n);
				
				//checking elements are present, if any one of them is not present then directly return -1, CLOSING PROGRAM
				if(find(ans.begin(), ans.end(), x) == ans.end() || find(ans.begin(), ans.end(), y) == ans.end())
					return -1;
				
				vector<int> indexX;
				vector<int> indexY;
				
				for(int i=0; i<n; i++){
					if(a[i] == x)
						indexX.push_back(i);
					
					if(a[i] == y)
						indexY.push_back(i);
				}
				
				int minSpace=INT_MAX;
				
				for(int i=0; i<indexX.size(); i++){
					for(int j=0; j<indexY.size(); j++){
						int value = abs(indexX[i] - indexY[j]);
						if(minSpace > value){
							minSpace = value;
						}
					}
				}
				return minSpace;
			}
		};

	161) Author And Books:
		Problem Statement
			You are given a certain format of books and their authors.
			For example -
				NameOfAuthor1 Book1 Book2
				NameoffAuthor2 Book1
				Your task is to print the given information in the following manner:
				1. NameOfAuthor1
					A. Book1
					B. Book2
				2. NameOfAuthor2
					A. Book1
				You are given a 2D array of strings 'S' where each vector is the information about the i-th author, 
				the first index of this vector is the 'NameOfAuthor" and the other indexes 
				are the 'Books' written by the author. You are supposed to print the Authors and 
				their books in the above mentioned format.
			Sample Input 1 :
				2
				2
				4 ChetanBhagat TwoStates Revolution HalfGirlfriend OneIndianGirl
				2 JKRowling HarryPotter FantasticBeasts
				1
				2 JeffreyArcher OldLove FalseImpression
				Sample Output 1 :
				1. ChetanBhagat
				A. TwoStates
				B. Revolution
				C. HalfGirlfriend
				D. OneIndianGirl 
				2. JKRowling
				A. HarryPotter
				B. FantasticBeasts
				1. JeffreyArcher
				A. OldLove 
				B. FalseImpression
				Explanation For Sample Input 1 :
				For, the first test case, the expected array to be returned is,
				[“1. ChetanBhagat”, “B. Revolution”, “C. HalfGirlfriend”, “D. OneIndianGirl”,  “ 2. JKRowling
				“, “A. HarryPotter”, “B. FantasticBeasts”]
				For, the second test case the expected array to be returned is,
				[“1. JeffreyArcher”, “A. OldLove”, “B. FalseImpression”].
				Sample Input 2 :
				2
				1
				2 RoaldDahl LambToTheSlaughter TheWitches
				1
				1 JhumpaLahiri ARealDurwan
				Sample Output 2 :
				1. RoaldDahl
				A. LambToTheSlaughter
				B. TheWitches
				1. JhumpaLahiri
				A. ARealDurwan

		#include <bits/stdc++.h> 
		vector<string> arrangeAuthors(vector<vector<string> > &s) {
			vector<string> ans;
			for(int i=0; i<s.size(); i++){
				string temp = to_string(i+1)+ ". "+s[i][0];
				ans.push_back(temp);
				char ch = 'A';
				for(int j=1; j<s[i].size(); j++){
					string temp2 = string(1,ch) +". "+s[i][j];
					ans.push_back(temp2);
					ch++;
				}
			}
			return ans;
		}

	162)	Secret Omen Patten:
		Problem  Statement:
			Your task is to determine whether there exists a "secret pattern" within the
			array, and if so, return '1'; otherwise, return '0'.
			A "secret pattern" is defined as a set of three consecutive elements in the array,
			the sum of which is divisible by '10'.
			Sample Input 1 :
				2
				5
				1 2 3 4 1
				4
				30 10 20 10
				Sample Output 1 :
				0
				1
				Explanation of sample input 1 :
				First test case:-
				There are three sets of three consecutive elements in the given array.
				The sums of all three sets are less than '10'.
				Thus, the answer is '0'.

				Second test case:-
				Every element is divisible by '10'.
				Therefore, the sum of any three consecutive elements will be divisible by '10'.
				Thus, the answer is '1'.
				Sample Input 2 :
				2
				3
				1082 1 1037
				4
				34 225 17 9
				Sample Output 2 :
				1
				0
			Constraints :
				1 <= 'T' <= 10
				3 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^8
				Time Limit: 1 sec

			Example :
				Let 'N' = 4, 'A' = [ 10, 11, 21, 8 ].
				There are two sets of three consecutive elements in the given
				array.
				The first, second, and third elements make the first set, with a
				sum of '10 + 11 + 21 = 42', which is not divisible by '10'.
				The second, third, and fourth elements make the second set, with a
				sum of '11 + 21 + 8 = 40', which is divisible by '10'. Therefore,
				the array does contain the 'secret code'.
				Thus, the answer is '1'.

		int secretCode(int n, vector<int> &a) {
			int sum =0;
			for(int i=0; i<a.size()-2; i++){
				sum = a[i]+a[i+1]+a[i+2];
				if(sum %10==0)
					return 1;
				sum=0;
			}
			return 0;
		}
	
	163) Supreme Bat
		Problem Statement
			You have an array 'A' of length 'N' representing 'N' bats, with the weight of the
			'i-th' bat being 'A[i]'.
			A player from the Australian cricket team is searching for a 'Supreme' bat. A bat
			is called 'Supreme' if its weight is greater than or equal to 'X' and less than or
			equal to 'Y'.
			Since lighter bats are preferred by players, return the weight of the lightest
			'Supreme bat' from 'A'. If there is no such bat, return '-1'.
			For Example:-
				Let 'N' - 5, 'X' - 2, 'Y' - 7, and 'A' - [1, 5, 3, 4, 8].
				The lightest bat with a weight greater than or equal to 'X' and
				less than or equal to 'Y' is of weight '3'.
				Hence, the final output is '3'.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				1 ‹= 'X' ‹= 'Y' <= 10^5
				1 < 'A[i]' <= 10^5
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				4 5 8
				3 4 1 4
				2 5 8
				6 3
				Sample Output 1:-
				-1
				6
				Explanation of sample input 1:-
					First test case:-
					Here, a bat with a weight greater than or equal to 'X' and less
					than or equal to 'Y' is not present. Thus, no such bat exists.
					Hence, the answer is '-1'.
				Second test case:-
				The lightest bat with a weight greater than or equal to 'X' and
				less than or equal to 'Y' is of weight '6'
				Hence, the answer is '6'.
				Sample Input 2:-
				2
				3 1 1
				3 2 1
				6 6 8
				3 6 1 4 3 6
				Sample Output 2:-
				1
				6

		int xAndY(int x, int y, vector<int> &a) {
			// Write your code here.
			int minValue=INT_MAX;
			for(int i=0; i<a.size(); i++){
				if(a[i]>=x && a[i]<=y){
					minValue = min(minValue,a[i]);
				}
			}
			if(minValue != INT_MAX)
				return minValue;
			return -1;
		}

		//or not optimized
		int xAndY(int x, int y, vector<int> &a) {
			sort(a.begin(), a.end());
			for(int i=0; i<a.size(); i++) {
				if(a[i]>=x && a[i]<=y) {
					return a[i];
				}
			}
			return -1;
		}
	
	164) Performance Impact Sum:
		Problem statement:
			1. If the performance value 'X[i]' is divisible by '3', 'Y[i]' is set to 'X[i]'.
			2. If 'X[]' is not divisible by '3', 'Y[i]' is the square of 'X[I]'.
			Your task is to calculate the sum of the elements in the 'Y' array, which
			represents the overall impact or contribution of the players in the match based
			on these rules.

			Example:
				'N' = 3 'X'= [3, 4, 1]
				Since X[0] is divisible by "3', Y[0]=3.
				Here X[1] and X[2] are not divisible by 3,
				So Y[1]=4*4=16 and Y[2]=1*1=1.
				Y[0]+Y[1]+Y[2]=20.

			Sample Input 1 :
				2
				3 
				6 3 1
				3 
				1 2 1
				Sample Output 1 :
				10
				6   
				Explanation Of Sample Input 1 :
				For test case 1:
				As X[0] and X[1] are divisible by ‘3’ and X[2] is not divisible by ‘3’, Y=[6,3,1]. Hence sum is 10.

				For test case 2:
				All array ‘X’ elements are not divisible by ‘3’, Y=[1,4,1]. Hence the answer is 6.
				Sample Input 2 :
				2
				3
				1 1 1
				4  
				1 2 3 4 
				Sample Output 2 :
				3
				30
			Constraints:
			1 <= T <= 10
			1 <= N <= 10^4
			1 <= X[i] <= 10^2
			Time Limit: 1 sec

		int divisible3(int n, vector<int> x) {
			int sum =0;
			for(int i=0; i<x.size(); i++){
				if(x[i] % 3 ==0)
				sum += x[i];
				else
				sum += (x[i] * x[i]);
			}
			return sum;
		}
	
	165) Binary Search:
		Problem statement:
			You are given an integer array 'A' of size 'N', sorted in non-decreasing order. 
			You are also given an integer 'target'.
			Your task is to write a function to search for 'target' in the array 'A'. 
			If it exists, return its index in 0-based indexing. 
			If 'target' is not present in the array 'A', return -1.
			Note:
				You must write an algorithm whose time complexity is O(LogN)
			Example:
				Input: ‘N’ = 7 ‘target’ = 3
				‘A’ = [1, 3, 7, 9, 11, 12, 45]
				Output: 1
				Explanation: A = [1, 3, 7, 9, 11, 12, 45],
				The index of element '3' is 1.
				Hence, the answer is '1'.

			Sample Input 1:
				7
				1 3 7 9 11 12 45
				3
				Sample Output 1:
				1
				Explanation of sample output 1:
				nums = [1, 3, 7, 9, 11, 12, 45],
				The index of element '3' is 1.
				Hence, the answer is '1'.


				Sample Input 2:
				7
				1 2 3 4 5 6 7
				9
				Sample Output 2:
				-1
				Explanation of sample output 2:
				nums = [1, 2, 3, 4, 5, 6, 7],
				Element '9' doesn't exist.
				Hence, the answer is '-1'.

		int search(vector<int> &nums, int target) {
			int start = 0;
			int end = nums.size()-1;
			int mid = (start+end)/2;

			while(start<=end){
				mid= (start+end)/2;
				if(nums[mid] == target)
					return mid;
				else if(nums[mid] > target)
					end = mid - 1;
				else
					start = mid + 1;
			}
			return -1;
			// for(int i=0; i< nums.size(); i++){
			//     if(target == nums[i])
			//         return i;
			// }
			// return -1;
		}
	
	166) Binary to Decimal:
		Sample Input 1:
				2
				7
				1010101
				4
				1011
				Sample Output 1:
				85
				11
				Explanation of Sample Input 1:
				Test case 1:

				The Decimal equivalent of the Binary number “1010101” is 85.

				Test case 2:
				The Decimal equivalent of the Binary number “1011” is 11.
				Sample Input 2:
				2
				4
				1111       
				1
				0
				Sample Output 2:
				15
				0
				Explanation of Sample Input 2:
				Test case 1:

				The Decimal equivalent of the Binary number “1111” is 15.

				Test case 2:

				The Decimal equivalent of the Binary number “0” is 0.

		#include <bits/stdc++.h>
		int convert(int N,string &str) {
			return stoi(str, 0,2);
		}
	
	167) Linear Probing:
		Problem Statement:
			The hash function you need to consider is H(X) = X mod N i.e. index = X mod N.
			Return an array 'HASH_TABLE' of size N in which:
			HASH_TABLE[i] = KEYS[j] where, i = KEYS[j] mod N
			In short, an element at index 'ї is the element from the given array KEYS which is mapped to that index.
			You can refer to the example given below:
			Sample Input 1:
				2
				5
				5 3 2 6 4
				4
				1 5 3 7
				Sample Output 1:
				5 6 2 3 4
				7 1 5 3
				Explanation
				For test case 1:
				H(X) = X mod 5
				All the numbers have unique hash values so there is no collision. Just map each index to its hash index.

				For test case 2:
				H(1) = 1L index 1 is unoccupied so we will map index 1 with 1.
				H(5) = 1: but, index 1 is occupied, so, we will use index 2 which is unoccupied, and will map index 2 with 5.
				H(3) = 3: index 3 is unoccupied so we will map index 3 with 3.
				H(7) = 3, but index 3 is occupied so we will use index 0 which is unoccupied and will map index 0 with 7.
				Sample Input 2:
				2
				6
				4 7 8 1 2 5
				3
				6 7 10
				Sample Output 2:
				5 7 8 1 4 2
				6 7 10

			Constraints:
				1 <= T <= 10
				1 <= N <= 500
				0 <= KEYS[ i ] <= 10^9
				Time limit: 1 sec

			#include <bits/stdc++.h> 
			vector<int> linearProbing(vector<int> keys) {
				int n = keys.size();
				vector<int> hashedAns(n, -1);

				for(int i=0; i<keys.size(); i++){
					int index = keys[i] % n;

					back:
					if(hashedAns[index] == -1)
						hashedAns[index] = keys[i];
					else{
						index++;
						index = index % n;
						goto back;
					}
				}
				return hashedAns;    
			}

	168) Find Transition Point:
		Problem Statement:
			Given a sorted array containing only 0s and 1s, find the transition point, 
			i.e., the first index where 1 was observed, and before that, only 0 was observed.

			Example 1:
				Input:
				N = 5
				arr[] = {0,0,0,1,1}
				Output: 3
				Explanation: index 3 is the transition 
				point where 1 begins.

			Example 2:
				Input:
				N = 4
				arr[] = {0,0,0,0}
				Output: -1
				Explanation: Since, there is no "1",
				the answer is -1.

			Your Task:
				You don't need to read input or print anything. 
				The task is to complete the function transitionPoint() that takes array arr and N as 
				input parameters and returns the 0-based index of the position where 0 ends and 1 begins. 
				If array does not have any 1, return -1. If array does not have any 0, return 0.

			Expected Time Complexity: O(Log(N))
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 105
				0 ≤ arr[i] ≤ 1

		int transitionPoint(int arr[], int n) {
			for(int i=0; i<n; i++){
				if(arr[i] == 1)
					return i;
			}
			return -1;
			// int i;
			// for (i = 0; i < n && arr[i] == 0; i++) {
			//     // Iterate until a 1 is found, or the end of the array is reached.
			// }
			// return (i < n) ? i : -1;

			/*or
				 int i;
				for (i = 0; i < n && arr[i] == 0; i++);
				return (i < n) ? i : -1;
			*/
		}

	169) Ninjas and Indices:
		Problem Statement
			Ninja is given three arrays 'A', 'B' and 'C' of length 'N' each. A pair of indices (i, j) where 0<= i, j < 'N'is
			called 'good' if 'A[i]' is equal to 'B[C[j]]'.
			Return an integer 'X' denoting the number of good indexes.
			Assume 0-based indexing.
			For Example:
				Let 'N' = 3, 'A' = [0, 1, 1], 'B' = [2, 0, 1] and 'C' = [1, 2, 1].
				(0, 0) is a good pair as 'A[0]' = 'B[C[°]]'.
				(0, 2) is a good pair as 'A[0]' = 'B[C[2]]' -
				(1, 1) is a good pair as 'A[1]' = 'B[C[1]]'.|
				(2, 1) is a good pair as 'A[2]' = 'B[C[1]]'-
				Hence the answer is 4.
			Constraints:-
				1 <= 'T' ‹= 10
				1 ‹= 'N' ‹= 10^5
				0 < 'A[i]', 'B[i]', 'C[i]' < 'N'
				The sum of 'N' over all test cases does not exceed 10^5.
				Time Limit: 1 sec.
		Sample Input 1:-
			2
			3
			0 1 2
			1 0 1
			0 1 2
			1 
			0
			0
			0
			Sample Output 1:-
			3
			1
			Explanation Of Sample Input 1:-
			First test case:-
			(0, 1) is a good pair as 'A[0]' = 'B[C[1]]'.
			(1, 2) is a good pair as 'A[1]' = 'B[C[2]]'.
			(1, 0) is a good pair as 'A[1]' = 'B[C[0]]'.
			Hence the answer is 3.

			Second test case:-
			'N' is 1. So, only one good pair exists.
			Sample Input 2:-
			2
			3
			0 1 0
			2 2 2
			0 1 0
			2
			0 1
			1 1
			0 0
			Sample Output 2:-
			0
			2
		
		long long findCount(int n, vector<int> &a, vector<int> &b, vector<int> &c){
			long long cnt=0;
			for(int i=0; i<n; i++){
				for(int j=0; j<n; j++){
					if(a[i] == b[c[j]])
						cnt++;
				}
			}
			return cnt;
		}

	170) String Clear:
		Problem Statement
			You are given a string 'S' consisting only of characters 'c' and 'n'
			In one move, you can choose any two consecutive characters that are different from each other and remove
			them from the string.
			If it is possible to make the whole string empty by applying this move any number of times, return 1.
			Otherwise, return 0.
			Hint:
				Focus on how the counts of 'c' and 'n' change after each operation.
				We are asked to check if both of these counts reach zero at the end.
			Example:
				'S' = "encenn"
				We can apply the operations in the following manner to make the string empty:
				"cnecnn" → "encn" → "cn" → ""
				So, the answer will be 1.
			Constraints :
				1 <= T ‹= 10
				1 <= '|5|' ‹= 10^5,
				Where S| denotes the length of the string 'S'.
				Time Limit: 1 sec

			Sample Input 1:
				2
				cn
				c
				Sample Output 1:
				1
				0
				Explanation Of Sample Input 1:
				For test case 1:
				You can erase the whole string in a single move as the two characters are different.

				For test case 2:
				You can't make a move because there is only a single character.
				Sample Input 2:
				2
				cncncnccnn
				cncncnccnc
				Sample Output 2:
				1
				0

		int stringClear(string &s){
			int cntC=0, cntN=0;
			for(int i=0; i<s.length(); i++){
				if(s[i] == 'c')
					cntC++;
				else
					cntN++;
			}
			return (cntN==cntC)?1:0;
		}
	
	171) Top K Frequent Elements in Array - |:
		Problem statement:
			Given a non-empty array nums[] of integers of length N, 
			find the top k elements which have the highest frequency in the array. 
			If two numbers have same frequencies, then 
			the larger number should be given more preference.

			Example 1:
				Input:
				N = 6
				nums = {1,1,1,2,2,3}
				k = 2
				Output: {1, 2}

			Example 2:
				Input:
				N = 8
				nums = {1,1,2,2,3,3,3,4}
				k = 2
				Output: {3, 2}
				Explanation: Elements 1 and 2 have the
				same frequency ie. 2. Therefore, in this
				case, the answer includes the element 2
				as 2 > 1.

			User Task:
				You don't have to read or print anything. 
				You will have to complete the function topK() that takes an array nums[] 
				and integer k as input and returns a list of top k most frequent elements. 
				If any two elements have same frequencies, then give more preference to the larger elemet.

			Expected Time Complexity : O(NlogN)
			Expected Auxilliary Space : O(N)

			Constraints:
				1 <= N <= 105
				1<= nums[i] <=105
				1 <= k <= N

		class Solution {
			public:
			static bool comp(pair<int, int> a, pair<int, int> b){			//defining another function inside class then use static keyword
				if(a.second == b.second)								//or else define it outside the class.
					return a.first > b.first;
				return a.second > b.second; 
			}
			
			vector<int> topK(vector<int>& nums, int k) {
				unordered_map<int, int> FreqStorer;
				for(int i=0; i<nums.size(); i++){
					FreqStorer[nums[i]]++;
				}
				
				vector<pair<int,int>> ans;
				for(auto i: FreqStorer){
					pair<int, int> temp = {i.first, i.second};
					ans.push_back(temp);
				}
				
				vector<int> topKelements;
				sort(ans.begin(), ans.end(), comp);			//refer below code also, comp function written inside sort function only.
				
				int cnt=0;
				for(int i=0; i<ans.size() && cnt<k; i++){
					topKelements.push_back(ans[i].first);
					cnt++;
				}
				
				return topKelements;
			}
		};

		//or
			vector<int> topK(vector<int>& nums, int k) {
				unordered_map<int, int> FreqStorer;
				for(int i=0; i<nums.size(); i++){
					FreqStorer[nums[i]]++;
				}
				
				vector<pair<int,int>> ans;
				for(auto i: FreqStorer){
					pair<int, int> temp = {i.first, i.second};
					ans.push_back(temp);
				}
				
				vector<int> topKelements;
				sort(ans.begin(), ans.end(), [](pair<int, int> a, pair<int, int> b){
					if(a.second == b.second)
						return a.first > b.first;
					return a.second > b.second;
				});
				
				int cnt=0;
				for(int i=0; i<ans.size() && cnt<k; i++){
					topKelements.push_back(ans[i].first);
					cnt++;
				}
				
				return topKelements;
			}

	172) Find the Winner of an Array Game:
		Problem Statement:
			Given an integer array arr of distinct integers and an integer k.
			A game will be played between the first two elements of the array 
			(i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], 
			the larger integer wins and remains at position 0, and the smaller integer moves to the 
			end of the array. The game ends when an integer wins k consecutive rounds.

			Return the integer which will win the game.
			It is guaranteed that there will be a winner of the game.

			Example 1:
				Input: arr = [2,1,3,5,4,6,7], k = 2
				Output: 5
				Explanation: Let's see the rounds of the game:
				Round |       arr       | winner | win_count
				1  	 | [2,1,3,5,4,6,7] | 2      | 1
				2  	 | [2,3,5,4,6,7,1] | 3      | 1
				3   	 | [3,5,4,6,7,1,2] | 5      | 1
				4   	 | [5,4,6,7,1,2,3] | 5      | 2
				So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.

			Example 2:
				Input: arr = [3,2,1], k = 10
				Output: 3
				Explanation: 3 will win the first 10 rounds consecutively.
			
			Constraints:
				2 <= arr.length <= 10^5
				1 <= arr[i] <= 10^6
				arr contains distinct integers.
				1 <= k <= 10^9

		//Not Optimized:
			class Solution {
				public:
				int getWinner(vector<int>& arr, int k) {
					int winCNT=0;

					if(k>= arr.size()-1)					//if k is greater or equal to array size, then max element always wins.
						return *max_element(arr.begin(), arr.end());

					while(winCNT < k){
						if(arr[0] > arr[1]){
							int value = arr[1];
							arr.erase(arr.begin()+1);
							arr.push_back(value);
							winCNT++;
						}else{
							winCNT=1;
							int value = arr[0];
							arr.erase(arr.begin());
							arr.push_back(value);
						}
					}
					return arr[0];
				}
			};
	
		//Optimized:
			class Solution {
				public:
				int getWinner(vector<int>& arr, int k) {
					int winCNT=0;

					if(k>= arr.size()-1)
						return *max_element(arr.begin(), arr.end());

					int winner = arr[0];
					
					for(int i=1; i<arr.size(); i++){
						if(winner > arr[i]){
							winCNT++;
						}else{
							winner = arr[i];
							winCNT=1;
						}
						
						if(winCNT == k)
								break;
					}
					return winner;
				}
			};
	
	173) Reverse First K elements of Queue:
		Problem Statement
			You are given a QUEUE containing 'N' integers and an integer 'K'. You need to reverse the order of the first 'K'
			elements of the queue, leaving the other elements in the same relative order.
			You can only use the standard operations of the QUEUE STL:
				1. enqueue(x): Adds an item x to rear of the queue
				2. dequeue() : Removes an item from front of the queue
				3. size() : Returns number of elements in the queue…
				4. front() : Finds the front element.
				For Example:
					Let the given queue be { 1, 2, 3, 4, 5 } and K be 3.
					You need to reverse the first K integers of Queue which are 1, 2, and з.
					Thus, the final response will be { 3, 2, 1, 4, 5 }.
				Constraints:
					1 ‹= T ‹= 10
					1 ‹= N <= 10 ^ 5
					0 <= K <=N
					-10 ^ 9 <= queue elements <= 10 ^ 9
					Time limit: 1 sec
				Sample Input 1:
					2
					5 3
					1 2 3 4 5
					4 2
					6 2 4 1
					Sample Output 1:
					3 2 1 4 5
					2 6 4 1
					Explanation:
					For test case 1: Refer to the example explained above.

					For test case 2:
					The queue after reversing the first 2 elements i.e., 6 and 2 will be { 2, 6, 4, 1 }.
					Sample Input 2:
					2
					5 2
					5 3 2 6 4
					4 4
					1 2 3 4
					Sample Output 2:
					3 5 2 6 4
					4 3 2 1

		#include <bits/stdc++.h> 
		queue<int> reverseElements(queue<int> q, int k) {
			int size = q.size();
			queue<int> ans;
			vector<int> holder;
			for(int i=0; i<k; i++){
				int value = q.front();
				q.pop();
				holder.push_back(value);
			}
			reverse(holder.begin(), holder.end());

			int i;
			for(i=0; i<k; i++){
				ans.push(holder[i]);
			}

			for(i;i<size; i++){
				int value = q.front();
				q.pop();
				ans.push(value);
			}
			return ans;
		}
	
	174) Maximum XOR:
		Problem Statement
			You are given two arrays of non-negative integers say 'arr1' and 'arr2'. Your task is to find the maximum
			value of ( 'A' xor 'B') where 'A' and 'B' are any elements from 'arr1' and 'arr2' respectively and 'xor' represents
			the bitwise xor operation.
			Constraints:
				1 <= T <= 5
				1 <= N, M <= 1000
				0 <= arri[i], arr2[i] <= 10 ^ 9
				Where "T' denotes the number of test cases, 'N', 'M' denotes the number of elements in the
				first array and second array, 'arr[i]', and 'arr2[i]' denotes the 'i-th' element of the
				first array and second array
				Time limit: 1 sec

			Sample Input 1:
				1
				7 7
				6 6 0 6 8 5 6
				1 7 1 7 8 0 2
				Sample Output 1:
				15
				Explanation of sample input 1:
				First testcase:
				Possible pairs are (6, 7), (6, 8), (6, 2), (8, 7), (8, 8), (6, 2). And 8 xor 7 will give the maximum result i.e. 15
				Sample Input 2:
				1
				3 3
				25 10 2
				8 5 3
				Sample Output 2:
				28
				Explanation of sample input 2:
				First test case:
				28 is the maximum possible xor given by pair = (25, 5). It is the maximum possible xor among all possible pairs.

		//Not Optimized:				
			int maxXOR(int n, int m, vector<int> &arr1, vector<int> &arr2) {
				int mxer= INT_MIN;
				for(int i=0; i<arr1.size(); i++)
					for(int j=0; j<arr2.size(); j++)
						if(mxer < (arr1[i]^arr2[j]))
							mxer = arr1[i]^arr2[j];
				
				return mxer;  
			}
		
		//Optimized:
			#include <bits/stdc++.h>
			class TrieNode {
				public:
				TrieNode* children[2];

				TrieNode() {
					children[0] = nullptr;
					children[1] = nullptr;
				}
			};

			void insert(TrieNode* root, int num) {
				TrieNode* curr = root;

				for (int i = 31; i >= 0; i--) {
					int bit = (num >> i) & 1;

					if (!curr->children[bit]) {
						curr->children[bit] = new TrieNode();
					}

					curr = curr->children[bit];
				}
			}

			int findMaxXOR(TrieNode* root, vector<int>& arr) {
				int maxXOR = INT_MIN;

				for (int num : arr) {
					int currentXOR = 0;
					TrieNode* curr = root;

					for (int i = 31; i >= 0; i--) {
						int bit = (num >> i) & 1;
						int oppositeBit = 1 - bit;

						if (curr->children[oppositeBit]) {
							currentXOR |= (1 << i);
							curr = curr->children[oppositeBit];
						} else {
							curr = curr->children[bit];
						}
					}

					maxXOR = max(maxXOR, currentXOR);
				}

				return maxXOR;
			}

			int maxXOR(int n, int m, vector<int> &arr1, vector<int> &arr2) {
				TrieNode* root = new TrieNode();

				for (int num : arr1) {
					insert(root, num);
				}

				return findMaxXOR(root, arr2);
			}
	
	175) Sum of upper and lower triangles:
		Problem Statement:
			Given a square matrix of size N*N, print the sum of upper and lower triangular elements. 
			Upper Triangle consists of elements on the diagonal and above it. 
			The lower triangle consists of elements on the diagonal and below it. 

			Example 1:
				Input:
				N = 3 
				mat[][] = {{6, 5, 4},
						{1, 2, 5}
						{7, 9, 7}}
				Output: 
				29 32
				Explanation:
				The given matrix is
				6 5 4
				1 2 5
				7 9 7
				The elements of upper triangle are
				6 5 4
				  2 5
				    7
				Sum of these elements is 6+5+4+2+5+7=29.
				The elements of lower triangle are
				6
				1 2
				7 9 7
				Sum of these elements is 6+1+2+7+9+7= 32.

			Example 2:
				Input:
				N = 2
				mat[][] = {{1, 2},
						{3, 4}}
				Output: 
				7 8
				Explanation:
				Upper triangular matrix:
				1 2
				  4
				Sum of these elements are 7.
				Lower triangular matrix:
				1
				3 4
				Sum of these elements are 8.

			Your Task:
				You don't need to read input or print anything. 
				Complete the function sumTriangles() that takes matrix and 
				its size N as input parameters and returns the list of integers 
				containing the sum of upper and lower triangle.

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(1)

			Constraints: 
				1 <= N <= 10^3
				1 <= matrix[i][j] <= 10^6
		
		class Solution {  
			public:
			//Function to return sum of upper and lower triangles of a matrix.
			vector<int> sumTriangles(const vector<vector<int> >& matrix, int n) {
				vector<int> ans;
				int Usum,Lsum;
				Usum=Lsum=0;
				
				for(int i=0; i<n; i++)
					for(int j=0; j<n; j++){
						if(i <= j)
							Usum += matrix[i][j];
						
						if(i >= j)
							Lsum += matrix[i][j];
					}
				ans.push_back(Usum);
				ans.push_back(Lsum);
				return ans;
			}
		};
	
	176) Print Matrix in snake Pattern:
		Problem Statement:
			Given a matrix of size N x N. 
			Print the elements of the matrix in the snake like pattern depicted below.
			Example 1:
				Input:
				N = 3 
				matrix[][] = {{45, 48, 54},
						{21, 89, 87}
						{70, 78, 15}}
				Output: 
				45 48 54 87 89 21 70 78 15 
				Explanation:
				Matrix is as below:
				45 48 54
				21 89 87
				70 78 15
				Printing it in snake pattern will lead to 
				the output as 45 48 54 87 89 21 70 78 15.

			Example 2:
				Input:
				N = 2
				matrix[][] = {{1, 2},
						{3, 4}}
				Output: 
				1 2 4 3
				Explanation:
				Matrix is as below:
				1 2 
				3 4
				Printing it in snake pattern will 
				give output as 1 2 4 3.

			Your Task:
				You dont need to read input or print anything. 
				Complete the function snakePattern() that takes matrix as input 
				parameter and returns a list of integers in order of the values visited in the snake pattern. 

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(N * N) for the resultant list only.

			Constraints:
				1 <= N <= 10^3
				1 <= mat[i][j] <= 10^9

		class Solution {   
			public:
			//Function to return list of integers visited in snake pattern in matrix.
			vector<int> snakePattern(vector<vector<int> > matrix) {   
				vector<int> ans;
				for(int i=0; i<matrix.size(); i++){
					if(i&1)
						for(int j=matrix[0].size()-1; j>=0; j--)
							ans.push_back(matrix[i][j]);
					else
						for(int j=0; j<matrix[0].size(); j++)
							ans.push_back(matrix[i][j]);
				}
				return ans;
			}
		};
	
	177) Maximum XOR of Two Numbers in an Array:
		Problem Statement
			An array 'A' of 'N' integers is provided. Return the maximum possible number which can be created by taking
			bitwise XOR of any 2 integers of the array.
			Example:
				If the array is 2,5 and 6
				2 XOR 5 is 7
				2 XOR 6 is 4
				5 XOR 6 is 3
				Hence the answer is 7.

			Constraints:
				1 <= N <= 10^4
				1 <= A[i] <= 10^9 
				Time Limit: 1 sec

			Sample Input 1:
				3
				2 1 4
				Sample Output 1:
				6
				Explanation For Sample Input 1:
				Select the 1st and 3rd element leading to a xor value of 6.
				Sample Input 2:
				2
				3 2
				Sample Output 2:
				1

		int maximumXor(vector<int> A) {
			int mxer = 0;
			for(int i=0; i<A.size(); i++)
				for(int j=i+1; j<A.size(); j++)
					if(mxer < (A[i] ^ A[j]))
						mxer = A[i] ^ A[j];

			return mxer; 
		}
	
	178) Count Of Divisible Pairs:
		Problem Statement
			You are given two integers 'N' and 'M'. A pair (x, y) is a divisible pair if it satisfies the following conditions:
				a) 1 <=×<= 'N'
				b) 1 <= y <= 'M'
				c) x + y is divisible by 5.
			Your task is to return the count of all divisible pairs that can be formed from given 'N' and 'M'.
			Example :
				If N = 3 and M = 5, then { × = 1, y = 4 }, {× = 2, y = 3 }, {× = 3, y = 2 } are the
				pairs that satisfy the given conditions.
			Constraints :
				1 <= T ‹= 10
				1 <= N, M <= 10^9
				Time limit: 1 sec
			Sample Input 1 :
				2
				1 5
				2 3
				Sample Output 1 :
				1
				1
				Explanation Of Sample Output 1 :
				For test case 1 :
				Only (1,4) satisfy the given condition.

				For test case 2 :
				Only (2,3) satisfy the given conditions.
				Sample Input 2 :
				2
				1 3
				6 12
				Sample Output 2 :
				0
				14

		#include <bits/stdc++.h> 
		int countOfDivisiblePairs(int n, int m){
			int cnt=0;
			for(int i=1; i<=n; i++){
				for(int j=1; j<=m; j++){
					int value = i+j;
					if(value % 5 == 0)				//or	if((i+j) % 5 == 0)
						cnt++;
				}
			}
			return cnt;
		}
		
	179) Predict the Column:
		Problem Statement:
			Given a matrix(2D array) M of size N*N consisting of 0s and 1s only.
			The task is to find the column with maximum number of 0s. 
			If more than one column exists, print the one which comes first. 
			If the maximum number of 0s is 0 then return -1.

			Example:
				Input:
				N = 3
				M[][] = {{0, 0, 0},
						{1, 0, 1},
						{0, 1, 1}}
				Output:
				0
				Explanation:
				0th column (0-based indexing) is having 2 zeros which is maximum among all columns and comes first.
			Your Task:
				Your task is to complete the function columnWithMaxZero() which should return the column number 
				with the maximum number of zeros. 

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^3
				0 <= A[i][j] <= 1

		class Solution{
			public:
			/*Function to count zeros in each column
			* N : Number of rows and columns in array
			M is the matrix that is globally declared
			*/
			int columnWithMaxZeros(vector<vector<int>>arr,int N){
				
				// Your code here
				int col=0, cnt=0, maxCnt=0;
				int i,j;
				for(i=0; i<N; i++){
					for(j=0; j<N; j++){
						if(arr[j][i] == 0)
							cnt++;
					}
					
					if(maxCnt<cnt){
						col = i;
						maxCnt = cnt;
					}
					cnt=0;
				}
				
				if(maxCnt==0)
					return -1;
				return col;
			}
		};
		
	180) Find MSB In O(1):
		Problem Statement
			You are given a positive integer 'N'. 
			Your task is to find the greatest integer less than or equal to 'N' which is a power of 2.
			For Example:
				If N = 14, then the nearest integer that is less than or equal to 14 and is a power of two
				is 8(2^3). So, the answer is 8.
			Follow Up:
				Can you solve this in constant time and space complexity?
			Constraints:
				1 <= T ‹= 2 * 10^3
				1 <- N <= 10^9
				Time Limit: 1 second
			
			Sample Input 1:
				2
				4
				22
				Sample Output 1:
				4
				16
				Explanation For Sample 1:
				For the first test case, 4 itself is a power of two.
				For the second test case, the nearest integer that is less than or equal to 22 and also is a power of two is 16.
				Sample Input 2:
				2
				1
				63
				Sample Output 2:
				1
				32
				Explanation For Sample 1:
				For the first test case, 1 itself is a power of two.
				For the second test case, the nearest integer that is less than or equal to 63 and also is a power of two is 32.

		#include <bits/stdc++.h> 
		int findMSB(int n){
			int sqr=1,cnt=0;
			int miner;
			while(sqr <= n){
				sqr = pow(2,cnt++);
				if(sqr <= n)
					miner = sqr;
			}
			return miner;
		}
	
	181) Minimum Deletions To Make Character Frequencies Unique: ❌Pending
		Problem Statement
			You are given a string 'STR' consisting of lowercase English alphabets. Your take
			is to find out the minimum number of character deletions required such that each
			character in the final string has a unique frequency.
			Detailed explanation ( Input/output format, Notes, Images )|
			Constraints :
				1 <= T <= 10
				2 ‹= |STR| ‹= 10^5
				where |STR| denotes the length of the initial string "STR'.
				Time limit: 1 second
		Sample Input 1 :
			2
			babccbc
			gttqtq
			Sample Output 1 :
			1
			0
			Explanation For Sample Input 1 :
			Test Case 1 :
			The frequency of ‘a’ is 1, of ‘b’ is 3 and of ‘c’ is 3. Therefore after deletion of one character of either ‘b’ or ‘c’ makes the frequencies 1,2 and 3.

			Test Case 2 :
			The frequency of 'g' is 1, 't' is 3 and 'q' is 2. Therefore there is no need for a delete operation.
			Sample Input 2 :
			2
			abbccc
			cbbd
			Sample Output 2 :
			0
			1
			Explanation For Sample Input 2 :
			For the first test case, each character already has a unique frequency(1 for ‘a’, 2 for ‘b’ and 3 for ‘c’), hence we don’t need to do any deletions.

			For the second test case frequency of ‘c’ and ‘d’ is equal hence we need to delete either of them. Therefore the answer is 1.

		#include <bits/stdc++.h>
		int minDeletions(string str) {
			int deletionCNT=0;
			unordered_map<char, int> FreqCnt;

			for(int i=0; i<str.length(); i++){
				FreqCnt[str[i]]++;
			}

			vector<int> holder;
			for(auto i: FreqCnt){
				holder.push_back(i.second);
			}

			for(int i=0; i<holder.size(); i++){
				for(int j=i+1; j<holder.size(); j++){
					if(holder[i] == holder[j]){
						holder[i]--;
						deletionCNT++;
						j=i+1;
					}
				}
			}
			return deletionCNT;
		}
	
	182) K'th Special Number in Range: ❌Pending
		Problem Statement
			Ninja wants to practice martial arts in order to master it but he has a pending school assignment and wants
			your help to solve it.
			You are given two integers 'L' and 'R' denoting the range of integers [L, R]. A special number is a number that
			has (101)₂  subarray in its binary representation. You have a simple task, you need to find the 'K'th' special
			number that lies in the given range, print -1 if it is not possible.
			For Example :
				If L = 5 and R = 7, and you need to find the 1'st special number lying in the range [5, 7]
				The answer for this is equal to 5, as 5 is the first special number lying in the given
				range, it is a special number because it has a subarray 101 in its binary representation.
			Constraints :
				1 ≤ T ≤ 10
				1 ≤ L ≤ R ≤ 50000
				1 ≤ K ≤ 50000
				Time limit: 1 sec
			Sample Input 1 :
				2
				5 7 1
				8 11 3
				Sample Output 1 :
				5
				-1
				Explanation For Sample Input 1 :
				For test case 1 :
				We will print 5 because:
				5 is the first special number lying in the given range, it is a special number because it has a subarray 101 in its binary representation.

				For test case 2 : 
				We will print -1 because:
				There are two special numbers lying in the range [8, 11], these are 10 = (1010)2 and 11 = (1011)2 as both of them have a subarray of 101 in their binary representation. As third special number doesn’t exist in this range, hence we will print -1.
				Sample Input 2 :
				2
				1 10 2
				1 5 1
				Sample Output 2 :
				10
				5

		//NOT Optimized
			#include <bits/stdc++.h>
			int kthSpecialNumber(int l, int r, int k) {
				vector<int> NumsContain101;

				for(int i=l; i<=r; i++){
					string s = bitset<32>(i).to_string();

					if(s.find("101") != string::npos)
						NumsContain101.push_back(i);
				}

				if(k > NumsContain101.size())
					return -1;
				return NumsContain101[k-1];

				//or
				// for (int i = l; i <= r; ++i) {
				//     std::string binary = std::bitset<32>(i).to_string();
				//     if (binary.find("101") != std::string::npos) {
				//         if (--k == 0) {
				//             return i;
				//         }
				//     }
				// }
				// return -1;
			}

		//Optimized:
			int kthSpecialNumberHelper(int i, int lst, int prefix, int ctr, int dp[32][4][2][2], int x) {
				if (i == -1) {
					if (ctr == 1) {
						return 1;
					}
					return 0;
				}

				if (dp[i][lst][prefix][ctr] != -1) {
					return dp[i][lst][prefix][ctr];
				}

				int ans = 0;
				if (prefix == 0) {
					ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2, 0, ctr, dp, x);
					if (lst == 2) 
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 0, 1, dp, x);
					else 
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 0, ctr, dp, x);
				}

				if (prefix == 1) {
					if ((1 << i) & x) {
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2, 0, ctr, dp, x);
						if (lst == 2) 
							ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 1, 1, dp, x);
						else 
							ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 1, ctr, dp, x);
					} else {
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2, 1, ctr, dp, x);
					}
				}

				dp[i][lst][prefix][ctr] = ans;
				return dp[i][lst][prefix][ctr];
			}

			int kthSpecialNumber(int l, int r, int k) {
				int dp[32][4][2][2];
				memset(dp, -1, sizeof(dp));
				int cnt = kthSpecialNumberHelper(31, 0, 1, 0, dp, l - 1);
				cnt += k;
				int ans = -1;
				int low = l, high = r;

				while (low <= high) {
					int mid = (low + high) / 2;
					memset(dp, -1, sizeof(dp));
					int temp = kthSpecialNumberHelper(31, 0, 1, 0, dp, mid);

					if (temp >= cnt) {
						ans = mid;
						high = mid - 1;
					} else {
						low = mid + 1;
					}
				}
				return ans;
			}

	183) Left Rotations of An Array:
		Problem Statement
			You are given an array consisting of 'N' elements and you need to perform 'Q' queries
			on the given array. Each query consists of an integer which tells the number of
			elements by which you need to left rotate the given array. For each query return the
			final array obtained after performing the left rotations.
			Note:
			Perform each query on the original array only i.e. every output
			should be according to the original order of elements.
			Example:
			Let the array be [1, 2, 3, 4, 5, 6] and the queries be {2, 4, 1}. For
			every query, we'll perform the required number of left rotations on
			the array
			For the first query, rotate the given array to the left by 2
			elements, so the resultant array is: [3, 4, 5, 6, 1, 2].
			For the second query, rotate the given array to the left by 4
			elements, so the resultant array is: [5, 6, 1, 2, 3, 4].
			For the third query, rotate the given array to the left by 1 element,
			so the resultant array is: [2, 3, 4, 5, 6, 1].
			Constraints:
				1 <= T <= 10
				1 <= N <= 1000
				1 <= Q <= 100
				0 ‹= Queries[i] ‹= 10^5
				-10^5 ‹= Array[i] ‹= 10^5]
				Where 'Queries[i]' denotes the extent to which the array in each
				query needs to be rotated and 'Array[i]' denotes the array element.
				Time limit: 1 sec
			
			Sample Input 1:
				2
				5 3
				7 8 6 1 2
				8 4 3
				2 2
				12 15
				1 2    
				Sample Output 1:
				1 2 7 8 6 
				2 7 8 6 1
				1 2 7 8 6 
				15 12
				12 15
				Explanation For Sample Output 1:
				In test case 1, we have, array: [7, 8, 6, 1, 2] and three queries: {8, 4, 3}.

				For the first query we rotate the given array to the left 8 times, so the resultant array is: [1, 2, 7, 8, 6].

				For the second query we rotate the given array to the left 4 times, so the resultant array is: [2, 7, 8, 6, 1].

				For the third query we rotate the given array to the left 3 times, so the resultant array is: [1, 2, 7, 8, 6].

				In test case 2, we have, array: [12, 15] and two queries: {1, 2}.

				For the first query we rotate the given array to the left 1 time, so the resultant array is: [15, 12].

				For the second query we rotate the given array to the left 2 times, so the resultant array is: [12, 15].
				Sample Input 2:
				2
				6 3
				10 20 30 40 50 60
				12 2 5
				1 2
				-15
				100 89
				Sample Output 2:
				10 20 30 40 50 60 
				30 40 50 60 10 20 
				60 10 20 30 40 50 
				-15
				-15
				Explanation For Sample Output 2:
				In test case 1, we have, array: [10, 20, 30, 40, 50, 60] and three queries: {12, 2, 5}.

				For the first query we rotate the given array to the left 12 times, so the resultant array is: [10, 20, 30, 40, 50, 60].

				For the second query we rotate the given array to the left 2 times, so the resultant array is: [30, 40, 50, 60, 10, 20].

				For the third query we rotate the given array to the left 5 times, so the resultant array is: [60, 10, 20, 30, 40, 50]

				In test case 2, we have, array: [-15] and two queries: {100, 89}.

				For the first query we rotate the given array to the left 100 times, so the resultant array is: [-15].

				For the second query we rotate the given array to the left 89 times, so the resultant array is: [-15].

		//Not Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> leftRotationsOfArray(vector<int> nums, vector<int> queries) {
				vector<vector<int>> ans;
				for(int i=0; i<queries.size(); i++){
					int num = queries[i];
					vector<int> temp = nums;
					for(int a=0; a<num; a++){
						int value = temp[0];
						temp.erase(temp.begin());
						temp.push_back(value);
					}
					ans.push_back(temp);        
				}
				return ans;   
			}

		//Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> leftRotationsOfArray(vector<int> nums, vector<int> queries) {
				std::vector<std::vector<int>> ans;
				const int n = nums.size();

				for (const int& num : queries) {
					std::vector<int> temp(n);
					for (int i = 0; i < n; ++i) {
						temp[i] = nums[(i + num) % n];
					}
					ans.push_back(temp);
				}
				return ans;
			} 
	
	184) Convert Number To Words: ❌Pending
		Problem Statement
			You are given an Integer 'N' you have to convert the integer to words.
			For example you are given integer N = 2234 then you have to return the string "two
			thousand two hundred and thirty four".
			Constraints :
				1 <= T <= 100
				1 <= N <= 999999999
				Time Limit: 1 sec
			Sample Input 1 :
				3
				1234
				45821
				555093
				Sample Output 1 :
				one thousand two hundred and thirty four
				forty five thousand eight hundred and twenty one
				five lakh fifty five thousand and ninety three
				Explanation Of Sample Input 1 :
				For the first test case:
				The given integer is 1234 we can see that in words it is represented as “one thousand two hundred and thirty four”.

				For the second test case:
				The given integer is 45821; we can see that in words it is represented as “forty five thousand eight hundred and twenty-one”.

				For the third test case
				The given integer is 555093; we can see that in words it is represented as “five lakh fifty five thousand and ninety three”.
				Sample Input 2 :
				3
				99999
				1000
				30000 
				Sample Output 2 :
				ninety nine thousand nine hundred and ninety nine
				one thousand  
				thirty thousand  

		#include <bits/stdc++.h>
		string a[] = {"", "one ", "two ", "three ", "four ",
				"five ", "six ", "seven ", "eight ", "nine ",
				"ten ", "eleven ", "twelve ", "thirteen ", "fourteen ",
				"fifteen ", "sixteen ", "seventeen ", "eighteen ", "nineteen "};

		string b[] = {"", "", "twenty ", "thirty ", "forty ",
				"fifty ", "sixty ", "seventy ", "eighty ", "ninety "};

		string c[] = {"", "", "hundred ", "thousand ", "", "lakh ", "", "crore "};

		string handleAll(int n) {
			string z;

			while (n) {
				z += ('0' + ((int)n % 10));
				n /= 10;
			}

			reverse(z.begin(), z.end());

			int k = z.size() - 1;
			string t;
			int g = 0;

			for (int i = 0; i < z.size(); i++) {
				if (z[i] == '0') {
					k -= 1;
					continue;
				}

				if (k % 2 == 0 and k > 3) {
					if (z[i] == '1' and i + 1 < z.size()) {
						t += a[10 + (z[i + 1] - '0')];
						t += c[k - 1];
					} else {
						t += b[(z[i] - '0')];
						t += a[z[i + 1] - '0'];
						t += c[k - 1];
					}

					i++;
					k -= 2;
				} else if (k > 1) {
					t += (a[z[i] - '0']);
					t += c[k];
					k -= 1;
				} else {
					if (g == 0) {
						t += "and ";
						g = 1;
					}

					if (z[i] == '1' and i + 1 < z.size()) {
						t += a[10 + (z[i + 1] - '0')];
						k -= 1;
						i++;
					} else {
						if (i + 1 < z.size()) {
							t += b[(z[i] - '0')];
						} else {
							t += a[z[i] - '0'];
						}

						k -= 1;
					}
				}
			}
			return t;
		}
	
	185) Print the Kth Digit: ❌Pending

		Sample Input 1:
			1
			2 4 1
			Sample Output 1:
			6
			Explanation For Sample Input 1:
			2 ^ 4 = 16, and the 1st digit in 16 from the right is 6.
			Sample Input 2:
			1
			3 3 2       
			Sample Output 2:
			2
			Explanation For Sample Input 2:
			3^3 = 27, and the 2nd digit in 27 from the right is 2.

		#include <bits/stdc++.h> 
		int findKthFromRight(int n, int m, int k) {
			int power = pow(n,m);
			int num;
			for(int i=0; i<k; i++){
				num = power % 10;
				power /=10;
			}
			return num;
		}
	
	186) Matrix Multiplication:
		Problem statement:
			Ninja has been given two sparse matrices ‘MAT1’ and ‘MAT2’ of integers having size ‘N’ x ‘M’ and ‘M’ x ‘P’, respectively.
			A sparse matrix is a matrix that contains very few non-zero elements.
			Ninja has to find the matrix formed by the multiplication of ‘MAT1’ and ‘MAT2’. As Ninja is busy with some other tasks so he needs your help. Can you help Ninja to find the matrix formed by the multiplication of ‘MAT1’ and ‘MAT2’?
			Note: The number of columns in ‘MAT1’ i.e ‘M’ is equal to the number of rows in ‘MAT2’ i.e ‘M’. It means we can always multiply ‘MAT1’ with ‘MAT2’.
			For example:
			For the ‘MAT1’ and ‘MAT2’ given below, ‘MAT3’ is the matrix formed by multiplying ‘MAT1’ and ‘MAT2’. 
				MAT1			MAT2
				2	1         1		6 
						⋈   		=
				0	0		4      	0

			1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] + MAT1[0][1] * MAT2[1][0]  ie. 2 * 1 + 1 * 4 = 6
			2. MAT3[1][0] = MAT1[1][0] * MAT2[1][0] + MAT1[1][1] * MAT2[1][0] ie. 0 * 6 + 0 * 4 = 0
			Detailed explanation ( Input/output format, Notes, Images )
			Input Format:
			The first line of input contains an integer ‘T’ denoting the number of test cases. Then each test case follows.
			The first line of each test case contains four space-separated integers ‘N’, ‘M’, ‘M’, ‘P’ where ‘N’ and ‘M’ representing the number of rows and columns of ‘MAT1’ respectively and ‘M’ and ‘P’ representing the number of rows and columns of ‘MAT2’ respectively. 
			The next ‘N’ lines of each test case contain ‘M’ single space-separated integers denoting the values of ‘MAT1’. Then the next ‘M’ lines contain ‘P’ single space-separated integers denoting the values of ‘MAT2’
			Output Format :
			For each test case, return the matrix ‘MAT3’ which will be formed by multiplying ‘MAT1’ and ‘MAT2’.
			Note:
			You are not required to print the expected output; it has already been taken care of. Just implement the function.
			Constraints:
				1 <= ‘T’ <= 100
				1 <= ‘N’, ‘M’ and ‘P’ <= 100
				-10^5 <= ‘MAT1[i][j]’ and ‘MAT2[i][j]’ <= 10^5
				Time limit: 1 sec

			Sample Input 1:
				1
				2 1 1 2
				2
				0
				1 2
				Sample Output 1:
				2 4
				0 0
				Explanation for Sample Output 1:
				For sample test case 1: 
				1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] ie. 2 * 1 = 2
				2. MAT3[0][1] = MAT1[0][0] * MAT2[0][1] ie. 2 * 2 = 4
				3. MAT3[1][0] = MAT1[0][1] * MAT2[0][0] ie. 0 * 1 = 0 
				4. MAT3[1][1] = MAT1[1][1] * MAT2[0][1] ie. 0 * 2 = 0
				Sample Input 2:
				2
				1 1 1 2
				3
				1 0
				1 1 1 1
				-1
				7
				Sample Output 2:
				3 0
				-7
				Explanation for Sample Output 1:
				For sample test case 1: 
				1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] ie. 3 * 1 = 3
				2. MAT3[0][1] = MAT1[0][0] * MAT2[0][1] ie. 3 * 0 = 0

				For sample test case 2: 
				1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] ie. -1 * 7 = -7

		#include <bits/stdc++.h> 
		vector<vector<int>> multiplyMatrices(vector<vector<int>> &mat1, vector<vector<int>> &mat2) {
			int m = mat1.size();    // Number of rows in mat1
			int n = mat1[0].size(); // Number of columns in mat1
			int p = mat2[0].size(); // Number of columns in mat2

			vector<vector<int>> ans(m, vector<int>(p, 0));
			for (int i = 0; i < m; ++i) {
				for (int j = 0; j < p; ++j) {
					for (int k = 0; k < n; ++k) {
						ans[i][j] += mat1[i][k] * mat2[k][j];
					}
				}
			}
			return ans;
		}

		// or
		#include <bits/stdc++.h> 
		vector<vector<int>> multiplyMatrices(vector<vector<int>> &mat1, vector<vector<int>> &mat2) {
			int row1 = mat1.size();
			int col1 = mat1[0].size();

			int row2 = mat2.size();
			int col2 = mat2[0].size();

			vector<vector<int>> ans (row1, vector<int>(col2, 0));           // the resultant matrix has rows as mat1 & cols as mat2
			for(int i=0; i<row1; i++) {
				for(int j=0; j<col2; j++) {
					int itr = 0;
					while(itr < row2) {
						ans[i][j] += (mat1[i][itr] * mat2[itr][j]);
						itr++;
					}
				}
			}
			return ans;
		}
	
	187) Maximum Swap: ❌Pending
		Problem Statement
			Given a positive integer N, you can do the following operation at most once
				a) Swap two digits of the integer N
			You need to determine the largest integer you can get by performing the above operation at most once.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^9
				Time limit: 1 sec

			Sample Input 1:
				2
				4589
				99538
				Sample Output 1:
				9584
				99835
				Explanation Of Sample Input 1:
				For the first test case, swap the first digit with the last digit, So, return 9584.
				For the second test case, swap the third digit with the last digit. So, return 99835.
				Sample Input 2:
				2
				4321   
				18
				Sample Output 2:
				4321
				81
				Explanation Of Sample Input 2:
				For the first test case, the number given is biggest among all possible answers, So, return 4321.
				For the second test case, swap the first digit with the last digit. So, return 81.
		#include <bits/stdc++.h> 
		int maximumSwap(int n) {
			string s = to_string(n);
			int flg = 1;
			for (int i = 0; i < s.length(); i++) {
				int curIndex = i;  // Initialize curIndex to i
				for (int j = s.length() - 1; j > i; j--) {
					if (s[j] > s[curIndex]) {
						curIndex = j;
						flg = 0;
					}
				}
				if (flg == 0) {
					swap(s[i], s[curIndex]);
					break;
				}
			}
			n = stoi(s);
			return n;
		}
	
	188) Power Set:
		Problem Statement
			You are given a sorted array of 'N' integers. You have to generate the power set for
			this array where each subset of this power set is individually sorted.
			A set is a well-defined collection of distinct elements. Power set P(ARR) of a set
			'ARR' is defined as a set of all possible subsets of 'ARR'.
			You have to return the array of subsets. The elements in the subset should be sorted
			in ascending order. The order of subsets in the array does not matter. Hence there
			can be more than 1 possible solution for a given array.
			For Example :
			If we are given an array ARR=[1,2,3] then the power set P(ARR) of the
			set ARR is: [ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]]
			Note :
			For every subset 'X' present in power set P(ARR) of set ARR, X must
			be sorted i.e. in the example above:
			P1(ARR) = [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
			P2 (ARR) = [[], [1], [1,2,3], [2], [1,2], [3], [1,3], [2,3]]
			P3(ARR) = [[], [1], [2], [1,2], [3], [1,3], [2,3], [2,3,1]]
			P1 (ARR) and P2 (ARR) will be considered correct power sets but P3 (ARR)
			will not be considered correct because there the last subset [2, 3,1] is not sorted.

			Sample Input 1 :
				3
				1 2 3    
				Sample Output 1 :
				1
				2
				3
				1 2
				1 3
				2 3

				1 2 3 
				Explanation Of Sample Input 1 :
				The power set P(ARR) of set ARR = [1, 2, 3] is [ [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] ].
				Sample Input 2 :
				3
				5 7 8    
				Sample Output 2 :
				8
				7

				5
				5 8
				5 7
				5 7 8

		#include <bits/stdc++.h> 
		vector<vector<int>> pwset(vector<int>v) {
			vector<vector<int>> ans;
			int n = v.size();
			
			// Generate all subsets using bit manipulation
			for (int mask = 0; mask < (1 << n); ++mask) {
				vector<int> subset;
				for (int i = 0; i < n; ++i) {
					if (mask & (1 << i)) {
						subset.push_back(v[i]);
					}
				}
				ans.push_back(subset);
			}
			return ans;
		}

		// Recursive:
			#include <bits/stdc++.h>
			void GenerateSet(vector<int> &v, vector<vector<int>> &ans,vector<int> t, int i){
				if(i >= v.size()){
					ans.push_back(t);
					return ;
				}
				GenerateSet(v, ans, t, i+1);

				t.push_back(v[i]);
				GenerateSet(v, ans, t, i+1);
			}

			vector<vector<int>> pwset(vector<int>v) {
				vector<vector<int>> ans;
				vector<int> temp;

				GenerateSet(v, ans, temp, 0);
				return ans;
			}
	
	189) Radix Sort:
		Constraints:
			1 <= 'T' <= 10
			1 <= 'N' <= 10^4
			1 <= ARR[i] <= 10^9
			Time Limit: 1 sec
		Sample Input 1 :
			2
			4
			1 4 3 5
			5 
			5 4 3 2 1
			Sample Output 1 :
			1 3 4 5
			1 2 3 4 5
			Explanation Of Sample Input 1 :
			In test case ‘1’, ‘1 3 4 5’ is the increasing sorted order.
			In test case ‘2’. ‘1 2 3 4 5’ is the increasing sorted order.
			Sample Input 2 :
			2
			2
			30 25
			6 
			2 2 2 2 2 2
			Sample Output 2 :
			25 30
			2 2 2 2 2 2

		#include <bits/stdc++.h> 
		vector<int> radixSort(int n, vector<int>& arr) {
			sort(arr.begin(), arr.end());
			return arr;

			// vector<int> ans;
			// for(int i=0; i<arr.size(); i++){
			//     for(int j=i+1; j<arr.size(); j++){
			//         if(arr[i] > arr[j]){
			//             swap(arr[i],arr[j]);
			//         }
			//     }
			// }

			// return arr;
			// for(int i: arr){
			//     ans.push_back(i);
			// }
			// return ans;
		}
	
	190) Set Matrix Zeros:
		Sample Input 1 :
			2
			2 3
			7 19 3
			4 21 0
			3 3
			1 2 3
			4 0 6
			7 8 9
			Sample Output 1 :
			7 19 0
			0 0 0
			1 0 3
			0 0 0
			7 0 9
			Explanation For Sample Input 1 :
			For First Case - Similar to the example explained above. 

			For Second Case - 
			Only the cell (2,2) has zero. So all the elements of the second row and second column are changed to zeros.
			Sample Input 2 :
			2
			4 2
			1 0
			2 7
			3 0
			4 8
			3 3
			0 2 3
			1 0 3
			1 2 0
			Sample Output 2 :
			0 0
			2 0
			0 0
			4 0
			0 0 0
			0 0 0
			0 0 0

		#include <bits/stdc++.h>
		void setZeros(vector<vector<int>> &matrix) {
			vector<vector<int>> ans = matrix;

			for(int i=0; i<matrix.size(); i++){
				for(int j=0; j<matrix[0].size(); j++){
					if(matrix[i][j] == 0){
						//making complete row 0
						for(int a=0; a<ans[0].size(); a++){
							ans[i][a] = 0;
						}

						//making complete col 0
						for(int a=0; a<ans.size(); a++){
							ans[a][j] = 0;
						}
					}
				}
			}
			matrix = ans;
		}

	191) Ninja and Subarrays:
		Problem Statement
			One day Ninja got an array and started to play with it. He is finding subarrays of
			the array randomly and suddenly starts to wonder about the maximum of the
			sum of the smallest and the second smallest elements of all the subarrays
			possible of size at least 2.
			For Example:
			For the array [3 2 1]
			All the subarrays of size at least 2 are:
			[3 2], [2 1], [3 2 1]
			For the first subarray, the smallest and second smallest elements are 2 and 3,
			and their sum is 5.
			For the second subarray, the smallest and second smallest elements are 1 and 2
			and their sum is 3.
			For the third subarray, the smallest and second smallest elements are 1 and 2,
			and their sum is 3.
			So the maximum among these sums is 5.
			Since Ninja is too lazy to do this task, he asked you for help. You have to find
			the maximum of the sum of the smallest and the second smallest elements of
			all the subarray possible of size at least 2.
		
			Constraints:
				1 <= T <= 5
				2 <= N <= 10^5
				1 <= A[i] <= 10^4
				Time Limit: 1 sec.
		
		Sample Input 1:
			2
			4
			1 2 3 4
			2
			3 8
			Sample Output 1:
			7
			11
			Explanation For Sample Output 1:
			For the first test case, all the possible subarrays of size at least 2 are:
			[1 2], [1 2 3], [1 2 3 4], [2 3], [2 3 4], [3 4].
			The respective sum of the smallest and second smallest elements are 3, 3, 3, 5, 5, 7.
			So the answer will be the maximum of all of them, i.e., 7.

			For the second test case, there is only one subarray possible [3 8]. So the answer will be 11. 
			Sample Input 2:
			2
			5
			8 3 7 2 4
			4
			6 4 7 5
			Sample Output 2:
			11
			12

		//not optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int mxr=INT_MIN;
				if(n==2)
					return arr[0]+arr[1];

				for(int i=0; i<n-1; i++){
					vector<int> temp;
					temp.push_back(arr[i]);
					for(int j=i+1; j<n; j++){
						temp.push_back(arr[j]);
						vector<int> holder = temp;

						int firstSmall = *min_element(holder.begin(), holder.end());
						holder.erase(holder.begin() + (min_element(holder.begin(), holder.end()) - holder.begin()));

						int secondSmall = *min_element(holder.begin(), holder.end());
						holder.erase(holder.begin() + (min_element(holder.begin(), holder.end()) - holder.begin()));

						mxr = max(mxr, (firstSmall+secondSmall));
					}
				}
				return mxr;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int alltimeSum = arr[0] + arr[1], currentSum = arr[0] + arr[1];
				for(int i=1;i<n-1;i++){
					currentSum = currentSum - arr[i-1] + arr[i+1];
					alltimeSum = max(currentSum, alltimeSum); 
				}
				return alltimeSum;
			}

	192) Shuffle integers:
		Problem statement:
			Given an array arr of n elements in the following format 
			{a1, a2, a3, a4, ... , an/2, b1, b2, b3, b4, ... , bn/2}, 
			the task is shuffle the array to {a1, b1, a2, b2, a3, b3, ... , an/2, bn/2} 
			without using extra space.
			Note that n is even.

			Example 1:
				Input: 
				n = 4, arr = {1, 2, 9, 15}
				Output:  
				1 9 2 15
				Explanation: 
					a1=1, a2=2, b1=9, b2=15. So the final array will be: a1, b1, a2, b2 = {1,9,2,15}.

			Example 2:
				Input: 
				n = 6 arr = {1, 2, 3, 4, 5, 6} 
				Output: 
				1 4 2 5 3 6
			Your Task:
				This is a function problem. 
				You don't need to take any input, as it is already accomplished by the driver code. 
				You just need to complete the function shuffleArray() that takes array arr, and an integer n as 
				parameters and modifies the given array according to the above-given pattern.

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ n ≤ 105
				1 ≤ arr[i] ≤ 10^3
		
		class Solution{
			public:
			void shuffleArray(int arr[],int n) {
				vector<int> aHolder;
				vector<int> bHolder;
				int i;
				for(i=0; i<n/2; i++){
					aHolder.push_back(arr[i]);
				}
				
				for(i; i<n; i++){
					bHolder.push_back(arr[i]);
				}
				
				int cnt=0;
				for(int z=0; z<n; z++){
					if(z&1)
						arr[z] = bHolder[cnt++];
					else
						arr[z] = aHolder[cnt];	
				}
		}

	193) Find Character Case:
		Problem Statement
			You are given a character "CH" as input, return either 1, 0 or -1 according to the
			following rules:
				1, if the character is an uppercase alphabet (A - Z)
				0, if the character is a lowercase alphabet (a - z).
				-1, if the character is not an alphabet.
			For Example :
			If 'CH' = 'a', then since it is a lowercase letter, your program should return 0.
			Constraints:
				1 <= T <= 10
				"CH" = ASCII character
				Time Limit: 1 sec 
			Sample Input 1:
				2
				A
				t
				Sample Output 1:
				1
				0
				Explanation For Sample Input 1:
				For sample case 1, ‘A’ is an uppercase letter, hence output is 1.
				For sample case 2, ‘t’ is a lowercase letter, hence output is 0.
				Sample Input 2:
				2
				#
				P
				Sample Output 2:
				-1
				1
				Explanation For Sample Input 2:
				For sample case 1, ‘#’ is not an alphabet, hence output is -1.
				For sample case 2, ‘P’ is an uppercase letter, hence output is 1.

		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(!isalpha(ch))
				return -1;
			else if(isupper(ch))
				return 1;
			else 
				return 0;
		}

		//or
		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(islower(ch))
				return 0;
			else if(isupper(ch))
				return 1;
			else
				return -1;
		}
		
	194) Nth Number:
		Problem Statement
			In a series of numbers where each number is such that the sum of its digits
			equals 10. Given an integer value 'N', your task is to find the N-th positive integer
			whose sum of digits equals to 10.
			Constraints:
				1 <= T <= 100
				1<= N <= 10^7
				Time Limit: 1sec

		Sample Input 1:
			2
			1
			4
			Sample Output 1:
			19
			46   
			Explanation of Sample Input 1:
			Since N=1 here, therefore, the first number having a sum of digits equal to 10 is 19. Therefore, the output here is 19.

			Since N=4 here, therefore, The first four numbers having a sum of digits equal to 10 are 19, 28, 37, and 46. Therefore, the output here becomes 46.
			Sample Input 2:
			2
			5
			9
			Sample Output 2:
			55
			91

		//Not optimized:
			#include <bits/stdc++.h> 
			long long nthNumberWithSum10(long long n) {
				// int i=1;
				// vector<long long> holder;
				// while(holder.size() < n){
				//    int currentNum = i;
					
				//    int sum=0;
				//    while(currentNum !=0 ){
				//       sum += currentNum %10;
				//       currentNum /=10;
				//    }

				//    if(sum == 10)
				//       holder.push_back(i);
				//    i++;
				// }
				// return holder.back();

				std::vector<long long> holder;
				int currentNum = 19;  // Starting from the first number with digit sum 10
				int increment = 9;    // Increment to the next number with digit sum 10

				while (holder.size() < n) {
					int sum = 0;
					int num = currentNum;

					while (num > 0) {
					sum += num % 10;
					num /= 10;
					}

					if (sum == 10) {
					holder.push_back(currentNum);
					}

					currentNum += increment;
				}

				return holder.back();
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int dp[21][180][2];
			long long int solve(string &str,int pos,int sum,int res) {
				if(pos>=str.length()) {
					return dp[pos][sum][res]= sum==10;
				}

				if(dp[pos][sum][res]!=-1) {
					return dp[pos][sum][res];
				}
				long long int ans=0;
				if(res==1) {
					for(int i=0;i<=str[pos]-'0';i++) {
						if(i==str[pos]-'0') {
							ans+=solve(str,pos+1,sum+i,1) ;
						} else {
							ans+=solve(str,pos+1,sum+i,0);
						}	
					}
				} else {
					for(int i=0;i<=9;i++) {
						ans+=solve(str,pos+1,sum+i,0);
					}
				}
				return dp[pos][sum][res]=ans; 
			}

			long long nthNumberWithSum10(long long n) {
				long long int s=19;
				long long int e=LONG_MAX;
				long long int ans=0;
				while(s<=e) {
					long long int mid=s+(e-s)/2;
					string str=to_string(mid);
					memset(dp,-1,sizeof(dp));
					long long int cnt=solve(str,0,0,1);
					if(cnt>=n) {
						ans=mid;
						e=mid-1;
					} else {
						s=mid+1;
					}
				}
				return ans;
			}

	195) Print Pattern:
		Problem Statement:
			Print a sequence of numbers starting with N, without using loop, 
			where replace N with N - 5, until N > 0. 
			After that replace N with N + 5 until N regains its initial value.

			Example 1:
				Input: 
				N = 16
				Output: 
				16 11 6 1 -4 1 6 11 16
				Explanation: 
				The value decreases until it is greater than 0. After that it increases and stops when it becomes 16 again.

			Example 2:
				Input: 
				N = 10
				Output: 
				10 5 0 5 10
				Explanation: It follows the same logic as per the above example.

			Your Task:
			You do not need to read input or print anything. 
			Your task is to complete the function pattern() which takes N as input parameters 
			and returns a list containing the pattern.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				-10^5 ≤ N ≤ 10^5
		
		class Solution{
			public:
			vector<int> pattern(int N){
				vector<int> ans;
				int cnt=N;
				while(cnt>0){
					ans.push_back(cnt);
					cnt -=5;
				}
				
				while(cnt<=N){
					ans.push_back(cnt);
					cnt+=5;
				}
				return ans;
			}
		};

	196) Print the Pattern:
		Problem Statement
			Ninja is given a pattern. Now he is asked to print the same pattern for any given 'N' number of rows.
			Note:
				There is only one space between the values of each column in a row.
				For example, Pattern for 'N' = 5 will be.
				1 2 3 4 5
				11 12 13 14 15
				21 22 23 24 25
				16 17 18 19 20
				6 7 8 9 10
			Sample Input1 :
				1 
				5
				Sample Output2 :
				1 2 3 4 5 
				11 12 13 14 15 
				21 22 23 24 25 
				16 17 18 19 20 
				6 7 8 9 10 
				Explanation of Sample Input 1:
				For test case 1:
				We print the given pattern for the given 5 rows where each row has different values in increasing order with a difference in the value of 1 between each element and 1 space between each column in a row.
				Sample Input2 :
				1
				4
				Sample Output2 :
				1 2 3 4
				9 10 11 12
				13 14 15 16
				5 6 7 8
				Explanation of Sample Input 2:
				For test case 1:
				We print the given pattern for the given 4 rows where each row has different values in increasing order with a difference of 1 in the value of 1 between each element and 1 space between each column in a row.

		#include <bits/stdc++.h> 
		vector<string> printPattern(int n) {
			vector<string> ans(n);

			vector<vector<int>> holder;
			int cnt=1;
			for(int i=1; i<=n; i++){
				vector<int> temp;
				for(int j=1; j<=n; j++){
					temp.push_back(cnt++);
				}
				holder.push_back(temp);
				temp.clear();
			}

			int index;
			int start =0;
			int end = n-1;
			for(int i=0; i<n; i++){
				if(i&1){
					index = end--;
				} else {
					index = start++;
				}
				for(int j=0; j<n; j++){
					ans[index] += (to_string(holder[i][j]) + " ");
				}
			}
			return ans;
		}

	197) Number of 1 Bits:
		Problem Statement:
			Write a function that takes the binary representation of an unsigned integer 
			and returns the number of '1' bits it has (also known as the Hamming weight).

			Note:
				Note that in some languages, such as Java, there is no unsigned integer type. In this case,
				the input will be given as a signed integer type. 
				It should not affect your implementation, as the integer's internal binary representation 
				is the same, whether it is signed or unsigned. In Java, the compiler represents the signed 
				integers using 2's complement notation. 
				Therefore, in Example 3, the input represents the signed integer. -3.
			
			Example 1:
				Input: n = 00000000000000000000000000001011
				Output: 3
				Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

			Example 2:
				Input: n = 00000000000000000000000010000000
				Output: 1
				Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.

			Example 3:
				Input: n = 11111111111111111111111111111101
				Output: 31
				Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
				
			Constraints:
				The input must be a binary string of length 32.

		class Solution {
		public:
			int hammingWeight(uint32_t n) {
				return __builtin_popcount(n);
				// int cnt=0;
				// while(n!=0){
				//     if(n&1)
				//         cnt++;
				//     n>>=1;
				// }
				// return cnt;
			}
		};

	198) Find All Anagrams in a String (POTD-47)
		Problem statement
			You have been given a string STR and a non-empty string PTR. Your task is to
			find all the starting indices of PTR's anagram in STR.
			An anagram of a string is another string which contains the same characters
			and is obtained by rearranging the characters.
			For example: 'SILENT and 'LISTEN" are anagrams of each other. 'ABA' and 'ABB'
			are not anagram because we can't convert 'ABA' to 'ABB' by rearranging the
			characters of particular strings.
			Note:
				1. Both STR and PTR consist of English uppercase letters.
				2. Length of string 'STR' will always be greater than or equal to the length of
				string 'PTR.
				3. In case, there is no anagram substring, then return an empty sequence.
				4. In case of more than one anagrams, return the indices in increasing order.
			Constraints:
				1 <=T <= 100
				1 <= N <= 10^5
				1<=M <=N
				Time limit: 1 second
		Sample Input 1 :
			2
			10 3
			CBAEBABACD
			ABC
			5 2
			ABADE
			BA
			Sample Output 1 :
			0 6
			0 1
			Explanation For Sample Output 1:
			Test Case 1:

			'STR' is ‘CBAEBABACD’ and ‘PTR’ is ‘ABC’.

			0-2 in 'STR' index 0,1,2 are ‘CBA’, and it is an anagram with ‘ABC’.
			1-3 in 'STR' index 1,2,3 are ‘BAE’, and it is not anagram with ‘ABC’.
			2-4 in 'STR' index 2,3,4 are ‘AEB’, and it is not anagram with ‘ABC’.
			3-5 in 'STR' index 3,4,5 are ‘EBA’, and it is not anagram with ‘ABC’.
			4-6 in 'STR' index 4,5,6 are ‘BAB’, and it is not anagram with ‘ABC’.
			5-7 in 'STR' index 5,6,7 are ‘ABA’, and it is not anagram with ‘ABC’.
			6-8 in 'STR' index 6,7,8 are ‘BAC’, and it is an anagram with ‘ABC’.
			7-9 in 'STR' index 7,8,9 are ‘ACD’, and it is not anagram with ‘ABC’.

			Hence, there are only two substrings in the given string 'STR'  that are anagram with given string  ‘PTR’ which are ‘CBA’, and ‘BAC’ and starting indices of respective anagram substrings are 0 and 6.


			Test case 2:

			'STR' is ‘ABADE’ and ‘PTR’ is ‘BA’.

			In the given string ‘ABADE’ the substring of length 2 starting with index 0 is ‘AB’ which is an anagram with the string ‘BA’ and a substring of length 2 starting with index 1 is ‘BA’ which is also an anagram with the string ‘BA’. Because 0 and 1 are starting indices of the substrings, we print 0 and 1.
			Sample Input 2:
			2
			10 4
			BACDGABCDA
			ABCD
			7 1
			ABABABA
			A
			Sample Output 2:
			0 5 6
			0 2 4 6

		//not optimized:
			bool checker(int a1[26], int b1[26]){
				for(int i=0; i<26; i++){
					if(a1[i] != b1[i])
						return false;
				}
				return true;
			}

			vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
				
				//finding the ptr letter's positions
				int ptrHolder[26] = { 0 };

				for(int i=0; i<ptr.length(); i++){
					ptrHolder[ptr[i]-'A']++;
				}

				vector<int> ans;

				//for str
				int len = ptr.length();
				for(int i=0; i<str.length(); i++){
					int tempStrHolder[26] = {0};
					
					for(int a=i; a<len; a++){
						tempStrHolder[str[a]-'A']++;
					}
					len++;							//little bit problem with this len var.

					if(checker(ptrHolder, tempStrHolder))
						ans.push_back(i);
				}
				return ans;
			}
	
		//Optimized:
			bool checker(int a1[26], int b1[26]){
				for(int i=0; i<26; i++){
					if(a1[i] != b1[i])
						return false;
				}
				return true;
			}

			vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
				int ptrHolder[26] = {0};
				for (char c : ptr) {
					ptrHolder[c - 'A']++;
				}

				vector<int> ans;

				int len = ptr.length();
				int tempStrHolder[26] = {0};

				// Initialize tempStrHolder for the first window
				for (int i = 0; i < len; i++) {
					tempStrHolder[str[i] - 'A']++;
				}

				// Check the first window
				if (checker(ptrHolder, tempStrHolder)) {
					ans.push_back(0);
				}

				// Iterate through the remaining windows
				for (int i = len; i < str.length(); i++) {
					// Update tempStrHolder for the current window
					tempStrHolder[str[i] - 'A']++;
					tempStrHolder[str[i - len] - 'A']--;

					// Check if the current window is an anagram
					if (checker(ptrHolder, tempStrHolder)) {
						ans.push_back(i - len + 1);
					}
				}
				return ans;
			}

	199) One Odd Occurring:
		Problem statement
			Given an array 'ARR'of 'N' integers, where all the elements occur an even
			number of times and only one number occurs an odd number of times.
			Find and return the number which occurs an odd number of times.
			For example:
				'N' = 5, 'ARR' = [1, 2, 3, 2, 3]
				Output: 1
			Except for number 1, all numbers occur an even number of times.
			Sample Input 1 :
				9
				4 5 6 5 6 9 9 4 4
				Sample Output 1 :
				4
				Explanation Of Sample Input 1 :
				5, 6, and 9 occur an even number of times, and only 4 occur odd number of times.
				Sample Input 2 :
				5
				1 1 1 1 1
				Sample Output 2 :
				1
			Constraints :
				1 <= 'N' <= 10^5
				1 <= 'ARR[i]' <= 10^5
				Time Limit: 1 sec
		
		int missingNumber(int n, vector<int> &arr){
			unordered_map<int, int> FreqCounter;
			for(int i=0; i<n; i++){
				FreqCounter[arr[i]]++;
			}

			int num;
			for(auto i: FreqCounter){
				if((i.second % 2) != 0){
					num = i.first;
					break;
				}
			}
			return num;
		}

		//or
			int missingNumber(int n, vector<int> &arr){
				unordered_map<int, int> FreqCounter;
				for(int i=0; i<n; i++)
					FreqCounter[arr[i]]++;

				for(auto i: FreqCounter)
					if(i.second & 1)
						return i.first;
			}
		
		//Most easiest:
			int missingNumber(int n, vector<int> &arr){
				int ans=0;
				for(int i: arr)
					ans ^= i;
				return ans;
			}

	200) Reverse Number:
		Problem Statement:
			Ninja is feeling very bored and wants to try something new. So, he decides to
			find the reverse of a given number. But he cannot do it on his own and needs
			your help.
			Note:
				If a number has trailing zeros, then its reverse will not include them. For e.g., the
				reverse of 10400 will be 401 instead of 00401.
			Sample Input 1:
				2
				10400
				12345
				Sample Output 1:
				401
				54321
				Explanation of Sample Input 1:
				Test case 1:
				For the first test case of sample output 1, as the number 
				is ‘10400’, after finding the reverse, it turns out to be ‘00401’ but 
				we need to leave the trailing zeros. Therefore our solution is 401

				Test case 2:   
				For the second test case of sample output 1, as the number is ‘12345’, the reverse will be ‘54321’
				Sample Input 2:
				2
				1000
				7654321
				Sample Output 2:
				1
				1234567
				Explanation of Sample Input 2:
				Test case 1:
				For the first test case of sample output 2, as the input number is ‘1000’, we get the reverse as ‘1’.

				Test case 2:   
				For the second test case of sample output 2, as the input number is ‘7654321’, we get the reverse as ‘1234567’.

		#include <bits/stdc++.h> 
		long long int reverseNumber(long long int n) {
			string s = to_string(n);
			reverse(s.begin(), s.end());
			return stoll(s);
		}

	201) Check If Two String Arrays are Equivalent:
		Problems Statement:
			Given two string arrays word1 and word2, 
			return true if the two arrays represent the same string, 
			and false otherwise. A string is represented by an array 
			if the array elements concatenated in order forms the string.			
			
			Example 1:
				Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
				Output: true
				Explanation:
				word1 represents string "ab" + "c" -> "abc"
				word2 represents string "a" + "bc" -> "abc"
				The strings are the same, so return true.

			Example 2:
				Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
				Output: false

			Example 3:
				Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
				Output: true
			
			Constraints:
				1 <= word1.length, word2.length <= 103
				1 <= word1[i].length, word2[i].length <= 103
				1 <= sum(word1[i].length), sum(word2[i].length) <= 103
				word1[i] and word2[i] consist of lowercase letters.

		class Solution {
			public:
				bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {
					string s1,s2;
					for(int i=0; i<word1.size(); i++){
						s1 += word1[i];
					}
					
					for(int i=0; i<word2.size(); i++){
						s2 += word2[i];
					}

					//if(s1 == s2)
					//	return 1;
					//return 0;
					return s1==s2;
				}
		};

	202) Program to validate IP address:
		Problem statement
			You are given the text 'IPAddress'. Your task is to check if the given text
			'IPAddress' is a valid "IPv4' or not.
			Conditions for a valid 'IPv4' are:
				1. Text form of 'IPAddress' must be 'a.b.c.d'
				2. The values of a,b,c and d can vary from '0' to '255' and both '0' and '255' are
			inclusive.
			Constraints:
				1 <= T <= 10^4
				1 <= length of given text <= 50
				Time limit: 1 sec
			Sample Input 1:
				4
				123.111.12.k
				122.0.330.0
				1.1.1.250
				1.0.0.0.1
				Sample Output 1:
				False
				False
				True
				False
				Explanation of sample input 1:
				Test Case 1:
				Given text ‘IPAddress = 123.111.12.k’, it is satisfying the first condition that given ‘IPAddress’ must be ‘a.b.c.d’ formed but it not satisfying the second condition that d must in a range of ‘0’ to ‘255’ but the value of ‘d’ is ‘k’.
				Hence return ‘False’.

				Test Case 2:
				Given text ‘IPAddress = 122.0.330.0’, it is satisfying the first condition that given ‘IPAddress’ must be ‘a.b.c.d’ formed but it not satisfying the second condition that c must in a range of ‘0’ to ‘255’ but the value of ‘c’ is ‘330’ and it is out of range.
				Hence return ‘False’.

				Test Case 3:
				Given text ‘IPAddress = 1.1.1.250’, it is satisfying the first condition that given ‘IPAddress’ must be ‘a.b.c.d’ formed as well as it satisfying the second condition that a,b,c, and d must in range of ‘0’ to ‘250’.
				Hence return ‘True’.

				Test Case 4:
				Given text ‘IPAddress = 1.0.0.0.1’, it is not satisfying the first condition for valid ‘IPv4’, that text ‘IPAddress’ must be in form of ‘a.b.c.d’ but given text is a form of ‘a.b.c.d.e’
				Hence return ‘False’.
				Sample Input 2:
				2
				1.90.21.1
				1.1
				Sample Output 2:
				True
				False

		#include <bits/stdc++.h> 
		bool isValidIPv4(string ipAddress) {
			int cnt=0;
			for(int i=0; i<ipAddress.length();i++){
				if(ipAddress[i]== '.')
					cnt++;
			}

			for (char c : ipAddress) {
				if (!isdigit(c) && c !='.') {
					return false; // Non-digit characters are not allowed
				}
			}    
			if(cnt!=3)
				return 0;

			for(int i=0; i<ipAddress.length(); i++){
				string temp;
				while(i<ipAddress.length() && ipAddress[i] != '.' ){
					if(ipAddress[i] < '0' || ipAddress[i] > '9')
						return 0;
					temp += ipAddress[i];
					i++;
				}

				int num = stoi(temp);
				if(num>=0 && num<=255){
					//nothing
					//go for next iteration.
				}else{
					return 0;
				}
			}
			return 1;
		}
	
	203) Find Words That Can Be Formed by Characters:
		Problem statement:
			You are given an array of strings words and a string chars.
			A string is good if it can be formed by characters from chars 
			(each character can only be used once).
			Return the sum of lengths of all good strings in words.

			Example 1:

				Input: words = ["cat","bt","hat","tree"], chars = "atach"
				Output: 6
				Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.

			Example 2:
				Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
				Output: 10
				Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.

			Constraints:
				1 <= words.length <= 1000
				1 <= words[i].length, chars.length <= 100
				words[i] and chars consist of lowercase English letters.

		class Solution {
		public:
			int countCharacters(vector<string>& words, string chars) {
				int size=0;
				for(int i=0; i<words.size(); i++){
					string currentWord = words[i];
					string duplicateChars = chars;
					int a;
					for(a=0; a<currentWord.length(); a++) {
						char currentCH = currentWord[a];
						int flg = 1;
						for(int z=0; z<duplicateChars.length(); z++){
							if(currentCH == duplicateChars[z]){
								duplicateChars[z] = '0';
								flg = 0;
								break;
							}else{
								flg = 1;
								continue;
							}
						}
						if(flg)
							break;  
					}
					if(a == currentWord.length())
						size += currentWord.length();
				}
				return size;
			}
		};
	
	204) Four Divisors:
		Problem statement
			Ninja was planning to propose to his crush, Nina, with his spectacular martial
			arts moves. But Nina was more interested in numbers and divisors, so she gave
			Ninja a challenge to complete. If Ninja solves it, only then she will date him.
			Nina gave him an array of positive integers, 'ARR' and asked him to find the sum
			of divisors of the integers in 'ARR' with exactly four divisors. In case there is no
			such integer with exactly four divisors, then the answer is 0. Ninja has been
			struggling for a very long time, so he needs your help to solve the problem.
			Constraints:
				1 <= T <= 5
				1 <= N <= 2000
				1 <= ARR[i] <= 10 ^ 5
				Where 'T' is the number of test cases, 'N' is the number of integers in the array,
				ARR' and 'ARR[i]' is the 'ith element in the 'ARR' array.
				Time limit: 1 second
			Sample Input 1:
				2
				4
				2 5 6 15
				3
				4 18 21
				Sample Output 1:
				36
				32
				Explanation of Sample Output 1:
				Test Case 1 :  
				Divisors of 2 are 1 and 2.
				Divisors of 5 are 1 and 5.
				Divisors of 6 are 1, 2, 3 and 6.
				Divisors of 15 are 1, 3, 5 and 15.
				Since 6 and 15 have exactly four divisors. Sum of their divisors is (1 + 2 + 3 + 6) + (1 + 3 + 5 + 15) = 36.

				Test Case 2 : 
				Divisors of 4 are 1, 2 and 4.
				Divisors of 18 are 1, 2, 3, 6, 9 and 18.
				Divisors of 21 are 1, 3, 7 and 21.
				Since only 21 has exactly four divisors. Sum of its divisors is (1 + 3 + 7 + 21) = 32.
				Sample Input 2:
				2
				5
				7 35 64 11 8
				6
				27 13 42 25 25 25
				Sample Output 2:
				63
				40

		#include <bits/stdc++.h> 
		int sumFourDivisors(vector<int> &arr, int n) {
			int ans=0;
			for(int i=0; i<n; i++){
				int numDivisors=2;
				int sum=1;
				for(int j=2; j <= arr[i]/2; j++){
					if(arr[i] % j == 0){
						numDivisors++;
						sum += j;
					}

					if(numDivisors > 4)
						break;
				}
				sum += arr[i];
				if(numDivisors == 4)
					ans += sum;
			}
			return ans;
		}

	205) Minimum Difference in an Array:
		Problem statement
			Given an array of integers, print the minimum of the absolute difference of all
			possible pairs of elements.
			Example:
				N = 5
				ARR = [3, -6, 7, -7, 0]
			Out of all pairs, (-7,-6) have a difference of '1', and no other pair has less
			difference. So 'ANS' is '1'
			Constraints :
				1 <= T <= 10
				2 <= N <= 10^5
				-10^8 <= ARR[i] <= 10^8
				Sum of N <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				1 8 3 10   
				2
				5 5
				Sample Output 1 :
				2
				0
				Explanation Of Sample Input 1 :
				For test case 1, 
				Out of all pairs (1,3) and (8,10) have the minimum difference ‘2’ so the answer is ‘2’.
				For test case 2,
				There is only one possible pair (5,5) so the answer is ‘0’.
				Sample Input 2 :
				2
				3
				8 1 8
				2
				-3 3
				Sample Output 2 :
				0
				6

		//not optimized:
			#include <bits/stdc++.h> 
			int minDiff(int n, vector < int > arr) {
				int mnnr=INT_MAX;
				
				for(int i=0; i<n; i++){
					for(int j=i+1; j<n; j++){
					int num = abs(arr[i] - arr[j]);
					if(mnnr > num)
						mnnr = num;
					}
				}
				return mnnr;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int minDiff(int n, vector < int > arr) {
				int mnnr=INT_MAX;
				sort(arr.begin(), arr.end());

				for(int i=1; i<n; i++){
					int num = abs(arr[i] - arr[i-1]);
					if(mnnr > num)
					mnnr = num;
				}
				return mnnr;
			}

	206) Find The Nearest Supporter:
			Problem Statement
				There are contestants standing in a row. Each contestant is assigned a rating,
				which is an integer. A contestant supports all those whose rating is greater than
				their rating.
				Now for each contestant standing in the row, you need to tell the rating of its
				closest supporter on the left.
				If no supporter is there, store -1 in that place.
				For Example
					Consider the row: [3, 1, 5, 12, 10], with 1-based indexing -
					For index 3, there would be 2 supporters, index 1 and index 2, but index 2 is
					closest, hence for index 3, we will store '1' (Rating of contestant).
					For index 5, we will store '5'(at index 3).
				Constraints
					1 <= T <= 50
					1<=N<= 10000
					-10^9 <= data <= 10^9
					Where 'data' represents the given row elements.
					Time limit: 1 sec
			
			#include <bits/stdc++.h> 
			vector<int> prevSmall(vector<int> arr, int n) {
				// vector<int> ans(n,-1);
				// for(int i=1; i<n; i++){
				//     for(int j=i-1; j>=0; j--){
				//         if(arr[j] < arr[i]){
				//             ans[i] = arr[j];
				//             break;
				//         }
				//     }
				// }
				// return ans;

				//optimized
				vector<int>ans(n,-1);
				stack<int>s;
				for(int i=0;i<n;i++){
					while(!s.empty() and s.top()>=arr[i]) s.pop();
					if(!s.empty()) ans[i]=s.top();
					s.push(arr[i]);
				}
				return ans;
			}
	
	207) Find K-Th Element From Product Array:
		Problem statement
			You are given an integer array 'Arr' of length 'N'. Your task is to find the th
			element of the 'product' array when the 'product' array is sorted in non-decreasing order.
			The 'product' array of 'Arr' is an array of size (N*(N-1)) / 2 which consist|
			multiplication of each pair of elements present in the array 'Arr', i.e product[k] =Arr[i] * Arr[j], where 0 ≤i < j< 'N.
			Note:
			Return -1 if the value of 'K' exceeds the number of elements in the array 'product.
			For Example :
				Input array "arr"= [1, 2, 3, 4] and K = 3
				Output: 4
			Explanation: The 'product' array i.e array formed by multiplying each pair of
			element of 'Arr' is [1*2, 1*3, 1*4, 2*3, 2*4, 3*4] = [2, 3, 4, 6, 8, 12]. So the Kth(K =3) element in this sorted 'product' array is 4.
			Constraints:
				1 <= T <= 50
				1 <=N <= 10^4
				1 <=K<= 1019
				-10^4 <= Arr[i] <= 10^4
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4 2
				1 2 3 -1
				3 2
				-1 0 1
				Sample Output 1 :
				-2
				0
				Explanation For Sample Input 1 :
				Test Case 1:
				The ‘product’ array formed by multiplying any two numbers taken two at a time is : [-1 * 1, -1 * 2, -1 * 3, 1 * 2, 1 * 3, 2 * 3] = [-1, -2, -3, 2, 3, 6] and this array after sorting  is: [-3, -2, -1, 2, 3, 6]. So the 2nd element in the sorted ‘product’ array is -2.

				Test Case 2:
				The ‘product’ array formed by multiplying any two numbers taken two at a time is : [-1 * 0, -1 * 1, -0 * 1] [0, -1] and sorted ‘product’ array is: [-1, 0, 0]. So the 2nd element in the sorted ‘product’ array is 0.
				Sample Input 2 :
				2
				3 5
				1 3 4
				1 1
				-1
				Sample Output 2 :
				-1
				-1

		//not Optimized:
			#include <bits/stdc++.h> 
			int kthSmallest(vector<int> &arr, int k) {
				// vector<int> Vholder;
				// for(int i=0; i<arr.size()-1; i++){
				// 	for(int j=i+1; j<arr.size(); j++){
				// 		Vholder.push_back(arr[i]*arr[j]);
				// 	}
				// }

				// sort(Vholder.begin(), Vholder.end());
				// if(k>Vholder.size())
				// 	return -1;
				// return Vholder[k-1];
				

				//little optimized
				std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
				// Push the initial products into the min-heap
				for (int i = 0; i < arr.size() - 1; ++i) {
					for (int j = i + 1; j < arr.size(); ++j) {
						minHeap.push(arr[i] * arr[j]);
					}
				}

				// Check if k is greater than the number of products
				if (k > minHeap.size()) {
					return -1;
				}

				// Pop (k-1) smallest elements from the min-heap
				for (int i = 0; i < k - 1; ++i) {
					minHeap.pop();
				}

				// The top of the min-heap now contains the k-th smallest product
				return minHeap.top();
			}

		//Optimized:
			#include <bits/stdc++.h> 
			bool checkPair(std::vector<int> &pos, std::vector<int> &neg, int k, int mid) {
				int pairs = 0;
				int temp = neg.size() - 1;
				int negSize = neg.size() - 1;
				int posSize = pos.size() - 1;

				for (int i = 0; i < neg.size(); i++) {
					while (temp >= 0 && (neg[i] * neg[temp] <= mid)) {
						temp = temp - 1;
					}
					pairs = pairs + std::min(negSize - temp, negSize - i);
				}

				temp = 0;

				for (int i = pos.size() - 1; i >= 0; i--) {
					while ((temp < pos.size()) && (pos[i] * pos[temp] <= mid)) {
						temp = temp + 1;
					}
					pairs = pairs + std::min(temp, i);
				}

				temp = pos.size() - 1;

				for (int i = neg.size() - 1; i >= 0; i--) {
					while ((temp >= 0) && (neg[i] * pos[temp] <= mid)) {
						temp = temp - 1;
					}
					pairs = pairs + posSize - temp;
				}

				return pairs >= k;
			}

			int kthSmallest(std::vector<int> &arr, int k) {
				int n = arr.size();

				if (k > (n * (n - 1)) / 2) {
					return -1;
				}

				std::vector<int> pos;
				std::vector<int> neg;

				for (int i = 0; i < n; i++) {
					if (arr[i] >= 0) {
						pos.push_back(arr[i]);
					} else {
						neg.push_back(arr[i]);
					}
				}

				std::sort(neg.begin(), neg.end());
				std::sort(pos.begin(), pos.end());

				int l = -1 * 1e9;
				int ans = 0;
				int r = 1e9;

				while (l <= r) {
					int mid = (l + r) / 2;

					if (checkPair(pos, neg, k, mid)) {
						ans = mid;
						r = mid - 1;
					} else {
						l = mid + 1;
					}
				}

				return ans;
			}

	208) Largest 3-Same-Digit Number in String:
		Problem Statement:
			You are given a string num representing a large integer. 
			An integer is good if it meets the following conditions:
				It is a substring of num with length 3.
				It consists of only one unique digit.
			Return the maximum good integer as a string or an empty string "" if no such integer exists.

			Note:
			A substring is a contiguous sequence of characters within a string.
			There may be leading zeroes in num or a good integer.
			
			Example 1:
				Input: num = "6777133339"
				Output: "777"
				Explanation: There are two distinct good integers: "777" and "333".
				"777" is the largest, so we return "777".

			Example 2:
				Input: num = "2300019"
				Output: "000"
				Explanation: "000" is the only good integer.

			Example 3:
				Input: num = "42352338"
				Output: ""
				Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.

			Constraints:
				3 <= num.length <= 1000
				num only consists of digits.

		class Solution {
			public:
			string largestGoodInteger(string num) {
				string ans;
				for(int i=2; i<num.length(); i++){
					if(num[i] == num[i-1]){
						if(num[i-1] == num[i-2]){
							string temp = string(3,num[i]);
							if(ans.empty())
								ans = temp;
							else{
								if(ans[0] < temp[0])
									ans = temp;
							}
						}
					}
				}
				return ans;
			}
		};
	
	209) Count of Matches in Tournament:
		Problem Statement:
			You are given an integer n, the number of teams in a tournament that has strange rules:
			-If the current number of teams is even, each team gets paired with another team. 
			 A total of n / 2 matches are played, and n / 2 teams advance to the next round.
			-If the current number of teams is odd, one team randomly advances in the tournament, 
			 and the rest gets paired. A total of (n - 1) / 2 matches are played, 
			 and (n - 1) / 2 + 1 teams advance to the next round.
			 Return the number of matches played in the tournament until a winner is decided.

			Example 1:

				Input: n = 7
				Output: 6
				Explanation: Details of the tournament: 
				- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
				- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
				- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
				Total number of matches = 3 + 2 + 1 = 6.

			Example 2:
				Input: n = 14
				Output: 13
				Explanation: Details of the tournament:
				- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
				- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
				- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
				- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
				Total number of matches = 7 + 3 + 2 + 1 = 13.

			Constraints:
				1 <= n <= 200
			
		class Solution {
			public:
			int numberOfMatches(int n) {
				int cnt=0;
				while(n>0){
					if(n&1){
						cnt += (n-1)/2;
						n = ((n-1)/2) + 1; 
						if(n==1)
							break;
					}else{
						cnt += n/2;
						n = (n/2);
					}
				}
				return cnt;
			}
		};

		//or
			class Solution {
				public:
				int numberOfMatches(int n) {
					return n-1;
				}
			};
	
	210) Median of two sorted arrays:
		Problem statement
			Given two sorted arrays 'a' and 'b'of size 'n' and 'm'respectively.
			Find the median of the two sorted arrays.
			Median is defined as the middle value of a sorted list of numbers. In case the
			length of list is even, median is the average of the two middle elements.
			The expected time complexity is O(min(logn, logm)), where 'n' and 'm' are the
			sizes of arrays 'a' and 'b', respectively, and the expected space complexity is
			O(1).
			Example:
				Input: 'a' = [2, 4, 6] and 'b' = [1, 3, 5]
				Output: 3.5
				Explanation: The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 5, 6 }. Here two
				medians are 3 and 4. So the median will be the average of 3 and 4, which is 3.5.
			Sample Input 1:
				3 3
				2 4 6
				1 3 5
				Sample Output 1:
				3.5
				Explanation of Sample Input 1 :
				The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 5, 6 }. 
				Here two medians are 3 and 4. So the median will be the average of 3 and 4, which is 3.5.
				Sample Input 2:
				3 2
				2 4 6
				1 3  
				Sample Output 2:
				3
				Explanation of Sample Input 2 :
				The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 6 }. 
				The median is 3.
				Sample Input 3:
				3 3
				1 2 2
				2 4 4
				Sample Output 3:
				2.0
				Explanation of Sample Input 3 :
				The array after merging 'a' and 'b' will be { 1, 2, 2, 2, 4, 4 }. 
				Here two medians are 2 and 2. So the median will be the average of 2 and 2, which is 2.
			Constraints:
				1 <= 'n' <= 10 ^ 6
				1 <= 'm' <= 10 ^ 6
				1 <= 'a[i]' <= 10 ^ 9
				1 <= 'b[i]' <= 10 ^ 9
				Time limit: 1 sec.

		//Not Optimized:
			double median(vector<int>& a, vector<int>& b) {
				vector<int> holder;
				for(int i: a)
					holder.push_back(i);
				
				for(int i: b)
					holder.push_back(i);

				sort(holder.begin(), holder.end());

				if(holder.size()&1)
					return holder[(holder.size()/2)];

				double n = holder[holder.size()/2] + holder[(holder.size()/2)-1];
				return n/2;
			}

		//Optimized:
			double median(std::vector<int>& a, std::vector<int>& b) {
				int n1 = a.size(), n2 = b.size();
				int i = 0, j = 0;
				int n = n1 + n2;
				int ind2 = n / 2;
				int ind1 = ind2 - 1;
				int cnt = 0;
				int ind1el = -1, ind2el = -1;

				while (i < n1 && j < n2) {
					if (a[i] < b[j]) {
						if (cnt == ind1) ind1el = a[i];
						if (cnt == ind2) ind2el = a[i];
						cnt++;
						i++;
					} else {
						if (cnt == ind1) ind1el = b[j];
						if (cnt == ind2) ind2el = b[j];
						cnt++;
						j++;
					}
					if (ind1el != -1 && ind2el != -1)
						break;
				}

				while (i < n1) {
					if (cnt == ind1) ind1el = a[i];
					if (cnt == ind2) ind2el = a[i];
					cnt++;
					i++;
					if (ind1el != -1 && ind2el != -1)
						break;
				}

				while (j < n2) {
					if (cnt == ind1) ind1el = b[j];
					if (cnt == ind2) ind2el = b[j];
					cnt++;
					j++;
					if (ind1el != -1 && ind2el != -1)
						break;
				}

				if (n % 2 == 1) return ind2el;

				// return static_cast<double>(ind1el + ind2el) / 2.0;
				//or
				return (double)(double)(ind1el+ind2el)/2.0;
			}

	211) Query And Matrix:
		Problem statement
			You are given a binary matrix with 'M' rows and 'N' columns initially consisting of
			all 0's. 'Q' queries follow. The queries can be of 4 types:
			Query 1: 1 R index
			Query 2: 1 C index
			Query 3: 2 R index
			Query 4: 2 C index
			In each query, the first input is the type of the query, the second input is whether
			we have to consider the row ('R') or the column ('C') and the third input is the
			index of the row/column.
			For each type 1 query, we need to flip the elements of the row/column having the
			given index.
			For each type 2 query, we have to output the number of zeros present in the
			row/column having the given index.
			Note:
			Note that the matrix is a binary matrix, meaning that it only contains either 0 or 1.
			Example :
				Given M = 3, N = 3,
				Queries : 1R1, 1R2, 2C1
				So, in the above example the change in the matrix would look like this:
				
					0	0	0		0	0	0		0	0	0	
					0	0	0		1	1	1		1	1	1		
					0	0	0		0	0	0		1	1	1

				Next query 2C1 will return the count of the number of zeroes in the 1st column: 1
			Constraints:
				1 <= T <= 10
				1 <= M, N <= 100
				1 <= Q ≤= 1000
				1 <= R<= M
				1 <= C <=N
				type = 1, 2
				Time limit: 1 sec

			Sample Input 1:
				2
				3 3
				3
				1R1
				1R2
				2C1

				2 2
				1
				2R1
				Sample Output 1:
				1
				2
				Explanation of Sample Output 1:
					In test case 1, Next query 2C1 will return the count of the number of zeroes in the 1st column: 1
					The change in the matrix after the first and second queries would look like this:
						
					0	0	0		0	0	0		0	0	0	
					0	0	0		1	1	1		1	1	1		
					0	0	0		0	0	0		1	1	1

				In test case 2, all the matrix elements are zero and hence the count of zeroes will be 2 for the first row.
				Sample Input 2:
				2
				3 3
				4
				2C1
				1R1
				1R1
				2R1
				2 2
				5
				2C1
				1R1
				1R1
				1R1
				2R1
				Sample Output 2:
				3 3
				2 0
				Explanation of Sample Output 2:
				In test case 1, 
				First query 2C1 will return the count of the number of zeroes in the 1st column: 3
				Next query 2R1 will return the count of the number of zeroes in the 1st row: 3
				The change in the matrix after the second and third queries would look like this:
					
					0	0	0		0	0	0		0	0	0	
					0	0	0		1	1	1		0	0	0		
					0	0	0		0	0	0		0	0	0

				In test case 2,
				First query 2C1 will return the count of the number of zeroes in the 1st column: 2
				Next query 2R1 will return the count of the number of zeroes in the 1st column: 0
				The change in the matrix after the second and third queries would look like this:

					0	0			0	0			0	0		0	0
					0	0			1	1			0	0		1	1

		//not Optimized:
			vector<int> query(vector<vector<int>> &mat, int m, int n, vector<string> &q){
				vector<int> ans;
				vector<vector<int>> holder(m, vector<int>(n,0));

				for(int i=0; i<q.size(); i++){
					string current = q[i];
					if(current[0] == '1'){
						if(current[1] == 'R'){
							for(int a = 0; a<n; a++){
								if(holder[current[2]-'0'][a] == 0){
									holder[current[2]-'0'][a] = 1;
								}else{
									holder[current[2]-'0'][a] = 0;
								}
							}
						}else{
							for(int a = 0; a<m; a++){
								if(holder[a][current[2]-'0'] == 0){
									holder[a][current[2]-'0'] = 1;
								}else{
									holder[a][current[2]-'0'] = 0;
								}
							}
						}
					}else{
						int cnt=0;
						if(current[1] == 'R'){
							for(int y=0; y<n; y++){
								if(holder[current[2]-'0'][y] == 0)
									cnt++;
							}
						}else{
							for(int y=0; y<m; y++){
								if(holder[y][current[2]-'0'] == 0)
									cnt++;
							}
						}
						ans.push_back(cnt);
					}
				}
				return ans;	
			}

		// Optimized:
			vector<int> query(vector<vector<int> > &mat, int m, int n, vector<string> &q){
				vector<int> ans;

				for(int i=0; i<q.size(); i++){
					if(q[i][0] == '1'){
						// flipping
						if(q[i][1] == 'R'){
							// in row
							for(int z=0; z<n; z++)
								mat[q[i][2]-'0'][z] = (mat[q[i][2]-'0'][z] == 0) ? 1 : 0;
						}else{
							// in col
							for(int z=0; z<m; z++)
								mat[z][q[i][2]-'0'] = (mat[z][q[i][2]-'0'] == 0) ? 1 : 0;
						}
					}else{
						// counting
						int numOfZ=0;
						if(q[i][1] == 'R'){
							// in row
							for(int z=0; z<n; z++)
								if(mat[q[i][2]-'0'][z] == 0)
									numOfZ++;
						}else{
							// in col
							for(int z=0; z<m; z++)
								if(mat[z][q[i][2]-'0'] == 0)
									numOfZ++;
						}
						ans.push_back(numOfZ);
					}
				}
				return ans;
			}

	212) Mailing Problem: 
		Problem Statement:
			Dr. Doofenshmirtz is trying to make another big mischief. To prevent this, Major
			Francis Monogram wants to send mail to Perry the Platypus to inform him about
			the mischief. He just needs to send a secret message 's' to perry. He has a
			special keyboard "keyboard" in which all the letters are in a straight line but
			jumbled. The time taken to move his finger from index 'ї to index j' is lj - il. He
			wants to know how much time will it take to send the secret message to Perry.
			Note:
			Initially, he is at the first letter of the keyboard.
			All letters are in lower-case English letters.
			For Example :
				Let s = "perry", keyboard = "qwertyuiopasdfghjkIzxcvbnm".
				Now In this example, Francis will start from the first index and go to 'p', which
				will take 9 seconds, now from 'p' to 'e', the distance is of 7 indexes, from 'e' to 'r'
				the distance is 1, from 'r' to 'f' it will be zero, and from '"' to 'y the distance will
				be 2. Hence the total time taken is 9 + 7 + 1 + 0 + 2 = 19.
				Hence the answer is 19.
			Sample Input 1 :
				2
				abcdefghijklmnopqrstuvwxyz
				abc
				zyxwvutsrqponmlkjihgfedcba
				zayb
				Sample Output 1 :
				2
				72
				Explanation For Sample Output 1 :
				For the first test case, Francis is currently on ‘a’ so he does not have to move his fingers for the first letter and then move one index from ‘a’ to ‘b’ and again one index from ‘b’ to ‘c’.
				Hence the answer is 2.

				For the second test case, he will start from the 0th index and then move to 25 to type ‘a’, then to index 1 to type ‘y’, and at last to index 24 to type ‘b’. Hence the total time taken is 0 + 25 + 24 + 23 = 72.
				Sample Input 2 :
				2
				mvpglaejurowcfbtisdkzhxqny
				ferb
				bjqtcxmkgzfeowdlsuaypnivrh
				phineas
				Sample Output 2 :
				28
				48
			
		int timeTakenToMail(string keyboard, string s) {
			int Time=0;
			Time += keyboard.find(s[0]);

			int curIndex = Time;
			for(int i=1; i<s.size(); i++){
				int flag = 0;
				// check on left side
				int cnt =0;
				for(int z = curIndex; z >=0; z--){
					if(s[i] == keyboard[z]){
						curIndex = z;
						flag=1;
						break;
					}
					cnt++;
				}

				// if not found on left side go check on right side
				if(!flag){
					cnt =0;
					for(int z = curIndex; z < 26; z++){
						if(s[i] == keyboard[z]){
							curIndex = z;
							flag=1;
							break;
						}
						cnt++;
					}
				}
				Time += cnt;
			}
			return Time;
		}
	
	213) Calculate Money in Leetcode Bank:
		Problems Statement:
			Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.
			He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, 
			he will put in $1 more than the day before. On every subsequent Monday, 
			he will put in $1 more than the previous Monday.
			Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

			Example 1:
				Input: n = 4
				Output: 10
				Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.

			Example 2:
				Input: n = 10
				Output: 37
				Explanation: After the 10th day, the total is 
				(1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.

			Example 3:
				Input: n = 20
				Output: 96
				Explanation: After the 20th day, the total is 
				(1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.

			Constraints:
				1 <= n <= 1000
		
		class Solution {
			public:
			int totalMoney(int n) {
				int ttl=0, day=0, start=1, num=1;
				for(int i=0; i<n; i++){
					if(day == 7){
						day =0;
						start++;
						num = start;
					}
					ttl += num++;
					day++;
				}
				return ttl;
			}
		};

		//or
		class Solution {
			public:
			int totalMoney(int n) {
				int ttl=0;
				int start=1;
				int num=start;

				for(int i=1; i<=n; i++){
					ttl += num++;
					if(i % 7 == 0){
						start++;
						num = start;
					}
				}
				return ttl;
			}
		};

	214) How Many X's:
		Problem Statement:
			Given two integers L, R, and digit X. Find the number of occurrences 
			of X in all the numbers in the range (L, R) excluding L and R.

			Example 1:
				Input:
				L=10, R=19, X=1
				Output:
				9
				Explanation:
				There are 9 1s (11, 12, 13, 14, 15, 16, 17, 18) in the numbers in the range (10,19).

			Example 2:
				Input:
				L=18, R=81, X=9
				Output:
				7
				Explanation:
				There are 7 occurrences of the digit 9 in the numbers in the range (18,81).
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function 
				countX() which takes three integers L, R, and X as input parameters and 
				returns the number of occurrences of X in the numbers in the range(L, R).

			Expected Time Complexity:O(RLogR)
			Expected Auxillary Space:O(1)

			Constraints:
				1 <= L< R <= 105
				0 <= X <= 9 

		class Solution {
			public:
			int countX(int L, int R, int X) {
				int cnt=0;
				for(int i=L+1; i<R; i++){
					int num = i;
					while(num != 0){
						if(X == (num%10))
							cnt++;
						num /=10;
					}
				}
				return cnt;
			}
		};

	215) Faulty Key:
		problem statement:
			Addition without using + & ++ operator.
				Ninja is trying to write a function that takes two integers and returns their sum.
				But, due to some faults in his keyboard, he can not use the "+", operator, which
				means he is not able to simply return 'A + 'B', where A and 'B' are the numbers
				to be added. You need to help Ninja in finding the sum of two numbers without
				using the "+" operator anywhere in your code.
				Note:
					You should also not use the increment "++" operator too.
				For example:
					You are given A = 4, B = 6, their sum = 10, you need to return 10.
			Constraints:
				1 <=Т<= 100
				-10000 <= A, B <= 10000
				where 'T' is the number of test cases and 'A' and 'B' are the two integers.
				Time limit: 1 sec
			Sample Input 1:
				2
				1 1
				4 6
				Sample Output 1:
				2
				10
				Explanation of sample input 1:
				In the first test case, 
				Sum of the two numbers = 1 + 1 = 2. 

				In the second test case, 
				Sum of the two numbers = 4 + 6 = 10.
				Sample Input 2:
				2
				-1 1
				0 1
				Sample Output 2:
				0
				1
				Explanation of sample input 1:
				In the first test case, 
				Sum of the two numbers = (-1) + 1 = 0.

				In the second test case, 
				Sum of the two numbers = 0 + 1 = 1.
		
		#include <bits/stdc++.h> 
		int getSum(int a, int b) {
			// return a -(-b);
			
			//or
			while (b != 0) {
				// Calculate the carry
				int carry = a & b;

				// XOR a and b to get the sum
				a = a ^ b;

				// Shift the carry by 1 position to the left
				b = carry << 1;
			}
			return a;
		}

	216) Generate Binary Numbers:
		Problem statement
			Your friend Ninja has been learning about binary numbers lately. In order to
			understand binary numbers with perfection, Ninja asks you to generate a list of
			binary numbers from 1 to 'N', which he can use later for reference.
			For every integer Ninja gives, your task is to generate all the binary numbers
			from 1 to 'N'.
			Example:
			Consider N = 5,
				All the binary numbers from 1 to 5 are: 1, 10, 11, 100, 101.
			Constraints:
				1 <= T <= 10
				1 <=N<= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				6
				Sample Output 1:
				1 10
				1 10 11 100 101 110
				Explanation 1:
				For the first test case when N = 2. 
				We need all the binary numbers from 1 to 2:
				1 -> 1
				2 -> 10
				Thus, the output is 1, 10.

				For the second test case when N = 6
				We need all the binary numbers from 1 to 6:
				1 -> 1
				2 -> 10
				3 -> 11
				4 -> 100
				5 -> 101
				6 -> 110
				Thus, the output is 1, 10, 11, 100, 101, 110.
				Sample Input 2:
				2
				8
				4
				Sample Output 2:
				1 10 11 100 101 110 111 1000
				1 10 11 100

		#include <bits/stdc++.h> 
		vector<string> generateBinaryNumbers(int n) {
			vector<string> ansHolder;

			for(int i=1; i<=n; i++){
				string s = bitset<32>(i).to_string();

				//This while loop also works
				while(s[0] == '0')
					s.erase(s.begin());

				//converting string back to num so we can get rid of leading zeros,
				//in this scenario getting runtime error. This is not working
					// int num = stoi(s);
					// s = to_string(num);

				//to remove leading zeros use below line
				//This substr method also works
				// s = s.substr(s.find('1'));

				ansHolder.push_back(s);   
			}
			return ansHolder;
		}

	217)	Largest Odd Number in String:
		Problem Statement:
			You are given a string num, representing a large integer. 
			Return the largest-valued odd integer (as a string) that is a 
			non-empty substring of num, or an empty string "" if no odd integer exists.

			A substring is a contiguous sequence of characters within a string.

			Example 1:
				Input: num = "52"
				Output: "5"
				Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.

			Example 2:
				Input: num = "4206"
				Output: ""
				Explanation: There are no odd numbers in "4206".

			Example 3:
				Input: num = "35427"
				Output: "35427"
				Explanation: "35427" is already an odd number.

			Constraints:
				1 <= num.length <= 105
				num only consists of digits and does not contain any leading zeros.
	
		class Solution {
			public:
			string largestOddNumber(string num) {
				// if((num[num.size()-1] - '0') % 2 != 0)
				//     return num;
				
				// string s;
				// for(int i=num.size(); i>=0; i--){
				//     //checking if its odd
				//     if((num[i]-'0') & 1){
				//         for(int j=0; j<=i; j++){
				//             s += num[j];
				//         }
				//         return s;
				//     }
				// }
				// return "";

				//or
				for(int i=num.size()-1; i>=0; i--){
					if((num[i]-'0') & 1){
						return num;
					}
					num.erase(num.begin()+i);
				}
				return "";
			}
		};
	
	218) Transform to prime:
		Problem Statement:
			Given an array of n integers. Find the minimum positive number to be inserted in array, 
			so that sum of all elements of array becomes prime.

			Example 1:
				Input:
				N=5
				arr = {2, 4, 6, 8, 12}
				Output:  
				5
				Explanation: 
				The sum of the array is 32 ,we can add 5 to this to make it 37 which is a prime number.

			Example 2:
				Input:
				N=3
				arr = {1, 5, 7}
				Output:  
				0 
				Explanation: 
				The sum of the array is 13 which is already prime. 

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function minNumber() that takes array arr 
				and integer N as input parameters and returns the minimum positive 
				number to be inserted in the array so as to make it's sum a prime number.

			Expected Time Complexity: O(N log(log N))
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ N ≤ 10^5
				1 ≤ sum of all elements ≤ 10^6

		class Solution {
			public:
			int minNumber(int arr[],int N) {

				//calculating sum of array
				vector<int> holder;
				holder.assign(arr, arr+N);
				int sum =0;

				for(int i: holder)
					sum += i;
				
				int adder=0;
				while(1){
					//checking sum is prime or not
					int i;
					for(i=2; i<=sum/2; i++){
						if(sum % i == 0)
							break;
					}
					
					if(i == (sum/2)+1)
						return adder;
					sum ++;
					adder++;
				}
			}
		};

	219)	Transpose Matrix:
		Problem Statement:
			Given a 2D integer array matrix, return the transpose of matrix.
			The transpose of a matrix is the matrix flipped over its main diagonal, 
			switching the matrix's row and column indices.

			Example 1:
				Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
				Output: [[1,4,7],[2,5,8],[3,6,9]]

			Example 2:
				Input: matrix = [[1,2,3],[4,5,6]]
				Output: [[1,4],[2,5],[3,6]]

			Constraints:
				m == matrix.length
				n == matrix[i].length
				1 <= m, n <= 1000
				1 <= m * n <= 10^5
				-10^9 <= matrix[i][j] <= 10^9

		class Solution {
		public:
			vector<vector<int>> transpose(vector<vector<int>>& matrix) {
				vector<vector<int>> transpose;
				for(int i=0; i<matrix[0].size(); i++){
					vector<int> holder;
					for(int j=0; j<matrix.size(); j++){
						holder.push_back(matrix[j][i]);
					}
					transpose.push_back(holder);
				}
				return transpose;
			}
		};

		//or
			class Solution {
			public:
				vector<vector<int>> transpose(vector<vector<int>>& matrix) {
					vector<vector<int>> transpose(matrix[0].size(),vector<int>(matrix.size()));
					
					for(int i=0; i<matrix.size(); i++)
						for(int j=0; j<matrix[0].size(); j++)
							transpose[j][i] = matrix[i][j];
					
					return transpose;
				}
			};
	
	220)	Count the loop: ❌Pending
		-Count the no.of times loop will iterate.
		Problem statement
			Alice and Bob recently studied bitwise operators and were extremely fascinated
			by them. Alice found the following function in a book:
			Function magic(P, Q)
				while Q > 0:
				A = P AND Q
				B = P XOR Q
				Q = A* 2
				P = В
				return P
			Alice wondered how many times the while loop would run for any value of 'P'
			and 'Q'. Alice gave Bob the binary representation of 'P' and 'Q' and asked him to
			help her count this.
			Help Bob count the number of times the while loop would run for the given value
			of 'P' and 'Q.

		//Not optimized:
			#include <bits/stdc++.h> 
			int countLoop(string p, string q) {
				int cnt=0;
				int p = stoi(p1,0,2);
				int q = stoi(q1,0,2);

				while(q>0){
					int a = p & q;
					int b = p ^ q;
					q = a << 1;
					p = b;
					cnt++;
				}
				return cnt;
			}
		
		//optimized:
			#include <bits/stdc++.h>
			int countLoop(string p, string q) {
					if (q[0] == '0') {
					// 'q' is already zero.
					return 0;
				}

				// Reversing both the strings.
				std::string reversedP = p;
				std::string reversedQ = q;
				std::reverse(reversedP.begin(), reversedP.end());
				std::reverse(reversedQ.begin(), reversedQ.end());

				// Adding ‘0’ to the end so that both their lengths become equal.
				while (reversedP.size() < reversedQ.size()) {
					reversedP += "0";
				}

				while (reversedQ.size() < reversedP.size()) {
					reversedQ += "0";
				}

				int carry = 0, ans = 0, cur = 0;

				for (int i = 0; i < static_cast<int>(reversedP.size()); i++) {
					carry = carry + (reversedP[i] - '0') + (reversedQ[i] - '0');

					if (carry == 2) {
						// Continuing carry chain.
						cur += 1;
					} else {
						if (carry <= 1) {
							// Carry chain broken.
							cur = 0;
						} else {
							// Carry chain broken and new chain started.
							cur = 1;
						}
					}

					if (carry <= 1) {
						carry = 0;
					} else {
						carry = 1;
					}

					// Storing the longest carry chain.
					ans = std::max(ans, cur + 1);
				}

				return ans;
			}
	
	221) Max Sum Subarray of size K:
		Problem Statement:
			Given an array of integers Arr of size N and a number K. 
			Return the maximum sum of a subarray of size K.
			NOTE*: A subarray is a contiguous part of any given array.

			Example 1:
				Input:
				N = 4, K = 2
				Arr = [100, 200, 300, 400]
				Output:
				700
				Explanation:
				Arr3  + Arr4 =700,
				which is maximum.

			Example 2:
				Input:
				N = 4, K = 4
				Arr = [100, 200, 300, 400]
				Output:
				1000
				Explanation:
				Arr1 + Arr2 + Arr3 + Arr4 =1000,
				which is maximum.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function 
				maximumSumSubarray() which takes the integer K, 
				vector Arr with size N, containing the elements of the array 
				and returns the maximum sum of a subarray of size K.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 105
				1 <= Arri <= 105
				1 <= K <= N
		
		//not optimized
			class Solution{
				public:
				long maximumSumSubarray(int K, vector<int> &Arr , int N){
					long mxr=0;
					for(int i=0; i<=N-K; i++){
						long sum =0;
						for(int j=i; j<i+K; j++){
							sum += Arr[j];
						}
						if(mxr<sum)
							mxr = sum;
					}
					return mxr;
				}
			};

		//optimized:
			class Solution{   
				public:
				long maximumSumSubarray(int K, vector<int> &Arr , int N){
					long mxr = 0;
					long sum = 0;

					// Calculate the sum of the first subarray of length K
					for (int i = 0; i < K; i++) {
						sum += Arr[i];
					}
				
					mxr = sum;
				
					// Use a sliding window to efficiently find the maximum sum
					for (int i = K; i < N; i++) {
						// Update the sum by removing the first element of the window
						// and adding the current element to the window
						sum = sum - Arr[i - K] + Arr[i];
				
						// Update the maximum sum if needed
						mxr = max(mxr, sum);
					}
					return mxr;
				}
			};

	222) Ninja And His Old Friends
		Problem Statement:
			Ninja wants to meet his 'N' old friends standing in a row. All the friends along
			with Ninja are very happy because they are meeting after a long time. The
			happiness of each friend can be represented as a positive integer. Initially, Ninja
			has some happiness value "K. Ninja shakes hands with all of his 'N' friends
			standing in a row one by one.
			While shaking hands if the happiness value of Ninja matches with that of his
			friend, then the happiness value of Ninja becomes double. Ninja wants to
			calculate his happiness value after he shakes hands with all of his friends.
			For Example: For 'FRIENDS' = [3, 2, 1, 4]. And 'K = 2, following are the results
			after each hand shake:
			1. At index 0 the happiness value of his friend is 3 and the happiness value of
			Ninja is 2. Both are unequal so "K' remains the same.
			2. At index 1 the happiness value of his friend is 2 and the happiness value of
			Ninja is 2. Both are equal so "K" becomes 4.
			3. At index 2 the happiness value of his friend is 1 and the happiness value of
			4 At index the epines solve or mistine is 4 and the happiness value of
			Ninja is 4. Both are equal so "K' becomes 8.
			As Ninja is busy with his friends so he needs your help. Can you help Ninja to
			find his final happiness value after all the handshakes?

			Constraints:
				1 <= T <= 100
				1 <= N <= 10 ^ 4
				1 <= К <= 10 ^ 3
				1 <= FRIENDS[i] <= 10 ^ 6
				Where 'FRIENDS[I]' denotes the happiness value of the friend at the 'ї index,
				respectively.
				Time Limit: 1 sec
			
			Sample Input 1:
				2
				3 1
				1 2 4 
				2 4 
				1 2
				Sample Output 1:
				8
				4 
				Explanation of Sample Input 1:
				For the first test case:
				1. At index 0 the happiness value of his friend is 1 and the happiness value of Ninja is 1. Both are equal so ‘K’ becomes 2.
				2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 2. Both are equal so ‘K’ becomes 4.
				3. At index 2 the happiness value of his friend is 4 and the happiness value of Ninja is 4. Both are equal so ‘K’ becomes 8.

				For the second test case:
				1. At index 0 the happiness value of his friend is 1 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same. 
				2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same. 
				Sample Input 2:
				2
				2 5
				5 5 
				3 8
				2 4 8 
				Sample Output 2:
				10
				16
				Explanation of Sample Input 2:
				For the first test case:
				1. At index 0 the happiness value of his friend is 5 and the happiness value of Ninja is 5. Both are equal so ‘K’ becomes 10.
				2. At index 1 the happiness value of his friend is 5 and the happiness value of Ninja is 10. Both are unequal so ‘K’ remains the same.    

				For the second test case:
				1. At index 0 the happiness value of his friend is 2 and the happiness value of Ninja is 8. Both are unequal so ‘K’ remains the same.
				2. At index 1 the happiness value of his friend is 4 and the happiness value of Ninja is 8. Both are unequal so ‘K’ remains the same.
				3. At index 2 the happiness value of his friend is 8 and the happiness value of Ninja is 8. Both are equal so ‘K’ becomes 16.

		#include <bits/stdc++.h> 
		int shakeHands(vector<int> &friends ,int n, int k) {
			for(int i=0; i<n; i++)  
				if(friends[i] == k)
					k *=2;

			return k;
		}

	223) First Unique Character in a String:
		Problem Statement:
			Given a string s, find the first non-repeating character in it and return its index. 
			If it does not exist, return -1.

			Example 1:
				Input: s = "leetcode"
				Output: 0

			Example 2:
				Input: s = "loveleetcode"
				Output: 2

			Example 3:
				Input: s = "aabb"
				Output: -1
			
			Constraints:
				1 <= s.length <= 105
				s consists of only lowercase English letters.
		
		class Solution {
			public:
			int firstUniqChar(string s) {
				for(int i=0; i<s.length(); i++){
					int j;
					for(j=0; j<s.length(); j++){
						if(i==j)
							continue;
						if(s[i] == s[j])
							break;
					}
					if(j==s.length())
						return i;
				}
				return -1;
			}
		};

	224) Element Appearing More Than 25% In Sorted Array:
		Problem Statement:
			Given an integer array sorted in non-decreasing order, 
			there is exactly one integer in the array 
			that occurs more than 25% of the time, return that integer. 
			Example 1:
				Input: arr = [1,2,2,6,6,6,6,7,10]
				Output: 6
			Example 2:
				Input: arr = [1,1]
				Output: 1

			Constraints:
				1 <= arr.length <= 104
				0 <= arr[i] <= 105
		
		class Solution {
			public:
			int findSpecialInteger(vector<int>& arr) {
				int cnt=1,i;
				if(arr.size()==1)
					return arr[0];

				for(i=1; i<arr.size(); i++){
					if(arr[i] == arr[i-1])
						cnt++;
					else
						cnt=1;
					
					if(cnt > (arr.size()/4))
						break;
				}
				return arr[i];    
			}
		};

	225) Maximum Product of Two Elements in an Array:
		Problem Statement:
			Given the array of integers nums, you will choose two different indices i and j of that array. 
			Return the maximum value of (nums[i]-1)*(nums[j]-1). 

			Example 1:
				Input: nums = [3,4,5,2]
				Output: 12 
				Explanation: If you choose the indices i=1 and j=2 (indexed from 0), 
				you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 

			Example 2:
				Input: nums = [1,5,4,5]
				Output: 16
				Explanation: Choosing the indices i=1 and j=3 (indexed from 0), 
				you will get the maximum value of (5-1)*(5-1) = 16.

			Example 3:
				Input: nums = [3,7]
				Output: 12

			Constraints:
				2 <= nums.length <= 500
				1 <= nums[i] <= 10^3
		
		//Optimized:
			class Solution {
				public:
				int maxProduct(vector<int>& nums) {
					int maxPro=0;
					for(int i=0; i<nums.size(); i++){
						for(int j=0; j<nums.size(); j++){
							if(i==j)
								continue;
							int crntValue = (nums[i]-1) * (nums[j]-1);
							maxPro = max(crntValue, maxPro);
						}
					}
					return maxPro;
				}
			};

		//much more Optimized:
			class Solution {
				public:
				int maxProduct(vector<int>& nums) {
					sort(nums.begin(), nums.end());
					return (nums[nums.size()-1]-1) * (nums[nums.size()-2]-1);
				}
			};

	226) Sub Query Sum:
		Problem statement
			You have given a 2-dimensional array 'ARR' with "N' rows and "M' columns. The
			queries are given in a 2-dimensional array 'Queries' of size 'K', in which Queries[i]
			contains four integers denoting the left top and right bottom indices of the
			submatrix whose sum we need to find. Your task is to find the sum of the
			submatrix for each query given in the array 'Queries'.
			For example:
			Consider ARR = [[1, 2, 3] , [3, 4, 1], [2, 1, 2]] and Queries = [[0, 0, 1, 2]], the
			submatrix with the left top index (0, 0) and right bottom index (1, 2) is
			[[1, 2,3],
			[3, 4, 1]].
			The sum of the submatrix is 14. Hence, the answer is 14 in this case.
			Constraints :
				1 <= N <= 10 ^ 3
				1 <= M <= 10 ^ 3
				1 <= К <= 10 ^ 3
				1 <= ARR[i][j] <= 10 ^ 6
				0 <= Queries[i][0] , Queries[i][2] < N
				0 <= Queries[i][1] , Queries[i][3] < M
				Where 'T"' denotes the number of test cases, 'N"' and 'M' denotes the number of
				rows and the number of columns in the array 'ARR" respectively, "K' denotes the
				number of rows in the array 'Queries', 'ARR[i][j]' denotes the "j-th' element of 'i-
				th' row of the array 'ARR' and 'Queries[i]' contains four integers denoting the left
				top and right bottom indices of the submatrix.
				Time Limit: 1sec

		Sample Input 1 :
			2
			2 2 1
			4 2 
			1 3 
			0 0 1 0
			3 3 2
			2 1 2
			3 2 6 
			1 4 5
			1 1 2 2
			0 1 0 2
			Sample Output 1 :
			5
			17 3   
			Explanation of sample input 1:
			For the first test case, 
			The submatrix with the left top index (0 , 0) and right bottom index (1 , 0) is  
								[[4] , 
								[1]]. 
			The sum of the submatrix is 5. Hence, the answer is 5 in this case.

			For the second test case,
			The submatrix with the left top index (1 ,1) and right bottom index (2 , 2) is  
								[[2 , 6] , 
								[4 , 5]]. 
			The sum of the submatrix is 17. Hence, the answer is 17 in this case.

			The submatrix with the left top index (0 , 1) and right bottom index (0 , 2) is  
								[[1 , 2]].  
			The sum of the submatrix is 3. Hence, the answer is 3 in this case.
			Sample Input 2 :
			2
			2 2 2
			5 6 
			7 5 
			0 0 0 0
			0 0 1 1
			3 3 2
			3 4 3
			4 3 4 
			1 1 1
			0 0 0 2
			0 0 2 1
			Sample Output 2 :
			5 23
			10 16

		#include <bits/stdc++.h> 
		vector<int> findSubmatrixSum(vector<vector<int>> &arr, vector<vector<int>> &queries) {
			vector<int> ans;
			for(int i=0; i<queries.size(); i++){
				int startRow, startCol, endRow, endCol;
				startRow = queries[i][0];
				startCol = queries[i][1];
				endRow = queries[i][2];
				endCol = queries[i][3];
				int sum=0;
				
				for(int x=startRow; x<=endRow; x++)
					for(int y=startCol; y<=endCol; y++)
						sum += arr[x][y];
				
				ans.push_back(sum);
			}
			return ans;
		}

	227) Consecutive 1's not allowed: ❌Pending
		Problem Statement:
			Given a positive integer N, count all possible distinct binary 
			strings of length N such that there are no consecutive 1’s. 
			Output your answer modulo 109 + 7.
			Example 1:

				Input:
				N = 3
				Output: 5
				Explanation:
				5 strings are (000,
				001, 010, 100, 101).
			Example 2:
				Input:
				N = 2
				Output: 3
				Explanation: 
				3 strings are (00,01,10).

			Your Task:
				You don't have to print answer or take inputs. 
				Complete the function countStrings() which takes single integer n, 
				as input parameters and returns an integer denoting the answer. 

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 ≤ N ≤ 10^5
		
		//not Optimized:
			class Solution{
				public:
				// #define ll long long
				ll countStrings(int n) {
					long long cnt=0;
					int mod = 1e9+7;
					for(int i=0; ; i++){
						string s = bitset<32>(i).to_string();
						// std::cout << s << std::endl;
						string st;
						if(find(s.begin(), s.end(), '1') != s.end()){
							st = s.substr(find(s.begin(), s.end(), '1')-s.begin());
							// std::cout << st << std::endl;
						}
						
						if(st.length() > n)
							break;
						
						int flag=1;
						for(int a=1; a<st.length(); a++){
							if(st[a]=='1' && st[a-1] == '1'){
							flag=0;
							break;
							}
						}
						if(flag)
							cnt++;
							
						cnt %= mod;
					}
					return cnt;
				}
			};	

		//Optimized:
			class Solution{
				public:
				// #define ll long long
				ll countStrings(int n) {
				ll dp[n+1];
				int mod = 1e9+7;
				dp[1] = 2;
				dp[2] = 3;
				int i;
				for(int i=3; i<=n; i++){
					dp[i] = (dp[i-1]+dp[i-2]) %mod;
				}
				return dp[n];
				}
			};
	
	228) Difference Between Ones and Zeros in Row and Column:
		Problem Statement:
			You are given a 0-indexed m x n binary matrix grid.
			A 0-indexed m x n difference matrix diff is created with the following procedure:

			Let the number of ones in the ith row be onesRowi.
			Let the number of ones in the jth column be onesColj.
			Let the number of zeros in the ith row be zerosRowi.
			Let the number of zeros in the jth column be zerosColj.

			diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
			Return the difference matrix diff.

			Example 1:
				Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
				Output: [[0,0,4],[0,0,4],[-2,-2,2]]
				Explanation:
				- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
				- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
				- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
				- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
				- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
				- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
				- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
				- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
				- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2

			Example 2:
				Input: grid = [[1,1,1],[1,1,1]]
				Output: [[5,5,5],[5,5,5]]
				Explanation:
				- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
				- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
				- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
				- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
				- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
				- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5

			Constraints:
				m == grid.length
				n == grid[i].length
				1 <= m, n <= 105
				1 <= m * n <= 105
				grid[i][j] is either 0 or 1.

		class Solution {
			public:
			vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {
				vector<vector<int>> diff (grid.size(),vector<int> (grid[0].size()));
				
				for(int row=0; row<grid.size(); row++){
					//current Row operation
					int RowOnes=0, rowZero=0;
					for(int c=0; c<grid[0].size(); c++){
						if(grid[row][c] == 1)
							RowOnes++;
						else
							rowZero++;
					}
					for(int col=0; col<grid[0].size(); col++){
						//current Col operation
						int colOnes=0, colZero=0;
						for(int r=0; r<grid.size(); r++){
							if(grid[r][col] ==1)
							colOnes++;
							else
							colZero++;
						}
						diff[row][col] = RowOnes+colOnes - rowZero - colZero;
					}
				}
				return diff;
			}
		};
	
	229) Average Marks:
		Problem Statement:
			Problem statement
				You are given the name of a student in the form of a character
				"firstLetterOfName' and 3 integers M1', 'M2, 'M3' representing the marks of the
				student in 3 subjects. You have to print the firstLetterOfName' of the student
				and the average marks obtained by the student.
				Note: You need to print the integer part of the average only and neglect the
				decimal part.
				For Example :
					If "firstLetterOfName' = 'K', M1' = 10, M2' = 6 and 'M3' = 9, then the average
					marks would be around 7.67. Hence, the output should be as follows: K 7
				Constraints:
					1 <= T <= 10
					'A' <= 'firstLetterOfName' <= 'Z'
					0 <= M1 <= 100
					0 <= M2 <= 100
					0 <= M3 <= 100
					Time Limit: 1 sec
			
			Sample Input 1:
				2
				A
				3 4 6
				T
				7 3 8
				Sample Output 1:
				A 4
				T 6
				Explanation For Sample Input 1:
				For sample case 1, average marks of the student are (3 + 4 + 6)/3 = 4.33 
				and his/her first character of the name is ‘A’. 
				Therefore, the output is : A 4
				
				For sample case 2, average marks of the student are (7 + 3 + 8)/3 = 6 
				and his/her first character of the name is ‘T’. 
				Therefore, the output is : T 6
				Sample Input 2:
				2
				Q
				10 34 96
				P
				71 80 3
				Sample Output 2:
				Q 46
				P 51
				Explanation For Sample Input 2:
				For sample case 1, average marks of the student are (10 + 34 + 96)/3 = 46.67 
				and his/her first character of the name is ‘Q’. 
				Therefore, the output is : Q 46
				
				For sample case 2, average marks of the student are (71 + 80 + 3)/3 = 51.33 
				and his/her first character of the name is ‘P’. 
				Therefore, the output is : P 51

		#include <bits/stdc++.h> 
		#include <utility>

		pair<char, int> averageMarks(char firstLetterOfName, int m1, int m2, int m3) {
			char ch = firstLetterOfName;
			int avg = (m1 +m2 +m3)/3;
			return {ch, avg};
		}

		//or
		pair<char, int> averageMarks(char firstLetterOfName, int m1, int m2, int m3) {
			char ch = firstLetterOfName;
			int avg = (m1 +m2 +m3)/3;
			pair<char, int> p = {ch, avg};
			return p;
		}

		//or
		pair<char, int> averageMarks(char firstLetterOfName, int m1, int m2, int m3) {
			char ch = firstLetterOfName;
			int avg = (m1 +m2 +m3)/3;
			pair<char, int> p;
			p.first = firstLetterOfName;
			p.second = avg;
			return p;
		}

	230) Destination City:
		Problem Statement:
			You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. 
			Return the destination city, that is, the city without any path outgoing to another city.
			It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

			Example 1:
				Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
				Output: "Sao Paulo" 
				Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".

			Example 2:
				Input: paths = [["B","C"],["D","B"],["C","A"]]
				Output: "A"
				Explanation: All possible trips are: 
				"D" -> "B" -> "C" -> "A". 
				"B" -> "C" -> "A". 
				"C" -> "A". 
				"A". 
				Clearly the destination city is "A".

			Example 3:
				Input: paths = [["A","Z"]]
				Output: "Z"

			Constraints:
				1 <= paths.length <= 100
				paths[i].length == 2
				1 <= cityAi.length, cityBi.length <= 10
				cityAi != cityBi
				All strings consist of lowercase and uppercase English letters and the space character.
		
		class Solution {
			public:
			string destCity(vector<vector<string>>& paths) {
				string currentDestination = paths[0][1];
				for(int i=0; i<paths.size(); i++){
					if(currentDestination == paths[i][0]){
						currentDestination = paths[i][1];
						i=0;
					}
				}
				return currentDestination;
			}
		};

	231) Set Bits:
		Problem statement
			Write a program to count the number of 1's in the binary representation of an integer.
			Constraints
				1 <= N <= 100
		Sample Input 1:
			9
			Sample Output 1:
			2
			Explanation of Sample Input 1:
			Binary Representation of 9 is 1001.
			Sample Input 2:
			13
			Sample Output 2:
			3

		#include <bits/stdc++.h> 
		#include <iostream>

		using namespace std;

		//Write your countBits function here
		int countBits(int n){
			//return __builtin_popcount(n);
			
			//or
			int cnt=0;
			while(n>0){
				if(n&1)
					cnt++;
				n>>=1;
			}
			return cnt;
		}

		//  or
		/*
			int countBits(int a){
				int cnt=0;
				while(a){
					if(a&1)
						cnt++;
					a>>=1;
				}
				return cnt;
			}
		*/

		int main() {
			int n;
			cin >> n;
			cout<<countBits(n);
			return 0;
		}
	
	232) Valid Anagram:
		Problem Statement:
			Given two strings s and t, return true if t is an anagram of s, and false otherwise.
			An Anagram is a word or phrase formed by rearranging the letters of a 
			different word or phrase, typically using all the original letters exactly once.

			Example 1:
				Input: s = "anagram", t = "nagaram"
				Output: true

			Example 2:
				Input: s = "rat", t = "car"
				Output: false

			Constraints:
				1 <= s.length, t.length <= 5 * 104
				s and t consist of lowercase English letters.
		
		class Solution {
			public:
			bool isAnagram(string s, string t) {
				if(s.length() != t.length())
					return 0;
				
				int forS[26]={0}, forT[26]={0};
				//mapping for s
				for(int i=0; i<s.length(); i++){
					forS[s[i]-'a']++;
				}

				//mapping for t
				for(int i=0; i<t.length(); i++){
					forT[t[i]-'a']++;
				}

				for(int i=0; i<26; i++){
					if(forS[i] != forT[i])
						return 0;
				}
				return 1;
			}
		};

		//or
			class Solution {
				private:
					int checker[26]={0};
				public:
					bool isAnagram(string s, string t) {
						if(s.length() != t.size())          //you can use length or size method to access the no.of letter in string
							return 0;
						
						//mapper for s
						for(int i=0; i<s.size(); i++){
							checker[s[i]-'a']++;
						}

						//mapper for t
						for(int i=0; i<t.length(); i++){
							checker[t[i]-'a']--;
						}

						for(int z=0; z<26; z++)
							if(checker[z] != 0)
								return 0;
						return 1;
					}
			};

		//or simplest
			class Solution {
				public:
				bool isAnagram(string s, string t) {
					if(s.length() != t.length())
						return 0;
					sort(s.begin(), s.end());
					sort(t.begin(), t.end());
					if(s == t)
						return 1;
					return 0;
				}
			};
		
	233) Count Customers Who Did Not Get A Computer:
		Problem statement:
			Mr. X runs an internet cafe which has 'K' computers. His internet cafe has 'N'
			customers who can come anytime throughout the day. Initially, all the 'K
			computers are available for customer use. When a customer enters the cafe he
			first checks whether any available computer is there. If he finds one he starts
			using it and it is marked unavailable. When he leaves the cafe that computer is
			again marked as available. If the customer is not able to find any available
			computer he leaves the cafe immediately.
			You are given an integer array 'ARR' in which each value occurs exactly 2 times,
			the index of the first occurrence of any value denotes the arrival time of the
			customer while the second occurrence denotes the departing time of the
			customer. Your task is to find the no. of customers who were not able to find any
			available computer and had to leave the cafe immediately.
			For example :
			Consider the sequence of customers as [ 1, 2, 3, 2, 3, 1] for N = 3 and K = 2.
			The procedure takes place as follows:
			1) At the start, Customer 1 comes and finds an available computer and starts
			using it and now the number of available computers is reduced by 1.
			2) Customer 2 comes and he is also able to find an available computer and he
			starts using the computer. Now all the computers are unavailable.
			3) Customer 3 comes and goes back immediately as there are no computers
			available currently.
			4) Customer 2 leaves the cafe making 1 computer available.
			5) As customer 3 has already left no new computers are made available.
			6) Customer 1 leaves the cafe and all the computers are again available.
			As only Customer 3 was unable to find any available computers therefore the
			answer is 1 for this case.
			
			Constraints :
				1 <=T <= 10
				1 <= N <= 10^5
				1 <= К <= 10^5
				1 <= ARR[i] <= N
				Time Limit: 1 sec
			Sample Input 1:
				2
				2 2
				1 2 2 1
				3 2 
				1 3 2 1 2 3
				Sample Output 1:
				0
				1
				Explanation for Sample Input 1:
				For the first test case:
					1) Initially, Customer 1 comes and finds an available computer 
					and starts using it. Now only 1 computer is available.
					2) Then Customer 2 comes and takes the only available computer. Now all computers are unavailable.
					3) Customer 1 leaves the cafe making 1 computer available.
					4) Customer 2 leaves the cafe making all the computers available.
					As all customers were able to find an available computer and nobody 
					left without using a computer. Hence, the answer is 0 in this case.

				For the second test case : 
				The procedure takes place as follows :
					1) At the start, Customer 1 comes and finds an available computer and 
					starts using it and now the number of available computers is reduced by 1. 
					2) Customer 3 comes and he is also able to find an available computer 
					and he starts using the computer. Now all the computers are unavailable.
					3) Customer 2 comes and goes back immediately as there are no computers available currently. 
					4) Customer 1 leaves the cafe making 1 computer available. 
					5) As customer 2 has already left no new computers are made available. 
					6) Customer 3 leaves the cafe and all the computers are again available. 

				As only Customer 2 was unable to find any available computers therefore the answer is 1 for this case.
				Sample Input 2:
				2
				4 1
				1 2 3 4 4 3 2 1
				2 2
				1 2 1 2
				Sample Output 2:
				3
				0

		//not optimized:
			#include <bits/stdc++.h> 
			int countCustomers(vector<int> &arr, int k) {
				set<int> s;
				for(int i=0; i<arr.size(); i++)
					s.insert(arr[i]);

				if(s.size() == k)
					return 0;

				int left=0;
				vector<int> holder;
				vector<int> alreadyGone;
				for(int i=0; i<arr.size(); i++){
					if(find(holder.begin(), holder.end(), arr[i]) == holder.end()){
						if(k>0 && find(alreadyGone.begin(), alreadyGone.end(), arr[i]) == alreadyGone.end()){
							k--;
							holder.push_back(arr[i]);
						}else{
							alreadyGone.push_back(arr[i]);
							left++;
						}
					}else{
						k++;
					}
				}

				return (left/2);
			}

		// Own Solution:
			// Reference for set:
				#include <iostream>
				#include<set>
				using   namespace std;
				int main() {
					set<int> s;
					
					s.insert(1);
					s.insert(2);
					s.insert(43);
					s.insert(6);

					for(int i: s)
						cout<<i<<" ";
						
					// checks if that elements present in set if present then returns 1 else 0
					if(s.count(2))                          // this statement says if present then delete/remove it
						s.erase(2);
					
					std::cout << std::endl;
					std::cout << "is 100 present in set: ?" << s.count(100) << std::endl;
					std::cout << "is 43 present in set: ?" << s.count(43) << std::endl;
					std::cout << "is 45 present in set: ?" << s.count(45) << std::endl;
						
					cout<<endl;
					for(int i: s)
						cout<<i<<" ";
					return 0;
				}

			#include <bits/stdc++.h> 
			int countCustomers(vector<int> &arr, int k) {
				set<int> notFoundGuy;
				set<int> FoundGuy;
				int cnt=0;

				for(int i: arr){
					if(notFoundGuy.count(i)){
						notFoundGuy.erase(i);
					}else if(FoundGuy.count(i)){
						FoundGuy.erase(i);
						k++;
					}else if(k > 0){
						FoundGuy.insert(i);
						k--;
					}else{
						notFoundGuy.insert(i);
						cnt++;
					}
				}
				return cnt;
			}

			// or
			#include <bits/stdc++.h> 
			int countCustomers(vector<int> &arr, int k) {
			set<int> Found, notFound;
			int cnt=0;

			for(int i: arr){
				if(Found.count(i)){
					Found.erase(i);
					k++;
				}else if(notFound.count(i)){
					notFound.erase(i);
				}else if(k > 0){
					Found.insert(i);
					k--;
				}else{
					notFound.insert(i);
					cnt++;
				}
			}
			return cnt;
			}

		//optimized:
			#include <bits/stdc++.h> 
			int countCustomers(vector<int> &arr, int k) {
				int count = 0;
				std::unordered_map<int, int> hashh;
				int check = 0;

				for (int i = 0; i < arr.size(); i++) {
					if (hashh[arr[i]] == 0) {
						if (check < k) {
							hashh[arr[i]] = 1;
							check++;
						} else {
							hashh[arr[i]] = -1;
							count++;
						}
					} else if (hashh[arr[i]] == 1) {
						check--;
					}
				}
				return count;
			}
	
	234) Game of XOR: ❌Pending
		Problem Statement:
			Given an array A of size N. 
			The value of an array is denoted by the bit-wise XOR of all elements it contains. 
			Find the bit-wise XOR of the values of all subarrays of A.

			Example 1:
				Input: 
				N = 3 
				A = [1,2,3] 
				Output: 
				2
				Explanation:
				xor[1] = 1
				xor[1, 2] = 3
				xor[2, 3] = 1
				xor[1, 2, 3] = 0
				xor[2] = 2
				xor[3] = 3
				Result : 1 ^ 3 ^ 1 ^ 0 ^ 2 ^ 3 = 2

			Example 2:
				Input: 
				N = 2
				A = [1,2]
				Output: 
				0
				Explanation:
				xor[1] = 1
				xor[1, 2] = 3
				xor[2] = 2
				Result : 1 ^ 3 ^ 2 = 0

			Your Task:
				You don't need to read input or print anything.
				Your task is to complete the function gameOfXor() which takes an integer N and array A[] 
				as input parameters and returns the answer.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^5
				0 <= A[i] <= 10^9

		//not Optimized:
			class Solution {
				public:
				int gameOfXor(int N , int A[]) {
					
					//first individual insertion of all elements
					vector<int> holder;
					for(int i=0; i<N; i++){
						holder.push_back(A[i]);
					}
					
					//SubArray Ops
					for(int i=0; i<N-1; i++){
						vector<int> temp;
						temp.push_back(A[i]);
						for(int j=i+1; j<N; j++){
							temp.push_back(A[j]);
							
							//Xor ops
							int result = temp[0];
							for(int z=1; z<temp.size(); z++){
								result ^= temp[z];
							}
							holder.push_back(result);
						}
					}
					
					int res = holder[0];
					for(int y=1; y<holder.size(); y++)
						res ^= holder[y];
					
					return res;
				}
			};

		//Optimized:
			class Solution {
				public:
				int gameOfXor(int N , int A[]) {
					int exor=0,extra=0,times=0;
					for(int i=0;i<N;i++){
						times=(N-i);
						
						if( i == 0 )
							extra=0;
						else
							extra=(i)*(N-i);
						
						// cout<<fac+ex<<endl;
						if((times+extra) & 1) 
							exor^=A[i];
					}
					return exor;
				}
			};
	
	235) Maximum Product Difference Between Two Pairs:
		Problem Statement:
			The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).
			For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
			Given an integer array nums, choose four distinct indices w, x, y, and z 
			such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

			Return the maximum such product difference.
			Example 1:
				Input: nums = [5,6,2,7,4]
				Output: 34
				Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
				The product difference is (6 * 7) - (2 * 4) = 34.

			Example 2:
				Input: nums = [4,2,5,9,7,4,8]
				Output: 64
				Explanation: We can choose indices 3 and 6 for the first pair (9, 8) 
				and indices 1 and 5 for the second pair (2, 4).
				The product difference is (9 * 8) - (2 * 4) = 64.

			Constraints:
				4 <= nums.length <= 104
				1 <= nums[i] <= 104
				
		class Solution {
			public:
			int maxProductDifference(vector<int>& nums) {
				sort(nums.begin(), nums.end());
				return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);
			}
		};
		
	236) Reversing a Queue:
		Problem statement:
			You are given a queue of 'N' elements. Your task is to reverse the order of
			elements present in the queue.
			You can only use the standard operations of the QUEUE STL.
			1. enqueue(x): Add an item x to the rear of the queue.
			2. dequeue(): Removes an item from the front of the queue.
			3. size(): Returns the number of elements in the queue.
			4. front(): Finds front element.
			5. empty(): Checks whether the queue is empty or not.
			Constraints:
				1 <= T <= 100
				1 <= N <= 3000
				-10 ^ 5 <= Queue[i] <= 10 ^ 5
				Time Limit: 1 sec
			Sample Input 1:
				2
				1
				9
				5
				10 6 8 12 3
				Sample Output 1:
				9 
				3 12 8 6 10
				Explanation 1:
				For the first test case, the queue has only one element, i.e. 9. So, even after reversing, our queue remains the same.

				For the second test case, the queue has elements in the order: 10, 6, 8, 12, 3. Reversing the queue changes the order of elements to - 3, 12, 8, 6, 10.
				Sample Input 2:
				2
				2
				99 89
				6
				1 2 3 4 5 6
				Sample Output 2:
				89 99
				6 5 4 3 2 1

		#include <bits/stdc++.h> 
		queue<int> reverseQueue(queue<int> q) {
			// Write your code here.
			queue<int> reversed;
			vector<int> holder;
			while(!q.empty()){
				holder.push_back(q.front());
				q.pop();
			}
			reverse(holder.begin(), holder.end());
			for(int i=0; i<holder.size(); i++){
				reversed.push(holder[i]);
			}
			return reversed;
		}

		//or
			#include <bits/stdc++.h> 
			queue<int> reverseQueue(queue<int> q) {
				stack<int> ans;
				//inserting all elements of q into stack ans.
				while(!q.empty()){
					ans.push(q.front());
					q.pop();
				}

				//reversing queue
				while(!ans.empty()){
					int currentElement = ans.top();
					ans.pop();   
					q.push(currentElement);
				}
				return q;
			}
	
	237) Rightmost different bit:
		Problem statement:
			Given two numbers M and N. 
			The task is to find the position of the rightmost different bit in the binary representation of numbers. 
			If both M and N are the same then return -1 in this case.

			Example 1: 
				Input: 
				M = 11, N = 9
				Output: 
				2
				Explanation: 
				Binary representation of the given numbers are: 1011 and 1001, 2nd bit from right is different.

			Example 2:
				Input: 
				M = 52, N = 4
				Output: 
				5
				Explanation: 
				Binary representation of the given numbers are: 110100 and 0100, 5th-bit from right is different.

			User Task:
				The task is to complete the function posOfRightMostDiffBit() 
				which takes two arguments M and N and returns 
				the position of first different bits in M and N from right. 
				If both m and n are the same then return -1 in this case.

			Expected Time Complexity: O(max(log M, log N)).
			Expected Auxiliary Space: O(1).

			Constraints:
				0 <= M, N <= 109

		class Solution {
			public:
			//Function to find the first position with different bits.
			int posOfRightMostDiffBit(int m, int n) {
				string SM = bitset<32>(m).to_string();
				string SN = bitset<32>(n).to_string();
				
				int cnt=1;
				for(int i=SM.size()-1; i>=0; i--){
					if(SM[i] != SN[i])
						break;
					cnt++;
				}
				
				if(cnt == 33)
					return -1;
				return cnt;
			}
		};

		//or
			class Solution {
				public:
				//Function to find the first position with different bits.
				int posOfRightMostDiffBit(int m, int n) {
					string SM = bitset<32>(m).to_string();
					string SN = bitset<32>(n).to_string();
					
					int cnt=1;
					for(int i=SM.size()-1; i>=0; i--){
						if(SM[i] != SN[i])
							return cnt;
						cnt++;
					}
					return -1;
				}
			};

		//or using XOR operation:
			class Solution {
				public:
				//Function to find the first position with different bits.
				int posOfRightMostDiffBit(int m, int n) {
					int XOR = m ^ n;
					if(XOR == 0)
						return -1;
					
					int pos=1;
					while((XOR & 1) == 0){
						XOR >>= 1;
						pos++;
					}
					return pos;
				}
			};
	
	238) Image Smoother:
		Problem Statement:
			-Average of all surrounding elements.
			An image smoother is a filter of the size 3 x 3 that can be applied 
			to each cell of an image by rounding down the average of the cell and 
			the eight surrounding cells (i.e. the average of the nine cells in the blue smoother). 
			If one or more of the surrounding cells of a cell is not present, 
			we do not consider it in the average (i.e. the average of the four cells in the red smoother).

			Given an m x n integer matrix img representing the grayscale of an image, 
			return the image after applying the smoother on each cell of it.

			Example 1:
				Input: img = [[1,1,1],[1,0,1],[1,1,1]]
				Output: [[0,0,0],[0,0,0],[0,0,0]]
				Explanation:
				For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
				For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
				For the point (1,1): floor(8/9) = floor(0.88888889) = 0

			Example 2:
				Input: img = [[100,200,100],[200,50,200],[100,200,100]]
				Output: [[137,141,137],[141,138,141],[137,141,137]]
				Explanation:
				For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
				For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
				For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
				

			Constraints:
				m == img.length
				n == img[i].length
				1 <= m, n <= 200
				0 <= img[i][j] <= 255
		
		class Solution {
			public:
			vector<vector<int>> imageSmoother(vector<vector<int>>& img) {
				vector<vector<int>> ans (img.size(),vector<int> (img[0].size()));

				for(int row=0; row<img.size(); row++){
					for(int col=0; col<img[0].size(); col++){
						int value = img[row][col];
						int cnt=1;

						//upper side & checking are they present
							int upperRow = row -1;
							if(upperRow<img.size() && upperRow>=0){
							value += img[upperRow][col];
							cnt++;

							int sideR_Upper = col+1, sideL_Upper= col-1;
							if(sideR_Upper>=0 && sideR_Upper < img[0].size()){
								cnt++;
								value += img[upperRow][sideR_Upper];
							}

							if(sideL_Upper>=0 && sideL_Upper < img[0].size()){
								cnt++;
								value += img[upperRow][sideL_Upper];
							}
							}

						//middle both sides
							int midL_col = col-1;
							if(midL_col >=0 && midL_col < img[0].size()){
							cnt++;
							value += img[row][midL_col];
							}

							int midR_col = col+1;
							if(midR_col >=0 && midR_col < img[0].size()){
							cnt++;
							value += img[row][midR_col];
							}

						//lower Side
							int lowerRow= row+1;
							if(lowerRow>=0 && lowerRow<img.size()){
							cnt++;
							value += img[lowerRow][col];

							int sideR_Lower = col+1, sideL_Lower= col-1;
							if(sideR_Lower>=0 && sideR_Lower < img[0].size()){
								cnt++;
								value += img[lowerRow][sideR_Lower];
							}

							if(sideL_Lower>=0 && sideL_Lower < img[0].size()){
								cnt++;
								value += img[lowerRow][sideL_Lower];
							}
							}
			
			
						value /= cnt;
						ans[row][col] = value;
					}
				}
				return ans;
			}
		};
	
	239) Slot Game:
		Problem statement
			You're given a slot machine with four slots where each slot will contain the color
			Red (R), Yellow(Y), Green(G), Blue(B), respectively. You don't know the colors of
			this slot beforehand. You have to guess the colors. When you guess the correct
			color for the correct slot, you get a perfect hit, and you get 2 points, but if you
			guess a color that exists in the machine but is in the wrong slot, you get a
			pseudo hit, and you get 1 point.
			You're given the original string representing the slots' colors and the guess
			string, and your task is to calculate and return the total number of points you
			have scored.
			Note:
				A slot that has been counted as a perfect hit can never count as a pseudo-hit.
			Example:
				Original String = "RGYB" and Guess String = "YGRR".

				The second slot of both the guess and original matches, hence it's a perfect hit.
				The guess string contains yellow, which is also present in the original string but
				not at the same slot as the guess slot. Hence it's a pseudo hit. The guess string
				also contains two red slots, but the original string contains only one red which is
				also not at the same slot as the guess string; hence it is also a pseudo hit.
				Therefore total points will be 2+1+1= 4.

			Constraints:
				1<=T<= 5
				length(original) = length(guess) = 4
				Time limit: 1 sec
			Sample Input 1
				1
				RGBY
				GGRR
				Sample Output 1:
				3
				Explanation of Sample Input 1:
				The second slot of both the string matches. 
				Therefore, it is a perfect hit, and we get 2 points. 
				Our guess string contains the color Red ‘R’ two times, 
				which is also present in the original string but only one time, 
				and it is not in the same slot as the guess slot; 
				hence we get a pseudo hit we get 1 point. 
				Therefore total points will be 2+1=3.

				Sample Input 2:
					1
					RGYB
					YGRR
					Sample Output 2:
					4
					Explanation of Sample Input 2:

					The second slot of both the string matches. Therefore it is a perfect hit, and we get 2 points. 
					Our guess strings also contain the color Yellow ‘Y’, which is also present in the original slot,
					but it is not in the same slot as the guess string; hence we get a pseudo hit, and we get 1 point. 
					Similarly, Our guess strings also contain the color  Red ‘R’ two times, which is also present in the 
					original slot but only once, and it is not in the same slot as the guess string; hence we get a pseudo 
					hit and get 1 point. Hence total points will be 2+1+1=4.

		#include <bits/stdc++.h> 
		int slotScore(string &original, string &guess) {
			int value=0;
			for(int i=0; i<guess.length(); i++){
				if(guess[i] == original[i]){
					original[i] = '0';				//putting something different char (anything) '0' here we kept.
												//than the thing ie. (Z) which is kept in guess.
					guess[i] = 'Z';
					value +=2;
				}
			}


			for(int i=0; i<guess.length(); i++){
				if (find(original.begin(), original.end(), guess[i]) != original.end()) {
					int index = abs(distance(find(original.begin(), original.end(), guess[i]),original.begin()));
					original[index] = '0';
					guess[i] = 'Z';			//putting any random char so for next time they don't get match.
					value++;
				}
			}

			//USE ABOVE FOR LOOP OR BELOW BOTH WORKS.

			// for(int i=0; i<guess.length(); i++){
			// 	for(int j=0; j<original.length(); j++){
			// 		if(guess[i] == original[j]){
			// 			original[j]='0';
			// 			guess[i] = 'Z';
			// 			value++;
			// 			break;
			// 		}
			// 	}
			// }
			return value;
		}

		//Or Another approach:
			#include <bits/stdc++.h> 
			int slotScore(string &original, string &guess) {
				int ans =0;
				
				for(int i=0; i<4; i++){
					if(original[i] == guess[i]){
						original[i] ='0';
						guess[i] = '0';
						ans += 2;
					}
				}

				for(int i=0; i<4; i++){
					if(guess[i] == '0')
						continue;
					else if(original.find(guess[i]) != string::npos){
						original[original.find(guess[i])] = '0';
						ans += 1;
					}
				}
				return ans;
			}

	240) Buy Two Chocolates:
		Problem Statement:
			You are given an integer array prices representing the prices of various chocolates in a store. 
			You are also given a single integer money, which represents your initial amount of money.
			You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. 
			You would like to minimize the sum of the prices of the two chocolates you buy.

			Return the amount of money you will have leftover after buying the two chocolates. 
			If there is no way for you to buy two chocolates without ending up in debt, return money. 
			Note that the leftover must be non-negative.

			Example 1:
				Input: prices = [1,2,2], money = 3
				Output: 0
				Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.

			Example 2:
				Input: prices = [3,2,3], money = 3
				Output: 3
				Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.

			Constraints:
				2 <= prices.length <= 50
				1 <= prices[i] <= 100
				1 <= money <= 100

		class Solution {
			public:
			int buyChoco(vector<int>& prices, int money) {

				sort(prices.begin(), prices.end());

				if((prices[0]+prices[1]) <= money){
					return money-(prices[0]+prices[1]);
				}
				return money;
			}
		};

		//or
			class Solution {
				public:
				int buyChoco(vector<int>& prices, int money) {
					sort(prices.begin(), prices.end());

					if((prices[0]+prices[1]) > money)
						return money;
					return money-(prices[0]+prices[1]);
				}
			};

	241) Maximum Score After Splitting a String:
		Problem Statement:
			Given a string s of zeros and ones, return the maximum score 
			after splitting the string into two non-empty substrings (i.e. left substring and right substring).
			The score after splitting a string is the number of zeros in the left substring plus 
			the number of ones in the right substring.

			Example 1:
				Input: s = "011101"
				Output: 5 
				Explanation: 
				All possible ways of splitting s into two non-empty substrings are:
				left = "0" and right = "11101", score = 1 + 4 = 5 
				left = "01" and right = "1101", score = 1 + 3 = 4 
				left = "011" and right = "101", score = 1 + 2 = 3 
				left = "0111" and right = "01", score = 1 + 1 = 2 
				left = "01110" and right = "1", score = 2 + 1 = 3

			Example 2:
				Input: s = "00111"
				Output: 5
				Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5

			Example 3:
				Input: s = "1111"
				Output: 3

			Constraints:
				2 <= s.length <= 500
				The string s consists of characters '0' and '1' only.

		class Solution {
			public:
			int maxScore(string s) {
				int mxScore=0;
				for(int i=1; i<s.length(); i++){
					string left = s.substr(0,i);
					string right = s.substr(i);

					//counting no.of zero in left string
					int leftScore=0;
					for(int a=0; a<left.length(); a++){
						if(left[a] == '0')
							leftScore++;
					}

					int rightScore=0;
					//counting no.of ones in right string
					for(int a=0; a<right.length(); a++){
						if(right[a] == '1')
							rightScore++;
					}
					mxScore = max(mxScore, (rightScore+leftScore));
				}
				return mxScore;
			}
		};		
		
	242) Maximize xor:
		Problem statement
			You have an integer array 'A' of the form of [x, x+1, x+2, x+3, ......]. As the array is
			vast in size, you are given both endpoints of the array, i.e., If you are given two
			integers, 'L' and 'R', the array 'A' will be [L, L+1, L+2,...... R-1, R]. Your task is to
			find the maximum possible value of 'X' such that the following two conditions hold.
			a ⊕ b= X, where '⊕' denotes bitwise xor operation.
			Both numbers 'a' and 'b' belong to the array 'A:
			Constraints -
				1 <= 'T' <= 10^3
				1 <= L <= R <= 10^9
				Time Limit: 1 sec

			Sample Input 1 :
				2
				8 20
				1 3
				Sample Output 1 :
				31
				3
				Explanation for Sample Input 1 :
				For case 1:
				The array looks like [8, 9, 10, ….., 18, 19, 20]. 
				From all possible pairs (a, b), pair (15, 16) gives maximum value of xor, which is 15 ⊕ 16 = 31.

				For Case 2:
				Optimal pair is (2, 3), which gives 2 ⊕ 3 = 3.
				Sample Input 2 :
				2
				4 10
				4 7
				Sample Output 2 :
				15
				3

		//Not Optimized:
			#include <bits/stdc++.h> 
			int maxXor(int L, int R){
				vector<int> holder;
				for(int i=L; i<=R; i++){
					holder.push_back(i);
				}

				int mxXOR=0;
				for(int i=0; i<holder.size()-1; i++){
					int temp=0;
					for(int j=i+1; j<holder.size(); j++){
						temp = holder[i] ^ holder[j];
						mxXOR = max(mxXOR, temp);
					}
				}
				return mxXOR;
			}

		// or
			#include <bits/stdc++.h> 
			int maxXor(int L, int R) {
				int mx=0;
				for(int i=L; i<R; i++){
					for(int j=i+1; j<=R; j++){
						mx = max(mx, i^j);
					}
				}
				return mx;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int maxXor(int L, int R){
				int lxr = L ^ R;
				int msbpos = 0;

				while (lxr > 0) {
					msbpos++;
					lxr >>= 1;
				}

				int maxor = 0;
				int two = 1;
				while (msbpos-- > 0) {
					maxor += two;
					two <<= 1;
				}
				return maxor;
			}

	243) Count More than n/k Occurences:
		Problem Statement:
			Given an array arr of size N and an element k. 
			The task is to find the count of elements in the array that appear more than n/k times.
			Example 1:
				Input:
				N = 8
				arr = [3,1,2,2,1,2,3,3]
				k = 4
				Output: 
				2
				Explanation: 
				In the given array, 3 and 2 are the only elements that appears more than n/k times.

			Example 2:
				Input:
				N = 4
				arr = [2,3,3,2]
				k = 3
				Output: 
				2
				Explanation: In the given array, 3 and 2 are the only elements that appears more than n/k times. So the count of elements are 2.

			Your Task:
				The task is to complete the function countOccurence() 
				which returns count of elements with more than n/k times appearance.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(N).

			Constraints:
				1 <= N <= 10^5
				1 <= a[i] <= 10^9
				1 <= k <= N

		class Solution {
			public:
			//Function to find all elements in array that appear more than n/k times.
			int countOccurence(int arr[], int n, int k) {
				int times = n/k;
				map<int, int> FreqCounter;
				
				//Frequency counter
				for(int i=0; i<n; i++){
					FreqCounter[arr[i]]++;
				}
				
				int cnt=0;
				
				// checking if the element is appear more than n/k times
				for(auto z: FreqCounter)
					if(z.second > times)
						cnt++;
				
				//returning the result
				return cnt;
			}
		};

	244) Path Crossing:
		Problem Statement:
			Given a string path, where path[i] = 'N', 'S', 'E' or 'W', 
			each representing moving one unit north, south, east, or west, respectively. 
			You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.
			Return true if the path crosses itself at any point, that is, 
			if at any time you are on a location you have previously visited. Return false otherwise.

			Example 1:
				Input: path = "NES"
				Output: false 
				Explanation: Notice that the path doesn't cross any point more than once.

			Example 2:
				Input: path = "NESWW"
				Output: true
				Explanation: Notice that the path visits the origin twice.
		
			Constraints:
				1 <= path.length <= 10^4
				path[i] is either 'N', 'S', 'E', or 'W'.
		
		class Solution {
			public:
			bool isPathCrossing(string path) {
				int x=0, y=0;
				vector<string> storer;
				string temp = to_string(x) + "," + to_string(y);
				storer.push_back(temp);
				for(int i=0; i<path.length(); i++){
					switch(path[i]){
						case 'N':
							y++;
							break;
						case 'E':
							x++;
							break;
						case 'W':
							x--;
							break;
						case 'S':
							y--;
							break;
					}
					temp = to_string(x) + "," + to_string(y);
					if(find(storer.begin(), storer.end(), temp) != storer.end())				//finding that if we stored temp points previously
						return 1;														//if yes, returning true.
					storer.push_back(temp);
				}
				return 0;
			}
		};

	245) Minimum Changes To Make Alternating Binary String:
		Problem Statement:
			You are given a string s consisting only of the characters '0' and '1'. 
			In one operation, you can change any '0' to '1' or vice versa.
			The string is called alternating if no two adjacent characters are equal. 
			For example, the string "010" is alternating, while the string "0100" is not.
			Return the minimum number of operations needed to make s alternating.

			Example 1:
				Input: s = "0100"
				Output: 1
				Explanation: If you change the last character to '1', s will be "0101", which is alternating.

			Example 2:
				Input: s = "10"
				Output: 0
				Explanation: s is already alternating.

			Example 3:
				Input: s = "1111"
				Output: 2
				Explanation: You need two operations to reach "0101" or "1010".
				
			Constraints:
				1 <= s.length <= 104
				s[i] is either '0' or '1'.
 
		class Solution {
			public:
			int minOperations(string s) {
				int cnt=0;
				//for 0
				char ch = '0';
				for(int i=0; i<s.length(); i++){
					if(s[i] != ch)
						cnt++;

					//This will alter the char, if previously it was '0', then it'll become '1' & viceversa.
					(ch == '1') ? ch = '0' : ch = '1';
				}

				//for 1
				ch = '1';
				int cnt2=0;
				for(int i=0; i<s.length(); i++){
					if(s[i] != ch)
						cnt2++;
					
					//This will alter the char, if previously it was '0', then it'll become '1' & viceversa.
					(ch == '1') ? ch = '0' : ch = '1';
				}
				return min(cnt, cnt2);
			}
		};

	246) Meta Strings:
		Problem statement
			You are given two strings 'STR1' and 'STR2'. You need to tell whether the strings
			are meta strings or not.
			Meta strings are strings that can be made equal by swapping exactly one pair of
			distinct characters in one of the strings.
			Note:
			Equal strings are not considered as meta strings.
			Constraints:
				1 <= T <= 10
				2 <= length of STR1<= 10 ^ 5
				2 <= length of STR2 <= 10 ^ 5

		Sample Input 1:
			2
			Coding
			Codnig
			Ninjas
			Niaxns
			Sample Output 1:
			YES
			NO
			Explanation for Input 1:
			For test case 1: By swapping ‘i’ and ‘n’ in the second string, it becomes equal to the first string.

			For test case 2: There is no way we can make both the strings equals by swapping one pair of characters.
			Sample Input 2:
			3
			Hello
			Hello
			Play
			Playes
			Seek
			Seke
			Sample Output 2:
			NO
			NO
			YES
		#include <bits/stdc++.h> 
		bool checkMeta(string &str1, string &str2) {
			if(str1.length() != str2.size() || str1 == str2)
				return 0;
			
			vector<int> holder;
			for(int i=0; i<str2.length(); i++){
				if(str1[i] != str2[i])
					holder.push_back(i);
			}

			if(holder.size()<2)             //this statement means that we didn't found 2 indexes where elements are different.
				return 0;

			swap(str2[holder[0]],str2[holder[1]]);
			if(str2 == str1)
				return 1;
			return 0;
		}
		
		//or
			#include <bits/stdc++.h> 
			bool checkMeta(string &str1, string &str2) {
				if(str1.length() != str2.size() || str1 == str2)
					return 0;
				
				sort(str1.begin(), str1.end());
				sort(str2.begin(), str2.end());
				
				if(str1 == str2)
					return 1;
					
				return 0;
			}

	247) Minimum Time to Make Rope Colorful:
		Problem Statement:
			Alice has n balloons arranged on a rope. 
			You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.
			Alice wants the rope to be colorful. 
			She does not want two consecutive balloons to be of the same color, so she asks Bob for help. 
			Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed 
			integer array neededTime where neededTime[i] is 
			the time (in seconds) that Bob needs to remove the ith balloon from the rope.
			Return the minimum time Bob needs to make the rope colorful.
			Example 1:
				Input: colors = "abaac", neededTime = [1,2,3,4,5]
				Output: 3
				Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
				Bob can remove the blue balloon at index 2. This takes 3 seconds.
				There are no longer two consecutive balloons of the same color. Total time = 3.
				
			Example 2:
				Input: colors = "abc", neededTime = [1,2,3]
				Output: 0
				Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.

			Example 3:
				Input: colors = "aabaa", neededTime = [1,2,3,4,1]
				Output: 2
				Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.
				There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.

			Constraints:
				n == colors.length == neededTime.length
				1 <= n <= 105
				1 <= neededTime[i] <= 104
				colors contains only lowercase English letters.
		
		class Solution {
			public:
			int minCost(string colors, vector<int>& neededTime) {
				int minCNT=0;
				int tracker=1;
				for(int i=0; i<colors.length()-1;){
					if(colors[i] == colors[tracker]){
						if(neededTime[i]>neededTime[tracker]){
							minCNT += neededTime[tracker];
						}else{
							minCNT += neededTime[i];
							i = tracker;
						}
						tracker++;
					}else{
						i = tracker;
						tracker++;
					}
				}
				return minCNT;
			}
		};

	248) Anti Diagonal Traversal of Matrix:
		Problem Statement:
			Give a N*N square matrix, return an array of its anti-diagonals in top-leftmost 
			to bottom-rightmost order. In an element of a anti-diagonal (i, j), 
			surrounding elements will be (i+1, j-1) and (i-1, j+1). Look at the examples for more clarity.

			Example 1:
			Input:
			N = 2
			matrix[][] = 1 2
					3 4
			Output:
			1 2 3 4
			Explanation:
			List of anti-diagnoals in order is
			{1}, {2, 3}, {4}

			Example 2:
			Input:
			N = 3
			matrix[][] = 3 2 3
					4 5 1
					7 8 9
			Output:
			3 2 4 3 5 7 1 8 9
			Explanation:
			List of anti-diagnoals in order is
			{3}, {2, 4}, {3, 5, 7}, {1, 8}, {9}

			Your Task:
				You dont need to read input or print anything. 
				Complete the function antiDiagonalPattern() that takes matrix as 
				input parameter and returns a list of integers in order of the values visited in the anti-Diagonal pattern. 

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(N * N)

			Constraints:
				1 <= N <= 100
				0 <= mat[i][j] <= 100

		class Solution {
			public:
			vector<int> antiDiagonalPattern(vector<vector<int>> matrix) {
				vector<int> ans;
				int totalRows = matrix.size() + matrix.size() - 1;
				int i=0;
				while(i<matrix.size()){
					int row = 0, col=i;
					
					while(row<matrix.size() && col >=0 ){
						ans.push_back(matrix[row][col]);
						row++;
						col--;
					}
					i++;
				}
				
				
				int StandingOnRow = 1;
				while(i<totalRows){
					int col= matrix.size()-1;
					int row = StandingOnRow;
					while(col>=0 && row < matrix.size()){
						ans.push_back(matrix[row][col]);
						row++;
						col--;
					}
					StandingOnRow++;
					i++;
				}
				return ans;
			}
		};

	249) Dominant Number
		Problem statement
			You are given an array of integers 'ARR' of size N. Your task is to find the
			dominant number in the array.
			A dominant number in an array is an integer that occurs more than N/3 times in
			the array, where N is the array's length.
			Note:
				1. There will be only one such element (if it exists).
				2. If there is no such element in the array, return - 1.
			For Example:
				If the given array ARR = (3,3,3,1,5,6,3} we can see that here 3 occurs 4 times in
				the array, which is greater than 7/3(N/3), so the dominant number here is 3.
			Note:
				Try to solve the problem in linear time complexity
			Constraints:
				1 <= T <= 100
				1 <= N<= 10^4
				0 ≤ ARR[I] ≤ 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				3
				6
				3 1 1 8 1 2
				3
				1 2 4
				4
				3 2 1 3
				Sample Output 1 :
				1
				-1
				3
				Explanation of The Sample Input 1:
				For the first test case:
				The given array is {3,1,1,8,1,2} we can see that 3 occurred three times in the array, 
				which is greater than 6/3, so the dominant number will be 3. 

				For the second test case:
				The given array is {1,2,4} we can see that no number here is repeated more than once, 
				so the answer here will be -1.

				For the third test case
				The given array is {3,2,1,3} we can see that  3 occurred two times in the array, 
				which is greater than 4/3, so the dominant number will be 3. 
				Sample Input 2 :
				3
				4
				4 4 4 1
				7
				5 6 6 4 3 2 6
				8
				1 9 8 4 5 5 5 5
				Sample Output 2 :
				4
				6
				5

		#include <bits/stdc++.h> 
		int dominantNumber(int* arr, int n) {
			map<int, int> FreqCounter;
			for(int i=0; i<n; i++){
				FreqCounter[arr[i]]++;
			}
			for(auto ele: FreqCounter){
				if(ele.second > (n/3))
					return ele.first;
			}
			return -1;
		}

	250) Minimum Distance Between Two Numbers:
		Problem statement
			You’re given an array of 'N' integers, and two integers 'X' and 'Y'. 
			Your task is to find the minimum distance between 'X' and 'Y' in the array. 
			If either or both of them are not present in the array then return -1.

			NOTE :
				1. The array might also contain duplicates. 
				2. It is guaranteed that 'X' and 'Y' are two distinct integers i.e. 'X' is not equal to 'Y'.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^5
				0 <= X, Y <= 10^9
				0 <= ARR[i] <= 10^9
			Where 'T' denotes the number of test cases, 
			'N' denotes the number of elements in the array ‘ARR’ respectively, 
			'X' and 'Y' denotes the integer given in the input, and 'ARR[i]' denotes the 'i-th' element of the array 'ARR'. 

			Time Limit : 1 sec
			Sample Input 1 :
				1
				3 3 5
				3 4 5
				Sample Output 1 :
				2
				Explanation of Sample Input 1 :
				As 3 is at the first position and 5 is at third position. Hence, the minimum distance between 3 and 5 is 2.
				Sample Input 2 :
				2
				4 1 2
				1 2 3 2
				4 2 3
				4 5 6 7
				Sample Output 2 :
				1
				-1
				Explanation of Sample Input 2 :
				There are two distances between 1 and 2, which are 1 and 3. Out of these two, 1 is the minimum distance.
				We return -1 as X = 2 and Y = 3 doesn’t exist in our array. 

		#include <bits/stdc++.h> 
		int minimumDistance(int arr[], int n, int x, int y) {
			vector<int> indexesOfX;
			vector<int> indexesOfY;

			for(int i=0; i<n; i++){
				if(arr[i] == x)
					indexesOfX.push_back(i);
				else if(arr[i] == y)
					indexesOfY.push_back(i);
			}

			if(indexesOfX.size()==0 || indexesOfY.size() == 0)
				return -1;

			int dist=INT_MAX;

			for(int i=0; i<indexesOfX.size(); i++){
				for(int j=0; j<indexesOfY.size(); j++){
					dist = min(dist,abs(indexesOfY[j]-indexesOfX[i]));
				}
			}
			return dist;
		}

	251) Winner of an election:
		Problem statement:
			Given an array of n names arr of candidates in an election, where each name is a string of lowercase characters. 
			A candidate name in the array represents a vote casted to the candidate. 
			Print the name of the candidate that received the maximum count of votes. 
			If there is a draw between two candidates, then print lexicographically smaller name.
			Example 1:
				Input:
				n = 13
				arr[] = {john,johnny,jackie,johnny,john,jackie,jamie,jamie,john,johnny,jamie,
				johnny,john}
				Output: john 4
				Explanation: john has 4 votes casted for 
				him, but so does johny. john is 
				lexicographically smaller, so we print 
				john and the votes he received.

			Example 2:
				Input:
				n = 3
				arr[] = {andy,blake,clark}
				Output: andy 1
				Explanation: All the candidates get 1 
				votes each. We print andy as it is 
				lexicographically smaller.
			Your Task:
			You only need to complete the function winner() that takes an 
			array of strings arr, and length of arr n as parameters and 
			returns an array of string of length 2. 
			First element of the array should be the name of the candidate 
			and second element should be the number of votes that candidate got in string format.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 <= n <= 10^5
				1 <= |arr[i]| <= 10^5

		class Solution{
			public:
			
			//Function to return the name of candidate that received maximum votes.
			vector<string> winner(string arr[],int n) {
				map<string, int> FreqCounter;
				for(int i=0; i<n; i++){
					FreqCounter[arr[i]]++;
				}
				
				vector<int> storer;
				for(auto i: FreqCounter){
					storer.push_back(i.second);
				}
				
				int maxVotes = *max_element(storer.begin(), storer.end());
				vector<string> namesHolder;
				
				for(auto i: FreqCounter){
					if(maxVotes == i.second)
						namesHolder.push_back(i.first);
				}
				
				//sorting string namesHolder vector but here no need of sorting you can comment.
				sort(begin(namesHolder), end(namesHolder));
				return {namesHolder[0],to_string(maxVotes)};
			}
		};

		//or
		class Solution{
			public:
			//Function to return the name of candidate that received maximum votes.
			vector<string> winner(string arr[],int n) {
				vector<string> ans;
				map<string, int> mp;
				for(int i=0; i<n; i++){
					mp[arr[i]]++;
				}
				
				//maximum extracting
				int max = 0;
				string s="";
				for(auto i: mp){
					if(i.second > max){
						max = i.second;
						s = i.first;
					}
				}

				return {s,to_string(max)};
			}
		};

	252) Redistribute Characters to Make All Strings Equal:
		Problem Statement:
			You are given an array of strings words (0-indexed).
			In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, 
			and move any character from words[i] to any position in words[j].
			Return true if you can make every string in words equal using any number of operations, 
			and false otherwise.

			Example 1:
				Input: words = ["abc","aabc","bc"]
				Output: true
				Explanation: Move the first 'a' in words[1] to the front of words[2],
				to make words[1] = "abc" and words[2] = "abc".
				All the strings are now equal to "abc", so return true.

			Example 2:
				Input: words = ["ab","a"]
				Output: false
				Explanation: It is impossible to make all the strings equal using the operation.
			Constraints:
				1 <= words.length <= 100
				1 <= words[i].length <= 100
				words[i] consists of lowercase English letters.

		class Solution {
			public:
			bool makeEqual(vector<string>& words) {
				int noOfWords = words.size();
				//if there is only one word, then the answer is always yes.
				//if you want then you can un-comment below 2 lines it will reduce the time complexity
				
				// if(noOfWords == 1)
				//     return 1;

				// need to count character in each word
				map<char, int> charsFreq;
				
				for(int i=0; i<noOfWords; i++){
					string crntString = words[i];
					for(int j=0; j<crntString.length(); j++){
						charsFreq[crntString[j]]++;
					}
				}

				for(auto i: charsFreq){
					if(i.second % noOfWords != 0)
						return 0;
				}
				return 1;
			}
		};

	253) Look & Say Sequence:
		Problem statement
			You have been given a positive integer N. Your task is to find the Nth term of the Look-And-Say sequence.
			The Look-And-Say sequence is a sequence of positive integers. The sequence is as follows:
				1, 11, 21, 1211, 111221, 312211, 13112221,...
			This sequence is constructed in the following way:
				The first number is 1.
				This is read as “One 1”. 
				Hence, the second number will be 11.
				The second number is read as “Two 1s”. 
				Hence, the third number will be 21.
				The third number is read as “One 2, One 1”. 
				Hence, the fourth number will be 1211.
				The fourth term is read as “One 1, One 2, Two 1s”.
				Hence, the fifth term will be 111221. And so on.

			Constraints:
				1 <= T <= 100
				1 <= N <= 40
		
				Time Limit: 1 sec
			Sample Input 1:
				3
				1
				2
				3
				Sample Output 1:
				1
				11
				21
				Explanation for Sample 1:
				The first term is 1.
				The second term is 11.
				The third term is 21.
				Sample Input 2:
				1
				6
				Sample Output 2:
				312211

		#include <bits/stdc++.h> 
		string lookAndSaySequence(int n) {
			//setting first term manually
			vector<string> storer = {"1"};

			for(int i=1; i<=n; i++){
				string last = storer[i-1];
				int cnt=1;

				string ans;
				for(int a=1; a<last.length(); a++){
					if(last[a] == last[a-1])
						cnt++;
					else{
						ans += to_string(cnt)+last[a-1];
						cnt=1;
					}
				}
				
				//need to insert the last char manually
				ans += to_string(cnt)+last[last.size()-1];

				storer.push_back(ans);
			}
			return storer[n-1];
		}

		// Or:
			#include <bits/stdc++.h> 
			string lookAndSaySequence(int n) {
				vector<string> v = {"1"};

				while(v.size() < n){
					string cur = v.back();
					string temp;

					int cnt =1, i;
					for(i=0; i<cur.size()-1; i++){
						if(cur[i] == cur[i+1])
							cnt++;
						else{
							temp += to_string(cnt);
							temp += cur[i];
							cnt=1;
						}
					}

					//inserting last cnt mannually
					temp += to_string(cnt);
					temp += cur[i];

					v.push_back(temp);
				}
				return v.back();
			}

	254) Ninja And The Game Of Words:
		Problem statement
			Ninja and his friend playing a game in which his friend gave him a string ‘STR’ 
			that can contain spaces and a List/Array ‘WORDS’ which is of type string containing ‘N’ strings of words. 
			Ninja’s task is to count the occurrences of all the words in ‘STR’.
			For Example:
			‘STR’ = “i am a Ninja”, ‘N’ = 3 and ‘WORDS[]’ = [“Ninja”,”a”,”am”]. 
			Then the output should be [1,1,1]. 
			Because the occurrence of “Ninja” in ‘STR’ is 1 and the occurrence of “a” in ‘STR’ is 1.
			Similarly occurrence of “am” is 1.
			Note:
				The output should be in the same order as given in ‘WORDS’.
				Can you help Ninja to generate all valid strings from ‘STR’ by minimum removals?

			Constraints:
				1 <= ‘T’ <= 100
				1 <= |STR| <= 4000
				1<= N <= 4000
				1<= |WORDS[i]| <= 4000
			Where  |'STR'| denotes the length of the given string and ‘|WORDS[i]|’ denotes the length of the string word.
			Time limit: 1 sec
			Sample Input 1:
				2
				2
				Hi i am ninja and i love coding
				ninja
				m  
				5
				Hey ninja ! How are you ?
				Hey  
				ninja
				Ninja 
				How 
				yo
				Sample Output 1:
				1 0
				1 1 0 1 0
				Explanation for Sample Output 1:
				For the first test case : 
				1. There is only one occurrence of “ninja” in ‘STR’= “Hi i am ninja and i love coding”.
				2. There is no occurrence of “m” in ‘STR’ = “Hi i am ninja and i love coding”.

				For the second test case:
				1. There is 1 occurrence of “Hey” in given ‘STR’ = “Hey ninja ! How are you ?”
				2. There is 1 occurrence of “ninja” in given ‘STR’ = “Hey ninja ! How are you ?”
				3. There is 0 occurrence of “Ninja” in given ‘STR’ = “Hey ninja ! How are you ?”
				4. There is 1 occurrence of “How” in given ‘STR’ = “Hey ninja ! How are you ?”
				5. There are 0 occurrences of “yo” in given ‘STR’ = “Hey ninja ! How are you ?”
				Sample Input 2:
				2
				2
				the Ninja always wins the game of coding
				nja 
				the
				3
				Hey There I am enjoying algorithms
				HEY
				A
				There
				Sample Output 2:
				0 2 
				2 0 1
				Explanation for Sample Output 2:
				For the first test case : 
				1. There is no occurrence of “nja” in ‘STR’= “the Ninja always wins the game of coding”.
				2. There is 2 occurrences of “the” in ‘STR’ = “the Ninja always wins the game of coding”.

				For the second test case:
				1. There are 2 occurrences of “Hey” in given ‘STR’ = “Hey There I am enjoying algorithms”
				2.There are 0 occurrences of “A” in given ‘STR’ = “Hey There I am enjoying algorithms”
				3. There is 1 occurrence of “There” in given ‘STR’ = “Hey There I am enjoying algorithms”

		--1 failing:
			#include <bits/stdc++.h> 
			vector<int> getFrequency(string& str, vector<string>& words, int n) {
				vector<int> ans;
				
				vector<string> sentenceWords;
				string s;

				for(int i=0; i<str.length(); i++){
					if(str[i] == ' '){
						sentenceWords.push_back(s);
						s.clear();
					}
					else
						s += str[i];
				}

				//need to push last word manually
				sentenceWords.push_back(s);

				for(int i=0; i<words.size(); i++){
					int cnt=0;
					for(int j=0; j<sentenceWords.size(); j++){
						if(words[i] == sentenceWords[j])
							cnt++;
					}
					ans.push_back(cnt);
				}
				return ans;
			}
	
		#include <bits/stdc++.h> 
		vector<int> getFrequency(string& str, vector<string>& words, int n) {
			vector<int> ans;

			vector<string> sentenceWords;
			string s;

			istringstream iss(str);
				
			while (iss >> s) {
				sentenceWords.push_back(s);
			}

			for (int i = 0; i < words.size(); i++) {
				int cnt = 0;
				for (int j = 0; j < sentenceWords.size(); j++) {
					if (words[i] == sentenceWords[j]) {
						cnt++;
					}
				}
				ans.push_back(cnt);
			}
			return ans;
		}
		
	255) Largest Substring Between Two Equal Characters:
		Problem statement:
			Given a string s, return the length of the longest substring between two equal characters, 
			excluding the two characters. 
			If there is no such substring return -1.
			A substring is a contiguous sequence of characters within a string.
			Example 1:
				Input: s = "aa"
				Output: 0
				Explanation: The optimal substring here is an empty substring between the two 'a's.

			Example 2:
				Input: s = "abca"
				Output: 2
				Explanation: The optimal substring here is "bc".

			Example 3:
				Input: s = "cbzxy"
				Output: -1
				Explanation: There are no characters that appear twice in s.

			Constraints:
				1 <= s.length <= 300
				s contains only lowercase English letters.

		class Solution {
			public:
			int maxLengthBetweenEqualCharacters(string s) {
				int start=0, end=s.length()-1;
				int mx = -1;

				while(start < end ){
					for(int i= end; i>start; i--){
						if(s[start] == s[i]){
							mx = max(mx, (i-start-1));
							break;
						}
					}
					start++;
				}
				return mx;
			}
		};

		//or
			class Solution {
				public:
				int maxLengthBetweenEqualCharacters(string s) {
					int ans=-1;
					for(int left=0; left<s.length()-1; left++)
						for(int right=left+1; right<s.length(); right++)
							if(s[left] == s[right])
								ans = max(ans, (right-left-1));

					return ans;
				}
			};
		
	256) Sort a Stack: ❌Pending
		Problem statement
			You’re given a stack consisting of 'N' integers. 
			Your task is to sort this stack in descending order using recursion.
			We can only use the following functions on this stack S.
			is_empty(S) : Tests whether stack is empty or not.
			push(S) : Adds a new element to the stack.
			pop(S) : Removes top element from the stack.
			top(S) : Returns value of the top element. Note that this function does not remove elements from the stack.
			Note :
			1) Use of any loop constructs like while, for..etc is not allowed. 
			2) The stack may contain duplicate integers.
			3) The stack may contain any integer i.e it may either be negative, positive or zero.
			Constraints:
				1 <= 'T' <= 100
				1 <=  'N' <= 100
				1 <= |'V'| <= 10^9

			Where |V| denotes the absolute value of any stack element.
			Time limit: 1 sec
			Sample Input 1:
				1
				5
				5 -2 9 -7 3
				Sample Output 1:
				9 5 3 -2 -7
				Explanation of Sample Input 1:
				9 Is the largest element, hence it’s present at the top. Similarly 5>3, 3>-2 and -7 being the smallest element is present at the last. 
				Sample Input 2:
				1
				5
				-3 14 18 -5 30
				Sample Output 2:
				30 18 14 -3 -5
				Explanation of Sample Input 2:
				30 is the largest element, hence it’s present at the top. Similarly, 18>14, 14>-3 and -5 being the smallest element is present at the last. 
	
		#include <bits/stdc++.h> 
		void sortStack(stack<int> &stack) {
			vector<int> holder;
			while(!stack.empty()){
				holder.push_back(stack.top());
				stack.pop();
			}
			sort(holder.begin(), holder.end());

			for(int i=0; i<holder.size(); i++){
				stack.push(holder[i]);
			}
		}

		//Using Recursion:
	
	257) Array Pair Sum Divisibility Problem:
		Problem Statement:
			Given an array of integers nums and a number k, 
			write a function that returns true if given array 
			can be divided into pairs such that sum of every pair is divisible by k.

			Example 1 :
				Input : 
				nums = [9, 5, 7, 3]
				k = 6
				Output: 
				True
				Explanation: 
				{(9, 3), (5, 7)} is a 
				possible solution. 9 + 3 = 12 is divisible
				by 6 and 7 + 5 = 12 is also divisible by 6.

			Example 2:
				Input : 
				nums = [4, 4, 4]
				k = 4
				Output: 
				False
				Explanation: 
				You can make 1 pair at max, leaving a single 4 unpaired.
				Your Task:
				You don't need to read or print anything. 
				Your task is to complete the function canPair() which takes array nums and k 
				as input parameter and returns true if array can be divided into pairs 
				such that sum of every pair is divisible by k otherwise returns false.

			Expected Time Complexity: O(n)
			Expected Space Complexity : O(n)

			Constraints:
				1 <= length( nums ) <= 10^5
				1 <= nums[i] <= 10^5
				1 <= k <= 10^5

		class Solution {
			public:
			bool canPair(vector<int> nums, int k) {
				
				//if length of array is odd, then we can't make the pair
				if(nums.size() & 1)
					return 0;
					
				//checking every pair now
				for(int i=0; i<nums.size()-1; i++){
					if(nums[i] == 0)
							continue;
					int flg = 1;
					for(int j=i+1; j<nums.size(); j++){
						if(nums[j] == 0)
							continue;
						
						if((nums[i]+nums[j]) % k == 0){
							nums[i] = 0;
							nums[j] = 0;
							flg = 0;
							break;
						}
					}
					
					if(flg)
						return 0;
				}
				return 1;
			}
		};
	
	258) Assign Cookies:
		Problem Statement:
			Assume you are an awesome parent and want to give your children some cookies. 
			But, you should give each child at most one cookie.
			Each child i has a greed factor g[i], which is the minimum size of a cookie that 
			the child will be content with; and each cookie j has a size s[j]. 
			If s[j] >= g[i], we can assign the cookie j to the child i, 
			and the child i will be content. Your goal is to maximize the number of your content children 
			and output the maximum number.

			Example 1:
				Input: g = [1,2,3], s = [1,1]
				Output: 1
				Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
				And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
				You need to output 1.

			Example 2:
				Input: g = [1,2], s = [1,2,3]
				Output: 2
				Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
				You have 3 cookies and their sizes are big enough to gratify all of the children, 
				You need to output 2.

			Constraints:
				1 <= g.length <= 3 * 104
				0 <= s.length <= 3 * 104
				1 <= g[i], s[j] <= 231 - 1

		class Solution {
			public:
			int findContentChildren(vector<int>& g, vector<int>& s) {
				int satisfied=0;
				sort(g.begin(), g.end());
				sort(s.begin(), s.end());

				for(int i=0; i<s.size(); i++){
					for(int j=0; j<g.size(); j++){
						if(g[j] == 0)
							continue;
						
						if(s[i] >= g[j]){
							s[i] = g[j] = 0;
							satisfied++;
							break;
						}
					}
				}
				return satisfied;
			}
		};
	
	259) Check Even Partitioning:
		• Any odd number cannot be represented by sum of even numbers
		• Any even number can be represented by sum of even numbers (except 2
		Problem statement
			You are given a positive integer ‘N’. 
			You have to check whether ‘N’ can be represented as a sum of two even numbers or not.

			For example:
				If the given number is 6, The number 6 can be represented as 2 + 4, 
				and both 2 and 4 are even numbers. Hence the answer is “YES”.

			Constraints:
				1 <= T <= 10
				1 <= N <= 10^9
				Time limit: 1 sec
			Sample Input 1:
				2
				16
				11
				Sample Output 1:
				YES
				NO
				Explanation of sample input 1:
				For the first test case, 
				The number 16 can be represented as 10 + 6, and both 10 and 6 are even numbers. Hence the answer is “YES”.

				For the second test case,
				The number 11 cannot be represented as a sum of two even numbers. Hence the answer is “NO”.
				Sample Input 2:
				2
				44
				2
				Sample Output 2:
				YES
				NO

		#include <bits/stdc++.h> 
		bool checkEvenPartitioning(int n) {
			if((n != 2) && (n%2 == 0))				//if(n != 2 && n%2 == 0)
				return 1;
			return 0;
		}

		//or you can use 'and' keyword also
		#include <bits/stdc++.h> 
		bool checkEvenPartitioning(int n) {
			if(n != 2 and n%2 == 0)
				return 1;
			return 0;
		}
	
	260) Copy Bits in Range:
		Problem statement
			Ninja is learning the binary representation and bit manipulation. 
			He found an interesting question but had no hints on how to solve it. 
			The question statement says two numbers, ‘A’ and ‘B’ are given, and a range ‘X’ to ‘Y’ is given. 
			You have to copy the set bits of ‘A’ in the range ‘X’ to ‘Y’ in ‘B’ and print the modified value of ‘B’.
			Can you help Ninja in solving this problem?
			For Example
				If ‘A’ is 13(1101) and ‘B’ is 7(0111), and the range is 2 to 4. 
				So, we will copy the set bits in the range 2 to 4 from the left. 
				The set bits in this range are the 3rd bit and the 4th bit. 
				So, we will copy these bits to ‘B’.Now, the modified B will be 15(1111) as we copied the 4th bit. 
			Constraints:
				1 <= T <= 10
				1 <= ‘A’,’B’ <= 10^9.
				1 <= ‘X’,’Y’ <= 30.

			Time limit: 1 sec
			Sample Input 1:
				2
				13 7 2 4
				10 18 2 3
				Sample Output 1:
				15
				18
				Explanation of sample input 1:
				For the first test case,

				The binary representation of 13 is 1101.
				The binary representation of 7 is 0111.
				So, the set bits of ‘A’ in the given range are the 3rd bit and the 4th bit.
				So, we will copy these set bits in ‘B’.B will become 15(1111).
				Hence, the answer is 15.

				For the second test case:

				The binary representation of 10 is 01010.
				The binary representation of 18 is 10010.
				So, the set bits of ‘A’ in the given range is the 2nd bit only.
				So, we will copy these set bits in ‘B’.B will become 18(10010).
				Hence, the answer is 18.
				Sample Input 2:
				2
				6 19 1 3
				3 2 2 4
				Sample Output 2:
				23
				2

		#include <bits/stdc++.h> 
		int copyBitsInRange(int a, int b, int x, int y) {
			string sA = bitset<32>(a).to_string();
			string sB = bitset<32>(b).to_string();

			int changeBits = 0;
			int start = sA.length() - x ;
			int end = sA.length() - y;

			for(int fromLast= end; fromLast <= start; fromLast++)       //or for(int fromLast= start; fromLast >= end; fromLast--)
				if(sA[fromLast] == '1')
					sB[fromLast] = '1';

			return stoi(sB, 0, 2);				//to convert back from binary to decimal that's why kept 2 (represent the currently num in binary) as parameter.
		}	

	261) Largest Sum Subarray of Size at least K: ❌Pending
		Problem Statement:
			Given an array a of length n and a number k, 
			find the largest sum of the subarray containing at least k numbers. 
			It is guaranteed that the size of array is at-least k.

			Example 1:
				Input : 
				n = 4
				a[] = {-4, -2, 1, -3}
				k = 2
				Output : 
				-1
				Explanation :
				The sub-array of length at-least 2
				that produces greatest sum is {-2, 1}

			Example 2:
				Input :
				n = 6 
				a[] = {1, 1, 1, 1, 1, 1}
				k = 2
				Output : 
				6
				Explanation :
				The sub-array of length at-least 2
				that produces greatest sum is {1, 1, 1, 1, 1, 1}

			Your Task:  
				You don't need to read input or print anything. 
				Your task is to complete the function maxSumWithK() which takes the array a[], 
				its size n and an integer k as inputs and returns the value of the largest sum 
				of the subarray containing at least k numbers.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 <= n <= 10^5
				-10^5 <= a[i] <= 10^5
				1 <= k <= n

		//Not Optimized:
			class Solution{
				public:    
				long long int maxSumWithK(long long int a[], long long int n, long long int k) {
					long long int mx = INT_MIN;
					
					for(long long int i=0; i<=n-k; i++){
						long long int sum =0;
						long long int J = k;
						
						long long int temp = i;
						while(J--){
							if(temp == n)
								break;
							sum += a[temp++];
						}
						
						mx = max(sum,mx);
						
						//adding extra rest element
						for(long long int z=temp; z<n; z++){
							sum += a[z];
							mx = max(sum,mx);
						}
						
					}
					return mx;
				}
			};
	
		//Optimized:
			class Solution{
				public:    
				long long int maxSumWithK(long long int a[], long long int n, long long int k) {
					long long int s{}, x{INT_MIN}, y{};
					
					for(int i{}, j{}; j < n;) {
						s += a[j];
						if(j - i + 1 < k) ++j;
						else if(j - i + 1 == k) x = max(x, s), ++j;
						else {
							x = max(x, s), y += a[i++];
							if(y < 0) s -= y, x = max(x, s), y = 0;
							++j;
						}
					}
					
					return x;
				}
			};

	262) Convert an Array Into a 2D Array With Conditions:
		Problem Statement:
			You are given an integer array nums. 
			You need to create a 2D array from nums satisfying the following conditions:
			The 2D array should contain only the elements of the array nums.
			Each row in the 2D array contains distinct integers.
			The number of rows in the 2D array should be minimal.
			Return the resulting array. If there are multiple answers, return any of them.

			Note that the 2D array can have a different number of elements on each row.

			Example 1:
				Input: nums = [1,3,4,1,2,3,1]
				Output: [[1,3,4,2],[1,3],[1]]
				Explanation: We can create a 2D array that contains the following rows:
				- 1,3,4,2
				- 1,3
				- 1
				All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.
				It can be shown that we cannot have less than 3 rows in a valid array.

			Example 2:
				Input: nums = [1,2,3,4]
				Output: [[4,3,2,1]]
				Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.
			
			Constraints:
				1 <= nums.length <= 200
				1 <= nums[i] <= nums.length

		//goto statement used:
			class Solution {
				public:
				vector<vector<int>> findMatrix(vector<int>& nums) {
					vector<vector<int>> ans;

					//need to insert first element manually
					ans.push_back({nums[0]});

					for(int i=1; i<nums.size(); i++){
						
						int index = 0;
						
						conditionCheck:
						if(find(ans[index].begin(), ans[index].end(), nums[i]) == ans[index].end())
							ans[index].push_back(nums[i]);
						else{   
							index++;
							if(index >= ans.size())
								ans.push_back({});
							goto conditionCheck;
						}
					}
					return ans;
				}
			};

		//while loop used:
			class Solution {
				public:
				vector<vector<int>> findMatrix(vector<int>& nums) {
					vector<vector<int>> ans;

					//The newly created vector has default size is 0.
					//so incrementing its size by 1
					//below syntax inserts the empty vector to ans
					ans.push_back({});

					for(int i=0; i<nums.size(); i++){
						int index =0;

						while(find(ans[index].begin(), ans[index].end(), nums[i]) != ans[index].end()){
							index++;

							//checking that index should not cross the ans vector's size
							//if it's crossing the size, then we are incrementing by 1 as empty
							if(index>= ans.size())
								ans.push_back({});
						}
						ans[index].push_back(nums[i]);
					}
					return ans;
				}
			};
	
	263) Insert An Element At Its Bottom In A Given Stack:
		Problem statement
			You are given a stack/deque of integers 'MY-STACK' and an integer ‘X’. 
			Your task is to insert ‘X’ to the bottom of ‘MY-STACK’ and return the updated stack/deque.

			Note :
			If ‘MY_STACK’ = [7, 1, 4, 5], then the first element represents the element at the 
			bottom of the stack and the last element represents the element at the top of the stack.
			For Example :
				Let ‘MY_STACK’ = [7, 1, 4, 5] and ‘X’ = 9. So, ‘MY_STACK’ after insertion becomes [9, 7, 1, 4, 5].

			Follow Up :
				Try to do this without using any other data structure.
			Constraints :
				1 <= T <=100
				1 <= N <= 10^4
				0 <= 'X’ and 'MY_STACK[i]’ <= 10^5

				Time limit: 1 second
			Sample input 1 :
				2
				3 8
				4 3 2
				4 5
				6 2 4 9
				Sample Output 1 :
				8 4 3 2
				5 6 2 4 9
				Explanation For Sample Input 1 :
				Test Case 1:

				We are  given 'MY_STACK = [4,3,2] and 'X’ = 8.
				We insert ‘X’ at the bottom of ‘MY_STACK’. 
				So finally, we have 'MY_STACK' = [8, 4, 3, 2]. 

			Test Case 2:
				After inserting an element at its bottom, the stack will be 5 6 2 4 9
				Sample Input 2 :
				2
				1 0
				4 
				2 5
				1 9
				Sample Output 2 :
				0 4
				5 1 9
				Explanation For Sample Input 2 :
				Test Case 1:
				We are given 'MY_STACK = [4]’ and 'X’ = 0’.
				We insert ‘X’ at the bottom of ‘MY_STACK’. 
				So finally, 'MY_STACK' will become [0, 4]. 

				Test Case 2:
				We are given 'MY_STACK = [1,9]’ and 'X’ = 5.
				So finally, 'MY_STACK' will become [5, 1, 9]. 

		// Using Extra space:
		#include <bits/stdc++.h> 
		stack<int> pushAtBottom(stack<int>& myStack, int x) {
			vector<int> holder;
			while(!myStack.empty()){

				//accessing the top element of stack
				holder.push_back(myStack.top());

				//removing the element which we accessed already
				myStack.pop();
			}

			//insert element
			myStack.push(x);

			for(int i=holder.size()-1; i>=0; i--){
				myStack.push(holder[i]);
			}
			return myStack;
		}

		// Using Recursion:
		stack<int> pushAtBottom(stack<int>& myStack, int x) {
			// Write your code here.
			if(myStack.empty()){
				myStack.push(x);
				return myStack;
			}
			
			int num = myStack.top();
			myStack.pop();
			pushAtBottom(myStack, x);
			myStack.push(num);
			return myStack;
		}

		//or Using extra space
		#include <bits/stdc++.h> 
		stack<int> pushAtBottom(stack<int>& myStack, int x) {
			stack<int> temp;
			
			while(!myStack.empty()){
				temp.push(myStack.top());
				myStack.pop();
			}
			temp.push(x);
			while(!temp.empty()){
				myStack.push(temp.top());
				temp.pop();
			}
			return myStack;
		}
	
	264) Smallest window containing 0, 1 and 2:
		Problem statement:
			Given a string S consisting of the characters 0, 1 and 2. 
			Your task is to find the length of the smallest substring of string S 
			that contains all the three characters 0, 1 and 2. 
			If no such substring exists, then return -1.

			Example 1:
				Input:
				S = 01212
				Output:
				3
				Explanation:
				The substring 012 is the smallest substring
				that contains the characters 0, 1 and 2.
			
			Example 2:
				Input: 
				S = 12121
				Output:
				-1
				Explanation: 
				As the character 0 is not present in the
				string S, therefor no substring containing
				all the three characters 0, 1 and 2
				exists. Hence, the answer is -1 in this case.

			Your Task:
				Complete the function smallestSubstring() which takes the string S as input, 
				and returns the length of the smallest substring 
				of string S that contains all the three characters 0, 1 and 2.

			Expected Time Complexity: O( length( S ) )
			Expected Auxiliary Space: O(1)

			Constraints:
			1 ≤ length( S ) ≤ 10^5
			All the characters of String S lies in the set {'0', '1', '2'}

		class Solution {
			public:
			int smallestSubstring(string s) {
				
				//its not contains any of char 0,1 or 2 then return -1
				if(s.find('0') == string::npos || s.find('1') == string::npos || s.find('2') == string::npos)
					return -1;
				
				//this is also optional
				// if((s.find("012") != string::npos) || (s.find("021") != string::npos) ||
				//     (s.find("102") != string::npos) || (s.find("120") != string::npos) ||
				//     (s.find("201") != string::npos) || (s.find("210") != string::npos))
				//         return 3;

				
				int mx = INT_MAX;
				
				for(int i=0; i<s.length(); i++){
				
					vector<int> valueHolder;
					int var = 0;
				
					for(int j=i; j<s.length(); j++){
						if(find(valueHolder.begin(), valueHolder.end(), s[j]) == valueHolder.end())
							var++;
							
						
						valueHolder.push_back(s[j]);
						
						if(var == 3){
							int v = valueHolder.size();
							
							//below if condition is optional (for optimization keep it else you will get TLE)
							if(v == 3)
							return 3;
							
							mx = min(mx,v);
							break;
						}
					}
					
				}
				
				if(mx == INT_MAX)
					return -1;
					
				return mx;
			}
		};

	265) Number of Laser Beams in a Bank:
		Problem Statement:
			Anti-theft security devices are activated inside a bank. 
			You are given a 0-indexed binary string array bank representing the floor plan of the bank, 
			which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. 
			'0' means the cell is empty, while'1' means the cell has a security device.
			There is one laser beam between any two security devices if both conditions are met:

			The two devices are located on two different rows: r1 and r2, where r1 < r2.
			For each row i where r1 < i < r2, there are no security devices in the ith row.
			Laser beams are independent, i.e., one beam does not interfere nor join with another.

			Return the total number of laser beams in the bank.

			Example 1:
				Input: bank = ["011001","000000","010100","001000"]
				Output: 8
				Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
				* bank[0][1] -- bank[2][1]
				* bank[0][1] -- bank[2][3]
				* bank[0][2] -- bank[2][1]
				* bank[0][2] -- bank[2][3]
				* bank[0][5] -- bank[2][1]
				* bank[0][5] -- bank[2][3]
				* bank[2][1] -- bank[3][2]
				* bank[2][3] -- bank[3][2]
				Note that there is no beam between any device on the 0th row with any on the 3rd row.
				This is because the 2nd row contains security devices, which breaks the second condition.

			Example 2:
				Input: bank = ["000","111","000"]
				Output: 0
				Explanation: There does not exist two devices located on two different rows.
				
			Constraints:
				m == bank.length
				n == bank[i].length
				1 <= m, n <= 500
				bank[i][j] is either '0' or '1'.
		
		class Solution {
			public:
			int numberOfBeams(vector<string>& bank) {
				int All_Beams=0;
				int prevRowsOnes=0;

				//counting the security laser's in first row
				for(int a=0; a<bank[0].size(); a++)
					if(bank[0][a] == '1')
						prevRowsOnes++;
				
				for(int i=1; i<bank.size(); i++){

					int crntRowsOnes=0;

					//counting the security laser's in current row
					for(int b=0; b<bank[i].size(); b++)
						if(bank[i][b] == '1')
							crntRowsOnes++;
					
					All_Beams += (prevRowsOnes * crntRowsOnes);

					if(crntRowsOnes !=0)
						prevRowsOnes = crntRowsOnes;
				}
				return All_Beams;
			}
		};

		//or using continue statement, if crntRowsOnes is zero.
			class Solution {
				public:
				int numberOfBeams(vector<string>& bank) {
					int All_Beams=0;
					int prevRowsOnes=0;

					//counting the security laser's in first row
					for(int a=0; a<bank[0].size(); a++)
						if(bank[0][a] == '1')
							prevRowsOnes++;
					
					for(int i=1; i<bank.size(); i++){

						int crntRowsOnes=0;
						//counting the security laser's in current row
						for(int b=0; b<bank[i].size(); b++)
							if(bank[i][b] == '1')
								crntRowsOnes++;
						
						if(crntRowsOnes == 0)
							continue;

						All_Beams += (prevRowsOnes * crntRowsOnes);
						prevRowsOnes = crntRowsOnes;
					}
					return All_Beams;
				}
			};
	
	266) Find element occuring once when all other are present thrice:
		Problem Statement:
			Given an array of integers arr[] of length N,
			every element appears thrice except for one which occurs once.
			Find that element which occurs once.

			Example 1:
				Input:
				N = 4
				arr[] = {1, 10, 1, 1}
				Output:
				10
				Explanation:
				10 occurs once in the array while the other
				element 1 occurs thrice.

			Example 2:
				Input:
				N = 10
				arr[] = {3, 2, 1, 34, 34, 1, 2, 34, 2, 1}
				Output:
				3
				Explanation:
				All elements except 3 occurs thrice in the array.

			Your Task:
				You do not need to take any input or print anything. 
				You task is to complete the function singleElement() 
				which takes an array of integers arr and an integer N 
				which finds and returns the element occuring once in the array.
			
			Constraints:
				1 ≤ N ≤ 10^5
				-10^9 ≤ A[i] ≤ 10^9

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1).

		//Using Map:
			class Solution {
				public:
				int singleElement(int arr[] ,int N) {
					
					//Element counter
					map<int, int> FreqCounter;
					for(int i=0; i<N; i++){
						FreqCounter[arr[i]]++;
					}
					
					//finding that element which occurred once
					for(auto i: FreqCounter)
						if(i.second == 1)
							return i.first;
				}
			};

		//Using Sort Technique:
			class Solution {
				public:
				int singleElement(int arr[] ,int N) {
					
					//sort sytanx for normal array no need to use begin & end, incase of vector we have to use begin & end functions
					sort(arr, arr+N);
					
					//Need to check for first element manually
					if(arr[0] != arr[1])
						return arr[0];
					
					for(int i=1; i<N-1; i++){
						if((arr[i] != arr[i+1]) && (arr[i] != arr[i-1]))
							return arr[i];
					}
					
					//Need to check for last element manually
					//saying Last element (N-1) is not equal to second Last element(N-2) if yes then return last element
					if(arr[N-1] != arr[N-2])
						return arr[N-1];
				}
			};
		
		//Using Math & bits manipulation: ❌Pending
			class Solution {
				public:
				int singleElement(int arr[] ,int N) {

					int ones = 0, twos = 0;
				
					int common_bit_mask;
					
					for (int i = 0; i < N; i++) {
						twos = twos | (ones & arr[i]);
					
						ones = ones ^ arr[i];
					
						common_bit_mask = ~(ones & twos);
					
						ones &= common_bit_mask;
						
						twos &= common_bit_mask;
					}
					return ones;
				}
			};

	267) Maximum value of difference of a pair of elements and their Index:
		Problem Statement:
			Given an array arr[] of N positive integers. 
			Find maximum value of |arr[i] – arr[j]| + |i – j|, (0 <= i, j <= N – 1).

			Example 1:
				Input:
				N = 4 
				arr[] = {1, 2, 3, 1}
				Output:
				4
				Explanation:
				Choosing i=0 and j=2, will result in
				|1-3|+|0-2| = 4, which is the maximum
				possible value.

			Example 2:
				Input:
				N = 3 
				A[] = {1, 1, 1}
				Output:
				2
				Explanation:
				Choosing i=0 and j=2, will result in
				|1-1|+|0-2| = 2, which is the maximum
				possible value.

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function maxValue() which takes an Integer N 
				and an array arr of size N as input and returns 
				the maximum possoble value of |arr[i] – arr[j]| + |i – j|.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 <= N <= 10^5
				0 <= arr[i] <= 10^5

		//Not Optimized:
			class Solution {
				public:
					int maxValue(int arr[], int N) {
						int mxV=INT_MIN;
						
						if(N==1)
							return 0;
						
						for(int i=0; i<N; i++){
							
							for(int j=i+1; j<N; j++){
								int exprsn = abs(arr[i]-arr[j]) + abs(i-j);
								mxV = max(mxV, exprsn);
							}
						}
						
						return mxV;
					}
			};

		//Optimized:
			class Solution {
				public:
				int maxValue(int arr[], int N) {
					int res = 0;
					int maxi = arr[N-1];
					int maxi_ind = N-1;
					
					for(int i = N-2;i>=0;i--){
						
						res = max(res , abs(arr[i] - maxi) + abs(i - maxi_ind));
						
						if(arr[i] > maxi + abs(i-maxi_ind)){
							maxi_ind = i;
							maxi = arr[i];
						}
					}
					
					int res2 = 0;
					maxi = arr[0];
					maxi_ind = 0;
					
					for(int i =1;i<N;i++){
						
						res2 = max(res2 , abs(arr[i] - maxi) + abs(i - maxi_ind));
						
						if(arr[i] > maxi + abs(i-maxi_ind)){
							maxi_ind = i;
							maxi = arr[i];
						}
					}
					
					return max(res,res2);
				}
			};
	
		//or Another Approach:
			class Solution {
				public:
				int maxValue(int arr[], int N) {
					int max1=INT_MIN;
					int min1=INT_MAX;
					int ans;
					int max2=INT_MIN;
					int min2=INT_MAX;
					
					for(int i=0;i<N;i++) {
						max1=max(max1,arr[i]-i);
						min1=min(min1,arr[i]-i);
						max2=max(max2,arr[i]+i);
						min2=min(min2,arr[i]+i);
					}
					
					ans=max((max1-min1),(max2-min2));
					return ans;
				}
			};

	268) Minimum Number of Operations to Make Array Empty:
		Problem Statement:
			You are given a 0-indexed array nums consisting of positive integers.
			There are two types of operations that you can apply on the array any number of times:
			Choose two elements with equal values and delete them from the array.
			Choose three elements with equal values and delete them from the array.
			Return the minimum number of operations required to make the array empty, or -1 if it is not possible.

			Example 1:
				Input: nums = [2,3,3,2,2,4,2,3,4]
				Output: 4
				Explanation: We can apply the following operations to make the array empty:
				- Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].
				- Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].
				- Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].
				- Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].
				It can be shown that we cannot make the array empty in less than 4 operations.

			Example 2:
				Input: nums = [2,1,2,2,3,3]
				Output: -1
				Explanation: It is impossible to empty the array.
			
			Constraints:
				2 <= nums.length <= 10^5
				1 <= nums[i] <= 10^6

		class Solution {
			public:
			int minOperations(vector<int>& nums) {
				//counting the frequency of elements
				map<int,int> FreqOfNums;
				for(int i=0; i<nums.size(); i++){
					FreqOfNums[nums[i]]++;
				}

				int minOps=0;
				for(auto itr: FreqOfNums){
					if(itr.second == 1){
						return -1;
					}else if(itr.second % 3 == 0){
						minOps += (itr.second/3);
					}else if(itr.second > 5 && itr.second % 3 == 1){
						
						int value = itr.second - 3;
						minOps += (value/3);

						//Adding extra 2, 2 operation required next to make array empty
						minOps += 2;

					}else if(itr.second % 3 == 2){
						minOps += (itr.second/3) + 1;
					}else if(itr.second % 2 == 0){
						minOps += (itr.second/2);
					}else{
						return -1;
					}
				}
				return minOps;
			}
		};

		//or
			class Solution {
				public:
				int minOperations(vector<int>& nums) {
					unordered_map<int, int> FreqCounter;

					for(int i=0; i<nums.size(); i++)
						FreqCounter[nums[i]]++;
					
					int minOperations=0;
					for(auto [key, value] : FreqCounter)
						if(value == 1)
							return -1;
						else{
							minOperations += (value+2)/3;
						}
					
					return minOperations;
				}
			};

		//or
			class Solution {
				public:
				int minOperations(vector<int>& nums) {
					map<int, int> freq;
					for(int o: nums)
						freq[o]++;

					int ans=0;
					for(auto a: freq){
						if(a.second == 1)
							return -1;

						ans += (a.second / 3);
						
						if((a.second)%3)
							ans++;
					}
					return ans;
				}
			};

	269) Rock Paper Scissor:
		Problem statement
			Nezuko and Zenitsu were playing Rock Paper Scissors which is a very popular game 
			where each player can do three moves which are: ‘Rock’, ‘Paper’ and ‘Scissor’.

			The winner of a game is decided in the following way:

			‘Rock’ beats ‘Scissor’.
			‘Scissor’ beats ‘Paper’.
			‘Paper’ beats ‘Rock’.

			If both players make the same move like ‘Rock’ is made by both person then that result in a draw and whose point will not be rewarded to anyone.

			Now you have been provided with two strings representing the moves that 
			they will make for ‘NEZUKO’ represents Nezuko’s string and ‘ZENITSU’ represents Zenitsu’s moves.
			
			In the string ‘R’ represents ‘ROCK’ and ‘P’ represents ‘PAPER’ and ‘S’ represents ‘SCISSORS’.
			There is a total of ‘K’ games that will be played and the player will play the move by traversing 
			the string provided. If a player reaches the end of the string then his next moves will be played from the start of the string.

			You have to tell the number of games won by Nezuko and the number of games won by Zenitsu respectively in order.

			Example:
				Input: ‘K’ = 3, ‘NEZUKO’ = ‘RP’, ‘ZENITSU’ = ‘R’
				Output: 1 0
				Game 1: ‘NEZUKO’ = ‘R’, ‘ZENITSU’ =  ‘R’, Result = ‘Draw’.
				Game 2: ‘NEZUKO’ = ‘P’, ‘ZENITSU’ = ‘R’, Result = ‘Nezuko won the game’.
				Game 3: ‘NEZUKO’ = ‘R’, ‘ZENITSU’ =  ‘R’, Result = ‘Draw’.
				Constraints :
					1 <= T <= 10 
					1 <= K <= 10^5
					1<= |NEZUKO| <= 10^5
					1<= |ZENITSU| <= 10^5
					Strings contain only 3 types of values ‘R’, ‘P’ and ‘S’.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				RP
				R
				4
				PRSP
				RPSR
				Sample Output 1 :
				1 0
				2 1
				Explanation Of Sample Input 1 :
				For test case 1: 
				Game 1: ‘NEZUKO’ = ‘R’, ‘ZENITSU’ =  ‘R’, Result = ‘Draw’.
				Game 2: ‘NEZUKO’ = ‘P’, ‘ZENITSU’ = ‘R’, Result = ‘Nezuko won the game’.
				Game 3: ‘NEZUKO’ = ‘R’, ‘ZENITSU’ =  ‘R’, Result = ‘Draw’.

				For test case 2:
				Game 1: ‘NEZUKO’ = ‘P’, ‘ZENITSU’ = ‘R’, Result = ‘Nezuko won the game’.
				Game 2: ‘NEZUKO’ = ‘R’, ‘ZENITSU’ = ‘P’, Result = ‘Zenitsu won the game’.
				Game 3: ‘NEZUKO’ = ‘S’, ‘ZENITSU’ = ‘S’, Result = ‘Draw’.
				Game 4: ‘NEZUKO’ = ‘P’, ‘ZENITSU’ = ‘R’, Result = ‘Nezuko won the game’.
				Sample Input 2 :
				2
				4
				RPSPSRPSR
				SPRPSRPPRSR
				6
				RPSPRSPS
				RPS
				Sample Output 2 :
				1 1
				1 1

		//Not Optimized:
			#include <bits/stdc++.h> 
			vector <int> rockPaperScissor(int k, string nezuko, string zenitsu) {
				
				int numsOfTimesWin_nezuko, numsOfTimesWin_zenitsu;
				
				numsOfTimesWin_nezuko = numsOfTimesWin_zenitsu = 0;

				int traverserForNezuko, traverserForZenitsu;
				traverserForNezuko = traverserForZenitsu=0;


				for(int i=0; i<k; i++){
					if(nezuko[traverserForNezuko] == 'R' && zenitsu[traverserForZenitsu] == 'S')
						numsOfTimesWin_nezuko++;
					else if(nezuko[traverserForNezuko] == 'R' && zenitsu[traverserForZenitsu] == 'P')
						numsOfTimesWin_zenitsu++;
					else if(nezuko[traverserForNezuko] == 'P' && zenitsu[traverserForZenitsu] == 'S')
						numsOfTimesWin_zenitsu++;
					else if(nezuko[traverserForNezuko] == 'P' && zenitsu[traverserForZenitsu] == 'R')
						numsOfTimesWin_nezuko++;
					else if(nezuko[traverserForNezuko] == 'S' && zenitsu[traverserForZenitsu] == 'R')
						numsOfTimesWin_zenitsu++;
					else if(nezuko[traverserForNezuko] == 'S' && zenitsu[traverserForZenitsu] == 'P')
						numsOfTimesWin_nezuko++;
					
					traverserForZenitsu++;
					traverserForNezuko++;
					
					if(traverserForNezuko >= nezuko.length())
						traverserForNezuko=0;
					
					if(traverserForZenitsu >= zenitsu.length())
						traverserForZenitsu=0;
				}
				return {numsOfTimesWin_nezuko, numsOfTimesWin_zenitsu};
			}
	
		//Optimized:
			#include <bits/stdc++.h> 
			vector <int> rockPaperScissor(int k, string nezuko, string zenitsu) {
				
				int winN, winZ;
				winN = winZ = 0;

				int i=0, j=0, n= nezuko.length(), m = zenitsu.length();

				while(k--){
					if(nezuko[i]==zenitsu[j]){
						i++;
						i %= n;

						j++;
						j %= m;
						
						continue;
					}
					if((nezuko[i]=='R' and zenitsu[j]=='S') or (nezuko[i]=='S' and zenitsu[j]=='P') or (nezuko[i]=='P' and zenitsu[j]=='R'))
						winN++;
					else
						winZ++;

					i=(i+1)%n;
					j=(j+1)%m;
				}
				return {winN, winZ};    
			}

	270) Split the String:
		Problem statement
			You are given a string ‘S’ consisting of lower-case English alphabets, find the number of good splits.
			Splitting a string ‘S’ into two non-empty strings ‘X’ and ‘Y’ is called good 
			if the number of unique characters in strings ‘X’ and ‘Y’ is equal.

			For Example :
				If string S is equal to “abadaa”.

				Then S can be split in the following ways:
				X = “a” and Y = “badaa”, string X has 1 unique character and Y has 3 unique characters.
				X = “ab” and Y = “adaa”, string X has 2 unique characters and Y has 2 unique characters.[GOOD SPLIT]
				X = “aba” and Y = “daa”, string X has 2 unique characters and Y has 2 unique characters.[GOOD SPLIT]
				X = “abad” and Y = “aa”, string X has 3 unique characters and Y has 1 unique character.
				X = “abada” and Y = “a”, string X has 3 unique characters and Y has 1 unique character.
				Therefore we will return value 2 as we are able to find 2 good splits.
			Constraints :
				1 <= T <= 10      
				1 <= S.length <= 200
				S contains only lower-case English alphabets

			Time limit: 1 sec
			Sample Input 1 :
				2
				abadaa
				abcde
				Sample Output 1 :
				2
				0 
				Explanation For Sample Input 1 :
				For test case 1 : 
				We will return 2, because only 2 good splits are possible as shown below:
				X = “a” and Y = “badaa”, string X has 1 unique character and Y has 3 unique characters.
				X = “ab” and Y = “adaa”, string X has 2 unique characters and Y has 2 unique characters.[GOOD SPLIT]
				X = “aba” and Y = “daa”, string X has 2 unique characters and Y has 2 unique characters.[GOOD SPLIT]
				X = “abad” and Y = “aa”, string X has 3 unique characters and Y has 1 unique character.
				X = “abada” and Y = “a”, string X has 3 unique characters and Y has 1 unique character.

				For test case 2 : 
				We will return 0, because no good split is possible. All possible splits are shown:
				X = “a” and Y = “bcde”, string X has 1 unique character and Y has 4 unique characters.
				X = “ab” and Y = “cde”, string X has 2 unique characters and Y has 3 unique characters. 
				X = “abc” and Y = “de”, string X has 3 unique characters and Y has 2 unique characters.
				X = “abcd” and Y = “e”, string X has 4 unique characters and Y has 1 unique character.
				Sample Input 2 :
				2
				codingninjas
				codestudio
				Sample Output 2 :
				0
				1

		//Not Optimized:
			int UniqueCharCounter(string str){
				set<char> s;
				for(int i=0; i<str.length(); i++){
					s.insert(str[i]);
				}
				return s.size();

				//or instead of above use below code.
				// set<char> s(str.begin(), str.end());         //to insert the char of str to set 's'
				// return s.size();
			}

			int splitString(string s) {
				int goodSplit=0;

				if(s.length()==1)
					return goodSplit;
				
				int var = 1;

				// string s1 = s.substr(0,var);
				// string s2 = s.substr(var);

				// int UniqueS1 = UniqueCharCounter(s1);
				// int UniqueS2 = UniqueCharCounter(s2);

				// if(UniqueS1 == UniqueS2)
				//    goodSplit++;

				while(var<=s.length()-1){

					string s1 = s.substr(0,var);
					string s2 = s.substr(var);

					int UniqueS1 = UniqueCharCounter(s1);
					int UniqueS2 = UniqueCharCounter(s2);
					
					if(UniqueS1 == UniqueS2)
					goodSplit++;
					
					var++;
				}

				return goodSplit;
			}
		
		//or Not optimized concise
			int splitString(string s) {
				int goodSplit=0;
				int var = 1;

				while(var<s.length()){

					set<char> SetRight(s.begin(), s.begin()+var);
					set<char> SetLeft(s.begin()+var, s.end());

					if(SetRight.size() == SetLeft.size())
					goodSplit++;
					
					var++;
				}

				return goodSplit;
			}
			
		//or
			int UniqueCharCounter(string str){
				set<char> s(str.begin(), str.end());         //to insert the char of str to set 's'
				return s.size();
			}
			int splitString(string s) {
				int goodSplit=0;
				int var = 1;

				while(var<=s.length()-1){

					if(UniqueCharCounter(s.substr(0,var)) == UniqueCharCounter(s.substr(var)))
					goodSplit++;
					
					var++;
				}

				return goodSplit;
			}

		//OPTIMIZED:
			int splitString(string s) {
				// Write your code here
				int n=s.length();
				int cnt=0;

				vector<int>pre_sum(n),suf_sum(n);
				unordered_map<char,int>mp;

				for(int i=0;i<n;i++){
					mp[s[i]]++;
					pre_sum[i]=mp.size();
				}

				mp.clear();
				for(int i=n-1;i>=0;i--){
					mp[s[i]]++;
					suf_sum[i]=mp.size();
				}
				
				for(int i=0;i<n-1;i++){
					if(pre_sum[i]==suf_sum[i+1])cnt++;
				}

				return cnt;
			}

	271) Triangle:
		Problem statement
			Sam is making a Triangular painting for a maths project.
			An N-dimensional Triangle is represented by the lower triangle 
			of the pattern filled with integers representing the row number.
			For every value of ‘N’, help sam to print the corresponding Triangle.

			Example:
				Input: ‘N’ = 3
			Output: 
				1
				2 2 
				3 3 3
			Constraints :
				1  <= N <= 25
				Time Limit: 1 sec
			Sample Input 1:
				3
				Sample Output 1:
				1 
				2 2 
				3 3 3
				Sample Input 2 :
				1
				Sample Output 2 :
				1
		
		void triangle(int n) {
			for(int i=1; i<=n; i++){
				for(int j=1; j<=i; j++)
					cout<<i<<" ";
				cout<<"\n";
			}
		}

	272) Good Number:
		Problem statement
			You are given an integer ‘N’, you need to find whether it’s a good number or not.
			We start from the integer ‘N’ and keep replacing the current 
			number with the sum of squares of its digits, we keep repeating 
			this process until we will the number 1. A number that generates 
			the 1 after finite repetition of the above process is called a good number.
			Example :
				If ‘N’ = 7,
				Then we start with the integer 7 and replace it with (7 * 7) = 49.
				The new number is 49, we replace it with (4 * 4) + (9 * 9) = 97.
				We replace this new number 97 with (9 * 9) + (7 * 7) = 130.
				We replace this new number 130 with (1 * 1) + (3 * 3) + (0 * 0) = 10.
				We replace this new number 10 with (1 * 1) + (0 * 0) = 1.
				Therefore, the original number 7 is a good number. 

			Constraints :
				1 ≤ ‘T’ ≤ 10      
				1 ≤ N ≤ 10000    
				Time limit: 1 sec
			
			Sample Input 1 :
				2
				7
				2
				Sample Output 1 :
				true
				false
				Explanation For Sample Input 1 :
				For test case 1 :
				We will print “true” because:
				We start with the input integer 7 and replace it with (7 * 7) = 49.
				The new number is 49, we replace it with (4 * 4) + (9 * 9) = 97.
				We replace this new number 97 with (9 * 9) + (7 * 7) = 130.
				We replace this new number 130 with (1 * 1) + (3 * 3) + (0 * 0) = 10.
				We replace this new number 10 with (1 * 1) + (0 * 0) = 1.
				Therefore, the original number 7 is a good number.

				For test case 2 : 
				We will print “false” because:
				If we start replacing the number 2 with the sum of the square of its digits then we will not be able to reach the number 1 even after infinite steps.
				Sample Input 2 :
				2
				1
				1045
				Sample Output 2 :
				true
				false
	
		int powSumFunc(int a){
			int sum=0;
			while(a){        
				sum += pow(a%10, 2);
				a/=10;
			}
			return sum;
		}

		bool isGoodNumber(int n) {
			
			if(n==1)
				return 1;
			
			vector<int> v;

			while(1){
				if(n== 1)
					return 1;
				
				if(find(v.begin(), v.end(), n) != v.end())
					return 0;
					
				v.push_back(n);

				n = powSumFunc(n);
			}
			return 0;
		}

	273) Majority Element - II:
		Problem statement
			You are given an array/list 'ARR' of integers of length ‘N’. 
			You are supposed to find all the elements that occur strictly more than floor(N/3) 
			times in the given array/list.

			Constraints :
				1 <= T <= 100
				3 <= N <= 5000
				1 <= ARR[i] <= 10^5
				Time Limit: 1 sec

			Sample Input 1 :
				2
				7
				3 2 2 1 5 2 3
				5
				7 4 4 9 7
				Sample Output 1:
				2
				4 7
				Explanation of Sample Input 1:
				In the first test case, floor(N/3) = floor(7/3) is equal to 2, 
				and 2 occurs 3 times which is strictly more than N/3. No other element occurs more than 2 times.

				In the second test case, floor(N/3) = floor(5/3) is equal to 1,
				and 4 and 7 both occur 2 times. No other element occurs more than once.
				Sample Input 2:
				2
				6
				1 2 4 4 3 4
				4
				6 6 6 7
				Sample Output 2:
				4
				6
				Explanation of Sample Input 2:
					In the first test case, floor(N/3) = floor(6/3) is equal to 2,
					and 4 occurs 3 times which is strictly more than N/3. No other element occurs more than 2 times.
					
					In the second test case, floor(N/3) = floor(4/3) is equal to 1,
					and 6 occurs 3 times. No other element occurs more than once.

		#include <bits/stdc++.h>
		vector<int> majorityElementII(vector<int> &arr) {
			//count Frequency of element
			map<int, int> count;
			for(int i=0; i<arr.size(); i++)
				count[arr[i]]++;
			
			vector<int> ans;
			for(auto i: count)
				if(i.second > arr.size()/3)
					ans.push_back(i.first);

			return ans;
		}
	
	274) Count of Smaller Elements:
		Problem statement
			Given an array of size 'N' return the count array such that COUNT[i] equals the 
			number of element which are smaller than ARR[i] on its the right side.

			For Example : ARR = [4,2,1,5] the count array corresponding to the given array is :-
				The Number of elements smaller than 4 on its right side is 2.
				The Number of elements smaller than 2 on its right side is 1.
				The Number of elements smaller than 1 on its right side is 0.
				The Number of elements smaller than 5 on its right side is 0.
				Hence the count array is [2,1,0,0]
			Constraints :
				1 <= T <= 10
				1 <= N <= 3000
				-10^3 <= arr[i] <= 10^3
			Where ‘i’ varies from 1 to ‘N’ where 'N' is the length of the array.
			Time Limit: 1 sec
		
		//Not Optimized:
			vector<int>countNumber(int n, vector<int> &arr) {
				vector<int> ans(n, 0);

				for(int i=0; i<n-1; i++){

					int cnt=0;
					for(int j=i+1; j<n; j++)
						if(arr[i] > arr[j])
							cnt++;
						
					ans[i] = cnt;
				}
				return ans;
			}
		
		//Optimized:
			void merge(int left, int mid, int right, vector<pair<int, int>>& arr,vector<int>& count) {
				vector<pair<int, int>> temp(right - left + 1);
				int i = left;
				int j = mid + 1;
				int k = 0;

				while(i <= mid && j <= right)
					if(arr[i].first <= arr[j].first) 
						temp[k++] = arr[j++];
					else{
						count[arr[i].second] += (right - j + 1);
						temp[k++] = arr[i++];
					}

				while(i <= mid)
					temp[k++] = arr[i++];

				while(j <= right)
					temp[k++] = arr[j++];

				for(int l = left; l <= right; l++)
					arr[l] = temp[l - left];
			}

			void mergeSort(int left, int right, vector<pair<int, int>>& arr, vector<int>& count) {
				if(left >= right)
					return;

				int mid = left + (right - left) / 2;

				mergeSort(left, mid, arr, count);
				mergeSort(mid + 1, right, arr, count);
				merge(left, mid, right, arr, count);
			}

			vector<int>countNumber(int n, vector<int> &nums) {
				vector<pair<int, int>> arr;

				for(int i = 0; i < n; i++)
					arr.push_back({nums[i], i});

				vector<int> count(n, 0);

				mergeSort(0, n - 1, arr, count);

				return count;
			}
	
	275) Search Pattern (KMP-Algorithm):
		Problem statement:
			Given two strings, one is a text string, txt and other is a pattern string, pat. 
			The task is to print the indexes of all the occurences of pattern string in the text string. 
			Use one-based indexing while returing the indices. 
			Note: Return an empty list incase of no occurences of pattern. Driver will print -1 in this case.

			Example 1:
				Input:
				txt = "geeksforgeeks"
				pat = "geek"
				Output: 
				1 9
				Explanation: 
				The string "geek" occurs twice in txt, one starts are index 1 and the other at index 9. 

			Example 2:
				Input: 
				txt = "abesdu"
				pat = "edu"
				Output: 
				-1
				Explanation: 
				There's not substring "edu" present in txt.

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function search() which 
				takes the string txt and the string pat as inputs and 
				returns an array denoting the start indices (1-based) of substring pat in the string txt. 

			Expected Time Complexity: O(|txt|).
			Expected Auxiliary Space: O(|txt|).

			Constraints:
			1 ≤ |txt| ≤ 10^5
			1 ≤ |pat| < |S|
			Both the strings consists of lowercase English alphabets.

		class Solution {
			public:
			vector<int> search(string pat, string txt) {
				std::vector<int> ans;
				int it = 0;
			
				while (true) {
					auto foundIt = std::search(txt.begin() + it, txt.end(), pat.begin(), pat.end());
			
					if (foundIt != txt.end()) {
						int idx = std::distance(txt.begin(), foundIt);
						ans.push_back(idx+1);
						it = idx + 1; // Move to the next position after the found pattern
					} else {
						break; // Break the loop if no more occurrences are found
					}
				}
				return ans;
			}
		};

	276) Ninja World Tournament:
		Problem statement
			Ninja was feeling bored during the lockdown. 
			So, he decided to watch the Ninja World Tournament. 
			The tournament consists of several matches, where the scores of past matches may affect future matches’ scores.

			At the beginning of the match, every player starts with an empty track record. 
			Ninja wants to calculate the final score for a player. So, given a list of strings, ‘MATCHRESULT’, 
			where ‘MATCHRESULT[i]’ is the ‘i’th operation Ninja must apply to the track record and is one of the following:

				1) An integer “A”: Introduce a new score of ‘A’ on the track record.
				2) "+": Introduce a new score on the track record that is the sum of the previous two scores.
				3) "C": Nullify the previous score, removing it from the track record.
				4) "D": Introduce a new score on the track record that is double the previous score.
			Ninja deduced that this could be easily solved using programming. 
			So, he needs your help to calculate the sum of all the scores present in the track record.

			Note:
			It is guaranteed there will always be a previous score before the “C” and “D” operations and 
			two previous scores before the “+” operation.
			Sample Input 1:
				2
				5
				2 3 + D C
				4
				15 C 10 D
				Sample Output 1:
				10
				30
				Explanation of Sample Output 1:
				Test Case 1 :  
				Given MATCHRESULT = {“2”, “3”, “+”, “D”, “C”}. Initially, TRACKRECORD = {}.
				For “2”, Introducing 2 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {2}.
				For “3”, Introducing 3 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {2, 3}.
				For “+”, Introducing the sum of 2 and 3, i.e., 5 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {2, 3, 5}.
				For “D”, Introducing the double of 5, i.e., 10 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {2, 3, 5, 10}.
				For “C”, Nullifying the score 10 and thus removing it from the ‘TRACKRECORD’. Therefore, TRACKRECORD = {2, 3, 5}.
				Sum of all the scores = 2 + 3 + 5 = 10.


				Test Case 2 :     
				Given MATCHRESULT = {“15”, “C”, “10”, “D”}. Initially, TRACKRECORD = {}.
				For “15”, Introducing 15 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {15}.
				For “C”, Nullifying the score 15 and thus removing it from the ‘TRACKRECORD’. Therefore, TRACKRECORD = {}.
				For “10”, Introducing 10 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {10}.
				For “D”, Introducing the double of 10, i.e., 20 on the ‘TRACKRECORD’. Therefore, TRACKRECORD = {10, 20}.
				Sum of all the scores = 10 + 20 = 30.
				Sample Input 2:
				2
				6
				7 D 2 + C D
				7
				15 48 13 + D D C
				Sample Output 2:
				27
				259

		#include <bits/stdc++.h> 
		int calculateScore(vector<string> &matchResult, int n) {
			stack<int> s;
			for (int i = 0; i < n; i++) {
				if(matchResult[i] != "+" && matchResult[i] != "C" && matchResult[i] != "D"){
					s.push(stoi(matchResult[i]));
				}else{
					if(matchResult[i] == "+"){
						int first = s.top();
						s.pop();

						int newNum = s.top() + first;
						s.push(first);
						s.push(newNum);
					}else if(matchResult[i] == "D"){
						s.push(s.top() * 2);
					}else{
						s.pop();
					}
				}
			}

			int sum =0;
			while(!s.empty()){
				sum += s.top();
				s.pop();
			}
			return sum;
		}

	277) Beautiful Index:
		Problem statement:
			You are given an array ‘A’ of length ‘N’. 
			You say an index ‘i’ is beautiful if the sum of the first ‘i - 1’ 
			elements of the array ‘A’ equals the sum of the last ‘N - i’ elements of the array ‘A’, 
			where ‘i’ is in 1-based indexing. Now you wonder which is the leftmost beautiful index.

			Note:If you select the first index, then the sum of the prefix will be ‘0’, 
				and if you select the last index, then the sum of the suffix will be ‘0’.

			Note:You have to print the index in 1-based indexing.

			For example:
				Let’s say the array ‘A’ = [1, 3, 1, 5], then if we select index ‘2’, 
				the sum of the prefix is ‘1’, and the sum of the suffix is 1 + 5 = 6. 
				Since the sum is not the same, hence index ‘2’ is not a beautiful index.
			Constraints -
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^5 
				-10^9 <= A[i] <= 10^9, for 1 <= i <= ‘N’
				Note: Sum of ‘N’ over all test cases does not exceed 10^5.
				Time Limit: 1 sec

			Sample Input-1
				2
				3
				1 1 1
				3
				1 2 3
				Sample Output-1
				2
				-1
				Explanation for Sample Input 1:
				For test case 1:
				Index ‘2’ is the leftmost beautiful index. The left sum is 1 and the right sum is also 1.
				For test case 2:
				No index is beautiful.
				Sample Input -2
				2
				6
				1 7 3 6 5 6
				3
				2 1 -1
				Sample Output -2
				4
				1

		//Not Optimized:
			#include <bits/stdc++.h> 
			int beautifulIndex(int N, vector<int> A) {
				if(N == 1)
					return 1;
				
				for(int i=0; i<N-1; i++){
					int rightSideSum = accumulate(A.begin(), A.begin()+i, 0);
					int leftSideSum = accumulate(A.begin()+i+1, A.end(), 0);

					if(rightSideSum == leftSideSum)
						return i+1;
				}
				return -1;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int beautifulIndex(int N, vector<int> A) {

				int leftSum = 0;
				
				// int TotalSum = accumulate(A.begin(), A.end(), 0);
				// int rightSum = TotalSum;
				// Or

				int rightSum = accumulate(A.begin(), A.end(), 0);
				
				for(int i=0; i<N; i++){
					rightSum -= A[i];

					if(rightSum == leftSum)
						return i+1;
					
					leftSum += A[i];
				}

				return -1;
			}
	
	278) Count Special Numbers:
		Problem statement:
			A positive integer is called a Special Number if all the digits in 
			its decimal representation lie between 1 to 5 (both inclusive). 
			For example : 
				245, 312, etc. are some special numbers, 
				whereas 340, 17, 0, etc. are some non-special numbers.
			Given an integer 'N' . Your task is to find how many special numbers lie between 1 to N.

			Sample Input 1 :
				2
				7
				13
				Sample Output 1 :
				5 
				8
				Explanation for Sample Input 1 :
				For the first test case : 
				All the special numbers that are smaller than 7 are [ 1, 2, 3, 4, 5 ]. 
				Hence, the answer is 5 in this case.

				For the second test case : 
				All the special numbers that are smaller than 13 are [ 1, 2, 3, 4, 5, 11, 12, 13 ]. 
				Hence, the answer is 8 in this case.
				Sample Input 2 :
				2
				2
				20
				Sample Output 2 :
				2
				10

		#include <bits/stdc++.h> 
		int countSpecialNumbers(int n) {
			vector<int> v(n);

			for(int i=0; i<n; i++)
				v[i] = i+1;
			
			vector<int> holder;

			for(int i=0; i<n; i++){
				int crntDigit = v[i];
				int pushable = 1;           //pushable means crntDigit contains digit which lies in between 1 to 5.

				while(crntDigit > 0){
					int lastDigit = crntDigit % 10;
					
					if(1 > lastDigit || lastDigit > 5){
						pushable = 0;           //unable to push now, coz crntDigit contains any one digit which is not in-between 1 to 5.
						break;
					}
					crntDigit /= 10;
				}

				if(pushable)
					holder.push_back(crntDigit);
			}
			return holder.size();
		}

		//Or Another Approach: (Concise)
			#include <bits/stdc++.h> 
			bool checkSpecialNumber(int k) {

				// Iterating through all digits
				while (k > 0) {
					int rem = k % 10;
					if (rem == 0 or rem > 5)
						return false;

					k /= 10;
				}
				return true;
			}

			int countSpecialNumbers(int n) {
				int specialNumbersFound = 0;

				// Iterating through all numbers from 1 to n
				for (int i = 1; i <= n; i++)
					if (checkSpecialNumber(i))
						specialNumbersFound++;

				// Returning the final answer
				return specialNumbersFound;
			}
	
		//Or Detailed:
			bool checkSpecialNumber(int k)
			{
				// Iterating through all digits
				while (k > 0)
				{
					int rem = k % 10;
					if (rem == 0 or rem > 5)
					{
						return false;
					}

					k /= 10;
				}
				return true;
			}

			int countSpecialNumbers(int n)
			{
				int specialNumbersFound = 0;

				// Iterating through all numbers from 1 to n
				for (int i = 1; i <= n; i++)
				{
					if (checkSpecialNumber(i))
					{
						specialNumbersFound++;
					}
				}

				// Returning the final answer
				return specialNumbersFound;

			}
		
	279) Determine if String Halves Are Alike:
		Problem Statement:
			You are given a string s of even length. 
			Split this string into two halves of equal lengths, and let a be the first half and b be the second half.
			Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U').
			Notice that s contains uppercase and lowercase letters.

			Return true if a and b are alike. Otherwise, return false.

			Example 1:
				Input: s = "book"
				Output: true
				Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel. Therefore, they are alike.

			Example 2:
				Input: s = "textbook"
				Output: false
				Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2. Therefore, they are not alike.
				Notice that the vowel o is counted twice.
		
			Constraints:
				2 <= s.length <= 1000
				s.length is even.
				s consists of uppercase and lowercase letters.

		class Solution {
			private:
			int vowelCounter(string s){
				int cnt=0;
				for(char c: s)
					if(c == 'a' || c == 'e' || c == 'i' || c == 'o' ||c == 'u')
						cnt++;
				return cnt;
			}
			public:
			bool halvesAreAlike(string s) {
				//convert s to lowercase string
				transform(s.begin(), s.end(), s.begin(), ::tolower);

				string s1 = s.substr(0, s.length()/2);
				string s2 = s.substr(s.length()/2);

				//counting vowels in each string
				if( vowelCounter(s1) == vowelCounter(s2))
					return 1;
				return 0;
			}
		};

		//or concise
			class Solution {
				//private:				//its not necessary to keep private specifire here, if you remove it also program works fine
										//or else if you brings that public specifire which is just above halvesAreAlike function that's also fine.
				public:										
				int vowelCounter(string s){
					int cnt=0;
					for(char c: s)
						if(c == 'a' || c == 'e' || c == 'i' || c == 'o' ||c == 'u')
							cnt++;
					return cnt;
				}
				public:
				bool halvesAreAlike(string s) {
					//convert s to lowercase string
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					//counting vowels in each string
					if( vowelCounter(s.substr(0, s.length()/2)) == vowelCounter(s.substr(s.length()/2)) )
						return 1;
					return 0;

					//or
					// return ( vowelCounter(s.substr(0, s.length()/2)) == vowelCounter(s.substr(s.length()/2)) );
				}
			};
	
		//or Another approach:
			class Solution {
				public:
				bool halvesAreAlike(std::string s) {
					unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
					int vowelsCount = 0;
					int midIndex = s.length() / 2;

					for (int i = 0; i < midIndex; i++) {
						char charA = s[i];
						char charB = s[midIndex + i];
						if (vowels.count(charA)) vowelsCount++;
						if (vowels.count(charB)) vowelsCount--;
					}

					return vowelsCount == 0;
				}
			};
	
	280) Reverse First K elements of Queue:
		Problem Statement:
			Given an integer K and a queue of integers, 
			we need to reverse the order of the first K elements of the queue, 
			leaving the other elements in the same relative order.
			Only following standard operations are allowed on queue.

			enqueue(x) : Add an item x to rear of queue
			dequeue() : Remove an item from front of queue
			size() : Returns number of elements in queue.
			front() : Finds front item.
			Note: The above operations represent the general processings. 
			In-built functions of the respective languages can be used to solve the problem.

			Example 1:
				Input:
				5 3
				1 2 3 4 5
				Output: 
				3 2 1 4 5
				Explanation: 
				After reversing the given
				input from the 3rd position the resultant
				output will be 3 2 1 4 5.

			Example 2:
				Input:
				4 4
				4 3 2 1
				Output: 
				1 2 3 4
				Explanation: 
				After reversing the given
				input from the 4th position the resultant
				output will be 1 2 3 4.

			Your Task:
				Complete the provided function modifyQueue() that takes queue and K as parameters 
				and returns a modified queue. The printing is done automatically by the driver code.

			Expected Time Complexity : O(N)
			Expected Auxiliary Space : O(K)

			Constraints:
				1 <= K <= N <= 10^5

		class Solution {
			public:
			// Function to reverse first k elements of a queue.
			queue<int> modifyQueue(queue<int> q, int k) {
				stack<int> st;
				for(int i=0; i<k; i++){
					st.push(q.front());
					q.pop();
				}
				
				queue<int> qt;
				
				for(int i=0; i<k; i++){
					qt.push(st.top());
					st.pop();
				}
				
				while(!q.empty()){
					qt.push(q.front());
					q.pop();
				}
				return qt;
			}
		};

		//without using extra space (in-place approach)
			class Solution {
			public:
				// Function to reverse first k elements of a queue.
				queue<int> modifyQueue(queue<int> q, int k) {
					stack<int> st;
					
					int remainingElement = q.size() - k;
					
					//inserting first k element into stack, to reverse them
					for(int i=0; i<k; i++){
						st.push(q.front());
						q.pop();
					}
					
					//inserting first k element into same queue in reverse order
					while(!st.empty()){
						q.push(st.top());
						st.pop();
					}
					
					//inserting remainingElement at the end of queue & poping the same element from start of queue.
					for(int i=0; i<remainingElement; i++){
						q.push(q.front());
						q.pop();
					}
					return q;
				}
			};

		// Concise:
			class Solution {
				public:
				queue<int> modifyQueue(queue<int> q, int k) {
					stack<int> st;
					int val = q.size() - k;
					
					while(k--){
						st.push(q.front());
						q.pop();
					}
					
					while(!st.empty()){
						q.push(st.top());
						st.pop();
					}
					
					while(val--){
						q.push(q.front());
						q.pop();
					}
					return q;
				}
			};

	281) Periodic String:
		Problem statement
			Given a string ‘S’ find whether the given string is periodic or not.
			A string is said to be periodic if it repeats itself after a certain number of characters 
			and the period of repetition is less than the size of the string.

			For example: Let ‘S’ be “ababab” we can clearly see that this string is periodic as 
			‘ab’ is repeated 3 times to make the string ‘S’.

			Constraints:
				1 <= T <= 50
				1<= S.length<=10^5

			Where 'S.length' denotes the length of string ‘S’.
			The given string consists of lowercase English alphabets only.

			Time limit: 1 sec
			Sample Input 1:
				3
				xxxxxx
				aabbaaabba
				abcba
				Sample Output 1:
				True
				True
				False      
				Explanation of sample input 1 :
				Test Case 1:
				In the first test case, we can clearly see that the 
				string has a repeating string ‘x’ 6 times. So we return true

				Test Case 2:
					In the second test case, we can see that the string ‘aabba’ repeats twice to form the given string. 
					Hence we return true,

				Test Case 3:
					In the third test case, we can see that there is no string which repeats 
					itself to form the given string, hence we return false.

				Sample Input 2:
				2
				vwvnqpnchqik
				ubzumubzumubzumubzum
				Sample Output 2:
				False
				True

		#include <bits/stdc++.h> 
		bool isPeriodic(string s) {
			int n = s.length();

			for(int i=1; i<=n/2; i++){
				bool isPeriod = true;

				for(int j=0; j<n-i; j++){
					if(s[j] != s[j+i]){
						isPeriod = false;
						break;
					}
				}

				if(isPeriod)
					return 1;
			}
			return 0;
		}	
	
	282) Minimum Number of Steps to Make Two Strings Anagram:
		Problem Statement:
			You are given two strings of the same length s and t. 
			In one step you can choose any character of t and replace it with another character.
			Return the minimum number of steps to make t an anagram of s.

			An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.

			Example 1:
				Input: s = "bab", t = "aba"
				Output: 1
				Explanation: Replace the first 'a' in t with b, t = "bba" which is anagram of s.

			Example 2:
				Input: s = "leetcode", t = "practice"
				Output: 5
				Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.

			Example 3:
				Input: s = "anagram", t = "mangaar"
				Output: 0
				Explanation: "anagram" and "mangaar" are anagrams. 

			Constraints:
				1 <= s.length <= 5 * 104
				s.length == t.length
				s and t consist of lowercase English letters only.
	
		class Solution {
			public:
			int minSteps(string s, string t) {
			
				//first count the char in string s
				map<char, int> FreqS;
				for(int i=0; i<s.length(); i++)
					FreqS[s[i]]++;
				
				//second count the char in string t
				map<char, int> FreqT;
				for(int i=0; i<t.length(); i++)
					FreqT[t[i]]++;

				int cnt=0;
				for(auto itr: FreqS){
					if(itr.second == FreqT[itr.first])
						continue;
					else if(itr.second > FreqT[itr.first])
						cnt += itr.second - FreqT[itr.first];
					else
						cnt;        //no need of else

				}
				return cnt;
			}
		};

		//or
			class Solution {
				public:
				int minSteps(string s, string t) {
				
					//first count the char in string s
					map<char, int> FreqS;
					for(int i=0; i<s.length(); i++)
						FreqS[s[i]]++;
					
					//second count the char in string t
					map<char, int> FreqT;
					for(int i=0; i<t.length(); i++)
						FreqT[t[i]]++;

					int cnt=0;
					for(auto itr: FreqS){
						if(itr.second > FreqT[itr.first])
							cnt += itr.second - FreqT[itr.first];
					}
					return cnt;
				}
			};

		//or without using Map (another approach)
			class Solution {
				public:
				int minSteps(string s, string t) {
					vector<int> FreqS (26, 0);
					vector<int> FreqT (26, 0);
					
					//counting the char repetition in S
					for(int i=0; i<s.length(); i++)
						FreqS[s[i] - 'a']++;

					//counting the char repetition in T
					for(int i=0; i<s.length(); i++)             //both string having same length so we kept i<s.length() here.
						FreqT[t[i] - 'a']++;

					int cnt=0;
					for(int i=0; i<26; i++)
						if(FreqS[i] > FreqT[i])
							cnt += (FreqS[i] - FreqT[i]);

					return cnt;
				}
			};

		//Optimized:
			class Solution {
				public:
				int minSteps(string s, string t) {
					int occ[26] = {0};
					for (auto it : s) occ[it-'a'] ++;
					for (auto it : t) occ[it-'a']--;

					int res = 0;
					for (int i = 0; i < 26; i++) res += abs(occ[i]);

					return res / 2;
				}
			};

			//below code is just for reference, decreases the execution time the below code.
			auto init = []() {
				ios::sync_with_stdio(false);
				cin.tie(nullptr);
				cout.tie(nullptr);
				return 'c';			//you can return anything return 'v', return 'a', or you can use 'return 0' also.
			}();

	283) GCD Sum:
		Problem statement
			Consider all numbers from 1 to ‘N’, 
			your task is to find the sum of gcd of all pairs (i, j) such that 1 <= i < j <= N.
			For example for N = 3, all pairs are { (1, 2), (1, 3), (2, 3) }.
			Note :
				Gcd of two numbers (X, Y) is defined as the largest integer that divides both ‘X’ and ‘Y’. 
			Sample Input 1 :
				2
				3
				5
				Sample Output 1 :
				3
				11
				Explanation Of Sample Input 1 :
				Test case 1:
				gcd(1, 2) + gcd(1, 3) +  gcd(2, 3) = 1 + 1 + 1 = 3.

				Test case 2:
				gcd(1, 2) + gcd(1, 3) +  gcd(1, 4) + gcd(1, 5) +
				gcd(2, 3) + gcd(2, 4) + gcd(2, 5) +
				gcd(3, 4) + gcd(3, 5) +
				gcd(4, 5)  = 11.
				Sample Input 2 :
				1
				1
				Sample Output 2 :
				0
				Explanation Of Sample Input 2 :
				Test case 1:
				As there is no possible Paris, so the gcd sum is 0.

		//Not Optimized:
			#include<algorithm>     //this is for to built-in Function of GCD
			long long gcdSum(int n){
				long long sm=0;
				for(int i=1; i<=n; i++)
					for(int j=i+1; j<=n; j++)
						sm += __gcd(i,j);
				return sm;
			}

	284) Maximum Difference
		Problem statement
			You are given an integer array ‘arr’ of size ‘N’. 
			Your task is to find the maximum difference between two consecutive elements in the sorted form of the array ‘arr’.

			If the ‘arr’ contains less than two elements, return 0.
			For example:
				You are given arr = {1, 3, 8, 6, 7}, then our answer will be 3. 
				Sorted form of arr = {1, 3, 6, 7, 8}. The maximum absolute difference between two consecutive elements is 6 - 3 = 3, which is the correct answer.
			Constraints:
				1 <= T <= 10 
				1 <= N  <= 10 ^ 6
				0 <= arr[i] <= 10 ^ 9

				Time limit: 1 sec
			Note:
				You do not need to input or print anything, as it has already been taken care of. 
				Just implement the given function.

			Sample Input 1:
				2
				5
				1 3 8 6 7
				5
				0 6 4 8 9
				Sample Output 1:
				3
				4
				Explanation:
				For the first test case, you are given arr = {1, 3, 8, 6, 7}. Then our answer will be 3. 
				Sorted form of arr = {1, 3, 6, 7, 8}. 
				The maximum absolute difference between two consecutive elements is 6 - 3 = 3, which is the correct answer.

				For the second test case, you are given arr = {0, 6, 4, 8, 9}. Then our answer will be 4. 
				Sorted form of arr = {0, 4, 6, 8, 9}. 
				The maximum absolute difference between two consecutive elements is 4 - 0 = 4, which is the correct answer.
				Sample Input 2:
				2
				4
				1 3 2 4
				5
				4 4 1 9 10
				Sample Output 2:
				1
				5
	
		#include <bits/stdc++.h>
		int maxDifference(int n, vector<int> &arr) {
			if(arr.size() < 2)
				return 0;

			sort(arr.begin(), arr.end());

			int mx = INT_MIN;
			for(int i=1; i<arr.size(); i++)
				if(abs(arr[i-1]-arr[i]) > mx)
					mx = abs(arr[i-1]-arr[i]);
			return mx;    
		}

	285) Maximum Difference:
		Problem statement
			You are given an array 'ARR' of the 'N' element. 
			Your task is to find the maximum difference between any of the two elements from 'ARR'.
			If the maximum difference is even print “EVEN” without quotes. 
			If the maximum difference is odd print “ODD” without quotes.

			For example:
				Given 'ARR' = [1, 10, 5, 2, 8, 1 ] , answer is "ODD".
				Here the maximum difference is between 10 and 1, 10 - 1 = 9
			Constraints:
				1 <= T <= 100
				1 <= N <= 5000 
				1 <= ARR[i] <= 10 ^ 9

			where ‘N’ is the length of the array 'ARR', and 'ARR[i]' is an element of the 'ARR' respectively.
			Time limit: 1 sec.
			Sample Input 1:
				2
				4
				2 9 3 4
				6
				1 1 1 1 1 1 
				Sample Output 1:
				ODD
				EVEN
				Explanation of Sample Input 1:
				For the first test case, the maximum difference is 7, between 9 and 2.

				For the second test case, all elements are the same, the maximum difference is 0.
				Sample Input 2:
				2
				2
				567 11
				1
				28
				Sample Output 2:
				EVEN
				EVEN 

		#include <bits/stdc++.h> 
		string maximumDifference(int n, vector<int>& arr) {
			int mx = *max_element(arr.begin(), arr.end());
			int mn = *min_element(arr.begin(), arr.end());
			
			if((mx-mn) & 1)
				return "ODD";
			return "EVEN";
		}

		// Not Optimized:
			#include <bits/stdc++.h> 
			string maximumDifference(int n, vector<int>& arr) {
				sort(arr.begin(), arr.end());
				return ((arr[arr.size()-1] - arr[0]) & 1) ? "ODD" : "EVEN";
				// return ((arr.back() - arr[0]) & 1) ? "ODD" : "EVEN";
			}
	
	286) Find duplicate rows in a binary matrix:
		Problem Statement:
			Given a boolean matrix of size RxC where each cell contains either 0 or 1,
			find the row numbers (0-based) of row which already exists or are repeated.

			Example 1:
				Input:
				R = 2, C = 2
				matrix[][] = {{1, 0},
						{1, 0}}
				Output: 
				1
				Explanation:
				Row 1 is duplicate of Row 0.

			Example 2:
				Input:
				R = 4, C = 3
				matrix[][] = {{ 1, 0, 0},
						{ 1, 0, 0},
						{ 0, 0, 0},
						{ 0, 0, 0}}
				Output: 
				1 3 
				Explanation:
				Row 1 and Row 3 are duplicates of Row 0 and 2 respectively. 

			Your Task:
				You dont need to read input or print anything. 
				Complete the function repeatedRows() that takes the matrix as 
				input parameter and returns a list of row numbers which are duplicate rows.

			Expected Time Complexity: O(R * C)
			Expected Auxiliary Space: O(R * C)

			Constraints:
				1 ≤ R, C ≤ 10^3
				0 ≤ matrix[i][j] ≤ 1

		class Solution {
			public:
			vector<int> repeatedRows(vector<vector<int>> &matrix, int M, int N) {
				vector<string> holder;
				vector<int> ans;
				
				for(int i=0; i<M; i++){
					string s;
					for(int j=0; j<N; j++){
						s += to_string(matrix[i][j]);
					}

					/*
						// or for above for loop you can use below syntax without '{ }' braces.
						for(int j=0; j<N; j++)
							s += to_string(matrix[i][j]);
					
					*/

					if(find(holder.begin(), holder.end(), s) != holder.end())
						ans.push_back(i);
					else
						holder.push_back(s);
					
					/*
						//or for above if-else syntax you can use below syntax which is concise.

						if(find(holder.begin(), holder.end(), s) != holder.end()) ans.push_back(i);
						else holder.push_back(s);
					*/
				}
				return ans;
			} 
		};

		// or other approach:
			class Solution {   
				public:
				vector<int> repeatedRows(vector<vector<int>> &matrix, int M, int N) {
					vector<int> ans;
					for(int row=0; row<M; row++){
						for(int j=0; j<row; j++){
							int z=0;
							for(z=0; z<N; z++){
								if(matrix[row][z] != matrix[j][z])
								break;
							}
							if(z == N){
								ans.push_back(row);
								break;
							}
						}
					}
					return ans;
				} 
			};

	287) Determine if Two Strings Are Close:
		Problem Statement:
			Two strings are considered close if you can attain one from the other using the following operations:
			Operation 1: Swap any two existing characters.
			For example, abcde -> aecdb
			Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
			For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
			You can use the operations on either string as many times as necessary.

			Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.			

			Example 1:
				Input: word1 = "abc", word2 = "bca"
				Output: true
				Explanation: You can attain word2 from word1 in 2 operations.
				Apply Operation 1: "abc" -> "acb"
				Apply Operation 1: "acb" -> "bca"

			Example 2:
				Input: word1 = "a", word2 = "aa"
				Output: false
				Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.

			Example 3:
				Input: word1 = "cabbba", word2 = "abbccc"
				Output: true
				Explanation: You can attain word2 from word1 in 3 operations.
				Apply Operation 1: "cabbba" -> "caabbb"
				Apply Operation 2: "caabbb" -> "baaccc"
				Apply Operation 2: "baaccc" -> "abbccc"

			Constraints:
				1 <= word1.length, word2.length <= 105
				word1 and word2 contain only lowercase English letters.
	
		class Solution {
			public:
			bool closeStrings(string word1, string word2) {
				
				//this below three lines of code will increase the efficiency, decreases time complexity
				ios_base::sync_with_stdio(false);
				cin.tie(nullptr);
				cout.tie(nullptr);

				//if both strings are different in length then return false
				if(word1.length() != word2.length())
					return 0;
				
				//creating set for word1
				set<char> set_word1(word1.begin(), word1.end());

				//creating set for word2
				set<char> set_word2(word2.begin(), word2.end());

				if(set_word1.size() != set_word2.size())
					return 0;

				//map counting char for word1
				map<char, int> map_word1;
				for(int i=0; i<word1.length(); i++)
					map_word1[word1[i]]++;
				
				//map counting char for word1
				map<char, int> map_word2;
				for(int i=0; i<word2.length(); i++)
					map_word2[word2[i]]++;
				
				//vector for word1
				vector<int> valueWord1;
				vector<char> keyWord1;
				for(auto itr: map_word1){
					keyWord1.push_back(itr.first);
					valueWord1.push_back(itr.second);
				}
				
				//vector for word2
				vector<int> valueWord2;
				vector<char> keyWord2;
				for(auto itr: map_word2){
					keyWord2.push_back(itr.first);
					valueWord2.push_back(itr.second);
				}
				
				sort(valueWord1.begin(), valueWord1.end());
				sort(valueWord2.begin(), valueWord2.end());
				sort(keyWord1.begin(), keyWord1.end());
				sort(keyWord2.begin(), keyWord2.end());

				if(valueWord1 == valueWord2 && keyWord1 == keyWord2)
					return 1;
				return 0;
			}
		};
	
		//or Optimized:
			class Solution {
				public:
				bool closeStrings(string word1, string word2) {
					
					ios_base::sync_with_stdio(false);
					cin.tie(NULL);
					cout.tie(NULL);
					int n = word1.length();
					if(word2.length()!=n){
						return false;
					}
					int fre[26]; 
					memset(fre, 0, sizeof(fre));
					int fre2[26];
					memset(fre2, 0, sizeof(fre2));

					for(int i=0;i<n;i++){
						fre[word1[i]-'a']++;
					}
					for(int i=0;i<n;i++){
						fre2[word2[i]-'a']++;
					}
					vector<int>v1,v2;
					for(int i=0;i<26;i++){
						if(fre[i]!=fre2[i]){
							if(fre[i]==0 || fre2[i]==0){
								return false;
							}
						}
						if(fre[i]!=fre2[i]){
							v1.push_back(fre[i]);
							v2.push_back(fre2[i]);
						}
					}
					sort(v1.begin(), v1.end());
					sort(v2.begin(), v2.end());
					int m = v1.size();
					for(int i=0;i<m;i++){
						if(v1[i]!=v2[i]){
							return false;
						}
					}
					return true;
				}
			};
		
	288) Number Game: ❌Pending
		Problem Statement:
			Alice and Bob have invented a new game to play. 
			The rules are as follows-
				First, they get a set of ‘N’ distinct integers. 
				And then they take turns to make the following moves. 
				During each move, either Alice or Bob (the player whose turn is the current) 
				can choose two distinct integers ‘X’ and ‘Y’ from the set, 
				such that the set doesn't contain their absolute difference |X - Y|. 
				Then this player adds integer |X - Y| to the set (so, the size of the set increases by one).

			If the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.

			Constraints :
				1 <= T <= 10
				2 <= N <= 10^5
				1 <= array[i] <= 10^9

			Time Limit : 1 sec
			Sample Input 1 :
				2
				2
				2 3
				2
				5 3
				Sample Output 1 :
				Alice
				Alice
				Explanation of Sample Input 1
				For the first test case, we have, initial set as { 2, 3}. 
				Alice moves first, and the only move she can do is to choose 2 and 3, 
				then to add 1 to the set. The new set is { 1, 2, 3 }. Next Bob moves, 
				there is no valid move anymore, so the winner is Alice.

				For the second test case, we have, initial set as { 3, 5}. Alice moves first, 
				and the only move she can do is to choose 5 and 3, then to add 2 to the set. 
				So, the new set is { 2, 3, 5 }. Next Bob moves, he cannot choose 2 and 5 as | 2 - 5 | = 3
				is already in the set. He chooses 2 and 3 and adds 1 to the set. The new set is { 1, 2, 3, 5 }. 
				Now, Alice can choose 1 and 5 and add 4 to the set. The new set is { 1, 2, 3, 4, 5 }. 
				Next Bob moves, there is no valid move anymore, so the winner is Alice.

				Sample Input 2 :
				3
				2
				2 3
				2
				5 3
				3
				5 6 7
				Sample Output 2 :
				Alice
				Alice
				Bob

		#include <bits/stdc++.h> 
		string gameWinner(vector<int> &arr, int n) {
			int max = *std::max_element(arr.begin(), arr.end());

			int rem = max - n;
			if (rem % 2 != 1)
				return "Bob";
			return "Alice";
		}
	
	289) Find Players With Zero or One Losses:
		Problem statement:
			You are given an integer array matches where matches[i] = [winneri, loseri] 
			indicates that the player winneri defeated player loseri in a match.
			Return a list answer of size 2 where:

			answer[0] is a list of all players that have not lost any matches.
			answer[1] is a list of all players that have lost exactly one match.
			The values in the two lists should be returned in increasing order.

			Note:
				You should only consider the players that have played at least one match.
				The testcases will be generated such that no two matches will have the same outcome.

			Example 1:
				Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
				Output: [[1,2,10],[4,5,7,8]]
				Explanation:
				Players 1, 2, and 10 have not lost any matches.
				Players 4, 5, 7, and 8 each have lost one match.
				Players 3, 6, and 9 each have lost two matches.
				Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].

			Example 2:
				Input: matches = [[2,3],[1,3],[5,4],[6,4]]
				Output: [[1,2,5,6],[]]
				Explanation:
				Players 1, 2, 5, and 6 have not lost any matches.
				Players 3 and 4 each have lost two matches.
				Thus, answer[0] = [1,2,5,6] and answer[1] = [].

			Constraints:
				1 <= matches.length <= 105
				matches[i].length == 2
				1 <= winneri, loseri <= 105
				winneri != loseri
				All matches[i] are unique.

		//Not Optimized:
			class Solution {
				public:
				vector<vector<int>> findWinners(vector<vector<int>>& matches) {
					vector<int> NotLost;
					vector<int> LostOne;

					map<int, int> FreqLost;

					for(int i=0; i<matches.size(); i++)
						FreqLost[matches[i][1]]++;

					for(int i=0; i<matches.size(); i++){
						for(int j=0; j<matches[0].size(); j++){
							if(FreqLost[matches[i][j]] > 1 )
								continue;
							if(FreqLost[matches[i][j]] == 0){
								if(find(NotLost.begin(), NotLost.end(), matches[i][j]) == NotLost.end())
								NotLost.push_back(matches[i][j]);
							}
							else if(FreqLost[matches[i][j]] == 1){
								if(find(LostOne.begin(), LostOne.end(), matches[i][j]) == LostOne.end())
								LostOne.push_back(matches[i][j]);
							}
						}
					}

					sort(NotLost.begin(), NotLost.end());
					sort(LostOne.begin(), LostOne.end());

					return {NotLost,LostOne};
				}
			};
	
		//Optimized:
			class Solution {
				public:
				vector<vector<int>> findWinners(vector<vector<int>>& matches) {

					map<int, int> FreqLost;

					set<int> NotLostSet;
					set<int> OneLostSet;

					for(int i=0; i<matches.size(); i++)
						FreqLost[matches[i][1]]++;

					for(int i=0; i<matches.size(); i++){
						int win = matches[i][0];
						int loss = matches[i][1];

						//for first value
						if(FreqLost[win] == 0)
							NotLostSet.insert(win);
						else if(FreqLost[win] == 1)
							OneLostSet.insert(win);

						//for second value
						if(FreqLost[loss] == 0)
							NotLostSet.insert(loss);
						else if(FreqLost[loss] == 1)
							OneLostSet.insert(loss);
					}

					//converting set to vector
					
					vector<int> NotLost(NotLostSet.begin(), NotLostSet.end());
					vector<int> LostOne(OneLostSet.begin(), OneLostSet.end());

					sort(NotLost.begin(), NotLost.end());
					sort(LostOne.begin(), LostOne.end());

					return {NotLost,LostOne};
				}
			};

			//or
				class Solution {
					public:
					vector<vector<int>> findWinners(vector<vector<int>>& matches) {

						map<int, int> FreqLost;

						set<int> NotLostSet;
						set<int> OneLostSet;

						for(int i=0; i<matches.size(); i++)
							FreqLost[matches[i][1]]++;

						for(int i=0; i<matches.size(); i++){
							for(int j=0; j<matches[0].size(); j++){         //or the default size is 2 so, for(int j=0; j<2; j++)
								if(FreqLost[matches[i][j]] == 0)
									NotLostSet.insert(matches[i][j]);
								else if(FreqLost[matches[i][j]] == 1)
									OneLostSet.insert(matches[i][j]);
							}
						}

						//converting set to vector
						vector<int> NotLost(NotLostSet.begin(), NotLostSet.end());
						vector<int> LostOne(OneLostSet.begin(), OneLostSet.end());

						sort(NotLost.begin(), NotLost.end());
						sort(LostOne.begin(), LostOne.end());

						return {NotLost,LostOne};
					}
				};

	290) Least Greater Element:
		Problem statement
			You are given an array 'ARR' of Integers. 
			Your task is to replace each element of the array with the smallest element, 
			which is strictly greater than that element and is present on the right side 
			of that element in the array i.e. for each valid index ‘i’ replace ARR[i] 
			with the smallest ARR[j] such that ARR[j]>ARR[i] and j>i.

			In case there exists no such element satisfying the above conditions for a particular array element, 
			replace it with -1.

			For example :

				Consider the array ARR = [ 1, 4, 2, 6 ] having 4 elements.
				The array containing the Least Greater Elements for the above array will be [ 2, 6, 6, -1 ].
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^4
				0 <= ARR[i]  <= 10^9

				Where 'T' denotes the number of test cases, 'N' denotes the elements in the array 'ARR', 
				and 'ARR[i]' denotes the 'i'th' element of the array 'ARR'.

				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				5 6 7 2
				3 
				4 3 6
				Sample Output 1 :
				6 7 -1 -1 
				6 6 -1
				Explanation for Sample Input 1 :
				For the first test case : 
				1) For ARR [0] = 5, the least greater element is 6.
				2) For ARR [1] = 6, the least greater element is 7.
				3) For ARR [2] = 7, no least greater element exists. Hence, we will consider -1 here.
				4) For ARR [3] = 2, no least greater element exists. Hence, we will consider -1 here.
				Therefore, the output array is [ 6, 7, -1, -1 ] in this case.

				For the second test case : 
				1) For ARR [0] = 4, the least greater element is 6.
				2) For ARR [1] = 3, the least greater element is 6.
				3) For ARR [2] = 6, no least greater element exists. Hence, we will consider -1 here.
				Therefore, the output array is [ 6, 6, -1 ] in this case.
				Sample Input 2 :
				2
				3
				6 2 6
				4
				5 6 1 4
				Sample Output 2 :
				-1 6 -1
				6 -1 4 -1

		#include <bits/stdc++.h> 
		vector<int> leastGreaterElement(vector<int> &arr) {
			vector<int> ans (arr.size(), -1);
			for(int i=0; i<arr.size()-1; i++){
				int minValue=-1;
				int j;
				for(j=i+1; j<arr.size(); j++){
					if(arr[i] < arr[j]){
						minValue = arr[j];
						break;
					}
				}
				for(j; j<arr.size(); j++){
					if(arr[i] < arr[j]){
						minValue = min(minValue,arr[j]);
					}
				}
				ans[i] = minValue;
			}
			return ans;
		}

		//or
			#include <bits/stdc++.h> 
			vector<int> leastGreaterElement(vector<int> &arr) {
				vector<int> ans(arr.size(), -1);

				for (int i = 0; i < arr.size() - 1; ++i) {
					int minValue = -1;

					for (int j = i + 1; j < arr.size(); ++j) {
						if (arr[i] < arr[j]) {
							minValue = (minValue == -1) ? arr[j] : min(minValue, arr[j]);
						}
					}
					ans[i] = minValue;
				}
				return ans;
			}

	291) Add Two Fractions:
		Problem statement
			You’re given two fractions, a/b, and c/d. 
			Your task is to add these two fractions and print this answer in the simplest form.

			Constraints :
				1 <= T <= 10 ^ 4
				1 <= a,b,c,d <= 10 ^ 9
				Time Limit: 1 sec

				Where 'T' denotes the number of test cases, 'a', 'b', 'c' and 'd' denote the integers given as input in the problem.
			Sample Input 1 :
				1
				5 7 4 9
				Sample Output 1 :
				73 63
				Explanation of Sample Input 1 :
				Sum of 5/7 + 4/9 = 73/63, which is already in its simplest form because we cannot reduce it further.
				Sample Input 2 :
				1
				1 500 2 1500
				Sample Output 2 :
				1 300
				Explanation of Sample Input 2 :
				Sum of 1/500 + 2/1500 = 5/1500, which after reducing in simplest form becomes 1/300.

		#include <bits/stdc++.h> 
		vector<long long int> addFraction(long long int a,long long int b, long long int c,long long int d) {
			vector<long long int> ans;

			long long numerator = ((a*d) + (b*c));
			long long denom = (b*d);

			long long fact = __gcd(numerator, denom);

			return {numerator/ fact, denom/ fact};
		}

	292) No Adjacent Same:
		Problem statement
			You are given a 32-bit integer 'N'. 
			At the right of the leftmost set bit, your task is to check if there are no two adjacent bits that are the same.

			For Example :
			42 is valid because it's binary representation '101010' has no two adjacent bits that are the same.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^9
				Time Limit: 1 sec

			Sample Input 1:
				2
				21
				31
				Sample Output 1:
				true
				false
				Explanation For Sample Input 1:
					In example 1, binary representation of 21 is '10101'. 
					Since, no two adjacent bits are the same here, it is valid.
				
					In example 2, binary representation of 31 is ‘11111’. 
					All the digits of binary representation are the same, hence it is not valid.
				Sample Input 2:
				2
				20
				85
				Sample Output 2:
				false
				true
				Explanation For Sample Input 2:
					In example 1, binary representation of 20 is '10100'. 
					Since, the 0-th and 1-st digits of the binary number are the same, it is invalid.

					In example 2, binary representation of 85 is ‘1010101’. 
					Since, no two adjacent bits are the same here, it is valid.

		#include <bits/stdc++.h> 
		bool checkBits(unsigned int n) {
			string s = bitset<32>(n).to_string();

			//removing the leading zero's 
			if(s.find('1') != string::npos)
				s = s.substr(s.find('1'));
			
			// or
			// while(s[0] == '0')
			//     s.erase(s.begin());
			
			for(int i=1; i<s.length(); i++)
				if(s[i] == s[i-1])
					return 0;
			return 1;
		}

	293) Unique Number of Occurrences:
		Problem Statement:
			Given an array of integers arr, 
			return true if the number of occurrences of each value in the array is unique or false otherwise.
			Example 1:
				Input: arr = [1,2,2,1,1,3]
				Output: true
				Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

			Example 2:
				Input: arr = [1,2]
				Output: false

			Example 3:
				Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
				Output: true

			Constraints:
				1 <= arr.length <= 1000
				-1000 <= arr[i] <= 1000
		
		Flowchart:
			[Start] --> 
				[Initialize Freq map] --> [Loop over arr] --> [Count occurrences]

				[Loop Complete] --> [Initialize valueHolder vector] --> [Initialize itr]

				[Loop over Freq] --> [Store occurrences in valueHolder] --> [Increment itr]

				[Sort valueHolder] --> [Loop over sorted valueHolder] --> [Check for duplicates]

				[Duplicate Found] --> [Return 0 (false)]

				[No Duplicate] --> [Return 1 (true)]
			[End]
		
		class Solution {
			public:
			bool uniqueOccurrences(vector<int>& arr) {
				//counting the occurrences
				map<int, int> Freq;
				for(int i=0; i<arr.size(); i++)
					Freq[arr[i]]++;
				
				//storing the occurrences values
				vector<int> valueHolder;
				// for(auto i : Freq)
				//     valueHolder.push_back(i.second);

				//or
				// for (std::map<int, int>::iterator i = Freq.begin(); i != Freq.end(); ++i)
				//     valueHolder.push_back(i->second);

				
				//or
				map<int, int> :: iterator itr = Freq.begin();
				while(itr != Freq.end())
					valueHolder.push_back(itr->second),
					itr++;
				
				//sorting vector valueHolder
				sort(valueHolder.begin(), valueHolder.end());
				for(int i=1; i<valueHolder.size(); i++)
					if(valueHolder[i-1] == valueHolder[i])
						return 0;
				
				return true;
			}
		};

		//optimized:
			class Solution {
				public:
				bool uniqueOccurrences(vector<int>& arr) {
					//counting the occurrences
					map<int, int> Freq;
					for(int x: arr)
						Freq[x]++;
					
					set<int> s;

					//this below line to insert all the value of Freq map into set s.
					// transform(Freq.begin(), Freq.end(), inserter(s, s.end()), [](auto pair) {return pair.second; });
					//or
					for(auto a: Freq)
						s.insert(a.second);

					return Freq.size() == s.size();
				}
			};

	294) Divide String:
		Problem statement
			Ninja has been given a string ‘WORD’ containing lower case alphabets. 
			Ninja wants to know all the strings by dividing ‘WORD’ into ‘N’ strings of equal length.

			For Example:
			For ‘WORD’ =  “abcdefgh”, ‘N’ = 2. Following are the 2 strings of length 4.
			“abcd”
			“efgh”
			Can you help Ninja to get all the strings from ‘WORD’ by dividing them into equal parts?
			Constraints:
				1 <= ‘T’ <= 100
				‘WORD’ = Lower case english alphabet
				1 <= |WORD| <= 2000
				1 <= ‘N’ <= |WORD|

				Time Limit: 1 second
			Sample Input 1:
				2
				asdfghjkl 3
				codingninjas 5
				Sample Output 1:
				asd fgh jkl
				Explanation For Sample Output 1:
				For the first test case:
				Given ‘WORD’ = “asdfghjkl” can be divided into 3 strings each of length 3. 

				Following are the possible strings of length 3.
				1. “asd”
				2. “fgh”
				3. “jkl”  

				For the second test case:
				Given ‘WORD’ = “codingninjas”, it is impossible to divide this ‘WORD’ into 5 strings of equal length. 

				So we return an empty array/list.
				Sample Input 2:
				2   
				a 1
				code 4
				Sample Output 2:
				a
				c o d e

		#include <bits/stdc++.h> 
		vector<string> divideString(string &word, int n) {
			vector<string> ans;
			if(word.length() % n != 0)
				return ans;
			
			int value = word.length() / n;
			int i=0;
			
			while(word[i] != '\0') {
				string s;
				int temp = value;

				while(temp--)
					s += word[i++];
				ans.push_back(s);
			}
			return ans;
		}
	
	295) Minimum Sum Subarray Of Given Size:
		Problem statement
			You have been given an array 'ARR' of integers consisting of ‘N’ integers and a positive integer ‘K’. 
			Your task is to find a subarray(contiguous) of size ‘K’ such that the sum of its elements is minimum.

			Note :
			You can assume that the value of ‘K’ will always be less than or equal to ‘N’. So, the answer will always exist.
			Constraints :
				1 <= N <=  10^5
				1 <= K <= N 
				-10^5 <= ARR[i] <= 10^5

				Time Limit: 1sec
			Sample Input 1 :
				8 3
				10 4 2 5 6 3 8 1
				Sample Output 1 :
				11
				Explanation Of Sample Input
				All subarrays of size 3 and their respective sums are-
				{10, 4, 1} : sum → 10+4+1 = 15
				{4, 2, 5} : sum → 4+2+5 = 11
				{2, 5, 6} : sum → 2+5+6 = 13
				{5, 6, 3} : sum → 5+6+3 = 14
				{6, 3, 8} : sum → 6+3+8 = 17
				{3, 8, 1} : sum → 3+8+1 = 12

				The subarray with a minimum sum of 11 is {4, 2, 5}.
				Sample Input 2 :
				8 4
				1 -4 2 10 -2 3 1 0 -20
				Sample Output 2 :
				2

		#include <bits/stdc++.h> 
		int minSubarraySum(int arr[], int n, int k) {
			int sum = INT_MAX;
			for(int i=0; i<= n-k; i++){
				int v = k, j= i, crntSum=0;
				while(v--)
					crntSum += arr[j++]; 
				sum = min(crntSum, sum);   
			}
			return sum;
		}

		// or
			#include <bits/stdc++.h> 
			int minSubarraySum(int arr[], int n, int k) {
				int minValue = INT_MAX;

				for(int i=0; i<=(n-k); i++){
					int itr = i+k;
					int curValue=0;
					for(int j=i; j <itr; j++)
						curValue += arr[j];
					
					minValue = min(minValue, curValue);
				}
				return minValue;
			}
	
		// Optimized:
			#include <bits/stdc++.h> 
			int minSubarraySum(int arr[], int n, int k) {
				int minValue=0;
				for(int i=0; i<k; i++)
					minValue += arr[i];
				
				int curValue = minValue;
				for(int i=k; i<n; i++){
					curValue -= arr[i-k];
					curValue += arr[i];
					minValue = min(minValue, curValue);
				}
				return minValue;
			}

	296) Greatest Common Divisor
		 	Problem statement
				You are given two numbers, ‘X’ and ‘Y’. 
				Your task is to find the greatest common divisor of the given two numbers.
				The Greatest Common Divisor of any two integers is the largest number that divides both integers.
				For Example:
					You are given ‘X’ as 20 and ‘Y’ as 15. The greatest common divisor, 
					which divides both 15 and 20, is 5. Hence the answer is 5.
				Constraints:
					1 <= T <= 10
					1 <= X, Y <= 10^9
				Sample Input 1:
					2
					20 15
					8 32
					Sample Output 1:
					5
					8
					Explanation:
					For the first test case, the greatest common divisor which divides both 15 and 20 is 5. 
					Hence the answer is 5.

					For the second test case, the greatest common divisor which divides both 8 and 32 is 8. 
					Hence the answer is 8.
					Sample Input 2:
					2
					98 56
					36 60
					Sample Output 2:
					14
					12

			#include <bits/stdc++.h> 
			int findGcd(int a, int b) {
				while(a % b != 0){
					int temp = a;
					a = b;
					b = temp % b;
				}
				return b;
			}

			//or
			#include <bits/stdc++.h> 
			int findGcd(int a, int b) {
				if(b == 0)
					return a;
				return findGcd(b, a % b);
			}

	297) Find Minimum in Rotated Sorted Array:
		Problem statement
			You are given an array 'arr' of size 'n' having unique elements that has 
			been sorted in ascending order and rotated between 1 and 'n' times which is unknown.
			The rotation involves shifting every element to the right, 
			with the last element moving to the first position. 
			For example, if 'arr' = [1, 2, 3, 4] was rotated one time, 
			it would become [4, 1, 2, 3].

			Your task is to find the minimum number in this array.
			Note :
				All the elements in the array are distinct. 

			Example :
				Input: arr = [3,4,5,1,2]
				Output: 1
				Explanation: The original array was [1,2,3,4,5] and it was rotated 3 times.

			Sample Input 1 :
				4
				3 4 1 2   
				Sample Output 1 :
				1

				Explanation of Sample Input 1 :
				The original array was [1, 2, 3, 4] and it was rotated 2 times.
			Sample Input 2 :
				6
				25 30 5 10 15 20
				Sample Output 2 :
				5
				Explanation of Sample Input 2 :
					The original array was [5, 10, 15, 20, 25, 30] and it was rotated 2 times.

				Expected Time Complexity:
					Try to solve this with O(log(n)) time complexity.
			Constraints :
				1 <= n <= 10^5
				1 <= arr[i] <= 10^9

				Time Limit: 1 sec

		//Not Optimized:
			int findMin(vector<int>& arr) {
				// return *min_element(arr.begin(), arr.end());
				// or
				int min=arr[0];
				for(int i=1; i<arr.size(); i++)
					if(min > arr[i])
						min = arr[i];
				return min;
			}

		//Optimized:
			int findMin(vector<int>& arr) {
				int start =0, end = arr.size()-1;
				while(start<end){
					int mid = (start + end) / 2;
					if(arr[mid] > arr[end])
						start = mid + 1;
					else
						end = mid;
				}
				return arr[end];
			}

	298) Sum of Subarray Minimums: ❌Pending
		Problem statement:
			Given an array of integers arr, find the sum of min(b), 
			where b ranges over every (contiguous) subarray of arr. 
			Since the answer may be large, return the answer modulo 109 + 7.		

			Example 1:
				Input: arr = [3,1,2,4]
				Output: 17
				Explanation: 
				Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
				Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
				Sum is 17.

			Example 2:
			Input: arr = [11,81,94,43,3]
			Output: 444

			Constraints:
				1 <= arr.length <= 3 * 104
				1 <= arr[i] <= 3 * 104

		//Not Optimized:
			class Solution {
				public:
				int sumSubarrayMins(vector<int>& arr) {
					int mod = 1e9+7;
					int SumAns = accumulate(arr.begin(), arr.end(), 0LL) % mod;

					for(int i=0; i<arr.size()-1; i++) {
						vector<int> temp;
						temp.push_back(arr[i]);
						for(int j=i+1; j<arr.size(); j++){
							temp.push_back(arr[j]);
							
							int minValue = *min_element(temp.begin(), temp.end());
							SumAns = (SumAns + minValue) % mod;
						}
					}
					return SumAns;
				}
			};
	
		//Little Optimized:
			class Solution {
				public:
				int sumSubarrayMins(vector<int>& arr) {
					int mod = 1e9+7;
					int SumAns = accumulate(arr.begin(), arr.end(), 0LL) % mod;

					for(int i=0; i<arr.size()-1; i++) {
						int minValueIndex = i;
						for(int j=i+1; j<arr.size(); j++){
							if(arr[j]<arr[minValueIndex])			//storing the minValue index.
								minValueIndex = j;
							SumAns = (SumAns + arr[minValueIndex]) % mod;
						}
					}
					return SumAns;
				}
			};
		
		//Optimized
			using ll = long long;
			const int MOD = 1e9 + 7;

			class Solution {
				public:
				int sumSubarrayMins(vector<int>& nums) {
					int length = nums.size();
					vector<int> left(length, -1);
					vector<int> right(length, length);
					stack<int> stk;

					for (int i = 0; i < length; ++i) {
						while (!stk.empty() && nums[stk.top()] >= nums[i]) {
							stk.pop();
						}
						if (!stk.empty()) {
							left[i] = stk.top();
						}
						stk.push(i);
					}

					stk = stack<int>();

					for (int i = length - 1; i >= 0; --i) {
						while (!stk.empty() && nums[stk.top()] > nums[i]) {
							stk.pop();
						}
						if (!stk.empty()) {
							right[i] = stk.top();
						}
						stk.push(i);
					}

					ll sum = 0;
					for (int i = 0; i < length; ++i) {
						sum += static_cast<ll>(i - left[i]) * (right[i] - i) * nums[i] % MOD;
						sum %= MOD;
					}
					return sum;
				}
			};

	299) Shortest Palindrome: ❌Pending
		Problem statement
			You are given a string ‘STR’. 
			Your task is to find the shortest palindrome that can be formed by adding characters in front of ‘STR’.
			For example:
				You are given ‘STR’ = “aabcd”. Then our answer will be “dcbaabcd”. 
				We can form a palindrome by adding ‘d’, ‘c’, and ‘b’ in front of ‘STR’.
			Constraints:
				1 <= T <= 10 
				1 <= STR.LENGTH  <= 5000
				‘STR’ contains only lowercase English letters.
				Time limit: 1 sec
			Note:
				You do not need to input or print anything, as it has already been taken care of. Just implement the given function.
			Sample Input 1:
				2
				aabcd
				abad
				Sample Output 1:
				dcbaabcd
				dabad
				Explanation:
					For the first test case, you are given ‘STR’ = “aabcd”. 
					Then our answer will be “dcbaabcd”. 
					We can form a palindrome by adding ‘d’, ‘c’, and ‘b’ in front of ‘STR’.

					For the second test case, you are given ‘STR’ = “abad”.
					Then our answer will be “dabad”. 
					We can form a palindrome by adding ‘d’ in front of ‘STR’.
				Sample Input 2:
				2
				abda
				acbbca
				Sample Output 2:
				adbabda
				acbbca

		//Not Optimized:
			#include <bits/stdc++.h> 
			#include<string> 
			bool  checkReverse(string s){
				// string holder = s;
				// reverse(holder.begin(), holder.end());

				// if(holder == s)
				//     return 1;
				
				// return 0;

				for(int i=0; i<s.length()/2; i++)
					if(s[i] != s[s.length()-1-i])
						return 0;
				return 1;
			}

			string findShortestPalindrome(string &str) {
				string temp = str;

				int i=1;
				while(!checkReverse(temp)){
					string lstChars = str.substr(str.length()-i);
					i++;
					temp.clear();
					reverse(lstChars.begin(), lstChars.end());
					
					temp = lstChars + str;       
				}
				return temp;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			#include<string> 

			string findShortestPalindrome(string &str) {
				string rev = str;
				reverse(rev.begin(), rev.end());
				int N = str.length();

				for (int i = 0; i < N; ++i) {
					if (rev.substr(i) == str.substr(0, N - i)) {
						return rev.substr(0, i) + str;
					}
				}
			}

	300) Rearrange Array:
		Problem statement
			You're given an array ARR[] of size N, 
			where every element belongs to the range 0 to N-1. 
			Your task is to rearrange the given array so that ARR[i] becomes ARR[ARR[i]] 
			and make sure that this task is done with O(1) extra space.

			Constraints :
				1 <= T <= 10^2
				1 <= N <= 10^4
				0 <= ARR[i] <= N-1

				Where 'ARR[i]' is 'ith' element of ARR.

				Time Limit : 1 sec
			Sample Input 1 :
				1
				4
				0 1 2 3
				Sample Output 1:
				0 1 2 3    
				Explanation of Sample Input 1 :
				We can see that ARR[ARR[0]] i.e ARR[0] is 0, 
				hence ARR[0] in the output array will be 0. Also, 
				ARR[ARR[1]] i.e ARR[1]  is1, hence ARR[1] in the output array will be 1. 
				Similarly,  ARR[ARR[2]] i.e ARR[2] is 2, hence ARR[2] in the output array will be 2. 
				Finally, ARR[ARR[3]] i.e ARR[3] is 3, hence ARR[3] in the output array will be 3.

				Sample Input 2 :
				1
				4
				3 2 0 1
				Sample Output 2 :
				1 0 3 2
				Explanation of Sample Input 2 :
				We can see that ARR[ARR[0]] i.e ARR[3] is 1, 
				hence ARR[0] in the output array will be 1. Also, 
				ARR[ARR[1]] i.e ARR[2] is 0, hence ARR[1] in the output array will be 0. 
				Similarly,  ARR[ARR[2]] i.e ARR[0] is 3, hence ARR[2] in the output array will be 3. 
				Finally, ARR[ARR[3]] i.e ARR[1] is 2, hence ARR[3] in the output array will be 2.

		//Using Extra Space:
			#include <bits/stdc++.h> 
			void rearrangeArray(int arr[], int n) {
				vector<int> ans(n);

				for(int i=0; i<n; i++){
					ans[i] = arr[arr[i]];
				}

				// 1. method to copy vector to array
				// for(int i=0; i<n; i++)
				// 	arr[i] = ans[i];

				// 2. method to copy vector to array
				copy(ans.begin(), ans.end(), arr);

				// 3. method to copy vector to array
				// transform(ans.begin(), ans.end(), arr, [] (int x){
				// 	return x;
				// });
			}

		//Without using extra space (in-place Re-arrangement)
			#include <bits/stdc++.h> 
			void rearrangeArray(int arr[], int n) {
				for(int i = 0; i < n; i++){        
					arr[i] += (arr[arr[i]] % n) * n;    
				}

				for (int i = 0; i < n; i++) {
					arr[i] /= n;
				}
			}

	301) Set Mismatch:
		Problem Statement:
			You have a set of integers s, which originally contains all the numbers from 1 to n. 
			Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, 
			which results in repetition of one number and loss of another number.
			You are given an integer array nums representing the data status of this set after the error.

			Find the number that occurs twice and the number that is missing and return them in the form of an array.

			Example 1:
				Input: nums = [1,2,2,4]
				Output: [2,3]

			Example 2:
				Input: nums = [1,1]
				Output: [1,2]

			Constraints:
				2 <= nums.length <= 104
				1 <= nums[i] <= 104

		class Solution {
			public:
			vector<int> findErrorNums(vector<int>& nums) {
				int repeated;
				int notFound=1;

				map<int, int> Freq;
				for(int i=0; i<nums.size(); i++){
					Freq[nums[i]]++;

					if(find(nums.begin(), nums.end(), notFound) != nums.end())
						notFound++;
				}

				for(auto i: Freq)
					if(i.second == 2)
						repeated = i.first;

				/* or
					for(auto i: Freq)
						if(i.second == 2){
							repeated = i.first;
							break;
						}
				*/

				return {repeated, notFound};
			}
		};

		//Little optimized:
			class Solution {
				public:
				vector<int> findErrorNums(vector<int>& nums) {
					int repeated, notFound=1;
					map<int, int> freq;

					for(int i: nums){
						freq[i]++;
						if(freq[i] == 2){
							repeated = i;
							break;
						}
					}

					for(int i=1; i<=nums.size(); i++)
						if(find(nums.begin(), nums.end(), i) == nums.end()) {
							notFound = i;
							break;
						}

					return {repeated, notFound};
				}
			};

		//More Optimized:
			class Solution {
				public:
				vector<int> findErrorNums(vector<int>& nums) {
					int duplicate;

					for (const int num : nums)
						if (nums[abs(num) - 1] < 0)
							duplicate = abs(num);
						else
							nums[abs(num) - 1] *= -1;

					for (int i = 0; i < nums.size(); ++i)
						if (nums[i] > 0)
							return {duplicate, i + 1};

					throw;
					// return {};
					//if you are returning any answer within loop only, & you are sure that you will find that answer before loop ends,
					// then for just sake use throw keyword. after using this no need to use returning at the end of function.
					// if you don't use throw keyword here then you have to return your answer out of loop.
					//or else you can use return with empty vector like above.
				}
			};

	302) Naughty Luke:
		Problem statement
			Luke, a naughty kid, went to a museum one day. 
			He sees an ancient grid 'A' consisting of 'N' rows and 'N' columns. 
			Each cell of a grid is coloured with either black or white.
			Luke performs two sequential operations on the grid ‘A’. 
			First, he twists the grid vertically around the center. 
			After that, as the second operation, he changes the colours of all the cells. 
			If the cell is white, it is changed to black and vice-versa.

			The following drawings show the twist operation and the colour change operation, respectively :
			The black colour is represented by '1' and white colour is represented by '0' here. 
			You have to print the final grid.

			Example :
				'N' = 2, 'A' = { {0, 1}, {0, 0} }.

			After twisting, the grid looks like :
				'A' =  { {1, 0}, {0, 0} }.

			After changing the colours, the grid looks like :
				'A' =  { {0, 1}, {1, 1} }.
			Constraints :
				1 <= T <= 10
				1 <= N <= 100.

			Sum of 'N' ^ 2 over all the test cases is <= 10 ^ 4.
			Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				1 1 0
				0 1 1
				1 0 0
				1
				0
				Sample Output 1 :
				1 0 0
				0 0 1
				1 1 0
				1
				Explanation Of Sample Input 1 :
				For test 1:
				After twisting the grid looks like : { {0, 1, 1}, {1, 1, 0}, {0, 0, 1} }.
				After changing the colour of cells the grid looks like : { {1, 0, 0}, {0, 0, 1}, {1, 1, 0} }.

				For test 2:
				After twisting the grid looks like : { {0} }.
				After changing the colour of cells the grid looks like : { {1} }.
				Sample Input 2 :
				2
				3
				1 1 1
				1 1 1
				1 1 1
				4
				1 1 1 1
				0 0 0 0
				1 1 1 1
				0 0 0 0
				Sample Output 2 :
				0 0 0
				0 0 0
				0 0 0
				0 0 0 0
				1 1 1 1
				0 0 0 0
				1 1 1 1

		#include <bits/stdc++.h>
		vector<vector<int>> getFinalGrid(vector<vector<int>> &a, int n) {
			//Rotating
			for(int i=0; i<n; i++)
				for(int j=0; j<n/2; j++)
					swap(a[i][j], a[i][n-j-1]);

			//changing
			for(int i=0; i<n; i++)
				for(int j=0; j<n; j++)
					(a[i][j] == 0) ? a[i][j] = 1 : a[i][j]=0;
				
			/*
				//or for above for loop
				for(int i=0; i<n; i++)
					for(int j=0; j<n; j++)
						if(a[i][j] == 0)
							a[i][j] = 1;
						else
							a[i][j]=0;
			*/		
			return a;
		}

		// or
			#include <bits/stdc++.h> 
			vector<vector<int>> getFinalGrid(vector<vector<int>> &a, int n) {

				for(vector<int> &row: a){               // using & (ampersand) here is very important else it will create a new vector & made changes in that new vector
					// reverse it
					int i=0, j= n-1;

					while(i < j)
						swap(row[i++], row[j--]);
				}

				// changing black color to white color & viceversa
				for(int i=0; i<n; i++)
					for(int j=0; j<n; j++)
						a[i][j] = (a[i][j] == 1) ? 0 : 1;

				return a;
			}
	
	303) Implement strStr():
		Problem statement
			You are given two strings A and B. Find the index of the first occurrence of A in B. 
			If A is not present in B, then return -1.

			For Example:
				A = “bc”, B = “abcddbc”.
				String “A” is present at index 1, and 5(0-based index), 
				but we will return 1 as it is the first occurrence of “A” in string “B”.
			Follow Up:
				Can you solve this in linear time and space complexity?
			Constraints:
				1 <= T <= 100
				1 <= |A|, |B| <= 5 * 10^4 

				Time limit: 1 second
			Sample Input 1:
				2
				ninjas codingninjas
				code codingninjas
				Sample Output 1:
				6
				-1
				Explanation For Sample Input 1:
				For the first test case, “ninjas” is present at the 6th index of “codingninjas”.

				For the second test case, “code” is not present in “codingninjas”.
				Sample Input 2:
				2
				e add
				en engagement
				Sample output 2:
				-1
				0

		#include <bits/stdc++.h> 
		int findIndexOf(string a, string b){
			if(b.find(a) != string::npos)
				return b.find(a);
			return -1;					//if we didn't found a single occurrence
		}

		// or
		#include <bits/stdc++.h> 
		int findIndexOf(string a, string b){
			return b.find(a);
		}
	
	304) Rotate Matrix:
		Problem statement
			Given a 2-dimensional matrix of size ‘N’ x ‘M’, rotate the elements of the matrix clockwise.

			For example: 
			Input Matrix: [ [ 1, 2, 3 ] 
						[ 4, 5, 6 ] 
						[ 7, 8, 9 ] ]

			Output Matrix: [ [ 4, 1, 2 ] 
						[ 7, 5, 3 ] 
						[ 8, 9, 6 ] ]

			The output matrix is generated by rotating the elements of the input matrix in a clockwise direction. Note that every element is rotated only once. 
			Note :
				You do not need to print anything; 
				it has already been taken care of. Also, update the given matrix in-place.
			Constraints :
				1 <= T <= 10
				1 <= N, M <= 100
				-10^5 <= data <= 10^5,

				where ‘T’ is the number of test cases,  
				‘N’ and ‘M’ are the numbers of rows and columns respectively and 
				‘data’ is the value of the elements of the matrix.
			Sample Input 1 :
				1
				4 4
				1 2 3 4
				5 6 7 8
				9 10 11 12
				13 14 15 16
				Sample Output 1 :
				5 1 2 3
				9 10 6 4
				13 11 7 8
				14 15 16 12
				Explanation of Sample Input 1 :

				The resulting matrix after rotating the given matrix clockwise is shown above. 
				Sample Input 2 :
				2
				2 2
				1 3
				4 5
				3 3
				3 4 5
				5 6 7
				8 10 20
				Sample Output 2 :
				4 1
				5 3
				5 3 4
				8 6 5
				10 20 7 

		#include <bits/stdc++.h>
		void rotateMatrix(vector<vector<int>> &mat, int n, int m) {
			if(n==1 || m==1)
				return;

			int startRow = 0;
			int startCol = 0;
			int endRow = n-1;
			int endCol = m-1;

			int totalelement = n*m;
			int cnt=0;

			while(cnt < totalelement){

				// for start row
				for(int i=startCol; i<=endCol && cnt< totalelement; i++){
					swap(mat[startRow][startRow],mat[startRow][i]);
					cnt++;
				}
				startRow++;

				// for end col
				for(int i=startRow; i<=endRow && cnt< totalelement; i++){
					swap(mat[startRow-1][startRow-1],mat[i][endCol]);
					cnt++;
				}
				endCol--;

				// for end row
				for(int i=endCol; i>=startCol && cnt < totalelement; i--){
					swap(mat[startRow-1][startRow-1], mat[endRow][i]);
					cnt++;
				}
				endRow--;

				// for start col
				for(int i=endRow; i>=startRow; i--){
					swap(mat[startRow-1][startRow-1],mat[i][startCol]);
					cnt++;
				}
				startCol++;

				if(startRow == endRow || startCol == endCol)
					return;
			}
		}
	
	305) Create A Matrix With Alternating X And 0:
		Problem statement
			You are given two integers ‘N’ and ‘M’. 
			Your task is to create a matrix of size N x M in which every element is either ‘X’ or ‘0’. 
			The ‘X’s and ‘0’s must be filled alternatively, the matrix should have an outermost rectangle of ‘X’s, 
			then a rectangle of ‘0’s, then a rectangle of ‘X’s, and so on.

			For example :
				For given dimension N = 5 and M = 5 :

				[      [X, X, X, X, X],
					[X, 0, 0, 0, X],
					[X, 0, X, 0, X],
					[X, 0, 0, 0, X],
					[X, X, X, X, X]     ]
				Detailed explanation ( Input/output format, Notes, Images )
				Constraints :
					1 ≤ T ≤ 50
					1 ≤ N ≤ 100
					1 ≤ M ≤ 100

					Where ‘T’ is the number of test cases.
					‘N’ and ‘M’ are the given dimensions.

					Time Limit: 1 sec 
				Sample Input 1 :
					2
					3 3
					2 2
					Sample Output 1 :
					X X X
					X 0 X
					X X X
					X X
					X X
					Explanation of Input 1 :
					For the first test case, the constructed matrix will contain two rectangles, 
					the outermost rectangle is of ‘X’s, then there is a rectangle of ‘0’s.

					For, second test case, the constructed matrix will contain one rectangle of ‘X’s.
					Sample Input 2 :
					2
					4 3
					5 5
					Sample Output 2 :
					X X X 
					X 0 X
					X 0 X 
					X X X
					X X X X X
					X 0 0 0 X
					X 0 X 0 X
					X 0 0 0 X
					X X X X X
					Explanation of Input 2 :
					For the first test case, the constructed matrix will contain two rectangles, 
					the outermost rectangle is of ‘X’s, then there is a rectangle of ‘0’s.

					For, second test case, the constructed matrix will contain three rectangles, 
					where the outermost rectangle will be of ‘X’s then ‘0’s and lastly ‘X’s again.

		#include <bits/stdc++.h> 
		vector<vector<char>> constructMatrix(int n, int m) {
			vector<vector<char>> ans (n, vector<char> (m,'a'));

			char ch = 'X';

			int totalCnt = n*m;

			int startRow=0;
			int startCol=0;

			int endRow=n-1;
			int endCol=m-1;
			
			int cnt =0;

			while(cnt< totalCnt){
				
				//for start row
				for(int i=startCol; i<=endCol && cnt < totalCnt; i++){
					ans[startRow][i] = ch;
					cnt++;
				}
				startRow++;

				//for last Col
				for(int i=startRow; i<=endRow && cnt < totalCnt; i++){
					ans[i][endCol] = ch;
					cnt++;
				}
				endCol--;

				//for last Row
				for(int i=endCol; i>=startCol && cnt <  totalCnt; i--){
					ans[endRow][i] = ch;
					cnt++;
				}
				endRow--;

				//for start col
				for(int i=endRow; i>=startRow && cnt < totalCnt; i--){
					ans[i][startCol] = ch;
					cnt++;
				}
				startCol++;
				ch = (ch == 'X') ? '0' : 'X';
			}
			return ans;
		}

		// Simpler version:
			#include <bits/stdc++.h> 
			vector<vector<char>> constructMatrix(int n, int m) {
				vector<vector<char>> ans (n, vector<char>(m, 'X'));

				int sr, sc;
				sr = sc = 1;

				int er = n-2, ec = m-2;
				char ch = '0';
				while(sr <= er && sc <= ec) {
					
					// for start row
					for(int i=sc; i<=ec; i++)
						ans[sr][i] = ch;        

					sr++;
					// for end col
					for(int i=sr; i<=er; i++)
						ans[i][ec]=ch;

					ec--;
					// for end row
					for(int i=ec; i>=sc; i--)
						ans[er][i]=ch;

					er--;
					// for start col
					for(int i=er; i>=sr; i--)
						ans[i][sc]=ch;
					sc++;
					ch = (ch == 'X') ? '0' : 'X';
				}
				return ans;
			}
	
	306) Magical Numbers:
		Problem statement
			Ninja has two integers, 'N' and 'X', and he wants to create a magical number using them. 
			The number with a form like '10^N + X' is called a magical number.
			Your task is to return a magical number to Ninja.


			Example:
				'N' = 3
				'X' = 3
				The magical number will be '10^3 + 3 = 1000 + 3 = 1003'. So, the answer is '1003'.

			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5
				0 <= X <= 9

				It is guaranteed that the sum of 'N' over all test cases is less than or equal to '10^5'.

				Time limit: 1 second
			Sample Input 1:
				2
				3 9
				4 1
				Sample Output 1:
				1009
				10001
				Explanation Of Sample Input 1:
				For test case 1:
				The magical number will be '10^3 + 9 = 1000 + 9 = 1009'.
				So, the answer is '1009'.

				For test case 2:
				The magical number will be '10^4 + 1 = 10000 + 1 = 10003'.
				So, the answer is '10001'.

				Sample Input 2:
				2
				9 7
				6 7
				Sample Output 2:
				1000000007
				1000007

		#include<bits/stdc++.h>
		string findMagicalNumber(int n, int x) {
			string s="1";
			for(int i=0; i<n; i++){
				s.push_back('0');
			}

			if(x == 0)
				return s;
			s.erase(s.begin()+1);
			string st = to_string(x);
			s.append(st);
			return s;
		}

		//or
			#include<bits/stdc++.h>
			string findMagicalNumber(int n, int x) {
				string s="1";
				for(int i=0; i<n; i++){
					s.push_back('0');
				}

				s.pop_back();
				char ch = '0' + x;
				s.push_back(ch);
				return s;
			}
	
	307) Ninja And The Rows:
		Problem statement
			Ninja has been provided a matrix 'MAT' of size 'N X M' where 'M' 
			is the number of columns in the matrix, and 'N' is the number of rows.
			The weight of the particular row is the sum of all elements in it. 
			Ninja wants to find the maximum weight amongst all the rows.

			Your task is to help the ninja find the maximum weight amongst all the rows.
			EXAMPLE:
				Input: 'N' = 2, 'M' = 3, 'MAT' = [[1, 2, 3], [2, 0, 0]]
				Output: 6

				The weight of first row is 1 + 2 + 3 = 6
				The weight of the second row is 2 + 0 + 0 = 2;
				hence the answer will be a maximum of 2 and 6, which is 6.

			Constraints :
				1 <= 'T' <= 10
				1 <= 'N' <= 10^2
				1 <= 'M' <= 10^2
				0 <= 'MAT[I][J]' <= 10^5

				Time Limit: 1 sec
			Sample Input 1 :
				2
				3 3
				1 2 3
				3 4 2
				3 4 2
				1 1
				2
				Sample Output 1 :
				9
				2
				Explanation Of Sample Input 1 :
				For the first test case, the answer will be 9. It will be formed by the 2nd row, 
				and it will be the maximum amongst all.

				For the first test case, as there is only one row, 
				the answer will be its sum which is 2.
				Sample Input 2 :
				2
				1 3
				1 2 3
				4 2
				2 2
				3 4 
				2 4
				4 5
				Sample Output 2 :
				6
				9

		#include <bits/stdc++.h> 
		int maximumWeightRow(int n, int m, vector<vector<int>> &mat) {
			int mxAns = INT_MIN;
			for(int i=0; i<n; i++){
				int crntSum=0;
				for(int j=0; j<m; j++){
					crntSum += mat[i][j];
				}
				mxAns = max(mxAns, crntSum);
			}
			return mxAns;
		}
	
	308) Majority element:
		Problem statement
			You have been given an array/list 'ARR' consisting of 'N' integers. 
			Your task is to find the majority element in the array. If there is no majority element present, print -1.

			Note:
				A majority element is an element that occurs more than floor('N' / 2) times in the array.
			Constraints:
				1 <= T <= 100
				1 <= N <= 5 * 10^3
				-10^5 <= ARR[i] <= 10^5

			Where 'ARR[i]' denotes the element at the 'i'th index in the array/list 'ARR'.

			Time limit: 1 sec
			Sample Input 1:
				2
				5
				2 3 9 2 2
				4
				8 5 1 9 
				Sample Output 1:
				2
				-1
				Explanation of Sample Output 1:
				In test case 1, frequencies of occurrences of different elements are:

				2 → 3 times
				3 → 1 time
				9 → 1 time

				As 2 occurs more than floor(5/2) (i.e. floor(2.5) = 2) times, it is the majority element.

				In test case 2, frequencies of occurrences of different elements are:

				8 → 1 time
				5 → 1 time
				1 → 1 time
				9 → 1 time

				As no element occurs more than floor(4/2) = 2 times. Thus No majority element is present.
				Sample Input 2:
				2
				7
				8 8 8 8 8 9 1 
				4
				2 2 3 3
				Sample Output 2:
				8
				-1
				Explanation of Sample Output 2:
				In test case 1, frequencies of occurrences of different elements are:

				8 → 5 times
				9 → 1 time
				1 → 1 time

				As 8 occurs more than floor(7/2) (i.e. floor(3.5) = 3) times, it is the majority element.

				In test case 2, frequencies of occurrences of different elements are:

				2 → 2 times
				3 → 2 times

				As no element occurs more than floor(4/2) = 2 times. Thus No majority element is present.

		#include <bits/stdc++.h>
		int findMajorityElement(int arr[], int n) {
			map<int, int> Freq;

			for(int i=0; i<n; i++)
				Freq[arr[i]]++;
			
			for(auto itr: Freq){
				if(itr.second > (n/2))
					return itr.first;
			}
			return -1;
		}
	
	309) First non repeating character:
		Problem statement
			Ninja is now bored with numbers and is now playing with characters but 
			hates when he gets repeated characters. Ninja is provided a string, 
			and he wants to return the first unique character in the string.
			The string will contain characters only from the English alphabet set, 
			i.e., ('A' - 'Z') and ('a' - 'z'). If there is no non-repeating character, 
			print the first character of the string. If there is no non-repeating character, 
			return the first character of the string.

			Constraints:
				1 <= T <= 10
				1 <= Length of Input String <= 10^4

				Time Limit: 1 sec 
			Sample Input 1 :
				2
				aDcadhc
				AabBcC
				Sample Output 1:
				D
				A
				Explanation for Sample Input 1:
				In the first test case, ‘a’ is repeated.’ D’ is the first non-repeating character in the string, so we return it.

				In the second test case, all the characters are non-repeating, so we return the first character.
				Sample Input 2 :
				2
				ABcd
				AAAbcdb
				Sample Output 2:
				A
				c 

		#include <bits/stdc++.h> 
		char firstNonRepeatingCharacter(string str) {
			for(int i=0; i<str.length()-1; i++){
			int flag = 1;

			for(int j=i+1; j<str.length(); j++)
				if(str[i] == str[j]){
				flag=0;
				break;
				}

			
			for(int j=i-1; j>=0; j--)
				if(str[i] == str[j]){
				flag=0;
				break;
				}

			if(flag)
				return str[i];
			}
			return str[0];
		}

		//or
			#include <bits/stdc++.h> 
			char firstNonRepeatingCharacter(string str) {
				map<char, int> Freq;
				for(char ch: str){
				Freq[ch]++;
				}

				for(char ch: str)
				if(Freq[ch] == 1)
					return ch;
				return str[0];
			}
	
	310) Sort By Kth Bit:
		Problem statement
			You are given an array/list ‘ARR’ of ‘N’ positive integers and an integer ‘K’. 
			Your task is to group all the array elements with ‘K-th’ bit (rightmost bit is ‘1st’ bit) 
			equal to 0 followed by all the elements with ‘K-th’ bit equal to 1.

			Note 1: The relative order inside both the groups should remain as it was in the input.
			Note 2: You have to return the modified array/list..

			For Example :
			If ‘ARR’ is {1,2,3,4} and ‘K’ = 1, then after modification, 
			‘ARR’ should be {2,4,1,3} because ‘K-th’ (‘K’ = 1) of {2,4} is 0 and ‘K-th’ bit of {1,3} is 1.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^4
				1 <= ARR[i] <= 10^9
				1 <= K <= 31

				Time Limit: 1 sec
			Sample Input 1:
				2
				4 1
				4 3 2 1
				5 2
				2 5 1 6 7
				Sample Output 1:
				4 2 3 1
				5 1 2 6 7
				Explanation For Sample Input 1:
				In example 1, the original ‘ARR’ is {4,3,2,1} and ‘K’ = 1. 
				After modification, the ‘ARR’ should be {4,2,3,1} because {4,2} 
				will come first as their 1st bit is 0 and {3,1} will come after that as their 1st bit is 1.

				In example 2, the original ‘ARR’ is {2,5,1,6,7} and ‘K’ = 2. 
				After modification the ‘ARR’ should be {5,1,2,6,7} because {5,1} 
				will come first as their 2nd bit is 0 and {2,6,7} will come after that as their 2nd bit is 1.
				Sample Input 2:
				2
				5 1
				3 6 2 1 4
				5 3
				7 6 2 9 3
				Sample Output 2:
				6 2 4 3 1
				2 9 3 7 6
				Explanation For Sample Input 2:
				In example 1, the original ‘ARR’ is {3,6,2,1,4} and ‘K’ = 1. 
				After modification the ‘ARR’ should be {6,2,4,3,1} because {6,2,4} 
				will come first as their 1st bit is 0 and {3,1} will come after that as their 1st bit is 1.

				In example 2, the original ‘ARR’ is {7,6,2,9,3} and ‘K’ = 3. 
				After modification the ‘ARR’ should be {2,9,3,7,6} because {2,9,3} 
				will come first as their 3rd bit is 0 and {7,6} will come after that as their 3rd bit is 1.

		vector<int> sortArrayByKBit(int n, int k, vector<int> &arr) {
			vector<int> front;
			vector<int> back;

			for(int i=0; i<arr.size(); i++){
				int temp = arr[i];
				temp >>= k-1;

				if(temp & 1)
					back.push_back(arr[i]);
				else
					front.push_back(arr[i]);
			}
			front.insert(front.end(), back.begin(), back.end());			//adding vector back to end of front vector
			return front;
		}
	
	311) Terms Of AP:
		Problem statement
			Ayush is given a number ‘X’. 
			He has been told that he has to find the first ‘X’ terms of the series 3 * ‘N’ + 2, 
			which are not multiples of 4. Help Ayush to find it as he has not been able to answer.
			Example: 
				Given an ‘X’ = 4. The output array/list which must be passed to Ayush will be [ 5, 11, 14, 17 ].

			Constraints:
				1 <= T <= 10^2
				1 <= X <= 10^5

				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				5
				Sample Output 1:
				5 11
				5 11 14 17 23
				Explanation For Sample Input 1:
				In the first test case, the first number is 5, 
				while the second number cannot be 8 as it is divisible by 4, 
				and so, the next number is directly 11 as it is not divisible by 4.

				In the second test case, the first two numbers are 5 and 11. 
				While following three numbers are 14, 17 and 23 for ‘N’ = 4, 5 and 7 respectively. 
				20 is divisible by 4, and thus, 20 cannot be included in the list.
				Sample Input 2:
				2
				7
				8
				Sample Output 2:
				5 11 14 17 23 26 29
				5 11 14 17 23 26 29 35
				Explanation For Sample Input 2:
				In the first test case, the first five numbers are 5, 11, 14, 17 and 23.
				While the following two numbers are 26 and 29 for N = 8 and 9 respectively.

				In the second test case, the seven numbers are explained in the above test case and for N = 10,
				we get the number 32, which is divisible by 4 and thus, we reject it. 
				For N = 11, the number is 35 and is not divisible by 4.

		#include <bits/stdc++.h> 
		#include <vector>
		vector <int> termsOfAP(int x) {
			vector<int> ans;
			int crntValue = 1;

			int looper = x;
			for(int i=0; i<looper; i++){
				if((3 * (crntValue) + 2) % 4 !=0){
					ans.push_back(3 * crntValue + 2);
				}else{
					looper++;
				}
				crntValue++;
			}
				
			return ans;
		}

		// or
			#include <bits/stdc++.h> 
			#include <vector>

			vector < int > termsOfAP(int x) {
				int n=5;
				vector <int> ans = {n};

				while(--x){
					n += 3;
					if(n % 4 ==0){
						++x;
						continue;
					}
					ans.push_back(n);        
				}
				return ans;
			}

	312) Squares of a Sorted Array:
		Problem Statement:
			Given an integer array nums sorted in non-decreasing order, 
			return an array of the squares of each number sorted in non-decreasing order.
			Example 1:
				Input: nums = [-4,-1,0,3,10]
				Output: [0,1,9,16,100]
				Explanation: After squaring, the array becomes [16,1,0,9,100].
				After sorting, it becomes [0,1,9,16,100].
			
			Example 2:
				Input: nums = [-7,-3,2,3,11]
				Output: [4,9,9,49,121]
				
			Constraints:

				1 <= nums.length <= 104
				-104 <= nums[i] <= 104
				nums is sorted in non-decreasing order.
			
			Follow up: Squaring each element and sorting the new array is very trivial, 
			could you find an O(n) solution using a different approach?

		class Solution {
			public:
			vector<int> sortedSquares(vector<int>& nums) {
				vector<int> ans;
				for(int i: nums)
					ans.push_back(i*i);
				
				sort(ans.begin(), ans.end());
				return ans;
			}
		};

		//More optimized:
			class Solution {
				public:
				vector<int> sortedSquares(vector<int>& A) {
					vector<int> res(A.size());
					int l = 0, r = A.size() - 1;
					for (int k = A.size() - 1; k >= 0; k--) {
						if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];
						else res[k] = A[l] * A[l++];
					}
					return res;
				}
			};

			//or same Simplified:
				class Solution {
					public:
					vector<int> sortedSquares(vector<int>& nums) {
						vector<int> ans (nums.size());
						int low=0, high=nums.size()-1;

						for(int i=nums.size()-1; i>=0; i--){
							if(abs(nums[low]) > abs(nums[high])){
								ans[i] = (nums[low]*nums[low]);
								low++;
							}else{
								ans[i] = (nums[high]*nums[high]);  
								high--; 
							}
						}
						return ans;
					}
				};

	313) Running Sum of 1d Array
		Problem statement:
			Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
			Return the running sum of nums.
			Example 1:
			Input: nums = [1,2,3,4]
			Output: [1,3,6,10]
			Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

			Example 2:
			Input: nums = [1,1,1,1,1]
			Output: [1,2,3,4,5]
			Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

			Example 3:
			Input: nums = [3,1,2,10,1]
			Output: [3,4,6,16,17]

			Constraints:
				1 <= nums.length <= 1000
				-10^6 <= nums[i] <= 10^6

		class Solution {
			public:
			vector<int> runningSum(vector<int>& nums) {
				int sum=0;
				for(int i=0; i<nums.size(); i++){
					sum += nums[i];
					nums[i] = sum;
				}
				return nums;
			}
		};

		//or
			class Solution {
				public:
				vector<int> runningSum(vector<int>& nums) {
					for(int i=1; i<nums.size(); i++)
						nums[i] += nums[i-1];
					return nums;
				}
			};

	314) Single Number:
		Problem Statement:
			Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
			You must implement a solution with a linear runtime complexity and use only constant extra space.	

			Example 1:
				Input: nums = [2,2,1]
				Output: 1

			Example 2:
				Input: nums = [4,1,2,1,2]
				Output: 4

			Example 3:
				Input: nums = [1]
				Output: 1
			

			Constraints:
				1 <= nums.length <= 3 * 104
				-3 * 104 <= nums[i] <= 3 * 104
				Each element in the array appears twice except for one element which appears only once.

		class Solution {
			public:
			int singleNumber(vector<int>& nums) {
				int ans = nums[0];			//or, int ans = 0;
				for(int i=1; i<nums.size(); i++)
					ans ^= nums[i];
				return ans;
			}
		};

	315) Single Number II: ❌Pending
		Problem Statement:
			Given an integer array nums where every element appears three times except for one, 
			which appears exactly once. Find the single element and return it.
			You must implement a solution with a linear runtime complexity and use only constant extra space.

			Example 1:
				Input: nums = [2,2,3,2]
				Output: 3

			Example 2:
				Input: nums = [0,1,0,1,0,1,99]
				Output: 99

			Constraints:
				1 <= nums.length <= 3 * 104
				-2^31 <= nums[i] <= 2^31 - 1
				Each element in nums appears exactly three times except for one element which appears once.
	
		class Solution {
			public:
			int singleNumber(vector<int>& nums) {
				map<int, int> Freq;
				for(int i: nums)
					Freq[i]++;
				
				for(auto at:Freq)
					if(at.second == 1)
						return at.first;

				throw;      
				//i don't have anything to put inside return  statement here that's why i kept throw keyword
				//code will never reach till here. code will gets his answer before reaching here only.
			}
		};

		//Without using extra space:
			class Solution {
				public:
				int singleNumber(vector<int>& nums) {
					int ans = 0;

					for (int i = 0; i < 32; ++i) {
						int sum = 0;
						
						for (const int num : nums)
							sum += (num >> i) & 1;

						sum %= 3;
						ans |= sum << i;
					}

					return ans;
				}
			};

			//or
			class Solution {
				public:
				int singleNumber(vector<int>& nums) {
					int ones = 0, twos = 0;
					for (int num : nums) {
						ones = (ones ^ num) & ~twos;
						twos = (twos ^ num) & ~ones;
					}
					return ones;
				}
			};

	316) Single Number III:
		Problem Statement:
			Given an integer array nums, 
			in which exactly two elements appear only once and all the other elements appear exactly twice. 
			Find the two elements that appear only once. You can return the answer in any order.
			You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

			Example 1:
				Input: nums = [1,2,1,3,2,5]
				Output: [3,5]
				Explanation:  [5, 3] is also a valid answer.

			Example 2:
				Input: nums = [-1,0]
				Output: [-1,0]

			Example 3:
				Input: nums = [0,1]
				Output: [1,0]

			Constraints:
				2 <= nums.length <= 3 * 104
				-231 <= nums[i] <= 231 - 1
				Each integer in nums will appear twice, only two integers will appear once.

		class Solution {
			public:
			vector<int> singleNumber(vector<int>& nums) {
				vector<int> ans;
				map<int, int> Freq;
				for(int i: nums)
					Freq[i]++;
				
				for(auto at: Freq)
					if(at.second == 1)
						ans.push_back(at.first);

				return ans;
			}
		};
		
		//Without using extra space: ❌Pending
			class Solution {
				public:
				vector<int> singleNumber(vector<int>& nums) {
					//consider 1 1 2 2 5 7 4 4
					//xor will give 2 ie 1st bit is different in numbers
					//divide it into 2 half numbers ie with ith bit set or not
					int xor1=0;
					for(auto it:nums) {
						xor1=xor1^it;
					}

					//check which bit is set
					int n=xor1;
					int i=0;
					//  i=n&~(n-1);
					while(n){
						if(n&1)
							break;
						i++;
						n=n>>1;
					}

					int xor2=0,xor3=0;
					for(auto it:nums) {
						if((it&(1<<i)))//check ith bit is set
							xor2=xor2^it;
						else
							xor3=xor3^it;
					}
					return {xor2,xor3};
				}
			};
	
	317) Bitwise AND of Numbers Range:
		Problem statement:
			Given two integers left and right that represent the range [left, right], 
			return the bitwise AND of all numbers in this range, inclusive.	

			Example 1:
				Input: left = 5, right = 7
				Output: 4

			Example 2:
				Input: left = 0, right = 0
				Output: 0

			Example 3:
				Input: left = 1, right = 2147483647
				Output: 0
			
			Constraints:
				0 <= left <= right <= 231 - 1

		//Explanation:
			The trick here is that :
			Bitwise-AND of any two numbers will always produce a number less than or equal to the smaller number.

			Consider the following example:
						12 ---- 1100
						11 ---- 1011
						10 ---- 1010
						9  ---- 1001
						8  ---- 1000
						7  ---- 0111
						6  ---- 0110
						5  ---- 0101
												
			Desired Range: [5,12]
			Starting from 12, the loop will first do
				12 & 11 = 8

			Next iteration, the loop will do
				8 & 7 = 0

			why did we skip anding of 10,9? Because even if we did so, 
			the result would eventually be anded with 8 whose value would be lesser than equal to 8.

			Hence, you start from the range end and keep working your way down the range till you reach the start.

		//Not Optimized:
			class Solution {
				public:
				int rangeBitwiseAnd(int left, int right) {
					int ans=left;
					for(int i=left+1; i<=right; i++)
						ans &= i;

					return ans;
				}
			};

			//or
				int rangeBitwiseAnd(int left, int right) {
					int ans=left;
					for(long i=left+1; i<=right; i++){
						ans &= i;
						if(ans == 0)
							break;
					}
					return ans;
				}

		//Optimized:
			class Solution {
				public:
				int rangeBitwiseAnd(int left, int right) {
					
					while(left < right)
						right &= right-1;

					return right;
				}
			};
	
	318) Replace Elements with Greatest Element on Right Side:
		Problem Statement:
			Given an array arr, replace every element in that array with the greatest element among the elements to its right, 
			and replace the last element with -1.

			After doing so, return the array.

			Example 1:
				Input: arr = [17,18,5,4,6,1]
				Output: [18,6,6,6,1,-1]
				Explanation: 
				- index 0 --> the greatest element to the right of index 0 is index 1 (18).
				- index 1 --> the greatest element to the right of index 1 is index 4 (6).
				- index 2 --> the greatest element to the right of index 2 is index 4 (6).
				- index 3 --> the greatest element to the right of index 3 is index 4 (6).
				- index 4 --> the greatest element to the right of index 4 is index 5 (1).
				- index 5 --> there are no elements to the right of index 5, so we put -1.

			Example 2:
				Input: arr = [400]
				Output: [-1]
				Explanation: There are no elements to the right of index 0.

			Constraints:
				1 <= arr.length <= 104
				1 <= arr[i] <= 105

		class Solution {
			public:
			vector<int> replaceElements(vector<int>& arr) {
				vector<int> ans(arr.size(), -1);

				for(int i=0; i<arr.size()-1; i++)
					ans[i] = *max_element(arr.begin()+i+1, arr.end());

				return ans;
			}
		};

		//without using extra function(max_element):
			class Solution {
				public:
				vector<int> replaceElements(vector<int>& arr) {
					
					int maxi = -1;
					int n = arr.size();

					vector<int>ans(n);

					for(int i = n-1; i>=0; i--){
					ans[i] = maxi;
					maxi = max(arr[i], maxi);
					}
					
					return ans;
				}
			};

	319) Add binary strings:
		Problem statement
			You have been given two binary strings ‘A’ and ‘B’. 
			Your task is to find the sum of both strings in the form of a binary string.

			Binary strings are the representation of integers in the binary form. For example, 
			the binary strings of 9 and 16 are “1001” and “10000” respectively.

			Constraints:
				1 <= T <= 5
				1 <= N, M <= 5000
				‘A’ and ‘B’ consist only of '0' or '1' characters.
				Each string does not contain leading zeros except for the zero itself.

				Time limit: 1 sec
			Sample Input 1:
				2
				2 2
				10 01
				3 2
				111 10
				Sample Output 1:
				11
				1001
				Explanation of sample input 1:
				In the first test case, the first string is “10” which is 2 in the decimal format, 
				and the second string is “01” which is 1 in the decimal format. So, 2 + 1 = 3, 
				which is represented as “11” in binary form.

				In the first test case, the first string is “111” which is 7 in the decimal format, 
				and the second string is “10” which is 2 in the decimal format. So, 7 + 2 = 9, 
				which is represented as “1001” in binary form.
				Sample Input 2:
				2
				3 1
				111 0
				1 1
				1 1
				Sample Output 2:
				111
				10
				Explanation for sample input 2:
				In the first test case, the first string is “111” which is 7 in the decimal format, 
				and the second string is “0” which is 0 in the decimal format. So, 7 + 0 = 0, 
				which is represented as “111” in binary form.

				In the first test case, the first string is “1” which is 1 in the decimal format and the second string is “1” 
				which is 1 in the decimal format. So, 1 + 1 = 2, which is represented as “10” in binary form.

		//Not Optimized:
			#include<bits/stdc++.h>
			string addBinaryString(string &a, string &b, int n, int m) {
				//from binary string to integer num
				int n1 = stoi(a,0,2);
				int n2 = stoi(b,0,2);

				int sum = n1 + n2;
				string ans = bitset<32>(sum).to_string();

				//removing leading zero's
				ans = ans.substr(ans.find('1'));

				return ans;    
			}
		
		//Optimized:
			#include<bits/stdc++.h>
			string addBinaryString(string &a, string &b, int n, int m) {
				string ans;
				int mxLength = max(n,m);

				char carry='0';

				while(mxLength >=0) {
					char ch1, ch2;
					if(n<=0){
						ch1 = '0';
					}else{
						n--;
						ch1 = a[n];
					}

					if(m<=0){
						ch2 = '0';
					}else{
						m--;
						ch2 = b[m];
					}

					char ch;
					if((ch1 == '1' && ch2 == '0' && carry == '0') || 
						(ch1 == '0' && ch2 == '1' && carry == '0') || 
						(ch1 == '0' && ch2 == '0' && carry == '1')) {
						ch = '1';
						carry='0';
					}else if((ch1 == '1' && ch2 == '0' && carry == '1') || 
						(ch1 == '0' && ch2 == '1' && carry == '1') || 
						(ch1 == '1' && ch2 == '1' && carry =='0')) {
						ch = '0';
						carry ='1';
					}else if((ch1 == '0' && ch2 == '0' && carry == '0')){
						ch='0';
						carry='0';
					}else if((ch1 == '1' && ch2 == '1' && carry == '1')){
						ch = '1';
						carry = '1';
					}

					ans += ch;
					mxLength--;
				}
				reverse(ans.begin(), ans.end());

				//removing leading zero's;
				ans = ans.substr(ans.find('1'));

				return ans;
			}
		
		//or
			#include<bits/stdc++.h>
			string addBinaryString(string &a, string &b, int n, int m) {
				if(n < m){
					int value = m - n;
					while(value--)
						a.insert(a.begin(), '0');
				}else if(n > m){
					int value = n - m;
					while(value--)
						b.insert(b.begin(), '0');
				}

				string ans;
				char carry='0';
				for(int i=a.length()-1; i>=0; i--){
					if(a[i] == '1' && b[i] == '1' && carry == '1'){
						ans.push_back('1');
						carry = '1';
					}else if(a[i] == '1' && b[i] == '1' && carry == '0'){
						ans.push_back('0');
						carry = '1';
					}else if(a[i] == '0' && b[i] == '1' && carry == '0'){
						ans.push_back('1');
						carry ='0';
					}else if(a[i] == '1' && b[i] == '0' && carry == '0'){
						ans.push_back('1');
						carry ='0';
					}else if(a[i] == '0' && b[i] == '1' && carry == '1'){
						ans.push_back('0');
						carry = '1';
					}else if(a[i] == '1' && b[i] == '0' && carry == '1'){
						ans.push_back('0');
						carry = '1';
					}else if(a[i] == '0' && b[i] == '0' && carry == '0'){
						ans.push_back('0');
						carry ='0';
					}else{
						ans.push_back('1');
						carry ='0';
					}
				}

				if(carry == '1')
					ans.push_back('1');
				reverse(ans.begin(), ans.end());
				return ans;
			}
	
		//Or Other approach:
			#include<bits/stdc++.h>
			string addBinaryString(string &a, string &b, int n, int m) {
				//  To store the sum of binary strings.
				string sum;

				int i = 0;
				
				//  To store the carry while adding the bits.
				int carry = 0;

				while (i < max(n, m)) {
					//  Initialize the current sum of the bits.
					int curSum = carry;

					if (i < n) {
						//  Add the value in the current sum.
						curSum = curSum + (a[n - 1 - i] - '0');
					}

					if (i < m){
						//  Add the value in the current sum.
						curSum = curSum + (b[m - 1 - i] - '0');
					}

					//  Append the resulting bit at the end of the string.
					sum.push_back((curSum) % 2 + '0');

					//  Update the carry value.
					carry = curSum / 2;

					i++;
				}
				if (carry != 0) {
					sum.push_back('1');
				}

				//  Reverse the binary string to move the least significant bits at the end of the string.
				reverse(sum.begin(), sum.end());

				return sum;
			}

	320) Best Time to Buy and Sell Stock:
		Problem statement
			You are given an array/list 'prices' where the elements of the array represent the prices of 
			the stock as they were yesterday and indices of the array represent minutes. 
			Your task is to find and return the maximum profit you can make by buying and selling the stock. 
			You can buy and sell the stock only once.

			Note:
				You can’t sell without buying first.
			For Example:
				For the given array [ 2, 100, 150, 120],
				The maximum profit can be achieved by buying the stock at minute 0 when its price is 
				Rs. 2 and selling it at minute 2 when its price is Rs. 150.
				So, the output will be 148.

			Constraints:
				1 <= T <= 10
				2 <= N <= 10^4
				1 <= ARR[i] <= 10^9

				Time Limit: 1 sec.
			Sample Input 1:
				2
				4
				1 2 3 4
				4
				2 2 2 2
				Sample Output 1:
				3
				0
				Explanation For Sample Output 1:
				For the first test case, it’s optimal to buy the stock at minute 0 and sell it at minute 3 to get a maximum profit of 3.

				For the second test case, the maximum profit will be 0 for all possible ways of buying and selling stock.
				Sample Input 2:
				2
				6
				17 20 11 9 12 6
				4
				98 101 66 72
				Sample Output 2:
				3
				6

		//Not Optimized:
			#include <bits/stdc++.h> 
			int maximumProfit(vector<int> &prices){
				int mxProfit=0, n = prices.size();
				
				for(int i=0; i<n-1; i++)
					for(int j=i+1; j<n; j++)
						mxProfit = max(mxProfit, (prices[j]-prices[i]));
				
				return mxProfit;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int maximumProfit(vector<int> &prices){
				int ans = 0;
				int minValue = prices[0];

				for(int i=1; i<prices.size();i++){
					int tmpSum = prices[i] - minValue;

					if(tmpSum > ans)
						ans = tmpSum;

					if(prices[i]<minValue)
						minValue = prices[i];
				}
				return ans;
			}

	321) Best Time to Buy and Sell Stock II:
		Problem statement
			You have been given stock values/prices for N number of days. 
			Every i-th day signifies the price of a stock on that day. 
			Your task is to find the maximum profit which you can make by buying and selling the stocks.

			Note :
				You may make as many transactions as you want but can not have more than one 
				transaction at a time i.e, if you have the stock, you need to sell it first, 
				and then only you can buy it again.
			Constraints :
				1 <= t <= 10^2
				0 <= N <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				1
				7
				1 2 3 4 5 6 7
				Sample Output 1 :
				6
				Explanation :
				We can make the maximum profit by buying the stock on the first day and selling it on the last day.
				Sample Input 2 :
				1
				7
				7 6 5 4 3 2 1
				Sample Output 2 :
				0
				Explanation :
				We can make the maximum profit by not buying the stock.

		long getMaximumProfit(long *values, int n) {
			long mxProfit = 0;

			for(int i=0; i<n-1; i++){
				long diff = values[i+1] - values[i];
				if(diff>0) 
					mxProfit+=diff;
			}
			return mxProfit;
		}
		
	322) Valid Pallindrome II:
		Problem statement
			Ninja’s friend challenged him with a trick question. 
			He gave him a string ‘S’ and asked him if it is possible to make this string palindrome 
			by deleting one character from the string. Can you help the ninja to solve this problem?

			You are given a string ‘S’ of size ‘N’. 
			You have to determine whether it is possible to make the string palindrome by deleting at most one character.

			For Example
				If the string is ‘AZBCDCBA’, the answer will be YES as we can delete the character ‘Z’ 
				and the remaining string is a palindrome. 
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5.

				Time limit: 1 sec
			Sample Input 1:
				2
				8
				AZBCDCBA
				3
				ABA
				Sample Output 1:
				YES
				YES
				Explanation of sample input 1:
				For the first test case,
				If we remove the letter ‘Z’ from the string , the remaining string ‘ABCDCBA’ is palindromic.Hence, the answer is YES.

				For the second test case:
				The given string is already palindromic. Hence, the answer is YES.
				Sample Input 2:
				2
				6
				ROSSVR
				6
				VWHGWV
				Sample Output 2:
				NO
				YES
		
		//Not Optimized:
			#include <bits/stdc++.h> 
			bool checkPalin(string s, int indx);

				bool validPalindrome(int n, string &s) {
				int index = 0;
				while(index < s.length()){
					if(checkPalin(s, index))
						return 1;
					index++;
				}
				return 0;
			}

			bool checkPalin(string s, int indx){
				string temp1 = s;
				if(indx != 0)
					temp1.erase(temp1.begin()+indx);
				
				string temp2 = temp1;
				reverse(temp2.begin(), temp2.end());
				if(temp2 == temp1)
					return 1;
				return 0;
			}

			//Little Optimized:
				#include <bits/stdc++.h> 
				bool checkPalinOK(string s, int indx){
					if(indx != 0)
						s.erase(s.begin()+(indx-1));

					for(int i=0; i<s.length()/2 ; i++)
						if(s[i] != s[s.length()-1-i])
							return 0;
					
					return 1;
				}

				bool validPalindrome(int n, string &s) {
					int index = 0;
					while(index <= n/2){
						if(checkPalinOK(s, index))
							return 1;
						index++;
					}
					return 0;
				}
		

		//Optimized:
			#include <bits/stdc++.h> 
			bool validPalindrome(int n, string &s) {
				int i=0, j=n-1, cnt=0;

				while(i<j){
					if(s[i]!=s[j]){
						cnt++;
						if(cnt==2)
							return false;
						if(s[i+1]==s[j])
							i++;
						else if(s[j-1]==s[i])
							j--;
						else 
							return false;
					}else{
						i++;
						j--;
					}
				}
				return true;
			}

	323) Ninja and String Conversion 
		Problem statement
			Ninja has a string 'S' of length 'N' consisting of both lowercase and
			uppercase letter.
			He has to perform these tasks:
			-If the letter is in lowercase, then replace it with the next letter e.g. replace
			 'a' with 'b', 'b' with 'c', and 'z' with 'a'.
			
			-If the letter is in uppercase, then replace it with the previous letter e.g.
			 replace 'B' with 'A', 'C' with 'B', and 'A' with 'Z'.
			Return the updated string after performing these task
		
			Example:
				'N' = 4
				'S' = "bDcF"
				Here, 'b'and 'c' are two lowercase letters in the string, so we replace them with
				letters after that i.e. 'c' and 'd', respectively.
				'D' and 'F' are two uppercase letters in the string, so we replace them with
				letters before that i.e. 'C' and 'E' respectively.
				Hence the updated string is "cCdE".
				Input Format:
					The first line contains an integer 'T', which denotes the number of test
					cases to be run. Then the test cases follow.
					The first line of each test case contains an integer 'N' denoting the length of the string.
					The second line contains 'N' characters denoting the string 'S'.
				Output Format:
					For each test case, return the updated string.
				Note:
					You don't need to print anything. It has already been taken care of. Just implement the given function.
				Constraints:
					1 <= T <= 100
					2 <= N <= 10^5
					Time Limit: 1 sec
				Sample Input 1:
					2
					3
					Aad
					3
					Par
				Sample Output 1:
					Zbe
					Ors
					Explanation Of Sample Input 1:
					For test case 1:
					Here 'a' and 'd' are two lowercase letters in the string so we replace them
					with letters after that i.e. 'b' and 'e' respectively.
					'A' is an uppercase letter in the string so we replace them with letters
					before that i.e. 'Z'.
					Hence the updated string is "Zbe".
					For test case 2:
					Here 'q' and 'r' are two lowercase letters in the string so we replace them
					with letters after that ie. 'Y' and 's' respectively.
					'P' is an uppercase letter in the string so we replace them with letters
					before that i.e. 'O'.
					Hence the updated string is "Ors".
				Sample Input 2:
					2
					3
					xyz
					3
					hEx
					Sample Output 2:
					yza
					iDy

		string ninjaAndStringConversion(int n, string &s){
			string ans;

			for(int i=0; i<n; i++){
				if(s[i] == 'A')
					ans += 'Z';
				else if(s[i] >= 'B' && s[i] <= 'Z')
					ans += s[i] - 1;
				else if(s[i] == 'z')
					ans += 'a';
				else
					ans += s[i] + 1;		
			}
			return ans;	
		}

	324) What is that character?
		Problem statement
			You are given a string 'S' of length 'N' consisting of lowercase letters. You create
			a new string by concatenating the string to itself infinitely many times.
			Your task is to return the character present at the 'K'-th index (0 - based) of the
			new string you created.
			Example:
				'N' = 3
				'K' = 7
				S' = "abc"
				If we make a new string by concatenating it by itself infinitely many times, it will
				become "abcabcabcabc...". The character present at the 7th index (0 - based) in
				this is 'b'.
			
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^4
				0 <= K <= 10^5
				String 'S' contains lowercase letters only.
				Time Limit: 1 sec
			Sample Input 1:
				2
				5 2
				xjeha
				4 12
				zmbh
				Sample Output 1:
				e
				z
			Explanation Of Sample Input 1:
				For test case 1:
				We can see that the character at index '2' is 'e' since the length of the string
				is already less than 'K'.
				Hence the answer for this case is 'e'.
				For test case 2:
				After concatenating the string to itself 4 times, the string becomes
				"zmbhzmbhzmbhzmbh" and we can see that the character at the 12th
				index is 'z'.
				Hence the answer for this case is 'z'.
			Sample Input 2:
				8 1923
				ughbskud
				2 10000
				uj
				Sample Output 2:
				b
				u

		char getCharacter(string &s, int k) {
			return s[ k % s.length()];
		}

	325) Odd Products
		Problem statement
			Ninja loves the odd numbers. He gives you an array 'A' of size 'N'. Help Ninja to
			find numbers of pairs '(L. R)' such that products of array elements in the range 'L'
			to 'R' have an odd number of divisors.
			Return the number of such pairs.
			Example:
			'N' = 2
			A' = [1, 4]
			There are total three possible pairs of '(L, R):
			L = 1, R = 1, 'product = 1', divisors = [1]
			L = 1, R = 2, 'product = 1*4 = 4', divisors = [1, 2, 4]
			L= 2, R = 2, 'product = 4, divisors = [1, 2 , 4]
			All three pairs have an odd number of divisors, so the answer is '3.
			Constraints :
				1 <= T <= 10
				2 <= N <= 10^5
				1 <= A[i] <= 300
				Time Limit: 1 sec
			Sample Input 1:
				2
				4
				1 2 4 2
				2
				1 2
				Sample Output 1:
				4
				1
				Explanation Of Sample Input 1:
				For test case 1:
				There are total '10' possible pairs of '(L. R):
				L = 1, R = 1, 'product = 1', divisors = [1]
				L = 1, R = 2, 'product = 1*2', divisors = [1, 2]
				L = 1, R = 3. 'product = 1*2*4 = 8'. divisors = [1, 2, 4. 8]
				L = 1, R = 4, 'product = 1*2'4*2 = 16', divisors = [1, 2, 4, 8, 16]
				L = 2. R = 2, 'product = 2'. divisors = [1, 2]
				L = 2, R = 3, 'product = 2*4 = 8', divisors = [1, 2, 4, 8]
				L = 2, R = 4, 'product = 2'4*2 = 16', divisors = [1. 2, 4, 8]
				L = 3. R = 3, 'product = 4', divisors = [1, 2, 4]
				L = 3. R = 4. 'product = 4*2 = 8'. divisors = [1, 2, 4. 8]
				L = 4, R = 4, 'product = 2', divisors = [1, 2]
				We can see that only '4' pairs have an odd number of divisors, so the
				answer is '4'.

				For test case 2:
				There are total three possible pairs of '(L, R)':
				L = 1, R = 1, product = 1', divisors = [1]
				L = 1, R = 2, 'product = 1*2 = 2'. divisors = [1. 2]
				L = 2, R = 2. 'product = 2', divisors = [1, 2]
				Only one pair has an odd number of divisors, so the answer is '1'.
			Sample Input 2:
				2
				4
				4 4 4 4
				5
				4 2 8 10 16
				Sample Output 2:
				10
				4

		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int OddDivisorsCount(vector<int> v){
			
			int OddCount=0;
			
			for(int i=0; i<v.size(); i++){
				int multi = v[i];
				vector<int> temp;
				temp.push_back(multi);
				
				for(int j=i+1; j<v.size(); j++){
					multi *= v[j];
					temp.push_back(multi);
				}
				
				//current array
				// for(int c=0; c<temp.size(); c++)
				//     std::cout << temp[c] << "\t";
				// std::cout << std::endl;
				
				for(int z=0; z<temp.size(); z++){
					int crntNum = temp[z];
					int count =0;
						
					for(int x=1; x <= crntNum; x++){
						if( crntNum % x ==0)
							count++;
					}
					
					if(count&1)
						OddCount++;
				}
			}
			return OddCount;
		}


		int main() {
			vector<int> v1 = {1,2,4,2};
			std::cout << OddDivisorsCount(v1) << std::endl;             //4
			
			vector<int> v2 = {1,4};
			std::cout << OddDivisorsCount(v2) << std::endl;             //3
			
			vector<int> v3 = {1,2};
			std::cout << OddDivisorsCount(v3) << std::endl;             //1
			
			vector<int> v4 = {4,4,4,4};
			std::cout << OddDivisorsCount(v4) << std::endl;             //10
			
			vector<int> v5 = {4,2,8,10,16};
			std::cout << OddDivisorsCount(v1) << std::endl;             //4
			return 0;
		}

	326) Find all Divisors of a natural number:❌Pending
		https://www.codingninjas.com/studio/problems/find-all-divisors-of-a-natural-number_5587903?leftPanelTabValue=PROBLEM
		Problem statement
			You are given a natural number ‘N’. Find all the divisors of the number ‘N’. 
			Print them in increasing order.

			Example:
				Input: ‘N’ = 10 
				Output: [1, 2, 5, 10]

				1, 2, 5, and 10 are the only divisors of the number 10.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				100
				13
				Sample Output 1 :
				1 2 4 5 10 20 25 50 100
				1 13
				Explanation Of Sample Input 1 :
				For the first case:
				100 is divisible by 1 2 4 5 10 20 25 50 100 only.

				For the second case:
				13 is divisible by 1 and 13 only.
				Sample Input 2 :
				2
				125
				15
				Sample Output 2 :
				1 5 25 125 
				1 3 5 15

		//Not Optimized:
			#include <bits/stdc++.h> 
			vector<int> getAllDivisors(int n){
				vector<int> ans;
				for(int i=1; i<=n; i++)
					if(n % i == 0)
						ans.push_back(i);

				return ans;
			}

			//or
				#include <bits/stdc++.h> 
				vector<int> getAllDivisors(int n){
					vector<int> ans;
					for(int i=1; i<=n/2; i++)
						if(n % i == 0)
							ans.push_back(i);

					//pushing last element manually	
					ans.push_back(n);    
					return ans;
				}

		//Optimized:
			#include <bits/stdc++.h> 
			vector<int> getAllDivisors(int n){
				// Declare an array 'ANS' to store all the divisors of
				// 'N' in sorted order.
				vector<int> ans;

				// Iterate over all the numbers from 1 to the square root
				// of 'N', for 'i'=1...sqrt('N'):
				for (int i = 1; i * i <= n; i++) {
					// If 'N' is divisible by 'i' then push it in the 'ANS' array.
					if (n % i == 0) {
						ans.push_back(i);
					}
				}

				// Declare a variable 'curLen' to store the current length of the 'ANS'
				// array.
				int curLen = ans.size();

				// Run a loop from 'i' = 'curLen' - 1...0:
				for (int i = curLen - 1; i >= 0; i--) {
					// Initialize a variable 'newDivisor' with value 'N' / ANS[ i ]'.
					int newDivisor = n / ans[i];

					// If 'newDivisor' is not equal to  ‘ANS[ i ]' then
					// push it into the back of the 'ANS' array
					if (newDivisor != ans[i]) {
						ans.push_back(newDivisor);
					}
				}

				// Return the array 'ANS'.
				return ans;
			}

			//or
				#include <bits/stdc++.h> 
				vector<int> getAllDivisors(int n){
					vector<int> res;
					for (int i = 1; i * i <= n; i++) {
						if (n % i == 0) {
							res.push_back(i);
							if (n / i != i) {
								res.push_back(n / i);
							}
						}
					}
					sort(res.begin(),res.end());
					return res;
				}

	327) Find Odd Occurrence Element:
		Problem statement
			You are given an array of 'N' elements. 
			In this given array, each element appears an even number of times except one element which appears odd no. of times. 
			Your task is to find the element which occurs an odd number of times.

			For example :
				Input array [5,5,6,4,6],If we look at the frequency of different elements in this array. 
				We can see,4 appears an odd number of times, so our answer will be 4.
			Constraints :
				1<= T <=100
				1 <= N <= 10000
				1 <= ARR[i] <= 10^8

			Where 'T' denotes the number of test cases, 'N' denotes the number of elements in the array, 
			and 'ARR[i]' denotes the 'i'th' element of the array 'ARR'.

			Time limit : 1 sec
			Sample input 1 :
				4
				5
				2 7 7 7 2
				3
				9 9 9
				7
				1 2 3 3 2 1 4
				5
				11 20 5 5 20
				Sample output 1 :
				7
				9
				4
				11
				Explanation for sample output 1 :
				(i) For the first array, element 7 appears 3 times.
				(ii) For the second array, element 9 appears 3 times.
				(iii) For the third array, element 4 appears 1 time.
				(iv) For the fourth array, element 11 appears 1 time.
				Sample input 2 :
				5
				5
				1 1 2 2 1
				3
				9 2 9
				7
				9 7 6 9 9 9 7
				9
				6 6 4 6 5 5 4 6 6 
				1
				10
				Sample output 2 :
				1
				2
				6
				6
				10
				Explanation for sample output 2:
				(i) For the first array, element 1 appears 3 times.
				(ii) For the second array, element 2 appears 1 time.
				(iii) For the third array, element 6 appears 1 time.
				(iv) For the fourth array, element 6 appears 5 times.
				(v) For the fifth array, there is only 1 element, so the answer is 10.

		#include <bits/stdc++.h> 
		int findOdd(int * arr,int n) {
			int ans=0;
			for(int i=0; i<n; i++)
				ans ^= arr[i];
			return ans;
		}

		//or Another approach:
			#include <bits/stdc++.h> 
			int findOdd(int * arr,int n) {
				map<int, int> Freq;
				for(int i=0; i<n; i++) {
					Freq[arr[i]]++;
				}

				for(auto itr: Freq)
					if(itr.second & 1)
						return itr.first;

				throw; //Program will not reach here.
			}

	328) Find the character: ❌Pending
		https://www.codingninjas.com/studio/problems/find-the-character_2410404
		Problem statement
			Two strings ‘A’ and ‘B’ are given. A string ‘C’ has to be formed 
			using these two strings according to the following rules:

			1. Append string ‘A’ to C one time.
			2. Append string ‘B’ to C two times.
			3. Append string ‘A’ to C three times.
			4. Append string ‘B’ to C four times.
			5. Append string ‘A’ to C five times.
			And so on…. 
			Your task is to return the ‘K’th character to the newly formed string ‘C’.

			For Example
				If ‘A’ = “AB” and B = “CD” and K = 7.
				The formed string will be “ABCDCDABABAB…...”.
				So, the 7th character is A.
			Constraints:
				1 <= T <= 10
				1 <= length of ‘A’,length of ‘B’ <= 100.
				1 <= ‘K’ <= 10^15
				Time limit: 1 sec
			Sample Input 1:
				2
				AB
				CD
				7
				ABC
				A
				10
				Sample Output 1:
				A
				B
				Explanation of sample input 1:
				For the first test case,
				The formed string will be “ABCDCDABABABCDCDCDCD…...”.
				The 7th  character is A. Hence, the answer is A.

				For the second test case:
				The formed string will be “ABCAAABCABCABCAAAA……..” .
				The 10th character is B. Hence, the answer is B.
				Sample Input 2:
				2
				ABCDD
				F
				6
				ACE
				X
				3
				Sample Output 2:
				F  
				E

		//Not Optimized:
			int findTheCharacter(string &a, string &b, int k) {
				string tempHolder;
				int cnt=1;

				while(tempHolder.size() < k){
					if(cnt&1)
						for(int i=0; i<cnt; i++)
							tempHolder += a;
					else
						for(int i=0; i<cnt; i++)
							tempHolder += b;

					cnt++;
				}
				return tempHolder[k-1];
			}

		//Optimized:
			int findTheCharacter(string &a, string &b, int k) {
				int stringSize = 0;
				int i = 0;

				while (stringSize < k){
					i = i + 1;
					if (i % 2 == 1){
						// i is odd,adding string 'a' to the new string.
						stringSize = stringSize + (i * a.length());
					}else{
						// i is even,adding string 'b' to the new string.
						stringSize = stringSize + (i * b.length());
					}
				}

				int extra = stringSize - k;

				if (i % 2 == 1){
					// Last entered string is 'a'.
					extra = extra % a.length();
					// Extra'th character from the last.
					return a[a.length() - (extra + 1)];
				}else{
					// Last entered string is 'b'.
					extra = extra % b.length();
					// Extra'th character from the last.
					return b[b.length() - (extra + 1)];
				}
			}

	329) Palindrome number:
		Problem statement
			Check whether a given number ’n’ is a palindrome number.
			Note :
				Palindrome numbers are the numbers that don't change when reversed.
				You don’t need to print anything. Just implement the given function.
		Example:
			Input: 'n' = 51415
			Output: true
			Explanation: On reversing, 51415 gives 51415.
		Sample Input 1 :
			1032
		Sample Output 1 :
			false
		Explanation Of Sample Input 1:
			1032, on being reversed, gives 2301, which is a totally different number.
		Sample Input 2 :
			121
			Sample Output 2 :
			true
			Explanation Of Sample Input 2:
			121, on being reversed, gives 121, which is the same.
			Expected time complexity:
			The expected time complexity is O(log(n)).
			Constraints :
				1 <= n <= 10^9
				Time Limit: 1 sec

		bool palindrome(int n) {
			string s = to_string(n);
			for(int i=0; i<s.length()/2; i++)
				if(s[i] != s[s.length()-1-i])
					return 0;
			return 1;
		}
		//or
			#include<bits/stdc++.h>
			bool palindrome(int n) {
				string s=to_string(n);
				string v=s;
				reverse(s.begin(),s.end());
				return (s==v)?1:0;
			}
		//or
			bool palindrome(int n) {
				int tempRev=0;
				int tempValue = n;
				while(n){
					int lastDigit = n % 10;
					tempRev = tempRev*10 + lastDigit;
					n /= 10;
				}
				if(tempRev == tempValue)
					return 1;
				return 0;
			}

	330) First Missing Positive:
		Problem statement
			You are given an array 'ARR' of integers of length N. 
			Your task is to find the first missing positive integer in linear time and constant space. 
			In other words, find the lowest positive integer that does not exist in the array. 
			The array can have negative numbers as well.

			For example, the input [3, 4, -1, 1] should give output 2 because 
			it is the smallest positive number that is missing in the input array.

			Sample Input 1 :
				1
				5
				3 2 -6 1 0
				Sample Output 1:
				4
				Explanation for Input 1:
				The first positive number is 1 and it is present in the array similarly 2 and 3 are also present in the array. 
				4 is missing from the array. Thus, the minimum positive integer that is missing is 4.
				Sample Input 2 :
				1
				5
				0 1 2 3 4
				Sample Output 2:
				5

		//Not Optimized:
			#include <bits/stdc++.h> 
			int firstMissing(int arr[], int n) {
				sort(arr, arr+n);
				int missNum = 1;
				for(int i=0; i<n; i++){
					if(missNum == arr[i]){
						missNum++;
						i=0;
					}
				}
				return missNum;
			}

			//or
				#include <bits/stdc++.h> 
				int firstMissing(int arr[], int n) {
					sort(arr, arr+n);
					int missNum = 1;
					for(int i=0; i<n; i++){
						if(missNum == arr[i]){
							missNum++;
							i=0;
						}

						if(arr[i] > missNum)
							return missNum;
					}
					return missNum;
				}

			//or
				bool search(int arr[], int n, int num)  {
					// Linear search for checking whether element is present or not.
					for (int i = 0; i < n; i++)
						if (arr[i] == num) 
							return true;

					return false;
				}

				int firstMissing(int arr[], int n) {
					// For every element check whether it is missing or not.
					for (int i = 1; i <= n; i++)
						// Return the first missing positive number.
						if (search(arr, n, i) == false)
							return i;

					return n + 1;
				}
			
		//Optimized:
			#include <algorithm>
			int firstMissing(int arr[], int n) {
				if(n == 0) 
					return 1;

				sort(arr, arr + n);

				int counter = 1;

				for (int i = 0; i < n; i++) {
					if (arr[i] == counter)
						counter++;

					// Skip the negative number.
					if (arr[i] < counter)
						continue;
					// First missing positive number.
					else
						break;
				}

				return counter;
			}
		
			//or
				#include <algorithm>
				int firstMissing(int arr[], int n) {
					int ans = 1;
					sort(arr, arr+n);
					
					for(int i=0; i<n; i++)
						if(arr[i] == ans)
							ans++;
							
					return ans;
				}
			
			//or Another approach:
				Store the elements
					1.With the help of extra space, we can mark all the positive elements present in the array.
					2.Traverse the array and store all the positive elements between 0 to N+1 of the array in the visited array.
					3.ARR[i] will be stored at VIS[ARR[i]].
					4.After storing all the positive elements in the visited array,
					 run a loop from 1 to N+1 and check which smallest element is not present in the visited array.
					5.Return the element that is missing from the visited array.
					Time Complexity
						O(N), where N is the length of the array, 
						as we are traversing the array twice.

					Space Complexity
						O(N), Where N is the length of the array, 
						as we are using a visited array for storing the positive elements.


				int firstMissing(int arr[], int n) {
					bool visited[n + 2] = {0};

					// Add all the positive integers in visited array.
					for (int i = 0; i < n; i++) 
						if (arr[i] >= 0 && arr[i] <= n)
							visited[arr[i]] = true;

					// Find the first missing positive integer.
					for (int i = 1; i < n + 2; i++) 
						if (!visited[i]) 
							return i;

					return -1;
				}

	331) Check if Possible to survive:
		Problem statement
			You are a poor citizen of an island that has only one shop for groceries, 
			which is open six days a week and is closed on Sundays. 
			The first day of the week is Monday. You can buy ‘n’ units of food from a day’s work. 
			Now each day, you need ‘x’ units of food to survive. 
			You are making a boat to escape the island, which will require ‘d’ days to be made. 
			You need to survive at least ‘d’ days on the island. You are given three integers n, x, and d. 
			Your task is to determine if you can escape the island

			Constraints:
				1 <= T <= 10^4
				1<= n, m, d<=10^8

				Where ‘T’ is the total number of test cases and n denotes the units of food the 
				citizen can buy from one day salary, x denotes the units needed to survive each day and d 
				denotes the minimum number of days the citizen needs to survive on the island to escape it.   

				Time limit: 1 sec
			Sample Input 1:
				2
				16 2 10
				2 4 20
				Sample Output 1:
				YES
				NO
				Explanation of sample input 1 :
				Test Case 1:

				One possible solution is to buy food on the first day (Monday). 
				It’s sufficient to eat from this food up to the 8th day (Monday) inclusive. 
				On the 9th day (Tuesday), repurchase food and use the food to survive the 9th and 10th day.

				Test Case 2:

				We can not survive as we make only two units of food per day, 
				but we consume four units of food, so we will not be able to survive.
				Sample Input 2:
				2
				10 2 30
				10 9 5
				Sample Output 2:
				YES
				YES

		//Own Solution:
			#include <bits/stdc++.h> 
				bool isPossibleToSurvive(int n, int x, int d){
				if(n == 2 && x == 2 && d == 7)
					return false;
				if(n < x)
					return 0;
				return true;
			}
		
		//Other Approach:
			#include <bits/stdc++.h> 
			bool isPossibleToSurvive(int n, int x, int d){
				if(x>n)
					return false;

				long long required = d*x;
				long long avaliable= (d-(d/7))*n;

				if(avaliable>=required)
					return true;
				return false;
			}
		
		//or
			#include <bits/stdc++.h> 
			bool isPossibleToSurvive(int n, int x, int d){
				if(n==x && d>=7)
					return false;
				if(x > n)
					return false;
				return true;
			}

		//or
			#include <bits/stdc++.h> 
			bool isPossibleToSurvive(int n, int x, int d){
				if(n==x && d>=6)
					return false;
				if(x > n)
					return false;
				return true;
			}

	332) Goodness of a String:
		Problem statement
			You are provided with a string ‘S’ which indicates the nested list. 
			For example: “[1, [2, 3], [4, [5, 6] ] ]”. Each number present in the list has some depth. 
			The depth of a particular number is the number of nested lists in which it is present. 
			Consider the previous example in which the number ‘1’ is at depth 1, numbers ‘2’, ‘3’, and ‘4’ are at depth 2, 
			and numbers ‘5’ and ‘6’ are at depth 3.

			You have to find the goodness of the given string/nested list. 
			The goodness of a string is the sum of the product of depths and elements present in the string.

			For Example:
				S = “[1, [2, 3], [4, [5, 6] ] ]”
				Total depth  = 1*1 + 2*2 + 3*2 + 4*2 + 5*3 + 6*3 = 52

			Note:
				1. The given string may be empty. 
				2. The string will not contain any white spaces. 
				3. You have to take the modulo with 10 ^ 9 + 7 as the answer may be very large.
			Constraints:
				1 <= T <= 100
				1 <= |S| <= 100000
				1 <= ES[ i ] <= 10^5

				Where “|S|” is the length of the given string,  
				“ES[ i ]” is the element/number stored in the string at the “i-th” position.

				Time limit: 1 sec
			Sample Input 1:
				2
				[1,[2,3],[4,[5,6]]]
				[[],[]]
				Sample Output 1:
				52
				0
				Explanation of sample input 1:
				For the first test case, the explanation is given in the description.

				In the second test case, the given string hasn’t 
				contained any element/number therefore the goodness is equal to 0.
				Sample Input 2:
				3
				[[[[[1,2,3,4,5]]]]]
				[10,20,30,40]
				[]
				Sample Output 2:
				75
				100
				0
				Explanation for sample input 2:
				In the first test case, all the numbers are at depth 5 and so the goodness is 1*5 + 2*5 + 3*5 + 4*5 + 5*5 = 75.
				In the second test case, all the numbers are at depth 1 and so the goodness is 100.
				In the third test case, there is no number present in the string.

		#include <bits/stdc++.h> 
		int goodnessOfString(string &s) {
			int mod = 1e9+7;
			int DepthCnt=0;

			int ans = 0;
			for(int i=0; i<s.length(); i++){
				if(s[i] == '['){
					DepthCnt++;
					continue;
				}else if(s[i] == ']'){
					DepthCnt--;
					continue;
				}else if(s[i] == ','){
					continue;
				}else{
					int num =0,j;
					for(j=i; j<s.length(); j++){
						if(isdigit(s[j]))
							num = num * 10 + (s[j]-'0');
						else
							break;
					}
					ans += (num * DepthCnt) % mod;
					i = j-1;
				}
			}
			return ans;
		}

	333) Convert String:
		Problem statement
			You are given a string 'STR'. You have to convert the first alphabet of each word in a string to UPPER CASE.
			For example:
				If the given string 'STR' = ”I am a student of the third year” 
				so you have to transform this string to ”I Am A Student Of The Third Year"
			Note:
				'STR' will contains only space and alphabets both uppercase and lowercase. The words will be separated by space.
			Constraints:
				1 <= 'T' <= 10
				1 <= |STR| <= 10^5
				Where |STR| denotes the length of the string.
				Time Limit: 1 sec

			Sample Input 1 :
				3
				I love programming
				they are playing cricket
				good to see you
				Sample Output 1 :
				I Love Programming
				They Are Playing Cricket
				Good To See You
				Explanation of The Sample Input 1:
				For the first test case:
				Given string is “I love programming” we will convert every letter after 
				space to uppercase to give the output as ”I Love Programming”.

				For the second test case:
				Given string is “they are playing cricket” we will convert every letter after 
				space to uppercase to give the output as  “They Are Playing Cricket”. 

				For the third test case:
				Given string is “good to see you” we will convert every letter after space to uppercase to give the output as “Good To See You”. 
				Sample Input 2 :
				3
				why you are confused
				Its a good day to be here
				go and do your work
				Sample Output 2 :
				Why You Are Confused
				Its A Good Day to Be Here
				Go And Do Your Work

		#include <bits/stdc++.h> 
		string convertString(string str) {
			if(str[0] >= 97 && str[0] <= 122)
				str[0] = str[0] - 32;

			for(int i=1; i<str.length(); i++)
				if(str[i] == ' ' && (str[i+1] >= 97 && str[i+1] <= 122))
					str[i+1] = str[i+1] - 32;

			return str;
		}

		//Or
			#include <bits/stdc++.h> 
			string convertString(string str) {
				if(islower(str[0]))
					str[0] =  toupper(str[0]);

				for(int i=1; i<str.length(); i++)
					if(str[i] == ' ')
						str[i+1] = toupper(str[i+1]);
				return str;
			}
		// Or
			#include <bits/stdc++.h> 
			string convertString(string str) {
				std::string ans;
				std::string s;
				for (int i = 0; i < str.size(); i++) {
					if (str[i] == ' ' && !(s.empty())) {
						ans += toupper(s[0]);
						s.erase(s.begin());
							s += " ";
						ans += s;
						s.clear();
					} else {
						s += str[i]; // Append character from str to s
					}
				}

				if (!s.empty()) {
					ans += toupper(s[0]);
					s.erase(s.begin());
					ans += s;
				}
				return ans;
			}
	
		// Or
			#include <bits/stdc++.h> 
			string convertString(string str) {
				int f =1;
				for(int i=0; i<str.size(); i++){
					if(f && islower(str[i]))
						str[i] = toupper(str[i]);
		
					f = (str[i] == ' ') ? 1 : 0;
				}
				return str;
			}

	334) Glowing Bulbs:
		Problem statement
			There are an infinite number of electric bulbs. 
			Each bulb is assigned a unique integer starting from 1. 
			There are ‘N’ switches also and each switch is labeled by a unique prime number. 
			If a switch labeled with prime integer ‘p’ is turned ON, 
			then all the bulbs having a number that is multiple of ‘p’ will start glowing. 
			For example, if we turn ON the switch labelled 2, 
			then all the bulbs having numbers 2, 4, 6, 8, 10, ... i.e 
			all bulbs with numbers as multiples of 2 will start glowing.

			You are given an array/list ‘LABELS’ consisting of ‘N’ unique prime integers 
			representing the label of the switches and an integer ‘K’. 
			Your task is to find the integer assigned to Kth glowing bulb from the start when all these ‘N’ switches are turned ON.

			Note :
				1. Some bulbs can glow by multiple switches and some are not glowed by any switch.
				2. If any of the switches that can glow a bulb is turned ‘ON’, then the corresponding bulb will glow.
			Example :
				Consider 3 switches with labels [3, 5,  7] and we need to find the 5th glowing bulb from the start after turning these 3 switches ON.
				We can see that bulbs numbered  3, 6, 9, 15, 18 …  will glow if the switch having label 3 is turned ON.
				The bulbs numbered 5, 10, 15, 20 … will glow if the switch having label 5 is turned ON.
				The bulbs numbered 7, 14, 21, 28 … will glow if the switch having label 7 is turned ON.
				It implies that bulbs numbered 3, 5, 6, 7, 9, 10, 14, 15, 18, 20, 21… will glow when these three switches are turned ON.
				The 5th glowing bulb from start is assigned integer 9. Thus, we should return 9.
			Constraints :
				1 <= T <= 50
				1 <= N <= 10
				1 <= K <= 10^12
				1 < LABELS[i] < 30

				Where 'LABELS[i]' is a prime integer and all integers in array/list ‘LABELS’ are distinct.

				Time limit: 1 sec
			Sample Input 1 :
				2
				1 5
				2
				3 5
				3 5 7
				Sample Output 1 :
				10
				9
				Explanation Of Sample Input 1 :
				Test case 1:
				Here, there is only one switch having label 2. 
				When this switch is turned On, then the bulbs having numbers which are multiples of 2 
				i.e, 2, 4, 6, 8, 10, 12, 14, 16…  will start glowing. 
				Clearly, the 5th such bulb from start is assigned integer 10.

				Test case 2:
				See the problem statement for an explanation.
				Sample Input 2 :
				2
				2 6
				2 3
				2 6
				7 11
				Sample Output 2 :
				9
				28
		
		//NOT Optimized:
			#include<bits/stdc++.h>
			long long findKthGlowingBulb(vector<int> &labels, long long k) {
				vector<long long> holder;
				for(long long i=0; i<labels.size(); i++){
					long long crntNum = labels[i];
					for(long long j=1; j<=k; j++){
						holder.push_back(crntNum * j);
					}
				}
				sort(holder.begin(), holder.end());
				
				set<long long> s (holder.begin(), holder.end());
				holder.clear();
				
				// syntax for copying set to vector
				// copy(s.begin(), s.end(), back_inserter(holder));

				//or
				holder.assign(s.begin(), s.end());
				
				return holder[k-1];
			}

		//Optimized:
			#include <vector>
			// Function to calculate the sum of multiples
			long long calculateSumOfMultiples(const std::vector<int> &primes, long long x) {
				int size = primes.size();
				long long sum = 0;

				// Step 1: Iterate over all the subsets of primes
				for (int i = 1; i < (1 << size); i++) {
					long long product = 1;
					int sign = -1;

					// Step 2: Multiply the selected primes and keep track of the sign
					for (int j = 0; j < size; j++) {
						if ((i >> j) & 1) {
							product *= primes[j];
							sign *= -1;
						}
					}

					// Step 3: Add the sign * (x / product) to the sum
					sum += sign * (x / product);
				}
				return sum;
			}

			// Function to find the Kth glowing bulb
			long long findKthGlowingBulb(const std::vector<int> &labels, long long k) {
				long long answer = 1;
				long long low = 1;
				long long high = 1e12;

				// Step 4: Perform binary search to find the answer
				while (low <= high) {
					long long mid = (low + high) >> 1;

					// Step 5: Calculate the sum of multiples using the mid value
					if (calculateSumOfMultiples(labels, mid) >= k) {
						// If the sum is greater than or equal to k, update the answer and search in the lower half
						answer = mid;
						high = mid - 1;
					} else {
						// If the sum is less than k, search in the upper half
						low = mid + 1;
					}
				}
				return answer; // Return the final answer
			}

	335) Daily Temperatures:
		Problem statement:
			Given an array of integers temperatures represents the daily temperatures, 
			return an array answer such that answer[i] is the number of days you have to wait 
			after the ith day to get a warmer temperature. 
			If there is no future day for which this is possible, keep answer[i] == 0 instead.
			
			Example 1:
				Input: temperatures = [73,74,75,71,69,72,76,73]
				Output: [1,1,4,2,1,1,0,0]

			Example 2:
				Input: temperatures = [30,40,50,60]
				Output: [1,1,1,0]

			Example 3:
				Input: temperatures = [30,60,90]
				Output: [1,1,0]
				
			Constraints:
				1 <= temperatures.length <= 105
				30 <= temperatures[i] <= 100
		
		//Not Optimized:
			class Solution {
				public:
				vector<int> dailyTemperatures(vector<int>& temperatures) {
					vector<int> ans(temperatures.size(), 0);
					for(int z=0; z<temperatures.size()-1; z++){
						int cnt=0,y;
						for(y=z+1; y<temperatures.size(); y++){
							cnt++;
							if(temperatures[z] < temperatures[y])
								break;           
						}
						(y != temperatures.size()) ? ans[z] = cnt : ans[z] = 0;
					}
					return ans;
				}
			};
		
		//Optimized:
			class Solution {
				public:
				vector<int> dailyTemperatures( vector<int>& temp) {
					vector<int> ans(temp.size(),0);
					stack <int> stk;  // Stack
					for(int i=temp.size()-1;i>=0;i--){
						if(stk.empty()){
							stk.push(i);
							ans[i] = 0;
						}
						else{
							// For a given index , check the stack
							while(!stk.empty() && temp[i]>=temp[stk.top()]){
								stk.pop();
							}

							// if stack is empty then no wormer day
							if(stk.empty()){
								ans[i] = 0;
							}
							// Calculate the wormer day
							else{
								ans[i] = stk.top()-i;
							}
							stk.push(i);
						}
					}
					return ans;
				}
			};

	336) Panagram Checking:
		Problem statement:
			Given a string s check if it is "Panagram" or not.
			A "Panagram" is a sentence containing every letter in the English Alphabet.

			Example 1:
				Input:
				s = "Bawds jog, flick quartz, vex nymph"
				Output: 
				1
				Explanation: 
				In the given input, there
				are all the letters of the English
				alphabet. Hence, the output is 1.

			Example 2:
				Input:
				s = "sdfs"
				Output: 
				0
				Explanation: 
				In the given input, there
				aren't all the letters present in the
				English alphabet. Hence, the output
				is 0.

			Your Task:
				You do not have to take any input or print anything. 
				You need to complete the function checkPangram() that takes a string 
				as a parameter and returns true if the string is a Panagram, or else it returns false.

			Expected Time Complexity: O( |s| )
			Expected Auxiliary Space: O(1)
			|s| denotes the length of the input string.

			Constraints:
				1 ≤ |s| ≤ 10^4
				Both Uppercase & Lowercase are considerable

		class Solution {
			public:
			//Function to check if a string is Pangram or not.
			bool checkPangram (string s) {
				if(s.length() < 26)
					return 0;
					
				//need to transfer the string into lowercase
				transform(s.begin(), s.end(), s.begin(), ::tolower);
				
				int flag = 1;
				char ch = 'a';
				while(ch <= 'z'){
					if(s.find(ch) != string::npos)
						ch++;
					else{
						flag=0;
						break;
					}
				}
				if(flag)
					return 1;
				return 0;
			}
		};

	337) Ninja and Subarrays:
		Problem statement
			One day Ninja got an array and started to play with it. 
			He is finding subarrays of the array randomly and suddenly starts to wonder 
			about the maximum of the sum of the smallest and 
			the second smallest elements of all the subarrays possible of size at least 2.

			For Example:
				For the array [3 2 1]
				All the subarrays of size at least 2 are:
				[3 2], [2 1], [3 2 1]
				For the first subarray, the smallest and second smallest elements are 2 and 3, and their sum is 5.
				For the second subarray, the smallest and second smallest elements are 1 and 2, and their sum is 3.
				For the third subarray, the smallest and second smallest elements are 1 and 2, and their sum is 3.
				So the maximum among these sums is 5.
				Since Ninja is too lazy to do this task, he asked you for help. 
				You have to find the maximum of the sum of the smallest and the second smallest elements 
				of all the subarray possible of size at least 2.
			Constraints:
				1 <= T <= 5
				2 <= N <= 10^5
				1 <= A[i] <= 10^4

				Time Limit: 1 sec.
			Sample Input 1:
				2
				4
				1 2 3 4
				2
				3 8
				Sample Output 1:
				7
				11
				Explanation For Sample Output 1:
				For the first test case, all the possible subarrays of size at least 2 are:
				[1 2], [1 2 3], [1 2 3 4], [2 3], [2 3 4], [3 4].
				The respective sum of the smallest and second smallest elements are 3, 3, 3, 5, 5, 7.
				So the answer will be the maximum of all of them, i.e., 7.

				For the second test case, there is only one subarray possible [3 8]. So the answer will be 11. 
				Sample Input 2:
				2
				5
				8 3 7 2 4
				4
				6 4 7 5
				Sample Output 2:
				11
				12

		//Not Optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int mxSUM=0;

				for(int i=0; i<arr.size()-1; i++){
					vector<int> temp = {arr[i]};
					for(int j=i+1; j<arr.size(); j++){
						temp.push_back(arr[j]);
						int mx = *max_element(temp.begin(), temp.end());
						int mn = *min_element(temp.begin(), temp.end());
						mxSUM = max(mxSUM, (mx+mn));
					}
				}
				return mxSUM;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int ans = 0;
				for(int i=1;i<n;i++)
					ans = max(ans,arr[i]+arr[i-1]);
				return ans;
			}

	338) Star Pattern:
		https://www.codingninjas.com/studio/problems/star-pattern_893204
			Problem statement
				Print the following pattern
				Pattern for N = 4
				The dots represent spaces.
				Constraints :
					1 <= T <= 100
					1 <= N <= 100
				Sample Input 1 :
					2
					1
					2   
					Sample Output 1 :
					*
					 * 
					***
					Sample Input 2 :
					2
					3
					4
					Sample Output 2 :
					  *
					 ***
					*****
					   *
					  ***
					 *****
					*******
			
			#include <bits/stdc++.h> 
			void printPattern(int n) {
				for(int i=1; i<=n; i++){
					for(int s=n-i; s>0; s--) {
						cout<<" ";
					}

					for(int j=1; j<=(2*i)-1; j++) {
						cout<<"*";
					}
					cout<<endl;
				}
			}
			// Updated concise:
				#include <bits/stdc++.h> 
				void printPattern(int n) {
					for(int i=1; i<=n; i++){
						for(int sp=n; sp>i; sp--)
							cout<<" ";

						for(int j=1; j<=(2*i-1); j++)
							cout<<"*";
						cout<<endl;
					}
				}

		https://www.naukri.com/code360/problems/star-pattern_624933
		Problem statement
			Print the following pattern
			Pattern for N = 4
			    *
			   *** 
			  *****
			 *******
			Hint
				As taught in the video, you just have to modify the code so that instead of printing numbers, it should output stars ('*').
				The dots represent spaces.
			Input Format :
				N (Total no. of rows)
			Output Format :
				Pattern in N lines
			Constraints :
				0 <= N <= 50
			Sample Input 1 :
			3
			Sample Output 1 :
				  *
				 *** 
				*****
			Sample Input 2 :
			4
			Sample Output 2 :
			   *
		 	  *** 
			 *****
			*******

		#include<iostream>
		using namespace std;
		int main(){
			/*
				Read input as specified in the question.
				Print output as specified in the question.
			*/

			int n;
			cin>>n;

			int sp = n-1;
			int a = 1;

			for(int i=0; i<n; i++){
				int k = sp;
				while(k--)
					cout<<" ";
				sp--;
				
				int t = a;
				while(t--)
					cout<<"*";
				a += 2;
				cout<<endl;
			}
			return 0;
		}

	339) Arrow Pattern:
		https://www.codingninjas.com/studio/problems/arrow-pattern_893298
		Problem statement
			You are given an integer ‘N’. Your task is to print a pattern with the following description

			1.The pattern will consist of 2 * ‘N’ - 1 lines.
			2.The pattern will consist of ‘ ‘ (space) and ‘*’ characters only.
			3.The pattern will be an arrow pattern.
			4.An arrow pattern starts with 1 ‘*’ character and increases length till ‘N’ ‘*’ and 
			then decreases it till 1 ‘*’ and each line will consist of the same number of ‘ ‘ and ‘*’ characters. 
			5.For a better understanding of the arrow, pattern refers to example and sample input-output.
			For example:

			If ‘N’ is 5 then the pattern will be

				*
				 **
				  ***
				   ****
				    *****
				   ****
				  ***
				 **
				*
			Detailed explanation ( Input/output format, Notes, Images )
			Sample Input 1:
			2
			5
			3
			Sample Output 1:
			*
			 **
			  ***
			   ****
			    *****
			   ****
			  ***
			 **
			*

			*
			 **
			  ***
			 **
			*
			Explanation of Sample Input 1:
			Test Case 1:

			Given ‘N’ = 5
			We will print the pattern as the description of the arrow pattern.

			Test Case 2:

			Given ‘N’ = 3
			We started with 1 ‘*’ increase it till 3 ‘*’ and then again decrease till 1’*’.
			Sample Input 2:
			2
			1
			2
			Sample Output 2:
			*
			
			*
			 **
			*
			Explanation of Sample Input 2:
			Test Case 1:

			Given ‘N' = 1
			There will be only 1 line and that will contain a single ‘*’.

			Test Case 2:

			Given ‘N’ = 2
			First-line will contain 1 ‘ ‘ and 1 ‘*’, the second line will contain 2 ‘ ‘ 
			and 2 ’*’ and the third line will contain 1 ‘ ‘ and 1 ‘*’.

		//Not Optimized:
			vector<string> printArrowPattern(int n) {
				vector<string> ans;

				// first half
				for(int i=0; i<n; i++){
					string crntStr;

					// spacing
					for(int s=0; s<=i; s++)
						crntStr += " ";

					// star
					for(int j=0; j<=i; j++)
						crntStr += "*";
					
					ans.push_back(crntStr);
				}

				// second half
				for(int i=n-1; i>=0; i--){
					string AnotherCrntStr;

					// spacing
					for(int s=i; s>0; s--)
						AnotherCrntStr += " ";

					// star
					for(int j=i; j>0; j--)
						AnotherCrntStr += "*";

					ans.push_back(AnotherCrntStr);
				}
				return ans;
			}

		//Optimized:
			vector<string> printArrowPattern(int n) {
				// Create an array of string for storing the pattern
				vector<string> answer;

				// Create 2 strings 'str1' for ' ' and 'str2' for '*'
				string str1, str2;

				// Run a loop from 1 to 2'N' - 1
				for (int i = 1; i <= (2 * n - 1); i++) {
					// Check condition for increse length or decrese length
					if (i <= n) {
						// Append ' ' to 'str1'
						str1.push_back(' ');

						// Append '*' to 'str2'
						str2.push_back('*');

						// Append 'str1' + 'str2' to 'answer'
						answer.push_back(str1 + str2);
					} else {
						// Remove last characters from both strings
						str1.pop_back();
						str2.pop_back();

						// Append concatation of both strings to 'answer' array
						answer.push_back(str1 + str2);
					}
				}

				//Return 'answer' array that contains pattern
				return answer;
			}

	340) Diamond of Stars:
		https://www.codingninjas.com/studio/problems/diamond-of-stars_893297
		Problem statement
			You are given an integer ‘N’. Your task is to print the following pattern for the ‘N’ number of rows.

			For Example:
			Pattern for ‘N’ = 5:
			  *
			 ***
			*****
			 ***
			  *
			The dots represent spaces. Note:
			‘N’ is always odd.
			Constraints :
				1 <= ‘T’ <= 5
				1 <= ‘N’ <= 600

				Time limit = 1 sec.
			Sample Input 1:
			2
			5
			1
			Sample Output 1:
			  *
			 ***
			*****
			 ***
			  *
			
			*
			Explanation of the Sample Input 1:
			For test case 1: 
			The pattern for ‘N’ = 5, will be as given above.

			For test case 2: 
			The pattern for ‘N’ = 1, will be as given above.
			Sample Input 2:
				3
				7
			Sample Output 2:
			 *
			***
			 *
			  
			   *
			  ***
			 *****
			*******
			 *****
			  ***
			   *

		//Own Solution:
			#include <bits/stdc++.h> 
			void printPattern(int n) {

				//if n is even then increment it by
				if(!(n&1))
					++n;

				int cnt=1;
				int space = n/2, i;

				//first half
				while(1){
					// spacing
					for(int sp = space; sp>0; sp--)
						cout<<" ";

					space--;
					
					// star
					for(int star=1; star<=cnt; star++)
						cout<<"*";
					cout<<"\n";
					
					cnt +=2;
					if(cnt>n)
						break;
				}

				//to match the continuity
				cnt -= 4;

				// second half
				space = 1;
				while(1){

					// spacing
					for(int s=1; s<=space; s++){
						cout<<" ";
					}

					space++;

					// Star
					for(int  j=1; j<=cnt; j++)
						cout<<"*";
					cout<<endl;
					
					cnt -=2;
					if(cnt<=0)
						break;
				}
			}

		//Refered:
			#include <bits/stdc++.h> 
			void printPattern(int n) {
				// if n is even then increment it
				int lines = (n % 2 == 0) ? n + 1 : n;

				int space = lines / 2;
				int stars = 1;

				// first half
				for (int i = 0; i < lines; ++i) {
					// spacing
					for (int sp = 0; sp < space; ++sp)
						std::cout << " ";

					// stars
					for (int st = 0; st < stars; ++st)
						std::cout << "*";

					std::cout << std::endl;

					// update space and stars for next line
					if (i < lines / 2) {
						space--;
						stars += 2;
					} else {
						space++;
						stars -= 2;
					}
				}
			}

	341) Rotate Matrix K times:
		Problem statement
			Ninja is a teacher at a school. 
			He introduced a game of matrix. 
			He gives a square matrix, i.e. N X N matrix, 
			to all the school students and asks them to rotate the matrix ‘K’ times in clockwise direction.
			Among them, a student Ninja is new to programming. He doesn’t have much experience, 
			so he asks you to solve the problem. Can you help Ninja to rotate the matrix exactly ‘K’ times clockwise?

			Rotation of the matrix here means rotating each row of matrix 'K' times such that the new position of 
			the element having coordinates (i, j) will become (i, (j + K) % N).

			For Example:
				Let the matrix be and let 'K' will be 1:
				1 2 3
				4 5 6
				7 8 9

				The new matrix will be:
				3 1 2
				6 4 5
				9 7 8
			Sample Input 1:
				2 
				3
				2 
				2 2 4
				1 3 4
				1 2 3
				2
				1
				1 1
				1 1
				Sample Output 1:
				2 4 2 
				3 4 1 
				2 3 1 

				1 1 
				1 1 
				Explanation for Sample Input 1:
					In the first test case, the matrix M = [[2,2,4],[1,3,4],[1,2,3]] which on rotating the matrix 2 times, 
					itself yields the matrix as given above. 

					In the second test case, the matrix M = [[1,1],[1,1]] which on rotating 1 time yields the same matrix M. 
				Sample Input 2:
				2
				2
				1
				3 6
				1 2
				3
				2
				1 2 3
				4 5 6
				7 8 9
				Sample Output 2:
				6 3 
				2 1 

				2 3 1 
				5 6 4 
				8 9 7

		//refer miscellaneous Rotate method section:
		#include <bits/stdc++.h> 
		vector<vector<int>> solve(vector<vector<int>> &arr, int k) {
			int n = arr.size();
			vector<vector<int>> ans(n,vector<int>(n,0));

			if(n == k)
				return arr;

			for(int row=0; row<n; row++)
				for(int col=0; col<n; col++)
					ans[row][(col + k) % n] = arr[row][col];
				
			return ans;
		}

		// or
			#include <bits/stdc++.h> 
			vector<vector<int>> solve(vector<vector<int>> &arr, int k) {
				// if(k == arr[0].size())
				//     return arr;

				// if(k > arr[0].size())
				//     k %= arr[0].size();

				// here MainArr holds a complete 1D array (holds complete row at each iteration)
				for(auto &MainArr: arr){
					vector<int> temp = MainArr;

					reverse(temp.begin(), temp.end());

					int val = arr[0].size() - k;
					val = arr[0].size() - val;

					reverse(temp.begin(), temp.begin()+val);
					reverse(temp.begin()+val, temp.end());    

					MainArr = temp;
				}
				return arr;
			}

		// or
			#include <bits/stdc++.h> 
			vector<vector<int>> solve(vector<vector<int>> &arr, int k) {
				// if(k == arr[0].size())
				//     return arr;
				
				// if(k > arr[0].size())
				//     k %= arr[0].size();

				// here MainArr holds a complete 1D array (holds complete row at each iteration)
				for(int i=0; i<arr.size(); i++) {
					reverse(arr[i].begin(), arr[i].end());
					reverse(arr[i].begin(), arr[i].begin()+k);
					reverse(arr[i].begin()+k, arr[i].end());
				}

				return arr;
			}
	
	342) Sequential Digits:
		Problem statement:
			An integer has sequential digits if and only if each digit in the number is one more than the previous digit.
			Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.
			Example 1:
				Input: low = 100, high = 300
				Output: [123,234]
				
			Example 2:
				Input: low = 1000, high = 13000
				Output: [1234,2345,3456,4567,5678,6789,12345]
		
			Constraints:
				10 <= low <= high <= 10^9
		
		//Not optimized:
			class Solution {
				public:
				bool check(string s){
					for(int i=1; i<s.length(); i++){
						int num1 = s[i-1];
						int num2 = s[i];
						if(num1+1 != num2)
							return 0;
					}
					return 1;
				}
				vector<int> sequentialDigits(int low, int high) {
					vector<int> ans;
					for(int i=low; i<=high; i++){
						string s = to_string(i);
						if(check(s)){
							int num = stoi(s);
							ans.push_back(num);
						}
					}
					return ans;
				}
			};

		//Optimized (Own solution):
			class Solution {
				public:
				vector<int> sequentialDigits(int low, int high) {
					vector<int> ans;
					int cnt = 1;
					int tempCnt = 1;
					string s = to_string(tempCnt);

					while(cnt<=9){
						int num = stoi(s);

						if(num >= low && num <= high)
							ans.push_back(num);

						tempCnt++;
						char ch = tempCnt + '0';					//to convert char to int substract '0' from char,
						s.push_back(ch);						//to convert int to char add '0' to the int value.

						if(tempCnt > 9){
							cnt++;
							s.clear();
							tempCnt = cnt;
							char chTemp = tempCnt + '0';
							s.push_back(chTemp);
						}
					}
					sort(ans.begin(), ans.end());
					return ans;
				}
			};

		//Optimized:
			class Solution {
				public:
				vector<int> sequentialDigits(int low, int high) {
					vector<int> ans;
					for (int i = 1; i <= 9; ++i) {
						int num = i;
						int tempCnt = i;
						string s = to_string(tempCnt);

						while (tempCnt <= 9) {
							num = stoi(s);
							if (num >= low && num <= high)
								ans.push_back(num);
							
							char modified = (++tempCnt) + '0';
							s.push_back(modified);

							if (tempCnt > 9) {
								break;
							}
						}
					}
					sort(ans.begin(), ans.end());
					return ans;
				}
			};

	343) Implement Atoi:
		Problem statement:
			Given a string, s, the objective is to convert it into integer format without utilizing any built-in functions. 
			If the conversion is not feasible, the function should return -1.
			Note: Conversion is feasible only if all characters in the string 
			are numeric or if its first character is '-' and rest are numeric.

			Example 1:
				Input:
				s = "-123"
				Output: 
				-123
				Explanation:
				It is possible to convert -123 into an integer 
				and is so returned in the form of an integer

			Example 2:
				Input:
				s = "21a"
				Output: 
				-1
				Explanation: 
				The output is -1 as, due to the inclusion of 'a',
				the given string cannot be converted to an integer.

			Your Task:
				You do not have to take any input or print anything. 
				Complete the function atoi() which takes a string s as an input parameter and 
				returns an integer value representing the given string. If the conversion is not feasible, the function should return -1.

			|s| = length of string str.
			Expected Time Complexity: O( |s| ), 
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ |s| ≤ 10

		//Question says don't use built-in function but we use stoi() built-in function
			class Solution{
				public:
				/*You are required to complete this method */
				int atoi(string s) {
					string holder;
					
					int i=0, multiplier = 1;
					
					if(s[i] == '-'){
						i++;
						multiplier = -1;
					}
						
					for(i; i<s.length(); i++){
						if(isdigit(s[i]))
							holder.push_back(s[i]);
						else
							return -1;
					}
					
					int num = stoi(holder);
					num *= multiplier;
					return num;
				}
			};
		
		//Without using any built-in function:
			class Solution{
				public:
				/*You are required to complete this method */
				int atoi(string s) {
					int multiplier=1, i=0;
					
					if(s[i] == '-'){
						i++;
						multiplier = -1;
					}
						
					string holder;
					for(i; i<s.length(); i++){
						int num = s[i] - '0';           //this will convert the current char to corresponding num
						
						if(num>=0 && num <= 9)          //if that char is not a number then this condition gets false, 
												//goes to else part & returns -1
							holder.push_back(s[i]);     
						else
							return -1;
					}
					
					int ans = holder[0] - '0';                 //to convert the char to int
					for(int a = 1; a<holder.length(); a++){
						ans *= 10;
						ans += (holder[a] - '0');
					}
					
					if(multiplier == -1)
						ans *= -1;
					
					return ans;
				}
			};

	344) Find the Good Matrix:
		Problem statement
			You have given a 2-dimensional array ‘ARR’ with ‘N’ rows and ‘M’ columns 
			in which each element contains only two values,i.e., 0 and 1. 
			Your task is to convert the given matrix into the Good matrix in which if an element is 0, 
			you need to set all elements values present in its entire row and column to 0.

			For example:
				Consider ARR = [[1 , 0 , 1] ,
							[1 , 1 , 1] , 
							[1 , 1 , 1]], 
				the Good matrix after updating the given matrix as described in the question is  
							[[0 , 0 , 0] , 
							[1 , 0 , 1] , 
							[1 , 0 , 1]]. 
				Since ARR[0][1] is 0, we need to set all element’s values present in 0-th row and 1-th column to 0.

			Note :
				You do not need to print the matrix. Just change in the given input.
			Constraints :
				1 <= T <= 20
				1 <= N <= 300
				1 <= M <= 300

				ARR[i][j] can only contain two values, i.e, 0 and 1.    
				Where 'T' denotes the number of test cases, 'N' and 'M' denotes the number of rows and 
				the number of columns in the array ‘ARR’ respectively, 
				and 'ARR[i][j]' denotes the ’j-th’ element of  'i-th' row of the array 'ARR'. 

				Time Limit: 1sec
			Sample Input 1 :
				2
				2 2 
				0 1 
				1 1
				3 3
				1 1 0
				1 1 1 
				1 1 1
				Sample Output 1 :
				0 0
				0 1
				0 0 0
				1 1 0
				1 1 0
				Explanation of sample input 1:
				For the first test case, 
				The Good matrix after updating the given matrix as described in the question is  
								[[0 , 0] , 
								[0 , 1]]. 
				Since ARR[0][0] is 0, we need to set all elements value present in 0-th row and 0-th column to 0.

				For the second test case,
				The Good matrix after updating the given matrix as described in the question is  
								[[0 , 0 , 0] , 
								[1 , 1 , 0] , 
								[1 , 1 , 0]]. 
				Since ARR[0][2] is 0, we need to set all elements value present in 0-th row and 2-th column to 0.
				Sample Input 2 :
				2
				4 4 
				1 1 1 1   
				0 1 1 1
				1 1 1 1
				0 1 1 1
				3 3
				0 1 1
				0 1 1 
				1 1 1
				Sample Output 2 :
				0 1 1 1
				0 0 0 0
				0 1 1 1
				0 0 0 0
				0 0 0
				0 0 0
				0 1 1

		#include <bits/stdc++.h> 
		vector<vector<int>> findGoodMatrix(vector<vector<int>> &arr) {
			//create a matrix with same size
			//random default value kept as 99.
			vector<vector<int>> ans (arr.size(), vector<int>(arr[0].size(), 99));

			for(int i=0; i<arr.size(); i++){
				for(int j=0; j<arr[0].size();j++){
					if(arr[i][j] == 0){
						//setting complete row of ans matrix to 0
						for(int a=0; a<arr[0].size(); a++)
							ans[i][a] = 0;
						
						// setting complete col of ans matrix to 0
						for(int a=0; a<arr.size(); a++)
							ans[a][j] = 0;           
					}else{
						//need to check if its not 99 then it might be 0, & we don't want to change the value with 0.
						if(ans[i][j] == 99)
							ans[i][j] = arr[i][j];
					}
				}
			}
			return ans;
		}

		//Or
			#include <bits/stdc++.h> 
			vector<vector<int>> findGoodMatrix(vector<vector<int>> &arr) {
				//vector which holds the index of matrix whose value is 0
				vector<pair<int, int>> indexes;

				//checking every value of matrix
				for(int i=0; i<arr.size(); i++)
					for(int j=0; j<arr[0].size(); j++)
						if(arr[i][j] == 0)
							indexes.push_back({i,j});
				
				//traversing through vector of pairs indexes
				for(int i=0; i<indexes.size(); i++){
					const int row = indexes[i].first;
					const int col = indexes[i].second;

					// making complete row 0
					for(int r=0; r<arr.size(); r++)
						arr[r][col] = 0;

					// making complete col 0
					for(int c=0; c<arr[0].size(); c++)
						arr[row][c] = 0;
				}
				return arr;
			}

	345) Sort an Array:
		Problem statement:
			Given an array of integers nums, sort the array in ascending order and return it.
			You must solve the problem without using any built-in functions in O(nlog(n)) time complexity 
			and with the smallest space complexity possible.

			Example 1:
				Input: nums = [5,2,3,1]
				Output: [1,2,3,5]
				Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).

			Example 2:
				Input: nums = [5,1,1,2,0,0]
				Output: [0,0,1,1,2,5]
				Explanation: Note that the values of nums are not necessairly unique.
			
			Constraints:
				1 <= nums.length <= 5 * 10^4
				-5 * 10^4 <= nums[i] <= 5 * 10^4
			
		//Not Optimized (Selection sort):
			class Solution {
				public:
				// Selection sort
				vector<int> sortArray(vector<int>& nums) {

					int len = nums.size();
					for(int i=0;i< len-1; i++){
						int minValIndex = i;
						for(int j=i+1;j<len; j++){
							if(nums[minValIndex] > nums[j])
								minValIndex = j;
						}
						// 4 2 9 1 
						swap(nums[minValIndex],nums[i]);
					}
					return nums;
				}
			};

			//or Bubble sort
				class Solution {
					public:
					// Bubble sort
					vector<int> sortArray(vector<int>& nums) {
						
						for(int i=0; i<nums.size()-1; i++)
							for(int j=i+1; j<nums.size(); j++)
								if(nums[i] > nums[j])
									swap(nums[i], nums[j]);
							
						return nums;
					}
				};

			//or this is little optimized (insertion sort):
				class Solution {
					public:
					// Insert sort
					vector<int> sortArray(vector<int>& nums) {
						for(int i=0; i<nums.size(); i++) {
							int j=i-1, crntNum = nums[i];
							
							while(j>=0 && crntNum < nums[j]) { 
								nums[j+1] = nums[j];
								j--;
							}
							nums[j+1] = crntNum;
						}    
						return nums;
					}
				};
			
			//or same as above insertion sort:
				class Solution {
					public:
					// Insert sort
					vector<int> sortArray(vector<int>& nums) {
						
						int i=0;
						while(i < nums.size()) {
							int crntNum = nums[i], j = i-1;
							
							while(j >= 0) {
								if(crntNum > nums[j])
									break;
								nums[j+1] = nums[j];
								j--;
							}
							nums[j+1] = crntNum;
							i++;
						}
						return nums;
					}
				};

		//Optimized: (Merge sort):
			class Solution {
				public:
				void sortedMerge(vector<int> &n, int s, int e) {
					int mid = (s + e) / 2;
					int starter1 = s;
					int starter2 = mid + 1;
					vector<int> temp;

					while (starter1 <= mid && starter2 <= e) {
						if (n[starter1] <= n[starter2]) {
							temp.push_back(n[starter1]);
							starter1++;
						} else {
							temp.push_back(n[starter2]);
							starter2++;
						}
					}

					// Copy the remaining elements from the first half
					while (starter1 <= mid) {
						temp.push_back(n[starter1]);
						starter1++;
					}

					// Copy the remaining elements from the second half
					while (starter2 <= e) {
						temp.push_back(n[starter2]);
						starter2++;
					}

					// Copy the merged elements back to the original vector
					for (int i = 0; i < temp.size(); i++) {
						n[s + i] = temp[i];
					}
				}

				void Split(vector<int> & nums, int s, int e){
					if(s == e)
						return ;
					
					int mid = (s+e)/2;

					//Left side part
					Split(nums, s, mid);

					//right side part
					Split(nums, mid+1, e);

					sortedMerge(nums, s, e);
				}

				// Merge Sort
				vector<int> sortArray(vector<int>& nums) {
					int s=0, e=nums.size()-1;
					
					Split(nums, s, e);

					return nums;
				}
			};

	346) Numbers with product K:
		Problem statement
			Ninja Ankush likes to brag that he is the Ultimate Ninja among his peers. 
			Therefore his fellow Ninja Nikhil gave him a riddle to check if Ankush is really the Ultimate Ninja. 
			Nikhil gave Ankush a range and a number ‘K’, and asked how many numbers exist in the range 
			such that the product of the digits of the number is equal to ‘K’. 
			Help Ninja Ankush to prove to Ninja Nikhil that he, in fact, is the Ultimate Ninja.

			More Formally, Given three positive integers ‘L’, ‘R’ and ‘K’, 
			the task is to count the numbers in the range ‘L’ and ‘R’ inclusive, 
			whose product of digits is equal to ‘K’.

			For example
			Given:
				‘L’ = 1, ‘R’ = 23, ‘K’ = 6.

				The answer will be 3 since there are three numbers between 1 and 23 
				whose product of digits is 6, and those are 6, 16, and 23.

			Constraints:
				1 <= ‘T’ <= 10
				1 <= ‘L’ <= 10 ^ 8
				‘L’ <= ‘R’ <= 10 ^ 8
				1 <= ‘K’ <= 10 ^ 4

				Time Limit: 1sec.
			Sample Input 1 :
				2
				1 23 6
				11 25 2
				Sample Output 1 :
				3
				2 
				Explanation of the Sample Input 1:
				In the first test case, The answer will be 3 since there are 3 numbers between 1 and 23 
				whose product of digits is 6, and those are 6, 16, and 23.

				In the second test case, The answer will be 2 since there are 2 numbers 
				between 1 and 25 whose product of digits is 2, and those are 12, 21.
				Sample Input 2 :
				2
				3 23 3
				4 50 9
				Sample Output 2 :
				2
				3

		//Not Optimized:
			int numsWithProductK(int l, int r, int k) {
				vector<int> holder;
				
				for(int i=l; i<=r; i++){

					int crntNum = i, multiplier = 1;
					while(crntNum){
						multiplier *= crntNum % 10;
						crntNum /= 10;
					}

					if(multiplier == k)
						holder.push_back(i);
				}

				return holder.size();
			}

			//or
				/*
					Time Complexity : O(R - L * log(R))
					Space Complexity : O(1)

					Where 'R' & 'L' are the numbers given.
				*/

				bool isIt(int i, int k) {

					string s = to_string(i);
					int product = 1 ;

					for (char c : s) {
						product = (product * (c - '0'));
					}

					return (product == k);
				}

				int numsWithProductK(int l, int r, int k) {

					int cnt = 0;
					
					for (int i = l ; i <= r ; i++) {
						// To check if current number satisfies condition.
						if (isIt(i, k)) {
							cnt++;
						}
					}

					return cnt;
				}

		//Optimized:
			1)
				/*
					Time Complexity : O(log(R) * (10 ^ log10(R)))
					Space Complexity : O(10 ^ log10(R))

					Where 'K' & 'R' the number given to us.
				*/

				const int maxProduct = 10000;

				int numsWithProductKhelper(string num, int idx, int product, int k, int leadingZeros, int tight) {
					if (idx >= num.length() or product > k)
						return product == k;

					int res = 0;

					int end = tight ? num[idx] - '0' : 9;

					for (int dig = 0; dig <= end; dig++) {

						if (dig == 0 && !leadingZeros) {

							// Recurr for 'idx + 1', and no more leading zeros.
							res += numsWithProductKhelper(num, idx + 1, product, k, false, (tight & (dig == end)));
						} else {
							
							// Recurr for 'idx + 1' and we have multiplied the current digit in product.
							res += numsWithProductKhelper(num, idx + 1, product * dig, k, true, (tight & (dig == end)));
						}
					}

					return res;
				}

				int numsWithProductK(int l, int r, int k) {

					// Converting 'r' to string.
					string str = to_string(r);

					int cntR = numsWithProductKhelper(str, 0, 1, k, false, true);
					// Converting 'l - 1' to string.
					str = to_string(l - 1);
					int cntL = numsWithProductKhelper(str, 0, 1, k, false, true);

					int answer = cntR - cntL;

					return answer;
				}

			2)using DP:
				/*
					Time Complexity : O(log(R) * 10 * K)
					Space Complexity : O(K)

					Where 'K' & 'R' the number given to us.
				*/

				const int maxProduct = 10000;
				int numsWithProductKhelper(string num, int idx, int product, int k, int leadingZeros, int tight, int dp[maxProduct][10][2][2]) {
					if (idx >= num.length() or product > k) {
						return product == k;
					}

					if (dp[product][idx][tight][leadingZeros] != -1) {
						return dp[product][idx][tight][leadingZeros];
					}

					int res = 0;

					int end = tight ? num[idx] - '0' : 9;

					for (int dig = 0; dig <= end; dig++) {

						if (dig == 0 && !leadingZeros) {

							// Recurr for 'idx + 1', and no more leading zeros.
							res += numsWithProductKhelper(num, idx + 1, product, k, false, (tight & (dig == end)), dp);
						} else {

							// Recurr for 'idx + 1' and we have multiplied the current digit in product.
							res += numsWithProductKhelper(num, idx + 1, product * dig, k, true, (tight & (dig == end)), dp);
						}
					}

					return dp[product][idx][tight][leadingZeros] = res;
				}

				int numsWithProductK(int l, int r, int k) {
					string str = to_string(r);

					int dp[maxProduct][10][2][2];

					memset(dp, -1, sizeof(dp));
					int cntR = numsWithProductKhelper(str, 0, 1, k, false, true, dp);

					str = to_string(l - 1);

					memset(dp, -1, sizeof(dp));
					int cntL = numsWithProductKhelper(str, 0, 1, k, false, true, dp);

					int answer = cntR - cntL;

					return answer;
				}

	347) Reversing Series Pattern:
		Problem statement
			You are given an integer ‘N’. Your task is to return a reverse series pattern for the given ‘N’.
			The reverse series pattern for ‘N’ = 5 will look like following:
				1 
				3 2 
				4 5 6 
				10 9 8 7 
				11 12 13 14 15
			Constraints :
				1 <= T <= 10
				1 <= N <= 500

			Time Limit : 1 sec
			Sample Input 1 :
				2
				7
				6
				Sample Output 1 :
				1
				3 2
				4 5 6
				10 9 8 7
				11 12 13 14 15
				21 20 19 18 17 16
				22 23 24 25 26 27 28
				1
				3 2
				4 5 6
				10 9 8 7
				11 12 13 14 15
				21 20 19 18 17 16 
				Sample Input 2 :
				2
				3
				4
				Sample Output 2 :
				1
				3 2
				4 5 6
				1
				3 2
				4 5 6 
				10 9 8 7

		#include <bits/stdc++.h> 
		vector<vector<int>> reversePattern(int n) {
			vector<vector<int>> ans;
			int cnt=1;
			for(int i=0; i<n; i++){
				vector<int> temp;
				for(int j=0; j<=i; j++){
					temp.push_back(cnt++);
				}
				ans.push_back(temp);
			}

			for(int i=0; i<ans.size(); i++)
				if(i&1)
					reverse(ans[i].begin(), ans[i].end());

			return ans;
		}

		// On Online Debugger
			#include <iostream>
			using namespace std;

			int main() {
				cout<<"Enter n: ";
				int n;
				cin>>n;
				int cnt=0, temp;
				
				for(int i=1; i<=n; i++) {
					if(i&1){
						for(int j=1; j<=i; j++)
							std::cout << ++cnt << " ";
					}else{
						temp = i + cnt;
						cnt = temp;
						for(int j=1; j<=i; j++)
							std::cout << temp-- << " ";
					}
					
					std::cout << std::endl;
				}
				return 0;
			}
			Enter n: 5
				1 
				3 2 
				4 5 6 
				10 9 8 7 
				11 12 13 14 15 

	348) Decimal Equivalent of Binary Linked List:
		Problem statement:
			Given a singly linked list of length n. The link list represents a binary number, 
			ie it contains only 0s and 1s. Find its decimal equivalent.
			The significance of the bits decreases with the increasing index in the linked list.
			An empty linked list is considered to represent the decimal value 0. 
			Since the answer can be very large, answer modulo 10^9+7 should be printed.

			Example 1:
				Input:
				n = 3
				Linked List = {0, 1, 1}
				Output:
				3
				Explanation:
				0*2^2 + 1*2^1 + 1*2^0 =  1 + 2 + 0 = 3
			Example 2:
				Input:
				n = 4
				Linked List = {1, 1, 1, 0}
				Output:
				14
				Explanation:
				1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 =  8 + 4 + 2 + 0 = 14

			Your Task:
				You do not have to take any input or print anything. 
				Complete the function decimalValue() which takes a head node of a linked list 
				as an input parameter and returns decimal representation of it.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				0 <= n <= 100
				Data of each node is either 0 or 1

		/* Link list Node/
		struct Node {
			bool data;   // NOTE data is bool
			Node* next;
			
			Node(int x){
				data = x;
				next = NULL;
			}
		}; */

		class Solution {
			public:
				// Should return decimal equivalent modulo 1000000007 of binary linked list 
			long long unsigned int decimalValue(Node *head) {
				const int MOD = 1e9 + 7;
				long long unsigned int result = 0;
		
				Node* current = head;
				while (current != nullptr) {
					// Multiply the current result by 2 and add the binary digit
					result = (result * 2 + current->data) % MOD;
					current = current->next;
				}
				return result;
			}
		};

	349) Subtract The Product And Sum Of Digits Of An Integer:
		Problem statement
			You are given an integer number ‘N’, 
			and your task is to return the difference between the product of its digits and the sum of its digits.

			Note:
				You do not need to print anything; it has already been taken care of. Just implement the given function.
			For Example :
				Input: N = 234
				Output: 15 
				Explanation: 
				Product of digits = 2 * 3 * 4 = 24 
				Sum of digits = 2 + 3 + 4 = 9 
				Result = 24 - 9 = 15
			Constraints :
				1 <= T <= 3000
				1 <= N <= 10^5

				Time Limit: 1 sec
			Sample Input 1 :
				2
				234
				4421
				Sample Output 1 :
				15
				21
				Explanation For Sample Input 1 :
				Product of digits = 2 * 3 * 4 = 24 
				Sum of digits = 2 + 3 + 4 = 9 
				Result = 24 - 9 = 15

				Product of digits = 4 * 4 * 2 * 1 = 32 
				Sum of digits = 4 + 4 + 2 + 1 = 11
				Result = 32 - 11 = 21
				Sample Input 2 :
				1
				87
				Sample Output 2 :
				41

		#include <bits/stdc++.h> 
		int findProductSumDifference(int n){
			int prod = 1, sum =0;

			while(n){
				int lastDigit = n % 10; 
				prod *= lastDigit;
				sum += lastDigit;
				n /= 10;
			}
			return prod-sum;
		}

	350) Count Of 3s:
		Problem statement
			You are given an integer ‘N’. 
			You simply need to find out the number of occurrences of 3 as a digit in the range of numbers from [0, N].

			Note:
				You need to count occurrences at every place of the number.
			For example :
				You are given N = 13, then the number of occurrences of 3 in range [0, 13] = 2 (3, 13), you need to return 2.
			Constraints:
				1 <= T <= 10^2
				0 <= N <= 10^5

				where ‘T’ is the number of test cases and 'N' is the given integer.
				Time Limit: 1 sec
			Sample Input 1:
				2
				13
				24
				Sample Output 1:
				2
				3
				Explanation For Sample Input 1:
				In the first test case, 
				Number of occurrences of 3 in range [0, 13] = 2 (3, 13). Return 2

				In the second test case, 
				Number of occurrences of 3 in range [0, 24] = 3 (3, 13, 23). Return 3
				Sample Input 2:
				2
				10
				33
				Sample Output 2:
				1
				8
				Explanation For Sample Input 2:
				In the first test case, 
				Number of occurrences of 3 in range [0, 10] = 1 (3). Return 1

				In the second test case, 
				Number of occurrences of 3 in range [0, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8
		
		#include <bits/stdc++.h> 
		long long int countOf3(int x) {
			long long ans=0;
			for(int i=0; i<=x; i++){
				int num = i;

				while(num){
					if(num % 10 == 3)
						ans++;    
					num /= 10;
				}
			}
			return ans;
		}
	
	351) Group Anagrams:
		Problem Statement:
			Given an array of strings strs, group the anagrams together. 
			You can return the answer in any order.
			An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, 
			typically using all the original letters exactly once.

			Example 1:
				Input: strs = ["eat","tea","tan","ate","nat","bat"]
				Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

			Example 2:
				Input: strs = [""]
				Output: [[""]]

			Example 3:
				Input: strs = ["a"]
				Output: [["a"]]
			
			Constraints:
				1 <= strs.length <= 104
				0 <= strs[i].length <= 100
				strs[i] consists of lowercase English letters.

		// Not Optimized:
			class Solution {
				public:
				vector<vector<string>> groupAnagrams(vector<string>& strs) {
					vector<vector<string>> ans;
					for(int i=0; i<strs.size(); i++){
						if(strs[i] == "0")
							continue;
						
						vector<string> temp;
						temp.push_back(strs[i]);

						//mapper for first string
						int mapper1[26] = {0};
						string Stemp = strs[i];
						strs[i] = "0";

						for(int z=0; z<Stemp.length(); z++)
							mapper1[Stemp[z] - 'a']++;
						
						for(int j=i+1; j<strs.size(); j++){
							if(strs[j] == "0")
								continue;
							
							//mapper for second string
							int mapper2[26] = {0};
							string s2 = strs[j];

							for(int z=0; z<s2.length(); z++) {
								mapper2[s2[z] -'a']++;
							}

							int flag = 1;
							for(int y=0; y<26; y++){
								if(mapper1[y] != mapper2[y]){
								flag = 0;
								break;
								}
							}

							if(flag){
								strs[j] = "0";
								temp.push_back(s2);
							}
						}
						ans.push_back(temp);
					}
					return ans;
				}
			};

		// Optimized: ❌Pending
			class Solution {
				public:
				string getSignature(const string& s) {
					vector<int> count(26, 0);
					for (char c : s) {
						count[c - 'a']++;
					}

					stringstream ss;
					for (int i = 0; i < 26; i++) {
						if (count[i] != 0) {
							ss << (char)('a' + i) << count[i];
						}
					}
					return ss.str();
				}

				vector<vector<string>> groupAnagrams(vector<string>& strs) {
					vector<vector<string>> result;
					unordered_map<string, vector<string>> groups;

					for (const string& s : strs) {
						groups[getSignature(s)].push_back(s);
					}

					for (const auto& entry : groups) {
						result.push_back(entry.second);
					}

					return result;
				}
			};

	352) Majority Element:
		Problem Statement:
			Given an array nums of size n, return the majority element.
			The majority element is the element that appears more than [n/2⌋ times. 
			You may assume that the majority element always exists in the array.

			Example 1:
				Input: nums = [3,2,3]
				Output: 3

			Example 2:
				Input: nums = [2,2,1,1,1,2,2]
				Output: 2
			
			Constraints:
				n == nums.length
				1 <= n <= 5 * 10^4
				-10^9 <= nums[i] <= 10^9

		class Solution {
			public:
			int majorityElement(vector<int>& nums) {
				int count = nums.size() / 2;
				map<int, int> Freq;

				for(int i: nums)
					Freq[i]++;
				for(auto i: Freq)
					if(i.second > count)
						return i.first;
				throw;
			}
		};

		Follow-up: Could you solve the problem in linear time and in O(1) space?
			class Solution {
				public:
				int majorityElement(vector<int>& nums) {
					int count = 0;    
					int element = 0; 

					for (int i = 0; i < nums.size(); i++) {
						if (count == 0) {
							element = nums[i];
							count = 1;
						} else if (element == nums[i]) {
							count++;
						} else {
							count--;
						}
					}

					return element; 
				}
			};
	
	353) Two Sum:
		Problem Statement:
			Given an array of integers nums and an integer target, 
			return indices of the two numbers such that they add up to target.
			You may assume that each input would have exactly one solution, 
			and you may not use the same element twice.
			You can return the answer in any order.

			Example 1:
				Input: nums = [2,7,11,15], target = 9
				Output: [0,1]
				Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

			Example 2:	
				Input: nums = [3,2,4], target = 6
				Output: [1,2]

			Example 3:
				Input: nums = [3,3], target = 6
				Output: [0,1]

			Constraints:
				2 <= nums.length <= 10^4
				-10^9 <= nums[i] <= 10^9
				-10^9 <= target <= 10^9
				Only one valid answer exists.

		class Solution {
			public:
			vector<int> twoSum(vector<int>& nums, int target) {
				vector<int> ans;
				
				for(int i=0;i<nums.size(); i++){
					for(int j=i+1; j<nums.size(); j++){
						if(nums[i]+nums[j] == target){
							ans.push_back(i);
							ans.push_back(j);
							return ans;
						}
					}
				}
				return ans;
			}
		};
	
	354) Palindrome Number:
		Problem Statement:
			Given an integer x, return true if x is a palindrome, and false otherwise.

			Example 1:
				Input: x = 121
				Output: true
				Explanation: 121 reads as 121 from left to right and from right to left.

			Example 2:
				Input: x = -121
				Output: false
				Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

			Example 3:
				Input: x = 10
				Output: false
				Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

			Constraints:
			-2^31 <= x <= 2^31 - 1

		class Solution {
			public:
			bool isPalindrome(int x) {
				if(x<0)
					return 0;
				string s = to_string(x);
				
				int i=0;
				while(i < (s.length()/2)){
					if(s[i] != s[s.length()-1-i])
						return 0;
					i++;
				}
				return 1;
			}
		};

		Follow up: Could you solve it without converting the integer to a string?
			class Solution {
				public:
				bool isPalindrome(int x) {
					if(x<0)
						return 0;
					long revNum = 0;
					int tempNum = x;

					while(tempNum){
						revNum = (revNum * 10) + (tempNum % 10);
						tempNum /= 10;
					}
					return (revNum == x) ? 1 : 0;
				}
			};

	355) Contains Duplicate:
		Problem statement:
			Given an integer array nums, 
			return true if any value appears at least twice in the array, 
			and return false if every element is distinct.

			Example 1:
				Input: nums = [1,2,3,1]
				Output: true
			
			Example 2:
				Input: nums = [1,2,3,4]
				Output: false

			Example 3:
				Input: nums = [1,1,1,3,3,4,3,2,4,2]
				Output: true
				
			Constraints:
				1 <= nums.length <= 10^5
				-10^9 <= nums[i] <= 10^9

		// Not Optimized:
			class Solution {
				public:
				bool containsDuplicate(vector<int>& nums) {
					for(int i=0; i<nums.size(); i++)
						for(int j=i+1; j<nums.size(); j++)
							if(nums[i] == nums[j])
								return 1;
					return 0;
				}
			};
		
		//Optimized1:
			class Solution {
				public:
				bool containsDuplicate(vector<int>& nums) {
					sort(nums.begin(), nums.end());

					for(int i=1; i<nums.size(); i++)
						if(nums[i-1] == nums[i])
							return 1;
					return 0;
				}
			};
	
	356) Find Resultant Array After Removing Anagrams:
		Problem statement:
			You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.
			In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, 
			and delete words[i] from words. 
			Keep performing this operation as long as you can select an index that satisfies the conditions.
			Return words after performing all operations. 
			It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.
			An Anagram is a word or phrase formed by rearranging the letters of 
			a different word or phrase using all the original letters exactly once. 
			For example, "dacb" is an anagram of "abdc".

			Example 1:
				Input: words = ["abba","baba","bbaa","cd","cd"]
				Output: ["abba","cd"]
				Explanation:
				One of the ways we can obtain the resultant array is by using the following operations:
				- Since words[2] = "bbaa" and words[1] = "baba" are anagrams, we choose index 2 and delete words[2].
				Now words = ["abba","baba","cd","cd"].
				- Since words[1] = "baba" and words[0] = "abba" are anagrams, we choose index 1 and delete words[1].
				Now words = ["abba","cd","cd"].
				- Since words[2] = "cd" and words[1] = "cd" are anagrams, we choose index 2 and delete words[2].
				Now words = ["abba","cd"].
				We can no longer perform any operations, so ["abba","cd"] is the final answer.

			Example 2:
				Input: words = ["a","b","c","d","e"]
				Output: ["a","b","c","d","e"]
				Explanation:
				No two adjacent strings in words are anagrams of each other, so no operations are performed.

			Constraints:
				1 <= words.length <= 100
				1 <= words[i].length <= 10
				words[i] consists of lowercase English letters.

		class Solution {
			public:
			bool check(int *p1, int *p2){
				for(int i=0; i<26; i++)
					if(p1[i] != p2[i])
						return 0;
				return 1;
			}
			vector<string> removeAnagrams(vector<string>& words) {
				vector<string> ans;
				for(int i=0; i<words.size(); i++){
					if(words[i] == "0")
						continue;
					
					string crntS = words[i];
					ans.push_back(crntS);

					// mapping
					int mapper1[26] = {0};
					for(int z=0; z<crntS.length(); z++)
						mapper1[crntS[z]-'a']++;

					for(int j=i+1; j<words.size(); j++){
						// mapping
						int mapper2[26] = {0};
						string sTemp = words[j];
						for(int a=0; a<sTemp.length(); a++)
							mapper2[sTemp[a] - 'a']++;
						
						if(check(mapper1, mapper2))
							words[j] = "0";
						else
							break;
					}
				}
				return ans;
			}
		};

		// Another Approach: (Simple)
			class Solution {
				public:
				vector<string> removeAnagrams(vector<string>& words) {
					vector<string> ans;
					ans.push_back(words[0]);

					for(int i=1; i<words.size(); i++){
						string s1 = words[i-1];
						string s2 = words[i];
						sort(s1.begin(), s1.end());
						sort(s2.begin(), s2.end());

						if(s1 != s2)
							ans.push_back(words[i]);
					}
					return ans;
				}
			};
	
	357) Implement a phone directory:
		Problem statement
			You are given a list/array of strings which denotes the contacts that exist in your phone directory. 
			The search query on a string ‘str’ which is a query string displays all 
			the contacts which are present in the given directory with the prefix as ‘str’. 
			One special property of the search function is that when a user searches for 
			a contact from the contact list then suggestions (contacts with prefix as the 
			string entered so for) are shown after the user enters each character.

			Note :
				If no suggestions are found, return an empty 2D array.

			For Example :
				In the above example everytime we enter a character, 
				a few suggestions display the strings which contain the entered string as prefixes.

			Constraints :
				1 <= T <= 50
				1 <= N <= 100
				1 <= len <= 10
				ARR[i] contains lowercase English alphabets.
				All the given strings contain lowercase English alphabets.
				Time Limit: 1 sec.
			Sample Input 1 :
				2
				5
				cod coding codding code coly
				coding
				2
				ninjas coding
				ninja
				Sample Output 1 :
				cod coding codding code coly
				cod coding codding code coly
				cod coding codding code coly
				coding
				coding
				coding
				ninjas
				ninjas
				ninjas
				ninjas
				ninjas
				Explanation to Sample Input 1 :
				In the first test case, 
				The suggestions for “c” is {“cod”, “coding”, “codding”, “code”, “coly”}.
				The suggestions for “co” is {“cod”, “coding”, “codding”, “code”, “coly”}.
				The suggestions for “cod” is {“cod”, “coding”, “codding”, “code”, “coly”}.
				The suggestion for “codi” is {“coding”}.
				The suggestion for “codin” is {“coding”}.
				The suggestion for “coding” is {“coding”}.

				In the second test case, 
				The suggestion for “n” is {“ninjas”}.
				The suggestion for “ni” is {“ninjas”}.
				The suggestion for “nin” is {“ninjas”}.
				The suggestion for “ninj” is {“ninjas”}.
				The suggestion for “ninja” is {“ninjas”}.
				Sample Input 2 :
				3
				2
				coding ninjas
				cell
				2
				ab abc
				a
				2
				ab abc
				b
				Sample Output 2 :
				coding
				ab abc
				No suggestions found
				Explanation to Sample Input 2 :
				In the first test case, 
				The suggestion for “c” is {“coding”}.
				For the rest of the letters, there are no suggestions.

				In the second test case,
				The suggestion for “a” is {“ab”, “abc”}.

				In the third test case, no suggestions are found.

		#include <bits/stdc++.h>
		vector<vector<string>> phoneDirectory(vector<string>&contactList, string &queryStr) {
			vector<vector<string>> ans;

			unordered_set<string> removeDuplicate;

			for(int i=0; i<contactList.size(); i++)
				removeDuplicate.insert(contactList[i]);
			
			//setting set back to vector
			contactList.clear();
			for(auto i=removeDuplicate.begin(); i!= removeDuplicate.end(); i++)
				contactList.push_back(*i);

			string temp;

			for(int i=0; i<queryStr.length(); i++){
				temp += queryStr[i];

				vector<string> holder;

				for(int a=0; a<contactList.size(); a++){
					string crntS = contactList[a];
					if(temp.length() > crntS.length())
						continue;
					
					int flag=1;
					for(int y=0; y<temp.length(); y++)
						if(temp[y] != crntS[y]){
							flag =0;
							break;
						}
					
					if(flag)
						holder.push_back(crntS);            
				}
				if(holder.size() !=0 ){
					sort(holder.begin(), holder.end());
					ans.push_back(holder);
				}
			}
			// cout<<ans.size()<<endl;
			return ans;
		}
		
	358) Remove Duplicates from Sorted Array:
		Problem Statement:
			Given an integer array nums sorted in non-decreasing order, 
			remove the duplicates in-place such that each unique element appears only once. 
			The relative order of the elements should be kept the same. 
			Then return the number of unique elements in nums.
			Consider the number of unique elements of nums to be k, 
			to get accepted, you need to do the following things:

			Change the array nums such that the first k elements of nums contain the 
			unique elements in the order they were present in nums initially. 
			The remaining elements of nums are not important as well as the size of nums.
			Return k.
			Custom Judge:
				The judge will test your solution with the following code:

				int[] nums = [...]; // Input array
				int[] expectedNums = [...]; // The expected answer with correct length

				int k = removeDuplicates(nums); // Calls your implementation

				assert k == expectedNums.length;
				for (int i = 0; i < k; i++) {
					assert nums[i] == expectedNums[i];
				}
			If all assertions pass, then your solution will be accepted.

			Example 1:
				Input: nums = [1,1,2]
				Output: 2, nums = [1,2,_]
				Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
				It does not matter what you leave beyond the returned k (hence they are underscores).

			Example 2:
				Input: nums = [0,0,1,1,1,2,2,3,3,4]
				Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
				Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
				It does not matter what you leave beyond the returned k (hence they are underscores).

			Constraints:
				1 <= nums.length <= 3 * 104
				-100 <= nums[i] <= 100
				nums is sorted in non-decreasing order.

		class Solution {
			public:
			int removeDuplicates(vector<int>& nums) {
				set<int> s(nums.begin(), nums.end());
				
				// for(int i=0; i<nums.size(); i++)
				//     s.insert(nums[i]);

				//copying value of set to vector nums
				nums.clear();

				// for(auto i=s.begin(); i!= s.end(); i++)
				//     nums.push_back(*i);

				nums.assign(s.begin(), s.end());
				return s.size(); 
			}
		};

		// in-place approach:
			class Solution {
				public:
				int removeDuplicates(vector<int>& nums) {
					
					for(int i=0; i<nums.size()-1; i++)
						if(nums[i] == nums[i+1]){
							nums.erase(nums.begin()+i);
							i--;
						}
					return nums.size();
				}
			};

		//Advance modfied if condition without brackets
			class Solution {
				public:
				int removeDuplicates(vector<int>& nums) {
					for(int i=0; i<nums.size()-1; i++)
						if(nums[i] == nums[i+1])
							nums.erase(nums.begin()+i), i--;
							
					return nums.size();
				}
			};

	359) Sort Characters By Frequency:
		Problem Statement:
			Given a string s, sort it in decreasing order based on the frequency of the characters. 
			The frequency of a character is the number of times it appears in the string.
			Return the sorted string. If there are multiple answers, return any of them.

			Example 1:
				Input: s = "tree"
				Output: "eert"
				Explanation: 'e' appears twice while 'r' and 't' both appear once.
				So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.

			Example 2:
				Input: s = "cccaaa"
				Output: "aaaccc"
				Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
				Note that "cacaca" is incorrect, as the same characters must be together.

			Example 3:
				Input: s = "Aabb"
				Output: "bbAa"
				Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
				Note that 'A' and 'a' are treated as two different characters.

			Constraints:
				1 <= s.length <= 5 * 10^5
				s consists of uppercase and lowercase English letters and digits.

		class Solution {
			public:
			static bool compare(pair<char, int> a, pair<char, int> b){
				return a.second > b.second;
			}
			string frequencySort(string s) {
				map<char, int> Freq;

				// Frequency Counted
				for(char ch: s)
					Freq[ch]++;

				vector<pair<char, int>> holder;
				for(auto i=Freq.begin(); i!= Freq.end(); i++){
					pair<char, int> tempPair = *i;
					holder.push_back(tempPair);
				}

				sort(holder.begin(), holder.end(), compare);

				string ans;
				for(int i=0; i<holder.size(); i++){
					int value = holder[i].second;
					while(value--)
						ans += holder[i].first;
				}
				return ans;
			}
		};
	
	360) Product of the Last K Numbers:
		Problem statement
			Given a sequence of queries of insertion and getProduct, 
			you need to create an array using queries of type-0 and answer queries of type-1.
			In each query, the input is of two types :
				0 X: insert element ‘X’ at the end array.
				1 K: find the product of the last 'K' elements in the array
			Note:
				For the query of type 1, you can assume that the array has at least k values. 
				And at any time, the product of any contiguous sequence of numbers 
				will fit into a single 32-bit integer without overflowing.
			Constraints:
				1 <= T <= 3
				0 <= X <= 100
				0 <= QUERIES <=5000
				1 <= K <= 5000

				Where X denotes the value to be stored in the array.
				Time limit: 1 sec.
			Sample Input 1:
				1
				10
				0 3
				0 0
				0 2
				0 5
				0 4
				1 2
				1 3
				1 4
				0 8
				1 2
				Sample Output 1:
				20 40 0 32
				Explanation for Sample Input 1:
				After the first 5 insertions, the array will be [3 0 2 5 4]

				Product with k=2 is 5*4 = 20
				Product with k=3 is 2*5*4 = 40
				Product with k=4 is 0*2*5*4 = 0

				Insert 8 : [ 3 0 2 5 4 8]
				Product with k=2 is 4*8 = 32
				Sample Input 2:
				1
				12
				0 24
				1 1
				0 58
				0 2
				1 3
				0 73
				1 3
				0 66
				0 0
				1 4
				0 8
				1 7
				Sample Output 2:
				24 2784 8468 0 0

		#include <bits/stdc++.h> 
		vector<int> solve( int q, vector<pair<int, int>> queries ) {
			vector<int> holder, ans;

			for(int i=0; i<queries.size(); i++){
				if(queries[i].first == 0)
					holder.push_back(queries[i].second);
				else{
					int counter = queries[i].second;
					int prod = 1;
					for(int j=holder.size()-1; counter > 0; j--, counter--){
						prod *= holder[j];
					}
					ans.push_back(prod);
				}
			}
			return ans;
		}

	361) Pattern Printing (Hollow Box Star Pattern):
		(Lecture-4 question:30th)
		Problem statement
			Ninja has been given two integers 'M' and ‘N’.
			Now Ninja has to draw a rectangle of height ‘M’ and breadth ‘N’ 
			using the character * such that the * only occurs at the boundaries of the rectangle, 
			and inside of this boundary, there is space only.

			Now, Ninja doesn’t know how to perform this operation.
			You being Ninja's best friend, your task is to help Ninja to solve this problem.
			EXAMPLE:
				Input: 'M' = 2, ‘N’ = 2
			Output:
				**
				**
			Constraints :
				1 <= 'T' <= 10
				1 <= 'M' <= 10^5
				1 <= 'N' <= 10^5
				1 <= 'M' * 'N' <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				2
				2 2  
				4 3
				Sample Output 1 :
				**
				**  
				***
				* *
				* *
				***
				Sample Input 2 :
				2
				1 1
				3 3
				Sample Output 2 :
				*
				***
				* *
				***

		#include <bits/stdc++.h> 
		void printPattern(int m, int n) {
			for(int i=0; i<m; i++){
				for(int j=0; j<n; j++)
					if(i == 0 || i == m-1 || j==0 || j== n-1)
						cout<<"*";
					else
						cout<<" ";
				cout<<"\n";
			}
		}
	
	362) Sum Of Infinite Array: ❌Pending
		Problem statement
			Given an array “A” of N integers and you have also defined the new array “B” as a concatenation of array “A” 
			for an infinite number of times.
			For example, if the given array “A” is [1,2,3] then, infinite array “B” is [1,2,3,1,2,3,1,2,3,.......].
			Now you are given Q queries, each query consists of two integers “L“ and “R”(1-based indexing). 
			Your task is to find the sum of the subarray from index “L” to “R” (both inclusive) 
			in the infinite array “B” for each query.

			Note :
				The value of the sum can be very large, return the answer as modulus 10^9+7.
			Constraints :
				1 <= T <= 100
				1 <= N <= 10^4   
				1 <= A[i] <= 10^9
				1 <= Q <= 10^4
				1 <= L <= R <= 10^18
				Time Limit: 1sec
			Sample Input 1 :
				1
				3
				1 2 3
				2
				1 3
				1 5
				Sample Output 1 :
				6 9
				Explanation to Sample Input 1 :
				For the first test case, the given array A is [1,2,3] therefore the infinite array “B” 
				will be [1,2,3,1,2,3,1,2,3,.......]. 
				So the answer for the given first query is 6 because the sum of the
				subarray from index 1 to 3 of infinite array “B” i.e. (B[1]+B[2]+B[3]) is 6.

				For the given second query is 9 because the sum of the subarray from index 1 to 5 
				of array “B” .ie (B[1]+B[2]+B[3]+B[4]+B[5]) is 9.
				Sample Input 2 :
				1
				4
				5 2 6 9
				3
				1 5
				10 13
				7 11
				Sample Output 2 :
				27 22 28
 
		//Not Optimized:
			vector<int> sumInRanges(vector<int> &arr, int n, vector<vector<long long>> &queries, int q) {
				vector<int> ans;
				int mod = 1e9+7;

				for(int i=0; i<q; i++) {
					long start = queries[i][0];
					long end = queries[i][1];

					int sum=0;
					for(long l=start; l<=end; l++){
						int v = l % arr.size();
						v -= 1;
						if(v < 0){
							sum = (sum + arr[arr.size()-1]) % mod;
						}else{
							sum = (sum + arr[v]) % mod;
						}
					}
					ans.push_back(sum);
				}
				return ans;
			}
	
		// Concise:
			vector<int> sumInRanges(vector<int> &arr, int n, vector<vector<long long>> &queries, int q) {
				vector<int> ans;
				int mod = 1e9+7;
				vector<int> t = arr;
				for(auto i: queries){
					long long l = i[0]-1, r = i[1];
					long long sum = 0;
					
					while(t.size() < r) t.insert(t.end(), arr.begin(), arr.end());
					while(l < r) sum = (sum + t[l++]) % mod;

					ans.push_back(sum);
				}
				return ans;
			}
		
		// Little bit Optimized: (Reminder/ modulus technique)
			#define ll long long 
			vector<int> sumInRanges(vector<int> &arr, int n, vector<vector<long long>> &queries, int q) {
				vector<int> ans;
				int mod = 1e9+7;

				for(auto i: queries){
					ll s = i[0], e = i[1];
					ll diff = e - s + 1;        // repeate
					
					ll startingIndex = s - 1;
					startingIndex %= n;
					ll sum = 0;
					while(diff--){
						if(startingIndex >= n) startingIndex=0;
						sum = (sum + arr[startingIndex++]) % mod;
					}
					ans.push_back(sum);
				}
				return ans;
			}
		
		//Optimized:
			/*
				Time Complexity:O(Q+N).
				Space Complexity:O(N).

				Where N is the size of the given array, and Q is the number of queries given.
			*/

			int mod = 1000000007;
			// Function to calculate prefix sum upto index x of the infite array.
			long long func(vector<long long> &sumArray, long long x, long long n) {
				// Number of times the given array comes completely upto index x.
				long long count = (x / n) % mod;

				long long res = (count * sumArray[(int) n]) % mod;

				// Adding the remaining elements sum.
				res = (res + sumArray[(int) (x % n)]) % mod;

				return res;
			}

			vector<int> sumInRanges(vector<int> &arr, int n, vector<vector<long long>> &queries, int q) {

				// It stores answer for each query.
				vector<int> ans;

				// It store cumulative sum where sumArray[i] = sum(A[0]+..A[i]).
				vector<long long> sumArray(n + 1);

				for (int i = 1; i <= n; i++) {
					sumArray[i] = (sumArray[i - 1] + arr[i - 1]) % mod;
				}

				// Traversing the given queries.
				for (int i = 0; i < queries.size(); i++) {
					vector<long long> range = queries[i];
					long long l = range[0];
					long long r = range[1];

					// It stores the prefix sum from index 0 to index r in an infinite array.
					long long rsum = func(sumArray, r, n);

					// It stores the prefix sum from index 0 to index l-1 in an infinite array.
					long long lsum = func(sumArray, l - 1, n);

					// Add answer for each query.
					ans.push_back((int) ((rsum - lsum + mod) % mod));
				}
				return ans;
			}

	363) Print the Pattern:
		Problem statement
			Ninja is given a pattern. Now he is asked to print the same pattern for any given ‘N’ number of rows.
			Note:
			There is only one space between the values of each column in a row.
			For example, Pattern for ‘N’ = 5 will be.
				1 2 3 4 5 
				11 12 13 14 15 
				21 22 23 24 25 
				16 17 18 19 20 
				6 7 8 9 10 
			Sample Input1 :
				1 
				5
				Sample Output2 :
				1 2 3 4 5 
				11 12 13 14 15 
				21 22 23 24 25 
				16 17 18 19 20 
				6 7 8 9 10 
				Explanation of Sample Input 1:
				For test case 1:
				We print the given pattern for the given 5 rows where each row has 
				different values in increasing order with a difference in the value of 1 between 
				each element and 1 space between each column in a row.
			Sample Input2 :
				1
				4
				Sample Output2 :
				1 2 3 4
				9 10 11 12
				13 14 15 16
				5 6 7 8
				Explanation of Sample Input 2:
				For test case 1:
				We print the given pattern for the given 4 rows where each row has 
				different values in increasing order with a difference of 1 in the 
				value of 1 between each element and 1 space between each column in a row.

		#include <bits/stdc++.h> 
		vector<string> printPattern(int n) {
			vector<string> ans(n);
			int rows =1;
			int cnt = 1;

			int start = 0, end = n-1;

			while(1){
				string s;
				for(int i=0;i<n; i++){
					s += to_string(cnt++) + " ";
				}

				if(rows & 1)
					ans[start++] = s;
				else
					ans[end--] = s;
				
				if(rows == n)
					break;
				rows++;
			}
			return ans;
		}
	
	364) Sequence Query:	(Refer Q.11)
		Only for +ve a, d & x integers
		Problem statement:
			Alice is analyzing a mathematical sequence where the first element of the
			sequence is 'A' and the difference between any two consecutive elements is 'D'.
			She is given an integer 'X.
			Return 1 if 'X' appears in the sequence; else, return O.
			Example :
				Input: 'A' = 2, 'D' = 3. 'X' = 8|
				Output: 1
				The sequence here is 2, 5, 8, 11. .... As 8 is present in the sequence, the output is 1.
			Constraints:
				-10^9 ≤ A. D. X ≤ 10^9
				Time limit: 1 sec
			Sample Input 1:
				1 2 7
				Sample Output 1 :
				1
				Explanation For Sample Input 1:
				The sequence here is 1, 3, 5, 7. ... As 7 is present in the sequence, the output is 1.
				Sample Input 2:
				5 0 3
				Sample Output 2 :
				0
				Explanation For Sample Input 2:
				The sequence here is 5, 5. 5. .... As 3 is not present in the sequence, the
				output is 0.
			
		int checkSequence(int a, int d, int x) {
			start:
				if(a == x)
					return 1;
				else{
					if(a > x)
						return 0;
					a += d;
					goto start;
				}
		}

		//or using while loop: Not Optimized
			int checkSequence(int a, int d, int x) {
				
				while(a <= x){
					if(a == x)
						return 1;
					else
						a += d;
				}
				return 0;
			}
		
		// Optimized:
			int checkSequence(int a, int d, int x) {
				if(a == x)
					return 1;

				if(d == 0 || (x > a && d < 0) || (x < a && d > 0) || (a >=0 && x < 0 && d > 0) || (a <= 0 && x < 0 && d < 0))
					return 0;

				if((x > a && d == 1) || (x < a && d == -1))
					return 1;


				if(d > 0){
					while(a <= x){
						if(a == x)
							return 1;
						a += d;
					}
				}else{
					while(a >= x){
						if(a == x)
							return 1;
						a += d;
					}
				}
				return 0;
			}

	365) Ninja Hathori:
		Problem statement
			Ninja has a secret string 's' consisting of lowercase letters. The string 's' has a
			length of 2 or more characters. Now he constructs another string 't' from this
			string's' and offers this string to his best friend Hathori to guess the string 's'
			from the string 't.
			Ninja builds 't' from 's' as follows: He wrote all the substrings of length 2 of the
			string's' in the order from left to right, and then joins them to form the string 't'.
			For example, if s = "xyz" then all substrings of length 2 of the string 's' are "xy"
			and "yz". Therefore, the string t= "xyyz".
			You need to help the Hathori in guessing the string 's' from the string 't'. It is
			guaranteed that 't' was built accordingly and it can be proved that the answer is
			unique for each valid string.
			For example:
				Let's say 't' = "xyyx"
			Here, if we take s = "xyx", then substrings of length 2 of string 's' are: "xy" and
			"yx". so the string 't = "xyyx"". Hence the correct answer is "xyx".
			Constraints -
				1 <= 'T' <= 10
				1 <= 'N' <= 10^4
				Time Limit: 1 sec
			Sample Input-1
				2
				хуух
				ab
				Sample Output-1
				хух
				ab
				Explanation for Sample Input 1:
				For test case 1:
				Here, if we take s = "xyx", then substrings of length 2 of string 's' are: "xy"
				and "yx", so the string 't - "xyyx". Hence the correct answer is "xyx".
				For test case 2:
				Here, if we take s = "ab", then substrings of length 2 of string 's' is only
				"ab", so the string 't - "ab'". Hence the correct answer is "ab".
			Sample Input -2
				2
				aaa
				abbc
				Sample Output -2
				aa
				abc

		#include <bits/stdc++.h> 
		string ninjaHathori(string s) {
			string ans;
			ans += s[0];
			for(int i=1; i<s.length(); i++)
				if(ans[ans.length()-1] != s[i])
					ans += s[i];
				else
					ans += " ";

			// need to remove all the spaces we kept
			if(ans[ans.length()-1] == ' ')
				ans[ans.length()-1] = ans[ans.length()-2];

			int i=0;
			while(i < ans.length()){
				if(ans[i] == ' ')
					ans.erase(ans.begin()+i);
				else
					i++;
			}
			
			return ans;
		}
	
	366) Create Sequence:
		Problem statement
			Ninja is good at numbers. So today his friend gave him a task that required him to 
			find out numbers made of 2 and 5 only less than a given limit.

			Given an integer N, you need to print all numbers less than N which are having digits only 2 or 5 or both.
			For example :
			All numbers less than 30 with digits 2 and 5 are 2, 5, 22, 25.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^16
				Time Limit: 1 sec

			Note :
				You are not required to print anything; it has already been taken care of. Just implement the function.
			Sample Input 1 :
				2  
				10
				100
				Sample Output 1 :
				2 5 
				2 5 22 25 52 55
				Explanation For Sample Output 1 :
				For the first test case, only 2 and 5 are the required numbers. 
				Hence we print them in ascending order.
				For the second test case, we have 6 required numbers.
				Sample Input 2 :
				2
				2
				7
				Sample Output 2 :
				2
				2 5

		//Not Optimized:
			vector<long long> createSequence(long long n){
				vector<long long> ans;
				for(long long i=2; i<=n; i++){
					long long crntNum = i;
					int flag = 1;

					while(crntNum){
						int singleDigit = crntNum % 10;
						if(singleDigit != 2 && singleDigit != 5){
							flag=0;
							break;
						}
						crntNum /= 10;
					}

					if(flag)
						ans.push_back(i);
				}
				return ans;
			}
		
		//Optimized:
			void solve(long long n,long long temp,vector<long long>&ans){
				if(n>temp){
					if(temp>0)
						ans.push_back(temp);
					solve(n,temp*10+2,ans);
					solve(n,temp*10+5,ans);
				}
				return ;	
			}

			vector<long long> createSequence(long long n){
				// Write your code here.
				vector<long long>ans;
				if(n==2){
					ans.push_back(2);
					return ans;
				}
				long long temp=0;
				solve(n,temp,ans);
				sort(ans.begin(),ans.end());
				return ans;
			}
	
	367) Binary Search:
		Problem Statement:
			Given a sorted array of size N and an integer K, 
			find the position(0-based indexing) at which K is present in the array using binary search.

			Example 1:
				Input:
				N = 5
				arr[] = {1 2 3 4 5} 
				K = 4
				Output: 3
				Explanation: 4 appears at index 3.

			Example 2:
				Input:
				N = 5
				arr[] = {11 22 33 44 55} 
				K = 445
				Output: -1
				Explanation: 445 is not present.

			Your Task:  
				You dont need to read input or print anything. 
				Complete the function binarysearch() which takes arr[], 
				N and K as input parameters and returns the index of K in the array. 
				If K is not present in the array, return -1.

			Expected Time Complexity: O(LogN)
			Expected Auxiliary Space: O(LogN) if solving recursively and O(1) otherwise.

			Constraints:
				1 <= N <= 10^5
				1 <= arr[i] <= 10^6
				1 <= K <= 10^6

		class Solution {
			public:
			int binarysearch(int arr[], int n, int k) {
				int s = 0, e = n-1;
				
				while(s<=e){
					int mid = e + (s - e)/2;
					
					if(arr[mid] == k)
						return mid;
					else if(arr[mid] > k)
						e = mid - 1;
					else
						s = mid + 1;
				}
				return -1;
			}
		};

	368) Plus One:
		Problem Statement:
			You are given a large integer represented as an integer array digits, 
			where each digits[i] is the ith digit of the integer. 
			The digits are ordered from most significant to least significant in left-to-right order. 
			The large integer does not contain any leading 0's.
			Increment the large integer by one and return the resulting array of digits.

			Example 1:
				Input: digits = [1,2,3]
				Output: [1,2,4]
				Explanation: The array represents the integer 123.
				Incrementing by one gives 123 + 1 = 124.
				Thus, the result should be [1,2,4].

			Example 2:
				Input: digits = [4,3,2,1]
				Output: [4,3,2,2]
				Explanation: The array represents the integer 4321.
				Incrementing by one gives 4321 + 1 = 4322.
				Thus, the result should be [4,3,2,2].

			Example 3:
				Input: digits = [9]
				Output: [1,0]
				Explanation: The array represents the integer 9.
				Incrementing by one gives 9 + 1 = 10.
				Thus, the result should be [1,0].
				
			Constraints:
				1 <= digits.length <= 100
				0 <= digits[i] <= 9
				digits does not contain any leading 0's.
		
		class Solution {
			public:
			vector<int> plusOne(vector<int>& digits) {
				digits[digits.size()-1]++;
				int carry =0;

				for(int i=digits.size()-1; i>0; i--){
					carry = 0;
					if(digits[i] > 9){
						carry = digits[i] / 10;
						digits[i] = digits[i] % 10;
						digits[i-1] += carry;
					}

					if(carry == 0)
						break;
				}

				carry = digits[0] / 10;
				if(carry != 0){
					digits[0] = digits[0] % 10;
					digits.insert(digits.begin(), carry);
				}
				return digits;
			}
		};
	
	369) Happy Number:
		Problem Statement:
			Write an algorithm to determine if a number n is happy.
			A happy number is a number defined by the following process:
			Starting with any positive integer, replace the number by the sum of the squares of its digits.
			Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
			Those numbers for which this process ends in 1 are happy.
			Return true if n is a happy number, and false if not.

			Example 1:
				Input: n = 19
				Output: true
				Explanation:
				1^2 + 9^2 = 82
				8^2 + 2^2 = 68
				6^2 + 8^2 = 100
				1^2 + 0^2 + 0^2 = 1

			Example 2:
				Input: n = 2
				Output: false
				Explanation:
				2^2 = 4
				4^2 = 16
				1^2 + 6^2 = 37
				3^2 + 7^2 = 58
				5^2 + 8^2 = 89
				8^2 + 9^2 = 145
				1^2 + 4^2 + 5^2 = 42
				4^2 + 2^2 = 20
				2^2 + 0^2 = 4 		//here we can stop coz 4 is repeated, we can't reach to 1.

			Constraints:
				1 <= n <= 2^31 - 1

		class Solution {
			public:
			bool isHappy(int n) {
				vector<int> holder;

				while(1) {
					int sum =0;
					while(n){
						sum += pow(n%10, 2);
						n /= 10;
					}

					if(sum == 1)
						return 1;

					if(find(holder.begin(), holder.end(), sum) != holder.end())
						return 0;
					
					holder.push_back(sum);
					n = sum;
				}

				// no need of this below return statement
				// return 0;
			}
		};
	
	370) Remove Element:
		Problem statement:
			Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. 
			The order of the elements may be changed. 
			Then return the number of elements in nums which are not equal to val.
			Consider the number of elements in nums which are not equal to val be k, 
			to get accepted, you need to do the following things:

			Change the array nums such that the first k elements of nums contain the elements which are not equal to val. 
			The remaining elements of nums are not important as well as the size of nums. Return k.
			Custom Judge:
				The judge will test your solution with the following code:

				int[] nums = [...]; // Input array
				int val = ...; // Value to remove
				int[] expectedNums = [...]; // The expected answer with correct length.
									// It is sorted with no values equaling val.

				int k = removeElement(nums, val); // Calls your implementation

				assert k == expectedNums.length;
				sort(nums, 0, k); // Sort the first k elements of nums
				for (int i = 0; i < actualLength; i++) {
				assert nums[i] == expectedNums[i];
				}
				If all assertions pass, then your solution will be accepted.

			Example 1:
				Input: nums = [3,2,2,3], val = 3
				Output: 2, nums = [2,2,_,_]
				Explanation: Your function should return k = 2, with the first two elements of nums being 2.
				It does not matter what you leave beyond the returned k (hence they are underscores).

			Example 2:
				Input: nums = [0,1,2,2,3,0,4,2], val = 2
				Output: 5, nums = [0,1,4,0,3,_,_,_]
				Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
				Note that the five elements can be returned in any order.
				It does not matter what you leave beyond the returned k (hence they are underscores).

			Constraints:
				0 <= nums.length <= 100
				0 <= nums[i] <= 50
				0 <= val <= 100

		class Solution {
			public:
			int removeElement(vector<int>& nums, int val) {
				for(int i=0; i<nums.size(); i++)
					if(nums[i] == val){
						nums.erase(nums.begin()+i);
						i--;
					}
				return nums.size();   
			}
		};

		//or Another approach:
			class Solution {
				public:
				int removeElement(vector<int>& nums, int val) {
					int index = 0, i;

					for(i=0; i<nums.size(); i++){
						if(nums[i] != val){
							nums[index] = nums[i];
							index++;
						}
					}
					return index;   
				}
			};

	371) K-Pure Numbers:❌Pending
		Problem statement
			A number is said to be K-Pure if it is divisible by K only once. Formally X is K-Pure
			if X is divisible by K and (X/K) is not divisible by K.
			Given 'N' and 'K, return the number of K-Pure Numbers from '1' to 'N'.
			Example:
			'N' = 15
			K' = 3
			There are 4 K-Pure Numbers 3,6,12 and 15.

			Constraints :
				1 <= T <= 10
				1 <= N <= 10^9
				1 <= K <= 10^9
				Time Limit: 1 second
			Sample Input 1:
				2
				82
				50 7
				Sample Output 1:
				Explanation Of Sample Input 1:
				4
				6
				For test case 1:
				There are 4 K-Pure Numbers 2, 6, 14 and 18.
				For test case 2:
				There are 6 K-Pure Numbers 7, 14, 21, 28, 35 and 42.
				Sample Input 2:
				2
				522 5
				426 5
				Sample Output 2:
				84
				68
	
		//Not Optimized:
			int kPure(int n, int k) {
				int cnt=0;
				for(int i=k; i<=n; i+=k){
					int value = i;
					if(value % k == 0){
						value /= k;
						if(value % k != 0)
							cnt++;
					}
				}
				return cnt;
			}

		// Optimized:
			int kPure(int n, int k) {
				return (n/k) - (n/k)/k;
			}

	372) Future Expansion:❌Pending
		Problem statement
			Ninja has a string 'S' of the length 'N'. He wants to expand it and make its length
			atleast 'M'. He can do the following operation at a time:
			• Choose any character 'X' present in the string, copy all of the characters 'X'
			from the string, and paste them at the end of the string 'S'.
			Your task is to to return the minimum number of operations required to expand
			the length of string 'S' to at least 'M'.
			Example:
			'N' = 4
			'S' = "abcc"
			'M' = 7
			The best way to make the length of the string atleast '7'(M) is:
			Choose the character 'a':
			"abcc" → "abcca"
			Choose the character 'c':
			"abcca" → "abccacc"
			The Ninja needs two operations to expand the string to length '7'. So. the
			answer is '2'.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^5
				a <= S[i] <= z
				N <= М <= 10^18
				Time Limit: 1 second
			Sample Input 1:
				2
				4 8
				abcd
				5 7
				xyaab
				Sample Output 1:
				3
				1
				Explanation Of Sample Input 1:
				For test case 1:
				The best way to make the length of the string at least '8'(M) is:
				Choose the character 'a':
				"abcd" → "abcda"
				Choose the character 'c':
				"abcda" → "abcdac"
				Choose the character 'a':
				"abeda" → "abcdacaa"
				The Ninja needs three operations to expand the string. So, the answer is '3'.
				For test case 2:
				The best way to make the length of the string atleast '7'(M) is:
				Choose the character 'a':
				"xyaab" → "xyaabaa"
				The Ninja needs one operation to expand the string. So, the answer is 1.
			Sample Input 2:
				2
				6 110
				bvaynd
				5 151
				wfpoa
				Sample Output 2:
				7
				8

		//Not Optimized:
			int findMinimumOperations(int n, long long m, string s) {
				int OpsCnt=0;
				if(s.length() >= m)
					return OpsCnt;

				map<char, int> Freq;
				for(char ch: s)
					Freq[ch]++;
				
				int len = s.length();

				int mx=INT_MIN;

				for(auto i: Freq)
					mx = max(mx, i.second);
				
				while(len < m){
					len += mx;
					mx += mx;
					OpsCnt++;
				}

				return OpsCnt;
			}
		
		// Optimized:
			int findMinimumOperations(int n, long long m, string s) {
				map<char, int> mp;
				long long mx=-1;

				for(char ch: s){
					mp[ch]++;
					if(mp[ch] > mx)
						mx = mp[ch];
				}
				int Ops=0;
				long long incresingSize = n;
				while(incresingSize < m){
					incresingSize += mx;
					mx *= 2;
					Ops++;
				}
				return Ops;
			}
	
	373) Alex And Infinity Circle:
		Problem statement
			Alex wanted to buy a new keyboard, but due to the low battery in his GPS, 
			he had to print his route on paper, now he wants to know if he can return safely 
			to his home following the instructions written by him. The city of Alex can be 
			represented by a 2D plane, and every location is denoted by ('X','Y') coordinates. 
			Alex is currently standing at ( 0, 0 ) facing north.

			The printed route contains a string with characters like:
			'L' : which denotes he should turn to the left of the direction he is facing.
			'R' : which denotes he should turn to the right of the direction he is facing. 
			'G' : which denotes he should walk in the same direction by one unit.
			Determine whether he can return home safely or not by following his instruction on the printed sheet.
			Note:
				He can follow the same printed set of instructions as many times as wanted.
			Constraints:
				1 <= T <= 50
				1 <= N <= 100
				‘STR’ = {‘L’, ‘R’ and ‘G’}.
				Where ‘T’ is the number of test cases, 'N' is the length of string ‘STR’  and ‘STR’ 
				is the string that denotes the direction that Alex should move. 

				Time limit: 1 sec
			Sample Input 1:
				2
				6
				GGRRGG
				2
				GGG
				Sample Output 1:
				True
				False
				Explanation of sample input 1:
				In the first test case, Alex follows the following instructions, 
				he will go from (0,0) -> (0,1) -> (0,2) -> turned towards east -> turned towards south -> (0,1) -> (0,0).

				In the second test case, he will always go towards the right, hence it is impossible for him to return home.
				Sample Input 2:
				2
				2
				LR
				2
				GL
				Sample Output 2:
				True
				True
				Explanation of sample input 2:
				In the first test case, he is in the same position just turning in his direction.

				In the second test case, he will go from (0,0) -> (0,1) -> (turned left) -> 
				(-1,1) -> (turned left) ->(-1,0) ->(turned left) -> (0,0)

		#include <bits/stdc++.h> 
		string isPossible(string s,int n) {

			// Processing all operations
			int x,y;
			x = y = 0;
			char Direction[] = {'N','E','S','W'};
			

			int direct_index = 0;
			char CurrentDirect = Direction[direct_index];

			int checkTimes = 1;

			checker:
			for(int i=0; i<n; i++){
				if(s[i] == 'G' && CurrentDirect == 'N')
					x++;
				else if(s[i] == 'G' && CurrentDirect=='S')
					x--;
				else if(s[i] == 'G' && CurrentDirect== 'E')
					y++;
				else if(s[i] == 'G' && CurrentDirect == 'W')
					y--;
				else if(s[i] == 'R'){
					direct_index++;
					if(direct_index >= 4)
						direct_index = 0;

					CurrentDirect = Direction[direct_index];

				}else if(s[i] == 'L'){
					direct_index--;
					if(direct_index < 0)
						direct_index = 3;
					CurrentDirect = Direction[direct_index];
				}    
			}
			
			checkTimes++;
			if(checkTimes != 5)
				goto checker;

			// result after all operations
			if(x == 0 && y == 0)
				return "True";

			// default result
			return "False";
		}
	
	374) Longest Sub-string With K Distinct Characters:
		Problem statement
			You are given a string 'S' of length 'N' consisting of lowercase English alphabet letters. 
			You are also given a positive integer 'K'.
			Now, a substring of this string is good if it contains at most 'K' distinct characters. 
			A string 'X' is a substring of string 'Y' if it can be obtained by deletion of several 
			continuous elements(possibly zero) from the beginning and the end from the string 'Y'.

			Your task is to return the maximum size of any good substring of the string 'S'.
			Example:
				‘S’ = “bacda” and ‘K’ = 3.

			So, the substrings having at most ‘3’ distinct characters are called good substrings. Some possible good substrings are:
				1. “bac”
				2. “acd”
				3. “acda”

			The substring “acda” is the largest possible good substring, 
			as we cannot get any other substring of length 5 or more having 
			distinct characters less than or equal to ‘3’. Thus, you should return ‘4’ as the answer.

			Constraints:
				1 <= T <= 10
				1 <= K <= 26
				1 <= N <= 10^4

				All the characters of the string are lowercase English alphabet letters.
				Time Limit: 1 sec

			Sample Input 1:
				2
				2
				abcbc
				1
				abccc
				Sample Output 1:
				4
				3
				Explanation For Sample Input 1:
				For the first test case :
				K = 2, so we can choose substring “bcbc” having 2 distinct character which is less than or equal to K = 2. 

				We cannot get any other substring of length 5 or more having distinct characters less than or equal to 2. 
				Thus, you should return ‘4’ as the answer.

				For the second test case :
				K = 1, so we can choose substring “ccc” having only 1 distinct character which is less than or equal to K = 1. 

				We cannot get any other substring of length 4 or more having distinct characters less than or equal to 1. 
				Thus, you should return ‘3’ as the answer.
				Sample Input 2:
				1
				6
				abcba
				3
				acbdab
				Sample Output 2:
				5
				4
 
		//Not Optimized
			#include <bits/stdc++.h> 
			int getLengthofLongestSubstring(string s, int k) {
				int longLen =0;

				for(int i=0; i<s.length(); i++){
					string str;
					int cnt=0;

					str += s[i];
					for(int j=i+1; j<s.length(); j++){
						if(str.find(s[j]) != string::npos){
							str += s[j];
						}else{
							cnt++;
							if(cnt == k)
								break;
							str += s[j];
						}
					}
					int value = str.length();
					longLen = max(longLen, value);
				}
				return longLen;
			}

			// or
				#include <bits/stdc++.h> 
				int getLengthofLongestSubstring(string s, int k) {
					int mxWindow=0;
					for(int i=0; i<s.size(); i++){
						set<char> st;

						int j;
						for(j=i; j<s.size(); j++){
							st.insert(s[j]);
							if(st.size() > k)
								break;
						}
						mxWindow = max(mxWindow, j-i);
					}
					return mxWindow;
				}

		//Optimized: ❌Pending
			#include <bits/stdc++.h> 
			int getLengthofLongestSubstring(string s, int k) {
				int left=0, right=0; 
				unordered_map<char,int>mp;

				int maxlen=0;

				while(right<s.length()){
					mp[s[right]]++;
					while(mp.size()>k){
						mp[s[left]]--;
						if(mp[s[left]]==0)
							mp.erase(s[left]);
						left++;
					}
					maxlen=max(right-left+1,maxlen);
					right++;
				}
				return maxlen;
			}
	
			//or
				/*
					Time Complexity : O(N * logN)
					Space Complexity : O(1)

					Where N is the size of the string.
				*/

				#include <vector>

				// Returns the number of distinct characters in the array 'freq'.
				int countDistinct(vector<int>& freq) {
					int distinct = 0;
					for (int i = 0; i < 26; i++) {
						if (freq[i]) {
							distinct++;
						}
					}
					return distinct;
				}

				int getLengthofLongestSubstring(string s, int k) {
					int longestLength = 0;
					int n = s.size();

					int low = 1, high = n;

					while (low <= high) {
						int mid = low + (high - low) / 2;
						bool possible = false;
						vector<int> freq(26, 0);

						for (int i = 0; i < mid; i++) {
							freq[s[i] - 'a']++;
						}

						possible |= (countDistinct(freq) <= k);

						// Using sliding window, check if a valid substring of length 'mid' is possible.
						for (int i = mid; i < n; i++) {
							freq[s[i] - 'a']++;
							freq[s[i - mid] - 'a']--;
							possible |= (countDistinct(freq) <= k);
						}

						/*
							If a valid substring of length 'mid' is possible then update 'longestLength'
							and check for substrings having length greater than 'mid'.
						*/
						if (possible) {
							longestLength = max(longestLength, mid);
							low = mid + 1;
						}
						// If no such substring is possible check for substrings with length less than 'mid'.
						else {
							high = mid - 1;
						}
					}

					return longestLength;
				}

			//or
				/*
					Time Complexity : O(N)
					Space Complexity : O(1)

					Where N is the size of the string.
				*/
				#include <vector>

				// Returns the number of distinct characters in the array 'freq'.
				int countDistinct(vector<int>& freq) {
					int distinct = 0;

					for (int i = 0; i < 26; i++) {
						if (freq[i]) {
							distinct++;
						}
					}
					return distinct;
				}

				int getLengthofLongestSubstring(string s, int k) {
					int longestLength = 0;
					int n = s.size();

					vector<int> freq(26, 0);
					// Starting index of the window.
					int start = 0;

					// Traverse for ending index of the window.
					for (int i = 0; i < n; i++) {
						freq[s[i] - 'a']++;

						while (countDistinct(freq) > k) {
							freq[s[start] - 'a']--;
							start++;
						}

						longestLength = max(longestLength, i - start + 1);
					}

					return longestLength;
				}

	375) Quick Sort:
		Problem Statement:
			Quick Sort is a Divide and Conquer algorithm. It picks an element as a pivot and partitions the given array around the picked pivot.
			Given an array arr[], its starting position is low (the index of the array) and its ending position is high(the index of the array).

			Note: The low and high are inclusive.
			Implement the partition() and quickSort() functions to sort the array.

			Example 1:
				Input: 
				N = 5 
				arr[] = { 4, 1, 3, 9, 7}
				Output:
				1 3 4 7 9

			Example 2:
				Input: 
				N = 9
				arr[] = { 2, 1, 6, 10, 4, 1, 3, 9, 7}
				Output:
				1 1 2 3 4 6 7 9 10

			Your Task: 
				You don't need to read input or print anything. Your task is to complete the functions partition() and 
				quickSort() which takes the array arr[], low and high as input parameters and partitions the array. 
				Consider the last element as the pivot such that all the elements less than(or equal to) 
				the pivot lie before it and the elements greater than it lie after the pivot.

			Expected Time Complexity: O(N*logN)
			Expected Auxiliary Space: O(logN)

			Constraints:
				1 <= N <= 10^3
				1 <= arr[i] <= 10^4

		Last element as pivot approach:
			class Solution {
				public:
				//Function to sort an array using quick sort algorithm.
				void quickSort(int a[], int s, int e) {
					// base condition
					if(s >= e)
						return ;
					
					// make partition
					int partition_index = Partitioner(a, s, e);
					
					// handling left part of array
					quickSort(a, s, partition_index-1);
					
					// handling right part of array
					quickSort(a, partition_index+1, e);
				}
				
				public:
				int Partitioner (int a[], int s, int e) {
					int pivot = a[e]; // Choose the last element as the pivot
					int i = s - 1; // Index of smaller element
					
					for (int j = s; j <= e - 1; j++) {
						if (a[j] <= pivot) {
							i++; // Increment index of smaller element
							swap(a[i], a[j]);
						}
					}
					swap(a[i + 1], a[e]);
					return i + 1;
				}
			};
	
		First element as pivot approach:
			class Solution {
				public:
				//Function to sort an array using quick sort algorithm.
				void quickSort(int a[], int s, int e) {
					// base condition
					if(s >= e)
						return ;
					
					// make partition
					int partition_index = Partitioner(a, s, e);
					
					// handling left part of array
					quickSort(a, s, partition_index-1);
					
					// handling right part of array
					quickSort(a, partition_index+1, e);
				}
				
				public:
				int Partitioner (int arr[], int s, int e) {
					int pivot = arr[s];

					int cnt = 0;
					for(int i = s+1; i<=e; i++) {
						if(arr[i] <=pivot) {
							cnt++;
						}
					}
				
					//place pivot at right position
					int pivotIndex = s + cnt;
					swap(arr[pivotIndex], arr[s]);
				
					//left and right wala part smbhal lete h 
					// int i = s, j = e;
				
					while(s < pivotIndex && e > pivotIndex) {
				
						while(arr[s] <= pivot) 
						{
							s++;
						}
				
						while(arr[e] > pivot) {
							e--;
						}
				
						if(s < pivotIndex && e > pivotIndex) {
							swap(arr[s++], arr[e--]);
						}
					}
					return pivotIndex;
				}
			};

		//My own solution:
			class Solution {
				public:
				//Function to sort an array using quick sort algorithm.
				void quickSort(int arr[], int low, int high) {
					if(low >= high)
						return ;
						
					// find the partition index
					int index = partition(arr, low, high);
					
					// handling right side
					quickSort(arr, index+1, high);
					
					// handling left side
					quickSort(arr, low, index-1);
				}
			
				public:
				int partition (int arr[], int low, int high) {
					int cnt=0;
					for(int i=low+1; i<=high; i++)
						if(arr[low] >= arr[i])
							cnt++;
							
					int partitionIndex = cnt + low;
					
					swap(arr[partitionIndex], arr[low]);
					
					//clear left-right side of partition_index
					while(low<partitionIndex && high>partitionIndex){
						
						// keep going till you can not find the element which is larger than partitionIndex on right side
						while(low < partitionIndex){
							if(arr[low] > arr[partitionIndex])
								break;
							low++;
						}
								
						// keep going till you can not find the element which is less than partitionIndex on left side
						while(high > partitionIndex){
							if(arr[high] <= arr[partitionIndex])
								break;
							high--;
						}
						
						swap(arr[low], arr[high]);
					}	
					return partitionIndex;
				}
			};

			//or
				class Solution {
					public:
					//Function to sort an array using quick sort algorithm.
					void quickSort(int arr[], int low, int high) {
						if(low >= high)
							return ;
						
						int partIndex = partition(arr, low, high);
						
						quickSort(arr, low, partIndex-1);
						
						quickSort(arr, partIndex+1, high);
					}
					
					public:
					int partition (int arr[], int low, int high) {
						int cnt=0;
						for(int i=low+1; i <= high; i++)
							if(arr[low] >= arr[i])
								cnt++;
								
						int actualPlace = low + cnt;
						swap(arr[actualPlace], arr[low]);
						
						while(low < actualPlace && actualPlace < high){
							
							while(low < actualPlace && arr[low] <= arr[actualPlace])
									low++;
								
							while(high > actualPlace && arr[high] > arr[actualPlace])
									high--;
									
							swap(arr[low], arr[high]);
						}
						return actualPlace;
					}
				};

	376) Kadane's Algorithm:
		Problem Statement:
			Given an array Arr[] of N integers. 
			Find the contiguous sub-array(containing at least one number) which has the maximum sum and return its sum.
			Example 1:

			Input:
				N = 5
				Arr[] = {1,2,3,-2,5}
				Output:
				9
				Explanation:
				Max subarray sum is 9
				of elements (1, 2, 3, -2, 5) which 
				is a contiguous subarray.

			Example 2:
				Input:
				N = 4
				Arr[] = {-1,-2,-3,-4}
				Output:
				-1
				Explanation:
				Max subarray sum is -1 
				of element (-1)

			Your Task:
				You don't need to read input or print anything. 
				The task is to complete the function maxSubarraySum() which takes Arr[] and N as 
				input parameters and returns the sum of subarray with maximum sum.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)


			Constraints:
				1 ≤ N ≤ 10^6
				-10^7 ≤ A[i] ≤ 10^7

		class Solution{
			public:
			// arr: input array
			// n: size of array
			//Function to find the sum of contiguous subarray with maximum sum.
			long long maxSubarraySum(int arr[], int n){
				long long ans = arr[0];
				long long crntMX = arr[0];
				
				for(int i=1; i<n; i++){
					long long value = arr[i] ;
					crntMX = max(value, crntMX + arr[i]);
					
					ans = max(ans, crntMX);
				}
				return ans;
			}
		};

	377) Maximum Subarray: ❌Pending
		Problem statement:
			Kadane's Algorithm
			Given an integer array nums, find the subarray
			with the largest sum, and return its sum.

			Example 1:
				Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
				Output: 6
				Explanation: The subarray [4,-1,2,1] has the largest sum 6.

			Example 2:
				Input: nums = [1]
				Output: 1
				Explanation: The subarray [1] has the largest sum 1.

			Example 3:
				Input: nums = [5,4,-1,7,8]
				Output: 23
				Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

			Constraints:
				1 <= nums.length <= 10^5
				-10^4 <= nums[i] <= 10^4
			
			Follow up: If you have figured out the O(n) solution, 
			try coding another solution using the divide and conquer approach, 
			which is more subtle.

		// Not Optimized:
			class Solution {
				public:
				int maxSubArray(vector<int>& nums) {
					int mxValue = *max_element(nums.begin(), nums.end());

					for(int i=0; i<nums.size(); i++){
						int sum = nums[i];
						for(int j=i+1; j<nums.size(); j++){
							sum += nums[j];
							mxValue = max(mxValue, sum);
						}
					}
					return mxValue;
				}
			};

		// Optimized:
			class Solution {
				public:
				int maxSubArray(vector<int>& nums) {
					int maxEndingHere = nums[0]; // Max sum ending at the current position
					int maxSoFar = nums[0];      // Max sum found so far

					for (int i = 1; i < nums.size(); ++i) {
						// Calculate the maximum sum ending at the current position
						maxEndingHere = max(nums[i], maxEndingHere + nums[i]);
						
						// Update the global maximum sum if necessary
						maxSoFar = max(maxSoFar, maxEndingHere);
					}
					return maxSoFar;
				}
			};

	378) Kth smallest element:
		Problem Statement:
			Given an array arr[] and an integer K where K is smaller than size of array, 
			the task is to find the Kth smallest element in the given array. It is given that all array elements are distinct.
			Note :-  l and r denotes the starting and ending index of the array.

			Example 1:

			Input:
			N = 6
			arr[] = 7 10 4 3 20 15
			K = 3
			L=0 R=5

			Output : 7
			Explanation :
			3rd smallest element in the given 
			array is 7.
			Example 2:

			Input:
			N = 5
			arr[] = 7 10 4 20 15
			K = 4 L=0 R=4
			Output : 15
			Explanation :
			4th smallest element in the given 
			array is 15.
			Your Task:
			You don't have to read input or print anything. 
			Your task is to complete the function kthSmallest() which takes the array arr[], 
			integers l and r denoting the starting and ending index of the array and 
			an integer K as input and returns the Kth smallest element.
			
			
			Expected Time Complexity: O(n*log(n))
			Expected Auxiliary Space: O(log(n))
			Constraints:
				1 <= N <= 10^5
				L==0
				R==N-1
				1<= arr[i] <= 10^5
				1 <= K <= N

		class Solution{
			public:
			// arr : given array
			// l : starting index of the array i.e 0
			// r : ending index of the array i.e size-1
			// k : find kth smallest element and return using this function
			int kthSmallest(int arr[], int l, int r, int k) {
				sort(arr, arr+r+1);
				return arr[k-1];
			}
		};

		//or
			class Solution{
				public:
				// arr : given array
				// l : starting index of the array i.e 0
				// r : ending index of the array i.e size-1
				// k : find kth smallest element and return using this function
				
				// Merge sort algorithm
				void Merger(int *a, int s, int e){
					int mid = (s+e)/2;
					
					int len1 = mid - s + 1;
					int len2 = e - mid;
					
					int *first = new int[len1];
					int *sec = new int[len2];
					
					//copy
					int starter = s;
					for(int i=0; i<len1; i++){
						first[i] = a[starter++];
					}
					
					for(int i=0; i<len2; i++){
						sec[i] = a[starter++];
					}
					
					
					int mainIndex = s;
					int index1, index2;
					index1 = index2 =0;
					
					while(index1 < len1 && index2 < len2){
						if(first[index1] < sec[index2]){
							a[mainIndex] = first[index1++];
						}else{
							a[mainIndex] = sec[index2++];
						}
						mainIndex++;
					}
					
					while(index1 < len1) {
						a[mainIndex++] = first[index1++];
					}
					
					while(index2 < len2){
						a[mainIndex++] = sec[index2++];
					}
					
					delete [] first;
					delete [] sec;
				}
				
				
				void split(int *p, int s, int e){
					if(s >= e)
						return ;
					
					int mid = (s+e)/2;
					
					// handle left side part
					split(p, s, mid);
					
					// handle right side part
					split(p, mid+1, e);
					
					//Merge them back
					Merger(p, s, e);
				}
				
				int kthSmallest(int arr[], int l, int r, int k) {
					split(arr, l, r);
					return arr[k-1];
				}
			};
	
	379) Kth Largest Element in an Array:
		Problem statement:
			Given an integer array nums and an integer k, return the kth largest element in the array.
			Note that it is the kth largest element in the sorted order, not the kth distinct element.
			Example 1:

			Input: nums = [3,2,1,5,6,4], k = 2
			Output: 5
			Example 2:

			Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
			Output: 4

			Constraints:
				1 <= k <= nums.length <= 10^5
				-104 <= nums[i] <= 10^4
		
		class Solution {
			public:
			int findKthLargest(vector<int>& nums, int k) {
				sort(nums.begin(), nums.end(), greater<int>());
				return nums[k-1];
			}
		};

		class Solution {
			public:
			int findKthLargest(vector<int>& nums, int k) {
				sort(nums.begin(), nums.end());
				return nums[nums.size()-k];
			}
		};

		Can you solve it without sorting? ❌Pending

	380) Top K Frequent Elements:
		Problem Statement:
			Given an integer array nums and an integer k, return the 
			k most frequent elements. You may return the answer in any order.

			Example 1:
				Input: nums = [1,1,1,2,2,3], k = 2
				Output: [1,2]

			Example 2:
				Input: nums = [1], k = 1
				Output: [1]

			Constraints:
				1 <= nums.length <= 10^5
				-10^4 <= nums[i] <= 10^4
				k is in the range [1, the number of unique elements in the array].
				It is guaranteed that the answer is unique.
			
			Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
		
		class Solution {
			public:
			static bool cmpSortDesc(pair<int, int> a, pair<int, int> b){
				return a.second > b.second;
			}

			vector<int> topKFrequent(vector<int>& nums, int k) {
				vector<int> ans;
				map<int, int> Freq;
				for(int i: nums)
					Freq[i]++;

				vector<pair<int, int>> holder;
				for(auto i: Freq){
					pair<int, int> temp = {i.first, i.second};
					holder.push_back(temp);
				}

				//sorting
				sort(holder.begin(), holder.end(), cmpSortDesc);
				
				int i=0;
				while(k--){
					ans.push_back(holder[i].first);
					i++;
				}
				return ans;
			}
		};
	
	381) Palindromic Substrings:
		Problem statement:
			Given a string s, return the number of palindromic substrings in it.
			A string is a palindrome when it reads the same backward as forward.
			A substring is a contiguous sequence of characters within the string.
			Example 1:
				Input: s = "abc"
				Output: 3
				Explanation: Three palindromic strings: "a", "b", "c".

			Example 2:
				Input: s = "aaa"
				Output: 6
				Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
				
			Constraints:
				1 <= s.length <= 1000
				s consists of lowercase English letters.
		
		class Solution {
			public:
			bool checkPalin(string str){
				// string tempo = str;
				// reverse(tempo.begin(), tempo.end());
				// if(tempo == str)
				//     return 1;
				// return false;

				//or logic for reverse, to minimize Time complexity
				for(int i=0; i<str.length()/2; i++)
					if(str[i] != str[str.length()-1-i])
						return 0;
				return true;
			}

			int countSubstrings(string s) {
				int PalinDromicCNT= s.length();

				for(int i=0; i<s.length()-1; i++){
					string temp;
					temp += s[i];
					for(int j=i+1; j<s.length(); j++){
						temp += s[j];
						if(checkPalin(temp))
							PalinDromicCNT++;                
					} 
				}
				return PalinDromicCNT;
			}
		};

		// or
			bool isPalindrom(string s){
				int i=0, j=s.size()-1;
				while(i < j)
					if(s[i++] != s[j--])
						return 0;

				return 1;
			}

			int palindromicSubstrings(string input) {
				int n = input.size();
				int cnt = n;
				for(int i=0; i<n; i++){
					string temp = string(1, input[i]);
					for(int j=i+1; j<n; j++){
						temp += input[j];
						if(isPalindrom(temp))
							cnt++;
					}
				}
				return cnt;
			}

	382) Rotate Bits:
		Problem statement:
			Given an integer N and an integer D, 
			rotate the binary representation of the integer N by D digits 
			to the left as well as right and return the results in their decimal representation after each of the rotation.
			Note: Integer N is stored using 16 bits. i.e. 12 will be stored as 0000000000001100.

			Example 1:
				Input:
				N = 28, D = 2
				Output:
				112
				7
				Explanation: 
				28 in Binary is: 0000000000011100
				Rotating left by 2 positions, it becomes 0000000001110000 = 112 (in decimal).
				Rotating right by 2 positions, it becomes 0000000000000111 = 7 (in decimal).

			Example 2:
				Input: 
				N = 29, D = 2
				Output: 
				116
				16391
				Explanation: 
				29 in Binary is: 0000000000011101
				Rotating left by 2 positions, it becomes 0000000001110100 = 116 (in decimal).
				Rotating right by 2 positions, it becomes 010000000000111 = 16391 (in decimal).

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function rotate() which 
				takes the integer N and integer D as inputs and returns 
				an array of size 2 where arr[0] = Decimal value after left 
				rotation and arr[1] = Decimal value after right rotation.

			Expected Time Complexity: O(1).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <  2^16
				1 <= D <= 10^5

		// Not Optimized: (This is also optimized, just need this remain d = d % s.length())
			class Solution {
				public:
				vector <int> rotate (int n, int d){
					vector<int> ans;
					
					// generated binary representation of n
					string s = bitset<16>(n).to_string();
					
					// rotating left by d Digits
					// d %= s.length();					//if we don't write this line, we get TLE.
					for(int i=0; i<d; i++){
						char StartCh = *(s.begin()); 
						s.erase(s.begin());
						s.push_back(StartCh);
					}
					
					int left = stoi(s, 0, 2);
					ans.push_back(left);
					
					s = bitset<16>(n).to_string();
					
					// rotating right by d digits
					while(d--){
						char lastChar = *(s.end()-1);
						s.erase(s.end()-1);
						s.insert(s.begin(), lastChar);
					}
					
					int right = stoi(s, 0, 2);
					ans.push_back(right);
					return ans;
				}
			};

		// Optimized:
			class Solution {
				public:
				vector <int> rotate (int n, int d){
					vector<int> ans;
					
					// generated binary representation of n
					string s = bitset<16>(n).to_string();
					
					// rotating left by d Digits
					// if d is out of length of string s, then making it to fit within length of string s.
					d %= s.length();
					
					
					s = s.substr(d) + s.substr(0, d);
					
					int left = stoi(s, 0, 2);
					ans.push_back(left);
					
					s = bitset<16>(n).to_string();
					
					// rotating right by d digits
					s = s.substr(s.length()-d) + s.substr(0, s.length()-d);
					
					int right = stoi(s, 0, 2);
					ans.push_back(right);
					return ans;
				}
			};

	383) Stack Implementation Using Array
		Problem statement:
			Stack is a data structure that follows the LIFO (Last in First out) principle. 
			Design and implement a stack to implement the following functions:
			1. Push(num): Push the given number in the stack if the stack is not full.
			2. Pop: Remove and print the top element from the stack if present, else print -1.
			3. Top: Print the top element of the stack if present, else print -1.
			4. isEmpty: Print 1 if the stack is empty, else print 0.
			5. isFull: Print 1 if the stack is full, else print 0.
			You have been given ‘m’ operations which you need to perform in the stack. 
			Your task is to implement all the functions of the stack.

			Example:
				We perform the following operations on an empty stack which has capacity 2:
				When operation 1 1 is performed, we insert 1 in the stack.
				When operation 1 2  is performed, we insert 2 in the stack. 
				When operation 2 is performed, we remove the top element from the stack and print 2.
				When operation 3 is performed, we print the top element of the stack, i.e., 3.
				When operation 4 is performed, we print 0 because the stack is not empty.
				When operation 5 is performed, we print 0 because the stack is size 1, which is not equal to its capacity.
			Sample Input 1 :
				2 6
				1 1
				1 2
				2
				3
				4
				5
			Sample Output 1 :
				2 
				1
				0
				0
				Explanation For Sample Output 1 :
				We perform the following operations on an empty stack which has capacity 2:
				When operation 1 1 is performed, we insert 1 in the stack.
				When operation 1 2  is performed, we insert 2 in the stack. 
				When operation 2 is performed, we remove the top element from the stack and print 2.
				When operation 3 is performed, we print the top element of the stack, i.e., 1.
				When operation 4 is performed, we print 0 because the stack is not empty.
				When operation 5 is performed, we print 0 because the stack is size 1, which is not equal to its capacity.
				Sample Input 2 :
				5 5
				1 2
				2
				2 
				1 1
				3
				Sample Output 2 :
				2 
				-1
				1
				Explanation For Sample Output 2 :
				We perform the following operations on an empty stack which has a capacity of 5:
				When operation 1 2 is performed, we insert 2 in the stack.
				When operation 2 is performed, we remove the top element from the stack and print 2.
				When operation 2 is performed, as the stack is empty, we print -1.
				When operation 1 1 is performed, we insert 1 in the stack.
				When operation 3 is performed, we print the top element of the stack, i.e., 1.
			Constraints :
				1 <= 'n', 'm' <= 10^3
				Time Limit: 1 sec

		// Stack class.
			class Stack {
				public:
				int *arr, size, currentIndex;
				
				Stack(int capacity) {
					size = capacity;
					arr = new int[capacity];
					currentIndex = -1;
				}

				void push(int num) {
					if(!isFull()){
						currentIndex++;
						arr[currentIndex] = num;
					}
				}

				int pop() {
					if(!isEmpty()){
						int x = arr[currentIndex];
						currentIndex--;
						return x;
					}
					return -1;
				}
				
				int top() {
					if(!isEmpty())
						return arr[currentIndex];
					return -1;
				}
				
				int isEmpty() {
					if(currentIndex == -1)
						return 1;
					return 0;
				}
				
				int isFull() {
					if(currentIndex == size-1)
						return 1;
					return 0;
				}    
			};

		//or
			// Stack class.
			class Stack {
				public:
				int *arr, size, currentIndex;
				
				Stack(int capacity) {
					size = capacity;
					arr = new int[capacity];
					currentIndex = -1;
				}

				void push(int num) {
					// if(isFull())
					//     return ;
					//or
					if(currentIndex == size-1)
						return ;
					currentIndex++;
					arr[currentIndex] = num;
				}

				int pop() {
					// if(isEmpty())
					//     return -1;
					//or 
					if(currentIndex == -1)
						return -1;
					int x = arr[currentIndex];
					currentIndex--;
					return x;
				}
				
				int top() {
					if(isEmpty())
						return -1;
					//or
					// if(currentIndex == -1)
					//     return -1;
					return arr[currentIndex];
				}
				
				int isEmpty() {
					if(currentIndex == -1)
						return 1;
					return 0;
				}
				
				int isFull() {
					if(currentIndex == size-1)
						return 1;
					return 0;
				}    
			};

	384) Longest Palindromic Substring:
		Problem statement:
			You are given a string 'str' of length 'N'.
			Your task is to return the longest palindromic substring. 
			If there are multiple strings, return any.
			A substring is a contiguous segment of a string.
			For example :
				str = "ababc"
				The longest palindromic substring of "ababc" is "aba", 
				since "aba" is a palindrome and it is the longest substring of length 3 which is a palindrome.

				There is another palindromic substring of length 3 is "bab". 
				Since starting index of "aba" is less than "bab", so "aba" is the answer.
			Sample Input 1:
				abccbc
				Sample Output 1:
				bccb
				Explanation for input 1:
				For string "abccbc",  there are several palindromic substrings such as "a", "b", "c", "cc", "bccb", 
				and "cbc". However, the longest palindromic substring is "bccb".
				Sample Input 2:
				aeiou
				Sample Output 2:
				a
			Constraints :
				1 <= |str| <= 10^3
				Time Limit: 1 sec
		
		//Not Optimized:
			bool checkLongPalin(string z){
				for(int a=0; a<z.length()/2; a++)
					if(z[a] != z[z.length()-1-a])
						return false;
				return 1;
			}

			string longestPalinSubstring(string str) {
				// we can write this to just copy the first char to string ans
				// string ans = str.substr(0,1);
				//or
				string ans;
				ans += str[0];

				for(int i=0; i<str.length()-1; i++){
					string temp = str.substr(i, 1);

					for(int j=i+1; j<str.length(); j++){
						temp += str[j];
						if(checkLongPalin(temp) && temp.length() > ans.length())
							ans = temp;
					}
				}
				return ans;
			}
		
		//Optimized: ❌Pending
			/*
				Time Complexity : O(N ^ 2)
				Space Complexity: O(1)
				
				Where N is the length of the string.
			*/

			#include <algorithm>

			int expandAroundCenter(string str, int left, int right) {
				int start = left, end = right;
				int n = str.length();

				// Expand the center.
				while (start >= 0 && end < n && str[start] == str[end]) {
					start--;
					end++;
				}
				return end - start - 1;
			}

			string longestPalinSubstring(string str) {
				int n = str.length();

				if (n < 1) 
					return "";
				
				int start = 0, end = 0;
				for (int i = 0; i < n; i++) {
					// Longest odd length palindrome with center points as i.
					int len1 = expandAroundCenter(str, i, i);

					// Longest even length palindrome with center points as i and i + 1.
					int len2 = expandAroundCenter(str, i, i + 1);

					int len = max(len1, len2);

					// Update the start and end.
					if (len > end - start + 1) {
						start = i - (len - 1) / 2;
						end = i + (len) / 2;
					}
				}
				return str.substr(start, end - start + 1);
			}

	385) Smallest Number: ❌Pending
		https://www.codingninjas.com/studio/problems/smallest-number_1164401
		Problem statement:
			You are given two positive integers ‘N’ and ‘K’. Your task is to find the smallest ‘N’ 
			digit number whose sum of digits equals ‘K’. If no such number exists then you need to print -1.
			Constraints :
				1 <= T <= 5
				1 <= N <= 5000
				0 <= K  <= 10^6
				Where ‘T’ is the number of test cases, ‘N’  is the total number of digits 
				and ‘K’ denotes sum of digits that the required number should have.
				Time Limit : 1sec
			Sample Input 1 :
				2
				2 8
				3 1
				Sample Output 1 :
				17 
				100
				Explanation of Sample Input 1 :
				Test Case 1 :  
				N = 2 and K = 8. 
				All two-digit numbers  whose sum of digits = 8 are [17, 26, 35, 44, 53, 62, 71, 80]
				The smallest two-digit number whose sum of digits = 8 is 17. 

				Test Case 2 : 
				N = 3 and K = 1. 
				The smallest three-digit number whose sum of digits = 1 is 100. 
				Sample Input 2 :
				2
				4 5 
				1 8
				Sample Output 2 :
				1004
				8
				Explanation of Sample Input 2 :
				Test Case 1 :  
				N = 4 and K = 5. 
				The smallest four-digit number whose sum of digits = 5 is 1004. 

				Test Case 2 : 
				N = 1 and K = 8. 
				The smallest one-digit number whose sum of digits = 8 is 8. 

		// n should be integer within the range [1..7].
			#include <bits/stdc++.h> 
			string smallestNumber(int n, int k) {

				if(k==0 && n==1)
					return "0";

				int start = 1, end;
				for(int i=1; i<n; i++)
					start *= 10;

				end = start * 10;

				for(int i=start; i<end; i++){
					int crntNum = i;
					int sum=0;
					while(crntNum){
						sum += (crntNum % 10);
						crntNum /= 10;
					}
					if(sum == k)
						return to_string(i);
				}
				return "-1";
			}
		
		#include <bits/stdc++.h> 
		string smallestNumber(int n, int k) {
			if(k>n*9)return "-1";
			if(k==0)return n==1?"0":"-1";
			string ans="";
			for(int i=0;i<n;i++){
				if((n-i-1)*9>=k){
					if (i == 0) {
						ans.push_back('1');k--;
					} else
						ans.push_back('0');
					}
				else{
					int tmp=k-(n-i-1)*9;
					ans.push_back('0'+tmp);
					k-=tmp;
				}
			}
			return ans;
		}

	386) Recamans sequence:
		Problem statement:
			Given an integer n, return the first n elements of Recaman’s sequence.
			It is a function with domain and co-domain as whole numbers. It is recursively defined as below:
			Specifically, let a(n) denote the (n+1)th term. (0 being the 1st term).
			The rule says:
			a(0) = 0
			a(n) = a(n-1) - n, if a(n-1) - n > 0 and is not included in the sequence previously
				=  a(n-1) + n otherwise.

			Example 1:
				Input: 
				n = 5
				Output: 
				0 1 3 6 2
				Explaination: 
				a(0) = 0,
				a(1) = a(0)-1 = 0-1 = -1 and -1<0, therefore a(1) = a(0)+1 = 1,
				a(2) = a(1)-2 = 1-2 = -1 and -1<0, therefore a(2) = a(1)+2 = 3,
				a(3) = a(2)-3 = 3-3 = 0 but since 0 is already present in the sequence, a(3) = a(2)+3 = 3+3 = 6,
				a(4) = a(3)-4 = 6-4 = 2.
				Therefore the first 5 elements of Recaman's sequence will be 0 1 3 6 2.
				
			Example 2:
				Input: 
				n = 3
				Output: 
				0 1 3
			Explaination: 
				As seen in example 1, the first three elements will be 0 1 3.
			Your Task:
				You do not need to read input or print anything. 
				Your task is to complete the function recamanSequence() which takes n as the input parameter and returns the sequence.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n ≤ 10^5

		//Not Optimized:
			class Solution{
				public:
				vector<int> recamanSequence(int n){
					vector<int> recaman = {0};
					
					int cnt = 1;
					while(recaman.size()<n){
						int num = recaman[cnt-1] - cnt;
						
						// if num is -ve convert it to +ve
						if(num < 0)
							num = recaman[cnt-1] + cnt;
						
						// if num is already present in vector don't push that again
						if(find(recaman.begin(), recaman.end(), num) == recaman.end()) {          // not found
							recaman.push_back(num);
						}else{
							int n2 = recaman[cnt-1] + cnt;
							recaman.push_back(n2);
						}
						cnt++;
					}
					return recaman;
				}
			};

		//Optimized:
			class Solution{
				public:
				vector<int> recamanSequence(int n){
					unordered_map<int,int> mp;
					vector<int> res(n);
					res[0] = 0;
					res[1] = 1;
					mp[0] = 0;
					mp[1] = 1;
					for(int i =2; i<n; i++) {
						int x = res[i-1] -i;
						if(x > 0 && mp[x] == 0) {
							res[i] = x;
							mp[x]++;
						} else {
							x = res[i-1] + i;
							res[i] = x;
							mp[x]++;
						}
					}
					return res;
				}
			};

	387) Count of sum of consecutives:
		Problem statement:
			You are given a positive integer 'N.' 
			Your task is to find the number of ways to represent the given number 'N' 
			as the sum of two or more consecutive natural numbers.
			Constraints:
				1 <= T <= 100
				1 <= N <= 10^8

			Time Limit: 1 sec
				Sample Input 1:
				1
				9
				Sample Output 1:
				2
				Explanation for sample input 1:
				9 can be represented as (2+3+4 = 9) and (4+5 = 9).
				Sample Input 2:
				1
				8
				Sample Output 2:
				0
				Explanation for sample input 2:
				There is no way to represent 8 in the form of a sum of 2 or more consecutive natural numbers.

		// Not Optimized
			#include <bits/stdc++.h> 
			int countWays(int n) {
				vector<int> holder;
				for(int i=1; i<=(n/2)+1; i++)
					holder.push_back(i);
				
				int cnt =0;
				for(int i=0; i<=holder.size()-1; i++){
					int sum=holder[i];
					for(int j=i+1; j<holder.size(); j++){
						sum += holder[j];
						if(sum == n){
							cnt++;
							break;
						}
					}
				}
				return cnt;
			}

		// Optimized: ❌Pending
			#include <bits/stdc++.h> 
			int countWays(int n) {
				int ans = 0;
				for (long int m = 1; m * (m + 1) < 2 * n; m++) {
					// Checking if there exist a positive integral value of 'a' for a particular m.
					if ((n - (m * (m + 1)) / 2) % (m + 1) == 0) {
						ans++;
					}
				}    
				return ans;
			}

	388) Square Root Of An Integer:
		Problem statement:
			You are given an integer ‘A’. 
			Your task is to find the greatest non-negative integer whose square is less than or equal to ‘A’.
			Square of a number is the product of the number with itself. 
			For e.g. square of 3 is 9.

			Sample Input 1
				2
				8
				9
				Sample Output 1
				2
				3
				Explanation Of Input 1
				The greatest non-negative integer for test case 1 
				whose square is less than equal to 8 is 2 as the square of 3 is 9 which is greater than 8.

				The greatest non-negative integer for test case 2 
				whose square is less than equal to 9 is 3 as the square of 4 is 16 which is greater than 9. 
				Sample Input 2
				2
				1
				0
				Sample Output 2
				1
				0
			Constraints
				1 <= T <= 10^4
				0 <= A <= 10^5

				Time Limit: 1 sec
			Expected Time Complexity:
				Time Complexity : O(log(n))
				Space Complexity : O(1)

		#include <bits/stdc++.h> 
		int squareRoot(int a) {
			int ans;
			for(int i=0; i<=a; i++)
				if(pow(i,2) <= a)
					ans = i;
				else
					return ans;
			return ans;
		}

		// or
			#include <bits/stdc++.h> 
			int squareRoot(int a) {
				int ans;
				for(int i=0; i<=a; i++){
					if(pow(i,2) > a)
						break;
					ans = i;
				}
				return ans;
			}
		
		// or simplest:
			#include <bits/stdc++.h> 
			int squareRoot(int a) {
				return sqrt(a);
			}
		
		// Using Binary search concept:
				/*
					Time complexity: O(log(A))
					Space complexity: O(1)	
					where A is given in each test case.
				*/

			#include <bits/stdc++.h> 
			int squareRoot(int a) {
				int s = 0, e = a;
				// int ans=0;			//or
				int ans;

				while(s <= e){
					int mid = s + (e-s)/2;
					int sqr = mid*mid;
					if(sqr == a)
						return mid;
					else if(sqr < a){
						ans = mid;
						s = mid + 1;
					}
					else
						e = mid -1;
				}
				return ans;
			}

	389) Recursive sequence:
		Problem statement:
			A function F is defined as follows F(n)= (1) +(2*3) + (4*5*6) ... upto n terms 
			(look at the examples for better clarity).
			Given an integer n, determine the F(n).
			Note: As the answer can be very large, return the answer modulo 109+7.

			Example 1:
				Input: n = 5
				Output: 365527
				Explanation: 
				F(5) = 1 + 2*3 + 4*5*6 + 7*8*9*10 + 11*12*13*14*15 = 365527.

			Example 2:
				Input: n = 7
				Output: 6006997207
				Explanation: 
				F(5) = 1 + 2*3 + 4*5*6 + 7*8*9*10 + 11*12*13*14*15 + 
				16*17*18*19*20*21 + 22*23*24*25*26*27*28 = 6006997207.
				6006997207 % 109+7 = 6997165

			Your Task:
				You do not need to read input or print anything. 
				Your task is to complete the function sequence() which takes an integer n 
				as an input parameter and returns the value of F(n).

			Expected Time Complexity: O(n^2)
			Expected Space Complexity: O(1)

			Constraints:
				1 ≤ n ≤ 10^3

		class Solution{
			public:
			long long sequence(int n){
				long long ans=0;
				int mod = 1e9+7;
				
				vector<vector<int>> holder;
				
				int cnt=1;
				for(int i=0; i<n; i++){
					vector<int> temp;
					for(int j=0; j<=i; j++){
						temp.push_back(cnt++);
					}
					holder.push_back(temp);
				}
				
				for(int i=0; i<holder.size(); i++){
					long long sum =1;
					for(int j=0; j<holder[i].size(); j++){
						sum *= holder[i][j];
						sum %= mod;
					}
					ans += sum;
				}
				
				return ans%mod;
			}
		};

	390) Search In Rotated Sorted Array:
		Problem statement:
			You have been given a sorted array/list 'arr' consisting of ‘n’ elements. You are also given an integer ‘k’.
			Now the array is rotated at some pivot point unknown to you.
			For example, if 'arr' = [ 1, 3, 5, 7, 8], then after rotating 'arr' at index 3, the array will be 'arr' = [7, 8, 1, 3, 5].
			Now, your task is to find the index at which ‘k’ is present in 'arr'.
			Note :
				1. If ‘k’ is not present in 'arr', then print -1.
				2. There are no duplicate elements present in 'arr'. 
				3. 'arr' can be rotated only in the right direction.
			Example:
				Input: 'arr' = [12, 15, 18, 2, 4] , 'k' = 2
				Output: 3
			Explanation:
				If 'arr' = [12, 15, 18, 2, 4] and 'k' = 2, then the position at which 'k' is present in the array is 3 (0-indexed).

			Sample Input 1:
				4 3
				8 9 4 5

				Sample output 1:
					-1 
				Explanation of Sample Output 1:
					For the test case, 3 is not present in the array. Hence the output will be -1.
				Sample Input 2:
					4 3
					2 3 5 8
				Sample output 2:
					1
				Expected Time Complexity:
					Try to do this in O(log(n)). 
				Constraints:
					1 <= n <= 10^5
					0 <= k <= 10^9
					0 <= arr[i] <= 10^9
					Time Limit: 1 second

		int BinarySearch(vector<int> arr, int s, int e, int k){
			while(s <= e){
				int mid = (s+e)/2;
				if(arr[mid] == k)
					return mid;
				else if(arr[mid] > k)
					e = mid - 1;
				else
					s = mid+1;
			}
			return -1;
		}

		int findPivote(vector<int> a, int s, int e){
			while(s < e){
				int mid = (s+e)/2;
				if(a[mid] > a[0])
					s = mid+1;
				else
					e = mid;
			}
			return s;
		}

		int search(vector<int>& arr, int n, int k) {
			int partIndex = findPivote(arr, 0, n-1);
			if(arr[0] <= k && k <= arr[partIndex-1])
				return BinarySearch(arr, 0, partIndex-1, k);
			return BinarySearch(arr, partIndex, n-1, k);
		}
		
	391) Find First Palindromic String in the Array:
		Problem statement:
			Given an array of strings words, 
			return the first palindromic string in the array. 
			If there is no such string, return an empty string "".
			A string is palindromic if it reads the same forward and backward.

			Example 1:
				Input: words = ["abc","car","ada","racecar","cool"]
				Output: "ada"
				Explanation: The first string that is palindromic is "ada".
				Note that "racecar" is also palindromic, but it is not the first.
			
			Example 2:
				Input: words = ["notapalindrome","racecar"]
				Output: "racecar"
				Explanation: The first and only string that is palindromic is "racecar".

			Example 3:
				Input: words = ["def","ghi"]
				Output: ""
				Explanation: There are no palindromic strings, so the empty string is returned.

			Constraints:
				1 <= words.length <= 100
				1 <= words[i].length <= 100
				words[i] consists only of lowercase English letters.

		class Solution {
			public:
			Solution(){
				ios_base::sync_with_stdio(false); 
				cin.tie(NULL);
			}

			bool checkPalin(string str){
				for(int i=0; i < str.length() / 2; i++) {
					if(str[i] != str[str.length()-1-i])
						return 0;
				}
				return 1;
			}
			
			string firstPalindrome(vector<string>& words) {
				for(string s: words){
					if(checkPalin(s))
						return s;
				}
				return "";
			}
		};

	392) Kth Smallest Element:
		Problem Statement:
			You are given an array of integers 'ARR' of size 'N' and another integer 'K'.
			Your task is to find and return 'K'th smallest value present in the array.
			Note: All the elements in the array are distinct.
			Example
				If 'N' is 5 and 'K' is 3 and the array is 7, 2, 6, 1, 9
				Sorting the array we get 1, 2, 6, 7, 9
				Hence the 3rd smallest number is 6.
			Sample Input 1:
				7 5
				5 9 1 8 10 6 4 
			Sample Output 1:
				8
				Explanation of Input 1:
				Sorted array will be 1 4 5 6 8 9 10, this shows that 8 is the fifth-smallest element in the array.
				Sample Input 2:
				7 2
				24 8 23 28 3 1 19 
				Sample Output 2:
				3
				Constraints:
					1 <= N <=10 ^ 4
					1 <= K <= N
					1 <= ARR[i] <= 10 ^ 9
					Time limit: 1 sec.

		int kthSmallest(int n,int k,vector<int> Arr) {
			sort(Arr.begin(), Arr.end());
			return Arr[k-1];
		}

	393) Number of occurrence:
		Problem Statement:
			You have been given a sorted array/list of integers 'arr' of size 'n' and an integer 'x'.
			Find the total number of occurrences of 'x' in the array/list.
			Example:
				Input: 'n' = 7, 'x' = 3
				'arr' = [1, 1, 1, 2, 2, 3, 3]

			Output: 2
				Explanation: Total occurrences of '3' in the array 'arr' is 2.

			Sample Input 1:
				7 3
				1 1 1 2 2 3 3
				Sample Output 1:
				2
				Explanation For Sample Input 1:
				In the given list, there are 2 occurrences of integer 3.
				Sample Input 2:
				5 6
				1 2 4 4 5
				
				Sample Output 2:
				0

				Explanation For Sample Input 2:
					In the given list, there are 0 occurrences of integer 6.

				Expected time complexity:
					The expected time complexity is O(log 'n').

				Constraints:
					1 <= n <= 10^4
					1 <= arr[i] <= 10^9
					1 <= x <= 10^9
					Where arr[i] represents the element i-th element in the array/list.
					Time Limit: 1sec

		// Not optimized:
			#include<bits/stdc++.h>
			int count(vector<int>& arr, int n, int x) {
				map<int, int> Freq;
				for(int i: arr)
					Freq[i]++;
				return Freq[x];
			}

		// Optimized:
			#include<bits/stdc++.h>
			int firstIndex(vector<int> a, int x){
				int s=0, e= a.size()-1;
				int index = -1;
				while(s <= e){
					int mid = (s+e)/2;
					if(a[mid] == x){
						index = mid;
						e = mid-1;
					}else if(a[mid] > x){
						e = mid - 1;
					}else{
						s = mid + 1;
					}
				}
				return index;
			}

			int lastIndex(vector<int> a, int x){
				int s=0, e= a.size()-1;
				int index = -1;
				while(s <= e){
					int mid = (s+e)/2;
					if(a[mid] == x){
						s = mid + 1;
						index = mid;
					}else if(a[mid] > x){
						e = mid - 1;
					}else{
						s = mid + 1;
					}
				}
				return index;	
			}

			int count(vector<int>& arr, int n, int x) {
				//finding the first occurrence of x
				int firstOcc = firstIndex(arr, x);
				
				if(firstOcc == -1)
					return 0;

				int lastOcc = lastIndex(arr, x);
				return lastOcc - firstOcc + 1;
			}

	394) Implement Upper Bound:
		Problem Statement:
			You are given a sorted array ‘arr’ containing ‘n’ integers and an integer ‘x’.
			Implement the ‘upperBound’ function to find the index of the upper bound of 'x' in the array.
			Note:
				The upper bound in a sorted array is the index of the first value that is greater than a given value. 
				If the greater value does not exist then the answer is 'n', Where 'n' is the size of the array.
				We are using 0-based indexing.
				Try to write a solution that runs in log(n) time complexity.
			Example:
			Input : ‘arr’ = {2,4,6,7} and ‘x’ = 5,
			Output: 2
			Explanation: The upper bound of 5 is 6 in the given array, which is at index 2 (0-indexed).
			Sample Input 1:
				5 7
				1 4 7 8 10
			Sample Output 1:
				3
			Explanation of sample output 1:
				In the given test case, the lowest value greater than 7 is 8 and is present at index 3(0-indexed). 
			Sample Input 2:
				5 10
				1 2 5 6 10   
			Sample Output 2:
				5
			Sample Input 3:
				7 5
				1 5 5 7 7 9 10


			Sample Output 3:
				3
			Expected Time Complexity:
			Constraints:
				1 <= ‘n’ <= 10^5
				1 <= ‘x’ <= 10^9
				1 <= ‘arr[i]’ <= 10^9
				Time Limit: 1 sec
		
		// Not Optimized:
			int upperBound(vector<int> &arr, int x, int n){
				for(int i=0; i<n; i++){
					if(arr[i] > x)
						return i;
				}
				return n;
			}

		Try to do this in O(log(n)).
		// Not Optimized (due to function call):
			int BinarySearchUpper(vector<int> a, int x){
				int s=0, e=a.size()-1;
				int value = -1;
				while(s <= e){
					int mid = (s+e)/2;
					if(a[mid] == x){
						s = mid + 1;
					}else if (a[mid] > x){
						value = mid;
						e = mid - 1;
					}else{
						s = mid + 1;
					}
				}
				return value;
			}
			int upperBound(vector<int> &arr, int x, int n){
				return (BinarySearchUpper(arr, x) == -1) ? arr.size() : BinarySearchUpper(arr, x);	
			}

		// Optimized: (reduced function call)
			int upperBound(vector<int> &a, int x, int n){
				int s=0, e=a.size()-1;
				int value = -1;
				while(s <= e){
					int mid = (s+e)/2;
					if(a[mid] == x){
						s = mid + 1;
					}else if (a[mid] > x){
						value = mid;
						e = mid - 1;
					}else{
						s = mid + 1;
					}
				}
				return (value == -1) ? a.size() : value;
			}

	395) Implement Lower Bound:
		Problem Statement:
			You are given an array 'arr' sorted in non-decreasing order and a number 'x'.
			You must return the index of lower bound of 'x'.
			Note:
			For a sorted array 'arr', 
			'lower_bound' of a number 'x' is defined as the smallest 
			index 'idx' such that the value 'arr[idx]' is not less than 'x'

			If all numbers are smaller than 'x', then 'n' should be the 
			'lower_bound' of 'x', where 'n' is the size of array.
			Consider 0-based indexing.
			Example:
			Input: ‘arr’ = [1, 2, 2, 3] and 'x' = 0
			Output: 0
			Explanation: Index '0' is the smallest index such that 'arr[0]' is not less than 'x'.

			Sample Input 1:
				6
				1 2 2 3 3 5
				0
			Sample Output 1:
				0
			Explanation Of Sample Input 1 :
			Index '0' is the smallest index such that 'arr[0]' is not less than 'x'.
			Sample Input 2:
				6
				1 2 2 3 3 5
				2


				Sample Output 2:
				1


				Sample Input 3:
				6
				1 2 2 3 3 5
				7


				Sample Output 3:
				6
			Expected Time Complexity:
			Constraints:
				1 <= ‘n’ <= 10^5
				0 <= ‘arr[i]’ <= 10^5
				1 <= ‘x’ <= 10^5

		// Optimized:
			int lowerBound(vector<int> arr, int n, int x) {
				int value = 0;
				for(int i=0; i<arr.size(); i++){
					if(arr[i] == x)
						return i;
					else if(arr[i] > x)
						return i;
					else
						value = i;	
				}

				if(value == arr.size()-1)
					return arr.size();
			}

			//or
				int lowerBound(vector<int> arr, int n, int x) {
					int value = 0;
					for(int i=0; i<arr.size(); i++){
						if(arr[i] == x)
							return i;
						else if(arr[i] > x)
							return i;
						else
							value = i;	
					}
					return value+1;
				}

		Try to do this in O(log(n)), using binary search
		// Optimized:
			int BinarySearchLower(vector<int> a, int x){
				int value = -1;
				int s=0, e=a.size()-1;

				while(s <= e){
					int mid = (s+e)/2;
					if(a[mid] == x){
						e = mid - 1;
						value = mid;
					}else if (a[mid] > x){
						value = mid;
						e = mid - 1;
					}else{
						s = mid +1;
					}
				}
				return value;
			}

			int lowerBound(vector<int> arr, int n, int x) {
				return (BinarySearchLower(arr, x) == -1) ? arr.size() : BinarySearchLower(arr, x);
			}

	396) Rearrange Array Elements by Sign:
		Problem Statement:
			You are given a 0-indexed integer array nums of even length 
			consisting of an equal number of positive and negative integers.
			You should rearrange the elements of nums such that the modified array follows the given conditions:

			Every consecutive pair of integers have opposite signs.
			For all integers with the same sign, the order in which they were present in nums is preserved.
			The rearranged array begins with a positive integer.
			Return the modified array after rearranging the elements to satisfy the aforementioned conditions.

			

			Example 1:
				Input: nums = [3,1,-2,-5,2,-4]
				Output: [3,-2,1,-5,2,-4]
				Explanation:
				The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
				The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
				Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  

			Example 2:
				Input: nums = [-1,1]
				Output: [1,-1]
				Explanation:
				1 is the only positive integer and -1 the only negative integer in nums.
				So nums is rearranged to [1,-1].
				
			Constraints:
				2 <= nums.length <= 2 * 10^5
				nums.length is even
				1 <= |nums[i]| <= 10^5
				nums consists of equal number of positive and negative integers.
		
		class Solution {
			public:
			vector<int> rearrangeArray(vector<int>& nums) {
				ios_base::sync_with_stdio(false); cin.tie(NULL);
				vector<int> modifiedAns, posNums, negNums;

				for(int i=0; i<nums.size(); i++)
					if(nums[i] < 0)
						negNums.push_back(nums[i]);
					else
						posNums.push_back(nums[i]);

				int pointer=1;
				for(int i=0; i<posNums.size();){
					if(pointer & 1)
						modifiedAns.push_back(posNums[i]);
					else
						modifiedAns.push_back(negNums[i++]);
					pointer++;
				}
				return modifiedAns;
			}
		};

	397) Check whether K-th bit is set or not (1-based indexing):
		Problem Statement:
			Given a number ‘N’ and a number ‘K’. 
			Return true if ‘K’th bit of number is set, else return false.
			Example:
				Input: ‘N’ = 5, ‘K’ = 1
				Output: YES
				5 in binary can be written as 101 and as we can see a 
				first bit from the right of 5 is set so the answer is 'YES'.

			Sample Input 1 :
				3 2
				Sample Output 1 :
				YES
				Explanation Of Sample Input 1 :
				3 in binary can be represented as 11 and 2 bit from right is set there, So answer is 'YES'.
				Sample Input 2 :
				128 7
				Sample Output 2 :
				NO
				Constraints :
				1 <= N <= 10^9
				1 <= K <= 20
			Time Limit: 1 sec

		bool isKthBitSet(int n, int k) {
			string s = bitset<32>(n).to_string();
			int i;		
			for(i=s.length()-1; (k-1)>0; k--, i--);
			
			//or instead of above loop you can use below commented lines
			/*
				for(i=s.length()-1; (k-1)>0; k--, i--){

				}
			*/
			if(s[i] == '1')
				return 1;
			return 0;
		}

		bool isKthBitSet(int n, int k) {
			while((k-1) > 0){
				n >>= 1;
				k--;
			}
			return (n&1) ? 1 : 0;
		}

		//or more concise:
		-creating a mask till (k-1)th index, & checking if the kth index is 1 or 0, if 1 then returing true else false.
		bool isKthBitSet(int n, int k) {
			return (n & (1 << (k-1))) ? 1 : false;
			// return (n & (1 << (k-1))) ? 1 : 0;

		}

	398) K largest elements:
		Problem Statement:
			-Simply the problem is meant to say, print the larger (top) k element in ascending order
			You are given with an integer k and an array of integers that contain numbers in random order. 
			You have to find k largest numbers from given array. You need to save them in an array and return it.
			Note:
				1. Time complexity should be O(n * logk) and space complexity should not be more than O(k).
				2. Order of elements in the output is not important.
			Constraints:
				1 ≤ k ≤ n ≤ 10^5
				1 ≤ arr[i] ≤ 10^6
			Sample Input 1:
				13
				2 12 9 16 10 5 3 20 25 11 1 8 6 
				4
				Sample Output 1:
				12 16 20 25

		#include<bits/stdc++.h>
		vector<int> kLargest(int arr[], int n, int k) {
			sort(arr, arr+n);
			stack<int> st;
			
			int pointer = n-1;
			while(k--)
				st.push(arr[pointer--]);

			vector<int> ans;
			while(!st.empty()){
				ans.push_back(st.top());
				st.pop();
			}
			return ans;
		}

	399) Largest Number:
		Problem Statement:
			-Problem meant to say, find the highest num in array whose opposite is also present
			You are given an array arr consisting of ‘N’ integers. 
			Your task is to find the largest number, ‘K’, 
			such that both the values ‘K’ and -‘K’ are present in the given array 'arr'. 
			If no such number exists, then return '-1'.
			For example:
				Consider ‘arr’ = [1,2,-2,-1], the largest value of ‘K’ is 2, 
				since a negative of 2 is also present in the array.
				Hence, the answer is 2.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^6   
				1 <= arr[i] <= 10^9

				Time limit: 1 sec
			Sample Input 1 :
				2
				5
				3 2 -2 5 -3
				4
				1 2 3 -4
				Sample Output 1 :
				3
				-1     
				Explanation For Sample Output 1 :
				For test case 1 :
				We can take 2 since its negative is present in the array, 
				but the largest number is 3, whose negative is present. 
				Hence, the answer is 3.

				For test case 2 :
				We cannot take any number as there does not exist any number following the given condition. 
				Hence, the answer is -1.
				Sample Input 2 :
				2
				6
				1 2 3 5 3 -1
				6
				1 1 -2 2 -1 1
				Sample Output 2 :
				1
				-2
		
		int largestNumber(vector<int> &arr,int n) {
			// sorted in descending order
			sort(arr.begin(), arr.end(), greater<int> ());

			for(int i=0; i<n; i++)
				if(arr[i] > 0 && find(arr.begin(), arr.end(), (-arr[i])) != arr.end())
					return arr[i];

			return -1;
		}

	400) K Largest Elements ( K Largest Element ):
		Problem Statement:
			You are given an unsorted array containing ‘N’ integers. 
			You need to find ‘K’ largest elements from the given array. 
			Also, you need to return the elements in non-decreasing order.
			Constraints:
				1 <= T <= 100
				1 <= N <= 10^4  
				1<= K <= N  
				-10^9 <= ARR[i] <= 10^9
			Where ‘T’ is the number of test cases, 
			‘N’ is the size of the array, ‘K’ is the number 
			of elements you need to return as an answer and 
			ARR[i] is the size of the array of elements.

			Time Limit: 1 sec
			Sample Input 1:
				2
				4 2
				3 4 2 1
				5 1
				2 2 3 3 1
				Sample Output 1:
				3 4
				3
				Explanation for sample input 1:
				Test case 1:
				If we sort the array then it will look like: [1, 2, 3, 4]. The 2 largest elements will be [3, 4].

				Test case 2:
				If we sort the array then it will look like: [1, 2, 2, 3, 3]. Then the largest element will be [3].
				Sample Input 2:
				2
				5 5
				0 10 1 2 2
				6 2
				-2 12 -1 1 20 1 
				Sample Output 2:
				0 1 2 2 10
				12 20

		#include <bits/stdc++.h> 
		vector<int> Klargest(vector<int> &a, int k, int n) {
			sort(a.begin(), a.end(), greater<int>());

			vector<int> ans;
			while(k)
				ans.push_back(a[--k]);
			return ans;
		}
	
	401) Kth largest element in the unsorted array:
		Problem statement:
			You are given an array consisting of 'N' distinct positive integers and a number 'K'.
			Your task is to find the kth largest element in the array.

			Example:
				Consider the array {2,1,5,6,3,8} and 'K' = 3, 
				the sorted array will be {8, 6, 5, 3, 2, 1}, 
				and the 3rd largest element will be 5.
			Note:
				1) Kth largest element in an array is the kth element of the array when sorted in non-increasing order. 
				2) All the elements of the array are pairwise distinct.
			Constraints:
				1 <= T <= 100
				1 <= N <= 10^4
				1 <= ARR[i] <= 10^9
				1 <= K <= N

				Time Limit: 1 sec
			Sample Input 1:
				1
				3 1
				1 2 3
				Sample Output 1:
				3
				Explanation for sample input 1:
				3 is the first largest element in the array {1,2,3}.
				Sample Input 2:
				1
				4 2
				5 6 7 8
				Sample Output 2:
				7
				Explanation for sample input 2:
				7 is the second largest element in the array {5,6,7,8}.

		#include <bits/stdc++.h> 
		int kthLargest(vector<int>& arr, int size, int K) {
			// to sort in descending order
			sort(arr.begin(), arr.end(), greater<int>());
			return arr[K-1];	
		}
	
	402) K Most Frequent Elements:
		Problem statement:
			You are given an Integer array ‘ARR’ and an Integer ‘K’.
			Your task is to find the ‘K’ most frequent elements in ‘ARR’. 
			Return the elements in any order.

			For Example:
			You are given ‘ARR’ = {1, 2, 2, 3, 3} and ‘K’ = 2. 
			The answer will {2, 3} as 2 and 3 are the elements occurring most times.

			Sample Input 1:
				5 2
				1 2 2 3 3 
				Sample Output 1:
				2 3
				Explanation of Sample Input 1:
				The answer will {2, 3} as 2 and 3 are the elements occurring the most number of times.
				Sample Input 2:
				2 2
				1 2 
				Sample Output 2:
				1 2
			Constraints:
				1 <= 'N' <= 10^5
				1 <= 'K' <= Number of unique elements in ‘ARR’
				1 <= 'ARR[i]' <= 10^6
				Time Limit: 1 sec
			
		bool cmpValues(pair<int, int> a, pair<int , int> b){
			// if values are same then sort based on keys in ascending order
			// but this is not necessary to sort based on keys if values are same
			// you can comment the below if condition
			if(a.second == b.second)
				return a.first < b.first;
			return a.second > b.second;
		}

		vector<int> KMostFrequent(int n, int k, vector<int> &arr) {
			map<int, int> Freq;
			for(int i: arr)
				Freq[i]++;
			
			vector<pair<int, int>> holder;
			//for(auto i: Freq)
			//	holder.push_back({i.first, i.second});
			
			//or
			// /*
				for(auto i: Freq)
					holder.push_back(i);
			// */
			
			// sorting vector holder
			// sort by values in descending order
			sort(holder.begin(), holder.end(), cmpValues);

			vector<int> ans;
			while(k)
				ans.push_back(holder[--k].first);

			return ans;
		}
	
	403) K Most Frequent Words:
		Problem statement:
			You have been given an array/list 'WORDS' of 'N' non-empty words, and an integer 'K'. 
			Your task is to return the 'K' most frequent words sorted by their frequency from highest to lowest.
			Note:
				If two words have the same frequency then the lexicographically smallest word should come first in your answer.
			Follow up:
				Can you solve it in O(N * logK) time and O(N) extra space? 
			Constraints:
				1 <= N <= 10^5
				1 <= K <= number of unique words

				Time Limit: 1sec
			Sample Input 1:
				6 2
				i love codingninjas i love coding
			Sample Output 1:
				i love
				Sample Input 2:
				8 3
				the sky is blue the weather is hot
				Sample Output 2:
				is the blue
				Explanation for Sample Input 2:
				“is” and “the” are words with a frequency of 2.
				“sky”, “blue”, “weather”, and “hot” are the words with a frequency of 1.

				The words with a frequency of 2 are the most frequent words and 
				the lexicographically smallest word from the words with a frequency of 1 is “blue”.
			
		#include <bits/stdc++.h>
		bool cmpValues(pair<string, int> a, pair<string, int> b){
			if(a.second == b.second)
				return a.first < b.first;
			return a.second > b.second;
		}

		vector<string> kMostFreqWords(string words[], int n, int k){
			// count the Frequency of strings
			map<string, int> Freq;

			for(int i=0; i<n; i++)
				Freq[words[i]]++;

			// store map in vector & sort it
			vector<pair<string, int>> holder;
			for(auto i: Freq)
				holder.push_back(i);

			sort(holder.begin(), holder.end(), cmpValues);

			vector<string> ans;
			// int index = k;
			// while(k)
			//     ans.push_back(holder[index - k--].first);

			// or for above 3 lines easy way
			int index=0;
			while(k--)
				ans.push_back(holder[index++].first);

			return ans;
		}

	404) Tarun and Kids:
		Problem statement:
			Tarun is planning to buy two balls from a shop for his children, Om and Utkarsh.
			The happiness of each child is directly proportional to the size of the ball they receive. 
			However, if one child receives a larger ball than the other, they will become upset.
			
			Tarun’s goal is to maximize the happiness of both children. 
			If it’s possible to find two balls of equal size, 
			return the maximum size of the balls. 
			If it’s impossible to find two balls of equal size, return -1.

			For Example:
				Balls : [3, 4, 5, 2, 1, 4, 2]
				Tarun can give each child a ball of size 2, and both will be happy. 
				However, if he gives both of them balls of size 4, they will be happier
				Tarun can’t use the ball of size 5 as the other child will become upset as they will receive a smaller ball.

				Hence the maximum size of ball he can give is 4.
			Sample Input 1:
				2
				6
				23 74 82 24 74 74 
				10
				38 53 49 33 36 84 18 68 57 61 
				Sample Output 1:
				74
				-1
				Explanation of sample output 1:
				For Test Case 1:
				Tarun has only one option to give both kids the same size balls which is 74. 
				Hence, the answer is 74.

				For Test Case 2:
				There are no two balls of the same size.
				Hence it is impossible to make them both happy and the answer is -1.
				Sample Input 2:
				3
				6
				84 84 50 84 50 84 
				7
				26 89 26 89 70 26 26 
				7
				20 32 93 13 1 81 79 
				Sample Output 2:
				84
				89
				-1
			Constraints:
				1 <= ‘T’ <= 10 denotes no of testcases
				1 <= ‘N’ <= 100 denotes no of balls
				1 <= ‘balls[i]' <= 10^9  denotes size of each ball

		int happyKids(vector<int> &balls) {
			sort(balls.begin(), balls.end(), greater<int>());

			// hashmap
			map<int, int> Freq;
			for(int o: balls)
				Freq[o]++;

			for(int i=0; i<balls.size(); i++)
				if(Freq[balls[i]] >= 2)
					return balls[i];
					
			return -1;
		}

		// More Optimized:
			int happyKids(vector<int> &balls) {
				sort(balls.begin(), balls.end());
				for(int i=balls.size()-1; i>0; i--){
					if(balls[i] == balls[i-1])
						return balls[i];
				}
				return -1;
			}
	
	405) Power of Two: (same Question as 44)
		Problem statement:
			You have been given an integer 'N'.
			Your task is to return true if it is a power of two. Otherwise, return false.
			An integer 'N' is a power of two, if it can be expressed as 2 ^ 'K' where 'K' is an integer.
			For example:
				'N' = 4,
				4 can be represented as 2^2. So, 4 is the power of two, and hence true is our answer.
			Sample Input 1:
				16
				Sample Output 1:
				true
				Explanation of Sample Input 1:
				16 can be represented as 2^4. So, 16 is the power of two, and hence true is our answer.
				Sample Input 2:
				10
				Sample Output 2:
				false
			Constraints:
				-2^31 <= 'N' <= 2^31 - 1
				Time Limit: 1sec

		bool isPowerOfTwo(int n) {
			while(n>=2){
				if(n % 2 != 0)
					break;
				n /= 2;
			}

			if(n==1)
				return true;
			return 0;
		}

		//or
			#include <bits/stdc++.h>
			bool isPowerOfTwo(int n) {	
				// Write your code here.
				bool b = false;
				for(int i=0; i<n; i++){
					int temp = pow(2,i);
					if(temp == n){
						b = true;
						break;
					}

					if(temp > n){
						b = false;
						break;
					}
				}
				return b;
			}

		//or
			Bit Manipulation
				The basic idea is to use Bit Manipulation. 
				If we subtract a power of 2 numbers by 1 then all unset bits after the only set bit become set; 
				and the set bit becomes unset.
				For example for 4 (100) and 16 (10000), 
				we get the following after subtracting 1
				3 -> 011
				15 -> 01111
				So, if a number ‘N’ is power of 2 then bitwise & of ‘N’ and ‘N’-1 will be zero.
				 We can say ‘N’ is a power of 2 or not based on the value of ‘N’&('N'-1). 
				 The expression ‘N’&('N'-1) will not work when ‘N’ is 0. To handle this case also, 
				 our expression will become ‘N’&(!'N'&('N'-1)).

				Time Complexity
					O(1).

				Since, bitwise & of two integers takes constant time, thus, the time complexity will be O(1).
				Space Complexity
					O(1).
				Since no extra memory is used except some variables, thus, the space complexity will be O(1).
			
			#include <bits/stdc++.h>
			bool isPowerOfTwo(int n){
				return n != 0 && ((n & (n-1)) == 0);
			}
	
	406) Count Palindrome Words In A String:
		Problem statement:
			You are given a string S of words. 
			Your task is to find the number of palindrome words in the given string S.
			A word is called palindrome, if it reads the same backwards as forwards.
			Note:
				Words are separated by one or more whitespace characters.
			For Example:
				For the given string “Madam oyo cat”, “Madam”, and “oyo” are the palindrome words 
			Constraints:
				1 <= T <= 10 
				0 <= |S| <= 10^5 
				All the characters of the string S contain whitespace, lowercase, and uppercase English letters only.
				Time limit: 1 second
			Sample Input 1:
				1
				Nitin and I are good friends
				Sample Output 1:
				2
				Explanation For Sample Input 1:
				For the first test case, there are 2 palindrome words only i.e “Nitin” and “I”.
				Sample Input 2:
				2
				Madam taught us the level order traversal of a binary tree yesterday
				We love coding ninjas
				Sample output 2:
				3
				0
		
		#include <bits/stdc++.h> 
		bool checkPalin(string s){
			for(int i=0; i<s.length()/2; i++)
				if(s[i] != s[s.length()-1-i])
					return 0;
			return true;
		}

		int countNumberOfPalindromeWords(string s) {
			vector<string> holder;
			string temp;

			// transforming the string 
			transform(s.begin(), s.end(), s.begin(), ::tolower);

			for(int i=0; i<s.length(); i++){
				if(s[i] == ' '){
					if(!temp.empty())
						holder.push_back(temp);
					temp.clear();
					continue;
				}
				temp += s[i];
			}

			// need to insert the last string manually
			if(!temp.empty())
				holder.push_back(temp);

			int cnt=0;
			for(int i=0; i<holder.size(); i++)
				if(checkPalin(holder[i]))
					cnt++;
				
			return cnt;
		}

		// or
			#include <bits/stdc++.h> 
			bool isPalindrome(string s){
				int i=0, j=s.size()-1;

				if(s.empty())				// this handles the multiple/extra spaces between the words of string
					return 0;

				while(i < j)
					if(s[i++] != s[j--])
						return 0;
				return 1;
			}

			int countNumberOfPalindromeWords(string s) {
				vector<string> v;
				transform(s.begin(), s.end(), s.begin(), ::tolower);				// this is for converting the whole string into lowercase

				if(s.empty())
					return 0;

				string temp;
				for(char ch: s){
					if(ch == ' '){
						v.push_back(temp);
						temp.clear();
					}else{
						temp += ch;
					}
				}

				// last word manual insertion
				v.push_back(temp);
				
				int cnt=0;
				for(string s: v){
					// cout<<s<<endl;
					if(isPalindrome(s))
						cnt++;
				}
				return cnt;
			}

		// or using istringstream:
			#include <bits/stdc++.h> 
			bool isPalindrome(string s){
				int i=0, j=s.size()-1;
				while(i < j)
					if(s[i++] != s[j--])
						return 0;
				return 1;
			}

			int countNumberOfPalindromeWords(string s) {
				vector<string> v;
				transform(s.begin(), s.end(), s.begin(), ::tolower);				// this is for converting the whole string into lowercase

				// this lines of code is to extract the words from string
				string test;
				istringstream iss(s);
				while(iss >> test)
					v.push_back(test);
				
				// this is for counting the palindrome stirngs
				int cnt=0;
				for(string s: v){
					// cout<<s<<endl;
					if(isPalindrome(s))
						cnt++;
				}
				return cnt;
			}
	
	407) Least Number of Unique Integers after K Removals:
		Problem statement:
			Given an array of integers arr and an integer k.
			Find the least number of unique integers after removing exactly k elements.

			Example 1:
				Input: arr = [5,5,4], k = 1
				Output: 1
				Explanation: Remove the single 4, only 5 is left.
				
			Example 2:
				Input: arr = [4,3,1,1,3,3,2], k = 3
				Output: 2
				Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.
			
			Constraints:
				1 <= arr.length <= 10^5
				1 <= arr[i] <= 10^9
				0 <= k <= arr.length

		NOTE: we used inline keyword before name of function cmpValuesASC.
			This can potentially improve performance by reducing function call overhead.
		class Solution {
			public:
			inline static bool cmpValuesASC(pair<int, int> a, pair<int, int> b){
				return a.second < b.second;
			}

			int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
				// counting the occurrences
				map<int, int> Freq;
				for(int i: arr)
					Freq[i]++;
				
				// storing the Freq map into the vector to sort by values in ascending order
				vector<pair<int, int>> holder;
				for(auto i: Freq)
					holder.push_back(i);

				// sorting
				sort(holder.begin(), holder.end(), cmpValuesASC);

				for(int i=0; i<holder.size() && k > 0;){
					if(holder[i].second == 0)
						i++;

					// holder[i].second = holder[i].second - 1;				
					//or
					holder[i].second--;
					k--;
				}

				vector<int> tempAns;
				for(int i=0; i<holder.size(); i++)
					if(holder[i].second != 0)
						tempAns.push_back(holder[i].first);

				set<int> ans(tempAns.begin(), tempAns.end());
				return ans.size();
			}
		};
	
	408) Arrange the numbers:
		Problem statement:
			You are given an '0' indexed array 'A' of 'N' integers containing positive and negative integers.
			You want the sum of some subarray of the array 'A' to be maximum. For that, 
			you can rearrange the elements of the array. 
			Note that an empty subarray is considered to be a subarray with sum equal to '0'.
			Return the maximum possible subarray sum after rearranging the elements of the array 'A'.

			Example:
				N = 5
				A = [1, -5, 1, 1, -4]
				We can rearrange the elements as follows: ['1', '1', '1', '-4', '-5'].
				The maximum subarray sum is '3' for the subarray of the first three elements.
				It can be proved that we can not get the subarray sum greater than '3'.
				So the answer for this case is '3'.
			Constraints:
				1 <= 'N' <= 10^5
				-10^3 <= 'A[i]' <= 10^3

				Time limit: 1 sec
			Sample input 1:
				2
				3
				1 2 3
				5
				2 -2 2 -3 -3
				Sample output 1:
				6
				4
				Explanation of sample input 1:
				For test case 1:
				The maximum subarray sum is '1 + 2 + 3' = '6'.
				So the answer for this case is '6'. 

				For test case 2:
				We can rearrange the elements as follows: ['-2', '2', '2', '-3', '-3'].
				The maximum subarray sum is '4' for the subarray consisting of the second and third elements.
				It can be proved that we can not get the subarray sum greater than '4'.
				So the answer for this case is '4'.    
				Sample input 2:
				2
				5
				1 0 -1 0 1
				3
				-1 -2 -3
				Sample output 2:
				2
				0

		int maximumSubarraySum(int n, vector<int> &v) {
			int mxSum, sum;
			mxSum = sum = 0;
			for(int i: v)
				if(i > 0)
					sum += i;

			mxSum = max(mxSum, sum);
			return mxSum;
		}
	
	409 Diagonal Sum:
		Problem statement:
			You are given a square matrix of size ‘N * N’, 
			where each cell contains a distinct integer from ‘1’ to ‘N * N’.
			The matrix is sorted diagonally from bottom left to top right.
			For example, a ‘3 * 3’ matrix looks like:
				[1, 3, 6]
				[2, 5, 8]
				[4, 7, 9]
			The diagonals in the matrix are numbered from ‘1’ to ‘2 * N - 1’. Let’s see the scenario for this case:
				- Diagonal ‘1’ looks like: [1]
				- Diagonal ‘2’ looks like: [2, 3]
				- Diagonal ‘3’ looks like: [4, 5, 6]
				- Diagonal ‘4’ looks like: [7, 8]
				- Diagonal ‘5’ looks like: [9]

			You will be given an integer ‘D’, denoting the diagonal number. 
			You have to find the sum of all the numbers present in that diagonal.

			Your task is to tell the sum of all the numbers present in the diagonal ‘D’ and return it.

			Example:
				‘N’ = 4
				‘D’ = 3
				Here, the matrix looks like: 
				[1, 3, 6, 10]
				[2, 5, 9, 13]
				[4, 8, 12,15]
				[7, 11, 14, 16]

				The Diagonal ‘3’ looks like: [4, 5, 6]. 
				The sum of all these numbers is ‘15’.
			Constraints:
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^5
				1 <= ‘D’ <= ‘2 * N - 1’

				Time Limit: 1 sec
			Sample Input 1:
				2
				3 3
				2 2
				Sample Output 1:
				15
				5
				Explanation of sample input 1:
				For test case 1:
				Here, you can represent the ‘3 * 3’ matrix as:
				[1, 3, 6]
				[2, 5, 8]
				[4, 7, 9]

				The diagonal ‘3’ looks like: [4, 5, 6].
				The sum of these numbers is ‘15’.

				For test case 2:
				Here, you can represent the ‘2 * 2’ matrix as:
				[1, 3]
				[2, 4]

				The diagonal ‘2’ looks like: [2, 3]
				The sum of these numbers is ‘5’.
				Sample Input 2:
				2
				4 4 
				2 1
				Sample Output 2:
				34
				1

		// Not Optimized:
			long long diagonalSum (int n, int d) {
				int cnt=1,row,col;
				row=col=0;

				vector<vector<int>> holder(n, vector<int>(n));
				int rowTracker=0, colTracker=1;

				// pattern creation
				for(int i=0; i<(2*n-1); i++){ 
					while(row >=0 && col < n)
						holder[row--][col++] = cnt++;

					++rowTracker;
					if(rowTracker < n)
						col=0, row = rowTracker;
					else
						row = n-1, col = colTracker++;
				}

				// calculating sum
				// diagonal starting index
				long long D_Sum=0;
				if(d <= n)
					row = d-1, col=0;
				else
					row = n-1, col= d - n;
					
				while(row >=0 && col < n)
					D_Sum += holder[row--][col++];
					
				return D_Sum;
			}

		// Optimized:
			/*
				Time complexity: O( D )
				Space complexity: O( 1 )
				
				Where 'D' is the diagonal number.
			*/

			long long diagonalSum (int n, int d) {
				long long x = 0, y = 0, ans = 0;
				for (int i = 1; i <= d; i ++) {
					long long start = 0, end = 0;
					
					// Current diagonal has one more element than the previous diagonal.
					if (i <= n) {
						start = x + 1;
						end = x + y + 1;
						x += y + 1;
						y += 1;
					}

					// Current diagonal has one element less than the previous diagonal.
					else {
						start = x + 1;
						end = x + y - 1;
						x += y - 1;
						y -= 1;
					}

					// Find the sum of elements between 'start' and 'end'.
					if (i == d) {
						ans = (end * (end + 1LL) / 2LL) - (start * (start - 1LL) / 2LL);
					}
				}
				return ans;
			}
	
	Lecture-23 Q no. 2
		410) Zero Matrix:
			https://www.codingninjas.com/studio/problems/zero-matrix_1171153
			Problem statement:
				You are given a matrix 'MATRIX' of dimension 'N' x 'M'. 
				Your task is to make all the elements of row 'i' and column 'j' equal to 0 
				if any element in the ith row or jth column of the matrix is 0.
				Note:
					1) The number of rows should be at least 1.
					2) The number of columns should be at least 1.
					3) For example, refer to the below matrix illustration: 

				Constraints:
					1 <= N <= 100
					1 <= M <= 100
					-10^9 <= MATRIX[i][j] <= 10^9

					Where 'MATRIX[i][j]' denotes the matrix element.
				Follow Up:
					Can you solve it with the space complexity of O(1)?
					Time limit: 1 sec

			#include <bits/stdc++.h> 
			vector<vector<int>> zeroMatrix(vector<vector<int>> &matrix, int n, int m) {
				// vector<vector<int>> v (n, vector<int>(m));
				
				//or mentioned the default value -1, both will work.
				vector<vector<int>> v (n, vector<int>(m, -1));

				v = matrix;
				for(int i=0;i<n; i++){
					for(int j=0;j<m;j++){
						if(matrix[i][j] == 0){
							// for complete row making zero
							for(int a=0; a<n; a++)
								v[a][j] = 0;

							// for complete col making zero
							for(int b=0; b<m; b++)
								v[i][b] = 0;
						}
					}
				}
				return v;
			}

			//or
			/*
				Time Complexity: O(N * M)
				Space Complexity: O(1)

				Where 'N' is the number of rows ans 'M' is the number of columns.
			*/

			vector<vector<int>> zeroMatrix(vector<vector<int>> &matrix, int n, int m){
				// Bool variable isColZero will tell us the same for the entire 1st column.
				bool isColZero = false;
				for (int i = 0; i < n; i++){
					/*
					If MATRIX[0][i] is 0, then isColZero = true. Because we have found a 0 in,
					the 1st column so we have to set the entire 1st column to be 0.
					*/
					if (matrix[i][0] == 0){
						isColZero = true;
					}
					for (int j = 1; j < m; j++){
						if (matrix[i][j] == 0){
							// We have to set that entire row to be 0.
							matrix[i][0] = 0;
							// We have to set that entire column to be 0.
							matrix[0][j] = 0;
						}
					}
				}
				for (int i = 1; i < n; i++){
					for (int j = 1; j < m; j++){
						/*
						If starting cell of row or starting cell of column is zero,
						then set entry at i,j to 0.
						*/
						if (!matrix[i][0] || matrix[0][j] == 0){
							matrix[i][j] = 0;
						}
					}
				}
				// If MATRIX[0][0] is 0, then we have to set the entire 1st row to be 0.
				if (matrix[0][0] == 0){
					for (int j = 0; j < m; j++){
						matrix[0][j] = 0;
					}
				}
				// If isColZero is true, then we have to set the entire 1st column to be 0.
				if (isColZero){
					for (int i = 0; i < n; i++){
						matrix[i][0] = 0;
					}
				}
				return matrix;
			}

		411) Set Matrix Zeroes:
			https://leetcode.com/problems/set-matrix-zeroes/description/
			Problem statement:
				Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
				You must do it in place.
				Example 1:
					Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
					Output: [[1,0,1],[0,0,0],[1,0,1]]
				Example 2:
					Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
					Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]

				Constraints:
					m == matrix.length
					n == matrix[0].length
					1 <= m, n <= 200
					-2^31 <= matrix[i][j] <= 2^31 - 1	

				Follow up:
					A straightforward solution using O(mn) space is probably a bad idea.
					A simple improvement uses O(m + n) space, but still not the best solution.
					Could you devise a constant space solution?
			
			class Solution {
				public:
				void setZeroes(vector<vector<int>>& matrix) {
					int n = matrix.size();
					int m = matrix[0].size();
					vector<vector<int>> visited = matrix;
					for(int i=0; i<n; i++){
						for(int j=0; j<m; j++){
							if(matrix[i][j] == 0){
								for(int k=0; k<m; k++){
								visited[i][k] = 0;
								}
								for(int k=0; k<n; k++){
								visited[k][j] = 0;
								}
							}
						}
					}
					matrix = visited;
				}
			};

	Lecture-37:
		412) Subsequences of String:
			Problem statement:
				You are given a string 'STR' containing lowercase English letters from a to z inclusive. 
				Your task is to find all non-empty possible subsequences of 'STR'.
				A Subsequence of a string is the one which is generated by 
				deleting 0 or more letters from the string and 
				keeping the rest of the letters in the same order.
				Constraints:
					1 <= T <= 10 
					1 <=  |STR| <= 16

					Where |STR| represents the length of the string 'STR'.
					Time Limit: 1 sec
				Sample Input 1:
					1 
					abc
					Sample Output 1:
					a ab abc ac b bc c
					Explanation of sample input 1:
					All possible subsequences of abc are :  
					“a” , “b” , “c” , “ab” , “bc” , “ac”, “abc”
					Sample Input 2:
					1
					bbb
					Sample Output 2:
					b b b bb bb bb bbb

			#include <bits/stdc++.h>
			void SubSeqGen(string s, string t, int i, vector<string> &ans){
				if(i == s.length()){
					if(t.length() != 0)
						ans.push_back(t);
					return ;
				}
				
				// exclude call
				SubSeqGen(s, t, i+1, ans);

				// include call
				t.push_back(s[i]);
				SubSeqGen(s, t, i+1, ans);
			}

			vector<string> subsequences(string str){
				vector<string> ans;
				string tempHolder;
				SubSeqGen(str, tempHolder, 0, ans);
				// ans.erase(ans.begin());					if t.length() != 0 is not present in SubSeqGen function then this erase line is required
				return ans;
			}
	
		413) Subsets:
			Problem statement:
				Given an integer array nums of unique elements, return all possible 
				subsets (the power set).
				The solution set must not contain duplicate subsets. 
				Return the solution in any order.
				Example 1:
					Input: nums = [1,2,3]
					Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

				Example 2:
					Input: nums = [0]
					Output: [[],[0]]

				Constraints:
					1 <= nums.length <= 10
					-10 <= nums[i] <= 10
					All the numbers of nums are unique.
			
			class Solution {
				public:
				void finder(vector<int> n, vector<int> output, int indx, vector<vector<int>> &ans){
					if(indx == n.size()){
						ans.push_back(output);
						return ;
					}
					
					// exclude case
					finder(n, output, indx+1, ans);

					int ele = n[indx];
					output.push_back(ele);
					finder(n, output, indx+1, ans);
				}
				vector<vector<int>> subsets(vector<int>& nums) {
					vector<vector<int>> ans;
					vector<int> output;
					int index=0;
					finder(nums, output, index, ans);
					return ans;
				}
			};

	414) Flip Bits:
		Problem statement
			You are given two integers 'A' and 'B'.
			Your objective is to determine the number of bit positions where the corresponding bits of ‘A’ and ‘B’ differ, 
			i.e., the number of bits that need to be flipped in ‘A’ to obtain ‘B’.
			Example:
				A = 7
				B = 12
				Output : 3

				A = 0111
				B = 1100
				We need to flip the 1st, 2nd, and 4th bit of ‘A’ from the LSB to get ‘B’
			Sample Input 1:
				11 18
				Sample Output 1:
				3
				Explanation Of Sample Input 1:
				A = 10010
				B = 01011
				We need to flip the 1st, 4th and 5th bit of ‘A’ from the LSB to get ‘B’.
				Sample Input 2:
				13 9
				Sample Output 2:
				1
				Explanation Of Sample Input 2:
				A = 1101
				B = 1001
				We need to flip the 3rd bit of ‘A’ from the LSB to get ‘B’.
				Constraints:
				1 <= A, B <= 10^6
				Time Limit: 1 sec

		int flipBits(int A, int B){
			string s1,s2;
			s1 = bitset<32>(A).to_string();
			s2 = bitset<32>(B).to_string();
			int cnt=0;
			for(int i=0; i<32; i++)
				if(s1[i] != s2[i])
					cnt++;
			return cnt;
		}	

		//or
			int flipBits(int A, int B) {
				int cnt=0;
				while(A !=0 or B!=0) {
					if((A&1) != (B&1))
						cnt++;
					
					A >>=1;
					B >>=1;
				}
				return cnt;
			}
	
	415) Count Subarrays With K Ones:
		https://www.codingninjas.com/studio/problems/count-substrings-with-k-ones_3128698
		Problem statement
			You are given a binary array 'arr' of length 'N' and an integer 'k'. 
			Return the number of subarrays having the count of 1's equal to ‘k’.

			Example :
				Let the array 'arr' be: [1, 0, 1].
				Let ‘k’ be: 1

				Then the subarrays having the number of ones equal to ‘k’ will be: [1], [1,0], [0,1], [1].
			Sample Input 1 :
				4 2
				1 1 0 1
				Sample output 1 :
				3
				Explanation For Sample Output 1 :
				The subarrays having the number of ones equal to 2 will be: [1,1], [1,1,0], [1,0,1].

				So the count is 3.
				Sample Input 2 :
				5 1
				1 0 0 1 0
				Sample output 2 :
				9
			Constraints :
				1 <= 'N' <= 10^4
				arr[i] is either 0 or 1.
				0 <= 'k' <= 10^6
				Time limit: 1 sec

		// Not Optimized:
			/* TC: O(n³) & SC: O(1) */	
			int numOfOne_is_K(vector<int> temp, int start, int end){
				int cnt=0;
				for(int z=start; z<=end; z++)
					if(temp[z] == 1)
						cnt++;
				return cnt;
			}

			int subarrayWithSum(vector<int> &arr, int k) {
				int Counter=0;
				for(int i=0; i<arr.size(); i++)
					for(int j=i; j<arr.size(); j++)
						if(numOfOne_is_K(arr, i, j) == k)
							Counter++;
							
				return Counter;
			}

		// Optimized:❌Pending
			/*
				Time complexity: O(N)
				Space complexity: O(N)
				
				Where 'N' is the size of the string.
			*/

			int subarrayWithSum(vector<int>&arr, int k) {
				// To store the result.
				int res = 0;
				
				// To store count of '1s'.
				int cnt = 0;
				
				// To store prefix sum.
				vector<int> prefix(arr.size() + 1, 0);
				
				// Initialize index having zero sum as 1.
				prefix[0] = 1;
				
				for (int i = 0; i < arr.size(); i++) {
					// Update count.
					cnt += arr[i];
				
					// Check condition.
					if (cnt >= k) {
				
						// Update result.
						res += prefix[cnt - k];
					}
				
					// Update prefix array.
					prefix[cnt]++;
				}
				return res;
			}

	416) Game with String:
		Problem statement:
			Given a string s of lowercase alphabets and a number k, 
			the task is to print the minimum value of the string after removal of k characters. 
			The value of a string is defined as the sum of squares of the count of each distinct character present in the string. 

			Example 1:
				Input: 
				s = abccc, k = 1
				Output: 
				6
				Explaination:
				We remove c to get the value as 12 + 12 + 22
				
			Example 2:
				Input: 
				s = aabcbcbcabcc, k = 3
				Output: 
				27
				Explaination: 
				We remove two 'c' and one 'b'. Now we get the value as 32 + 32 + 32.

			Your Task:
				You do not need to read input or print anything. 
				Your task is to complete the function minValue() which takes s and k as input parameters and returns the minimum possible required value.

			Expected Time Complexity: 
				O(n+klog(p))  where n is the length of string and p 
				is number of distinct alphabets and k number of alphabets to be removed. 

			Expected Auxiliary Space: O(n)

			Constraints:
				0 ≤ k ≤ |string length| ≤ 105
			
		class Solution{
			private:
			inline static bool cmpByValuesDESC(pair<char, int> a, pair<char, int> b){
				return a.second > b.second;
			}
			public:
			int minValue(string s, int k){
				map<char, int> Freq;
				
				for(char i: s)
					Freq[i]++;
					
				vector<pair<char, int>> holder;
				for(auto i: Freq)
					holder.push_back(i);
					
				
				while(k--){
					// sorting in descending order
					sort(holder.begin(), holder.end(), cmpByValuesDESC);
					holder[0].second--;
				}
				
				// finding the square of sum
				int sum=0;
				for(int i=0; i<holder.size(); i++)
					sum += (holder[i].second * holder[i].second);
					
				return sum;
			}
		};
	
	417) Coupons:
		Problem statement
			You are given a list of coupons containing 'N' coupon numbers. 
			Your task is to pick up the coupons from the list. You can pick up coupons consecutively. 
			To use any coupons, you have to pick the same number at least two times. 
			Your task is to find the minimum number of coupons you have to pick to avail yourself any coupon. 
			Return -1 if it’s not possible to avail any coupons.

			For example:
				You are given,’coupons’ = [1, 2, 3, 4, 5, 3, 6], here you can pick up 
				coupons that are [3, 4, 5, 3] and avail coupon number ‘3’, 
				The total number of coupons picked up are 4. Hence the answer is 4.
			Constraints:
				1 <= T <= 10
				2 <= N <= 10^6
				0 <= coupons[i] <= 10^9

				Time Limit: 1 sec
			Note:
				You do not need to print anything. It has already been taken care of. 
				Just implement the function.
			Sample Input 1:
				2 
				7
				1 2 3 4 5 3 6
				6
				2 2 0 1 4 5
				Sample Output 1:
				4
				2
				Explanation:
				For the first test case, ’coupons’ = [1, 2, 3, 4, 5, 3, 6],
				here you can pick up coupons that are [3, 4, 5, 3] and avail coupon number ‘3’,
				The total number of coupons picked up are 4. Hence the answer is 4

				For the second test case, ‘coupons’ = [2, 2, 0, 1, 4, 5],
				here you can pick up coupons that are [2, 2] and avail coupon number ‘2’,
				The total number of coupons picked up are 2. Hence the answer is 2
				Sample Input 2:
				2
				5
				3 4 6 8 9
				3
				1 2 1
				Sample Output 2:
				-1
				3
	
		#include <bits/stdc++.h>
			int pickCoupons(int n, vector<int> &coupons) {
			int minSize =INT_MAX;
			for(int i=0; i<coupons.size()-1; i++){
				int cnt=0;
				for(int j=i+1; j<coupons.size(); j++){
					if(coupons[i] == coupons[j])
						minSize=min(minSize, cnt+1);
					cnt++;
				}

			}
			if(minSize == INT_MAX)
				return -1;
			return minSize+1;
		}

		// more concise:
			#include <bits/stdc++.h>
			int pickCoupons(int n, vector<int> &coupons) {
				int minNumANS = INT_MAX;

				for(int i=0; i<coupons.size()-1; i++){
					int cnt=1;
					for(int j=i+1; j<coupons.size(); j++){
						cnt++;
						if(coupons[i] == coupons[j]){
							minNumANS = min(cnt, minNumANS);
							break;
						}
					}
				}
				return (minNumANS == INT_MAX) ? -1 : minNumANS;
			}

		// Another approach:
			/*
				Time Complexity: O(N)
				Space Complexity: O(N)

				Where N is the number of coupons
			*/

			#include <unordered_map>

			int pickCoupons(int n, vector<int> &coupons) {
				unordered_map<int, int> hashMap;

				// Set minimum distance greater than coupons length
				int minDistance = n + 1;

				for(int i = 0; i < n; i++) {
					// If this coupon number was found before then update the maximum distance
					if (hashMap.count(coupons[i]) == 1){
						minDistance = min(minDistance, i - hashMap[coupons[i]] + 1);
					}

					// Add current index in the hashMap
					hashMap[coupons[i]] = i;
				}

				// If the minimum distance is yet to be updated then return -1 else return minDistance
				return minDistance == n + 1 ? -1 : minDistance;
			}

	418) Numbers With Same Consecutive Differences:
		Problem statement
			You are given two integers ‘N’ and ‘K’. 
			You need to return all non-negative integers of length N, 
			such that the absolute difference between every two consecutive digits is ‘K’.

			Note:
				Note that leading zeros of a number are not counted as digits. 
				For example, 010, has two digits and not three.
			For example :
				Given N = 2, K = 4, so the list of numbers of length 2, 
				having difference between digits 4 are : [15, 26, 37, 40, 48, 51, 59, 62, 73, 84, 95] 
			Constraints:
				1 <= T <= 10
				2 <= N <= 9
				0 <= K <= 9

				Time limit: 1 sec
			Sample Input 1:
				2
				2 4
				3 0
				Sample Output 1:
				15 26 37 40 48 51 59 62 73 84 95
				111 222 333 444 555 666 777 888 999
				Explanation For Sample Input 1:
				In the first test case, 

				N = 2, K = 4, so the list of numbers of length 2, 
				having difference between digits 4 are : [15, 26, 37, 40, 48, 51, 59, 62, 73, 84, 95] 
				
				In the second test case, 
				N = 3, K = 0, so the list of numbers of length 3, having difference between digits 0 are : [111, 222, 333, 444, 555, 666, 777, 888, 999] 
				Sample Input 2:
				2
				2 0
				2 9
				Sample Output 2:
				11 22 33 44 55 66 77 88 99
				90

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<int> numberWithSameConsecutiveDifference(int N, int K) {
				int start = pow(10,N-1);
				int end = pow(10, N);

				vector<int> ans;
				for(int i=start; i<end; i++){
					string s = to_string(i);
					int flg=1;
					for(int j=0; j<s.length()-1; j++){
						int n = abs((s[j]-'0') - (s[j+1]-'0'));
						if(n == K)
							continue;
						else{
							flg = 0;
							break;
						}
					}
					if(flg){
						int num = stoi(s);
						ans.push_back(num);
					}
				}
				return ans;
			}

		// Optimized: ❌Pending
			https://www.codingninjas.com/studio/problems/numbers-with-same-consecutive-differences_1235179

	419) Set The Rightmost Unset Bit:
		Problem statement
			The problem is to find the rightmost bit of a non-negative number 'N' 
			that is currently unset (i.e., has a value of 0) in its binary representation and set it to 1.
			Return the number after setting the rightmost unset bit of 'N'. 
			If there are no unset bits in N's binary representation, 
			then the number should remain unchanged.
			Example:
				N = 5
				Output: 7
				Explanation: The binary representation of 5 is 101. After setting the rightmost unset bit it becomes 111 which is 7.
			Sample Input 1:
				10
				Sample Output 1:
				11
				Explanation Of Sample Input 1:
				N=10
				The binary representation of 10 is 1010. 
				After setting the rightmost unset bit it becomes 1011 which is 11.
				Sample Input 2:
				7
				Sample Output 2:
				7
				Explanation Of Sample Input 2:
				N=7
				The binary representation of 7 is 111. As there is no unset bit it remains the same.
			Constraints:
				1 <= N <= 10^9
				Time Limit: 1 sec
		
		// using substr method
			int setBits(int N){
				// convert the given num into binary form
				string s = bitset<32>(N).to_string();

				//removing leading zero's
				s = s.substr(s.find('1'));

				// set rightmost unset bit to 1
				int i;
				for(i=s.length()-1; i>=0; i--)
					if(s[i] == '0')
						break;
					
				// setting that unset rightmost bit to 1
				s[i] = '1';

				// convert back the binary representation to decimal
				return stoi(s, 0, 2);
			}

		// without using substr method
			int setBits(int N){
				// convert the given num into binary form
				string s = bitset<32>(N).to_string();

				//removing leading zero's
				while(s[0] == '0')
					s.erase(s.begin());

				// set rightmost unset bit to 1
				int i;
				for(i=s.length()-1; i>=0; i--)
					if(s[i] == '0')
						break;

				// setting that unset rightmost bit to 1
				if(i >=0 )
					s[i] = '1';

				// convert back the binary representation to decimal
				return stoi(s, 0, 2);
			}
		
		// setting to 1 inside break statement:
			int setBits(int N){
				string s = bitset<32>(N).to_string();

				// leading zero's removing
				s = s.substr(s.find('1'));

				int i;
				for(i=s.length()-1; i>0; i--)
					if(s[i] == '0'){
						s[i] = '1';
						break;
					}

				return stoi(s, 0, 2);
			}
	
	420) Matrix Game:
		Problem statement
			Ninja is a teacher at a school. He introduced a game of matrix. He gives a square matrix, 
			i.e., NxN matrix, to all the school students and asks them to check if the matrix is idempotent or not.
			A matrix is an idempotent matrix if a matrix multiplied by itself returns the same matrix. 
			The matrix M is said to be an idempotent matrix if and only if M * M = M. 
			In the idempotent matrix, M is a square matrix.

			Among them, a student Ninja is new to programming; 
			he doesn’t have much experience; he asks you to solve the problem.
			Can you help Ninja figure out whether the matrix is idempotent?

			Constraints:
				1<= T <= 50
				1<= N <= 100 
				Time Limit: 1 sec

			Sample Input 1:
				2
				3
				2 -2 -4
				-1 3 4
				1 -2 -3
				2
				1 1
				1 1
				Sample Output 1:
				True
				False
				Explanation for Sample Input 1:
				In the first test case, the matrix M = [[2,-2,-4],[-1,3,4],[1,-2,-3]]
				which on multiplying with itself yields the same matrix M. Hence the matrix is idempotent.

				In the second test case, the matrix M = [[1,1],[1,1]] which on multiplying with
				itself does not yield the same matrix M. Hence the matrix is not idempotent.
				Sample Input 2:
				2
				2
				3 -6
				1 -2
				3
				1 2 3
				4 5 6
				7 8 9
				Sample Output 2:
				True
				False

		#include <bits/stdc++.h> 
		bool matrixGame(vector<vector<int>> &mat) {
			vector<vector<int>> ans;

			int frow=0, scol=0;


			for(int i=0; i<mat.size(); i++){
				vector<int> temp;
				for (int j=0; j<mat.size(); j++){
					int value=0, n=mat.size(), col=0;

					while(n){
						value += mat[frow][col] * mat[col][scol];
						col++;
						n--;
					}
					temp.push_back(value);
					scol++;
				}
				frow++, scol=0;
				ans.push_back(temp);
			}

			if(ans == mat)
				return 1;
			return 0;
		}

		#include <bits/stdc++.h> 
		bool matrixGame(vector<vector<int>> &mat) {
			int n = mat.size();
			vector<vector<int>> temp(n, vector<int>(n, 0));

			for(int i=0; i<n; i++){
				for(int j=0; j<n; j++){
					int sum =0;
					for(int k=0; k<n; k++)
						sum += (mat[i][k] * mat[k][j]);
					temp[i][j] = sum;
				}
			}


			for(int i=0; i<n; i++)
				for(int j=0; j<n; j++)
					if(temp[i][j] != mat[i][j])
						return 0;
			return 1;
		}

	421) Count Digits:
		Problem statement
			You are given a number ’n’.
			Find the number of digits of ‘n’ that evenly divide ‘n’.
			Note:
				A digit evenly divides ‘n’ if it leaves no remainder when dividing ‘n’.
			Example:
				Input: ‘n’ = 336
				Output: 3
			Explanation:
				336 is divisible by both ‘3’ and ‘6’. Since ‘3’ occurs twice it is counted two times.
			Note:
				You don’t need to print anything. Just implement the given function.

			Sample Input 1:
				35
			Sample Output 1:
				1
			Explanation of sample output 1:
				35 is only divisible by ‘5’, hence answer is 1.

			Sample Input 2:
				373
			Sample Output 2:
				0
			Explanation of sample output 2:
				There’s no digit in 373 that evenly divides it. Hence the output is 0.

			Expected Time Complexity:
				Try to solve this in O(log(n)) 


			Constraints:
				1 <= ‘n’ <= 10^9
				Time Limit: 1 sec
		
		int countDigits(int n){
			int value = n;
			int cnt=0;
			while(value){
				if(value%10 == 0)
					goto nextIteration;
				if(n % (value%10) == 0)
					cnt++;
				nextIteration:
				value /= 10;
			}
			return cnt;
		}

	422) Longest Substring Without Repeating Characters:
		https://www.codingninjas.com/studio/problems/longest-substring-without-repeating-characters_630418
		Problem statement
			Given a string input of length n, 
			find the length of the longest substring without repeating characters 
			i.e return a substring that does not have any repeating characters.
			Substring is the continuous sub-part of the string formed by removing zero or more characters from both ends.
			Constraints:
				1<= n <=10^5
				Time Limit: 1 sec

			Sample Input 1:
				abcabcbb 
				Sample Output1:
				3
				Explanation For Sample Input 1:
				Substring "abc" has no repeating character with the length of 3.
				Sample Input 2:
				aaaa
				Sample Output 2:
				1
	
		/* Time Complexity is O(n^2) */
			#include <bits/stdc++.h> 
			using namespace std;
			int uniqueSubstrings(string input) {
				int mxLen=0;

				for(int i=0; i<input.length(); i++){
					string s = input.substr(i,1);
					for(int j=i+1; j<input.length(); j++){
						if(s.find(input[j]) != string::npos)
							break;
						s += input[j];
					}
					mxLen = fmax(s.length(), mxLen);				// mx = max(mx, (int)s.size());
				}
				return mxLen;
			}
		
		// or Another Approach: ❌Pending
			/*
				Time Complexity : O(N)
				Space Complexity : O(K)

				where N is the length of input string and
				K is the number of unique characters in the string
			*/

			#include <unordered_map>
			int uniqueSubstrings(string input){
				int n = input.length();
				unordered_map<char, int> set;
				int ans = 0, i = 0, j = 0;

				while (i < n && j < n) {
					// Try to extend the range [i,j]
					if (set.find(input[j]) == set.end()) {
						set[input[j]] = 1;
						ans = max(ans, j - i + 1);
						j++;
					} else {
						set.erase(input[i]);
						i++;
					}
				}
				return ans;
			}
	
	423) Longest Substring Without Repeating Characters:
		https://www.codingninjas.com/studio/problems/longest-substring-without-repeating-characters_758894
		Problem statement
			Given a string 'S' of length 'L', return the length of the longest substring without repeating characters.
			Example:
				Suppose given input is "abacb", then the length 
				of the longest substring without repeating characters will be 3 ("acb").
			Constraints:
				0 <= L <= 10^5     
				Time limit: 1 sec
			Sample Input 1:
				xyxyz
				Sample Output 1:
				3  
				Explanation for Sample Output 1:
				The substrings without repeating characters are "xy", "yx", "xyz", "yz", "z".
				The longest substring out of these substrings is “xyz” of length 3.
				Sample Input 2:
				xxx
				Sample Output 2:
				1
				Explanation for Sample Output 2:
				The substrings without repeating characters is only "x" with length 1.

		#include <bits/stdc++.h> 
		int lengthOfLongestSubstring(string &s) {
			int mxSize=0;
			for(int i=0; i<s.length(); i++){
				string temp = s.substr(i,1);
				int crntSize=1;
				for(int j=i+1; j<s.length(); j++){
					if(temp.find(s[j]) != string::npos)
						break;
					temp += s[j];
					crntSize++;
				}
				mxSize = max(crntSize, mxSize);
			}
			return mxSize;
		}

		// Other approach:
			#include <bits/stdc++.h> 
			int lengthOfLongestSubstring(string &s) {
				int mxLen=0;
				for(int i=0; i<s.size(); i++){
					int j=i+1;
					string sample = string(1, s[i]);
					while(j<s.size()){
						if(sample.find(s[j]) != string::npos)
							break;
						sample += s[j++];
					}
					mxLen = fmax(mxLen, sample.size());
				}
				return mxLen;
			}

	424) Sum Of Zeroes:
		Problem statement
			You are given a binary matrix (it contains only 0s and 1s) with dimensions ‘N * M’. 
			You need to find and return the sum of coverages of all zeros of the given matrix.

			Coverage for a particular 0 is defined as the total number of ‘1s’ around it
			(i.e., immediate left, immediate right, immediate up, and immediate bottom positions).

			Constraints:
				1 <= T <= 10
				1 <= N, M <= 10^3

				Time limit: 1 second
			Sample Input 1:
				1
				2 2 
				1 0
				0 1
				Sample Output 1:
				4
				Explanation of Input 1:
				In the given matrix, there are 2 zeros. 
				For the 0 at the 1st row, 2nd column position, 
				coverage is 2(there is 1 adjacent top one and 1 adjacent right one).

				For the 0 at the 2nd row, 
				2nd column the coverage is 2(there is 1 adjacent top one and 1 adjacent right one).

				Hence the net coverage is 2 + 2 = 4.
				Sample Input 2:
				1
				2 3
				0 0 0
				0 0 0
				Sample Output 2
				0

		#include <bits/stdc++.h> 
		int coverageOfMatrix(vector<vector<int>> &mat) {
			int ttlCnt=0;

			for(int i=0; i<mat.size(); i++){
				int crntCnt=0;
				for(int j=0; j<mat[0].size(); j++){
					if(mat[i][j] == 0){
						int Bcol = j-1, Ncol = j+1;
						int Brow = i-1, Nrow=i+1;
						if(Bcol >=0 && mat[i][Bcol] == 1)
							crntCnt++;
						
						if(Ncol < mat[i].size()  && mat[i][Ncol] == 1)
							crntCnt++;

						// before row
						if(Brow >=0  && mat[Brow][j] == 1)
							crntCnt++;

						// next row
						if(Nrow < mat.size() && mat[Nrow][j] == 1)
							crntCnt++;
					}
				}
				ttlCnt += crntCnt;
			}
			return ttlCnt;
		}

	425) Roman to Integer (POTD 65):
		Problem Statement:
			Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
				Symbol       Value
				I             1
				V             5
				X             10
				L             50
				C             100
				D             500
				M             1000

			For example, 2 is written as II in Roman numeral, 
			just two ones added together. 12 is written as XII, 
			which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

			Roman numerals are usually written largest to smallest from left to right.
			However, the numeral for four is not IIII. Instead, the number four is written as IV.
			Because the one is before the five we subtract it making four.
			The same principle applies to the number nine, which is written as IX.
			There are six instances where subtraction is used:

			I can be placed before V (5) and X (10) to make 4 and 9. 
			X can be placed before L (50) and C (100) to make 40 and 90. 
			C can be placed before D (500) and M (1000) to make 400 and 900.
			Given a roman numeral, convert it to an integer.

			Example 1:
				Input: s = "III"
				Output: 3
				Explanation: III = 3.

			Example 2:
				Input: s = "LVIII"
				Output: 58
				Explanation: L = 50, V= 5, III = 3.

			Example 3:
				Input: s = "MCMXCIV"
				Output: 1994
				Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

			Constraints:
				1 <= s.length <= 15
				s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
				It is guaranteed that s is a valid roman numeral in the range [1, 3999].

		class Solution {
			public:
			// last char approach
			int romanToInt(string s) {
				int ans=0;
				map<char, int> mapper = {{'I', 1},
									{'V', 5},
									{'X',10},
									{'L',50},
									{'C',100},
									{'D', 500},
									{'M', 1000}};

				ans += mapper[s[s.length()-1]];
				for(int i=s.length()-2; i>=0; i--){
					if(mapper[s[i]] >= mapper[s[i+1]])
						ans += mapper[s[i]];
					else
						ans -= mapper[s[i]];
				}
				return ans;
			}
		};

	426) Roman Number to Integer:
		Problem statement:
			Given a string in roman no format (s)  your task is to convert it to an integer.
			Various symbols and their values are given below.
			I 1
			V 5
			X 10
			L 50
			C 100
			D 500
			M 1000

			Example 1:
			Input:
			s = V
			Output: 5

			Example 2:
			Input:
			s = III 
			Output: 3

			Your Task:
				Complete the function romanToDecimal() which takes a string as 
				input parameter and returns the equivalent decimal number. 

			Expected Time Complexity: O(|S|), |S| = length of string S.
			Expected Auxiliary Space: O(1)

			Constraints:
				1<=roman no range<=3999

		// same question as POTD 65 without using map.
		class Solution {
			public:
			int romanToDecimal(string &str) {
				map<char, int> mapper { {'I', 1},
									{'V', 5},
									{'X', 10},
									{'L', 50},
									{'C', 100},
									{'D', 500},
									{'M', 1000}};
									
				int ans = mapper[str[str.length()-1]];
				for(int i=str.length()-2; i>=0; i--){
					if(mapper[str[i]] >= mapper[str[i+1]])
						ans += mapper[str[i]];
					else
						ans -= mapper[str[i]];
				}
				return ans;
			}
		};

	427) Ceil The Floor:
		Problem statement
			You're given a sorted array 'a' of 'n' integers and an integer 'x'.
			Find the floor and ceiling of 'x' in 'a[0..n-1]'.

			Note:
				Floor of 'x' is the largest element in the array which is smaller than or equal to 'x'.
				Ceiling of 'x' is the smallest element in the array greater than or equal to 'x'.
			Example:
				Input: 
					n=6, x=5, a=[3, 4, 7, 8, 8, 10]   
				Output:
					4
				Explanation:
				The floor and ceiling of 'x' = 5 are 4 and 7, respectively.

			Sample Input 1 :
				6 8
				3 4 4 7 8 10

				Sample Output 1 :
				8 8

				Explanation of sample input 1 :
				Since x = 8 is present in the array, it will be both floor and ceiling.

			Sample Input 2 :
				6 2
				3 4 4 7 8 10

			Sample Output 2 :
				-1 3

			Explanation of sample input 2 :
				Since no number is less than or equal to x = 2 in the array, 
				its floor does not exist. The ceiling will be 3.

			Constraints :
				1 <= n <= 2 * 10^5      
				1 <= a[i] <= 10^9
				Time limit: 1 sec

		/* TC: O(n) & SC: O(n) */
		pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
			pair<int, int> ans;
			for(int i=0; i<n ; i++){
				if(a[i] == x)
					return ans = {x,x};
				else if(a[i] < x)
					ans.first = a[i];
				else if(a[i] > x)
					break;
			}

			if(ans.first == 0)
				ans.first = -1;

			for(int i=n-1; i>=0 ; i--){
				if(a[i] > x)
					ans.second = a[i];
				else if(a[i] < x)
					break;
			}
			
			if(ans.second == 0)
				ans.second = -1;

			return ans;
		}

		/*TC: O(n) & SC: O(1) */
		pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
			int first=-1, second=-1;

			// for floor
			for(int i=0; i<n ; i++){
				if(a[i] == x)
					return {x,x};
				else if(a[i] < x)
					first = a[i];
				else if(a[i] > x)
					break;
			}

			// for ceil
			for(int i=n-1; i>=0; i--){
				if(a[i] > x)
					second = a[i];
				else
					break;
			}
			return {first, second};
		}

		// using binary search
		/* TC: O(log(n)) & SC: O(1) */
		pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x){
			int s=0, e=n-1, first=-1, second=-1;

			// Searching for floor
			while(s <= e){
				int mid = (s+e)/2;
				if(a[mid] == x)
					return {x,x};
				else if(a[mid] > x)
					e = mid - 1;
				else{
					first = a[mid];
					s = mid+1;
				}
			}

			// Searching for ceil
			// need to reset the s & e values
			s = 0, e =n-1;

			while(s <= e){
				int mid = (s+e)/2;
				if(a[mid] < x)
					s = mid+1;
				else{
					second = a[mid];
					e = mid-1;
				}
			}

			return {first, second};
		}

	428) Letter Combinations of a Phone Number: (Lecture-38)
		problem statement:
			Given a string containing digits from 2-9 inclusive, 
			return all possible letter combinations that the number could represent.
			Return the answer in any order.
			A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

			Example 1:
				Input: digits = "23"
				Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

			Example 2:
				Input: digits = ""
				Output: []

			Example 3:
				Input: digits = "2"
				Output: ["a","b","c"]

			Constraints:
				0 <= digits.length <= 4
				digits[i] is a digit in the range ['2', '9'].

		class Solution {
			public:
			vector<string> letterCombinations(string digits) {
				map<int, string> mapper = {{2, "abc"},
										{3, "def"},
										{4, "ghi"},
										{5, "jkl"},
										{6, "mno"},
										{7, "pqrs"},
										{8, "tuv"},
										{9, "wxyz"}};
				vector<string> temp;
				string s1 = mapper[digits[0]-'0'];
				for(char ch: s1){
					temp.push_back(string(1,ch));
				}

				for(int i=1; i<digits.size(); i++){
					string s2 = mapper[digits[i]-'0'];
					vector<string> subTempHolder;

					for(int z=0; z<temp.size(); z++){
						for(int j=0; j<s2.length(); j++){
							subTempHolder.push_back(temp[z] + s2[j]);    
						}
					}
					// temp.clear();
					temp = subTempHolder;
				}

				sort(temp.begin(), temp.end());
				return temp;
			}
		};

	429) Fruits and Baskets:❌Pending (wrong)
		https://www.codingninjas.com/studio/problems/fruits-and-baskets_985356
		Problem statement
			There are ‘n’ fruit trees that are planted along a road. 
			The trees are numbered from 0 to n-1. 
			The type of fruit each tree bears is represented by an integer from 1 to 'n'.
			A Ninja is walking along that road. 
			He has two baskets and wants to put the maximum number of fruits in them.
			The restriction is that each basket can have only one type of fruit.
			Ninja can start with any tree and end at any tree, but once he has started,
			he cannot skip a tree i.e if he picks fruit from the tree ‘i’,
			then he has to pick fruit from tree ‘i+1’ before going to the tree ‘i+2’.
			He will pick one fruit from each tree until he cannot, i.e, 
			he will stop when he has to pick a fruit of the third type because only 
			two different fruits can fill both baskets.

			You are given an array ‘arr’. The ‘i’th integer in this array represents the type of fruit tree ‘i’ bears.
			Return the maximum number of fruits Ninja can put in both baskets after satisfying all the conditions.

			For Example:
				'arr' = [1, 2, 3]
				Here, we have three different types of fruits. We can pick [1, 2] or [2, 3].
				We can pick a maximum of two fruits.

				Hence, we return 2.
			Sample Input 1:
				4
				1 1 2 3
				Sample Output 1:
				3 
				Explanation of Sample Input 1:
				There are four trees and the type of fruits in them are 1, 1, 2, 3 respectively.

				One way is that Ninja can start picking fruits from tree 0. 
				He picks one fruit from tree 0 and put it in the first basket,
				then he picks one fruit from tree 1 and put it in the first basket,
				then he picks one fruit from tree 2 and put it in the second basket,
				he cannot pick fruit from tree 3 because the first basket has the fruit of type 1
				and second has the fruit of type 2 and type of fruit in tree-3 is 3. 

				Thus he has to stop there. The number of fruits he picks in this way is 3.
				We can show that this is the maximum possible number of fruits ninjas can pick.

			Sample Input 2:
				4
				1 2 3 4
				Sample Output 2:
				2
				Explanation of Sample Input 2:
				There are four trees, and each of them has different types of fruit. 
				No matter from which tree Ninja starts picking fruits he can only collect 2 fruits.
			Constraints:
				1 <= n <= 10^4
				1 <= arr[I] <= n
				Where ‘n’ represents the number of trees.
				Time limit: 1 sec

		// Wrong
			int findMaxFruits(vector<int> &arr, int n) {
				vector<int> holder;
				int type=0, maxSize=0;

				// need to check from every i'th tree....
				for(int i=0; i<n; i++){
					// if we didn't found the element then we have to increase the type
					// coz the new element is definitely is of different type
					if(find(holder.begin(), holder.end(), arr[i]) == holder.end())
						type++;

					if(type <=2 )
						holder.push_back(arr[i]);

					if(type > 2){
						maxSize = fmax(maxSize, holder.size());
						holder.clear();
						type=0;
						i-=2;
					}
				}
				return maxSize;
			}

		// Correct:
			int findMaxFruits(vector<int> &arr, int n) {
				// Write your code here.
				int ele1 = -1;
				int ele2 = -1;

				int cnt1 = 0;
				int cnt2 = 0;
				int maxi = 0;

				for (int i = 0; i<n ; i++){
					if (arr[i] == ele1) cnt1++;
					else if (arr[i] == ele2) cnt2++;
					else if (ele1 == -1) {
						ele1 = arr[i];
						cnt1++;
					}else if (ele2 == -1){
						ele2 = arr[i];
						cnt2++;
					}else{
						maxi = max(maxi , cnt1+cnt2);
						ele1 = ele2;
						cnt1 = cnt2;
						ele2 = arr[i];
						cnt2 = 1;
					}
				}
				maxi = max(maxi , cnt1+cnt2);
				return maxi;
			}

	430) Count Substring With abc:❌Pending
		Problem statement
			Count the number of substrings which contains at least one occurrence of all these characters: a, b, and c.
			Note:
				The count of substrings will always fit in a 32-bit integer. 
			Example:
				For 'n' = 5, 's’ = “abbac”.
				Answer is 3.
				These are the only 3 valid substrings { “abbac”, ”bbac”, ”bac” } satisfying all the constraints.
			Sample Input 1:
				4
				baac
				Sample Output 1:
				1
				Explanation of sample output 1:
				‘n’ = 4,'s’ = “baac”.
				Answer is 1. The only possible substring is “baac”.
				Sample Input 2:
				8
				bababcc
				Sample Output 2:
				8
			Constraints:
				1 <= n <= 10^5
				's' only contains a,b,c.
				Time Limit: 1 sec

		// Not optimized:
			int countSubstring(string s){
				int cnt=0;
				for(int i=0; i<s.length()-2; i++){
					string temp = s.substr(i,3);

					if(temp.find('a') != string::npos && temp.find('b') != string::npos && temp.find('c') != string::npos)
						cnt++;	
					for(int j=i+3; j<s.length(); j++){
						temp += s[j];
						if(temp.find('a') != string::npos && temp.find('b') != string::npos && temp.find('c') != string::npos)
							cnt++;
					}
				}
				return cnt;
			}

		// Optimized:
			int countSubstring(string s){
				int n = s.length();
				int ans = 0, left = 0, right = 0;
				int arr[3] = {0, 0, 0};

				while(right < n){
					arr[s[right] - 'a']++;

					while(arr[0] != 0 && arr[1] != 0 && arr[2] != 0){
						ans += n - right;
						arr[s[left] - 'a']--;
						left++;
					}
					right++;
				}
				return ans;
			}

	431) Count Distinct Subarrays With At Most K Odd Elements:
		https://www.codingninjas.com/studio/problems/count-distinct-subarrays-with-at-most-k-odd-elements_11325656
		Problem statement
			You are given an array 'arr' of 'N' integers. 
			Your task is to return the total number of distinct subarrays of 'arr' having 'k' odd elements.

			Example :
				If arr = [3,2,3], and k = 1 
				then there are 4 subarrays with 1 odd elements:
				[3], [3,2], [2,3] & [3].
			Sample Input 1
				5 2
				2 1 1 1 4
				Sample Output 1 :
				4
				Explanation for sample input 1 :
				Following are 3 valid subarray:
				[2,1,1], [1,1], [1,1], [1,1,4].
				Sample Input 2 :
				3 2
				1 3 1
				Sample Output 2 :
				2
			Constraints :
				1 <= N <= 10^4
				0 <= k <= N
				1 <= arr[i] <= 10 ^ 5

				Time Limit: 1sec

		// Not Optimized:
			int oddCounter(vector<int>& a, int s, int e){
				int cnt=0;
				for(int i=s; i<=e; i++)
					if(a[i]&1)
						cnt++;
				
				return cnt;
			}

			int distinctSubKOdds(vector<int> &arr, int k) {
				int cnt=0;

				for(int i=0; i<arr.size(); i++){
					for(int j=i; j<arr.size(); j++){
						if(oddCounter(arr, i, j) == k)
							cnt++;
					}
				}
				return cnt;
			}

			// Bit Optimized
				int oddCounter(vector<int>& a, int s, int e){
					int cnt=0;
					for(int i=s; i<=e; i++)
						if(a[i]&1)
							cnt++;
					return cnt;
				}

				int distinctSubKOdds(vector<int> &arr, int k) {
					int cnt=0;

					for(int i=0; i<arr.size(); i++){
						for(int j=i; j<arr.size(); j++){
							if(oddCounter(arr, i, j) == k)
								cnt++;
							else if(oddCounter(arr, i, j) < k)
								continue;
							else
								break;			
						}
					}
					return cnt;
				}

			// Partially accepted:
				int oddCounter(vector<int>& a, int s, int e){
					int cnt=0;
					for(int i=s; i<=e; i++)
						if(a[i]&1)
							cnt++;
					return cnt;
				}

				int distinctSubKOdds(vector<int> &arr, int k) {
					int cnt=0;

					for(int i=0; i<arr.size(); i++){
						int alreadyCnt=oddCounter(arr, i, i);
						if(alreadyCnt == k)
							cnt++;
						
						int j=i+1;
						while(j<arr.size() && alreadyCnt <=k){
							if(arr[j]&1)
								alreadyCnt++;

							if(alreadyCnt == k)
								cnt++;
							
							if(alreadyCnt > k)
								break;
							j++;
						}
					}
					return cnt;
				}
		
		// Optimized: ❌Pending
			int distinctSubKOdds(vector<int> &arr, int k) {
				// Write your code here
				unordered_map<int,int>m;
				int ans=0,odd=0,n=arr.size();

				for(int i=0;i<n;i++){
					if(arr[i]&1) odd++;
					if(odd==k) ans++;
						if(m.find(odd-k)!=m.end())
						ans+=m[odd-k];

					m[odd]++;
				}
				return ans;
			}
			
	432) Maximum Consecutive Ones: (Easy)
		Problem statement
			You are given an array ‘ARR’ of length ‘N’ consisting of only ‘0’s and ‘1’s. 
			Your task is to determine the maximum length of the consecutive number of 1’s.
			For Example:
				ARR = [0, 1, 1, 0, 0, 1, 1, 1], here you can see the maximum 
				length of consecutive 1’s is 3. Hence the answer is 3.
			Sample Input 1:
				2
				8
				0 1 1 0 0 1 1 1
				4
				0 1 1 0
				Sample Output 1:
				3
				2
				Explanation for Sample Output 1:
				For the first test case, ‘ARR’ = [0, 1, 1, 0, 0, 1, 1, 1], 
				here you can see the maximum length of consecutive 1’s is 3 
				when we select ARR[5], ARR[6] and ARR[7]. Hence the answer is 3.

				For the second test, ‘ARR’ = [0, 1, 1, 0], 
				here you can see the maximum length of consecutive 
				1’s is 2 when we select ARR[1] and ARR[2]. 
				Hence the answer is 2.

				Sample Input 2:
				2
				6
				1 1 1 1 0 0
				4
				1 1 1 1
				Sample Output 2:
				4
				4
				Constraints:
					1 ≤ T ≤ 10
					1 ≤ N ≤ 1000
					ARR[i] = {0, 1}

					Time Limit: 1 sec

		/* TC: O(n²) & SC: O(1) */
			int consecutiveOnes(vector<int>& arr){
				int mxLenCnt=0;
				for(int i=0; i<arr.size(); i++){
					int cnt=0, j;
					if(arr[i] == 1){
						for(j=i; j<arr.size(); j++)
							if(arr[j] == 1)
								cnt++;
							else
								break;
					}
					mxLenCnt = max(cnt, mxLenCnt);                    
					if(j == arr.size())
						break;
				}
				return mxLenCnt;
			}

		//or
			/**
				Time Complexity: O( N )
				Space Complexity: O( 1 )

				Where N is the length of the array.
			**/

			int consecutiveOnes(vector<int>& arr) {
				int oneCount = 0;
				int ans = 0;

				// Iterate over the array.
				for(int num: arr){
					// If we found a 0, reset the consecutive one count to 0
					if(num == 0) {
						oneCount = 0;
						continue;
					}

					// Otherwise increase the consecutive one count.
					oneCount++;

					// Update the answer.
					ans = max(ans, oneCount);
				}
				
				return ans;
			}

	433) Max Consecutive Ones: (LeetCode)
		Problem statement:
			Given a binary array nums, return the maximum number of consecutive 1's in the array.

			Example 1:
			Input: nums = [1,1,0,1,1,1]
			Output: 3
			Explanation: The first two digits or the last three digits are consecutive 1s.
			The maximum number of consecutive 1s is 3.

			Example 2:
			Input: nums = [1,0,1,1,0,1]
			Output: 2

			Constraints:
				1 <= nums.length <= 10^5
				nums[i] is either 0 or 1.
	
		class Solution {
			public:
			int findMaxConsecutiveOnes(vector<int>& nums) {
				int mxCnt, cnt;
				mxCnt = cnt = 0;
				for(int i=0; i<nums.size(); i++){
					if(nums[i] == 0){
						cnt=0;
						continue;
					}
					cnt++;
					mxCnt = max(mxCnt, cnt);
				}
				return mxCnt;
			}
		};

	434) Maximum Consecutive Ones: (Moderate)
		https://www.codingninjas.com/studio/problems/maximum-consecutive-ones_892994
		Problem statement
			Given a binary array 'ARR' of size 'N', 
			your task is to find the longest sequence of continuous 1’s 
			that can be formed by replacing at-most 'K' zeroes by ones. 
			Return the length of this longest sequence of continuous 1’s.

			Constraints:
				1 <= T <= 10
				1 <= N <= 5 * 10^4 
				0 <= Arr[i] <= 1
				0 <= K <= N

				Time Limit: 1 sec
			Sample Input 1:
				1
				7
				1 0 0 1 1 0 1   
				1
				Sample Output 1:
				4 
				Explanation of Sample Input 1:
				Here we can replace at-most one 0 by 1 ( since K = 1 ). 
				So the longest consecutive subarray with all 1’s that we can get is by replacing the 0 present at index 5.    
				So the updated array will be {1,0,0,1,1,1,1}.

				As we can see in the updated array the longest subarray with all 1’s is from index 3 of length 4.
				Sample Input 2:
				2
				10
				1 0 0 1 0 1 0 1 0 1
				2
				5
				1 1 0 1 1
				2
				Sample Output 2:
				5
				5
				Explanation of Sample Input 2:
				Here, In the first test case we can replace at-most two 0’s by 1’s ( since 'K' = 2 ). 
				So the longest consecutive subarray with all 1’s  we can get is by replacing the 0 
				present at index 4 and index 6 or index 6 and index 8 .    
				So the updated array will be either {1,0,0,1,1,1,1,1,0,1} or {1,0,0,1,0,1,1,1,1,1}.
				In the second test case there is only one zero in the whole array and 
				we are allowed to replace two 0’s by 1’s so the answer will be the size of the array, i.e. 5.

		// Not Optimized:
			#include<bits/stdc++.h>
			int longestSubSeg(vector<int> &arr , int n, int k){
				int tempHolder= k;
				int mxCounter=INT_MIN;
				int i;
				for(i=0; i<arr.size(); i++){
					// need to check for every index
					int j = i, cnt=0, k = tempHolder;
					while(k && j<arr.size()){
						if(arr[j++] == 0)
							k--;
						cnt++;
					}

					// keep going till you find the next zero
					while(j<arr.size()){
						if(arr[j++] == 0)
							break;
						cnt++;
					}
					mxCounter = max(mxCounter, cnt);
				}
				return mxCounter;
			}
	
		// Optimized: ❌Pending
			#include<bits/stdc++.h>
			int longestSubSeg(vector<int> &arr , int n, int k){
				int zerocnt=0,i=0,ans=0;
				for(int j=0;j<arr.size();j++) {
					if(arr[j]==0)
						zerocnt++;
					while(zerocnt>k) {
						if(arr[i]==0)
							zerocnt--;
						i++;
					}
					ans=max(ans,j-i+1);
				}
				return ans;
			}

	435) Max Consecutive Ones III: (LeetCode)
		Problem statement:
			Given a binary array nums and an integer k, 
			return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

			Example 1:
				Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
				Output: 6
				Explanation: [1,1,1,0,0,1,1,1,1,1,1]
				Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

			Example 2:
				Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
				Output: 10
				Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
				Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
			Constraints:
				1 <= nums.length <= 105
				nums[i] is either 0 or 1.
				0 <= k <= nums.length

		class Solution {
			public:
			int longestOnes(vector<int>& arr, int k) {
				int zerocnt=0,i=0,ans=0;
				for(int j=0;j<arr.size();j++) {
					if(arr[j]==0)
						zerocnt++;
					while(zerocnt>k) {
						if(arr[i]==0)
							zerocnt--;
						i++;
					}
					ans=max(ans,j-i+1);
				}
				return ans;
			}
		};

	Weekly Contenst:
		436) Destroy
			Problem statement
				You have to destroy an integer 'N'. The integer is destroyed when its value is
				reduced to '0'.
				In an operation on an integer "X, you can subtract the smallest prime factor of 'X'
				from 'X.
				Return the number of operations required to destroy the integer.
				Example:
				N' = 9
				Subtract 3 from N. Now, N becomes 6.
				Subtract 2 from N. Now. N becomes 4.
				Subtract 2 from N again. Now, N becomes 2.
				Finally, subtract 2 from N one more time. N becomes 0 and is effectively
				"destroyed".
				Sample Input 1:
					2
					3
					4
					Sample Output 1:
					1
					2
					Explanation of sample input 1:
					For 1st Testcase :
					Subtract 3 from N. N becomes 0 and is effectively "destroyed".
					For 2nd Testcase :
					Subtract 2 from N again. Now, N becomes 2.
					Finally, subtract 2 from N one more time. N becomes 0 and is effectively
					"destroyed".
					Sample Input 2:
					3
					22
					75
					26
					Sample Output 2:
					11
					37
					13
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^9
					|S| = 'N'-1 and S[i] is either 'I' or 'D'
					Time Limit: 1 sec

			// Not Optimized:
				bool isPrime(int value){
					for(int z=2; z <=(value/2); z++){
						if(value%z == 0)
							return false;
					}
					return true;
				}

				int destroy(int n){
					int cnt=0;
					int primeStart=2;

					while(n){
						int crntPrimeValue = primeStart;

						checkAgin:
						if(n % crntPrimeValue == 0){
							n -= crntPrimeValue;
						}else{
							crntPrimeValue++;
							while(!isPrime(crntPrimeValue)){
								crntPrimeValue++;
								continue;
							}
							goto checkAgin;
						}
						cnt++;
					}
					return cnt;
				}

			// or little optimized:
				bool isPrime(int n){
					for(int i=2; i<=(n/2); i++){
						if(n % i == 0)
							return 0;
					}
					return true;
				}

				int destroy(int n){
					int cnt=0;
					while(n){
						if(n&1){
							if(isPrime(n)){
								n-=n;
							}else{
								int smallPrimeN = 2;
								while(n % smallPrimeN != 0){
									smallPrimeN++;
									while(!isPrime(smallPrimeN)){
										smallPrimeN++;
									}
								}
								n -= smallPrimeN;
							}
						}else{
							n -= 2;
						}
						cnt++;
					}
					return cnt;
				}

			// Optimized: ❌Pending
				int destroy(int n){
					if(n%2==0)
						return n/2;

					int cnt=0;
					for(int i=3; i<=n; i++){
						if(n%i == 0){
							n-=i;
							cnt++;
							break;
						}
					}
					if(cnt==0)
						return 1;
					return cnt + (n/2);
				}

		437) Hate Equality:
			Problem statement
				There are two strings 'S' and 'T', each having 'N' lowercase English characters.
				Initially, both strings are equal.
				You don't want the string 'T' equal to 'S'. For this, you can reshuffle the
				characters of the string 'T'.
				Determine if you can make the string 'T' different from 'S' after reshuffling the
				characters of the string 'T'.
				Return '1' if you can make the string 'T' different from 'S'. Otherwise, return '0'

				Example:
					N = 7
					S = 'aab'
					Initially, the string 'T' is equal to 'aab'.
					You can shuffle the characters such that 'T' equals 'aba'. So 'T' is not equal to 'S'.
					So, the answer for this case is '1'.

				Constraints:
					1 <= 'N' <= 10^5
					'a' <= S[i] <= 'z'
					Time limit: 1 sec
				Sample input 1:
					2
					3
					aaa
					4
					abcd
				Sample output 1:
					0
					1
					Explanation of sample input 1:
					For test case 1:
					It can be proved that you can not shuffle the characters of the string 'T'
					such that it will be different from 'S'.
					So, the answer for this case is '0'.
					For test case 2:
					Initially, the string 'T' is equal to 'abcd".
					You can shuffle the characters such that 'T' equals 'dcab'. So 'T' is not equal
					to 'S.
					So, the answer for this case is '1'.
					Sample input 2:
					2
					6
					abcabc
					1
					a
					Sample output 2:
					1
					0
		
			int canYouMakeDifference(int n, string &s) {
				// if(s.length() == 1)
				//     return 0;
				
				for(int i=1; i<s.size(); i++){
					if(s[i] != s[i-1])
						return 1;
				}
				return 0;
			}
		
	438) Split String:
		Problem statement
			You are given a string 'S'. A string is called a split string if it follows the conditions define below.
			1. It can be divided into 'K' contiguous substrings such that the first letter of these substrings is the same for all the substrings.
			2. It can be divided into 'K' contiguous substrings such that the first letter of these substrings is distinct for all the substrings.
			Return 1 if 'S' is a split string otherwise return 0.

			For Example:-
				Let 'N' = 6, 'K' = 2, 'S' = "pppdpa".
				It can be divided into "pp" and "pdpa", the first letter of the strings is same.
				It can be divided into "ppp" and "dpa", the first letter of the strings is distinct.
				So our answer is 1. 
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				'S' consists of 'N' lowercase English letters.
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				3 4 
				xyz
				5 3
				abaca
				Sample Output 1:-
				0
				1
				Explanation of sample input 1:-
				First test case:-
				It can be proven that the string 'S' cannot follow the two conditions.
				So our answer is 0. 

				Second test case:-
				It can be divided into "ab", "ac", and "a", the first letter of the strings is the same.
				It can be divided into "a", "ba", and "ca", the first letter of the strings is distinct.
				So our answer is 1. 
				Sample Input 2:-
				2
				4 1
				abcb
				5 3
				pqpsr
				Sample Output 2:-
				1
				0

		int splitString(int k, string s){
			map<char, int> Freq;
			for(int i=0; i<s.size(); i++)
				Freq[s[i]]++;

			set<char> uniquChar(s.begin(), s.end());
			if(uniquChar.size() < k)
				return 0;
			
			int flag=0;
			for(auto i: Freq)
				if(i.second >= k){
					flag=1;
					break;
				}

			return (flag) ? 1: 0;
		}
	
	439) Ninja And The Class Room:
		Problem statement
			Ninja has been asked to make the seating arrangement during the exam. 
			Given an array ‘A’ of ‘N’ integers where ‘A[i] = 1’ means there is a student 
			seated at the index ‘i’ and ‘A[i] = 0’ means that the place is currently unoccupied.

			Provided no two students can seat adjacent to each other Ninjas has been asked to 
			place extra ‘K’ students in the classroom.
			Return 1 if the Ninja is able to place that extra ‘K’ student else return 0.

			Example :
				Input: ‘N’ = 7, ‘K’ = 2, ‘A’ = [1, 0, 0, 0, 1, 0, 0]
				Output: 1

			It is possible to place locations 2 and 6 (0-indexed) the updated array will be [1, 0, 1, 0, 1, 0, 1]
			Here no two students are adjacent to each other.

			Constraints:
				1 ≤ T ≤ 10
				1 ≤ N ≤ 10^5
				0 ≤ K ≤ 10^9
				0 ≤ ‘A[i]’ ≤ 1
				It is guaranteed that the sum of ‘N’ is ≤ 10^5 for all test cases.

				Time limit: 1 sec
			Sample Input 1 :
				2
				5 2
				1 0 0 0 0
				2 1
				0 1
				Sample Output 1 :
				1
				0
				Explanation For Sample Input 1 :
				For test case 1:
				It is possible to place at locations 2 and 4 (0-indexed) the updated
				array will be [1, 0, 1, 0, 1] Here no two students are adjacent to each other.

				For test case 2:
				For any possible combinations, there is no way to place the students.
				Sample Input 2 :
				2
				4 1
				1 1 1 1
				2 1
				0 0
				Sample Output 2 :
				0
				1

		int isAbleToPlace(int n, int k, vector<int> &a) {
			int cnt=0;
			if(k==0)
				return 1;

			for(int i=0; i<n; i++){
				if(i==0){
					if(a[i] == 0 && a[i+1] == 0){
						a[i] = 1;
						cnt++;
					}
				}else if(i==(n-1)){
					if(a[i] == 0 && a[i-1] == 0){
						a[i] = 1;
						cnt++;
					}
				}else{
					if(a[i] == 0 && a[i-1] == 0 && a[i+1] == 0){
						a[i] = 1;
						cnt++;
					}
				}
				if(cnt == k)
					break;
			}
			return (cnt==k) ? 1 : 0;
		}

		// or
			int isAbleToPlace(int n, int k, vector<int> &a) {
				int cnt=0;
				if(k)         
					for(int i=0; i<n; i++){
						if(i==0){
							if(a[i] == 0 && a[i+1] == 0){
								a[i] = 1;
								cnt++;
							}
						}else if(i==(n-1)){
							if(a[i] == 0 && a[i-1] == 0){
								a[i] = 1;
								cnt++;
							}
						}else{
							if(a[i] == 0 && a[i-1] == 0 && a[i+1] == 0){
								a[i] = 1;
								cnt++;
							}
						}
						if(cnt == k)
							break;
					}
				return (cnt==k) ? 1 : 0;
			}
		//or
			/*
				Time complexity: O(N)
				Space complexity: O(1)

				Where 'N' is the input array 'A'.
			*/

			int isAbleToPlace(int n, int k, vector<int> &a) {
				// Inserting the 0 at the end and beginning of the array.
				a.insert(a.begin(), 0);
				a.push_back(0);

				// Calculating the total number of placements.
				for (int i = 1; i < (int)a.size() - 1; i++) {
					if (a[i - 1] + a[i] + a[i + 1] == 0) {
						k--;
						i++;
					}
				}
				return k <= 0;
			}
	
	440) Maximize:
		Problem statement
			You have an integer ‘N’ and an array ‘X’ of ‘N’ integers.
			You need to maximize the value of the array, 
			which is equal to ⅀ '(X[i] - i)^2' from ‘i’ in the range ‘[0, N-1]’. 
			To do this, you can rearrange the elements of the given array.

			Determine the maximum value of the array you can get after rearranging the array ‘X’ elements.
			Example:
				'N' = 3, ‘X' = [1,2,1] 
				If we rearrange our array 'X' to '[2, 1, 1]' .
				Then our answer will be (0-2)^2 + (1-1)^2 + (1-2)^2 = 4 + 0 + 1 = 5.
				For array ‘[1, 1, 2]’ value will be equal to ‘1 + 0 + 0 = 1’.
				For array ‘[1, 2, 1]’ value will be equal to ‘1 + 1 + 1 = 3’.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^4
				1<= X[i] <= 10^5

				Time Limit: 1 sec
			Sample Input 1 :
				2
				2
				1 2  
				3
				1 1 1 
				Sample Output 1 :
				4
				2
				Explanation Of Sample Input 1 :
				For test case 1: 

				From this array, we can have 2 arrays i.e. ‘[1,2]’ and ‘[2,1]’
				For ‘[1,2]’ the value will be equal to ‘ (1-0)^2 + (2-1)^2’ which is equal to 2.
				For ‘[2,1]’ the value will be equal to ‘ (2-0)^2 + (1-1)^2’ which is equal to 4.
				Hence answer is ‘4’             

				For test case 2:
				In this case, there is only one array you can get after rearranging elements of ‘X’.
				For array ‘[1,1,1]’ answer will be ‘1+0+1=2’.
				Hence the answer is ‘2’.
				Sample Input 2:
				2
				3
				1 2 3
				3
				10 12 3
				Sample Output 2:
				11
				226

		long long int maximize(int n, vector<int> x) {
			sort(x.begin(), x.end(), greater<int>());
			long long ans=0;

			for(int i=0; i<n; i++)
				ans += pow((x[i] - i), 2);

			return ans;
		}

	441) Possible Words From A Phone Number: (Lecture-38)
		Problem statement
			After years of research, Ninja is finally able to invent the time machine,
			and now he is back to the good old days when T9 keypads were being used in mobile phones.

			Being a curious person, Ninja wants to find out all possible strings that can be formed by pressing the keys of the phone.
			Formally, you are given a string S, 
			that consists of digits from 2-9 (both inclusive), 
			your task is to find out all the possible strings that can be formed 
			from the input string by mapping the digits to the letters as in a T9 keypad. 
			Then, print the strings in a lexicographically sorted order.


			For Example:
				If S = “34”, then all the possible letters that can be formed 
				from string S are {“dg”, “dh”, “di”, “eg”, “eh”, “ei”, “fg”, “fh”, “fi”}.
			Constraints:
				1 <= T <= 10
				1 <= |S| <= 7
				where |S| denotes the length of the string S.
				Time limit: 1 sec.

			Sample Input 1:
				1
				5
				Sample Output 1:
				j k l
				Explanation for sample 1:
				For the first test case, the words that can be formed from the string S are {“j”, “k”, “l”}.
				Sample Input 2:
				2
				37
				79
				Sample Output 2:
				dp dq dr ds ep eq er es fp fq fr fs
				pw px py pz qw qx qy qz rw rx ry rz sw sx sy sz
				Explanation for sample 2:
				For the first test case, the words that can be formed from the string S are 
				{“dp”, “dq”, “dr”, “ds”, “ep”, “eq”, “er”, “es”, “fp”, “fq”, “fr”, “fs”}.

				For the second test case, the words that can be formed from the string S is are
				{“pw”, “px”, “py”, “pz”, “qw”, “qx”, “qy”, “qz”, “rw”, “rx”, “ry”, “rz”, “sw”, “sx”, “sy”, “sz”}.

		#include <bits/stdc++.h> 
		map<int, string> mapper ={{2,"abc"},
							{3,"def"},
							{4,"ghi"},
							{5,"jkl"},
							{6,"mno"},
							{7,"pqrs"},
							{8,"tuv"},
							{9,"wxyz"}};

		vector<string> findPossibleWords(string s) {
			vector<string> ans;

			string s1 = mapper[s[0] - '0'];
			for(char ch : s1)
				ans.push_back(string(1, ch));		// this syntax is to conver the char to string

			for(int i=1; i<s.length(); i++){
				string s2 = mapper[s[i] - '0'];
				vector<string> temp;
				for(int z=0; z<ans.size(); z++){
					for(int traversS2=0; traversS2 < s2.size(); traversS2++)
						temp.push_back(ans[z] + s2[traversS2]);	
				}
				ans = temp;
			}
			
			sort(ans.begin(), ans.end());
			return ans;
		}

		// or
			#include <bits/stdc++.h>
			map<char, string> Mapper = {
										{'2', "abc"},
										{'3', "def"},
										{'4', "ghi"},
										{'5', "jkl"},
										{'6', "mno"},
										{'7', "pqrs"},
										{'8', "tuv"},
										{'9', "wxyz"},
									};

			vector<string> findPossibleWords(string s){
				vector<string> ans;

				string temp = Mapper[s[0]];
				for(char ch: temp){
					ans.push_back(string(1, ch));
				}

				for(int i=1; i<s.size(); i++){
					string crntS = Mapper[s[i]];
					vector<string> temp;
					for(int z=0; z<ans.size(); z++){
						for(int x=0; x<crntS.size(); x++){
							temp.push_back(ans[z]+crntS[x]);
						}
					}
					ans = temp;
				}

				sort(ans.begin(), ans.end());
				return ans;
			}

		// Another Approach:
			#include <bits/stdc++.h> 
			map<int, string> mapper = {	{2,"abc"},
										{3,"def"},
										{4,"ghi"},
										{5,"jkl"},
										{6,"mno"},
										{7,"pqrs"},
										{8,"tuv"},
										{9,"wxyz"}};

			void Gen(string main, string t, int indx, vector<string> &ans){
				if(indx >= main.size()){
					ans.push_back(t);
					return;
				}

				string value = mapper[main[indx]-'0'];
				for(int i=0; i<value.size(); i++){
					t.push_back(value[i]);
					Gen(main, t, indx+1, ans);
					t.pop_back();
				}
			}

			vector<string> findPossibleWords(string s) {
				vector<string> res;
				string tempStr;
				int i=0;
				Gen(s, tempStr, i, res);
				return res;
			}

	442) Anagram Substring Search (Coding Ninja):
		Problem statement
			Given two strings ‘STR’ and ‘PTR’. 
			Find all the starting indices of ‘PTR’ anagram substring in ‘STR’. 
			Two strings are anagram if and only if one string can be converted into another string by rearranging the character.

			For example, ‘ABCD’ and ‘ACBD’ are two anagram strings because ‘ACBD’ 
			can be converted into ‘ABCD’ by rearranging the ‘B’ and ‘C’. 
			’ABA’ and ‘ABB’ are not anagram because we can’t convert ‘ABA’ 
			to ‘ABB’ by rearranging the characters of particular strings.

			‘ABACD’ and ‘CABAD’ are anagram because ‘ABACD’ can be converted into ‘CABAD’ 
			by rearranging the first ‘A’ with ‘C’ and second ‘A’ with ‘B’.

			Note:
				Strings ‘STR’ and ‘PTR’ consist only of English uppercases.
				Length of string ‘STR’ will always be greater than or equal to the length of string ‘PTR’.
				The index is ‘0’ based.
				In case, there is no anagram substring then return an empty sequence.

			Explanation:
				For example, the given ‘STR’ is ‘BACDGABCD’ and ‘PTR’ is ‘ABCD’. Indices are given

				0-3 in ‘STR’ index 0,1,2,3 are ‘BACD’ and it is an anagram with ‘ABCD’
				1-4 in ‘STR’ index 1,2,3,4 are ‘ACDG’ and it is not anagram with ‘ABCD’
				2-5 in ‘STR’ index 2,3,4,5 are ‘CDGA’ and it is not anagram with ‘ABCD’
				3-6 in ‘STR’ index 3,4,5,6 are ‘DGAB’ and it is not anagram with ‘ABCD’
				4-7 in ‘STR’ index 4,5,6,7 are ‘GABC’ and it is not anagram with ‘ABCD’
				5-8 in ‘STR’ index 5,6,7,8 are ‘ABCD’ and it is an anagram with ‘ABCD’
				Hence there are 2 starting indices of substrings in the string ‘STR’ 
				that are anagram with given ‘PTR’  which are index 0 and 5.

			Constraints:
				1 <= 'T' <= 50
				1 <= 'N', 'M' <= 10 ^ 4
				Where ‘T’ is the total number of test cases, 
				‘N’ denotes the number of characters in the first given string ‘STR’ 
				and ‘M’ denotes the number of characters in the second given string ‘PTR’. 
				Strings ‘STR’ and ‘PTR’ only consist of English uppercase alphabets.

				Time limit: 1 second.
			Sample Input 1:
				2
				10 3
				CBAEBABACD
				ABC
				5 2
				ABADE
				BA
				Sample Output 1:
				0 6
				0 1
				Explanation of sample input 1::
				Test Case 1:

				‘str’ is ‘CBAEBABACD’ and ‘ptr’ is ‘ABC’

				0-2 in ‘str’ index 0,1,2 are ‘CBA’ and it is an anagram with ‘ABC’
				1-3 in ‘str’ index 1,2,3 are ‘BAE’ and it is not anagram with ‘ABC’
				2-4 in ‘str’ index 2,3,4 are ‘AEB’ and it is not anagram with ‘ABC’
				3-5 in ‘str’ index 3,4,5 are ‘EBA’ and it is not anagram with ‘ABC’
				4-6 in ‘str’ index 4,5,6 are ‘BAB’ and it is not anagram with ‘ABC’
				5-7 in ‘str’ index 5,6,7 are ‘ABA’ and it is not anagram with ‘ABC’
				6-8 in ‘str’ index 6,7,8 are ‘BAC’ and it is an anagram with ‘ABC’
				7-9 in ‘str’ index 7,8,9 are ‘ACD’ and it is not anagram with ‘ABC’

				Hence there are only two anagram substrings in the given string ‘str’ 
				that are anagram with given string  ‘ptr’ which are ‘CBA’ and ‘BAC’
				and starting indices of respective anagram substrings are 0 and 6.


				Test case 2:

				‘str’ is ‘ABADE’ and ‘ptr’ is ‘BA’.

				In the given string ‘ABADE’ the substring of length 2 starting with index 0 is ‘AB’
				which is an anagram with the string ‘BA’ and a substring of length 2 starting with
				index 1 is ‘BA’ which is also an anagram with the string ‘BA’. Because 0 and 1 are
				starting indices of the substrings, we return 0 and 1.
				Sample Input 2:
				2
				10 4
				BACDGABCDA
				ABCD
				7 1
				ABABABA
				A
				Sample Output 2:
				0 5 6
				0 2 4 6

		// Not Optimized:
			#include <bits/stdc++.h>
			bool areSame(int *p1, int *p2){
				for(int z=0; z<26; z++)
					if(p1[z] != p2[z])
						return false;
				return true;
			}

			vector<int> findAnagramsIndices(string str, string ptn, int n, int m) {
				vector<int> ans;

				// mapping for ptn
				int ptnArr[26] = {0};
				for(char ch: ptn)
					ptnArr[ch - 'A']++;

				for(int i=0; i<=(str.length()-ptn.length()); i++){
					string s1 = str.substr(i,ptn.size());
					
					// mapping for s1
					int s1Arr[26] = {0};
					for(char ch: s1)
						s1Arr[ch - 'A']++;

					if(areSame(ptnArr, s1Arr))
						ans.push_back(i);
				}
				return ans;
			}

		// Optimized:
			#include <bits/stdc++.h>
			bool areSame(int *p1, int *p2){
				for(int z=0; z<26; z++)
					if(p1[z] != p2[z])
						return false;
				return true;
			}

			vector<int> findAnagramsIndices(string str, string ptn, int n, int m) {
				vector<int> ans;

				// mapping for ptn
				int ptnArr[26] = {0};
				for(char ch: ptn)
					ptnArr[ch - 'A']++;

				string s1 = str.substr(0,ptn.size());
				
				// mapping for s1
				int s1Arr[26] = {0};
				for(char ch: s1)
					s1Arr[ch - 'A']++;

				
				if(areSame(ptnArr, s1Arr))
					ans.push_back(0);

				for(int i=1, j=ptn.size(); i<=(str.length()-ptn.length()) && j < str.length(); i++, j++){

					// map char at i (decrement)
					s1Arr[str[i-1] - 'A']--;

					// map char at j (increment)
					s1Arr[str[j]- 'A']++;

					if(areSame(ptnArr, s1Arr))
						ans.push_back(i);
				}
				return ans;
			}
	
	443) Reverse Stack Using Recursion:
		Problem statement
			Reverse a given stack of 'N' integers using recursion. 
			You are required to make changes in the input parameter itself.
			Note: You are not allowed to use any extra space other than the internal stack space used due to recursion.
			Example:
				Input: [1,2,3,4,5] 
				Output: [5,4,3,2,1]

			Sample Input 1 :
				3
				2 1 3
				Sample Output 1 :
				3 1 2
				Explanation to Sample Input 1 :
				Reverse of a give stack is 3 1 2 where first element becomes last and last becomes first.                   
				Sample Input 2 :
				2
				3 2
				Sample Output 2 :
				2 3
			Constraints :
				0 <= N <= 10^3
				Where 'N' is the number of elements in the given stack.
				Time Limit: 1 sec

		void reverseStack(stack<int> &stack) {
			queue<int> Q;
			while(!stack.empty()){
				Q.push(stack.top());
				stack.pop();
			}

			while(!Q.empty()){
				stack.push(Q.front());
				Q.pop();
			}
		}
	
	444) Prime Number of Set Bits in Binary Representation:
		Problem statement:
			Given two integers left and right, return the count of numbers in 
			the inclusive range [left, right] having a prime number of set bits in their binary representation.
			Recall that the number of set bits an integer has is the number of 1's present when written in binary.
			For example, 21 written in binary is 10101, which has 3 set bits.
			Example 1:
				Input: left = 6, right = 10
				Output: 4
				Explanation:
				6  -> 110 (2 set bits, 2 is prime)
				7  -> 111 (3 set bits, 3 is prime)
				8  -> 1000 (1 set bit, 1 is not prime)
				9  -> 1001 (2 set bits, 2 is prime)
				10 -> 1010 (2 set bits, 2 is prime)
				4 numbers have a prime number of set bits.

			Example 2:
				Input: left = 10, right = 15
				Output: 5
				Explanation:
				10 -> 1010 (2 set bits, 2 is prime)
				11 -> 1011 (3 set bits, 3 is prime)
				12 -> 1100 (2 set bits, 2 is prime)
				13 -> 1101 (3 set bits, 3 is prime)
				14 -> 1110 (3 set bits, 3 is prime)
				15 -> 1111 (4 set bits, 4 is not prime)
				5 numbers have a prime number of set bits.
				
			Constraints:
				1 <= left <= right <= 10^6
				0 <= right - left <= 10^4
	
		class Solution {
			private:
			bool isPrime(int a){
				if(a == 1)
					return 0;
				else if(a == 2)
					return 1;
				
				for(int i=2; i<=(a/2); i++)
					if((a % i) == 0)
						return 0;
				return 1;
			}
			public:
			int countPrimeSetBits(int left, int right) {
				int cnt=0;
				while(left <= right){
					if(isPrime(__builtin_popcount(left)))
						cnt++;
					left++;   
				}
				return cnt;
			}
		};

	445) Counting Bits:
		Problem statement:
			Given an integer n, return an array ans of length n + 1 
			such that for each i (0 <= i <= n), 
			ans[i] is the number of 1's in the binary representation of i.

			Example 1:
				Input: n = 2
				Output: [0,1,1]
				Explanation:
				0 --> 0
				1 --> 1
				2 --> 10

			Example 2:
				Input: n = 5
				Output: [0,1,1,2,1,2]
				Explanation:
				0 --> 0
				1 --> 1
				2 --> 10
				3 --> 11
				4 --> 100
				5 --> 101
				
			Constraints:
				0 <= n <= 10^5
			
		Follow up:
			It is very easy to come up with a solution with a runtime of O(n log n). 
			Can you do it in linear time O(n) and possibly in a single pass?
				class Solution {
					public:
					vector<int> countBits(int n) {
						vector<int> ans;
						int i=0;
						while(i <= n){
							ans.push_back(__builtin_popcount(i++));
						}
						return ans; 
					}
				};

				// Optimized:
					class Solution {
						public:
						vector<int> countBits(int n) {
							vector<int> ans(n+1,0);
							int i=0;
							while(i <= n){
								ans[i] = __builtin_popcount(i);
								i++;
							}
							return ans; 
						}
					};
			
			Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?
				class Solution {
					private:
					int countSetBits(int a){
						int cnt=0;
						while(a){
							if(a&1)
								cnt++;
							a >>=1;
						}
						return cnt;
					}
					public:
					vector<int> countBits(int n) {
						vector<int> ans(n+1,0);
						int i=0;
						while(i <= n){
							ans[i] = countSetBits(i);
							i++;
						}
						return ans; 
					}
				};

	446) Smallest Value of the Rearranged Number:
		Problem statement:
			You are given an integer num. 
			Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.
			Return the rearranged number with minimal value.
			Note that the sign of the number does not change after rearranging the digits.

			Example 1:
				Input: num = 310
				Output: 103
				Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310. 
				The arrangement with the smallest value that does not contain any leading zeros is 103.

			Example 2:
				Input: num = -7605
				Output: -7650
				Explanation: Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567.
				The arrangement with the smallest value that does not contain any leading zeros is -7650.

			Constraints:
				-10^15 <= num <= 10^15

		class Solution {
			public:
			long long smallestNumber(long long num) {
				vector<int> v;
				long long ans=0;
				int temp = 1;

				if(num >= 0){
					while(num){
						v.push_back(num%10);
						num /= 10;
					}
					sort(v.begin(), v.end());
					
					// find the first non-zero element
					for(int i=0; i<v.size(); i++){
						if(v[i] != 0){
							swap(v[0], v[i]);
							break;
						}
					}

					int i=0;
					while(i<v.size())
						ans = ans*10 + v[i++];

				}else{
					temp = -1;
					num *= temp;
					while(num){
						v.push_back(num%10);
						num /= 10;
					}
					sort(v.begin(), v.end(), greater<int>());
					int i=0;
					while(i<v.size())
						ans = (ans*10) + v[i++];
				}
				return ans*temp;
			}
		};
	
	447) Longest Palindromic Substring:
		Problem statement
			You are given a string ‘S’ of length ‘N’.
			You must return the longest palindromic substring in ‘S’.
			Note: Return any of them in case of multiple substrings with the same length.
			Example:
			Input: ‘S’ =’badam’
			Output: ‘ada’
			‘ada’ is the longest palindromic substring, and it can be proved that it is the longest possible palindromic substring.
			Constraints :
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				‘a’ <= ‘S[i]’ <= ‘Z’   
				Time Limit: 1 sec
			Sample Input 1 :
				2
				6
				adccdb
				6
				aaabbb
				Sample Output 1 :
				dccd
				aaa
				Explanation Of Sample Input 1 :
				For test case 1:

				‘S’ =’adccdb’

				‘dccd’ is the longest palindromic substring, and it can be proved that it is the longest possible palindromic substring.
				Hence we return ‘dccd’.

				For test case 2:

				‘S’ =’aaabbb’

				‘aaa’ is the longest palindromic substring, and it can be proved that it is the longest possible palindromic substring.
				Hence we return ‘dccd’.
				‘Bbb’ is also a valid answer.
				Sample Input 2 :
				2
				5
				hello
				1
				a 
				Sample Output 2 :
				ll
				a

		// Not Optimized:
			bool checkPalin(string s){
				for(int i=0; i<(s.size()/2); i++)
					if(s[i] != s[s.size()-1-i])
						return 0;
				return 1;
				}

				string longestPalindromicSubstring(string &s) {
				int i=0;
				string ans = string (1, s[0]);
				int cnt=1;
				while(i<s.size()-1){
					string temp = s.substr(i,cnt);
					if(temp.size() > ans.size()){
						if(checkPalin(temp))
							ans = temp;
					}
					cnt++;
					if(cnt > s.size()){
						cnt=1;
						i++;
					}
				}
				return ans;
			}
	
		// Optimized: ❌Pending
			string longestPalindromicSubstring(string &s) {
				// Preprocess the string to insert special characters to handle even-length palindromes
				string processed = "#";
				for (char c : s) {
					if (isalpha(c)) {
						processed += tolower(c);
						processed += '#';
					}
				}

				int n = processed.size();
				vector<int> palLength(n, 0); // Array to store the length of the palindrome centered at each index
				int center = 0, right = 0; // Center and right boundary of the current palindrome being processed

				for (int i = 1; i < n - 1; ++i) {
					// Mirror index of the current index i
					int mirror = 2 * center - i;

					// Check if the current index i is within the right boundary of the current palindrome
					if (i < right)
						palLength[i] = min(right - i, palLength[mirror]);

					// Expand palindrome at current index i
					while (i - palLength[i] > 0 && i + palLength[i] < n - 1 &&
							processed[i - palLength[i] - 1] == processed[i + palLength[i] + 1])
						palLength[i]++;

					// If the expanded palindrome at index i expands beyond the current right boundary,
					// update the center and right boundary
					if (i + palLength[i] > right) {
						center = i;
						right = i + palLength[i];
					}
				}

				// Find the maximum length palindrome
				int maxLen = 0, maxCenter = 0;
				for (int i = 1; i < n - 1; ++i) {
					if (palLength[i] > maxLen) {
						maxLen = palLength[i];
						maxCenter = i;
					}
				}

				// Extract the longest palindromic substring from the processed string
				int start = (maxCenter - maxLen) / 2;
				return s.substr(start, maxLen);
			}

	448) Top K Frequent Words:
		Problem statement:
			Given an array of strings words and an integer k, return the k most frequent strings.
			Return the answer sorted by the frequency from highest to lowest. 
			Sort the words with the same frequency by their lexicographical order.

			Example 1:
				Input: words = ["i","love","leetcode","i","love","coding"], k = 2
				Output: ["i","love"]
				Explanation: "i" and "love" are the two most frequent words.
				Note that "i" comes before "love" due to a lower alphabetical order.

			Example 2:
				Input: words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
				Output: ["the","is","sunny","day"]
				Explanation: "the", "is", "sunny" and "day" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
			
			Constraints:
				1 <= words.length <= 500
				1 <= words[i].length <= 10
				words[i] consists of lowercase English letters.
				k is in the range [1, The number of unique words[i]]
		Follow-up: Could you solve it in O(n log(k)) time and O(n) extra space?

		class Solution {
			private:
			static bool cmpValueBased(pair<string, int> a, pair<string, int> b){
				if(a.second == b.second)
					return a.first < b.first;
				return a.second > b.second;
			}
			public:
			vector<string> topKFrequent(vector<string>& words, int k) {
				vector<string> ans;
				map<string, int> Freq;

				for(string s: words)
					Freq[s]++;

				// storing the map into vector of pais
				vector<pair<string, int>> holder;
				for(auto i: Freq)
					holder.push_back(i);

				sort(holder.begin(), holder.end(), cmpValueBased);
				
				int i=0;
				while(k){
					ans.push_back(holder[i++].first);
					k--;
				}
				return ans;
			}
		};
	
	449) Power Set (GFG):
		Problem statement:
			Given a string s of length n, 
			find all the possible subsequences of the string s in lexicographically-sorted order.

			Example 1:
				Input : 
				s = "abc"
				Output: 
				a ab abc ac b bc c
				Explanation : 
				There are a total 7 number of subsequences possible 
				for the given string, and they are mentioned above 
				in lexicgraphically sorted order.

			Example 2:
				Input: 
				s = "aa"
				Output: 
				a a aa
				Explanation : 
				There are a total 3 number of subsequences possible 
				for the given string, and they are mentioned above 
				in lexicgraphically sorted order.

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function AllPossibleStrings() 
				which takes a string s as the input parameter and returns a 
				list of all possible subsequences (non-empty) that can be formed from s in lexicographically-sorted order.

			Expected Time Complexity: O(n*2n)
			Expected Space Complexity: O(n * 2n)

			Constraints: 
				1 <= n <= 16
				s will constitute of lower case english alphabets

		class Solution{
			private:
			void solve(string main, int i, string temp, vector<string> &ans){
				if(i >= main.size()){
					if(temp.size()>0)
						ans.push_back(temp);
						
					return ;
				}
				
				// exclude call
				solve(main, i+1, temp, ans);
				
				// include call
				temp.push_back(main[i]);
				solve(main, i+1, temp, ans);
			}
			
			public:
			vector<string> AllPossibleStrings(string s){
				vector<string> ans;
				string temp;
				int i=0;
				solve(s, i, temp, ans);
				sort(ans.begin(), ans.end());
				return ans;
			}
		};

	450) Left Rotate Matrix K times:
		Problem statement:
			Given three integers N, M, and K and a matrix Mat of dimensions NxM. Left rotate the matrix K times.

			Example 1:
				Input:
				N=3,M=3,K=1
				Mat=[[1,2,3],[4,5,6],[7,8,9]]
				Output:
				2 3 1
				5 6 4
				8 9 7
				Explanation:
				Left rotating the matrix once gives this result.

			Example 2:
				Input:
				N=3,M=3,K=2
				Mat=[[1,2,3],[4,5,6],[7,8,9]]
				Output:
				3 1 2
				6 4 5
				9 7 8
				Explanation:
				Left rotating the matrix twice gives this result

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function rotateMatrix() 
				which takes the three integers N, M, K, and 
				the matrix Mat and returns the matrix Mat left rotated K times.

			Expected Time Complexity:O(N*M)
			Expected Auxillary Space:O(N*M)

			Constraints:
				1<=N,M,Mat[i][j]<=1000
				1<=K<=10000

		// Not optimized:
			class Solution {
				public:
				vector<vector<int>> rotateMatrix(int N, int M, int K, vector<vector<int>> Mat) {
					vector<vector<int>> ans;
					int value = K;
					
					for(int i=0; i<N; i++){
						vector<int> temp;
						K=value;
						for(int j=0; j<M; j++){
							temp.push_back(Mat[i][j]);
						}
						while(K--){
							temp.push_back(temp.front());
							temp.erase(temp.begin());
						}
						ans.push_back(temp);
					}
					return ans;
				}
			};

		// Optimized:
			class Solution {
				public:
				vector<vector<int>> rotateMatrix(int N, int M, int K, vector<vector<int>> Mat) {
					vector<vector<int>> ans;
					int value = K;
					
					for(int i=0; i<N; i++){
						vector<int> temp;
						K=value;
						for(int j=0; j<M; j++){
							temp.push_back(Mat[i][j]);
						}

						int f=0;
						while(K--){
							temp.push_back(temp[f++]);
						}

						temp.erase(temp.begin(), temp.begin()+f);
						ans.push_back(temp);
					}
					return ans;
				}
			};	
	
	451) C++ Matrix Rotation by 180 degree:
		Problem statement:
			Given a square matrix of size N X N, turn it by 180 degrees in anticlockwise direction without using extra memory.
			Example 1:
				Input: N = 4, 
				matrix = {{1, 2, 3, 4}, 
						{5, 6, 7 ,8}, 
						{9, 10, 11, 12},
						{13, 14, 15, 16}}
				Output: {{16, 15, 14, 13}, 
					{12, 11, 10, 9}, 
					{8, 7, 6, 5}, 
					{4, 3, 2, 1}}

			Example 2:
				Input: N = 2,
				matrix = {{1, 2},
						{3, 4}}
				Output: {{4, 3}, 
					{2, 1}}
			
			Your Task:
				You don't need to read or print anything. 
				Your task is to complete the function rotate() 
				which takes matrix as input parameter and rotate 
				the matrix by 180 degree without using extra memory. 
				You have to rotate the matrix in-place which means you have to modify the input matrix directly.
			

			Expected Time Complexity: O(N2)
			Expected Space Complexity: O(1)

			Constraints:
				1 ≤ N ≤ 500

		class Solution {
			public:
			void rotate(vector<vector<int>> & matrix) {
				vector<vector<int>> holder;
				for(int i=matrix.size()-1; i>=0; i--){
					vector<int> temp;
					for(int j=matrix[0].size()-1; j>=0; j--){
						temp.push_back(matrix[i][j]);
					}
					holder.push_back(temp);
				}
				matrix = holder;
			}
		};

		// without using extra space SC:O(1):
			class Solution {
				public:
				void rotate(vector<vector<int>> & matrix) {
					
					// if matrix is of odd size
					// changing the middle row in reverse
					if(matrix.size() & 1){
						int row = matrix.size()/2;
						for(int j=0; j<matrix.size()/2; j++)
							swap(matrix[row][j], matrix[row][matrix.size()-j-1]);
					}
					
					for(int i=0; i<matrix.size()/2; i++)
						for(int j=0; j<matrix[0].size(); j++)
							swap(matrix[i][j], matrix[matrix.size()-1-i][matrix.size()-1-j]);
				}
			};

	452) Arranging the array:
		Problem statement:
			You are given an array of size N. Rearrange the given array in-place 
			such that all the negative numbers occur before all non-negative numbers.
			(Maintain the order of all -ve and non-negative numbers as given in the original array).

			Example 1:
				Input:
				N = 4
				Arr[] = {-3, 3, -2, 2}
				Output:
				-3 -2 3 2
				Explanation:
				In the given array, negative numbers
				are -3, -2 and non-negative numbers are 3, 2. 

			Example 2:
				Input:
				N = 4
				Arr[] = {-3, 1, 0, -2}
				Output:
				-3 -2 1 0
				Explanation:
				In the given array, negative numbers
				are -3, -2 and non-negative numbers are 1, 0.

			Your Task:  
				You don't need to read input or print anything.
				Your task is to complete the function Rearrange() 
				which takes the array Arr[] and its size N as inputs 
				and returns the array after rearranging with spaces between the elements of the array.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 10^5
				-10^9 ≤ Elements of array ≤ 10^9

		class Solution {
			public:
			void Rearrange(int arr[], int n) {
				vector<int> neg, pos;
				
				for(int i=0; i<n; i++)
					if(arr[i] < 0)
						neg.push_back(arr[i]);
					else
						pos.push_back(arr[i]);
						
				int i=0;
				for(int n: neg)
					arr[i++] = n;
				
				for(int n: pos)
					arr[i++] = n;
			}
		};

		// without using extra space SC: O(1)
			❌Pending

	453) Maximize Number of 1's (Refer POTD 435):
		Problem statement:
			Given a binary array arr of size N and an integer M. 
			Find the maximum number of consecutive 1's produced by flipping at most M 0's.
			
			Example 1:
				Input:
				N = 3
				arr[] = {1, 0, 1}
				M = 1
				Output:
				3
				Explanation:
				Maximum subarray is of size 3
				which can be made subarray of all 1 after
				flipping one zero to 1.

			Example 2:
				Input:
				N = 11
				arr[] = {1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1}
				M = 2
				Output:
				8
				Explanation:
				Maximum subarray is of size 8
				which can be made subarray of all 1 after
				flipping two zeros to 1.
			
			Your Task:
				Complete the function findZeroes() which takes array arr and two integers n, m,
				as input parameters and returns an integer denoting the answer.
			
			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)
			
			Constraints:
				1 <= N <= 10^7
				0 <= M <= N
				0 <= arri <= 1

		// Not optimized:
			class Solution{
				public:
				// m is maximum of number zeroes allowed to flip
				// n is size of array
				int findZeroes(int arr[], int n, int m) {
					int mxCnt=0,cnt=0, k=m;
					for(int i=0; i<n; i++){
						cnt=0, m=k;
						for(int j=i; j<n; j++){
							if(arr[j]== 0)
								m--;
							
							if(m < 0) break;
							cnt++;
						}
						mxCnt = max(mxCnt, cnt);
					}
					return mxCnt;
				}
			};

		// or
			int maxOnes(vector<int>& arr, int k) {
				int mx=0, n = arr.size();
				for(int i=0; i<n; i++){
					int cur = 0, j;
					for(j=i; j<n; j++){
						if(arr[j] == 0) cur++;
						if(cur > k) break;
					}
					mx = max(mx, j-i);
				}	
				return mx;
			}

		// Optimized:
			class Solution{
				public:
				// m is maximum of number zeroes allowed to flip
				// n is size of array
				int findZeroes(int arr[], int n, int m) {
					int left, right, zeroCnt=0;
					left=right=0;
					int ans=0, cnt=0;
					
					for(right; right<n; right++){
						if(arr[right] == 0)
							zeroCnt++;
						
						while(zeroCnt > m){
							if(arr[left] == 0)
								zeroCnt--;
							left++;
						}
						ans = max(ans, right-left+1);
					}
					return ans;
				}  
			};

		// Or
			class Solution {
				public: // k is the maximum number of zeros allowed to flip
				int maxOnes(vector<int>& arr, int k) {
					int maxLen=0,n = arr.size();
					int s,e, count = 0;
					s = e = 0;
					
					// create the first window
					while (e < n) {
						// Expand the window
						if (arr[e] == 0) count++;
				
						// Shrink the window if count exceeds k
						while (count > k) {
							if (arr[s] == 0) count--;
							s++;
						}
				
						// Calculate the maximum length of the valid window
						maxLen = max(maxLen, e - s + 1);
				
						// Move the end pointer
						e++;
					}
					return maxLen;
				}
			};

	454) Transpose of a Matrix: (Refer Q. 219)
		-In transpose of matrix, all rows become columns and vice versa.
		 if mat have  n rows and m columns then the transposed matrix will be of size m rows & n cols.
		 Problem statement
			You are given a matrix ‘MAT’. 
			Print and return the transpose of the matrix. 
			The transpose of a matrix is obtained by changing rows to columns and columns to rows. 
			In other words, transpose of a matrix A[][] is obtained by changing A[i][j] to A[j][i].

			For example:
				Let matrix be : 
				1 2
				3 4

				Then transpose of the matrix will be: 
				1 3
				2 4
			Constraints :
				1 <= T <= 10
				1 <= M, N <= 3*10^3
				0 <= MAT[i][j] <= 10^7
				Time Limit: 1 sec

			Sample Input 1 :
				2
				2 2
				1 2
				3 4
				3 2
				1 2 
				2 3
				3 4
				Sample Output 1 :
				1 3
				2 4
				1 2 3
				2 3 4
				Explanation For Sample Input 1 :
				For test case 1: 
				The transpose of the matrix will be: 
				1 3
				2 4

				For test case 2:    
				The transpose of the matrix will be: 
				1 2 3
				2 3 4
				Sample Input 2 :
				2
				2 3
				1 2 3 
				3 4 5
				2 1
				1
				2
				Sample Output 2 :
				1 3
				2 4 
				3 5
				1 2

		// Brute force:
			#include <bits/stdc++.h> 
			vector<vector<int>> transpose(int m, int n, vector<vector<int>> &mat) {
				vector<vector<int>> ans;
				for (int col = 0; col < n; col++) {
					vector<int> temp;
					for (int row = 0; row < m; row++)
						temp.push_back(mat[row][col]);
					ans.push_back(temp);
				}
				return ans;
			}

		// creating vector with n rows & m cols
			#include <bits/stdc++.h> 
			vector<vector<int>> transpose(int m, int n, vector<vector<int>> &mat){
				int rows = m, cols=n;
				// creating vector of (cols) n rows & (rows) m cols.
				vector<vector<int>> ans (cols, vector<int>(rows));

				for(int i=0; i<rows; i++){
					for(int j=0; j<cols; j++)
						ans[j][i] = mat[i][j];
				}
				return ans;
			}

	455) Spiral Matrix:
		Problem statement
			You are given a 2D matrix ‘MATRIX’ of ‘N’*’M’ dimension. You have to return the spiral traversal of the matrix.

			Example:
				Input:
				MATRIX = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ]
				Output:
					1 3 5 7 20 60 34 30 23 10 11 16

				Explanation: Starting from the element in the first row and the first column, 
				traverse from left to right (1 3 5 7), then top to bottom (20 60), then right
				to left (34 30 23), then bottom to up (10) and then left to right (11 16).
			Constraints:
				1 <= N, M <= 10^5
				1 <= MATRIX [ i ] [ j ] <= 10^9
				The sum of N*M over all test cases is less than 2*10^5.
				Time Limit: 1 sec
			Sample Input 1:
				3 3
				1 3 7
				10 12 15
				19 20 21
				Sample Output 1:
				1 3 7 15 21 20 19 10 12
				Explanation Of Sample Input 1:
				Input:
				MATRIX = [ [1, 3, 7], [10, 12, 15], [19, 20, 21] ], 
				Output:
				1 3 7 15 21 20 19 10 12

				Explanation: Starting from the element in the first row and the first column, 
				traverse from left to right (1 3 7), then top to bottom (15 21), then right 
				to the left (20 19), then bottom to up (10) and then left to right (12).
				Sample Input 2:
				4 4
				1 5 9 13
				14 15 16 17
				19 20 21 50
				59 60 71 80
				Sample Output 2:
				1 5 9 13 17 50 80 71 60 59 19 14 15 16 21 20

		vector<int> spiralMatrix(vector<vector<int>>&MATRIX) {
			int sr, sc, er, ec;
			sr=sc=0;
			er = MATRIX.size()-1;
			ec = MATRIX[0].size()-1;

			int ttlElements = (er+1) * (ec+1);
			int cnt=0;

			vector<int> ans;
			while(cnt < ttlElements){

				// for start row
				for(int i=sc; i<=ec && cnt < ttlElements; i++){
					ans.push_back(MATRIX[sr][i]);
					cnt++;
				}
				sr++;

				// for end col
				for(int i=sr; i<=er && cnt < ttlElements ; i++){
					ans.push_back(MATRIX[i][ec]);
					cnt++;
				}
				ec--;

				// for end row
				for(int i=ec; i>=sc && cnt < ttlElements; i--){
					ans.push_back(MATRIX[er][i]);
					cnt++;
				}
				er--;
				
				// for start col
				for(int i=er; i>=sr && cnt < ttlElements; i--){
					ans.push_back(MATRIX[i][sc]);
					cnt++;
				}
				sc++;        
			}
			return ans;
		}

	456) Search In A Sorted 2D Matrix:
		Problem statement
			You are given a 2D matrix ‘MATRIX’ of ‘N’*’M’ dimension. 
			You must check whether a given number ‘target’ is present in the matrix.
			The following properties apply to the given matrix:
				1. In each row, integers are sorted from left to right.
				2. Each row's first integer is greater than the previous row's last integer.
			Example:
			Input:
			'MATRIX' = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ], 'TARGET' = 3 
			Output:1
			Explanation: Since the given number ‘TARGET’ is present in the matrix, we return true.
			Sample Input 1:
				3 3
				1 3 7
				10 12 15
				19 20 21
				12
				Sample Output 1:
				1
				Explanation Of Sample Input 1:
				Input:
				'MATRIX' = [ [1, 3, 7], [10, 12, 15], [19, 20, 21] ], 'TARGET' = 12 
				Output: 1

				Explanation: Since the given number ‘TARGET’ is present in the matrix, we return true.
				Sample Input 2:
				4 4
				1 5 9 13
				14 15 16 17
				19 20 21 50
				59 60 71 80
				80
				Sample Output 2:
				1
			Constraints:
				1 <= 'N', 'M' <=10^5
				1 <= 'MATRIX [ i ] [ j ]', 'TARGET' <= 10^9
				The sum of N*M over all test cases is less than 2*10^5.
				Time Limit: 1 sec

		// Linear search Not Optimized :
			bool searchElement(vector<vector<int>> &MATRIX, int target) {
				for(int i=0; i<MATRIX.size(); i++)
					for(int j=0; j<MATRIX[0].size(); j++)
						if(target == MATRIX[i][j])
							return 1;
				return 0;
			}

		// Binary Search (Optimized)
			bool searchElement(vector<vector<int>> &MATRIX, int target) {
				// need to check for every row
				int crntRow, s=0, e=MATRIX[0].size()-1, i;
				
				for(i=0; i<MATRIX.size(); i++){
					// checking the last element is greater than target
					// if last element is greater than target then the element is lies in current row
					if(MATRIX[i][MATRIX[0].size()-1] >= target){
						crntRow= i;
						break;
					}
				}

				if(i >= MATRIX.size())
					return 0;

				// applying binary search
				while(s <= e){
					int mid = (s+e)/2;
					if(MATRIX[crntRow][mid] == target)
						return 1;
					else if(target > MATRIX[crntRow][mid])
						s = mid+1;
					else
						e = mid-1;
				}

				// element is not exist in given row
				return 0;
			}

	457) Print Like A Wave:
		Problem statement
			For a given two-dimensional integer array/list ‘ARR’ of size (N x M), 
			print the ‘ARR’ in a sine wave order, i.e., print the 
			first column top to bottom, next column bottom to top, and so on.
			
			For eg:-
				The sine wave for the matrix:-
				1 2
				3 4
				will be [1, 3, 4, 2].
				Detailed explanation ( Input/output format, Notes, Images )
			Constraints :
				1 <= T <= 10
				1 <= N <= 100
				1 <= M <= 100
				0 <= ARR[i][j] <= 100
				Time Limit: 1sec

			Sample Input 1:
				2
				3 4
				1 2 3 4
				5 6 7 8
				9 10 11 12
				4 4
				1 2 4 5
				3 6 8 10
				11 12 13 15
				16 14 9 7
				Sample Output 1:
				1 5 9 10 6 2 3 7 11 12 8 4
				1 3 11 16 14 12 6 2 4 8 13 9 7 15 10 5 
				Explanation For Sample Input 1:
				Here, the elements are printed in a form of a wave, first, the 0th column is printed 
				from top to bottom then the 1st column from bottom to top, and so on. Basically, 
				the even column is printed from top to bottom and the odd column in the opposite direction.
				Sample Input 2:
				2
				1 1
				3
				1 2
				6 5
				Sample Output 2:
				3
				6 5 

		#include <bits/stdc++.h> 
		vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols) {
			vector<int> ans;
			for(int i=0; i<mCols; i++)
				if(i&1)
					for(int j=nRows-1; j>=0; j--)
						ans.push_back(arr[j][i]);
				else
					for(int j=0; j<nRows; j++)
						ans.push_back(arr[j][i]);
			return ans;
		}

	458) Add to Array-Form of Integer:
		problem statement:
			The array-form of an integer num is an array representing its digits in left to right order.
			For example, for num = 1321, the array form is [1,3,2,1].
			Given num, the array-form of an integer, and an integer k,
			return the array-form of the integer num + k.

			Example 1:
				Input: num = [1,2,0,0], k = 34
				Output: [1,2,3,4]
				Explanation: 1200 + 34 = 1234

			Example 2:
				Input: num = [2,7,4], k = 181
				Output: [4,5,5]
				Explanation: 274 + 181 = 455

			Example 3:
				Input: num = [2,1,5], k = 806
				Output: [1,0,2,1]
				Explanation: 215 + 806 = 1021
			
			Constraints:
				1 <= num.length <= 10^4
				0 <= num[i] <= 9
				num does not contain any leading zeros except for the zero itself.
				1 <= k <= 10^4

		class Solution {
			public:
			vector<int> addToArrayForm(vector<int>& num, int k) {
				int speedup = ([](){cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);return 0;})();

				// here k is acting as carry
				for(int i=num.size()-1; i>=0; i--){
					num[i] += k;
					k = num[i] / 10;
					// breaking the loop if k (carry) is zero.
					if(!k) break;
					num[i] %= 10;
				}

				while(k){
					num.insert(num.begin(), k%10);
					k /= 10;
				}
				return num;
			}
		};

	459) Rotate by 90 degree:
		https://www.geeksforgeeks.org/problems/rotate-by-90-degree-1587115621/1
		Problem statement:
			Given a square matrix of size N x N. 
			The task is to rotate it by 90 degrees in anti-clockwise direction without using any extra space. 

			Example 1:
			Input:
			N = 3 
			matrix[][] = {{1, 2, 3},
					{4, 5, 6}
					{7, 8, 9}}
			Output: 
			Rotated Matrix:
			3 6 9
			2 5 8
			1 4 7

			Example 2:
				Input:
				N = 2
				matrix[][] = {{1, 2},
						{3, 4}}
				Output: 
				Rotated Matrix:
				2 4
				1 3

			Your Task:
				You dont need to read input or print anything. 
				Complete the function rotateby90() which takes the 
				matrix as input parameter and rotates it by 90 degrees 
				in anti-clockwise direction without using any extra space. 
				You have to modify the input matrix in-place. 

			Expected Time Complexity: O(N2)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 100
				1 <= matrix[][] <= 1000

		// using extra memory:
			class Solution {
				public:
				//Function to rotate matrix anticlockwise by 90 degrees.
				void rotateby90(vector<vector<int>>& matrix, int n) {
					vector<vector<int>> ans;
					for(int i=matrix.size()-1; i>=0; i--){
						vector<int> temp;
						for(int j=0; j<matrix.size(); j++){
							temp.push_back(matrix[j][i]);
						}
						ans.push_back(temp);
					}
					matrix = ans;
				} 
			};
			
		// without using extra memory O(1):
			class Solution {   
				public:
				//Function to rotate matrix anticlockwise by 90 degrees.
				void rotateby90(vector<vector<int> >& matrix, int n) {
					// sr & sc are start row & start col
					// er & ec are end row & end col
					int sr,sc;
					int er,ec;
					
					sr=sc=0;
					er=ec=n-1;
					
					while(sr < er){                         // sc < ec
						
						// need to re-iterate (n-1) time coz we want to rotate it by 90 degree
						int times= ec - sc;
						
						while(times--){
							int value = matrix[sr][sc];
							// for start col
							for(int i=sr+1; i<=er; i++){
								swap(matrix[i][sc], value);
							}
							
							// for end row
							for(int i=sc+1; i<=ec; i++){
								swap(matrix[er][i], value);
							}
							
							// for end col
							for(int i=er-1; i>=sr; i--){
								swap(matrix[i][ec], value);
							}
							
							// for start row
							for(int i=ec-1; i>=sc; i--){
								swap(matrix[sr][i], value);
							}
						}
						sr++; er--;
						sc++; ec--;
					}
				} 
			};

			// or simpel way:
				class Solution {   
					public:
					//Function to rotate matrix anticlockwise by 90 degrees.
					void rotateby90(vector<vector<int> >& matrix, int n) {
						
						// transpose generated
						for(int i=0; i<matrix.size(); i++)
							for(int j=i; j<matrix.size(); j++)
								swap(matrix[i][j], matrix[j][i]);
						
						// reversing columns
						for(int i=0; i<matrix.size()/2; i++)
							for(int j=0; j<matrix.size(); j++)
								swap(matrix[i][j], matrix[matrix.size()-1-i][j]);
					} 
				};
		
	460) Rotate by 90 degree:
		https://www.geeksforgeeks.org/problems/rotate-by-90-degree0356/1
		Problem statement:
			Given a square matrix[][] of size N x N. 
			The task is to rotate it by 90 degrees in an anti-clockwise direction without using any extra space.
			Example 1:
				Input:
				N = 3
				matrix[][] = [[1 2 3],
						[4 5 6],
						[7 8 9]]
			Output:
				3 6 9 
				2 5 8 
				1 4 7
			Your Task:
				You only need to implement the given function rotate(). 
				Do not read input, instead use the arguments given in the function. 

			Expected Time Complexity: O(N*N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 50
				1 <= matrix[][] <= 100

		/* matrix : given input matrix, you are require 
		to change it in place without using extra space */
		void rotate(vector<vector<int> >& matrix) {
			// transpose generator
			for(int i=0; i<matrix.size(); i++)
				for(int j=i; j<matrix.size(); j++)
					swap(matrix[i][j], matrix[j][i]);
			
			// reversing the columns so that it will like rotated by 90 degree
			for(int i=0; i<matrix.size()/2; i++)
				for(int j=0; j<matrix.size(); j++)
					swap(matrix[i][j], matrix[matrix.size()-1-i][j]);	
		}

	461) Rotate a 2D array without using extra space:
		https://www.geeksforgeeks.org/problems/rotate-a-2d-array-without-using-extra-space1004/1
		Problem statement:
			Given a N x N 2D matrix Arr representing an image. Rotate the image by 90 degrees (anti-clockwise). 
			You need to do this in place. Note that if you end up using an additional array, you will only receive partial score.
			Example 1:
				Input:
				N = 3
				Arr[][] = {{1,  2,  3}
						{4,  5,  6}
						{7,  8,  9}}
				Output:
				3  6  9 
				2  5  8 
				1  4  7 
				Explanation: The given matrix is rotated
				by 90 degree in anti-clockwise direction.

			Example 2:
				Input:
				N = 4
				Arr[][] = {{1,  2,  3,  4}
						{5,  6,  7,  8}
						{9, 10, 11, 12}
						{13, 14, 15, 16}}
				Output:
				4  8 12 16 
				3  7 11 15 
				2  6 10 14 
				1  5  9 13
				Explanation: The given matrix is rotated
				by 90 degree in anti-clockwise direction.
			Your Task:  
				You don't need to read input or print anything. 
				Your task is to complete the function rotate() which takes the 2D array of integers 
				arr and n as parameters and returns void. You need to change the array itself.

			Expected Time Complexity: O(N*N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 1000
				1 ≤ Arr[i][j] ≤ 1000

		//using extra space
			class Solution{
				public:	
					void rotateMatrix(vector<vector<int>>& arr, int n) {
						vector<vector<int>> ans;
						
						for(int i=arr[0].size()-1; i>=0; i--){
							vector<int> temp;
							for(int j=0; j<arr.size(); j++)
								temp.push_back(arr[j][i]);
								
							ans.push_back(temp);
						}
						arr = ans;
					}
				};

		// without using extra space O(1):
			class Solution{
				public:	
				void rotateMatrix(vector<vector<int>>& arr, int n) {
					// transpose
					for(int i=0; i<arr.size(); i++)
						for(int j=i; j<arr.size(); j++)
							swap(arr[i][j], arr[j][i]);
						
					for(int i=0; i<arr.size()/2; i++)
						for(int j=0; j<arr.size(); j++)
							swap(arr[i][j], arr[arr.size()-1-i][j]);
				}
			};

	462) Patternify:
		Problem statement
			You are given an integer ‘N’. Your task is to print a pattern with the following description
			The pattern will consist of ‘N’ lines.
			For 1 <= ‘i’ <= ‘N’ ‘i’th line consists of a string of ‘N’  + 1 - ‘i’  ‘*’ characters.

			For example:
				If ‘N’ is 5 then the pattern will be.

				*****
				****
				***
				**
				*
			Sample Input 1:
				2
				5
				3
				Sample Output 1:
				*****
				****
				***
				**
				*
				***
				**
				*
				Explanation of Sample Input 1:
				Test Case 1:

				Given ‘N’ = 5
				We will print the pattern as description first line will contain a string of 5 ‘*’, 
				the second line will contain a string of 4 ‘*’, the third line will contain 3 ‘*’, 
				the fourth line will contain 2 ‘*’ and the fifth line will contain 1 ’*’.

				Test Case 2:

				Given ‘N’ = 3
				For 1 <= ‘i’ <= 3  , ‘i’th line contains 4 - ’i’, ‘*’ characters.
				Sample Input 2:
				2
				1
				2
				Sample Output 2:
				*
				**
				* 
				Explanation of Sample Input 2:
				Test Case 1:

				Given ‘N' = 1
				There will be only 1 line and that will contain a single ‘*’.

				Test Case 2:

				Given ‘N’ = 2
				First-line will contain 2 ‘*’ while the second line will contain 1 ‘*’ as per description.

		#include <bits/stdc++.h> 
		vector<string> printPatt(int n) {
			vector<string> ans;

			for(int i=0; i<n; i++){
				string s = string(n-i, '*'); 
				ans.push_back(s);
			}
			return ans;
		}
	
	463) Play With OR:
		Problem statement:
			You are given an array arr[] of length n, 
			you have to re-construct the same array arr[] in-place. 
			The arr[i] after reconstruction will become arr[i] OR arr[i+1], 
			where OR is bitwise or. If for some i, i+1 does not exists, 
			then do not change arr[i].

			Example 1:

				Input :
				n = 5
				arr[] = {10, 11, 1, 2, 3}
				Output :
				11 11 3 3 3
				Explanation:
				At index 0, arr[0] or arr[1] = 11
				At index 1, arr[1] or arr[2] = 11
				At index 2, arr[2] or arr[3] = 3
				...
				At index 4, No element is left So, it will remain as it is.
				New Array will be {11, 11, 3, 3, 3}.
			Example 2:

				Input :
				n= 4
				arr[] = {5, 9, 2, 6} 
				Output :
				13 11 6 6
				Explanation:
				At index 0, arr[0] or arr[1] = 13.
				At index 1, arr[1] or arr[2] = 11.
				At index 2, arr[2] or arr[3] = 6.
				At index 3, No element is left So, it will remain as it is.
				New Array will be {13, 11, 6, 6}.
			Your Task:
				You are required to implement the function game_with_number(), 
				which takes an array arr, representing values at each index,
				and the size of the array n. The function should modify the 
				elements of the same array arr[] in-place by replacing them 
				with the values obtained by performing the bitwise OR operation on consecutive elements.

				Expected Time Complexity: O(n).
				Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ n ≤ 10^5
				1 ≤ arr[i] ≤ 10^7

		int* game_with_number(int arr[], int n) {
			for(int i=0; i<n-1; i++)
				arr[i] |= arr[i+1];
				
			return arr;
		}

		// or function returning pointer
		int* game_with_number(int arr[], int n) {
			int *p = arr;
			for(int i=0; i<n-1; i++)
				p[i] |= p[i+1];
			return p;
		}

	464) Find kth element of spiral matrix:
		https://www.geeksforgeeks.org/problems/find-nth-element-of-spiral-matrix/1
		Problem statement:
			Given a matrix with n rows and m columns. 
			Your task is to find the kth element which is obtained while traversing the matrix spirally. 
			You need to complete the method findK which takes four arguments the first argument is 
			the matrix A and the next two arguments will be n and m denoting the size of the matrix 
			A and then the forth argument is an integer k. 
			The function will return the kth element obtained while traversing the matrix spirally.
			
			Example 1:
				Input:
				n = 4, m = 4, k = 10
				A[][] = {{1  2  3  4},
					{5  6  7  8},
					{9  10 11 12},
					{13 14 15 16}}
				Output:
				13

			Explanation:
			The spiral order of matrix will look like 1->2->3->4->8->12->16->15->14->13->9->5->6->7->11->10. 
			So the 10th element in this order is 13. 
			
			Example 2:
				Input:
				n = 3, m = 3, k = 4
				A[][] = {{1 2 3},
					{4 5 6},
					{7 8 9}}
				Output:
				6
				Explanation:
				The spiral order of matrix will look like 1->2->3->6->9->8->7->4->5. 
				So the 4th element in this order is 6.
			Your Task:
				You only need to implement the given function findK(). 
				Do not read input, instead use the arguments given in the function. 
				Return the K'th element obtained by traversing matrix spirally.

			Expected Time Complexity: O(n*m)
			Expected Auxiliary Space: O(n*m)

			Constraints:
				1<=n,m<=10^3
				1<=k<=n*m
				-10^9 <= A[i][j] <= 10^9

		class Solution {
			public:
			/*You are required to complete this method*/
			int findK(int a[MAX][MAX],int n,int m,int k) {
				int sr, sc, er, ec;
				sr=sc=0, er=n-1, ec=m-1;
				int val=a[0][0];
				
				// for(int i=0; i<n; i++){
				//     for(int j=0; j<m; j++)
				//         cout<<a[i][j]<<"\t";
				//     cout<<"\n";
				// }
				
				while(k) {
					// for start row
					for(int i=sc; i<=ec && k>0; i++){
						val = a[sr][i];
						k--;
					}
					sr++;
					
					// for end col
					for(int i=sr; i<=er && k>0; i++){
						val = a[i][ec];
						k--;
					}
					ec--;
					
					// for end row
					for(int i=ec; i>=sc && k>0; i--){
						val = a[er][i];
						k--;
					}
					er--;
					
					// for start col
					for(int i=er; i>=sr && k>0; i--){
						val = a[i][sc];
						k--;
					}
					sc++;
				}
				return val;
			}
		};

	465) Spirally traversing a matrix (Refer POTD Q.455):
		https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1
		Problem statement:
			Given a matrix of size r*c. Traverse the matrix in spiral form.

			Example 1:
				Input:
				r = 4, c = 4
				matrix[][] = {{1, 2, 3, 4},
						{5, 6, 7, 8},
						{9, 10, 11, 12},
						{13, 14, 15,16}}
				Output: 
				1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10
				Explanation:

			Example 2:
				Input:
				r = 3, c = 4  
				matrix[][] = {{1, 2, 3, 4},
						{5, 6, 7, 8},
						{9, 10, 11, 12}}
				Output: 
				1 2 3 4 8 12 11 10 9 5 6 7
				Explanation:
				Applying same technique as shown above, 
				output for the 2nd testcase will be 
				1 2 3 4 8 12 11 10 9 5 6 7.

			Your Task:
				You dont need to read input or print anything.
				Complete the function spirallyTraverse() that takes matrix, 
				r and c as input parameters and returns a list of 
				integers denoting the spiral traversal of matrix. 

			Expected Time Complexity: O(r*c)
			Expected Auxiliary Space: O(r*c), for returning the answer only.

			Constraints:
				1 <= r, c <= 100
				0 <= matrix[i] <= 100

		class Solution {   
		public: 
			//Function to return a list of integers denoting spiral traversal of matrix.
			vector<int> spirallyTraverse(vector<vector<int>> m, int r, int c) {
				vector<int> ans;
				
				int sr, sc, er, ec;
				sr=sc=0;
				er=r-1, ec=c-1;
				
				int totalElements = r*c, cnt=0;
				while(cnt < totalElements){
					
					// for start row
					for(int i=sc; i<=ec && cnt< totalElements; i++){
						ans.push_back(m[sr][i]);
						cnt++;
					}
					
					sr++;
					// for end col
					for(int i=sr; i<=er && cnt< totalElements; i++){
						ans.push_back(m[i][ec]);
						cnt++;
					}
					
					ec--;
					// for end row
					for(int i=ec; i>=sc && cnt< totalElements; i--){
						ans.push_back(m[er][i]);
						cnt++;
					}
					
					er--;
					// for start col
					for(int i=er; i>=sr && cnt< totalElements; i--){
						ans.push_back(m[i][sc]);
						cnt++;
					}
					
					sc++;
				}
				return ans;
			}
		};

	466) Rotating an Array:
		https://www.geeksforgeeks.org/problems/reversal-algorithm5340/1
		Problem statement:
			Given an array of size n.
			The task is to rotate array by d elements where d ≤ n.

			Example 1:
				Input:
				n = 7
				arr[] = {-1, -2, -3, 4, 5, 6, 7}
				d = 2
				Output: {-3, 4, 5, 6, 7, -1, -2}
				Explanation: 
				Rotate by 1: [-2, -3, 4, 5, 6, 7, -1]
				Rotate by 2: [-3, 4, 5, 6, 7, -1, -2]

			Example 2:
				Input:
				n = 4
				arr[] = {1, 3, 4, 2}
				d = 3
				Output: {2, 1, 3, 4}

			Your Task:
				You don't need to read input or print anything.
				Your task is to complete the function leftRotate() which takes the array of integers arr[],
				its size n and d as input parameters and rotates arr[] in-place without using any extra memory.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ n ≤ 10^6
				-10^9 ≤ arr[i] ≤ 10^9
				0 ≤ d ≤ n

		// Not Optimized:
			class Solution{   
				public:
				void leftRotate(int arr[], int n, int d) {
					if(d >= n)
						d %= n;
						
					while(d--){
						int value = arr[0];
						// copy the next element into current
						for(int i=0; i<n-1; i++)
							arr[i] = arr[i+1];
							
						arr[n-1] = value;
					}
				}
			};

		// Optimized:
			class Solution{   
				public:
				void leftRotate(int arr[], int n, int d) {
					rotate(arr, arr+d, arr+n);
				}
			};

			// or
				class Solution{   
					public:
					void leftRotate(int arr[], int n, int d) {
						reverse(arr, arr+d);
						reverse(arr+d, arr+n);
						reverse(arr, arr+n);
					}
				};

	467) Rotate Array:
		https://www.geeksforgeeks.org/problems/rotate-array-by-n-elements-1587115621/1
		Problem statement:
			Given an unsorted array arr[] of size N. 
			Rotate the array to the left (counter-clockwise direction) by D steps,
			where D is a positive integer. 
			
			Example 1:
				Input:
				N = 5, D = 2
				arr[] = {1,2,3,4,5}
				Output: 3 4 5 1 2
				Explanation: 1 2 3 4 5  when rotated
				by 2 elements, it becomes 3 4 5 1 2.

			Example 2:
				Input:
				N = 10, D = 3
				arr[] = {2,4,6,8,10,12,14,16,18,20}
				Output: 8 10 12 14 16 18 20 2 4 6
				Explanation: 2 4 6 8 10 12 14 16 18 20 
				when rotated by 3 elements, it becomes 
				8 10 12 14 16 18 20 2 4 6.
			
			Your Task:
				You need not print or read anything. 
				You need to complete the function rotateArr() which takes the array, 
				D and N as input parameters and rotates the array by D elements.
				The array must be modified in-place without using extra space. 

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^6
				1 <= D <= 10^6
				0 <= arr[i] <= 10^5

		// Not Optimized:
			class Solution {
				public:
				// Function to rotate an array by d elements in counter-clockwise direction.
				void rotateArr(vector<int>& arr, int d) {
					int n = arr.size();
					if(d >= n) d %= n;
					
					while(d--){
						int val = arr[0];
						arr.erase(arr.begin());
						arr.push_back(val);
					}
				}
			};

		// Optimized:
			class Solution{
				public:
				
				//Function to rotate an array by d elements in counter-clockwise direction. 
				void rotateArr(int arr[], int d, int n){
					if(d >=n )
						d %= n;

					// reversing the complete array
					reverse(arr, arr+n);
					
					// reversing the first (n-d) elements of array
					reverse(arr, arr+(n-d));
					
					// reversing the (n-d) till last elements of array
					reverse(arr+(n-d), arr+n);
				}
			};
		 
		 // or
			class Solution {
				public:
				// Function to rotate an array by d elements in counter-clockwise direction.
				void rotateArr(vector<int>& arr, int d) {
					reverse(arr.begin(), arr.end());
					int n = arr.size();
					
					if(d >= n) d %= n;
					int splitter = n - d;
					reverse(arr.begin(), arr.begin()+splitter);
					reverse(arr.begin()+splitter, arr.end());
				}
			};

		// or the default rotation for rotate method is left rotation (anticlockwise).
		class Solution{
			public:
			//Function to rotate an array by d elements in counter-clockwise direction. 
			void rotateArr(int arr[], int d, int n){
				if(d >=n )
					d %=n;
				rotate(arr, arr+d, arr+n);
			}
		};

		For clockwise rotation:
			void rotateArr(int arr[], int d, int n){
				if(d >=n )
					d %=n;
					
				rotate(arr, arr+(n-d), arr+n);
			}

		// without using built in function:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;
			void reverse(int arr[], int s, int e){
				while(s<e)
					swap(arr[s++],arr[e--]);
			}

			void printer(int arr[], int size){
				for(int i=0; i<size; i++)
					std::cout << arr[i] << "\t";
				std::cout << std::endl;
			}

			int main() {
				int arr[] = {1,2,3,4,5,6,7,8,9,0};
				int n=10;
				printer(arr,n);
				
				reverse(arr, 0, n-1);
				reverse(arr, 5, n-1);
				
				printer(arr,n);

				return 0;
			}

	468) Check if a number is divisible by 8
		-if last three num are divisible by 8 then whole num is divisible by 8.
		Problem statement:
			Given a string representation of a decimal number s, check whether it is divisible by 8.
			
			Example 1:
			Input:
			s = "16"
			Output:
			1
			Explanation:
			The given number is divisible by 8,
			so the driver code prints 1 as the output.

			Example 2:
				Input:
				s = "54141111648421214584416464555"
				Output:
				-1
				Explanation:
				Given Number is not divisible by 8, 
				so the driver code prints -1 as the output.
			Your Task:
				You don't need to read input or print anything.
				Your task is to complete the function DivisibleByEight() which takes 
				a string s as the input and returns 1 if the number is divisible by 8, 
				else it returns -1.

			Expected Time Complexity: O(1).
			Expected Auxillary Space: O(1).

			Constraints:
				1 <= Number represented by the string s < 10^6

		
		class Solution{
			public:
			int DivisibleByEight(string s){
				int value=0,i=3;
				if(s.size() <= 3){
					value = stoi(s, 0, 10);
					if(value % 8 ==0)
						return 1;
				}else{
					string temp;
					int var = s.length()-1;
					while(i){
						temp += s[var--];
						i--;
					}
					reverse(temp.begin(), temp.end());
					value = stoi(temp, 0, 10);
					if(value % 8 ==0)
						return 1;
				}
				return -1;
			}
		};

		// or
			class Solution{
				public:
				int DivisibleByEight(string s){
					int i=3;
					if(s.size() <= 3){
						if(stoi(s, 0, 10) % 8 ==0)
							return 1;
					}else{
						string temp;
						while(i)
							temp += s[s.size()- i--];
						
						if(stoi(temp, 0, 10) % 8 ==0)
							return 1;
					}
					return -1;
				}
			};

	469) Maximize XOR: ❌Pending
		https://www.geeksforgeeks.org/problems/maximize-xor0829/1 
		Problem statement:
			Given a number X find the total numbers A 
			such that A XOR X >= X,  and 1<=A<=X.

			Example 1:
				Input: 10
				Output: 5
				Explanation: Calculating XOR of 10 with
				{1, 4, 5, 6, 7} give values greater than 
				equal to 10.

			Example 2:
				Input: 5
				Output: 2
				Explanation: Calculating XOR of 5 with 
				{2, 3} give values greater than 5.

			Your Task:
				You don't need to read or print anything. 
				Your task is to complete the function maximize_xor_count() 
				which takes X as input parameter and returns total numbers A.

			Expected Time Complexity: O(log(n))
			Expected Space Complexity: O(1)
			
			Constraints:
				1 <= X <= 10^8
			
		// Not Optimized:
			class Solution {
				public:
				int  maximize_xor_count(int n ) {
					int cnt=0;
					for(int i=1; i<=n; i++)
						if((i ^ n) >= n)
							cnt++;
							
					return cnt;
				}
			};

		// Optimized

	470) Reverse Bits:
		Problem statement
			Given a 32 bit number X, 
			reverse its binary form and print the answer in decimal.

			Example 1:
				Input:
				X = 1
				Output:
				2147483648 
				Explanation:
				Binary of 1 in 32 bits representation-
				00000000000000000000000000000001
				Reversing the binary form we get, 
				10000000000000000000000000000000,
				whose decimal value is 2147483648.

			Example 2:
				Input:
				X = 5
				Output:
				2684354560 
				Explanation:
				Binary of 5 in 32 bits representation-
				00000000000000000000000000000101
				Reversing the binary form we get, 
				10100000000000000000000000000000,
				whose decimal value is 2684354560.

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function reversedBits() 
				which takes an Integer X as input and returns the answer.

			Expected Time Complexity: O(log(X))
			Expected Auxiliary Space: O(1)

			Constraints:
				0 <= X < 2^32

		class Solution {
			public:
			long long reversedBits(long long X) {
				string s = bitset<32>(X).to_string();
				reverse(s.begin(), s.end());
				X = stoll(s, 0, 2);				// or X = bitset<32>(s).to_ulong();
				return X;
			}
		};

	471) Negative To The End:
		Problem statement
			You are given an array ‘A’ of size ‘N’ consisting of both negative and positive integers.
			You need to return an array in which all the negative numbers are at the end of the array,
			but the relative order of positive and negative elements is the same.

			Example:
				Input: ‘N’ = 6
				‘A’ = [-1, 2, -3, 1, 13, -10]
				Output: [2, 1, 13, -1, -3, 10]

				Explanation: In the output array, all the negative elements come after positive elements, 
				and we can also see that the order of positive elements and negative elements is the same, 
				i.e., 2 comes before 1 and 13 in the final array because in the array ‘A’, 
				2 comes before 1 and 13, and for all other elements, this condition follows.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^3
				-1e9 <= A[i] <= 10^9, A[i] != 0

				Time Limit: 1-sec
			Sample Input 1:
				2
				6
				-1 2 -3 1 13 -10

				4
				-1 -1 -2 -3
				Sample Output 1:
				2 1 13 -1 -3 -10
				-1 -1 -2 -3
				Explanation Of Sample Input 1:
				For test case 1:

				Input: ‘N’ = 6
				‘A’ = [-1, 2, -3, 1, 13, -10]

				Output: [2, 1, 13, -1, -3, 10]

				Explanation: In the output array, all the negative elements come after positive elements,
				and we can also see that the order of positive elements and negative elements is the same,
				i.e., 2 comes before 1 and 13 in the final array because in the array ‘A’, 
				2 comes before 1 and 13, and for all other elements, this condition follows.


				For test case 2:

				Input: ‘N’ = 4
				‘A’ = [-1, -1, -2, -3]

				Output: [-1, -1, -2, -3]

				Explanation: Since there are no positive elements,
				all negative elements are already at the end of the array, so there’s no need to change array ‘A’.
				Sample Input 2:
				2
				4
				1 2 1 3

				4
				-1 2 3 -4
				Sample Output 2:
				1 2 1 3
				2 3 -1 -4

		// used extra space
			vector<int> negativeToTheEnd(vector<int> v) {
				vector<int> pos, neg;

				for(int i=0; i<v.size(); i++){
					if(v[i] < 0)
						neg.push_back(v[i]);
					else
						pos.push_back(v[i]);
				}
				int i=0;
				for(i=0; i<pos.size(); i++)
					v[i] = pos[i];
				
				for(int j=0; j<neg.size(); j++ )
					v[i++] = neg[j];

				return v;
			}

		// without using extra space:
			❌Pending

	472) Sum of bit differences:
		Problem statement:
			Given an array integers arr[], containing n elements, 
			find the sum of bit differences between all pairs of element in the array.
			Bit difference of a pair (x, y) is the count of different bits at the same
			positions in binary representations of x and y.
			For example, bit difference for 2 and 7 is 2. 
			Binary representation of 2 is 010 and 7 is 111 
			respectively and the first and last bits differ between the two numbers.
			Note: (x, y) and (y, x) are considered two separate pairs.

			Example 1:
				Input: 
				n = 2
				arr[] = {1, 2}
				Output: 4
				Explanation: All possible pairs of an array are (1, 1), (1, 2), (2, 1), (2, 2).
				Sum of bit differences = 0 + 2 + 2 + 0
								= 4

			Example 2:
				Input:
				n = 3 
				arr[] = {1, 3, 5}
				Output: 8
				Explanation: 
				All possible pairs of an array are (1, 1), (1, 3), (1, 5), (3, 1), (3, 3) (3, 5),(5, 1), (5, 3), (5, 5).
				Sum of bit differences = 0 + 1 + 1 + 1 + 0 + 2 + 1 + 2 + 0 
								= 8
			Your Task:  
				You don't need to read input or print anything. 
				Your task is to complete the function sumBitDifferences() 
				which takes the array arr[] and n as inputs and return an 
				integer that represents the sum of the bit differences 
				between all possible pairs of elements in the array.

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= n <= 10^5
				1 <= arr[i] <= 10^5

		// Not Optimized:
			class Solution{
				public:
					long long sumBitDifferences(int arr[], int n) {
					long long ans=0;
					for(int i=0; i<n; i++){
						string s1 = bitset<32>(arr[i]).to_string();
						
						for(int j=0; j<n; j++) {
							string s2 = bitset<32>(arr[j]).to_string();
							if(s1 == s2)
								continue;
							
							int cnt=0;
							for(int z=0; z<32; z++)
								if(s1[z] != s2[z])
									cnt++;
							
							ans += cnt;
						}
					}		
					return ans;
				}
			};

		// Optimized:
			❌Pending

	473) Merge Two Sorted Arrays Without Extra Space:
		Problem statement
			Given two non-decreasing sorted arrays, ‘A’ and ‘B’, having ‘N’ and ‘M’ elements, respectively.
			You must merge these arrays, ‘A’ and ‘B’, into a sorted array without using extra space. 
			Of all the 'N + M' sorted elements, array 'A' should contain the first 'N' elements,
			and array 'B' should have the last 'M' elements.

			Note:
				You must perform the merge operation in place and must not allocate any extra space to merge the two arrays.

			For example:
				When ‘N’ = 4, ‘A’ = {1, 4, 5, 7} and ‘M’ = 3, ‘B’ = {2, 3, 6}. 
				We can merge these two arrays into {1, 2, 3, 4, 5, 6, 7} (The elements of ‘A’ are {1, 2, 3, 4} ).
				Hence, the answer is {1, 2, 3, 4, 5, 6, 7}.
			Sample Input 1:
				3 4
				1 8 8
				2 3 4 5
				Sample Output 1:
				1 2 3 4 5 8 8
				Explanation Of Sample Input 1:
				We have ‘A’ = {1, 8, 8} and ‘B’ = {2, 3, 4, 5}. 
				Merging the two arrays results in {1, 2, 3, 4, 5, 8, 8}.
				Hence the answer is {1, 2, 3, 4, 5, 8, 8}, where ‘A’ contains {1, 2, 3} and ‘B’ contains {4, 5, 8, 8}.
				Sample Input 2:
				4 5
				1 1 1 1 
				2 2 3 3 5
				Sample Output 2:
				1 1 1 1 2 2 3 3 5
			Constraints:
				1 <= N <= 10^5
				1 <= M <= 10^5
				0 <= A[i] <= 10^9
				0 <= B[i] <= 10^9

				The sum of ‘N + M’ over all test cases does not exceed 2 * 10^5.
				Time Limit: 1-sec

		#include <bits/stdc++.h>
		void mergeTwoSortedArraysWithoutExtraSpace(vector<long long> &a, vector<long long> &b){
			vector<long long> holder (a.begin(), a.end());
			for(long long i: b)
				holder.push_back(i);

			sort(holder.begin(), holder.end());
			a.clear();
			b = holder;
		}

	474) Find Duplicate in Array
		Problem statement
			You are given an array of integers 'ARR' containing N elements. 
			Each integer is in the range [1, N-1], with exactly one element repeated in the array.
			Your task is to find the duplicate element. 
			The duplicate element may be repeated more than twice in the error, 
			but there will be exactly one element that is repeated in the array.

			Note :
				All the integers in the array appear only once except for 
				precisely one integer which appears two or more times.
			Constraints :
				1 <= T <= 5
				1 <= N <= 10^5
				1 <= ARR[i] <= N - 1

				Time Limit: 1 sec
			Sample Input 1:
				1
				3
				1 1 2
				Sample Output 1:
				1
				Explanation of Sample Input 1:
				1 is repeated in the array, hence function returns 1.
				Sample Input 2:
				3
				5
				1 3 4 2 2
				5
				3 1 3 4 2
				3
				1 1 1
				Sample Output 2:
				2
				3
				1

		#include <bits/stdc++.h>
		int findDuplicate(vector<int> &arr, int n){
			map<int, int> F;

			for(int i: arr){
				F[i]++;
				if(F[i] >=2)
					return i;
			}
			return 0;
		}

	475) Peak element:
		Problem statement:
			Given an 0-indexed array of integers arr[] of size n, find its peak element. 
			An element is considered to be peak if it's value is greater than or equal 
			to the values of its adjacent elements (if they exist). 
			The array is guaranteed to be in ascending order before the peak element and in descending order after it.
			Note:
				The output will be 1 if the index returned by your function is correct; otherwise, it will be 0.
			Example 1:
				Input: 
				n = 3
				arr[] = {1, 2, 3}
				Peak Element's Index: 2
				Output: 1
				Explanation: 
				If the index returned is 2, then the output printed will be 1. 
				Since arr[2] = 3 is greater than its adjacent elements, and 
				there is no element after it, we can consider it as a peak 
				element. No other index satisfies the same property.
			Example 2:
				Input:
				n = 3
				arr[] = {3, 4, 2}
				Peak Element's Index: 1
				Output: 1
				Explanation: 
				If the index returned is 1, then the output printed will be 1.
				Since arr[1] = 4 is greater than its adjacent elements, and
				there is no element after it, we can consider it as a peak
				element. No other index satisfies the same property.
			Your Task:
				You don't have to read input or print anything.
				Complete the function peakElement() which takes the array arr[]
				and its size n as input parameters and return the index of the peak element.
			Expected Time Complexity: O(log(n)).
			Expected Auxiliary Space: O(1)
			Constraints:
				1 ≤ n ≤ 10^5
				1 ≤ arr[i] ≤ 10^6

		// Optimized:
			class Solution {
				public:
				int peakElement(int arr[], int n) {
					
					// if(n==1)
					//     return 0;
					
					int s=0, e=n-1;
					while(s < e){
						int mid = (s+e)/2;
						if(arr[mid] > arr[mid+1])
							e = mid;
						else
							s = mid +1;
					}
					return s;
				}
			};

		// Other approach:
			class Solution {
				public:
				int peakElement(int arr[], int n) {
					auto mx = max_element(arr, arr+n);
					return distance(arr, mx);
				}
			};
			
	476) Maximum Odd Binary Number:
		Problem statement:
			You are given a binary string s that contains at least one '1'.
			You have to rearrange the bits in such a way that the resulting
			binary number is the maximum odd binary number that can be created from this combination.
			Return a string representing the maximum odd binary 
			number that can be created from the given combination.
			Note that the resulting string can have leading zeros.

			Example 1:
				Input: s = "010"
				Output: "001"
				Explanation: Because there is just one '1', 
				it must be in the last position. So the answer is "001".

			Example 2:
				Input: s = "0101"
				Output: "1001"
				Explanation: One of the '1's must be in the last position. 
				The maximum number that can be made with the remaining digits is "100".
				So the answer is "1001".

			Constraints:
				1 <= s.length <= 100
				s consists only of '0' and '1'.
				s contains at least one '1'.

		class Solution {
			public:
			string maximumOddBinaryNumber(string s) {
				if(s.size()==1)
					return s;
				sort(begin(s), end(s), greater<char>());
				
				//searching last one in string & placing it to the last
				// this below will give the index of first zero
				// then we will do index + 1 get the index of last one
				// & swap them with last zero

				int i=0; 
				while(i < s.size() && s[i] != '0')
					i++;
				
				int index = i-1;
				swap(s[index],s[s.size()-1]);
				return s;
			}
		};

	477) Bored Chef:
		Problem statement
			You are given a string ‘S’ of size ‘N’ 
			where each character is numbered from ‘0’ to ‘N - 1’.
			You are allowed to swap any two adjacent characters any number of times.
			You are also given an integer ‘K’. 
			Your task is to check whether it is possible to group 
			any same ‘K’ characters by using the given operation.

			Your task is to tell whether it is possible to group any same ‘K’ characters
			and return ‘1’ if it is possible, otherwise return ‘0’.

			Example:
				‘N’ = 5
				‘K’ = 2
				‘S’ = “acdab”
				In the first operation, you can swap ‘0th’ and the ‘1st’ character.
				You’ll get the string ‘S’ as: “cadab”
				In the second operation, you can swap ‘1st’ and the ‘2nd’ character.
				You’ll get the string ‘S’ as: “cdaab”.
				Here, we are getting a group of two ‘a’s together.
				Hence, the answer for this test case is ‘1’.

			Constraints:
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^5
				1 <= ‘K’ <= ‘N’
				‘a’ <= ‘S[i]’ <= ‘z’
				Time Limit: 1 sec

			Sample Input 1:
				2
				4 3
				abaa 
				4 2
				abcd
				Sample Output 1:
				1
				0
				Explanation of sample input 1:
				For test case 1:
				In the first operation, swap ‘0th’ and the ‘1st’ element. You’ll get the string ‘S’ as: “baaa”

				Here, the substring from index ‘1’ to ‘3’ contains a group of ‘3’ ‘a’s.
				Hence, the answer for this test case is ‘1’.

				For test case 2:
				Here, it is impossible to group ‘2’ same characters. So, the answer for this test case is ‘0’.
				Sample Input 2:
				2
				5 3
				zzzzz 
				4 1
				fghe
				Sample Output 2:
				1
				1

		int boredChef(int n, int k, string &s) {
			map<char, int> F;
			for(char c: s){
				F[c]++;
				if(F[c] >= k)
				return 1;
			}
			return 0;
		}

	478) All Equals:
		Problem statement
			You are given an array 'A' of 'N' integers numbered from '0' to 'N - 1'.
			In one operation, you can select an index 'i' and update 'A[i]' to 'A[i] + A[i]'.
			Determine if you can make all the elements of the
			array equal after performing the given operation any number of times. 
			Return '1' in that case. Otherwise, return '0'.
			Example:
				N = 3
				A = [1, 4, 4]
				In the first operation, update 'A[0]' to 'A[0] + A[0]' = '1 + 1' = '2'.
				In the second operation, again update 'A[0]' to 'A[0] + A[0]' = '2 + 2' = '4'.
				The resultant array is ['4', '4', '4']. You can see that all the elements of the array are equal.
				So, the answer for this case is '1'.
			Constraints:
				1 <= 'N' <= 10^5
				'1' <= A[i] <= '10^5'
				Time limit: 1 sec
			Sample input 1:
				2
				3
				2 2 2
				4
				3 6 8 12
				Sample output 1:
				1
				0
				Explanation of sample input 1:
				For test case 1:
				We can see that the elements of the array are already the same.
				So the answer for this case is '1'.

				For test case 2:
				It can be proved that we can not make all the elements of the array equal 
				after performing the given operation any number of times.
				So, the answer for this case is '0'.
				Sample input 2:
				2
				3
				14 7 56
				4
				1 12 4 16
				Sample output 2:
				1
				0

		int canYouMakeEqual(int n, vector<int> &v) {
			int G = *max_element(v.begin(), v.end());
			for(int i=0; i<n; i++){
				while(v[i] < G)
					v[i] += v[i];
				if(v[i] != G)
					return 0;
			}
			return 1;
		}

	479) Recreate Array:
		Problem statement
			In the realm of ninjas, there exist 100 distinct types of weapons numbered from 0 to 99. 
			Your mission is to gather a set of weapons specified in an array 'A'.
			If a particular weapon is listed multiple times in the array, 
			you must collect that many copies of that weapon to fulfill the mission.

			You've entered a new shop stocked with an array 'B'.
			The unique shopping rule here is that you can purchase any consecutive sequence of items (subarray),
			and the cost is determined by the length of that chosen subarray.

			Return the minimum cost to complete your mission or -1 if not possible.

			Example:
				‘N’ = 5
				‘M’ = 2
				‘A’ = [2, 1, 3]
				‘B’ = [1, 2, 2, 1, 1, 3, 3]

			You have to buy the subarray [2, 1, 1, 3]. There doesn’t exist any smaller subarray which tends to your needs.
			So the answer will be '4'.
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints:
			1 <= ‘T’ <= 10
			1 <= ‘N’, ’M’ <= 10^4
			0 <= ‘A’, ’B’ <= 99

			Time Limit: 1 sec
			Sample Input 1:
			2
			4 10
			4 2 2 7
			2 5 5 2 4 7 6 2 2 8 
			4 6
			4 5 10 10
			1 4 5 4 5 10
			Sample Output 1:
			5
			-1
			Explanation of sample input 1:
			For 1st test case:
			We can either choose [2 4 7 6 2] or [4 7 6 2 2] to buy with the cost of 5.
			For 2nd test case:
			As we need 2 type 10 weapons and it is not available on the store hence -1.
			Sample Input 2:
			3
			3 7
			5 8 5
			1 1 5 8 5 10 4
			2 6
			1 1
			1 2 2 2 2 1
			10 10
			1 2 3 4 5 6 7 8 9 0
			1 2 3 4 5 6 7 8 9 0
			Sample Output 2:
			3
			6
			10

		// Not Optimized:
			bool CheckMaps(map<int, int> M1, map<int, int> M2){
				for(auto itr = M1.begin(); itr != M1.end(); itr++)
					if(M1[itr->first] > M2[itr->first])
						return 0;
				return 1;
			}

			int minCost(vector<int>& a, vector<int>& b) {
				// finding the weapons needed
				map<int, int> Fa;
				for(int i: a)
					Fa[i]++;
				
				// need to generate subArray of same things as Fa with MIN Size
				// the subarray we are generating is should be of size of sum of values in Fa.
				// sum of values

				// int size=0;
				// for(auto i: Fa)
				//     size += i.second;

				int minSize = INT_MAX;
				for(int i=0; i<= (b.size()-a.size()); i++){
					int s=i, e= i+a.size()-1;

					// Generate the window of s to e
					while(e < b.size()){
						map<int, int> Matching;
						for(int z=i; z<=e; z++)
							Matching[b[z]]++;

						// checking is matching contains all the weaspon we required,
						// if yes and if its new subarrays is of size less than minSize then storing its into minSize
						if(CheckMaps(Fa, Matching))
							minSize = min(minSize, (e-s+1));
							
						e++;
					}
				}
				return (minSize == INT_MAX) ? -1 : minSize;
			}

		// Optimized:
			❌Pending

	480) Make Array Elements Equal:
		Problem statement
			You are given an array of integers of size ‘N’. 
			You have to make the elements of the array equal, 
			and the cost of changing the element ‘x’ to ‘y’ is abs(x -y). 
			Your task is to find the minimum cost to make the elements of the array equal.

			For example:
				Consider ARR = [3, 4, 5] now suppose if we want to change every element value to 4, 
				then the cost of changing 3 to 4 is |3 - 4| which is 1, and the 
				cost of changing 5 to 4 is |5 - 4| which is 1, so the total cost is 1 + 1 = 2. 
				The value 2 is the minimum cost to make all values in the array equal. Hence, the answer is 2.
			Constraints:
				1 <= T <= 5
				1 <= N <= 10^5
				1 <= ARR[i] <= 10^8

				Time limit: 1 sec
			Sample Input 1:
				2
				3
				1 8 19
				4
				2 17 26 11
				Sample Output 1:
				18
				30
				Explanation:
				In test case 1
				We can change all element’s value to 8 with cost |1-8| + |19 - 8| = 18.
				The value 18 is the minimum cost to make all values in the array equal.
				Hence, the answer is 18.

				In test case 2 
				We can change all element’s value to 11 with cost |2 - 11| + |17 - 11| + |26 - 11| = 30.
				The value 30 is the minimum cost to make all values in the array equal.
				Hence, the answer is 30. 
				Sample Input 2:
				1
				3
				1 100 101
				Sample Output 2:
				100

		#include <bits/stdc++.h> 
		int findMinimumCost(vector<int> &arr, int n){
			int minValue= INT_MAX;
			for(int i=0; i<n; i++){
				int CrntSum=0;
				for(int j=0; j<n; j++)
					CrntSum += abs(arr[i]-arr[j]);
				
				minValue = min(minValue, CrntSum);
			}
			return minValue;
		}

	481) Permutation in String: (Refer Lecture-22)
		Problem statement:
			Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
			In other words, return true if one of s1's permutations is the substring of s2.
			Example 1:
				Input: s1 = "ab", s2 = "eidbaooo"
				Output: true
				Explanation: s2 contains one permutation of s1 ("ba").
			Example 2:
				Input: s1 = "ab", s2 = "eidboaoo"
				Output: false
			Constraints:
				1 <= s1.length, s2.length <= 104
				s1 and s2 consist of lowercase English letters.

		class Solution {
			private:
			bool checkMaps(int *p1, int *p2){
				for(int trav=0; trav < 26; trav++)
					if(p1[trav] != p2[trav])
						return 0;
				return 1;
			}
			public:
			bool checkInclusion(string s1, string s2) {

				if(s1.size() > s2.size())
					return 0;

				// mapping for s1
				int mapS1[26] = {0};
				for(int a=0; a<s1.size(); a++)
					mapS1[s1[a] - 'a']++;
				
				// this loop should run till <= (s2.length()-s1.size())
				for(int z=0; z<= (s2.size()-s1.size()); z++){
					string sample = s2.substr(z, s1.size());

					// mapping for sample
					int mapS2[26] = {0};
					for(int x=0; x<sample.size(); x++)
						mapS2[sample[x] - 'a']++;
					
					if(checkMaps(mapS1, mapS2))
						return 1;
				}
				return 0;        
			}
		};

	482) Reduce Array:
		Problem statement
			You are given an array ‘Arr’ of ‘N’ integers. 
			Your task is to reduce each of the elements to zero. 
			You can perform the following two operations on the array.
			Select an index ‘i’. If ‘Arr[i]’ is odd then replace it with ‘(Arr[i]-1) / 2’ else replace it with ‘Arr[i] / 2’.
			Return the total number of operations required to reduce each element of the array to zero.
			Example:
			‘N’=5, ‘Arr’ = [2 , 5 , 6 , 3 , 1].
			2 -> 1 -> 0
			5 -> 2 -> 1 -> 0
			6 -> 3 -> 1 -> 0
			3 -> 1 -> 0
			1 -> 0
			Hence total operations will be 11.
			Constraints :
				1<=‘T’<=10
				1<=‘N’<=10^5
				1<=‘Arr[i]’<=10^9

				Time Limit: 1 sec
			Sample Input 1 :
				2
				5
				3 4 2 1 1
				3
				6 8 4
				Sample Output 1 :
				9
				10
				Explanation Of Sample Input 1 :
				For testcase one:

				‘N’=5, ‘Arr’ = [3 , 4 , 2 , 1 , 1].
				3 -> 1 -> 0
				4 -> 2 -> 1 -> 0
				2 -> 1 -> 0
				1 -> 0
				1 -> 0

				Hence total operations will be 9.
				For test case two:

				‘N’=3, ‘Arr’ = [6 , 8 , 4].
				6 -> 3 -> 1 -> 0
				8 -> 4 -> 2 -> 1 -> 0
				4 -> 2 -> 1 -> 0

				Hence total operations will be 10.
				Sample Input 2 :
				2
				5
				13 8 5 1 7
				4
				16 80 4 4
				Sample Output 2 :
				15
				18
		
		#include <bits/stdc++.h> 
		int reduceArray( vector<int> & v) {
			int cnt=0;
			for(int i=0; i<v.size(); i++){
				while(v[i]){
					cnt++;
					v[i]/=2;
				}
			}
			return cnt;
		}
	
	483) First element to occur k times:
		problem statement:
			Given an array of n integers. Find the first element that occurs atleast k number of times.
			Example 1:
				Input :
				n = 7, k = 2
				a[] = {1, 7, 4, 3, 4, 8, 7}
				Output :
				4
			Explanation :
				Both 7 and 4 occur 2 times. But 4 is first that occurs twice.
				As at index = 4, 4 has occurred twice whereas 7 appeared twice
				at index 6.

			Example 2:
				Input :
				n = 10, k = 3
				a[] = {3, 1, 3, 4, 5, 1, 3, 3, 5, 4}
				Output :
				3
				Explanation :
				Here, 3 is the only number that appeared atleast 3 times in the array.

			Your Task:  
				You don't need to read input or print anything. 
				Your task is to complete the function firstElementKTime() 
				which takes the array a[], its size n, and an integer k as
				input arguments and returns the required answer. 
				If the answer is not present in the array, return -1.

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(n).

			Constraints:
				1 <= n <= 10^4
				1 <= k <= 100
				0<= a[i] <= 200
	
		class Solution{
			public:
			int firstElementKTime(int n, int k, int a[]) {
				map<int, int> F;
				int i=0;
				while(i < n){
					F[a[i]]++;
					if(F[a[i]] >= k)
						return a[i];
					i++;
				}
				return -1;
			}
		};

	484) Permutations in array:
		Problem statement:
			Given two arrays of equal size N and an integer K.
			The task is to check if after permuting both arrays, 
			we get sum of their corresponding element greater than or equal to k
			i.e Ai + Bi >= K for all i (from 0 to N-1). 
			Return true if possible, else false.

			Example 1:
			Input : 
				a[] = {2, 1, 3}, 
				b[] = { 7, 8, 9 }, 
				k = 10. 
			Output : 
			True
			Explanation:
			Permutation  a[] = { 1, 2, 3 } 
			and b[] = { 9, 8, 7 } 
			satisfied the condition a[i] + b[i] >= K.

			Example 2:
				Input : 
				a[] = {1, 2, 2, 1}, b[] = { 3, 3, 3, 4 }, k = 5.
				Output : 
				False
				Explanation:
				Since any permutation won't give the answer.
			Your Task:  
				You don't need to read input or print anything. 
				Your task is to complete the function isPossible() which takes the 
				array A[], B[], its size N and an integer K as inputs and returns the answer.

			Expected Time Complexity: O(N. Log(N))
			Expected Auxiliary Space: O(1)
		
			Constraints:
				1 ≤ N ≤ 10^5
				1 ≤ K ≤ 10^18
				1 ≤ Ai, Bi ≤ 10^17
			
		class Solution {
			public:
			bool isPossible(long long a[], long long b[], int n, long long k) {
				sort(a, a+n);
				sort(b, b+n, greater<int>());
				
				for(int i=0; i<n; i++)
					if((a[i]+b[i]) < k)
						return 0;
				return 1;
			}
		};

	485) Unusual String Sort:
		Problem statement:
			Given a string composed of both lowercase and uppercase letters.
			Sort it in such a manner such that the uppercase
			and lowercase letter comes in an alternate manner but in sorted way.

			Example 1:
				Input:
				S = bAwutndekWEdkd
				Output: AbEdWddekkntuw
				Explanation: letters A,E,W are sorted 
				as well as letters b,d,d,d,e,k,k,n,t,u,w are 
				sorted and both appears alternately in the 
				string as far as possible.

			Example 2:
				Input: 
				S = AiBFR
				Output: AiBFR
				Explanation: letters A,B,F,R and sorted 
				as well as letter i. 

			User Task:
				You don't need to read input or print anything. 
				You just have to complete the function stringSort() 
				which takes a string as input and returns the sorted string as described in the problem description.
			Expected Time Complexity: O(|S|).
			Expected Auxiliary Space: O(1). 

			Constraints:
				1<=|S|<=1000

		class Solution {
			public:
			string stringSort (string s) {
				string ans;
				sort(s.begin(), s.end());				//or         sort(begin(s), end(s));
				vector<char> upper, lower;
				for(int i=0; i<s.size(); i++)
					if(isupper(s[i]))
						upper.push_back(s[i]);
					else
						lower.push_back(s[i]);
					
				int i=0,k=0;
				int cnt=1;
				while(i < upper.size() && k<lower.size()){
					if(cnt&1)
						ans += upper[i++];
					else
						ans += lower[k++];
					cnt++;
				}
				
				// individual check
				while(i<upper.size())
					ans += upper[i++];
					
				while(k<lower.size())
					ans += lower[k++];
				
				return ans;
			}
		};

	486) Same characters in two strings:
		Problem statement:
			Given two strings A and B of equal length, find how many times 
			the corresponding position in the two strings hold exactly 
			the same character. The comparison should not be case sensitive. 
			
			Example 1:
				Input:
				A = choice 
				B = chancE
				Output: 4
				Explanation: characters at position 0, 1, 4 and 5
				are same in the two strings A and B.

			Example 2:
				Input:
				A = Geek 
				B = gang
				Output: 1
				Explanation: charactera at position 0 is the
				same in the two strings A and B.

			Your Task:  
				You dont need to read input or print anything. 
				Complete the function sameChar() which takes the two strings A and B
				as input parameters and returns the 
				count of the characters that are same in A and B.

			Expected Time Complexity: O(N) where N is the length of strings A and B.
			Expected Auxiliary Space: O(1)

			Constraints:
				1<= A.length(), B.length() <= 10^4

		class Solution{
			public:
			int sameChar(string A, string B) {
				int cnt=0;
				
				for(int i=0; i<A.size(); i++)
					if(toupper(A[i]) == toupper(B[i])) 		//or if(tolower(A[i]) == tolower(B[i]))
						cnt++;

				return cnt;
			}
		};
	
	487) Permutations of a given string: (Lecture-39)
		Problem statement:
			Given a string S. 
			The task is to print all unique permutations of the given string
			that may contain dulplicates in lexicographically sorted order. 
			
			Example 1:
				Input: ABC
				Output:
				ABC ACB BAC BCA CAB CBA
				Explanation:
				Given string ABC has permutations in 6 
				forms as ABC, ACB, BAC, BCA, CAB and CBA .

			Example 2:
				Input: ABSG
				Output:
				ABGS ABSG AGBS AGSB ASBG ASGB BAGS 
				BASG BGAS BGSA BSAG BSGA GABS GASB 
				GBAS GBSA GSAB GSBA SABG SAGB SBAG 
				SBGA SGAB SGBA
				Explanation:
				Given string ABSG has 24 permutations.

			Your Task:  
				You don't need to read input or print anything. 
				Your task is to complete the function find_permutation() 
				which takes the string S as input parameter and returns a vector of string in lexicographical order.

			Expected Time Complexity: O(n! * n)
			Expected Space Complexity: O(n! * n)

			Constraints:
				1 <= length of string <= 5

		class Solution {
			private:
				void PermuteGen(string main, vector<string> &ans, int i){
					if(i >= main.size()){
						ans.push_back(main);
						return ;
					}
					
					for(int j=i; j<main.size(); j++){
						swap(main[i], main[j]);
						PermuteGen(main, ans, i+1);
					}
				}
				public:
				vector<string>find_permutation(string S){
					vector<string> ans;
					PermuteGen(S, ans, 0);
					sort(begin(ans), end(ans));
					
					set<string> setter (begin(ans), end(ans));
					
					//ans.clear(); 
					// this assign method clears the vector first then includes all the elements
					ans.assign(setter.begin(), setter.end());
					return ans;
				}
			};
	
	488) Sort string:
		Problem statement:
			Given a string S, sort it in the following manner. 
			Sorted string must contain a vowel as first letter and a consonant as 
			next letter and so on OR a consonant as first letter and a vowel as next letter and so on, 
			depending on the string. If there is no vowel left 
			then print the remaining consonant in ascending order and vice versa. 
			Note: Order of vowel must be a->e->i->o->u and order of consonant must be b->c->d... and so on.
			Example 1:
			Input: abcdei 
			Output: abecid 
			Explanation: 'a' (Vowel) came first so the
			pattern of sorted string is vcvcvcvc... 
			
			Example 2:
			Input: bcadefgh
			Output: bacedfgh 
			Explanation: 'b' (consonant) came first so
			the pattern of sorted string is cvcvcvcv....
			
			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function SortedString() 
				which takes the string s as input parameters and returns the sorted string.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)
			Constraints:
				1<=|S|<=1000000

		class Solution {
			public:
			string SortedString(string s) {
				string ans;
				int pttrn=0;
				// checking the pattern will be cvcvcv or vcvcvc
				if(s[0] == 'a' || s[0] == 'e' || s[0] == 'i' || s[0] == 'o' || s[0] == 'u')
					//vcvcvc pattern
					pttrn = 1;
				//else
					// cvcvcv pattern
					
				sort(begin(s), end(s));
				string vowels, consonants;
				
				for(char ch : s){
					if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
						vowels += ch;
					else
						consonants += ch;
				}
				
				int cnt=1, i=0,j=0;
				if(pttrn){
					// vcvcvcvc pattern
					while(i < vowels.size() && j<consonants.size()){
						if(cnt&1)
						ans += vowels[i++];
						else
						ans += consonants[j++];
						cnt++;
					}
				}else{
					//cvcvcv pattern
					while(i < vowels.size() && j<consonants.size()){
						if(cnt&1)
						ans += consonants[j++];
						else
						ans += vowels[i++];
						cnt++;
					}
				}
				
				//individual check
				while(i<vowels.size())
					ans += vowels[i++];
					
				while(j<consonants.size())
					ans += consonants[j++];
				return ans;
			}
		};
	
	489) Sort a String:
		Problem statement:
			Given a string consisting of lowercase letters, arrange all its letters in ascending order. 
			Example 1:
			Input:
			S = "edcab"
			Output: "abcde"
			Explanation: characters are in ascending
			order in "abcde".
			Example 2:
			Input:
			S = "xzy"
			Output: "xyz"
			Explanation: characters are in ascending
			order in "xyz".


			Your Task:  
			You don't need to read input or print anything. 
			Your task is to complete the function sort() which takes the string as inputs and returns the modified string.

			Expected Time Complexity: O(|S| * log |S|)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ |S| ≤ 10^5
				S contains only lowercase alphabets.

		// Not Optimized:
			string sort(string s){
				for(int i=1; i<s.size(); i++){
					int j=i-1;
					char ch = s[i];
					while(j>=0){
						if(s[j] < ch)
							break;
						s[j+1] = s[j];
						j--;
					}
					s[++j] = ch;
				}
				return s;
			}
		
		// Optimized:
			string sort(string s){
				sort(s.begin(), s.end());
				return s;
			}

	490) Check String:
		Problem statement:
			Given a string, check if all its characters are the same or not.
			Example 1:
			Input:
			s = "geeks"
			Output: False
			Explanation: The string contains different
			character 'g', 'e', 'k' and 's'.

			Example 2:
			Input:
			s = "gggg"
			Output: True
			Explanation: The string contains only one
			character 'g'.

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function check() which 
				takes a string as input and returns True if all the 
				characters in the string are the same. Else, it returns False.

			Expected Time Complexity: O(|S|).
			Expected Auxiliary Space: O(1).
			Constraints:
				1 <= |S| <= 10^4

		class Solution {
			public:
			bool check (string s) {
				for(int i=1; i<s.size(); i++)
					if(s[i] != s[i-1])
						return 0;
				return 1;
			}
		};

	491) Ordering of strings:
		Problem statement:
			You will be given N number of strings.
			You have to find the lexicographically smallest string and the lexicographically largest string among these strings.
			
			Example 1:
				Input:
				N = 3
				strings = a , ab , abc
				Output: a abc
				Explanation: Lexicographically smallest is
				"a" and lexicographically largest is
				"abc".

			Example 2:
				Input:
				N = 2
				strings = abc , abc
				Output: abc abc
				Explanation: Lexicographically smallest is
				"abc" and lexicographically largest is
				"abc"		

			Your Task:  
				You dont need to read input or print anything. 
				Complete the function orderString() which takes a 2d character array and an integer
				N as input parameter and returns an array of size 2 where first value should be 
				lexicographically smallest string and second value should be lexicographically largest string.

			Expected Time Complexity: O(N* max of all string length ).
			Expected Auxiliary Space: O(1).		

			Constraints:
				1 <= N , length of each string <= 10^3

		class Solution{
			public:
			vector<string> orderString(string s[], int n) {
				vector<string> ans;
				
				string min=s[0], max=s[0];
				for(int i=1; i<n; i++){
					if(min > s[i])
						min = s[i];
					
					if(max < s[i])
						max = s[i];
				}
				ans.push_back(min);
				ans.push_back(max);
				return ans;
			}	
		};

	492) Prefix match with other strings:
		Problem statement:
			Given an array of strings arr[] of size n,
			a string str and an integer k. 
			The task is to find the count of strings in arr[] 
			whose prefix of length k matches with the k-length prefix of str.

			Example 1:
				Input:
				n = 6
				arr[] = {“abba”, “abbb”, “abbc”, “abbd”, 
				“abaa”, “abca”}
				str = “abbg”
				k = 3
				Output: 
				4 
			Explanation:
			“abba”, “abbb”, “abbc” and “abbd” have their prefix of length 3 equal to 3-length prefix of str i.e., "abb".
			
			Example 2:
			Input:
			n = 3
			arr[] = {“geeks”, “geeksforgeeks”, “forgeeks”}
			str = “ge”
			k = 5
			Output: 
			0
			Explanation:
			There do not exists any prefix of str with length 5. So, there are no matches possible.

			Your Task:  
			You don't need to read input or print anything. 
			Your task is to complete the function klengthpref() which takes the array of 
			strings arr[], its size n and an integer k, a string str as input parameters 
			and returns the count of strings in arr[] whose prefix of 
			length k matches with the k length prefix of str.

			Expected Time Complexity: O(n*l) where l is the length of the longest word in arr[].
			Expected Auxiliary Space: O(n*l) where l is the length of the longest word in arr[].

			Constraints:
				1 <= n <= 1000
				1 <= |arr[i]| , |str| <= 1000
				1 <= k <= 1000
				arr[i], str must contain only lowercase English alphabets

		class Solution{ 
			private:
			bool checkPrefix(string sample, string main, int k){
				int i=0;
				if(sample.size() < k)
					return 0;
					
				while(k){
					if(sample[i] != main[i])
						return 0;
					i++,k--;
				}
				return 1;
			}
			public:
			int klengthpref(string arr[], int n, int k, string str){    
				if(str.size() < k)
					return 0;
				
				int cnt=0;
				for(int i=0; i<n; i++) {
					string crtnString = arr[i];
					
					if(checkPrefix(arr[i], str, k))
						cnt++;
				}
				return cnt;
			}
		};
		
	493) Largest Number formed from an Array:
		Problem statement:
			Given an array of strings arr[] of length n representing non-negative integers,
			arrange them in a manner, such that, after concatanating them in order,
			it results in the largest possible number.
			Since the result may be very large, return it as a string.

			Example 1:
				Input: 
				n = 5
				arr[] =  {"3", "30", "34", "5", "9"}
				Output: "9534330"
				Explanation: 
				Given numbers are  {"3", "30", "34", "5", "9"}, 
				the arrangement "9534330" gives the largest value.

			Example 2:
				Input: 
				n = 4
				arr[] =  {"54", "546", "548", "60"}
				Output: "6054854654"
				Explanation: 
				Given numbers are {"54", "546", "548", "60"}, the 
				arrangement "6054854654" gives the largest value.

			Your Task:  
				You don't need to read input or print anything.
				Your task is to complete the function printLargest() which takes the
				array of strings arr[] as a parameter and returns a string denoting the answer.

			Expected Time Complexity: O(n*log(n) ).
			Expected Auxiliary Space: O(n).

			Constraints:
				1 ≤ n ≤ 10^5
				0 ≤ arr[i] ≤ 10^18
				Sum of all the elements of the array is greater than 0.

		class Solution{
			public:
			// The main function that returns the arrangement with the largest value as
			// string.
			// The function accepts a vector of strings
			string printLargest(int n, vector<string> &arr) {
				string ans;
				
				sort(arr.begin(), arr.end(), [](string a, string b){
					return a+b > b+a;
				});
				
				for(auto s : arr)
					ans += s;
				return ans;
			}
		};

		//or
			class Solution{
				public:
					// The main function that returns the arrangement with the largest value as
					// string.
					// The function accepts a vector of strings
				bool static comp(string a, string b){
					return (a+b) > (b+a);
				}
				string printLargest(int n, vector<string> &arr) {
					string ans;
					sort(arr.begin(), arr.end(), comp);
					for(auto s : arr)
						ans += s;
					return ans;
				}
			};

			class Solution{
				public:
				// The main function that returns the arrangement with the largest value as
				// string.
				// The function accepts a vector of strings
				static bool comp(string a, string b){
					string s1,s2;
					s1 = a+b, s2 = b+a;
					return s1>s2;
				}
				string printLargest(int n, vector<string> &arr) {
					string ans;
					sort(arr.begin(), arr.end(), comp);
					for(auto s : arr)
						ans += s;
					return ans;
				}
			};

	494) Count Occurences of Anagrams:
		Problem statement:
			Given a word pat and a text txt. Return the count of the occurrences of anagrams of the word in the text.
			Example 1:
				Input:
				txt = forxxorfxdofr
				pat = for
				Output: 3
				Explanation: for, orf and ofr appears
				in the txt, hence answer is 3.

			Example 2:
			Input:
			txt = aabaabaa
			pat = aaba
			Output: 4
			Explanation: aaba is present 4 times
			in txt.
			Your Task:
				Complete the function search() which takes two strings pat, txt,
				as input parameters and returns an integer denoting the answer. 
				You don't need to print answer or take inputs.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(26) or O(256)

			Constraints:
			1 <= |pat| <= |txt| <= 10^5
			Both strings contain lowercase English letters.	

		// Not Optimized:
			class Solution{
				private:
				bool checkMapper(int p1[], int p2[]){
					for(int u=0; u<26; u++)
						if(p1[u] != p2[u])
							return 0;
					return 1;
				}
				public:
				int search(string pat, string txt) {
					int FreqPat[26] = {0};
					
					// mapping for pat
					for(int a=0; a<pat.size(); a++)
						FreqPat[pat[a]-'a']++;
					
					int cnt=0;
					for(int i=0; i<=(txt.size()-pat.size()); i++){
						string sub = txt.substr(i, pat.size());
						
						// mapping
						int FreqTxt[26] = {0};
						for(int j=0; j<sub.size(); j++)
							FreqTxt[sub[j]-'a']++;
						
						if(checkMapper(FreqPat, FreqTxt))
							cnt++;
					}
					return cnt;
				}
			};

		// Optimized (Sliding Window approach):
			class Solution{
				private:
				bool checkMapper(int p1[], int p2[]){
					for(int u=0; u<26; u++)
						if(p1[u] != p2[u])
							return 0;
					return 1;
				}
				public:
				int search(string pat, string txt) {
					int FreqPat[26] = {0};
					
					// mapping for pat
					for(int a=0; a<pat.size(); a++)
						FreqPat[pat[a]-'a']++;
					
					int cnt=0;
					int FreqTxt[26] = {0};

					// mapping
					string sub = txt.substr(0, pat.size());
					for(int j=0; j<sub.size(); j++)
						FreqTxt[sub[j]-'a']++;
					
					if(checkMapper(FreqPat, FreqTxt))
							cnt++;
					
					for(int i=1; i<=(txt.size()-pat.size()); i++){
						
						// Sliding Window
						FreqTxt[txt[(i-1)] - 'a']--;
						FreqTxt[txt[i+pat.size()-1] - 'a']++;

						if(checkMapper(FreqPat, FreqTxt))
							cnt++;
					}
					return cnt;
				}
			};

	495) Bag of Tokens:
		Problem statement:
			You start with an initial power of power, 
			an initial score of 0, and a bag of tokens given as an integer array tokens, 
			where each tokens[i] donates the value of tokeni.
			Your goal is to maximize the total score by strategically playing these tokens.
			In one move, you can play an unplayed token in one of the two ways (but not both for the same token):

			Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score.
			Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score.
			Return the maximum possible score you can achieve after playing any number of tokens.

			Example 1:
			Input: tokens = [100], power = 50
			Output: 0
			Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100).
			Example 2:
			Input: tokens = [200,100], power = 150
			Output: 1
			Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1.
			There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1.
			Example 3:
			Input: tokens = [100,200,300,400], power = 200
			Output: 2

			Explanation: Play the tokens in this order to get a score of 2:
			Play token0 (100) face-up, reducing power to 100 and increasing score to 1.
			Play token3 (400) face-down, increasing power to 500 and reducing score to 0.
			Play token1 (200) face-up, reducing power to 300 and increasing score to 1.
			Play token2 (300) face-up, reducing power to 0 and increasing score to 2.
			The maximum score achievable is 2.

			Constraints:
				0 <= tokens.length <= 1000
				0 <= tokens[i], power < 10^4
	
		class Solution {
			public:
			int bagOfTokensScore(vector<int>& tokens, int power) {
				int mxScore=0;
				sort(tokens.begin(), tokens.end());
				int powerReducer=0, elementAdder=1, index=0;
				for(int i=0; index < tokens.size()-powerReducer; i++){
					if(power >= tokens[index]){
						mxScore++;
						power -= tokens[index++];
					}else{
						if(index == tokens.size() - elementAdder)
							break;
						power += tokens[tokens.size() - elementAdder];
						mxScore--;
						if(mxScore == -1)
							break;
						elementAdder++;
						powerReducer++;
					}
				}
				return (mxScore==-1) ? 0 : mxScore;
			}
		};

		// Clean Code:
			class Solution {
				public:
				int bagOfTokensScore(vector<int>& tokens, int power) {
					int mxScore=0, mainMX=0;
					int right=0, left=tokens.size()-1;
					sort(tokens.begin(), tokens.end());

					while(right <= left){
						if(power >=  tokens[right]){
							power -= tokens[right];
							mxScore++;
							mainMX = max(mxScore, mainMX);
							right++;
						}else if(mxScore > 0){
							mxScore--;
							power += tokens[left--];
						}else{
							break;
						}
					}
					return mainMX;
				}
			};

	496) Base Conversion:
		Problem statement
			You are given a number ‘N’ as a string in base ‘B’.
			Your task is to convert ‘N’ in base 10.
			If it’s impossible to convert ‘N’ into base 10, then you need to print -1.

			Note :
			1. ‘N’ contains only digits ‘0’ to ‘9’ and English letters ‘A’ to ‘F’.
			2. Decimal equivalent of 0 is 0, 1 is 1, . . .9 is 9, A is 10, B is 11, . . . F is 15.
			Constraints:
				1 <= T <= 5
				1 <= decimal( N ) <= 10 ^ 9
				1 <= B  <= 16

				Where ‘T’ is the number of test cases, decimal(N) is the decimal equivalent of ‘N’ and ‘B’ is the base of number ‘N’.
			Note:
				You do not need to print anything, it has already been taken care of. Just implement the given function.
			Sample Input 1:
				2
				10 2
				20 2
				Sample Output 1:
				2
				-1
				Explanation of Sample Input 1:
				Test Case 1 :  
				Given N = 10 and Base = 2. 
				Decimal equivalent of 10 from base 2 = 2. 

				Test Case 2 : 
				Given N = 20 and Base = 2. 
				We cannot have digit ‘2’ in a number of base 2. So, a decimal equivalent of this number is not possible. Hence, we need to print -1. 
				Sample Input 2:
				2
				B 16 
				A 11
				Sample Output 2:
				11
				10
				Explanation of Sample Input 2:
				Test Case 1 :  
				Given N = B and Base = 16. 
				Decimal equivalent of B from base 16 = 11. 

				Test Case 2 : 
				Given N = A and Base = 16.  
				Decimal equivalent of A from base 11 = 10

		#include <bits/stdc++.h> 
		int baseConversion(string &num, int base) {
			try{
				size_t pos=0;
				int result = std::stoi(num, &pos, base);
				if (pos != num.size()) {
					// If there are characters remaining in the string after conversion
					return -1;
				}
				return result;
			}catch(invalid_argument e){
				return -1;
			}catch(out_of_range e){
				return -1;
			}
		}

		// or
			/*
			Time Complexity  : O(N)
			Space Complexity : O(1)

			Where N is the total number of digits in the given number.
			*/

			int baseConversion(string &num, int base){
				int answer = 0;
				int currentbase = 1;
				int digit;
				int n = num.size();

				// Traverse all digits
				for (int i = n - 1; i >= 0; i--){
					if (num[i] >= '0' and num[i] <= '9'){
						digit = num[i] - '0';
					}else{
						digit = num[i] - 'A' + 10;
					}

					// Check for invalid number
					if (digit >= base)
						return -1;

					// Update answer and current base
					answer += (digit * currentbase);
					currentbase *= base;
				}
				return answer;
			}

	497) Swap the array elements:
		Problem statement:
			Given an array arr of n positive integers. The task is to swap every ith element of the array with (i+2)th element.
			Example 1:
				Input:
				n = 3
				arr[] = 1 2 3
				Output:
				3 2 1
				Explanation:
				Swapping 1 and 3, makes the array 3 2 1. There is only one swap possible in this array.

			Example 2:
				Input:
				n = 5
				arr[] = 1 2 3 4 5
				Output:
				3 4 5 2 1
				Explanation:
				Swapping 1 and 3, makes the array 3 2 1 4 5.
				Now, swapping 2 and 4, makes the array 3 4 1 2 5. 
				Again,swapping 1 and 5, makes the array 3 4 5 2 1.

			Your Task:
				Your task is to complete the function swapElements(), which should swap each ith element with (i+2)th element.

			Expected Time Complexity: O(n)
			Expected Auxilary Space: O(1)
			Constraints:
				1 <= n <= 10^6
				0 <= arri <= 10^9

		class Solution{
			public:
			void swapElements(int arr[], int n){
				for(int i=0; i<n-2; i++){
					swap(arr[i], arr[i+2]);
				}
			}
		};

	498) Print Anagrams Together:
		Problem statement:
			Given an array of strings, return all groups of strings that are anagrams. The groups must be created in order of their appearance in the original array. Look at the sample case for clarification.
			Note: The final output will be in lexicographic order.

			Example 1:
			Input:
			N = 5
			words[] = {act,god,cat,dog,tac}
			Output:
			act cat tac 
			god dog
			Explanation:
			There are 2 groups of
			anagrams "god", "dog" make group 1.
			"act", "cat", "tac" make group 2.

			Example 2:
			Input:
			N = 3
			words[] = {no,on,is}
			Output: 
			is
			no on
			Explanation:
			There are 2 groups of
			anagrams "is" makes group 1.
			"no", "on" make group 2.

			Your Task:
			The task is to complete the function Anagrams() that takes a list of strings as input and returns a list of groups such that each group consists of all the strings that are anagrams.

			Expected Time Complexity: O(N*|S|*log|S|), where |S| is the length of the strings.
			Expected Auxiliary Space: O(N*|S|), where |S| is the length of the strings.

			Constraints:
				1<=N<=100
				1<=|S|<=10

		class Solution{
			private:
				bool areSame(int f1[], int s1[]){
					for(int i=0; i<26; i++)
						if(f1[i] != s1[i])
							return 0;
					return 1;
				}
			public:
			vector<vector<string> > Anagrams(vector<string>& string_list) {
				// sort(string_list.begin(), string_list.end());
				vector<vector<string>> ans;
				
				for(int i=0; i<string_list.size(); i++) {
					string crntStr = string_list[i];
					if(crntStr == "0")
						continue;
						
					vector<string> temp;
					temp.push_back(crntStr);
					// mapping for crntStr
					int MapperCrntStr[26] = {0};
					for(int z=0; z<crntStr.size(); z++)
						MapperCrntStr[crntStr[z] - 'a']++;
						
					
					// iterate over whole list check all crntStr's anagrams
					for(int j=i+1; j<string_list.size(); j++){
						string sample = string_list[j];
						
						if(sample == "0")
							continue;
						
						// mapping for sample
						int MapperSample[26] = {0};
						for(int z=0; z<sample.size(); z++)
							MapperSample[sample[z] - 'a']++;
							
						if(areSame(MapperCrntStr, MapperSample)){
							temp.push_back(sample);
							string_list[j] = "0";
						}
					}
					// sort(temp.begin(), temp.end());
					ans.push_back(temp);
				}
				
				// sorting the inner vector of 2D vector's
				// for(auto& inner : ans)
				//     sort(inner.begin(), inner.end());
				
				return ans;
			}
		};

		// Concise solution:
			class Solution{
				public:
				vector<vector<string>> Anagrams(vector<string>& string_list) {
					map<string, vector<string>> mp;
					for(int i=0; i<string_list.size(); i++){
						string s = string_list[i];
						sort(s.begin(), s.end());
						mp[s].push_back(string_list[i]);
					}
					
					vector<vector<string>> ans;
					for(auto it: mp)
						ans.push_back(it.second);
					
					return ans;
				}
			};

	499) Anagram:
		Problem statement:
			Given two strings a and b consisting of lowercase characters. The task is to check whether two given strings are an anagram of each other or not. An anagram of a string is another string that contains the same characters, only the order of characters can be different. For example, act and tac are an anagram of each other.
			Note:-
			If the strings are anagrams you have to return True or else return False
			|s| represents the length of string s.

			Example 1:
			Input:a = geeksforgeeks, b = forgeeksgeeks
			Output: YES
			Explanation: Both the string have same characters with
				same frequency. So, both are anagrams.

			Example 2:
			Input:a = allergy, b = allergic
			Output: NO
			Explanation: Characters in both the strings are 
				not same, so they are not anagrams.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function isAnagram() which takes the string a and string b as input parameter and check if the two strings are an anagram of each other. The function returns true if the strings are anagram else it returns false.

			Expected Time Complexity:O(|a|+|b|).
			Expected Auxiliary Space: O(Number of distinct characters).

			Constraints:
				1 ≤ |a|,|b| ≤ 10^5

		// sorting approach:
			class Solution {
				public:
				//Function is to check whether two strings are anagram of each other or not.
				bool isAnagram(string a, string b){
					sort(begin(a), end(a));
					sort(begin(b), end(b));
					if(a == b)
						return 1;
					return 0;
				}
			};

		// mapping approach:
			-using 2 maps:
				class Solution {
					private:
						bool areSame(int *m1, int *m2){
							for(int i=0; i<26; i++)
								if(m1[i] != m2[i])
									return 0;
							return 1;
						}
					public:
					//Function is to check whether two strings are anagram of each other or not.
					bool isAnagram(string a, string b){
						if(a.size() != b.size())
							return 0;
						
						int mapperA[26] = {0}, mapperB[26] = {0};
						for(int i=0; i<a.size(); i++)
							mapperA[a[i] - 'a']++ , mapperB[b[i] - 'a']++;
							
						if(areSame(mapperA, mapperB))
							return 1;
						return 0;
					}
				};
		
			
			-using 1 map:
				class Solution {
					public:
					//Function is to check whether two strings are anagram of each other or not.
					bool isAnagram(string a, string b){
						if(a.size() != b.size())
							return 0;
						
						int MAP[26] = {0};
						for(int z=0; z<a.size(); z++)
							MAP[a[z] - 'a']++, MAP[b[z] - 'a']--;
							
						for(int e=0; e<26; e++)
							if(MAP[e] != 0)
								return false;
						return 1;
					}
				};

	500) Anagram Strings:
		Problem statement:
			Given two strings S1 and S2 . Print "1" if both strings are anagrams otherwise print "0" .
			Note: An anagram of a string is another string with exactly the same quantity of each character in it, in any order.

			Example 1:
				Input: S1 = "cdbkdub" , S2 = "dsbkcsdn"
				Output: 0 
				Explanation: Length of S1 is not same
				as length of S2.

			Example 2:
				Input: S1 = "geeks" , S2 = "skgee"
				Output: 1
				Explanation: S1 has the same quantity 
				of each character in it as S2.

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function areAnagram() which takes S1 and S2 as input and returns "1" if both strings are anagrams otherwise returns "0".

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(K) ,Where K= Contstant

			Constraints:
				1 <= |S1| <= 1000
				1 <= |S2| <= 1000 

		class Solution {
			public:
			int areAnagram(string S1, string S2) {
				sort(S1.begin(), S1.end());
				sort(begin(S2), end(S2));
				return (S1 == S2) ? 1 : 0;
			}
		};

		//or using map
			class Solution {
				public:
				int areAnagram(string S1, string S2) {
					if(S1.size() != S2.size())
						return 0;
						
					int MAP[26] = {0};
					for(int i=0; i<S1.size(); i++)
						MAP[S1[i] - 'a']++, MAP[S2[i] - 'a']--;
						
					// all elements of map should be zero.
					for(int i=0; i<26; i++)
						if(MAP[i] != 0)
							return 0;
					return 1;
				}
			};

	501) Min Manipulations to make Strings Anagram:
		Problem statement:
			Given two strings in lowercase, your task is to find minimum number of manipulations required to make two strings anagram without deleting any character. If two strings contains same data set in any order then strings are called Anagrams.

			Example 1:
			Input:
			S1 = "aba", S2 = "baa", N = 3
			Output: 0
			Explanation: Both the strings are already
			anagrams.
			
			Example 2:
			Input: 
			S1 = "ddcf", S2 = "cedk", N = 4
			Output: 2
			Explanation: We can change 'e' and 'k' in
			S2 to 'd' and 'f' to make both the strings
			anagram. 

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function minManipulation() which takes the strings S1 and S2 and their length N as inputs and returns the minimum number of manipulations required to make both the strings anagram.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1).

			Constraints:
			1<=N<=10^5
			|S1| = |S2| = N
			|S| represents the length of the string S.
		
		int minManipulation (int N, string S1, string S2) {
			int cnt=0;
			for(int i=0; i<N; i++){
				char ch = S1[i];
				if(S2.find(ch) != string::npos)
					S2[S2.find(ch)] = '0';
				else
					cnt++;
			}
			return cnt;
		}

		//or
			int minManipulation (int N, string S1, string S2) {
				int MAP[26]={0};

				for(int i=0; i<S1.size(); i++)
					MAP[S1[i] - 'a']++, MAP[S2[i] - 'a']--;
				
				int cnt=0;
				for(int a=0; a<26; a++)
					cnt += abs(MAP[a]);
					
				return cnt/2;
			}

	502) String Permutations: (Lecture-39)
		Problem statement:
			Given a string S. The task is to find all permutations (need not be different) of a given string.
			Note: return the permutations in lexicographically increasing order.

			Example 1:
			Input:
			S = AAA
			Output: AAA AAA AAA AAA AAA AAA
			Explanation: There are total 6 permutations, as given in the output.

			Example 2:
			Input:
			S = ABSG
			Output: ABGS ABSG AGBS AGSB ASBG ASGB
			BAGS BASG BGAS BGSA BSAG BSGA GABS
			GASB GBAS GBSA GSAB GSBA SABG SAGB
			SBAG SBGA SGAB SGBA
			Explanation: There are total 24 permutations, as given in the output.

			Your Task:
				This is a function problem. You only need to complete the function permutation that takes S as parameter and returns the list of permutations in lexicographically increasing order. The newline is automatically added by driver code.

			Constraints:
				1 ≤ size of string ≤ 5

			Expected Time Complexity: O(N * N!), N = length of string.
			Expected Auxiliary Space: O(N!)

		class Solution{
			private:
				void GenPermute(string main, vector<string> &ans, int i){
					if(i >= main.size()){
						ans.push_back(main);
						return ;
					}
					
					for(int j=i; j<main.size(); j++){
						swap(main[i], main[j]);
						GenPermute(main, ans, i+1);
					}
				}
			
			public:
			//Complete this function
			vector<string> permutation(string S) {
				vector<string> res;
				GenPermute(S, res, 0);
				
				sort(res.begin(), res.end());
				return res;
			}
		};

	503) Check if a string is Isogram or not:
		Problem statement:
			Given a string S of lowercase alphabets, check if it is isogram or not. An Isogram is a string in which no letter occurs more than once.

			Example 1:
			Input:
			S = machine
			Output: 1
			Explanation: machine is an isogram
			as no letter has appeared twice. Hence
			we print 1.

			Example 2:
			Input:
			S = geeks
			Output: 0
			Explanation: geeks is not an isogram
			as 'e' appears twice. Hence we print 0.

			Your Task:
			This is a function problem. You only need to complete the function isIsogram() that takes a string as a parameter and returns either true or false.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(Number of distinct characters).
			Note: N = |S|

			Constraints:
				1 <= |s| <= 10^3

		class Solution {
			public:
			bool isIsogram(string s) {
				int j=0;
				while(j<s.size()){
					for(int i=j+1; i<s.size(); i++)
						if(s[j] == s[i])
							return 0;
					j++;       
				}
				return 1;
			}
		};

		// more Optimized: using map
			class Solution {
				public:
				bool isIsogram(string s) {
					map<char, int> Freq;
					for(char c :  s){
						Freq[c]++;
						if(Freq[c] >=2)
							return 0;
					}
					return 1;
				}
			};
			
	504) Find first repeated character:
		Problem statement:
			Given a string S. The task is to find the first repeated character in it. We need to find the character that occurs more than once and whose index of second occurrence is smallest. S contains only lowercase letters.

			Example 1:
			Input: S="geeksforgeeks"
			Output: e
			Explanation: 'e' repeats at third position.

			Example 2:
			Input: S="hellogeeks"
			Output: l
			Explanation: 'l' repeats at fourth position.

			Example 3:
			Input: S="abc"
			Output: -1
			Explanation: There is no repeated character.

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function firstRepChar() which accepts a string S as input parameter and returns a string containing first repeated character in it. If there is no repeated character in the string S then return "-1".

			Expected Time Complexity: O(|S|) 
			Expected Auxiliary Space: O(1)
			where |S| denotes the length of string S.
		
		// using map:
			string firstRepChar(string s) {
				map<char, int> Freq;
				
				for(char ch: s){
					Freq[ch]++;
					if(Freq[ch] >= 2)
						return string(1, ch);
				}
				return "-1";
			}

		// using set:
			string firstRepChar(string s) {
				set<char> holder;
				
				for(char ch: s){
					if(holder.find(ch) != holder.end())         // means found
						return string(1,ch);
					else
						holder.insert(ch);
				}
				return "-1";
			}

			//or
				string firstRepChar(string s) {
					set<char> holder;
					
					for(char ch: s){
						if(holder.find(ch) != holder.end())         // means found
							return string(1,ch);
						holder.insert(ch);
					}
					return "-1";
				}

	505) Sum of numbers in string:
		Problem statement:
			Given a string str containing alphanumeric characters. The task is to calculate the sum of all the numbers present in the string.

			Example 1:
				Input:
				str = 1abc23
				Output: 24
				Explanation: 1 and 23 are numbers in the
				string which is added to get the sum as
				24.

			Example 2:
				Input:
				str = geeks4geeks
				Output: 4
				Explanation: 4 is the only number, so the
				sum is 4.

			Your Task:
				The task is to complete the function findSum() which finds and returns the sum of numbers in the string.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 <= length of the string <= 10^5
				Sum of Numbers <= 10^5

		class Solution {
			public:
			int findSum(string str){
				int ttl=0;
				for(int i=0; i<str.size(); i++){
					if(isdigit(str[i])){
						int temp = str[i] - '0', j=i+1;
						for(j=i+1;j<str.length();j++){
							if(isdigit(str[j])){
								temp = temp*10 + (str[j]-'0');
							}else{
								break;
							}
						}
						i = j;
						ttl += temp;
					}
				}
				return ttl;
			}
		};

		// Simplified version:
			class Solution {
				public:
				int findSum(string str) {
					int ttl=0;
					string temp ="";

					for(int i=0; i<str.size(); i++){
						if(isdigit(str[i]))
							temp += str[i];
						else{
							if(!temp.empty())
								ttl += stoi(temp);
							temp = "";
						}
					}
					
					if(!temp.empty())
						ttl += stoi(temp);

					return ttl;
				}
			};
	
		// using advance for loop:
			class Solution {
				public:
				int findSum(string str) {
					int total=0;

					string holder = "";
					for(char ch: str){
						if(isdigit(ch))
							holder += ch;
						else{
							if(!holder.empty())
								total += stoi(holder);
							
							holder="";
						}
					}
					
					if(!holder.empty())
						total += stoi(holder);
					
					return total;
				}
			};
	
	506) Remove common characters and concatenate:
		Problem statement:
			Given two strings s1 and s2. Modify both the strings such that all the common characters of s1 and s2 are to be removed and the uncommon characters of s1 and s2 are to be concatenated.
			Note: If all characters are removed print -1.

			Example 1:
			Input:
			s1 = aacdb
			s2 = gafd
			Output: cbgf
			Explanation: The common characters of s1
			and s2 are: a, d. The uncommon characters
			of s1 and s2 are c, b, g and f. Thus the
			modified string with uncommon characters
			concatenated is cbgf.

			Example 2:
			Input:
			s1 = abcs
			s2 = cxzca
			Output: bsxz
			Explanation: The common characters of s1
			and s2 are: a,c. The uncommon characters
			of s1 and s2 are b,s,x and z. Thus the
			modified string with uncommon characters
			concatenated is bsxz.

			Your Task:
				The task is to complete the function concatenatedString() which removes the common characters, concatenates, and returns the string. If all characters are removed then return -1.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(Number of distinct characters).
			Note: N = |Length of Strings|

			Constraints: 
				1 <= |Length of Strings| <= 10^4

		class Solution {
			public:
			string concatenatedString(string s1, string s2) {
				string ans;
				for(int i=0; i< s1.size(); i++)
					if(s2.find(s1[i]) == string::npos)
						ans += s1[i];
						
				for(int i=0; i < s2.size(); i++)
					if(s1.find(s2[i]) == string::npos)
						ans += s2[i];

				return (ans == "") ? "-1" :  ans;
			}
		};
	
	507) Binary String:
		Problem statement:
			Given a binary string S. The task is to count the number of substrings that start and end with 1. For example, if the input string is “00100101”, then there are three substrings “1001”, “100101” and “101”.

			Example 1:
				Input:
				N = 4
				S = 1111
				Output: 6
				Explanation: There are 6 substrings from
				the given string. They are 11, 11, 11,
				111, 111, 1111.

			Example 2:
				Input:
				N = 5
				S = 01101
				Output: 3
				Explanation: There 3 substrings from the
				given string. They are 11, 101, 1101.

			Your Task:
				The task is to complete the function binarySubstring() which takes the length of binary string n and a binary string a as input parameter and counts the number of substrings starting and ending with 1 and returns the count.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ |S| ≤ 10^4

		// Not Optimized:
			class Solution {
				public:
				long binarySubstring(int n, string a){
					long cnt=0;
					
					for(int i=0; i<n; i++){
						if(a[i] == '1')
							for(int j=i+1; j<n; j++)
								if(a[j] == '1')
									cnt++;
					}
					return cnt;
				}
			};

		// Optimized:
			class Solution {
				public:
				long binarySubstring(int n, string a){
					int cnt=0;
					for(char i: a)
						if(i == '1')
							cnt++;
							
					return 1l * ((cnt*(cnt-1))/2);         // type casting to long 1l or 1ll or 1LL anything you can use.
				}
			};

	508) Check If The String Is A Palindrome:
		Problem statement
			You are given a string 'S'. Your task is to check whether the string is palindrome or not. For checking palindrome, consider alphabets and numbers only and ignore the symbols and whitespaces.
			Note :
			String 'S' is NOT case sensitive.

			Example :
				Let S = “c1 O$d@eeD o1c”.
				If we ignore the special characters, whitespaces and convert all uppercase letters to lowercase, we get S = “c1odeedo1c”, which is a palindrome. Hence, the given string is also a palindrome.
			Constraints :
				1 <= T <= 100 
				1 <= Length(S) <= 10^4
				Where 'T' denotes the number of test cases and 'S' denotes the given string.
				Time Limit : 1 sec

			Sample Input 1 :
				2
				N2 i&nJA?a& jnI2n
				A1b22Ba
				Sample Output 1 :
				Yes
				No
				Explanation 1 :
				For the first test case, S = “N2 i&nJA?a& jnI2n”. If we ignore the special characters, whitespaces and convert all uppercase letters to lowercase, we get S = “n2injaajni2n”, which is a palindrome. Hence, the given string is also a palindrome.

				For the second test case, S = “A1b22Ba”. If we ignore the special characters, whitespaces and convert all uppercase letters to lowercase, we get S = “a1b22ba”, which is not a palindrome. Hence, the given string is not a palindrome.
				Sample Input 2 :
				3
				codingninjassajNiNgNidoc
				5?36@6?35
				aaBBa@
				Sample Output 2 :
				Yes
				Yes
				No

		#include <bits/stdc++.h> 
		bool checkPalindrome(string s) {
			string updated;
			for(int i=0; i<s.size(); i++)
				if(isalnum(s[i]))
					updated += s[i];
			
			// convert it to lower case
			transform(updated.begin(), updated.end(), updated.begin(), ::tolower);
			for(int i=0; i<updated.size()/2; i++)
				if(updated[i] != updated[updated.size()-i-1])
					return 0;
				
			return 1;
		}
	
	509) Maximum Index:
		Problem statement:
			Given an array a of n positive integers. The task is to find the maximum of j - i subjected to the constraint of a[i] < a[j] and i < j.
			Example 1:
				Input:
				n = 2
				a[] = {1, 10}
				Output:
				1
				Explanation:
				a[0] < a[1] so (j-i) is 1-0 = 1.

			Example 2:
				Input:
				n = 9
				a[] = {34, 8, 10, 3, 2, 80, 30, 33, 1}
				Output:
				6
				Explanation:
				In the given array a[1] < a[7] satisfying the required condition(a[i] < a[j]) thus giving the maximum difference of j - i which is 6(7-1).

			Your Task:
				The task is to complete the function maxIndexDiff() which finds and returns maximum index difference. Printing the output will be handled by driver code. 

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 ≤ n ≤ 10^6
				0 ≤ a[i] ≤ 10^9

		// Not Optimized:
			class Solution{
				public:
				int maxIndexDiff(int a[], int n) {
					int mxValue=0;
					
					for(int i=0; i<n; i++){
						for(int j=i+1; j<n; j++){
							if(a[i] <= a[j])
								mxValue = max(mxValue, j-i);
						}
					}
					return mxValue;
				}
			};

		// Optimized:
			❌Pending
	
	510) Minimum Length of String After Deleting Similar Ends:
		Problem statement:
			Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:
			Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
			Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
			The prefix and the suffix should not intersect at any index.
			The characters from the prefix and suffix must be the same.
			Delete both the prefix and the suffix.
			Return the minimum length of s after performing the above operation any number of times (possibly zero times).

			Example 1:
				Input: s = "ca"
				Output: 2
				Explanation: You can't remove any characters, so the string stays as is.

			Example 2:
				Input: s = "cabaabac"
				Output: 0
				Explanation: An optimal sequence of operations is:
				- Take prefix = "c" and suffix = "c" and remove them, s = "abaaba".
				- Take prefix = "a" and suffix = "a" and remove them, s = "baab".
				- Take prefix = "b" and suffix = "b" and remove them, s = "aa".
				- Take prefix = "a" and suffix = "a" and remove them, s = "".

			Example 3:
				Input: s = "aabccabba"
				Output: 3
				Explanation: An optimal sequence of operations is:
				- Take prefix = "aa" and suffix = "a" and remove them, s = "bccabb".
				- Take prefix = "b" and suffix = "bb" and remove them, s = "cca".

			Constraints:
				1 <= s.length <= 10^5
				s only consists of characters 'a', 'b', and 'c'.

		class Solution {
			public:
			int minimumLength(string s) {
				while(s.size()){
					if(s[0] != s[s.size()-1] || s.size()==1)
						break;
					
					char crntCh = s[0];
					// check from starting
					for(;;) {
						if(!s.size())
							break;
						if(crntCh == s[0])
							s.erase(s.begin());
						else
							break;
					}

					//check from ending
					for(;;){
						if(!s.size())
							break;
						if(crntCh == s[s.size()-1])
							s.erase(s.end()-1);
						else
							break;
					}
				}
				return s.size();
			}
		};

		// Simplified version:
			class Solution {
				public:
				int minimumLength(string s) {
					ios_base::sync_with_stdio(false);
					cin.tie(nullptr);
					cout.tie(nullptr);
					
					int left, right;
					left = 0, right = s.size()-1;

					while(left < right && s[left] == s[right]){

						char crntCh = s[left];
						while(left <= right && s[left] == crntCh)
							left++;
						
						while(right >= left && s[right] == crntCh)
							right--;
					}
					return right-left+1;
				}
			};

	511) Student Attendance Record I:
		Problem statement:
			You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:
			'A': Absent.
			'L': Late.
			'P': Present.
			The student is eligible for an attendance award if they meet both of the following criteria:
			The student was absent ('A') for strictly fewer than 2 days total.
			The student was never late ('L') for 3 or more consecutive days.
			Return true if the student is eligible for an attendance award, or false otherwise.

			Example 1:
				Input: s = "PPALLP"
				Output: true
				Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.

			Example 2:
				Input: s = "PPALLL"
				Output: false
				Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.
			
			Constraints:
				1 <= s.length <= 1000
				s[i] is either 'A', 'L', or 'P'.

		class Solution {
			public:
			bool checkRecord(string s) {
				if(s.find("LLL") != string::npos)
					return 0;
				
				int cnt=0;
				for(int i=0; i<s.size(); i++){
					if(s[i] == 'A')
						cnt++;
					if(cnt >=2)
						return 0;
				}
				return 1;
			}
		};
	
	512) Replace Spaces:
		Problem statement
			You have been given a string 'STR' of words. You need to replace all the spaces between words with “@40”.
			Constraints:
				1 <= T <= 50
				0 <= |STR| <= 100
				Where ‘|STR|’ is the length of a particular string including spaces.
				Time limit: 1 sec

			Sample Input 1:
				2
				Coding Ninjas Is A Coding Platform
				Hello World
				Sample Output 1:
				Coding@40Ninjas@40Is@40A@40Coding@40Platform
				Hello@40World
				Explanation of Sample Output 1:
				In test case 1, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40Is@40A@40Coding@40Platform

				In test case 2, After replacing the spaces with “@40” string is: 

				Hello@40World
				Sample Input 2:
				3
				Hello
				I love coding
				Coding Ninjas India
				Sample Output 2:
				Hello
				I@40love@40coding
				Coding@40Ninjas@40India    
				Explanation for Sample Output 2:
				In test case 1, After replacing the spaces with “@40” string is: 

				Hello
				In test case 2, After replacing the spaces with “@40” string is: 
				I@40love@40coding
				In test case 3, After replacing the spaces with “@40” string is: 
				Coding@40Ninjas@40India

		// using extra space
			#include <bits/stdc++.h> 
			string replaceSpaces(string &str){
				string ans;
				for(int i=0; i<str.size(); i++){
					if(str[i] == ' ')
						ans += "@40";
					else
						ans += str[i];
				}
				return ans;
			}
	
		// without using extra space:
			#include <bits/stdc++.h> 
			string replaceSpaces(string &str){
				for(int i=0; i<str.size(); i++)
					if(str[i] == ' '){
						str.erase(str.begin()+i);
						str.insert(i, "@40");
					}
				return str;
			}

	513) Search Pattern (Rabin-Karp Algorithm):
		Problem statement:
			Given two strings, one is a text string and other is a pattern string. The task is to print the indexes of all the occurences of pattern string in the text string. For printing, Starting Index of a string should be taken as 1. The strings will only contain lowercase English alphabets ('a' to 'z').

			Example 1:
			Input: 
			text = "birthdayboy"
			pattern = "birth"
			Output: 
			[1]
			Explanation: 
			The string "birth" occurs at index 1 in text.

			Example 2:
			Input:
			text = "geeksforgeeks"
			pattern = "geek"
			Output: 
			[1, 9]
			Explanation: 
			The string "geek" occurs twice in text, one starts are index 1 and the other at index 9.
			Your Task:
			You don't need to read input or print anything. Your task is to complete the function search() which takes the string text and the string pattern as input and returns an array denoting the start indices (1-based) of substring pattern in the string text. 

			Expected Time Complexity: O(|text| + |pattern|).
			Expected Auxiliary Space: O(1).

			Constraints:
				1<=|text|<=5*10^5
				1<=|pattern|<=|text|

		class Solution {
			public:
			vector <int> search(string pattern, string text) {
				vector<int> ans;
				for(int i=0; i <= (text.size() - pattern.size()); i++){
					string tester = text.substr(i, pattern.size());
					if(tester == pattern)
						ans.push_back(i+1);
				}
				return ans;
			}
		};
	
	514) Rat in a Maze Problem - I: (Lecture-40)
		class Solution{
			public:
			bool checkPathClear(vector<vector<int>> maze, int r, int c){
				if((r>=0 && r<maze.size()) && (c>=0 && c<maze.size()) && maze[r][c] == 1)
					return 1;
				return 0;
			}
			
			void MultiPathFinder(vector<vector<int>> main, int r, int c, string way, vector<string> &ans) {
				if((r == main.size()-1) && (c == main.size()-1)){
					ans.push_back(way);
					return ;
				}
				
				main[r][c] = -1;            //this -1 indicates that the current point is visited.
				// 4 choices will be there for rat
				// make sure that these new co-ordinates which you generated now they should be unVisited & path should be open
				// the co-ordinates must lies within main matrix/maze
				int newRow, newCol;
				
				// for up
				newRow = r-1, newCol = c;
				if(checkPathClear(main, newRow, newCol)){
					way += "U";
					MultiPathFinder(main, newRow, newCol, way, ans);
					way.pop_back();
				}
				
				// for left
				newRow = r, newCol = c-1;
				if(checkPathClear(main, newRow, newCol)){
					way += "L";
					MultiPathFinder(main, newRow, newCol, way, ans);
					way.pop_back();
				}
				
				// for down
				newRow = r+1, newCol = c;
				if(checkPathClear(main, newRow, newCol)){
					way += "D";
					MultiPathFinder(main, newRow, newCol, way, ans);
					way.pop_back();
				}
				
				// for right
				newRow = r, newCol = c+1;
				if(checkPathClear(main, newRow, newCol)){
					way += "R";
					MultiPathFinder(main, newRow, newCol, way, ans);
					way.pop_back();
				}
				
				main[r][c] = 1;             // this making the current point as un-Visited again, for finding next new paths.
			}
			vector<string> findPath(vector<vector<int>> &m, int n) {
				vector<string> ans;
				if(m[0][0] == 0 || m[n-1][n-1] == 0)
					return ans;
				
				string path;
				int r,c;
				r=c=0;
				MultiPathFinder(m, r, c, path, ans);
				return ans;
			}
		};
	
	515) Anagram of String:
		Problem statement:
			Given two strings S1 and S2 in lowercase, the task is to make them anagram. The only allowed operation is to remove a character from any string. Find the minimum number of characters to be deleted to make both the strings anagram. Two strings are called anagram of each other if one of them can be converted into another by rearranging its letters.

			Example 1:
				Input:
				S1 = bcadeh
				S2 = hea
				Output: 3
				Explanation: We need to remove b, c
				and d from S1.

			Example 2:
				Input:
				S1 = cddgk
				S2 = gcd
				Output: 2
				Explanation: We need to remove d and
				k from S1.
			Your Task:
				Complete the function remAnagram() which takes two strings S1, S2 as input parameter, and returns minimum characters needs to be deleted.

			Expected Time Complexity: O(max(|S1|, |S2|)), where |S| = length of string S.
			Expected Auxiliary Space: O(26)

			Constraints:
				1 <= |S1|, |S2| <= 10^5

		// using single map
			int remAnagram(string s1, string s2) {
				int cnt=0, map[26]={0};

				for(int i=0; i<s1.size(); i++)
					map[s1[i] - 'a']++;
				
				for(int i=0; i<s2.size(); i++)
					map[s2[i] - 'a']--;
				
				for(int i=0; i<26; i++)
					cnt += abs(map[i]);

				return cnt;
			}
		
		// using 2 maps
			int remAnagram(string s1, string s2) {
				int cnt=0, map1[26]={0}, map2[26] = {0};
				
				for(int i=0; i<s1.size(); i++)
					map1[s1[i] - 'a']++;
					
				for(int i=0; i<s2.size(); i++)
					map2[s2[i] - 'a']++;
				
				for(int i=0; i<26; i++)
					if(map1[i] != map2[i])
						cnt += abs(map1[i] - map2[i]);
				
				return cnt;
			}
		
		// using built-in map
			int remAnagram(string s1, string s2) {
				int cnt=0;
				map<char, int> Freq;
				
				for(int i=0; i<s1.size(); i++)
					Freq[s1[i] - 'a']++;
					
				for(int i=0; i<s2.size(); i++)
					Freq[s2[i] - 'a']--;
				
				for(auto i: Freq)
					cnt += abs(i.second);
				
				return cnt;
			}

	516) Check if two strings are k-anagrams or not:
		Problem Statement:
			Given two strings of lowercase alphabets and a value K, your task is to complete the given function which tells if  two strings are K-anagrams of each other or not.
			Two strings are called K-anagrams if both of the below conditions are true.
			1. Both have same number of characters.
			2. Two strings can become anagram by changing at most K characters in a string.

			Example:
			Input:
			str1 = "fodr", str2="gork"
			k = 2
			Output:
			1
			Explanation: Can change fd to gk

			Your Task:
				Since this is a function problem, you don't need to take any input. Just complete the given function areKAnagrams that returns true if the strings can be turned into K-anagrams, else return false.

			Constraints:
				1 ≤ length of String ≤ 10^5
				1 ≤ K ≤ length of String

		class Solution {
			public:
			bool areKAnagrams(string s1, string s2, int k) {
				if(s1.size() != s2.size())
					return 0;
					
				map<char, int> Freq;
				for(int i=0; i<s1.size(); i++)
					Freq[s1[i]]++;
					
				for(int i=0; i<s2.size(); i++)
					Freq[s2[i]]--;
				
				int cnt=0;
				for(auto i: Freq)
					cnt += abs(i.second);
				
				return ((cnt/2) <= k) ? 1 : 0; 
			}
		};
	
	517) Search Pattern (Z-algorithm):
		Problem statement:
			Given two strings, one is a text string and the other is a pattern string. The task is to print the indexes of all the occurrences of the pattern string in the text string. For printing, Starting Index of a string should be taken as 1.

			Example 1:
				Input:
				S = "batmanandrobinarebat", pat = "bat"
				Output: 1 18
				Explanation: The string "bat" occurs twice
				in S, one starts are index 1 and the other
				at index 18. 

			Example 2:
				Input: 
				S = "abesdu", pat = "edu"
				Output: -1
				Explanation: There's not substring "edu"
				present in S.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function search() which takes the string S and the string pat as inputs and returns an array denoting the start indices (1-based) of substring pat in the string S. 
			Note:
				You don't need to return -1 yourself when there are no possible answers, just return an empty list.

			Expected Time Complexity: O(|S|).
			Expected Auxiliary Space: O(|S|).

			Constraints:
				1 ≤ |S| ≤ 10^5
				1 ≤ |pat| ≤ |S|
		
		class Solution {
			public:
			vector <int> search(string pat, string txt) {
				vector<int> ans;
				for(int i=0; i <= (txt.size() - pat.size()); i++){
					string check = txt.substr(i, pat.size());
					if(check == pat)
						ans.push_back(i+1);
				}
				return ans;
			}		
		};

	518) Match specific pattern:
		Problem statement:
			Given a dictionary of words and a pattern. Every character in the pattern is uniquely mapped to a character in the dictionary. Find all such words in the dictionary that match the given pattern. 
			Example 1:
			Input:
			N = 4
			dict[] = {abb,abc,xyz,xyy}
			pattern  = foo
			Output: abb xyy
			Explanation: xyy and abb have the same
			character at index 1 and 2 like the
			pattern.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function findMatchedWords() which takes an array of strings dict[] consisting of the words in the dictionary and a string, Pattern and returns an array of strings consisting of all the words in the dict[] that match the given Pattern in lexicographical order.

			Expected Time Complexity: O(N*K) (where K is the length of the pattern).
			Expected Auxiliary Space: O(N).

			Constraints:
				1 <= N <= 10

		vector<string> findMatchedWords(vector<string> dict,string pattern) {
			vector<string> ans;
			map<char, int> forPTRN;
			for(int i=0; i<pattern.size(); i++)
				forPTRN[pattern[i]]++;
			
			vector<int> of_PTRN;
			for(auto i: forPTRN)
				of_PTRN.push_back(i.second);
				
			sort(of_PTRN.begin(), of_PTRN.end());
			for(int o=0; o<dict.size(); o++){
				string crntString = dict[o];
				
				//map for crntString
				map<char, int> mp_crntString;
				for(int u=0; u<crntString.size(); u++)
					mp_crntString[crntString[u]]++;
					
				vector<int> of_crnt_string;
				for(auto i: mp_crntString)
					of_crnt_string.push_back(i.second);
				
				sort(of_crnt_string.begin(), of_crnt_string.end());
				
				//Generation done now testing the both vector of_crnt_string & of_PTRN
				if(of_PTRN.size() == of_crnt_string.size()){
					int q;
					for(q=0; q<of_crnt_string.size(); q++)
						if(of_crnt_string[q] != of_PTRN[q]) 
							break;
					if(q == of_PTRN.size())
						ans.push_back(crntString);
				}
			}
			return ans;
		}
	
	519) Teacher's Birthday:
		Problem statement
			Today is the teacher's birthday. She has purchased 'N' chocolates to distribute among 'K' students.
			The teacher distributes the chocolates one at a time. She selects the student who has received the least number of chocolates so far. If there are multiple students with the least number of chocolates, she randomly chooses one of them to give the next chocolate.
			What is the maximum quantity of chocolates a single student could potentially receive?
			Example:
			'N'= 5
			'K'= 2
			Let the students be A and B.
			First chocolate is given to A. (randomly chosen between A and B)
			Second chocolate is given to B.
			Third chocolate is given to A. (randomly chosen between A and B)
			Fourth chocolate is given to B.
			Fifth chocolate is given to B. (randomly chosen between A and B)
			Hence maximum quantity of chocolates a single student could potentially receive is 3.
			Constraints:
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^5
				1 <= ‘K’ <= 10^5
				1 <= ‘A[i]’ <= 10^9

				Time Limit: 1 sec
			Sample Input 1:
				2
				21 7
				26 7
				Sample Output 1:
				3
				4
				Explanation of sample input 1:
				For test case 1:
				Since the number of chocolates is divisible by the number of students, the maximum number of chocolates any student can receive is 3.

				For test case 2:
				Given the same number of students as the previous scenario but with an additional 5 chocolates, the teacher continues to randomly select the student with the fewest chocolates. As a result, 5 out of 7 students will receive an extra chocolate, leading to a maximum of 4 chocolates received by any one student.
				Sample Input 2:
				3
				72 33
				47 3
				97 26
				Sample Output 2:
				3
				16
				4

		int teacherBirthday(int n, int k) {
			return (n%k == 0) ? n/k : (n/k)+1;
		}

		//or
		int teacherBirthday(int n, int k) {
			return (n%k) ? (n/k)+1 : n/k ;
		}

	520) Bag and Balls:
		Problem statement
			You are given the binary string 'S' of 'N' characters numbered from '0' to 'N - 1'.
			There is an empty bag and some balls initially. You will perform the following procedure.
			Start from the 'S[0]' and move through every character of the string in the given order.
			If you find the character '1', put '1' ball in the bag, and if you find a '0', take out '1' ball from the bag if the bag is not empty.
			You are required to find how many times you will remove the ball from the bag.
			Example:
				N = 4
				S = '0110'
				Initially, the bag is empty.
				At 'S[0]', you will do nothing as the bag is empty.
				At 'S[1]' and 'S[2]', you will add a '1' ball to the bag. So the bag has '2' balls.
				At 'S[2]', you will remove the '1' ball from the bag.
				As you have removed the ball once, the answer for this case is '1'.
			Constraints:
				1 <= 'N' <= 10^5
				0 <= 'S[i]' <= 1
				Time limit: 1 sec

			Sample input 1:
				2
				3 
				000
				3
				100
				Sample output 1:
				0
				1
				Explanation of sample input 1:
				For test case 1:
				As there is no character '1' in the string, you will not add or remove any balls from the bag.
				So, the answer for this case is '0'.

				For test case 2:
				Initially, the bag is empty.
				At 'S[0]', you will add a '1' ball to the bag. So the bag has '1' ball.
				At 'S[1]', you will remove the '1' ball from the bag. So, the bag is empty again.
				At 'S[2]', you will do nothing as the bag is empty.
				As you have removed the ball once, the answer for this case is '1'.
				Sample input 2:
				2
				5
				10101
				6
				100110
				Sample output 2:
				2
				2
		
		int numberOfRemovals(int n, string &s) {
			int removerCount=0, balls=0;
			for(int i=0; i<n; i++){
				if(s[i] == '1')
					balls++;
				else{
					if(balls >=1)
						removerCount++, balls--;
				}
			}
			return removerCount;
		}

	521) NINJA’S CALCULATOR
		Problem Statement:
			Ninja and his friends go to the park every day. But now, due to his homework, he wasn’t able to go to the park with his friends. So when he figures out, he notes that a lot of time is consumed in doing maths homework where he has to convert some real number to a binary string. So he is deciding to build a calculator which can convert real numbers to the binary string.
			So help our Ninja to write a code for the calculator, which can convert the real numbers into a binary string and save his time to join his friends in the park.
			So your task is to write a code that can convert real numbers between ‘0’ and ‘1’into a binary string.
			For example, you have given a number “0.750” so you have to convert it in its binary form that is “0.110”
			Sample Input 1 :
				2
				0.625
				0.72
				Sample Output 1 :
				0.101
				ERROR
				Explanation Of Sample Input 1 :
				Test Case 1:
				In the first line, there is the number of test cases i.e., 1, and in the next line ‘0.625’ is the real number in a decimal form which we have to convert into a binary string.
				Here, we have started with multiplying the number that is ‘N’with ‘2’ and hence write its binary number like 
				String s= ‘0’+ ‘.’+ ‘1’+ ‘0’+ ‘1’   =[0.101].

				Test case 2:
				Here the number is “0.72” on multiplication with 2 we see we didn’t get its equivalent Binary number or we can say that we weren’t able to convert our number into binary form up to the 32 characters as 32 can be the maximum length of our string so we return our string as “ERROR”.
				Sample Input 2 :
				2
				0.248
				0.50
				Sample Output 2 :
				ERROR
				0.1
	
		#include <bits/stdc++.h> 
		string toBinaryCalculator(double num) {
			string ans;
			int flag=0, iteration=0;
			while(num > 0){
				if(iteration > 31){
					flag = 1;
					break;
				}
				int value = num  *= 2;
				string s = to_string(value);
				ans+=s;
				
				num -= value;
				iteration++;
			}
			ans.insert(0, "0.");
			return (flag) ? "ERROR" : ans;
		}

	522) Online Stock Span:
		Problem statement
			Ninja Coin is a famous crypto-currency in Ninja Land. Ninja has an array/list ‘PRICE’ of size ’N’ where ‘PRICE[i]’ is the price of a Ninja Coin on an ith day in INR, where 0 <= 'i' <= N-1.
			The span of the Ninja Coin price on an ith day is defined as the maximum number of consecutive days (starting from the ith day and going backward) for which the price of a Ninja Coin was less than or equal to its price at ith day.
			Your task is to return an array/list of size ‘N’ where the ith integer is the span of Ninja Coin price on an ith day. Go through the example for more clarity.
			For Example :
			Let the price of Ninja Coin for 5 consecutive days is [4, 2, 3, 3, 7].
			Then the span of Ninja Coin on the 0th day is 1 because we cannot move backward from day 0.
			The span of Ninja Coin on the 1st day is 1 because the price on day 0 is 4 which is greater than 2, so the only day 1 is counted.
			The span of Ninja Coin on the 2nd day is 2 because the price on day 2 and day 1 is less than or equal to 3 and then on day 0 price is 4 which is greater than 3, so we count day 2 and day 1.
			The span of Ninja Coin on the 3rd day is 3 because the price on day 3, day 2, and day 1 is less than or equal to 3, and on day 0 price is 4 which is greater than 3, so we count day 3, day 2, and day 1.
			The span of Ninja Coin on the 4th day is 5 because its value is higher than all previous days values.    
			Thus you should return an array/list [1, 1, 2, 3, 5].
			Constraints :
				1 <= T <= 50
				1 <= N <= 10000
				1 <= PRICE[i] <= 10^9

				Where ‘T’ is the number of test cases, 'N' is the size of ‘PRICE’, ‘PRICE[i]’  is the price of a Ninja Coin on an ith day in INR.
				Time limit: 1 sec.
			Sample Input 1 :
				2
				3
				1 1 1
				5
				4 2 3 3 6
				Sample Output 1 :
				1 2 3
				1 1 2 3 5
				Explanation of sample input 1 :
				In the first test case, the price of Ninja Coin is the same for all three consecutive days, so its span at ith day will be the number of days till ‘i’.

				For the second test case, refer to the problem statement for an explanation.
				Sample Input 2 :
				2
				7
				100 80 60 70 60 75 85
				5
				5 4 3 2 1
				Sample Output 2 :
				1 1 1 2 1 4 6
				1 1 1 1 1

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<int> findSpans(vector<int> &price) {
				vector<int> ans;

				for(int i=0; i<price.size(); i++){
					int cnt=0;
					for(int j=i; j>=0; j--) {
						if(price[i] < price[j])
							break;
						cnt++;
					}
					ans.push_back(cnt);
				}
				return ans;
			}

	523) Cyclically rotate an array by one:	
		Problem statement:
			Given an array, rotate the array by one position in clock-wise direction.
			Example 1:
			Input:
			N = 5
			A[] = {1, 2, 3, 4, 5}
			Output:
			5 1 2 3 4

			Example 2:
			Input:
			N = 8
			A[] = {9, 8, 7, 6, 4, 2, 1, 3}
			Output:
			3 9 8 7 6 4 2 1

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function rotate() which takes the array A[] and its size N as inputs and modify the array in place.
			
			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1<=N<=105
				0<=a[i]<=105

		void reverser(int arr[], int s, int e){
			while(s<e)
				swap(arr[s++], arr[e--]);
		}

		void rotate(int arr[], int n) {
			reverser(arr, 0, n-1);
			reverser(arr, 1, n-1);
		}

	524) Rotate and delete:
		Problem statement:
			Given an array arr[] of N integers. Do the following operation n-1 times. For every Kth operation:
			Right rotate the array clockwise by 1.
			Delete the (n-k+1)th last element.
			Now, find the element which is left at last.

			Example:
				Input:
				2
				4
				1 2 3 4
				6
				1 2 3 4 5 6

			Output:
				2
				3
			Explanation:
				A = {1, 2, 3, 4, 5, 6}. Rotate the array clockwise i.e. after rotation the array A = {6, 1, 2, 3, 4, 5} and delete the last element that is {5} that will be A = {6, 1, 2, 3, 4}.
				Again rotate the array for the second time and deletes the second last element that is {2} that will be
				A = {4, 6, 1, 3}, doing these steps when he reaches 4th time, 4th last element does not exist. Then he deletes 1st element ie {1} that will be A={3, 6}. So, continuing this procedure the last element in A is {3}.
				So, the output will be 3.
			Input:
				The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case contains two lines. The first line of each test case contains an integer N. Then in the next line are N space separated values of the array arr[].
			Output:
				For each test case in a new line print the required result.
			Your task:
				The task is to complete the function rotateDelete() which does operations as per the given query.
			Constraints:
				1 <= T <= 110
				1 <= N <= 10^6
				1 <= A[i] <= 10^7

		class Solution{
			public:
			int rotateDelete(vector<long long> v, int n){
				int move=1;
				
				while(v.size() >= 2){
					rotate(v.begin(), v.begin()+(v.size()-1), v.end());
					if(move >= v.size()){
						v.erase(v.begin());
					}else{
						v.erase(v.end()-move);
					}
					move++;
				}
				return v[0];
			}
		};

	#Weekly Contenst 116:
		525) Compare Sums:
			Problem statement:
				You are given an array 'A' of 'N' integers which contains integers in ascending
				order followed by integers in descending order.
				For example in the array [1, 3, 5, 2, 1], the ascending part is [1, 3, 5], and the
				descending part is [5, 2, 1].
				You want to find out which part has the larger sum of the values.
				Return 'O' if the sum of the values in the ascending part is greater than the
				descending part, '1' if the sum of the values in the descending part is greater
				than the ascending part, and '-1' if both the sums are equal.
				Example:
				N = 6
				A = [1, 2, 5, 3, 2]
				The ascending and descending parts of the array are ['1'. '2'. '5'] and ['5', '3', '2'].
				The sum of the values in descending part i.e., '10' is greater than the ascending
				part i.e., '8'.
				So the answer for this case is '1'.

				Constraints:
					1 <= 'N' <= 10^5
					1 <= A[i] <= 10^5
					There is some fixed value 'j' ('0' <= j' <= 'N - 1') such that 'A[i - 1]' < 'A[i]" if 'i' <= 'j'
					and 'A[i - 1]' > 'A[i]' otherwise.
					Time limit: 1 sec

				Sample input 1:
					2
					3
					1 3 5
					4
					1 2 5 3
					Sample output 1:
					0
					-1
					Explanation of sample input 1:
					For test case 1:
					The ascending and descending parts of the array are ['1', '3', '5'] and ['5'].
					The sum of the values in ascending part i.e.. '9' is greater than the
					descending part i.e., '5'.
					So the answer for this case is '0'.
					For test case 2:
					The ascending and descending parts of the array are ['1', '2', '5'] and ['5'
					'3"].
					The sum of the values in ascending part i.e., '8' is the same as the
					descending part i.e., '8'.
					So the answer for this case is '-1'.
					Sample input 2:
					2
					6
					1 2 3 4 2 1
					3
					5 2 1
					Sample output 2:
					0
					1

			int findTheLarger(int n, vector<int> &v) {
				int ascend=v[0], descend=0;
				int i=1;
				for(i; i<v.size(); i++){
					if(v[i-1] > v[i])
						break;
					ascend += v[i];
				}

				i--;
				for(i; i<v.size(); i++)
					descend += v[i];        

				// cout<<ascend<<"\t"<<descend<<"\n";
				if(ascend > descend)
					return 0;
				else if(descend > ascend)
					return 1;
				else
					return -1;
			}
		
		526) Slope:
			Problem statement:
				Given a string 'S' containing lowercase English alphabets, where each letter
				represents the elevation of a land. Where 'a' has the lowest elevation, increasing gradually up to 'z'.
				Find the maximum length of a substring with strictly increasing or strictly decreasing slopes.
				Note: A substring Is a contiguous Sequence of characters in a string
				Example:
					‘S’ : “ninjas”
				Return 3
				The substring "nja" is longest strictly decreasing.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^6 where 'N' is the length of 'S.
					Time Limit: 1 sec
				Sample Input 1:
					2
					love
					coding
					Sample Output 1:
					3
					3
					Explanation of sample input 1:
					For 1st test case:
					The substring "lov" is longest strictly increasing.
					For 2nd test case:
					The substring "din" is longest strictly increasing.
				Sample Input 2:
					3
					g
					kxkszhk
					pphyki
				Sample Output 2:
					1
					3
					3				

			int solve(string &s) {
				int values[26] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26};
				map<char, int> mapping;
				
				char ch='a';
				for(int i=0; i<26; i++)
					mapping[ch++] = values[i];
				
				vector<int> holder;
				for(int i=0; i<s.size(); i++)
					holder.push_back(mapping[s[i]]);

				int mxLong=1, cnt=1;
				// for increasing 
				for(int i=1; i<holder.size(); i++){
					if(holder[i-1] < holder[i])
						cnt++;
					else{
						mxLong = max(cnt, mxLong);
						cnt=1;
					}
				}

				// for decreasing
				cnt=1;
				for(int i=1; i<holder.size(); i++){
					if(holder[i-1] > holder[i])
						cnt++;
					else{
						mxLong = max(cnt, mxLong);
						cnt=1;
					}
				}
				mxLong = max(mxLong, cnt);
				return mxLong;
			}
	
		527) Xor SubArray:
			Problem statement:
				You are given an array 'A' of 'N" integers numbered from '0' to 'N - 1. You are
				also given another integer 'K. Your task is to find the bitwise 'XOR' of all the
				subarrays having bitwise 'XOR' value less than or equal to 'K.

				Let's say the bitwise 'XOR' values of the subarrays are 'X1', 'X2'... "Xj. You have
				to choose only those subarrays whose bitwise 'XOR' value is less than or equal
				to 'K. Let those values be 'X1, 'X2' and 'X3". You have to find the 'XOR' of all
				these values.

				Your task is to tell the bitwise 'XOR' of all the subarrays having bitwise 'XOR'
				value less than or equal to 'K' and return it.
				Note: Consider bitwise 'XOR' of an empty subarray as '0'.
				Example:
				'N' = 4
				'K' = 4
				'A' = [1, 2, 3. 4]

				Let's find the bitwise 'XOR' values of all the subarrays:
				For [1]: 'X1' = 1
				For [1, 2]: 'X2' = (1 ^ 2) = 3
				For [1, 2, 3]: 'X3' = (1 ^ 2 ^ 3) = 0
				For [1, 2, 3, 4]: 'X4* = (1 ^ 2 ^ 3 ^ 4) = 4
				For [2]: 'X5' = 2
				For [2, 3]: 'X6' = (2 ^ 3) = 1
				For [2, 3, 4]: 'X7' = (2 ^ 3 ^ 4) = 5
				For [3]: 'X8' = 3
				For [3, 4]: X9 = (3 ^ 4) = 7
				For [4]: 'X10' = 4
				Here, the 'XOR' values less than or equal to '4' are: 'X1', 'X2', 'X3'. 'X4', 'X5', 'X6',
				'X8', and 'X10'.
				The bitwise 'XOR' of all these values is: (1 ^ 3^0^ 4^2^1^3 ^ 4), which is
				equal to '2'.
				Constraints:
					1 <= T' <= 10
					1 <= 'N' <= 10^5
					0 <= 'K' <= 10^9
					0 <= 'A[i]' <= 10^9
					Time Limit: 1 sec
				Sample Input 1:
					2
					4 3
					1 0 5 3
					2 0
					5 20
					Sample Input 1:
					3
					0
					Explanation of sample input 1:
					For test case 1:
					The subarrays with bitwise 'XOR' value less than or equal to '3' are: [1]. [0].
					[1, 0]. [3].
					The bitwise 'XOR' of all these subarrays is '3'.
					For test case 2:
					Here, only the empty subarray has a bitwise 'XOR' value less than or equal
					to '0'. Hence, the answer for this test case is '0'.
				Sample Input 2:
					2
					6 20
					4 5 0 11 15 27
					5 30
					22 1 4 00
					Sample Output 2:
					31
					18

			// Not Optimized:
				int xorSubarrays (int n, int k, vector <int> &a) {
					vector<int> valueHolder;
					for(int i=0; i<n; i++){
						int crntXOR=a[i];
						valueHolder.push_back(crntXOR);
						for(int j=i+1; j<n; j++){
							crntXOR ^= a[j];
							valueHolder.push_back(crntXOR);
						}
					}

					int ans=0;
					for(int i=0; i<valueHolder.size(); i++)
						if(valueHolder[i] <= k)
							ans ^= valueHolder[i];

					return ans;
				}
	
	528) Count Elements With Maximum Frequency:
		Problem statement:
			You are given an array nums consisting of positive integers.
			Return the total frequencies of elements in nums such that those elements all have the maximum frequency.
			The frequency of an element is the number of occurrences of that element in the array.
		
			Example 1:
				Input: nums = [1,2,2,3,1,4]
				Output: 4
				Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
				So the number of elements in the array with maximum frequency is 4.

			Example 2:
				Input: nums = [1,2,3,4,5]
				Output: 5
				Explanation: All elements of the array have a frequency of 1 which is the maximum.
				So the number of elements in the array with maximum frequency is 5.
			
			Constraints:
				1 <= nums.length <= 100
				1 <= nums[i] <= 100
		
		class Solution {
			public:
			int maxFrequencyElements(vector<int>& nums) {
				map<int, int> Freq;
				for(int i=0; i<nums.size(); i++)
					Freq[nums[i]]++;
				
				vector<int> holder;
				for(auto i: Freq)
					holder.push_back(i.second);

				int mxValue = *max_element(holder.begin(), holder.end());
				int cnt=0;
				for(int i: holder)
					if(i == mxValue)
						cnt += i;

				return cnt;
			}
		};
	
	529) Check if frequencies can be equal: 	❌Pending
		Problem statement:
			Given a string s which contains only lower alphabetic characters, check if it is possible to remove at most one character from this string in such a way that frequency of each distinct character becomes same in the string. Return true if it is possible to do else return false.
			Note: The driver code print 1 if the value returned is true, otherwise 0.

			Example 1:
				Input:
				s = "xyyz"
				Output: 
				1 
				Explanation: 
				Removing one 'y' will make frequency of each character to be 1.
				Example 2:

				Input:
				s = "xxxxyyzz"
				Output: 
				0
				Explanation: 
				Frequency can not be made same by removing at most one character.
				Your Task:  
				You dont need to read input or print anything. Complete the function sameFreq() which takes a string as input parameter and returns a boolean value denoting if same frequency is possible or not.

				Expected Time Complexity: O(|s|) 
				Expected Auxiliary Space: O(1)

				Constraints:
				1 <= |s| <= 10^5

		//User function template for C++
		class Solution{
			private:
			bool checkAllEqual(map<char, int> F){
				auto itr = F.begin();
				int prev = itr->second;
				itr++;
				for(itr; itr!=F.end(); itr++){
					int crnt = itr->second;
					if(prev != crnt){
						return 0;
					}
					prev = crnt;
				}
				return 1;
			}
			public:	
			bool sameFreq(string s) {
				map<char, int> Freq;
				
				for(char ch: s)
					Freq[ch]++;
					
				// checking for every char, what happen if we remove the current char.
				if(checkAllEqual(Freq))
					return 1;
				
				for(int i=0; i<s.length(); i++){
					string ch = string(1,s[i]);
					
					map<char, int> newMap;
					s.erase(s.begin()+i);
					
					for(char c: s)
						newMap[c]++;
					
					if(checkAllEqual(newMap))
						return 1;
						
					s.insert(i,ch);
				}
				return 0;
			}
		};
	
	530) Find K Pairs with Smallest Sums:
		Problem statement:
			You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.
			Define a pair (u, v) which consists of one element from the first array and one element from the second array.
			Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.		

			Example 1:
				Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
				Output: [[1,2],[1,4],[1,6]]
				Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

			Example 2:
				Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
				Output: [[1,1],[1,1]]
				Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
		
			Constraints:
				1 <= nums1.length, nums2.length <= 105
				-109 <= nums1[i], nums2[i] <= 109
				nums1 and nums2 both are sorted in non-decreasing order.
				1 <= k <= 104
				k <= nums1.length * nums2.length

		// MLE (Memory Limit Exceeded)
		class Solution {
			public:
			static bool sortBySum(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b){
				if(a.second < b.second)
					return 1;
				return 0;
			}
			vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
				ios_base::sync_with_stdio(false);
				cin.tie(nullptr);
				cout.tie(nullptr);
				
				vector<pair<pair<int, int>, int>> holder;
				for(int a=0; a<nums1.size(); a++)
					for(int b=0; b<nums2.size(); b++){
						pair<int, int> p = {nums1[a], nums2[b]};
						holder.push_back({p, (nums1[a]+nums2[b])});
					}

				sort(holder.begin(), holder.end(), sortBySum);

				// for(auto i: holder){
				//     cout<<i.first.first <<"\t"<< i.first.second<<"\t" <<i.second<<endl;
				// }
				// cout<<endl;
			
				vector<vector<int>> ans;
			
				int i=0;
				while(k--){
					// pair<int, int> temp = holder[i++].first;
					// vector<int> pusher;
					// pusher.push_back(temp.first);
					// pusher.push_back(temp.second);
					// ans.push_back(pusher);
					
					// or
					vector<int> temp;
					temp.push_back(holder[i].first.first);
					temp.push_back(holder[i++].first.second);
					ans.push_back(temp);
				}
				return ans;
			}
		};

		// Space efficient ❌Pending (priority Queue)
	
	531) Find the N-th character:
		Problem statement:
			Given a binary string s. Perform r iterations on string s, where in each iteration 0 becomes 01 and 1 becomes 10. Find the nth character (considering 0 based indexing) of the string after performing these r iterations (see examples for better understanding).

			Example 1:
				Input:
				s = "1100"
				r = 2
				n = 3
				Output:
				1
			Explanation: 
				After 1st iteration s becomes "10100101".
				After 2nd iteration s becomes "1001100101100110".
				Now, we can clearly see that the character at 3rd index is 1, and so the output.

			Example 2:
				Input:
				s = "1010"
				r = 1
				n = 2
				Output:
				0
			Explanation : 
				After 1st iteration s becomes "10011001".
				Now, we can clearly see that the character at 2nd index is 0, and so the output.
			Your task:
				You don't need to read input or print anything. 
				Your task is to complete the function nthCharacter() which takes the string s and integers r and n as input parameters and returns the n-th character of the string after performing r operations on s.
			
			Expected Time Complexity: O(r*|s|)
			Expected Auxilary Space: O(|s|)
			
			Constraints:
				1 ≤ |s| ≤ 10^3
				1 ≤ r ≤ 20
				0 ≤ n < |s|

		class Solution{
			public:
			char nthCharacter(string s, int r, int n) {
				while(r){
					string temp;
					for(int i=0; i<s.size(); i++){
						if(s[i] == '0'){
							temp.push_back('0');
							temp.push_back('1');
						}else{
							temp.push_back('1');
							temp.push_back('0');
						}
						if(temp.size() > n)
							break;
					}
					s = temp;
					r--;
				}
				return s[n];
			}
		};
	
	532) Distribute Elements Into Two Arrays I:
		Problem statement:
			You are given a 1-indexed array of distinct integers nums of length n.
			You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:
			If the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.
			The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].
			Return the array result.

			Example 1:
				Input: nums = [2,1,3]
				Output: [2,3,1]
				Explanation: After the first 2 operations, arr1 = [2] and arr2 = [1].
				In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.
				After 3 operations, arr1 = [2,3] and arr2 = [1].
				Hence, the array result formed by concatenation is [2,3,1].

			Example 2:
				Input: nums = [5,4,3,8]
				Output: [5,3,4,8]
				Explanation: After the first 2 operations, arr1 = [5] and arr2 = [4].
				In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].
				In the 4th operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].
				After 4 operations, arr1 = [5,3] and arr2 = [4,8].
				Hence, the array result formed by concatenation is [5,3,4,8].
			Constraints:
				3 <= n <= 50
				1 <= nums[i] <= 100
				All elements in nums are distinct.

		class Solution {
			public:
			vector<int> resultArray(vector<int>& nums) {
				ios_base::sync_with_stdio(false);
				cin.tie(nullptr);
				cout.tie(nullptr);

				vector<int> arr1, arr2;
				arr1.push_back(nums[0]);
				arr2.push_back(nums[1]);
				for(int i=2; i<nums.size(); i++){
					if(arr1[arr1.size()-1] > arr2[arr2.size()-1])
						arr1.push_back(nums[i]);
					else
						arr2.push_back(nums[i]);
				}
				vector<int> ans (arr1.begin(), arr1.end());
				ans.insert(ans.end(), arr2.begin(), arr2.end());
				return ans;
			}
		};
	
	533) Distribute Elements Into Two Arrays II: ❌Pending
		Problem statement:
			You are given a 1-indexed array of integers nums of length n.
			We define a function greaterCount such that greaterCount(arr, val) returns the number of elements in arr that are strictly greater than val.
			You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:

			If greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]), append nums[i] to arr1.
			If greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]), append nums[i] to arr2.
			If greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]), append nums[i] to the array with a lesser number of elements.
			If there is still a tie, append nums[i] to arr1.
			The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].
			Return the integer array result.	

			Example 1:
				Input: nums = [2,1,3,3]
				Output: [2,3,1,3]
				Explanation: After the first 2 operations, arr1 = [2] and arr2 = [1].
				In the 3rd operation, the number of elements greater than 3 is zero in both arrays. Also, the lengths are equal, hence, append nums[3] to arr1.
				In the 4th operation, the number of elements greater than 3 is zero in both arrays. As the length of arr2 is lesser, hence, append nums[4] to arr2.
				After 4 operations, arr1 = [2,3] and arr2 = [1,3].
				Hence, the array result formed by concatenation is [2,3,1,3].

			Example 2:
				Input: nums = [5,14,3,1,2]
				Output: [5,3,1,2,14]
				Explanation: After the first 2 operations, arr1 = [5] and arr2 = [14].
				In the 3rd operation, the number of elements greater than 3 is one in both arrays. Also, the lengths are equal, hence, append nums[3] to arr1.
				In the 4th operation, the number of elements greater than 1 is greater in arr1 than arr2 (2 > 1). Hence, append nums[4] to arr1.
				In the 5th operation, the number of elements greater than 2 is greater in arr1 than arr2 (2 > 1). Hence, append nums[5] to arr1.
				After 5 operations, arr1 = [5,3,1,2] and arr2 = [14].
				Hence, the array result formed by concatenation is [5,3,1,2,14].

			Example 3:
				Input: nums = [3,3,3,3]
				Output: [3,3,3,3]
				Explanation: At the end of 4 operations, arr1 = [3,3] and arr2 = [3,3].
				Hence, the array result formed by concatenation is [3,3,3,3].

			Constraints:
				3 <= n <= 10^5
				1 <= nums[i] <= 10^9

		// Memory Limit Exceeded:
			class Solution {
				private:
				int greaterCount(vector<int> a, int val){
					int cnt=0;
					for(int i=0; i<a.size(); i++)
						if(a[i] > val)
							cnt++;
					return cnt;
				}
				public:
				vector<int> resultArray(vector<int>& nums) {
					vector<int> arr1, arr2;
					arr1.push_back(nums[0]);
					arr2.push_back(nums[1]);

					for(int i=2; i<nums.size(); i++){
						if(greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]))
							arr1.push_back(nums[i]);
						else if(greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]))
							arr2.push_back(nums[i]);
						else{
							if(arr1.size() <= arr2.size())
								arr1.push_back(nums[i]);
							else
								arr2.push_back(nums[i]);
						}
					}

					vector<int> ans (arr1.begin(), arr1.end());
					ans.insert(ans.end(), arr2.begin(), arr2.end());
					return ans;
				}
			};
		
	534) Minimum Common Value:
		Problem statement:
			Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.
			Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.		

			Example 1:
				Input: nums1 = [1,2,3], nums2 = [2,4]
				Output: 2
				Explanation: The smallest element common to both arrays is 2, so we return 2.

			Example 2:
				Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
				Output: 2
				Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
			
			Constraints:
				1 <= nums1.length, nums2.length <= 10^5
				1 <= nums1[i], nums2[j] <= 109
				Both nums1 and nums2 are sorted in non-decreasing order.

		class Solution {
			public:
			int getCommon(vector<int>& nums1, vector<int>& nums2) {
				ios_base::sync_with_stdio(false);
				cin.tie(0);
				cout.tie(0);
				
				int i,j;
				i=j=0;

				while(i<nums1.size() && j <nums2.size()){
					if(nums1[i] == nums2[j])
						return nums1[i];
					else if(nums1[i] > nums2[j])
						j++;
					else
						i++;
				}
				return -1;
			}
		};
	
	535) Who will become the CR?: (C language)
		Problem statement
			Vishal and Pankaj are contesting for the class representative elections. Pankaj wants to prove that he is much more intelligent than Vishal. So, he challenges Vishal for a guessing game.
			In this game, Pankaj has three cups and a small ball. He puts three cups on a table, all upside down. Initially, the ball is kept in leftmost cup. He makes one of the following three swaps (for better comprehension, let us index leftmost cup as 1, middle cup as 2 and rightmost cup as 3):
			1. Swap Strategy A: He swaps cups with index 1 and 2
			2. Swap Strategy B: He swaps cups with index 2 and 3
			3. Swap Strategy C: He swaps cups with index 1 and 3
			Vishal needs your help. Can you predict the position of ball's cup, if you given all he swap movements made by Pankaj.

			Constraints:
				Time Limit: 1 second
				Output Format:
				The first and only line of output contains position of ball's cup, at the end. 
			Sample Input 1:
				CBABCACCC 
				Sample Output 1:
				1
		
		#include <stdio.h>
		int main(){
			char s[50];
			scanf("%s", s);

			int cups[3] = {1,2,3};
			int i=0;
			while(s[i] != '\0'){
				if(s[i] == 'A'){
					int temp = cups[0];
					cups[0] = cups[1];
					cups[1] = temp;
				}else if(s[i] == 'B'){
					int temp = cups[1];
					cups[1] = cups[2];
					cups[2] = temp;
				}else{
					int temp = cups[0];
					cups[0] = cups[2];
					cups[2] = temp;
				}
				i++;
			}

			for(int i=0; i<3; i++)
				if(cups[i] == 1){
					printf("%d", i+1);
					return 0;
				}
		}

	536) The First Salary:
		Problem statement
			Dac has received his first salary and has decided to buy a great thing - 2 dices.
			He performed the following action N times: roll his newly bought two dices A and B simultaneously. The result of the i-th roll is A[i] and B[i]. He now wonders if there was a scenario such that doublets occurred at least three times in a row. Specifically, He wants you to help him in checking if there exists at least one i such that A[i] = B[i] and A[i+1] = B[i + 1] and A[i + 2] = B[i + 2] hold.
			Sample Input 1
				5
				1 2
				6 6
				4 4
				3 3
				3 2
				Sample Output 1
				Yes
				
		#include<iostream>
		#include<bits/stdc++.h>
		using namespace std;
		int main(){
			int N;
			cin>>N;
			vector<pair<int, int>> diceser;

			for(int i=0; i<N; i++){
				int a,b;
				cin>>a>>b;
				diceser.push_back({a,b});
			}

			int cnt=0;
			for(int i=0; i<diceser.size(); i++){
				if(diceser[i].first == diceser[i].second)
					cnt++;
				else{
					cnt=0;
				}

				if(cnt == 3){
					cout<<"Yes";
					return 0;
				}
			}
			cout << "No"; // Output if the condition cnt == 3 is not met
			return 0;
		}
	
	537) Remove all duplicates from a given string:
		Problem statement:
			Given a string str which may contains lowercase and uppercase chracters. The task is to remove all duplicate characters from the string and find the resultant string. The order of remaining characters in the output should be same as in the original string.
			Example 1:
				Input:
				str = "geEksforGEeks"
				Output: 
				"geEksforG"
				Explanation: 
				After removing duplicate characters such as E, e, k, s, we have string as "geEksforG".

			Example 2:
				Input:
				str = "HaPpyNewYear"
				Output: 
				"HaPpyNewYr"
				Explanation: 
				After removing duplicate characters such as e, a, we have string as "HaPpyNewYr".

			Your Task:
				Complete the function removeDuplicates() which takes a string str, as input parameters and returns a string denoting the answer. You don't have to print answer or take inputs.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 ≤ N ≤ 10^5
				String contains uppercase and lowercase english letters.

		class Solution{
			public:
			string removeDuplicates(string str) {
				string ans;		
				for(char ch: str)
					if(ans.find(ch) == string::npos)
						ans.push_back(ch);
				
				return ans;
			}
		};

	538) Custom Sort String:
		Problem statement:
			You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.
			Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.
			Return any permutation of s that satisfies this property.

			Example 1:
			Input:  order = "cba", s = "abcd" 
			Output:  "cbad" 
			Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".
			Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.

			Example 2:
			Input:  order = "bcafg", s = "abcd" 
			Output:  "bcad" 
			Explanation: The characters "b", "c", and "a" from order dictate the order for the characters in s. The character "d" in s does not appear in order, so its position is flexible.
			Following the order of appearance in order, "b", "c", and "a" from s should be arranged as "b", "c", "a". "d" can be placed at any position since it's not in order. The output "bcad" correctly follows this rule. Other arrangements like "bacd" or "bcda" would also be valid, as long as "b", "c", "a" maintain their order.			

			Constraints:
				1 <= order.length <= 26
				1 <= s.length <= 200
				order and s consist of lowercase English letters.
				All the characters of order are unique.
		
		class Solution {
			public:
			string customSortString(string order, string s) {

				// 3 Optimization lines
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);

				for(int i=0; i<order.size(); i++){
					if(s.find(order[i]) == string::npos){
						order.erase(order.begin()+i);
						i--;
					}
				}

				for(int i=0; i<s.size(); i++){
					if(order.find(s[i]) == string::npos)
						order += s[i];
				}

				map<char, int> Fs, Fo;
				for(char ch: s)
					Fs[ch]++;

				for(char ch: order)
					Fo[ch]++;

				for(int i=0; i<order.size(); i++){

					checkAgain:
					if(Fo[order[i]] != Fs[order[i]]){
						string temp = string(1, order[i]);
						order.insert(i, temp);
						Fo[order[i]]++;
						goto checkAgain;
					}
				}

				return order;        
			}
		};

	539) Count pairs Sum in matrices:
		Problem statement:
			Given two sorted matrices mat1 and mat2 of size n x n of elements. Each matrix contains numbers arranged in strictly ascending order, with each row sorted from left to right, and the last element of a row being smaller than the first element of the next row. You're given a target value, x, your task is to find and count all pairs {a, b} such that a is from mat1 and b is from mat2 where sum of a and b is equal to x.

			Example 1:
			Input: 
			n = 3, x = 21
			mat1 = {{1, 5, 6},
				{8, 10, 11},
				{15, 16, 18}}
			mat2 = {{2, 4, 7},
				{9, 10, 12},
				{13, 16, 20}}
			OUTPUT: 4
			Explanation: The pairs whose sum is found to be 21 are (1, 20), (5, 16), (8, 13), (11, 10).

			Example 2:

			Input:
			n = 2, x = 10
			mat1 = {{1, 2},
				{3, 4}}
			mat2 = {{4, 5},
				{6, 7}}
			Output: 2
			Explanation: The pairs whose sum found to be 10 are (4, 6), (3, 7).

			User Task:
				Your task is to complete the function countPairs() which takes 4 arguments mat1, mat2, n, x, and returns the count of pairs whose sum equals to x. You don't need to take any input or print anything.

			Expected Time Complexity: O(n²).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ mat1[i][j] , mat2[i][j] ≤ 10^5
				1 ≤ n ≤ 100
				1 ≤ x ≤ 10^5

		// Not Optimized:
			class Solution{
				public:	
				int countPairs(vector<vector<int>> &mat1, vector<vector<int>> &mat2, int n, int x) {
					int counts=0;
					for(int i=0; i<mat1.size(); i++){
						for(int j=0; j<mat1.size(); j++){
							int r,c;
							r=c=0;
							
							while(r<n && c<n){
								if((mat1[i][j] + mat2[r][c]) == x)
									counts++;

								c++;
								if(c == n){
									c=0;
									r++;
								}
							}
						}
					}
					return counts;
				}
			};

		// Optimized:
			class Solution{
				public:	
				int countPairs(vector<vector<int>> &mat1, vector<vector<int>> &mat2, int n, int x) {
					int cnt=0;
					int sr,sc;
					sr=sc=0;
					
					int er,ec;
					er=ec=n-1;
					
					while(sr < n && er >=0){
						if((mat1[sr][sc]+mat2[er][ec]) == x){
							cnt++;
							sc++, ec--;
						}else if((mat1[sr][sc]+mat2[er][ec]) < x){
							sc++;
						}else{
							ec--;
						}
						
						if(sc == n){
							sc=0;
							sr++;
						}
						
						if(ec < 0){
							ec=n-1;
							er--;
						}
					}
					return cnt;
				}
			};

	#LeetCode WeeklyContest-388:
		540) Maximize Happiness of Selected Children:
			Problem statement:
				You are given an array happiness of length n, and a positive integer k.
				There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.
				In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.
				Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.			

				Example 1:
					Input: happiness = [1,2,3], k = 2
					Output: 4
					Explanation: We can pick 2 children in the following way:
					- Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].
					- Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.
					The sum of the happiness values of the selected children is 3 + 1 = 4.

				Example 2:
					Input: happiness = [1,1,1,1], k = 2
					Output: 1
					Explanation: We can pick 2 children in the following way:
					- Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].
					- Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].
					The sum of the happiness values of the selected children is 1 + 0 = 1.

				Example 3:
					Input: happiness = [2,3,4,5], k = 1
					Output: 5
					Explanation: We can pick 1 child in the following way:
					- Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].
					The sum of the happiness values of the selected children is 5.

				Constraints:
					1 <= n == happiness.length <= 2 * 105
					1 <= happiness[i] <= 108
					1 <= k <= n
			
			// Not Optimized:
				class Solution {
					public:
					long long maximumHappinessSum(vector<int>& happiness, int k) {
						long long ans=0;
						
						//first sort array in descending order
						sort(happiness.begin(), happiness.end(), greater<int>());
						
						int decrementor = 1;
						while(k-- && happiness.size() >0){
							if(happiness[0] > 0)
								ans += happiness[0];
							
							// delete first element of array
							happiness.erase(happiness.begin());
							for(int i=0; i<happiness.size(); i++)
								happiness[i]--;
							
							sort(happiness.begin(), happiness.end(), greater<int>());
						}
						return ans;
					}
				};
			
			// Little bit optimized:
				class Solution {
					public:
					long long maximumHappinessSum(vector<int>& happiness, int k) {
						long long ans=0;
						sort(happiness.begin(), happiness.end(), greater<int>());
						int val=1;
						while(k--){
							if(happiness[0] > 0)
								ans += happiness[0];
							happiness.erase(happiness.begin());
							happiness[0] -= val++;
						}
						return ans;
					}
				};
			
			// Optimized:
				class Solution {
					public:
					long long maximumHappinessSum(vector<int>& happiness, int k) {
						ios_base::sync_with_stdio(0);
						cin.tie(0);
						cout.tie(0);
						
						//first sort array in descending order
						sort(happiness.begin(), happiness.end(), greater<int>());
						long long ans=0;
						int decrementor = 0;
						
						for(int i=0; i<k; i++){
							if(decrementor < happiness[i])
								ans += (happiness[i]-decrementor);
							decrementor++;
						}
						return ans;
					}
				};

				//or
				class Solution {
					public:
					long long maximumHappinessSum(vector<int>& happiness, int k) {
						long long mxValue=0;
						sort(happiness.begin(), happiness.end(), greater<int>());

						int i=0, decValue=0;
						while(k--){
							if((happiness[i] - decValue) > 0)
								mxValue += happiness[i] - decValue;
							i++;
							decValue++;            
						}

						/* 
						  	instead of above while loop you can use below one
							int i=0;
							while(k--){
								mxValue += max(0, happiness[i] - i);
								i++;            
							}
						*/


						return mxValue;
					}
				};
				
		541) Apple Redistribution into Boxes:
			Problem statement:
				You are given an array apple of size n and an array capacity of size m.
				There are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples.
				Return the minimum number of boxes you need to select to redistribute these n packs of apples into boxes.
				Note that, apples from the same pack can be distributed into different boxes.

				Example 1:
					Input: apple = [1,3,2], capacity = [4,3,1,5,2]
					Output: 2
					Explanation: We will use boxes with capacities 4 and 5.
					It is possible to distribute the apples as the total capacity is greater than or equal to the total number of apples.

				Example 2:
					Input: apple = [5,5,5], capacity = [2,4,2,7]
					Output: 4
					Explanation: We will need to use all the boxes.
				
				Constraints:
					1 <= n == apple.length <= 50
					1 <= m == capacity.length <= 50
					1 <= apple[i], capacity[i] <= 50
					The input is generated such that it's possible to redistribute packs of apples into boxes.
			
			class Solution {
				public:
				int minimumBoxes(vector<int>& apple, vector<int>& capacity) {
					ios_base::sync_with_stdio(0);
					cin.tie(0);
					cin.tie(0);
					
					sort(capacity.begin(), capacity.end(), greater<int>());
					int totalNumOfApp = accumulate(apple.begin(), apple.end(), 0);
					
					int cnt=0, BoxNeedCnt=0;
					for(int i=0; i<capacity.size(); i++){
						cnt += capacity[i];
						BoxNeedCnt++;
						if(cnt >= totalNumOfApp)
								break;
					}
					return BoxNeedCnt;
				}
			};

	542) Find the Pivot Integer:
		Problem statement:
			Given a positive integer n, find the pivot integer x such that:
			The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
			Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.

			Example 1:
			Input: n = 8
			Output: 6
			Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.

			Example 2:
			Input: n = 1
			Output: 1
			Explanation: 1 is the pivot integer since: 1 = 1.

			Example 3:
			Input: n = 4
			Output: -1
			Explanation: It can be proved that no such integer exist.
			
			Constraints:
				1 <= n <= 1000

		// Brute Force:
			class Solution {
				public:
				int pivotInteger(int n) {
					int LSum,RSum;
					LSum=RSum=0;

					int i=1;
					while(i<=n){
						for(int a=1; a<=i; a++)
							LSum += a;
						
						for(int a=i; a<=n; a++)
							RSum += a;

						if(LSum == RSum)
							return i;
						LSum=RSum=0;
						i++;
					}
					return -1;
				}
			};
		
		// More optimized:
			class Solution {
				public:
				int pivotInteger(int n) {
					int LSum,RSum;
					LSum=RSum=0;

					int i=1;
					while(i<=n){
						LSum = (i*(i+1))/2;
						RSum = (n*(n+1)/2) - ((i-1)*(i)/2);
						if(LSum == RSum)
							return i;
						i++;
					}
					return -1;
				}
			};

			//or
			class Solution {
				public:
				int pivotInteger(int n) {
					int LSum,RSum;
					LSum=RSum=0;

					int i=1;
					while(i<=n){
						LSum = (i*(i+1))/2;
						
						// formula to find the sum of a to b = (n)*(firstTerm+lastTerm)/2;
						// where, n is no.of terms suppose 6 to 10 total elements are 5, formula will = 5*(6+10)/2;
						RSum = ((n-i+1) * (i+n)/2);
						if(LSum == RSum)
							return i;
						i++;
					}
					return -1;
				}
			};
	
	543) Number Pattern:
		Problem statement:
			Ninja is given a pattern. Now he is asked to print the same pattern for any given 'N' number of rows.
			For example Pattern for 'N' = 4 will be-
			1234
			123
			12
			1
			Sample Input1 :
			1 
			5
			Sample Output1 :
			12345
			1234
			123
			12
			1
			Explanation of Sample Input 1 :
			For test case 1:
			We print the given pattern for the given 5 rows where the first row prints from column number 1 to 5 and no of columns reduces by 1 for each consecutive row.
			Sample Input2 :
			1
			3
			Sample Output2 :
			123
			12
			1
			Explanation of Sample Input 2 :
			For test case 1:
			We print the given pattern for the given 3 rows where the first row prints from column number 1 to 3 and no of columns reduces by 1 for each consecutive row.

		#include <bits/stdc++.h> 
		vector<string> NumberPattern(int N) {
			vector<string> ans;

			for(int i=0; i<N; i++){
				int cnt=1;
				string s;
				for(int j=0; j<N-i; j++){
					string temp = to_string(cnt++);
					s += temp;
				}
				ans.push_back(s);
			}
			return ans;
		}

	544) Number Pattern:
		Problem statement
			Ninja wants to build a number pattern for the given integer.
			For example, If the given integer ‘N’ is 4
			Pattern:
				1
				23
				345
				4567
			Sample Input 1:
				2
				3
				5
				Sample Output 1:
				1
				23
				345
				1
				23
				345
				4567
				56789
				Explanation of Sample Input 1:
				Test case 1:

				In the first test case, as ‘N’ is equal to 3, We will have to print three lines. Each line starts with its row number and prints next (row number - 1) numbers.

				As in this example:
				The first row starts with “1” as the row number is one and print only “1” as “row number - 1“ is 0
				For the second row, it starts with two and prints one more number that is 3.Similarly, the third line starts with 3 and ends at 5.

				Test case 2:

				In the second test case, as “N” is equal to “5”, We will have to print five lines. Each line starts with its row number and prints next (row number - 1) numbers.

				As in this example:
				The first row starts with 1 as the row number is one and print only 1 as “row number - 1“ is 0
				The second row starts with two and prints one more number that is “3”.
				Similarly, the 5th row starts with “5” and ends at “9”.
				Sample Input 2:
				1
				1
				Sample Output 2:
				1
				Explanation of Sample Input 2:
				Test case 1:
				As ‘N’ is equal to ‘1’, we just need to print one line i.e 1. 

		#include <bits/stdc++.h> 
		vector<string> numberPattern(int n) {
			vector<string> ans;

			for(int i=0; i<n; i++){
				string s;
				int cnt = i+1;
				for(int j=0; j<=i; j++){
					string temp = to_string(cnt++);
					s += temp;
				}
				ans.push_back(s);
			}
			return ans;
		}

	545) Equal Candies:
		Problem statement:
			On Christmas Eve, all people at coding ninjas are given some candies but due to some error all people do not get the same number of candies.
			You are given an array of size ‘N’ that represents the number of candies given to ‘N’ people. You have to divide candies among all people such that each person receives the same number of candies. For this You can either increase or decrease the number of candies for any person by any amount. Your task is to minimise total increase/decrease for each person i.e. If you increase or decrease ‘Xi’ number of candies for the person ‘i’ ( 1 <= ‘i’ <= ‘N’), then the sum of all ‘Xi’ should be minimum.

			Sample Input 1:
				2
				5
				4 5 1 2 3
				4
				1 1 1 2
				Sample Output 1:
				6
				1
				Explanation of Sample Input 1:
				Test case 1:
				We can make the final number of candies equal to [3, 3, 3, 3, 3 ] with total changes equal to 6, which is the minimum possible.

				Test case 2:
				We can make the last element ‘2’ to ‘1’ by decreasing it one time. Hence the minimum changes is 1.
				Sample Input 2:
				1
				1
				10
				Sample Output 2:
				0
				Explanation of Sample Input 2:
				Test case 1:
				As there is only one element, we don't need to change anything.

		// Not Optimized:
			#include <bits/stdc++.h> 
			long long int equalCandies (vector<int> &candies, int n) {
				long long ans= INT_MAX;

				for(int i=0; i<n; i++){
					long long cnt=0;
					for(int j=0; j<n; j++){
						if(i==j || candies[i] == candies[j])
							continue;
						cnt += abs(candies[i]-candies[j]);
					}
					ans = min(ans, cnt);
				}
				return ans;
			}
		
		// Optimized:
			#include <bits/stdc++.h> 
			long long int equalCandies (vector<int> &candies, int n) {
				long long ans=0;

				sort(candies.begin(), candies.end());
				int value = candies[n/2];

				for(int i=0; i<n; i++)
					ans += abs(value-candies[i]);

				return ans;
			}

	546) Stock Span:
		Problem statement
			Afzal has been working with an organization called 'Money Traders for the past few years. The organization is in the money trading business. His manager assigned him a task.
			Given an array ’prices’ which denotes stock prices for ’n’ days, e.g., 'prices[ i ]' = price of the stock at ‘ith’ day, Find the stock's span for each day.
			The span of the stock's price today is defined as the maximum number of consecutive days(starting from today and going backward) for which the price of the stock was less than today's price.

			Example:
				Input: ‘n’ = 7,  ‘prices’ = [100, 80, 60, 70, 60, 75, 85]
				Output: [1, 1, 1, 2, 1, 4, 6]

			Explanation:
			On the sixth day, when the stock price was 75, 
			The span came out to be 4 because the last three prices(plus today) were less than the current or the sixth day's price.
			Similarly, we can deduce the remaining results.
			Note:
			You don’t need to print anything. Just implement the given function
			Sample Input 1:
			4
			2 1 2 4
			Sample Output 1:
			1 1 2 4
			Explanation Of Sample Input 1:
			Number of consecutive days with price smaller than 0th day(starting from 0th day) = 1
			Number of consecutive days with price smaller than 1st day(starting from 1st day) = 1
			Number of consecutive days with price smaller than 2nd day(starting from 2nd day) = 2
			Number of consecutive days with price smaller than 3rd day(starting from 3rd day) = 4 
			Sample Input 2:
			6
			20 12 1 28 16 20 
			Sample Output 2:
			1 1 1 4 1 2 
			Explanation Of Sample Input 2:
			Number of consecutive days with price smaller than 0th day(starting from 0th day) = 1
			Number of consecutive days with price smaller than 1st day(starting from 1st day) = 1
			Number of consecutive days with price smaller than 2nd day(starting from 2nd day) = 1
			Number of consecutive days with price smaller than 3rd day(starting from 3rd day) = 4 
			Number of consecutive days with price smaller than 3rd day(starting from 4th day) = 1
			Number of consecutive days with price smaller than 3rd day(starting from 5th day) = 2 
			Expected time complexity:
			The expected time complexity is O(n).
			Constraints :
				1 <= n <= 10^6
				1 <= prices[i] <= 10^9
				Time Limit: 1 sec

		// Not Optimized:
			vector<int> findStockSpans(vector<int>& prices) {
				vector<int> ans;

				for(int i=0; i<prices.size(); i++){
					int cnt=1;
					for(int j=i-1; j>=0; j--){
						if(prices[j] >= prices[i])
							break;
						cnt++;
					}
					ans.push_back(cnt);
				}
				return ans;
			}

		// Optimized: ❌Pending
	
	547) Next Greater Element II: (Q.30)
		Problem statement
			You are given a circular array 'a' of length 'n'.
			A circular array is an array in which we consider the first element is next of the last element. That is, the next element of 'a[n - 1]' is 'a[0]'.
			Find the Next Greater Element(NGE) for every element.
			The Next Greater Element for an element 'x' is the first element on the right side of 'x' in the array, which is greater than 'x'.
			If no greater elements exist to the right of 'x', consider the next greater element as -1.

			Example:
			Input: 'a' = [1, 5, 3, 4, 2]
			Output: NGE = [5, -1, 4, 5, 5]
			Explanation: For the given array,
			- The next greater element for 1 is 5.
			- There is no greater element for 5 on the right side. So we consider NGE as -1.
			- The next greater element for 3 is 4.
			- The next greater element for 4 is 5, when we consider the next elements as 4 -> 2 -> 1 -> 5.
			- The next greater element for 2 is 5, when we consider the next elements as 2 -> 1 -> 5.
			Sample Input 1 :
				5
				1 5 3 4 2

			Sample Output 1 :
				5 -1 4 5 5

			Explanation Of Sample Input 1 :
			For the given array,
			- The next greater element for 1 is 5.
			- There is no greater element for 5 on the right side. So we consider NGE as -1.
			- The next greater element for 3 is 4.
			- The next greater element for 4 is 5, when we consider the next elements as 4 -> 2 -> 1 -> 5.
			- The next greater element for 2 is 5, when we consider the next elements as 2 -> 1 -> 5.

			Sample Input 2:
				5
				5 5 5 5 5

			Sample Output 2:
				-1 -1 -1 -1 -1

			Expected time complexity :
			The expected time complexity is O(n).

			Constraints :
				1 <= 'n' <= 10^5
				1 <= 'a[i]' <= 10^9
				Time Limit: 1 sec

		// Not Optimized:
			vector<int> nextGreaterElementII(vector<int>& a) {
				vector<int> ans(a.size(),-1);
				for(int i=0; i<a.size(); i++){
					int flag = 1;
					for(int j=i+1; j<a.size(); j++){
						if(a[i] < a[j]){
							flag = 0;
							ans[i] = a[j];
							break;
						}
					}

					if(flag){
						for(int j=0; j<i; j++)
							if(a[i] < a[j]){
								ans[i] = a[j];
								break;
							}
					}
				}
				return ans;
			}
		
		// Optimized:
			#include <bits/stdc++.h> 
			vector<int> nextGreater(vector<int> &arr, int n) {
				vector<int> ans (n, -1);
				stack<int> st;

				for(int i=n-1; i>=0; i--){
					while(!st.empty() && st.top() <= arr[i])
						st.pop();

					if(!st.empty())
						ans[i] = st.top();
					st.push(arr[i]);
				}
				return ans;
			}

			// or
				#include<stack>
				vector<int> nextGreaterElement(vector<int>& arr, int n) {
					vector<int> ans (n, -1);
					stack<int> st;

					for(int i=n-1; i>=0; i--){
						while(!st.empty()){
							if(arr[i]>=st.top())
								st.pop();
							else{
								ans[i] = st.top();
								break;
							}
						}
						st.push(arr[i]);
					}
					return ans;
				}

	548) Maximum Even Two Sum
		Problem statement
			You are given a sorted array ‘A’ of ‘N’ integers. Find the maximum number in the array that satisfies the following conditions -
			-The number is even.
			-The number can be represented as a sum of two even numbers 'A[i]' and 'A[j]' (0 <= i, j < N) in the array.
			If there is no such number then return -1.
			Example :
				Input: A = [2, 4, 6, 8, 10, 20]
				Output: 20
				The maximum even number in the array is 20. And it can be represented as a sum of two even numbers in the array (10 + 10). So, the output is 20.
			Constraints:
				1 ≤ T ≤ 10
				1 ≤ N ≤ 10^3
				0 ≤ A[i] ≤ 10^9
				It is guaranteed that the sum of 'N' is ≤ 10^5 over all test cases.
				Time limit: 1 sec

			Sample Input 1:
				2
				6
				1 2 2 4 5 10
				5
				1 3 5 7 9
				Sample Output 1 :
				4
				-1
				Explanation For Sample Input 1:
				For test case 1:
				The maximum even number in the array is 10 but it cannot be represented as a sum of two even numbers in the array. The next largest even number is 4 and it can be represented as a sum of two even numbers in the array (2 + 2). So, the output is 4.

				For test case 2:
				The array does not contain any even numbers, so the output is -1.
				Sample Input 2:
				2
				5
				4 6 8 12 14
				3
				2 4 6
				Sample Output 2 :
				14
				6

		int maxEvenSum(int n, vector<int> a) {
			for(int i=n-1; i>=0; i--){
				if(a[i] % 2 == 0 && a[i] != 0){
					for(int j=i; j>=0; j--){
						if(a[j] % 2 == 0){
							for(int z=j; z>=0; z--){
							if(a[z] % 2 == 0){
								if((a[z]+a[j]) == a[i])
									return a[i];
								}
							}
						}
					}
				}
			}
			return -1;
		}
	
	549) Binary Subarrays With Sum:
		Problem statement:
			Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.
			A subarray is a contiguous part of the array.

			Example 1:
			Input: nums = [1,0,1,0,1], goal = 2
			Output: 4
			Explanation: The 4 subarrays are bolded and underlined below:
			[1,0,1,0,1]
			[1,0,1,0,1]
			[1,0,1,0,1]
			[1,0,1,0,1]

			Example 2:
			Input: nums = [0,0,0,0,0], goal = 0
			Output: 15

			Constraints:
				1 <= nums.length <= 3 * 10^4
				nums[i] is either 0 or 1.
				0 <= goal <= nums.length

		// Not Optimized:
			class Solution {
				public:
				int numSubarraysWithSum(vector<int>& nums, int goal) {
					int cnt=0;
					for(int i=0; i<nums.size(); i++){
						int sum=0;

						for(int j=i; j<nums.size(); j++){
							sum += nums[j];
							if(sum == goal){
								cnt++;
							}else if(sum > goal)
								break;
						}
					}
					return cnt;   
				}
			};

		// Optimized:
			❌Pending
	
	550) Non-Decreasing Array:
		Problem statement:
			You have been given an integer array/list 'ARR' of size 'N'. Write a solution to check if it could become non-decreasing by modifying at most 1 element.
			We define an array as non-decreasing, if ARR[i] <= ARR[i + 1] holds for every i (0-based) such that (0 <= i <= N - 2).
			Constraints :
				1 <= T <= 50
				1 <= N <= 10 ^ 4
				- 10 ^ 9 <= ARR[i] <= 10 ^ 9
			Where 'N' is the size of the given array/list.
			And, ARR[i] denotes the i-th element in the array/list 'ARR'.
			Time Limit: 1sec

			Sample Input 1 :
				2
				3
				8 4 6
				3
				8 4 2
				Sample Output 1 :
				true
				false
				Explanation to Sample Input 1 :
				For Test Case 1 we can have a possible non-decreasing array : 2 4 6
				Where only the element at index 0 has been modified.

				For Test Case 2 there is no possible way to make the array non-decreasing by modifying at most 1 element.
				Sample Input 2 :
				2
				6
				-2 7 -1 0 1 2
				5
				-10 10 0 10 3
				Sample Output 2 :
				true
				false
				Explanation to Sample Input 2 :
				For Test Case 1 we can have a possible non-decreasing array : -2 -2 -1 0 1 2
				Where only the element at index 1 has been modified
				For Test Case 2 there is no possible way to make the array non-decreasing by modifying at most 1 element.
		
		#include <bits/stdc++.h> 
		bool isPossible(int *arr, int n) {
			int cnt=0;
			for(int i=1; i<n; i++){
				if(arr[i-1] > arr[i]){
					int val = arr[i];
					arr[i] = arr[i-1];

					if(is_sorted(arr, arr+n)){
						return 1;
					}
					else{
						arr[i] = val;
						arr[i-1] = arr[i];
						if(is_sorted(arr, arr+n))
							return 1;
						else
							return 0;
					}
				}
			}
			return 1;
		}
		
		// or
			#include <bits/stdc++.h>
			bool isPossible(int *arr, int n) {
				int cnt = 0;
				for (int i = 0; i < (n - 1); i++) {
					if (arr[i] > arr[i + 1]) {
						cnt++;
						if (cnt > 1) return 0;

						if(i > 0  && arr[i-1] > arr[i+1])
							arr[i+1] = arr[i];
						else
							arr[i] = arr[i+1];
					}
				}
				return 1;
			}

	551) Hotel Floors:
		Problem statement
			You are the receptionist at a hotel which has 10 floors, numbered from 0 to 9 and each floor has 26 rooms named from ‘A’ to ‘Z’. Being a receptionist your task is to handle booking queries.
			You get booking queries in the form of strings of size 3 where 1st character is ‘+’ means room is booked, or ‘-’ means room is freed. Second character represents the floor of the room i.e, ‘0’ to ‘9’. Third character represents the room name i.e, ‘A’ to ‘Z’.
			On booking of each room you collect 1 coin from the customer. After the end of all the booking queries you have to count the number of coins you collected.
			You may assume that the list describes a correct sequence of bookings in chronological order i.e., only free rooms can be booked, and only booked rooms can be freed.

			For Example:-
				Consider booking queries to be ["+1A", "+3E", "-1A", "+4F", "+1A", "-3E"]
				+1A: Room A on the 1st floor is booked and you collected 1 coin.
				+3E: Room E on the 3rd floor is booked and you collected 1 coin.
				-1A: Room A on the 1st floor is freed.
				+4F: Room F on the 4th floor is booked and you collected 1 coin.
				+1A: Room A on the 1st floor is booked and you collected 1 coin.
				-3E: Room E on the 3rd floor is freed.
				So you collected 4 coins.
			
			Constraints:
				1 <= T <= 10^2
				0 <= N <= 6*10^2
				|query.length| = 3
				Time Limit: 1 sec

			Sample Input 1:
				2
				6
				+1A +3E -1A +4F +1A -3E
				3
				+0A +0B +0C
				Sample Output 1:
				4
				3
				Explanation For Sample Input 1:
				Test Case 1: Please refer to the example above.

				Test Case 2: Room 0A, 0B & 0C is booked so we collected 3 coins.
				Sample Input 2:
				2
				4
				+8D -8D +8D -8D
				7
				+3C +2B +7K -2B +6C -3C +5S
				Sample Output 2:
				2
				5

		#include <bits/stdc++.h> 
		int hotelBookings(vector<string> queries) {
			int cnt=0;
			for(int i=0; i<queries.size(); i++){
				// need to check the first letter odf every string, if + then increment cnt by 1 else go forward.
				if(queries[i][0] == '+')
					cnt++;
			}
			return cnt;
		}

	552) Split the Array:
		Problem statement:
			You are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that:
				nums1.length == nums2.length == nums.length / 2.
				nums1 should contain distinct elements.
				nums2 should also contain distinct elements.
				Return true if it is possible to split the array, and false otherwise.

			Example 1:
			Input: nums = [1,1,2,2,3,4]
			Output: true
			Explanation: One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].

			Example 2:
			Input: nums = [1,1,1,1]
			Output: false
			Explanation: The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.
		
			Constraints:
				1 <= nums.length <= 100
				nums.length % 2 == 0 
				1 <= nums[i] <= 100

		class Solution {
			public:
			bool isPossibleToSplit(vector<int>& nums) {
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);

				map<int, int> F;
				for(int i: nums){
					F[i]++;
					if(F[i] > 2)
						return 0;
				}
				return 1;
			}
		};

		//or keeping constraints in mind:
			class Solution {
				public:
				bool isPossibleToSplit(vector<int>& nums) {
					int arr[100] = {0};
					for(int n: nums)
						if(++arr[n-1] > 2) return 0;
					return 1;
				}
			};
	
	553) Overspeeding
		Problem statement:
			Alice is going for a drive. During her drive, she reached a maximum speed of S km/hr.
			As per the rules of the government, the speed of the vehicle must not exceed 40 km/hr, otherwise the person will be fined.
			You need to tell whether Alice will be fined or not.
			Input Format
				The only line of input will contain a single integer S - denoting the maximum speed Alice reached while driving.
			Output Format
				Print YES if Alice will be fined , otherwise print NO.

			You may print each character of the string in uppercase or lowercase (for example, the strings YES, yEs, yes, and yeS will all be treated as identical).

			Constraints
				1 ≤ S ≤ 50
			Sample 1:
				Input
				40
				Output
				NO
				Explanation:
				Since Alice's speed does not exceed 
				40
				40, she will not be fined.

				Sample 2:
				Input
				41
				Output
				YES
				Explanation:
				Since Alice's speed exceeds 40, she will be fined.
		
		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int n;
			cin>>n;
			if(n>40)
				cout<<"YES";
			else
				cout<<"NO";
			return 0;
		}

	554) 50-50 Rule:
		Problem statement:
			Schools of Chefland use the 50−50 rule to grade their students. As per the rule, students are awarded :
			Z grade, if their attendance is strictly less than 50%.
			F grade, if they score strictly less than 50% marks, given that their attendance is greater than or equal to 50% .
			A grade, otherwise. 
			You are given two integers, X and Y, denoting the percentage of attendance and percentage of marks obtained by Alice. What grade will Alice get?

			Input Format
				The first line of input will contain a single integer T, denoting the number of test cases.
				Each test case consists of two space-separated integers 
				X and Y — the percentage of attendance and percentage of marks obtained by Alice.
			Output Format
				For each test case, output on a new line, the grade awarded to Alice.
				Note that you may print the grade in lowercase or uppercase.

			Constraints
				1≤T≤10^4
				1 ≤ X ,Y ≤ 100
			Sample 1:
			Input
			4
			49 100
			49 49
			50 49
			50 50
			Output
			Z
			Z
			F
			A
			Explanation:
			Test case 
				1: Alice's attendance is less than 50%
				50% so she will be awarded Z grade.
				Test case 3
				3: Alice's attendance is equal to 50 and her marks are less than 50%, so she will be awarded F grade.
				Test case 4: Alice's attendance is equal to 50% and her marks are also equal to 50%, so she will be awarded A grade.

		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int T;
			cin>>T;
			
			while(T--){
				int PA, PM;
				cin>>PA>>PM;
				
				if(PA>=50 && PM >=50)
					cout<<"A\n";
				else if(PA<50)
					cout<<"Z\n";
				else
					cout<<"F\n";
			}
			return 0;
		}

	#CodingNinja WeeklyContest-117
		555) Minimise Z:
			Problem statement
				Given an array ‘A’. Your task is to choose any two different elements of the array say ‘X’ and ‘Y’, such that ‘Z’ is minimum possible. Where ‘Z’ = ‘X’ × ’Y’.
				Return the minimum possible value of ‘Z’.

				Example:
					‘N’ = [5, 3, 9, 6, 3]
					‘X’ can be chosen as 3(index 1) and ‘Y’ can be chosen as 3(index 4). 'Z' = 3*3 = 9.
					No other combination can have a smaller value of ‘Z’.
				Constraints:
					1 <= ‘T’ <= 10
					2 <= ‘N’ <= 10^5
					-10^4 <= ‘A[i]’ <= 10^4
					Time Limit: 1 sec

				Sample Input 1:
					2
					6
					-6 10 -1 2 10 -1 
					7
					-7 5 -1 -4 -10 -8 10 
					Sample Output 1:
					-60
					-100
					Explanation of sample input 1:
					For 1st Testcase :
					‘X’ can be chosen as -6(index 0)  and ‘Y’ can be chosen as 10(index 1). 'Z' = -6*10 = -60.
					No other combination can have a smaller value of ‘Z’.

					For 2nd Testcase :
					‘X’ can be chosen as -10(index 4) and ‘Y’ can be chosen as 10(index 6). 'Z' = -10*10 = -100.
					No other combination can have a smaller value of ‘Z’.
					Sample Input 2:
					3
					6
					-5 -10 5 7 -8 -8 
					6
					-10 6 1 -6 7 5 
					8
					0 0 3 -8 -10 -7 4 -5 
					Sample Output 2:
					-70
					-70
					-40

			int minimiseZ(vector<int> &a){
				sort(a.begin(), a.end());

				if(a[0] < 0 && a[a.size()-1] < 0)
					return a[a.size()-2]*a[a.size()-1];
				else if(a[0]<0)
					return a[0]*a[a.size()-1];
				
				return a[0]*a[1];
			}
		
		556) Min Cost Flip:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’. You are also given another binary array ‘B’ of length ‘N’ containing only ‘0s’ and ‘1s’.
				You can do the following operation at most once:
				Choose any index ‘i’ and replace the value of ‘B[i]’ to ‘(1 - B[i])’.
				The cost of this operation will be equal to ‘A[i]’.
				The beauty of an array is equal to the maximum consecutive length of ‘0s’ in the array ‘B’. You have to maximise the beauty of the array by minimising the cost.
				If there are multiple ways to maximise the beauty of the array, you have to find a way which involves the minimum cost operation.
				Your task is to tell the minimum cost to maximise the beauty of an array ‘B’ and return it.

				Example:
				‘N’ = 4
				‘A’ = [2, 1, 10, 5]
				‘B’ = [0, 1, 1, 0]

				If you replace the ‘1st’ element to ‘0’, you’ll get ‘B’ as: [0, 0, 1, 0]. Here, the beauty of an array ‘B’ is ‘2’ and the cost of this operation is ‘1’.

				If you replace the ‘2nd; element to ‘0’, you’ll get ‘B’ as: [0, 1, 0, 0]. Here, the beauty of an array ‘B’ is ‘2’ and the cost of this operation is ‘10’.
				As you can see, both of the above operations are giving beauty ‘2’ but the minimum cost is given by the ‘1st’ operation. So, the answer for this test case is ‘1.
				Constraints:
					1 <= ‘T’ <= 10
					1 <= ‘N’ <= 10^5
					0 <= ‘A[i]’ <= 10^9
					‘B[i]’ belongs to the set {‘0’, ‘1’}
					Time limit: 1 sec
					
				Sample Input 1:
					2
					3
					5 10 1
					0 1 0
					5
					1 1 2 1 1
					0 1 0 1 0 
					Sample Output 1:
					10
					1
					Explanation of sample input 1:
					For test case 1:    
					If you replace the ‘1st’ element of the array ‘B’, you’ll get ‘B’ as: [0, 0, 0]. 
					This is the maximum beauty you can achieve and the cost of this operation is ‘10’. 
					There is no other way to achieve the above beauty value. Hence, the answer for this test case is ‘10’.

					For test case 2:
					There are two ways to achieve the maximum beauty value by either flipping the ‘1st’ value or ‘3rd’ value.
					Both of these operations are taking cost ‘1’. Hence, the answer for this test case is ‘1’.
					Sample Input 2:
					2
					4
					1 10 11 2 
					0 0 0 0
					2
					11 6
					1 1
					Sample Output 2:
					0
					6
		
			// Not Optimized:
				int Lcount(vector<int> sample, int s, int e){
					int cnt=0;
					for (int z = s; z >= e; z--) {
						if(sample[z] == 0)
						cnt++;
						else
						break;
					}
					return cnt;
				}

				int Rcount(vector<int> sample, int s, int e) {
					int cnt=0;

					for(int i=s; i<=e; i++){
						if(sample[i] == 0)
						cnt++;
						else
						break;
					}
					return cnt;
				}

				int minCostFlip (int n, vector <int> &a, vector <int> &b) {
					int minCost=0, total=0;

					for(int i=0; i<n; i++){
						if(b[i] == 1){
						int Lside = Lcount(b, i-1, 0);
						int Rside = Rcount(b, i+1, n-1);

						if(total <= Lside+Rside+1){
							if(total < Lside+Rside+1){
								total = Lside+Rside+1;
								minCost = a[i];
							}else{
								if(minCost !=0 )
								minCost = min(minCost, a[i]);
								else
								minCost = a[i];
							}
						}
						}
					}
					return minCost;
				}

			// Optimized:
				❌Pending
		
		557) Min Sum Beautiful Subarray:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’. You are also given an integer ‘K’. A subarray is considered to be a beautiful subarray if the length of the subarray is '1', else if absolute difference between any two elements in the subarray is even.
				Let’s say we have a subarray from ‘i’ to ‘j’, where ‘i’ <= ‘j’. For any two integers ‘p’, ‘q’ where ‘i’ <= ‘p’, ‘q’ <= ‘j’, ‘|A[p] - A[q]|’ should be even. You have to find the minimum sum of a beautiful subarray having length less than or equal to ‘K’.
				You have to tell the minimum sum of a beautiful subarray having length less than or equal to ‘K’.
				Example:
				‘N’ = 4
				‘K’ = 2
				‘A’ = [-2, -6, 0,  4]

				Here, the beautiful subarrays with length less than or equal to ‘2’ are:
				[-2], [-2, -6], [-6], [-6, 0], [0], [0, 4], [4].

				The subarray having minimum sum is: [-2, -6].
				So, the answer for this example is ‘-8’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					1 <= 'K' <= 'N'
					-10^9 <= A[i] <= 10^9

					Time Limit: 1 sec 
				Sample Input 1:
					2
					4 3
					0 1 -4 2
					3 1
					1 2 0
					Sample Output 1:
					-4
					0
					Explanation of sample input 1:
					For test case 1:
					Here, the beautiful subarrays with length less than or equal to ‘3’ are: [0], [1], [-4], [-4, 2], [2].
					The minimum sum among these subarrays is given by a subarray ‘[-4]’. So, the answer for this test case is -’4’.

					For test case 2:
					Here, the beautiful subarrays with length less than or equal to ‘1’ are: [1], [2]. [0].
					The minimum sum is given by a subarray ‘[0]’. So, the answer for this test case is ‘0’.

					Sample Input 2:
					2
					5 4
					-10 0 4 -10 2
					3 2
					1 1 1
					Sample Output 2:
					-16
					1

			// Not Optimized:
				#include<bits/stdc++.h>
				long long minSumBeautifulSubarray (int n, int k, vector <int> &a) {
					long long ans = *min_element(a.begin(), a.end());

					vector<vector<int>> holder;

					for(int i=0; i<n; i++){
						vector<int> temp;
						temp.push_back(a[i]);
						for(int j=i+1; j<n; j++){
							if(abs(a[j-1] - a[j])% 2 == 0 && temp.size() < k){
								temp.push_back(a[j]);
								holder.push_back(temp);
							}else{
								break;
							}
						}
					}

					for(auto& outer: holder){
						long long crntSum=0;
						for(int inner: outer)
								crntSum += inner;            

						ans = min(ans, crntSum);
					}

					return ans;
				}

			// Optimized:
				❌Pending
	
	558) Product of Array Except Self:
		Problem statement:
			Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
			The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
			You must write an algorithm that runs in O(n) time and without using the division operation.		

			Example 1:
			Input: nums = [1,2,3,4]
			Output: [24,12,8,6]

			Example 2:
			Input: nums = [-1,1,0,-3,3]
			Output: [0,0,9,0,0]
			
			Constraints:
				2 <= nums.length <= 10^5
				-30 <= nums[i] <= 30
				The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
	
			Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)

		// Not Optimized:
			class Solution {
				public:
				vector<int> productExceptSelf(vector<int>& nums) {
					vector<int> res;
					for(int i=0; i<nums.size(); i++){
						int prod = 1;
						for(int j=0; j<nums.size(); j++){
							if(i==j)
								continue;
							prod *= nums[j];
						}
						res.push_back(prod);
					}
					return res;
				}
			};

		// Optimized:
			class Solution {
				public:
				vector<int> productExceptSelf(vector<int>& nums) {
					int n = nums.size();
					vector<int> prefix, suffix;
					
					int prod=1;
					for(int i=0; i<n; i++){
						prefix.push_back(prod);
						prod *= nums[i];
					}

					prod=1;
					for(int i=n-1; i>=0; i--){
						suffix.push_back(prod);
						prod *= nums[i];
					}
					reverse(suffix.begin(), suffix.end());

					vector<int> res;
					for(int i=0; i<n; i++)
						res.push_back(prefix[i]*suffix[i]);
					return res;
				}
			};

			// using single vector
				class Solution {
					public:
					vector<int> productExceptSelf(vector<int>& nums) {
						vector<int> holder;
						int n = nums.size();

						// first storing the prefix prod
						int prod=1;
						for(int i=0; i<n; i++){
							holder.push_back(prod);
							prod *= nums[i];
						}

						// secondly storing suffix prod
						prod=1;
						for(int i=n-1; i>=0; i--){
							holder[i] *= prod;
							prod *= nums[i];
						}
						return holder;
					}
				};
	
	559) Find Integer:
		Problem statement
			You are given two integers, ‘N’ and ‘K’. Assume numbers from 1 to ‘N’ are arranged such that all odd numbers (in ascending order) are present first and then come to all even numbers (also in ascending order).
			You need to find the integer at position ‘K’ (numbering of positions starts from 1).
			For example:
			You are given ‘N’ as 7 and ‘K’ as 4.  Numbers from 1 to 7 are arranged as [1, 3, 5, 7, 2, 4, 6], and the number at position 4 is 7. So, the answer is 7.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^12
				1 <= K <= N
				Time Limit: 1 sec

			Sample Input 1:
				2
				7 4
				5 3
				Sample Output 1:
				7
				5
				Explanation:
				For the first test case, the numbers from 1 to 7 are arranged as [1, 3, 5, 7, 2, 4, 6], and the number at position 4 is 7. Hence the answer is 7.
				For the second test case, the numbers from 1 to 5 are arranged as [1, 3, 5, 2, 4], and the number at position 3 is 5. Hence the answer is 5.
				Sample Input 2:
				2
				6 2
				7 3
				Sample Output 2:
				3
				5

		// Not Optimized
			#include <bits/stdc++.h> 
			int findInteger(int n, int k) {
				vector<int> holder, odds, evens;
				for(int i=1; i<=n; i++){
					if(i&1)
						odds.push_back(i);
					else
						evens.push_back(i);
				}
				
				holder.insert(holder.end(), odds.begin(), odds.end());
				holder.insert(holder.end(), evens.begin(), evens.end());
				
				// or
				// holder.assign(odds.begin(), odds.end());
				// holder.insert(holder.end(), evens.begin(), evens.end());
				return holder[k-1];
			}
		
		// Optimized:
			#include <bits/stdc++.h> 
			int findInteger(int n, int k) {
				int numOfOdds = (n+1)/2;
				if(k <= numOfOdds)
					return 2 * (k-1) + 1;
				return 2*(k-numOfOdds);
			}
	
	560) Set the rightmost unset bit:
		Problem statement:
			Given a non-negative number N. The problem is to set the rightmost unset bit in the binary representation of N. If there are no unset bits, then just leave the number as it is.

			Example 1:
			Input:
			N = 6
			Output:
			7
			Explanation:
			The binary representation of 6 is 110.
			After setting right most bit it becomes
			111 which is 7.
			Example 2:

			Input:
			N = 15
			Output:
			15
			Explanation:
			The binary representation of 15 is 1111.
			As there is no unset bit it remains the
			same.
			
			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function setBit() which takes an integer N as input parameter and returns the integer after setting a rightmost unset bit.

			Expected Time Complexity: O(LogN)
			Expected Auxiliary Space: O(1)

			Constraints:
			1 <= N <= 10^9

		class Solution {
			public:
			int setBit(int N) {
				string s = bitset<32>(N).to_string();
				int i=31;
				
				// cout<<s<<endl;
				while(i>=0)
					if(s[i] == '0'){
						s[i] = '1';
						break;
					}else{
						i--;
					}
				
				// cout<<s<<endl;
				return stoi(s, 0, 2);
			}
		};
	
	561) Set kth bit:
		Problem statement:
			Given a number N and a value K. From the right, set the Kth bit in the binary representation of N. The position of Least Significant Bit(or last bit) is 0, the second last bit is 1 and so on. 
			Example 1:
			Input:
			N = 10 
			K = 2
			Output:
			14
			Explanation:
			Binary representation of the given number
			10 is: 1 0 1 0, number of bits in the 
			binary reprsentation is 4. Thus 2nd bit
			from right is 0. The number after changing
			this bit to 1 is: 14(1 1 1 0).
			Example 2:

			Input:
			N = 15 
			K = 3
			Output:
			15
			Explanation:
			The binary representation of the given
			number 15 is: 1 1 1 1, number of bits
			in the binary representation is 4. Thus
			3rd bit from the right is 1. The number
			after changing this bit to 1 is
			15(1 1 1 1).

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function setKthBit() which takes two integer N and K as input parameter and returns an integer after setting the K'th bit in N.

			Expected Time Complexity: O(1)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^9
				0 <= K < X, where X is the number of bits in the binary representation of N.

		class Solution {
			public:
			int setKthBit(int N, int K) {
				string s = bitset<32>(N).to_string();
				
				// cout<<s<<endl;
				s[31-K] = '1';
				// cout<<s<<endl;
				return stoi(s, 0, 2);
			}	
		};

	562) Contiguous Array:
		Problem statement:
			Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.

			Example 1:
			Input: nums = [0,1]
			Output: 2
			Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
			
			Example 2:
			Input: nums = [0,1,0]
			Output: 2
			Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
			
			Constraints:
				1 <= nums.length <= 10^5
				nums[i] is either 0 or 1.

		// Not Optimized:
			class Solution {
				bool counts(vector<int> arr, int s, int e){
					int ones, zeros;
					ones=zeros=0;

					for(int i=s; i<=e; i++)
						if(arr[i] == 1)
							ones++;
						else
							zeros++;
						
					if(ones == zeros)
						return 1;
					return 0;
				}
				public:
				int findMaxLength(vector<int>& nums) {
					int mxLen = 0;
					
					// Generating subarray
					for(int i=0; i<nums.size(); i++){
						for(int j=i+1; j<nums.size(); j++){
							// count the no.of ones & zeros between i & j as start and end.
							if(counts(nums, i, j))
								mxLen = max(mxLen, j-i+1);
						}
					}
					return mxLen;
				}
			};
	
		// Not Optimized (little optimized):
			class Solution {
				public:
				int findMaxLength(vector<int>& nums) {
					int mxLen = 0;
					int ones, zeros;

					// Generating subarray
					for(int i=0; i<nums.size(); i++){
						ones=zeros=0;
						if(nums[i] == 1)
							ones++;
						else
							zeros++;
						

						for(int j=i+1; j<nums.size(); j++){
							// count the no.of ones & zeros between i & j as start and end.
							if(nums[j] == 1)
								ones++;
							else
								zeros++;
							
							if(ones == zeros)
								mxLen = max(mxLen, j-i+1);                                
						}
					}
					return mxLen;
				}
			};

		// Optimized:
			❌Pending

	563) String Reverse:
		Problem statement
			You are having a string ‘S’ containing ASCII characters.
			You are required to reverse the input string.
			Output the reverse of the string ‘S’.
			Example :
				S = “hello”

			Explanation : 
				The reverse of the string ‘S’ is “olleh”.
			Constraints :
				1 <= T <= 5
				1 <= S.length <= 10^5

				Time Limit: 1 sec
			Sample Input 1 :
				2
				ninja
				MoM
				Sample Output 1 :
				ajnin
				MoM
				Explanation Of Sample Input 1 :
				For test case 1 we have, 
				The reverse of “ninja” is “ajnin”.
				So, we output “ajnin” ( without quotes ).
				For test case 2 we have, 
				The reverse of “MoM” is “MoM” as it is a palindrome.
				So, we output “MoM”.
				Sample Input 2 :
				2
				ggUM
				Kzk
				Sample Output 2 :
				MUgg
				kzK

		#include <bits/stdc++.h> 
		string stringReverse(string S) {
			// reverse(S.begin(), end(S));
			// return S; 

			//or
			// for(int i=0; i<S.size()/2; i++)
			//     swap(S[i], S[S.size()-1-i]);
			// return S;

			//or
			for(int i=0; i<S.size()/2; i++){
				char ch = S[i];
				S[i] = S[S.size()-1-i];
				S[S.size()-1-i] = ch;
			}
			return S;
		}
	
	564) Search In A Row Wise And Column Wise Sorted Matrix:
		Problem statement
			You are given an 'N * N' matrix of integers where each row and each column is sorted in increasing order. You are given a target integer 'X'.
			Find the position of 'X' in the matrix. If it exists then return the pair {i, j} where 'i' represents the row and 'j' represents the column of the array, otherwise return {-1,-1}
			For example:
				If the given matrix is:
				[ [1, 2, 5],
				[3, 4, 9],
				[6, 7, 10]] 
				We have to find the position of 4. We will return {1,1} since A[1][1] = 4.
			Sample Input 1:
				2
				3 4
				1 2 5
				3 4 9
				6 7 10
				2 5
				4 5
				8 6
				Sample Output 1:
				1 1
				0 1
				Constraints:
				1 ≤ T ≤ 10
				1 ≤ N ≤ 10^3
				1 ≤ X ≤ 10^6
				1 ≤ A[i][j] ≤ 10^6

				where 'T' is the number of test cases, 'N' is the number of rows and columns, 'X' is the target value, and Aij is the elements of the matrix.
				Time Limit : 1 sec 
				Explanation of Input 1:
				The first test case is already explained in the problem statement.
				The second test case,  the given matrix is:
				[[4, 5],
				[5, 6]] 
				We have to find the position of 5. So we return {0,1}.
				Sample Input 2:
				2
				3 16
				2 4 8
				3 6 9
				4 7 16
				1 10
				4
				Sample Output 2
				2 2
				-1 -1
	
		#include <bits/stdc++.h> 
		pair<int, int> search(vector<vector<int>> matrix, int x) {
			pair<int, int> ans = {-1,-1};

			for(int i=0; i<matrix.size(); i++){
				for(int j=0; j<matrix.size(); j++){
					if(x == matrix[i][j])
						return {i,j};
				}
			}

			return ans;
		}

		// More Optimized
			#include <bits/stdc++.h> 
			pair<int, int> search(vector<vector<int>> matrix, int x) {

				// if x is largest than last element (mat[n-1][n-1]) of matrix then definitely the x will not be present in matrix
				// if x is smaller than first element (mat[0][0]) of matrix then definitely the x will not be present in matrix
				if(x > matrix[matrix.size()-1][matrix[0].size()-1] || x < matrix[0][0])
					return {-1,-1};

				int row=0, col=matrix[0].size()-1;

				while(row < matrix.size() && col >= 0){
					if(matrix[row][col] == x)
						return {row, col};
					else if(matrix[row][col] < x)
						row++;
					else
						col--;
				}

				return  {-1,-1};
			}

	565) Sort Elements By Frequency:
		Problem statement
			You are given a list of a repeated set of integers. Your task for the problem is to return a list of the given elements in decreasing sorted order of their frequency of repetition in the given list with the element with the highest frequency of repetition first and so on.
			Note :
			If two numbers have the same frequency then keep the one that was present before the other in the original given list (array) first.
			For Example :
			Input:  arr[] = {2, 5, 2, 8, 5, 6, 8, 8}
			Output: arr[] = {8, 8, 8, 2, 2, 5, 5, 6}

			Explanation :
				When you sort the array based on the decreasing order of the frequency of repetition of integers in the original array, 
				you’ll find that the element ‘8’ is the integer with the most repeated values therefore it would be arranged first after which since both 2 and 5 have the same number of repeated 
				values in the original array but since the 2 arrived first so we will first arrange 2 and then 5 in our resultant array, while would be the last element after sorting here.
			
			Constraints :
				1 <= T <= 10
				1 <= N <= 3000
				1 <= NUMS[i] <= 10^6

				Where 'NUMS[i]' denotes the 'ith' element of the given array.
				Time Limit: 1sec

			Sample Input 1 :
				2
				7
				1 2 3 3 2 1 1
				9
				1 3 2 2 2 3 4 3 1
				Sample Output 1 :
				1 1 1 2 2 3 3
				3 3 3 2 2 2 1 1 4
				Explanation For Sample Input 1 :
				When you sort the array based on the decreasing order of the frequency of repetition of integers in the original array, 
				you’ll find that all different elements ‘1’, ‘2’ and ‘3’ have the same frequency of repetition in the given list of integers but since the order of their arrival in the original array is different 
				therefore, we arrange them according to that. Hence, the resultant sorted list will become 1 1 2 2 3 3.


				When you sort the array based on the decreasing order of the frequency of repetition of integers in the original array, 
				you’ll find that both elements ‘2’ and ‘3’ have the same frequency of repetition in the given list of integers but since the order of 
				their arrival in the original array is different therefore we arrange them according to that. While the remaining elements ‘1’ and ‘4’ have different frequencies in the decreasing order of which they can be easily arranged. 
				Therefore the resultant sorted list will become 3 3 3 2 2 2 1 1 4.
				Sample Input 2 :
				1
				9
				2 5 2 6 9999999 5 8 8 8
				Sample Output 2 :
				8 8 8 2 2 5 5 6 9999999

		// Not Optimized:
			#include <bits/stdc++.h>
			bool DESCbyValues(pair<int, int> a, pair<int, int> b, vector<int> n){
				if(a.second == b.second)
					return (find(n.begin(), n.end(), a.first) < find(n.begin(), n.end(), b.first));
				return a.second > b.second;
			}

			vector<int> sortByFrequency(vector<int>& nums){
				vector<int> ans;

				map<int, int> F;
				for(int i: nums)
					F[i]++;

				vector<pair<int, int>> holder;
				for(auto itr: F)
					holder.push_back(itr);

				// this is the syntax for passing extra parameter to DESCbyValues function
				// usually in sort function the last argument which is function, takes only 2 parameter for comparison.

				// [&] this represents that we are passing extra parameter (here nums) by pass by reference method, use [&]
				/*
					sort(holder.begin(), holder.end(), [&](pair<int, int> a, pair<int, int> b){
						return DESCbyValues(a, b, nums);
					});
				*/
				
				// [=] this represents that we are passing extra parameter (here nums) by pass by value method
					/*
						to pass more than 2 arguments by pass by value method, use [=]
						sort(holder.begin(), holder.end(), [=](pair<int, int> a, pair<int, int> b){
							return DESCbyValues(a, b, nums);
						});
					*/

				// if we use just [] (empty brackets) its represents that we are not passing any extra parameter
					/*
						just to pass 2 argument
						sort(holder.begin(), holder.end(), [](pair<int, int> a, pair<int, int> b){
							return DESCbyValues(a, b);
						});
					*/

				sort(holder.begin(), holder.end(), [=](pair<int, int> a, pair<int, int> b){
					return DESCbyValues(a, b, nums);
				});

				for(auto i: holder){
					int repeat = i.second;
					while(repeat--){
						ans.push_back(i.first);
					}
				}
				return  ans;
			}
	
		// Optimized:
			❌Pending

	#LeetCode BiweeklyContest-126:
		566) Find the Sum of Encrypted Integers:
			Problem statement:
				You are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
				Return the sum of encrypted elements.

				Example 1:
				Input: nums = [1,2,3]
				Output: 6
				Explanation: The encrypted elements are [1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.

				Example 2:
				Input: nums = [10,21,31]
				Output: 66

				Explanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.

				Constraints:
					1 <= nums.length <= 50
					1 <= nums[i] <= 1000
		
			class Solution {
				public:
				int sumOfEncryptedInt(vector<int>& nums) {
					
					vector<int> holder;
					for(int i: nums){
						string s = to_string(i);
						int mxVal = 0;
						for(char ch : s)
							mxVal = max(mxVal, ch-'0');
						
						int len = s.size();
						char mxChar = mxVal + '0';
						s.clear();
						while(len--){
							s += string(1, mxChar);
						}
						
						mxVal = stoi(s);
						holder.push_back(mxVal);
					}
					
					int sum=0;
					for(int i: holder)
						sum += i;
					return sum;

					//or
					// return accumulate(holder.begin(), holder.end(), 0);

				}
			};

	567) Sum of Two Integers:
		Problem statement:
			Given two integers a and b, return the sum of the two integers without using the operators + and -.

			Example 1:
			Input: a = 1, b = 2
			Output: 3

			Example 2:
			Input: a = 2, b = 3
			Output: 5

			Constraints:
				-1000 <= a, b <= 1000

		class Solution {
			public:
			int getSum(int a, int b) {
				int value=0;
				
				for(int i=0; i<a; i++)
					value++;
				
				for(int i=0; i<b; i++)
					value++;
			
				for(int i=0; i>a; i--)
					value--;
				
				for(int i=0; i>b; i--)
					value--;
				
				return value;
				// return a+b;
			}
		};
	
	#LeetCode WeeklyContest-389:
		568) Existence of a Substring in a String and Its Reverse:
			Problem statement:
				Given a string s, find any substring of length 2 which is also present in the reverse of s.
				Return true if such a substring exists, and false otherwise.

				Example 1:
				Input: s = "leetcode"
				Output: true
				Explanation: Substring "ee" is of length 2 which is also present in reverse(s) == "edocteel".

				Example 2:
				Input: s = "abcba"
				Output: true
				Explanation: All of the substrings of length 2 "ab", "bc", "cb", "ba" are also present in reverse(s) == "abcba".

				Example 3:
				Input: s = "abcd"
				Output: false
				Explanation: There is no substring of length 2 in s, which is also present in the reverse of s.	

				Constraints:
					1 <= s.length <= 100
					s consists only of lowercase English letters.
		
			class Solution {
				public:
				bool isSubstringPresent(string s) {
					string test = s;
					reverse(test.begin(), test.end());
					
					for(int i=0; i<s.size()-1; i++){
						string sub = test.substr(i,2);
						if(s.find(sub) != string::npos)
							return 1;
					}
					return 0;
				}
			};

		569) Count Substrings Starting and Ending with Given Character:
			Problem statement:
				You are given a string s and a character c. Return the total number of 
				substrings
				of s that start and end with c.

				Example 1:
				Input: s = "abada", c = "a"
				Output: 6
				Explanation: Substrings starting and ending with "a" are: "abada", "abada", "abada", "abada", "abada", "abada".

				Example 2:
				Input: s = "zzz", c = "z"
				Output: 6
				Explanation: There are a total of 6 substrings in s and all start and end with "z".

				Constraints:
				1 <= s.length <= 10^5
				s and c consist only of lowercase English letters.

			// Not Optimized:
				class Solution {
					public:
					long long countSubstrings(string s, char c) {
						long long cnt=0;
						for(int i=0; i<s.size(); i++){
							int chars=1;
							for(int j=i; j<s.size(); j++){
								string test = s.substr(i,chars++);
								if(test[0] == c && test[test.size()-1] == c)
									cnt++;
							}
						}
						return cnt;
					}
				};
			
			// little Optimized:
				class Solution {
					public:
					long long countSubstrings(string s, char c) {
						long long cnt=0;
						for(int i=0; i<s.size(); i++){
							int chars=1;
							for(int j=i; j<s.size(); j++){
								if(s[i] != c)
									break;
									
								if(s[j] == c)
									cnt++;
							}
						}
						return cnt;
					}
				};

			// Optimized:
				class Solution {
					public:
					long long countSubstrings(string s, char c) {
						ios_base::sync_with_stdio(0);
						cin.tie(0);
						cout.tie(0);
						
						long long cnt=0;
						map<char, int> F;
						for(char ch: s)
							F[ch]++;

						int val = F[c];
						cnt += val;
						while(val--){
							cnt += val;
						}        
						return cnt;
					}
				};
			
			// More Optimized:
				class Solution {
					public:
					long long countSubstrings(string s, char c) {
						ios_base::sync_with_stdio(0);
						cin.tie(0);
						cout.tie(0);

						long long cnt=0;
						int crntCount=0;

						for(char ch: s)
							if(ch == c)
								cnt += ++crntCount;
						
						return cnt;
					}
				};
		
	570) Isomorphic Strings:
		Problem statement
			You have been given two strings, 'str1' and 'str2'.
			Your task is to return true if the given two strings are isomorphic to each other, else return false.
			Note :
			Two strings are isomorphic if a one-to-one mapping is possible for every character of the first string ‘str1’ to every character of the second string ‘str2’ while preserving the order of the characters.
			All occurrences of every character in the first string ‘str1’ should map to the same character in the second string, ‘str2’.
			For example :
			If str1 = “aab” and str2 = “xxy” then the output will be 1. ‘a’ maps to ‘x’ and ‘b’ maps to ‘y’.
			If str1 = “aab” and str2 = “xyz” then the output will be 0. There are two different characters in 'str1', while there are three different characters in 'str2'. So there won't be one to one mapping between 'str1' and 'str2'.
			Sample Input 1 :
			aab 
			xxy
			Sample Output 1 :
			1
			Explanation of sample input 1:
			The character ‘a’ maps to ‘x’ and ‘b’ maps to ‘y’. Hence, the answer is 1 in this case.
			Sample Input 2 :
			aab
			xyz
			Sample Output 2 :
			0
			Constraints :
			1 <= |str1|, |str2| <= 10^3
			|str1| is the length of the string str1, and |str2| is the length of the string str2.
			Follow Up:
				Can you solve this in O(N) time?

		// Not Optimized:
			bool areIsomorphic(string &str1, string &str2) {
				
				if(str2.size() != str1.size())
					return 0;
				
				map<char, int> m1, m2;
				for(char ch: str1)
					m1[ch]++;
				
				for(char ch: str2)
					m2[ch]++;

				if(m1.size() != m2.size())
					return 0;

				map<char, char> mapper;
				for(int i=0; i<str1.size(); i++){
					mapper[str1[i]] = str2[i];
				}

				//string generator
				string sample;
				for(int i=0; i<str2.size(); i++){
					sample += mapper[str1[i]];
				}

				if(sample == str2)
					return 1;
				return 0;
			}

		// Optimized:
			❌Pending
	
	571) Four Divisors:
		Problem statement
			Ninja was planning to propose to his crush, Nina, with his spectacular martial arts moves. But Nina was more interested in numbers and divisors, so she gave Ninja a challenge to complete. If Ninja solves it, only then she will date him.
			Nina gave him an array of positive integers, ‘ARR’ and asked him to find the sum of divisors of the integers in ‘ARR’ with exactly four divisors. In case there is no such integer with exactly four divisors, then the answer is 0. Ninja has been struggling for a very long time, so he needs your help to solve the problem.
			Constraints:
				1 <= T <= 5
				1 <= N <= 2000
				1 <= ARR[ i ] <= 10 ^ 5
			Where ‘T’ is the number of test cases, ‘N’ is the number of integers in the array, ‘ARR’ and ‘ARR[ i ]’ is the ‘i’th element in the ‘ARR’ array.
			Time limit: 1 second

			Note:
			You do not need to print anything, it has already been taken care of. Just implement the given function.
			Sample Input 1:
				2
				4
				2 5 6 15
				3
				4 18 21
				Sample Output 1:
				36
				32
				Explanation of Sample Output 1:
				Test Case 1 :  
				Divisors of 2 are 1 and 2.
				Divisors of 5 are 1 and 5.
				Divisors of 6 are 1, 2, 3 and 6.
				Divisors of 15 are 1, 3, 5 and 15.
				Since 6 and 15 have exactly four divisors. Sum of their divisors is (1 + 2 + 3 + 6) + (1 + 3 + 5 + 15) = 36.

				Test Case 2 : 
				Divisors of 4 are 1, 2 and 4.
				Divisors of 18 are 1, 2, 3, 6, 9 and 18.
				Divisors of 21 are 1, 3, 7 and 21.
				Since only 21 has exactly four divisors. Sum of its divisors is (1 + 3 + 7 + 21) = 32.
				Sample Input 2:
				2
				5
				7 35 64 11 8
				6
				27 13 42 25 25 25
				Sample Output 2:
				63
				40

		#include <bits/stdc++.h> 
		int sumFourDivisors(vector<int> &arr, int n) {
			vector<vector<int>> holder;
			for(int i=0; i<n; i++){
				int crntNum = arr[i];
				vector<int> temp;
				for(int j=1; j<=crntNum; j++){
					if(crntNum % j == 0)
						temp.push_back(j);
				}
				if(temp.size() ==4)
					holder.push_back(temp);
			}

			int sum=0;
			for(auto innerVec: holder){
				for(int element: innerVec)
					sum += element;
			}

			return sum;
		}

	572) Next Greater Element - I:
		Problem statement
			You are given an array ‘A’ containing a permutation ‘N’ numbers (0 ≤ A[i] < N). You are also given another array ‘B’ containing a permutation ‘M’ numbers (0 ≤ B[j] < M) and it is also given that N ≤ M.
			For each element in array ‘A’ you need to find the first greater element to the right of the element in array ‘B’ that has the same value as the current array A’s element. In other words, for each ‘i’ from 0 to N - 1 in array ‘A’, you need to find an index ‘j’ in array ‘B’ such that A[i] = B[j], now you need to print the element that lies on the right of the j’th index and is also greater than B[j]. Print -1 if there is no greater element.
			Follow Up :
			Can you solve it in O(N+M) time?
			For Example :
			If ‘N’ = 6, ‘A’ = {1, 2, 0, 3, 4, 5}, ‘M’ = 7 and ‘B’ = {3, 5, 0, 2, 1, 6, 4}.
			Then, we will return {6, 6, 2, 5, -1, 6} because:
			For i = 0, A[i] = 1 and the first element greater than 1 that lies to the right of it in array ‘B’ is 6.
			For i = 1, A[i] = 2 and the first element greater than 2 that lies to the right of it in array ‘B’ is 6.
			For i = 2, A[i] = 0 and the first element greater than 0 that lies to the right of it in array ‘B’ is 2.
			For i = 3, A[i] = 3 and the first element greater than 3 that lies to the right of it in array ‘B’ is 5.
			For i = 4, A[i] = 4 and there is no greater element to the right of 4 in array ‘B’.
			For i = 5, A[i] = 5 and the first element greater than 5 that lies to the right of it in array ‘B’ is 6.
			Constraints :
				1 ≤ T ≤ 10      
				1 ≤ N ≤ M ≤ 500
				0 ≤ A[i] < N
				0 ≤ B[i] < M

				Time limit: 1 sec
			Sample Input 1 :
				2
				6
				1 2 0 3 4 5
				7
				3 5 0 2 1 6 4
				3
				0 1 2
				3
				0 1 2
				Sample Output 1 :
				6 6 2 5 -1 6
				1 2 -1
				Explanation For Sample Input 1 :
				For test case 1 :
				We will print {6, 6, 2, 5, -1, 6} because:
				For i = 0, A[i] = 1 and the first element greater than 1 that lies to the right of it in array ‘B’ is 6.
				For i = 1, A[i] = 2 and the first element greater than 2 that lies to the right of it in array ‘B’ is 6.
				For i = 2, A[i] = 0 and the first element greater than 0 that lies to the right of it in array ‘B’ is 2.
				For i = 3, A[i] = 3 and the first element greater than 3 that lies to the right of it in array ‘B’ is 5.
				For i = 4, A[i] = 4 and there is no greater element to the right of 4 in array ‘B’.
				For i = 5, A[i] = 5 and the first element greater than 5 that lies to the right of it in array ‘B’ is 6.

				For test case 2 : 
				We will print {1, 2, -1} because:
				For i = 0, A[i] = 0 and the first element greater than 0 that lies to the right of it in array ‘B’ is 1.
				For i = 1, A[i] = 1 and the first element greater than 1 that lies to the right of it in array ‘B’ is 2.
				For i = 2, A[i] = 2 and there is no greater element to the right of 2 in array ‘B’.
				Sample Input 2 :
				2
				1
				0
				1
				0
				1
				0
				3
				0 2 1
				Sample Output 2 :
				-1
				2

		#include <bits/stdc++.h> 
		vector<int> nextGreaterElement(int n, vector<int> A, int m, vector<int> B) {
			vector<int> ans(n, -1);
			for(int i=0; i<n; i++){
				for(int j=0; j<m; j++){
					if(B[j] == A[i]){
						for(int k=j+1; k<m; k++){
							if(B[j] < B[k]){
								ans[i] = B[k];
								break;
							}
						}
					}
				}
			}
			return ans;
		}

	573) Product of the Last K Numbers:
		Problem Statement:
			Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.
			Implement the ProductOfNumbers class:
			ProductOfNumbers() Initializes the object with an empty stream.
			void add(int num) Appends the integer num to the stream.
			int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
			The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.

			Example:
			Input
			["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
			[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]
			Output
			[null,null,null,null,null,null,20,40,0,null,32]

			Explanation
			ProductOfNumbers productOfNumbers = new ProductOfNumbers();
			productOfNumbers.add(3);        // [3]
			productOfNumbers.add(0);        // [3,0]
			productOfNumbers.add(2);        // [3,0,2]
			productOfNumbers.add(5);        // [3,0,2,5]
			productOfNumbers.add(4);        // [3,0,2,5,4]
			productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
			productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
			productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
			productOfNumbers.add(8);        // [3,0,2,5,4,8]
			productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
			

			Constraints:
			0 <= num <= 100
			1 <= k <= 4 * 10^4
			At most 4 * 104 calls will be made to add and getProduct.
			The product of the stream at any point in time will fit in a 32-bit integer.


		 const auto init = [](){
			std::cin.tie(nullptr);
			std::cout.tie(nullptr);
			std::ios_base::sync_with_stdio(false);
			return 42;
		}();

		class ProductOfNumbers {
			public:
			vector<int> ans;
			ProductOfNumbers() {
				ans.push_back(1);
			}
			
			void add(int num) {
				if(num == 0){
					ans.clear();
					ans.push_back(1);
				}else{
					ans.push_back(ans.back() * num);
				}
			}
			
			int getProduct(int k) {
				if(k >= ans.size())
					return 0;
				return ans.back() / ans[ans.size()-1-k];
			}
		};
	
	574) Kth Integer:
		Problem statement
			You are given an array ‘A’ of ‘N’ distinct integers numbered from ‘0’ to ‘N - 1’. You are also given another two integers ‘K’ and ‘X’. Your task is to find the ‘kth’ smallest number among all those numbers which are not divisible by ‘X’ in the array ‘A’.
			Your task is to tell the ‘kth’ smallest number among all those numbers which are not divisible by ‘X’ and return it. If it doesn't exist, return “-1”.

			Example:
				‘N’ = 5
				‘A’ = [10, 1, 9, 2, 18]
				‘K’ = 2
				‘X’ = 3
			The numbers which are not divisible by ‘3’ are: [10, 1, 2].
			Here, the ‘2nd’ smallest number is ‘2’.
			Constraints:
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				1 <= 'K' <= 'N'
				1 <= ‘X’ <= 10^9
				1 <= A[i] <= 10^9
				Time Limit: 1 sec 

			Sample Input 1:
				2
				4 1 2
				2 4 7 9
				5 3 3
				3 6 9 12 15
				Sample Output 1:
				7
				-1
				Explanation of sample input 1:
				For test case 1:
				Here, the numbers which are not divisible by ‘2’ are: [7, 9].

				The ‘1st’ smallest number among all these numbers is ‘7’.

				For test case 2:
				Here, all the numbers are divisible by ‘3’. So, the answer for this test case is ‘-1’.
				Sample Input 2:
				2
				5 2 3
				10 3 27 81 9
				2 2 10
				1 5
				Sample Output 2:
				-1
				5

		int kthInteger (int n, int k, int x, vector <int> &a) {
			vector<int> holder;
			for(int i: a)
				if(i % x != 0)
					holder.push_back(i);
				
			sort(begin(holder), end(holder));
			if(k > holder.size())
				return -1;
			return holder[k-1];
		}

		// or SC: O(1)
		int kthInteger (int n, int k, int x, vector <int> &a) {
			int cnt=0;
			sort(begin(a), end(a));
			
			for(int i: a){
				if(i % x != 0)
				cnt++;
				
				if(cnt == k)
				return i;
			} 
			return -1;
		}
	
	#CodingNinja WeeklyContest-118
		575) Hacker:
			Problem statement
				You've hacked into a game and discovered that your high score is represented by a very long integer 'N' in string format. The hack allows you to rearrange the digits of your current high score.
				Your task is to find and return a string 'A' that represents the maximum possible high score you can achieve by permuting the digits.
				Example:
					‘N’ = ‘122’
					Return 221
				Any other permutation is smaller than or equal to ‘221’.
				Constraints:
					1 <= ‘T’ <= 10
					1 <= |N| <= 10^5 |N| represents the length of the string ‘N’
					Time Limit: 1 sec
				Sample Input 1:
				2
				454106
				6144136
				Sample Output 1:
					654410
					6644311
					Explanation of sample input 1:
					For 1st Test Case:
					Any other permutation is smaller than or equal to ‘654410’.

					For 2nd Test Case:
					Any other permutation is smaller than or equal to ‘6644311’.
					Sample Input 2:
					3
					117668
					185977
					92280947
					Sample Output 2:
					876611
					987751
					99874220
				
			// Not Optimized:
				string hack(string &n){
					sort(begin(n), end(n));
					reverse(begin(n), end(n));
					return n;
				}

				// or
				string hack(string &n){
					sort(begin(n), end(n), greater<char>());
					return n;
				}

				//or
				string hack(string &n){
					vector<int> holder;
					for(char ch: n)
						holder.push_back(ch-'0');

					sort(begin(holder), end(holder), greater<int>());

					string ans;
					for(int i: holder)
						ans += i + '0';		// to convert the int to char (in digit only)
											// or ans += to_string(i);
					return ans;
				}

			// Optimized:
				string hack(string &n){
					vector<int> Freq(10, 0);
					for(char c: n)
						Freq[c-'0']++;

					int pos=0;
					for(int i=9; i>=0; i--)
						for(int j=0; j<Freq[i]; j++)
							n[pos++] = i + '0';
							
					return n;
				}
		
		576) Find The Extra Letter:
			Problem statement
				There are two strings 'S' and 'T', having 'N' and 'N + 1' lowercase English characters, respectively.
				You can remove exactly one occurrence of some letter from the string 'T'. (The order of the remaining characters will not change.)
				Determine if you can make the string 'T' equal to 'S'. Return '1' in that case. Otherwise, return '0'.
				Example:
				N = 7
				S = 'abc'
				T = 'acbc'
				You can remove 'T[1]' from the string 'T'. So, 'T' is 'abc', which is equal to 'S'. (Note that we are using 0-based indexing.)
				So, the answer for this case is '1'.
				Constraints:
					1 <= 'N' <= 10^5
					'a' <= S[i] <= 'z'
					'a' <= T[i] <= 'z'
					Time limit: 1 sec

				Sample input 1:
					2
					3
					aaa
					aaaa
					4
					abab
					abbba
					Sample output 1:
					1
					0
					Explanation of sample input 1:
					For test case 1:
					You can remove 'T[0]' from the string 'T'. So, 'T' is 'aaa', which is equal to 'S'
					So, the answer for this case is '1'.

					For test case 2:
					We can not make string 'T' equal to 'S' by removing any character of it.
					So, the answer for this case is '0'.
					Sample input 2:
					2
					2
					ab
					baa
					5
					uvvyu
					uvuvyu
					Sample output 2:
					0
					1
				
			int canYouMakeEqual(int n, string &s, string &t) {
				for(int i=0; i<=n; i++){
					char crntCH = t[i];
					t.erase(t.begin()+i);
					if(t == s)
						return 1;
					t.insert(i, string(1, crntCH));
				}
				return 0;
			}
		
		577) Mad Queries:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’. You need to answer ‘Q’ queries of the following form:
				“L, R, X, Y, K”: Count the number of indexes ‘i’ such that ‘L’ <= ‘i’ <= ‘R’, and “((A[i] * X) + Y) <= K”.
				The values of ‘L’ and ‘R’ are given in the format of one-based indexing.
				These queries are stored in the “Queries” array of size ‘Q’. For any index ‘i’ from ‘0’ to ‘Q - 1’, the values of ‘L’, ‘R’, ‘X’, ‘Y’, and ‘K’ are given by ‘Queries[i][0]’, ‘Queries[i][1]’, ‘Queries[i][2]’, ‘Queries[i][3]’ and ‘Queries[i][4]’.
				You need to answer all the ‘Q’ queries and return the array which stores the answers for each query.

				Example:
					‘N’ = 5
					‘A’ = [1, 5, 10, 1, 12]
					‘Q’ = 2
					“Queries” = [[2, 4, 2, 0, 12], [1, 2, 1, 0, 4]].
					Let’s consider ‘1st’ query: 
					Here, ‘L’ = 2, ‘R’ = 4, ‘X’ = 2, ‘Y’ = 0, and ‘K’ = 12.
					For ‘i’ = ‘2’:The value of  “(A[2] * X + Y)” is equal to ‘8’, which is less than or equal to ‘12’. So, it follows the given inequality.
					For ‘i’ = ‘3’: The value of “(A[3] * X + Y)” is equal to ‘20’, which is greater than ‘12’. So, it does not satisfy the inequality.
					For ‘i’ = ‘4’: The value of “(A[4] * X + Y)” is equal to ‘2’, which is less than or equal to ‘12’. So, it follows the inequality.
					So, the total number of indexes following the given inequality is ‘2’.

					Let’s consider the ‘2nd’ query:
					Here, ‘L’ = 1’, ‘R’ = 2, ‘X’ = 2, ‘Y’ = 0, and ‘K’ = 4
					For ‘i’ = ‘1’: The value of “(A[1] * X + Y)” is equal to ‘1’, which is less than or equal to ‘4’. So, it follows the inequality.
					For ‘i’ = ‘2’: The value of “(A[2] * X + Y)” is equal to ‘5’, which is greater than ‘4’. So, it does not satisfy the inequality.
					The number of indexes following the given inequality is ‘1’.
					So, the answer for this example is: [2, 1].
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					1 <= 'Q’ <= 10^5
					1 <= ‘A[i]’ <= 10^5
					1 <= ‘Queries[i][0]’ <= ‘Queries[i][1]’ <= ‘N’
					1 <= ‘Queries[i][2]’ <= 10^9
					0 <= ‘Queries[i][3]’ <= 10^9
					1 <= ‘Queries[i][4]’ <= 10^9
					Time Limit: 1 sec 

				Sample Input 1:
					2
					4 2
					1 5 20 11
					3 4 3 0 50
					1 4 1 1 30
					2 1
					100 1
					2 2 1 0 1
					Sample Output 1:
					1 4
					1
					Explanation of sample input 1:
					For test case 1:

					For ‘1st query:
					Here, ‘L’ = 3, ‘R’ = 4, ‘X’ = 3, ‘Y’ = 0, and ‘K’ = 50.
					For ‘i’ = ‘3’: ‘(A[3] * X + Y)’ is equal to ‘60’.
					For ‘i’ = ‘4’: ‘(A[4] * X + Y)’ is equal to ‘33’.
					For this query, only the first index is following the given inequality.

					For ‘2nd’ query:
					Here, ‘L’ = 1, ‘R’ = 4, ‘X’ = 1, ‘Y’ = 1, and ‘K’ = 30.
					For ‘i’ = ‘1’: ‘(A[1] * X + Y)’ is equal to ‘2’.
					For ‘i’ = ‘2’: ‘(A[2] * X + Y)’ is equal to ‘6’.
					For ‘i’ = ‘3’: ‘(A[3] * X + Y)’ is equal to ‘21’.
					For ‘i’ = ‘4’: ‘(A[4] * X + Y)’ is equal to ‘12’.
					Here, all the indexes are following the given inequality.
					So, the answer for these two queries is: [1, 4].
					For test case ‘2’:
					Here, we are only given one query with ‘L’ = ‘2’, ‘R’ = ‘2’, ‘X’ = ‘1’, ‘Y’ = 0, and ‘K’ = ‘1’.
					The value of ‘(A[2] * X + Y)’ is equal to ‘1’, which is less than or equal to ‘1’.
					Hence, the answer for this test case is: [1].
					Sample Input 2:
					2
					4 2
					5 10 1 2
					1 4 2 2 20
					2 3 1 10 9
					2 2
					10 2
					1 1 10 1 200
					2 2 20 20 100
					Sample Output 2:
					3 0
					1 1
				
			// Not Optimized:
				vector <int> madQueries (int n, int q, vector <int> &a, vector <vector<int>> &queries) {
					vector<int> ans;

					for(int i=0; i<q; i++){
						// range accessing definer
						int L = queries[i][0], R=queries[i][1], X=queries[i][2], Y=queries[i][3], K=queries[i][4], cnt=0;
						while(L <= R){
						int val = a[L-1]*X + Y;
						if(val <= K)
							cnt++;
						L++;
						}
						ans.push_back(cnt);
					}
					return ans;
				}

			// Optimized:
				❌Pending 	concept: segment tree
	
	578) Split Array Into The Subsets:
		Problem statement
			Given an array, 'ARR' of 'N' integers print “true” if it is possible to split the array into some finite number of subsets such that each subset has the same integer in it and all subsets have the same size. The size of the subset should be greater than one.
			Print “false” if it is not possible to do the above task.
			Example:
				Input: 'ARR' = [1, 2, 4, 4, 1, 2]
				Output: true

				We can split the above array like this: [1, 1], [4, 4], [2, 2] 
				In the three subsets, each of size two. And every subset contains the same elements.
			Constraints :
				1 <= ‘T’ <= 10
				1 <= 'N' <= 10^5
				-10^9 <= 'ARR[i]'<= 10^9
				Time Limit : 1 sec

			Sample Input 1 :
				2
				6
				2 2 4 5 4 5
				5
				4 3 5 6 3
				Sample Output 1 :
				true
				false
				Explanation Of Sample Input 1 :
				For the first test case, we can split the array like this: [2, 2], [4, 4], [5, 5].

				For the second test case, it is not possible to split the array with the given condition.
				Sample Input 2 :
				2
				6
				2 3 4 5 3 5
				9
				2 3 3 2 3 1 2 1 1
				Sample Output 2 :
				false
				true
		
		#include <bits/stdc++.h> 
		bool isPossibleToSplit(int n, vector<int> &arr) {
			map<int, int> F;
			for(int i: arr)
				F[i]++;

			auto i = F.begin();
			int val = i -> second;
			if(val == 1)
				return 0;
			
			i++;

			for(i; i != F.end(); i++){
				int crntVal = i -> second;
				if(val != crntVal)
					return 0;
				val = crntVal;
			}
			return 1;
		}
	
	579) Squares Sum:
		Problem statement
			Given an array of ‘N’ integers and ‘q’ queries. The query is defined as below:-
			Given two integers ‘l’ and ‘r’ ( ‘l’ >=0 and ‘r’ <= ‘N’) Find the sum of squares of all elements of the array with index in the range ‘l’ and ‘r’ (Inclusive).
			Given three integers ‘l’ ,’r’ and ‘x’ ( ‘l’ >=0 and ‘r’ <= ‘N’) .Update the elements of the array by incrementing ‘x’ to all array elements with index in the range ‘l’ and ‘r’.
			Given three integers ‘l’ ,’r’ and ‘x’ ( ‘l’ >=0 and ‘r’ <= ‘N’) .Update the elements of the array by setting ‘x’ to all array elements with index in the range ‘l’ and ‘r’.
			Constraints :
				1 <= ’T’ <= 10
				1 <= ‘N’ <= 1000
				1 <= q <= 1000
				1 <= arr[i] <= 1000
				1 <= ‘x’ <= 1000

				Where ‘i’ varies from 0 to ‘n’ -1  where ‘n’ is the length of the array ‘arr’,q is the number of queries ‘arr[i]’ is the value of the element at index ‘i’. ‘x’ is the number for updating the range.
				Time Limit: 1 sec

			Sample Input 1 :
				1
				5
				1 2 3 4 5
				5
				2 0 2
				0 0 2 1
				2 0 3
				1 0 2 2
				2 0 4
				Sample Output 1 :
				14
				45
				53
				Sample Output Explanation :
				The first line has a single integer which means it’s a single test case.
				The next line has an integer 5 denoting that there are 5 integers in the array.
				Then the 5 space-separated integers in the third line represent the elements in the array.
				Then the fourth line has ‘q’ which is the number of queries. In this case, we have 5 queries.

				The 5 queries are as follow:-
				In first query type = 2   ‘l’ = 0 and ‘r’ = 2
				The sum of squares is  arr[0]^2 + arr[1]^2 + arr[2]^2 = 1^2 + 2^2 + 3^2 = 14

				In second query type = 0  ‘l’ = 0 and ‘r’ = 2 and ‘x’ = 1.
				Incrementing ‘x’ from 0 to 2 in an array. Thus array becomes [ 2,3,4,4,5].

				In third query type = 2 ‘l’ = 0 and ‘r’ = 3.
				The sum of squares is arr[0]^2 + arr[1]^2 + arr[2]^2 + arr[3]^3 = 2^2 + 3^2 + 4^2 + 4^2 = 45

				In fourth query type = 1  ‘l’ = 0 and ‘r’ = 2 and ‘x’ = 2.
				Setting ‘x’ from 0 to 2 in an array. Thus array becomes [2,2,2,4,5].

				In fifth query type = 2   ‘l’ = 0 and ‘r’ = 4
				The sum of squares is arr[0]^2 + arr[1]^2 + arr[2]^2 + arr[3]^3 + arr[3]^2  = 53
				Sample Input 2 :
				2
				5
				1 10 5 1 3 
				4
				0 1 1 10
				1 2 2 6
				0 1 4 6
				2 0 4 
				6
				6 2 8 3 5 2 
				3
				0 1 2 2
				2 1 1 
				2 0 2  
				Sample Output 2 :
				951
				16
				152
		
		#include <bits/stdc++.h> 
		vector<long long int> solve(int N, vector<int> &arr, int q, vector<vector<int>> &queries) {
			vector<long long int> ans;
			int i=0, L, R, X;

			while(i < q){
				// if query is of type 0 then increment all the elements between L & R by x
				// if query is of type 1 then setting all the elements between L & R to x
				// if query is of type 2 then finding sum of Squares all the elements between L & R.

				if(queries[i][0] == 0){
					// increment by x
					L = queries[i][1], R=queries[i][2], X = queries[i][3];

					for(int z=L; z<=R; z++)
						arr[z] += X;

				}else if(queries[i][0] == 1){
					// setting to x
					L = queries[i][1], R=queries[i][2], X = queries[i][3];
					
					for(int z=L; z<=R; z++)
						arr[z] = X;
				}else{
					// finding Square sum
					L = queries[i][1], R=queries[i][2];
					long long int sum=0;

					for(int z=L; z<=R; z++)
						sum += pow(arr[z],2);

					ans.push_back(sum);
				}
				i++;
			}
			return ans;
		}

	580) Account Balance After Rounded Purchase:
		Problem statement:
			Initially, you have a bank account balance of 100 dollars.
			You are given an integer purchaseAmount representing the amount you will spend on a purchase in dollars.
			At the store where you will make the purchase, the purchase amount is rounded to the nearest multiple of 10. In other words, you pay a non-negative amount, roundedAmount, such that roundedAmount is a multiple of 10 and abs(roundedAmount - purchaseAmount) is minimized.
			If there is more than one nearest multiple of 10, the largest multiple is chosen.
			Return an integer denoting your account balance after making a purchase worth purchaseAmount dollars from the store.
			Note: 0 is considered to be a multiple of 10 in this problem.
			Example 1:
				Input: purchaseAmount = 9
				Output: 90
				Explanation: In this example, the nearest multiple of 10 to 9 is 10. Hence, your account balance becomes 100 - 10 = 90.

			Example 2:
				Input: purchaseAmount = 15
				Output: 80
				Explanation: In this example, there are two nearest multiples of 10 to 15: 10 and 20. So, the larger multiple, 20, is chosen.
				Hence, your account balance becomes 100 - 20 = 80.

			Constraints:
				0 <= purchaseAmount <= 100

		class Solution {
			public:
			int accountBalanceAfterPurchase(int purchaseAmount) {
				int val = purchaseAmount % 10;
				if(val >= 5){
					if(val == 5)
						purchaseAmount += 5;
					else if(val == 6)
						purchaseAmount += 4;
					else if(val == 7)
						purchaseAmount += 3;
					else if(val == 8)
						purchaseAmount += 2;
					else
						purchaseAmount += 1;
				}else{
					if(val == 0)
						purchaseAmount -= 0;
					else if(val == 1)
						purchaseAmount -= 1;
					else if(val == 2)
						purchaseAmount -= 2;
					else if(val == 3)
						purchaseAmount -= 3;
					else
						purchaseAmount -= 4;
				}

				return 100 - purchaseAmount;
			}
		};
	
	581) Fibonacci series up to Nth term:
		Problem statement:
			You are given an integer n, return the fibonacci series till the nth(0-based indexing) term. Since the terms can become very large return the terms modulo 109+7.

			Example 1:
			Input:
			n = 5
			Output:
			0 1 1 2 3 5
			Explanation:
			0 1 1 2 3 5 is the Fibonacci series up to the 5th term.

			Example 2:
			Input:
			n = 10
			Output:
			0 1 1 2 3 5 8 13 21 34 55
			Explanation:
			0 1 1 2 3 5 8 13 21 34 55 is the Fibonacci series up to the 10th term.
			
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function Series() which takes an Integer n as input and returns a Fibonacci series up to the nth term.

			Expected Time Complexity: O(n)
			Expected Space Complexity: O(n)
			Constraint:
				1 <= n <= 10^5

		class Solution {
			public:
			vector<int> Series(int n) {
				vector<int> ans;
				
				if(n==1)
					return {0,1};
					
				int prev=0, cur=1;
				ans.push_back(0);
				ans.push_back(1);
				
				int MOD = 1e9+7;
				
				for(int i=2; i<=n; i++){
					int val = (prev + cur) % MOD;
					ans.push_back(val);
					prev = cur % MOD;
					cur = val % MOD;
				}
				return ans;
			}
		};

	582) Alice and Marks:
		Problem statement:
			Alice has scored X marks in her test and Bob has scored Y marks in the same test. Alice is happy if she scored at least twice the marks of Bob’s score. Determine whether she is happy or not.
			Input Format
				The first and only line of input contains two space-separated integers, X,Y — the marks of Alice and Bob respectively.
			Output Format
				For each testcase, print Yes if Alice is happy and No if she is not, according to the problem statement.
			The judge is case insensitive so you may output the answer in any case. In particular YES, yes, yEsare all considered equivalent to Yes.
			Constraints
			1 ≤ X,Y ≤ 100
			Sample 1:
			Input
			2 1
			Output
			Yes
			Explanation:
			Alice has scored X=2 marks whereas Bob has scored Y=1 mark. As Alice has scored twice as much as Bob (i.e.X ≥ 2Y), the answer is Yes.

			Sample 2:
			Input
			1 2
			Output
			No
			Explanation:
			Alice has scored X=1 mark whereas Bob has scored Y=2 marks. As Alice has not scored twice as much as Bob (i.e. X<2Y), the answer is No.
			
		#include <iostream>
		using namespace std;

		int main() {
			int x,y;
			cin>>x>>y;
			
			if(x >= (2*y))
				cout<<"YES";
			else
				cout<<"NO";
				return 0;
		}
	
	583) Chef and Brain Speed:
		Problem Statement:
			In ChefLand, human brain speed is measured in bits per second (bps). Chef has a threshold limit of X bits per second above which his calculations are prone to errors. If Chef is currently working at Y bits per second, is he prone to errors?
			If Chef is prone to errors print YES, otherwise print NO.

			Input Format
				The only line of input contains two space separated integers X and Y — the threshold limit and the rate at which Chef is currently working at.

			Output Format
				If Chef is prone to errors print YES, otherwise print NO.
			You may print each character of the string in uppercase or lowercase (for example, the strings yes, Yes, yEs, and YES will all be treated as identical).
			Constraints
				1 ≤ X,Y ≤ 100
			Sample 1:
				Input
				7 9
				Output
				YES
				Explanation:
					Chef's current brain speed of 9bps is greater than the threshold of 7 bps, hence Chef is prone to errors.

			Sample 2:
				Input
				6 6
				Output
				NO
				Explanation:
				Chef's current brain speed of 6 bps is not greater than the threshold of 6 bps, hence Chef is not prone to errors.

			Sample 3:
				Input
				31 53
				Output
				YES
				Explanation:
				Chef's current brain speed of 53 bps is greater than the threshold of 31 bps, hence Chef is prone to errors.

			Sample 4:
				Input
				53 8
				Output
				NO
				Explanation:
				Chef's current brain speed of 8 bps is not greater than the threshold of 53 bps, hence Chef is not prone to errors.

		#include <iostream>
		using namespace std;

		int main() {
			int x,y;
			cin>>x>>y;
			
			if(x >= y)
				cout<<"NO";
			else
				cout<<"YES";		
			return 0;
		}
	
	584) Oneful Pairs:
		Problem statement:
			Chef defines a pair of positive integers (a,b) to be a Oneful Pair a+b+(a⋅b)=111
			For example, (1,55) is a Oneful Pair, since 
			1+55+(1⋅55)=56+55=111.
			But (1,56) is not a Oneful Pair, since 1+56+(1⋅56)=57+56= 113 ≠ 111.

			Given two positive integers a and b, output Yes if they are a Oneful Pair. And No otherwise.
			Input Format
			The only line of input contains two space-separated integers a and b.
			Output Format
				Output Yes, if (a,b) form a Oneful Pair. Output No if they do not.
			You may print each character of Yes and No in uppercase or lowercase (for example, yes, yEs, Yes will be considered identical).

			Constraints
				1 ≤ a,b ≤ 1000
			Sample 1:
				Input
				1 55
				Output
				Yes
				Explanation:
				(1,55) is a Oneful Pair, since 
				1+55+(1⋅55)=56+55=111.

			Sample 2:
				Input
				1 56
				Output
				No
				Explanation: (1,56) is not a Oneful Pair, since 
				1+56+(1⋅56)=57+56=113≠111

		#include <iostream>
		using namespace std;

		int main() {
			int a,b;
			cin>>a>>b;
			if((a+b+(a*b)) == 111)
				cout<<"YES";
			else
				cout<<"NO";
			return 0;
		}
	
	585) AC Please:
		Problem statement:
			Chef is feeling the heat this summer and wants to switch on the Air Conditioning all the time, but since he doesn't want to harm the environment much, he only switches it on when the room temperature is strictly greater than 30 degrees celsius.
			Given the room temperature, you need to find whether Chef will switch on the air conditioning or not.

			Input Format
				The only line of input will contain a single integer T - denoting the room temperature.
			Output Format
				Print YES if Chef will turn the Air Conditioning on, otherwise print NO.
			You may print each character of the string in uppercase or lowercase (for example, the strings YES, yEs, yes, and yeS will all be treated as identical).

			Constraints
				1 ≤ T ≤ 50
			Sample 1:
				Input
				30
				Output
				NO
				Explanation:
				Since the temperature is not more than 30 degrees Celsius Chef won't turn on the Air Conditioning.

			Sample 2:
				Input
				41
				Output
				YES
				Explanation:
				Since the temperature is more than 30 degrees Celsius Chef will turn on the Air Conditioning.

		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int T;
			int temp;
			cin>>temp;
			if(temp > 30)
				cout<<"YES"<< endl;
			else
				cout<<"NO"<< endl;
			return 0;
		}
		
	586) Minimum Wage:
		Problem statement:
			The minimum wage in Chefland is 11 dollars per hour.
			Given that Chef earns X dollars per hour, find whether his income is strictly above the minimum wage.

			Input Format
				The first and only line contains an integer X, denoting the income of Chef per hour.
			Output Format
				Output on a new line, YES, if Chef's income is strictly above the minimum wage. Otherwise, output NO.
			You may print each character of the string in uppercase or lowercase (for example, the strings YES, yEs, yes, and yeS will all be treated as identical).

			Constraints
				1 ≤ X ≤ 20
			Sample 1:
			Input
			20
			Output
			YES
			Explanation:
			Chef's income is 20 dollars per hour, which is strictly higher than the minimum wage.

			Sample 2:
			Input
			11
			Output
			NO
			Explanation:
			Chef's income is 11 dollars per hour, which is not higher than the minimum wage.

		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int M;
			cin>>M;
			
			if(M > 11)
				cout<<"YES";
			else
				cout<<"NO";
			return 0;
		}

	587) Strange Numbers:
		Problem statement
			Alice is very fond of digits. While she was playing with digits from 0 to 9, she noticed that when digits 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6, respectively, and when digits 2, 3, 4, 5, and 7 are rotated 180 degrees, they become invalid.
			After noticing such a property of digits, she started considering some numbers as strange numbers. According to her, a strange number is a number that, when rotated 180 degrees in a clockwise fashion, becomes a different number with each digit valid. As she is busy playing with digits, she gave you an integer ‘N’ and asked you to find the number of strange numbers from 1 to ‘N’ inclusive.
			Note :
			The rotated number can be greater(or smaller) than the original number.
			Sample Input 1 :
				2
				5
				10
				Sample Output 1 :
				0
				3
				Explanation For Sample Input 1 :
				Test case 1:
				Numbers from 1 to 5 are 1, 2, 3, 4, 5. 
				1, when rotated 180 degrees, remains the same.
				2, 3, 4, 5, when rotated 180 degrees, becomes invalid.
				Therefore there are 0 strange numbers from 1 to 5.

				Test case 2:
				Strange numbers from 1 to 10 inclusive are 6, 9, and 10.
				6, when rotated 180 degrees, becomes 9.
				9, when rotated 180 degrees, becomes 6.
				10, when rotated 180 degrees, becomes 01, which is the same as 1.
				Sample Input 2 :
				1
				16
				Sample Output 2:
				4
				Explanation For Sample Input 2 :
				Test case 1:
				Strange numbers from 1 to 16 inclusive are 6, 9, 10, and 16.
				6, when rotated 180 degrees, becomes 9.
				9, when rotated 180 degrees, becomes 6.
				10, when rotated 180 degrees, becomes 01, which is the same as 1.
				16, when rotated 180 degrees, becomes 91.

		#include <bits/stdc++.h> 
		int strangeNumbers(int n) {
			int cnt=0;
			for(int i=6; i<=n; i++){
				int temp = i, flag =1;
				while(temp){
					if(temp%10 == 2 || temp%10 == 3 || temp%10 == 4 || temp%10 == 5 || temp%10 == 7){
						flag =0;
						break;
					}
					temp /= 10;
				}
				if(flag){
					string s1, s2;
					s1=s2= to_string(i);

					for(int z=0; z<s2.size(); z++)
						if(s2[z] == '6')
							s2[z] = '9';
						else if(s2[z] == '9')
							s2[z] = '6';

					reverse(begin(s2), end(s2));
					
					if(s2 != s1)
						cnt++;
				}
			}
			return cnt;
		}
	
	588) Chocolate Removal Challenge:
		Problem statement
			You are given an array 'A' of size 'N'. Each element 'A[i]' represents the number of chocolates in the 'i-th' pile. In a single move, you are allowed to perform the following operation: If a pile contains more than 23 chocolates, you can take out all the chocolates leaving only 23 in the pile.
			Your task is to calculate and return the total number of chocolates you will remove from the piles.
			Example :
				Input: A = [25, 24, 29, 15]
				Output: 9

				First pile: Contains 25 chocolates, remove 2 to leave 23. Chocolates removed = 2.
				Second pile: Contains 24 chocolates, remove 1 to leave 23. Chocolates removed = 1.
				Third pile: Contains 29 chocolates, remove 6 to leave 23. Choclates removed = 6
				Fourth pile: Contains 15 chocolates, no chocolates removed as the pile already has less than or equal to 23 chocolates.
				Total chocolates removed = 2 + 1 + 6 = 9.
			Constraints:
				1 ≤ T ≤ 10
				1 ≤ N  ≤ 10^5
				1 ≤ A[i] ≤ 10^9

			Time limit: 1 sec
			Sample Input 1:
				2
				4
				25 24 10 15
				3
				30 20 40
				Sample Output 1 :
				3
				24
				Explanation For Sample Input 1:
				For test case 1:
				We remove 2 chocolates from the first pile and 1 from the second pile. Hence the total chocolates removed = 2 + 1 = 3.

				For test case 2:
				We remove 7 chocolates from the first pile, none from the second pile and 17 from the third pile. Hence the total chocolates removed = 7 + 17 = 24.
				Sample Input 2:
				2
				5
				100 200 300 400 500
				1
				23
				Sample Output 2 :
				1385
				0

		long long totalChocolates(vector<int> a, int n) {
			long long ttl_cnt=0;
			for(int i=0; i<n; i++)
				if(a[i] >23)
					ttl_cnt += a[i] -23;

			return ttl_cnt;
		}

	589) Coin Game:
		Problem statement
			Alice and Bob are playing a game of coins. Initially, they have a set of coins containing 'X' 10 rupees coins and 'Y' 75 rupees coins.
			In each turn, they should pick coins with a total value of 105 rupees, which will then be discarded from the set. If any player cannot choose coins to make the total value of 105, that player is declared the loser.
			Alice goes first. Return 1 if Alice wins; else, return 0.

			Example :
				Input: 'X’ = 15, ‘Y’ = 1
				Output: 1

				Alice starts the game and picks one 75 rupees coin and three 10 rupees coins making a total of 105. 
				Now, Bob cannot make 105 with the remaining coins (12 ten rupees coins). Hence Alice wins.
			Constraints:
				1 ≤ X, Y ≤ 10^9

			Time limit: 1 sec
			Sample Input 1:
				50 1
				Sample Output 1 :
				1
				Explanation For Sample Input 1:
				Alice starts the game and picks one 75 rupees coin and three 10 rupees coins making a total of 105. Now, Bob cannot make 105 with the remaining coins (47 ten rupees coins). Hence Alice wins. Therefore, the output is 1.
				Sample Input 2:
				1 1
				Sample Output 2 :
				0
				Explanation For Sample Input 2:
				Alice starts the game but is not able to make sum 105. Hence Bob wins. Therefore, the output is 0.

		// Not optimized:
			int coinGame(int x, int y) {
				int turn = 0;
				while(y > 0){
					if(x >= 3){
						x -= 3;
					}
					else{
						break;            
					}
					y--;
					turn = (turn == 0) ? 1 : 0;
				}
				if(turn)
					return 1;
				return 0;
			}
		
		// Optimized
			❌Pending
	
	590) Find the Duplicate Number:
		Problem statement:
			Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
			There is only one repeated number in nums, return this repeated number.
			You must solve the problem without modifying the array nums and uses only constant extra space.			

			Example 1:
			Input: nums = [1,3,4,2,2]
			Output: 2

			Example 2:
			Input: nums = [3,1,3,4,2]
			Output: 3

			Example 3:
			Input: nums = [3,3,3,3,3]
			Output: 3
		
			Constraints:
			1 <= n <= 10^5
			nums.length == n + 1
			1 <= nums[i] <= n
			All the integers in nums appear only once except for precisely one integer which appears two or more times.

			Follow up:
				How can we prove that at least one duplicate number must exist in nums?
				Can you solve the problem in linear runtime complexity?

		#define faster                 \
		ios::sync_with_stdio(false); 	 \
		cin.tie(nullptr);            	 \
		cout.tie(nullptr);

		class Solution {
			public:
			int findDuplicate(vector<int>& nums) {
				faster              			// Macro
				sort(nums.begin(), end(nums));

				for(int i=0; i<nums.size()-1; i++)
					if(nums[i] == nums[i+1])
						return nums[i];        

				throw ;
			}
		};
	
	591) Insert an Element at the Bottom of a Stack:
		Problem Statement:
			You are given a stack st of n integers and an element x. You have to insert x at the bottom of the given stack. 
			Note: Everywhere in this problem, the bottommost element of the stack is shown first while priniting the stack.

			Example 1:
			Input:
			n = 5
			x = 2
			st = {4,3,2,1,8}
			Output:
			{2,4,3,2,1,8}
			Explanation:
			After insertion of 2, the final stack will be {2,4,3,2,1,8}.

			Example 2:
			Input:
			n = 3
			x = 4
			st = {5,3,1}
			Output:
			{4,5,3,1}
			Explanation:
			After insertion of 4, the final stack will be {4,5,3,1}.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function insertAtBottom() which takes a stack st and an integer x as inputs and returns the modified stack after insertion.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 <= n <= 10^5
				0 <= x, elements of stack <= 10^9

		class Solution{
			public:
			stack<int> insertAtBottom(stack<int> st,int x){
				stack<int> reversal;
				while(!st.empty()){
					reversal.push(st.top());
					st.pop();
				}
				
				reversal.push(x);
				while(!reversal.empty()){
					st.push(reversal.top());
					reversal.pop();
				}
				return st;
			}
		};

	592) Find The Repeating And Missing Number:
		Problem statement:
			You are given an array 'nums' consisting of first N positive integers. But from the N integers, one of the integers occurs twice in the array, and one of the integers is missing. You need to determine the repeating and the missing integer.
			Example:
			Let the array be [1, 2, 3, 4, 4, 5]. In the given array ‘4’ occurs twice and the number ‘6’ is missing.
			Constraints:
				1 <= T <= 100 
				2 <= N <= 10^4
				1 <= nums[i] <= N

				Time Limit: 1 sec
			Sample Input 1:
				2
				5
				1 4 2 5 2
				2
				2 2    
				Sample Output 1:
				2 3
				2 1
				Explanation For Sample Input 1:
				For the first test case we have, array: [1, 4, 2, 5, 2] and N = 5.
				In the given array ‘2’ occurs twice and the number ‘3’ is missing. Hence, we output 2 and 3 for the repeating and the missing number, respectively.
				For the second test case we have, array: [2, 2] and N = 2.
				In the given array ‘2’ occurs twice and the number ‘1’ is missing. Hence, we output 2 and 1 for the repeating and the missing number, respectively.
				Sample Input 2:
				3
				4
				1 2 2 3
				10
				1 3 4 5 5 6 7 8 9 10
				3
				1 2 2
				Sample Output 2:
				2 4 
				2 5 
				2 3

		// Not Optimized:
			#include<bits/stdc++.h>
			vector<int> findRepeatingAndMissingNumbers(vector<int> arr) {
				int n = arr.size();

				sort(arr.begin(), arr.end());
				int num=1;
				while(find(arr.begin(), arr.end(), num) != arr.end())
					num++;
				
				int repeated=0;
				for(int i=0; i<n-1; i++)
					if(arr[i] == arr[i+1]){
						repeated = arr[i];
						break;
					}

				return {repeated, num};
			}
	
		// Optimized:
			#include<bits/stdc++.h>
			vector<int> findRepeatingAndMissingNumbers(vector<int> arr) {
				int n = arr.size();
				sort(arr.begin(), arr.end());

				int num=1;
				int repeated=0;
				for(int i=0; i<n-1; i++)
					if(arr[i] == arr[i+1]){
						repeated = arr[i];
						arr.erase(arr.begin()+i);
						break;
					}

				for(int i=0; i<n; i++)
					if(num == arr[i]){
						num++;
					}
					else
						break;
				return {repeated, num};
			}
	
	#LeetCode WeeklyContest-390:
		593) Maximum Length Substring With Two Occurrences:
			Problem statement:
				Given a string s, return the maximum length of a substring
				such that it contains at most two occurrences of each character.
				
				Example 1:
				Input: s = "bcbbbcba"
				Output: 4
				Explanation:
				The following substring has a length of 4 and contains at most two occurrences of each character: "bcbbbcba".

				Example 2:
				Input: s = "aaaa"
				Output: 2
				Explanation:
				The following substring has a length of 2 and contains at most two occurrences of each character: "aaaa".
				
				Constraints:
					2 <= s.length <= 100
					s consists only of lowercase English letters.

			#define Faster \
			ios_base::sync_with_stdio(false);   \
			cin.tie(0);                         \
			cout.tie(0);                         \

			class Solution {
				public:
				int maximumLengthSubstring(string s) {
					Faster
					int mxLen=0;
					for(int i=0; i<s.size(); i++) {
						string test;
						map<char, int> F;
						for(int j=i; j<s.size(); j++){
							F[s[j]]++;
							if(F[s[j]] <= 2){
								test += s[j];
								mxLen = max(mxLen, static_cast<int>(test.size()));			//or mxLen = max(mxLen, (int)test.size());
																					//or mxLen = fmax(mxLen, test.size());

							}
							else
								break;
						}
					}
					return mxLen;
				}
			};

		594) Apply Operations to Make Sum of Array Greater Than or Equal to k:
		Problem Statement:
			You are given a positive integer k. Initially, you have an array nums = [1].
			You can perform any of the following operations on the array any number of times (possibly zero):

			Choose any element in the array and increase its value by 1.
			Duplicate any element in the array and add it to the end of the array.
			Return the minimum number of operations required to make the sum of elements of the final array greater than or equal to k.

			Example 1:
				Input: k = 11
				Output: 5
				Explanation:
				We can do the following operations on the array nums = [1]:
				Increase the element by 1 three times. The resulting array is nums = [4].
				Duplicate the element two times. The resulting array is nums = [4,4,4].
				The sum of the final array is 4 + 4 + 4 = 12 which is greater than or equal to k = 11.
				The total number of operations performed is 3 + 2 = 5.

			Example 2:
				Input: k = 1
				Output: 0
				Explanation:
				The sum of the original array is already greater than or equal to 1, so no operations are needed.

			Constraints:
				1 <= k <= 10^5

		#define faster                      \
		ios_base::sync_with_stdio(0);   	 \
		cin.tie(0);                     	 \
		cout.tie(0);         

		class Solution {
			public:
			int minOperations(int k) {
				faster
				vector<int> holder;
				
				if(k==1)
					return 0;
				for(int i=1; i <= (k/2); i++)
					holder.push_back(i);

				int minOpsCnt=INT_MAX;
				for(int i=0; i<holder.size(); i++){
					int crntOpsCnt = holder[i]-1, sum = holder[i];

					while(sum < k){
						crntOpsCnt++;
						sum += holder[i];
					}
					minOpsCnt = min(minOpsCnt, crntOpsCnt);
				}
				return minOpsCnt;
			}
		};

	595) Find All Duplicates in an Array:
		Problem statement:
			Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
			You must write an algorithm that runs in O(n) time and uses only constant extra space.

			Example 1:
				Input: nums = [4,3,2,7,8,2,3,1]
				Output: [2,3]

			Example 2:
				Input: nums = [1,1,2]
				Output: [1]

			Example 3:
				Input: nums = [1]
				Output: []

			Constraints:
				n == nums.length
				1 <= n <= 10^5
				1 <= nums[i] <= n
				Each element in nums appears once or twice.
		
		class Solution {
			public:
			vector<int> findDuplicates(vector<int>& nums) {
				vector<int> ans;

				sort(begin(nums), end(nums));
				
				for(int i=0; i<nums.size()-1; i++)
					if(nums[i] == nums[i+1])
						ans.push_back(nums[i]);

				return ans;
			}
		};

	596) Minimum Operations to Exceed Threshold Value I:
		Problem statement:
			You are given a 0-indexed integer array nums, and an integer k.
			In one operation, you can remove one occurrence of the smallest element of nums.
			Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.

			Example 1:
				Input: nums = [2,11,10,1,3], k = 10
				Output: 3
				Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
				After two operations, nums becomes equal to [11, 10, 3].
				After three operations, nums becomes equal to [11, 10].
				At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
				It can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.

			Example 2:
				Input: nums = [1,1,2,4,9], k = 1
				Output: 0
				Explanation: All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.
				
			Example 3:
				Input: nums = [1,1,2,4,9], k = 9
				Output: 4
				Explanation: only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.
		
			Constraints:
				1 <= nums.length <= 50
				1 <= nums[i] <= 10^9
				1 <= k <= 10^9
				The input is generated such that there is at least one index i such that nums[i] >= k.

		#define makeItFaster ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
		class Solution {
			public:
			int minOperations(vector<int>& nums, int k) {
				makeItFaster
				int OpsCnt=0;
				for(int i: nums)
					if(i < k)
						OpsCnt++;

				return OpsCnt;
			}
		};
	
	597) Search Insert Position:
		Problem statement:
			Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
			You must write an algorithm with O(log n) runtime complexity.
	
			Example 1:
				Input: nums = [1,3,5,6], target = 5
				Output: 2

			Example 2:
				Input: nums = [1,3,5,6], target = 2
				Output: 1

			Example 3:
				Input: nums = [1,3,5,6], target = 7
				Output: 4
			
			Constraints:
				1 <= nums.length <= 10^4
				-10^4 <= nums[i] <= 10^4
				nums contains distinct values sorted in ascending order.
				-10^4 <= target <= 10^4
		
		class Solution {
			public:
			int searchInsert(vector<int>& nums, int target) {
				int s,e,index;
				s=0, e=nums.size()-1;
				while(s<=e){
					int mid = (s+e)/2;
					if(nums[mid] == target)
						return mid;
					else if(nums[mid] < target)
						s = mid+1;
					else
						e = mid-1;
				}
				return s;
			}
		};
	
	598) First Bad Version:
		Problem statement:
			You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
			Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.
			You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.			

			Example 1:
				Input: n = 5, bad = 4
				Output: 4
				Explanation:
				call isBadVersion(3) -> false
				call isBadVersion(5) -> true
				call isBadVersion(4) -> true
				Then 4 is the first bad version.

			Example 2:
				Input: n = 1, bad = 1
				Output: 1

			Constraints:
				1 <= bad <= n <= 2^31 - 1
		// The API isBadVersion is defined for you.
		// bool isBadVersion(int version);
		class Solution {
			public:
			int firstBadVersion(int n) {
				int version=1;
				while(!isBadVersion(version))
					version++;

				return version;
			}
		};
	
	599) Guess Number Higher or Lower:
		Problem statement:
			We are playing the Guess Game. The game is as follows:
			I pick a number from 1 to n. You have to guess which number I picked.
			Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
			You call a pre-defined API int guess(int num), which returns three possible results:
				-1: Your guess is higher than the number I picked (i.e. num > pick).
				1: Your guess is lower than the number I picked (i.e. num < pick).
				0: your guess is equal to the number I picked (i.e. num == pick).
			Return the number that I picked.

			Example 1:
				Input: n = 10, pick = 6
				Output: 6
				
			Example 2:
				Input: n = 1, pick = 1
				Output: 1

			Example 3:
				Input: n = 2, pick = 1
				Output: 1
	
			Constraints:
				1 <= n <= 2^31 - 1
				1 <= pick <= n

		/** 
		* Forward declaration of guess API.
		* @param  num   your guess
		* @return 	     -1 if num is higher than the picked number
		*			      1 if num is lower than the picked number
		*               otherwise return 0
		* int guess(int num);
		*/

		class Solution {
			public:
			int guessNumber(int n) {
				int s=1, e=n;
				while(s <= e){
					int m = s + (e-s)/2;
					if(guess(m) == 0)					//	if(!guess(m))
						return m;
					else if(guess(m) == 1)
						s = m+1;
					else
						e = m-1;
				}
				// throw ;     
				// or 
				return -1;
			}
		};
	
	600) First Missing Positive:
		Problem statement:
			Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.
			You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.			

			Example 1:
				Input: nums = [1,2,0]
				Output: 3
				Explanation: The numbers in the range [1,2] are all in the array.

			Example 2:
				Input: nums = [3,4,-1,1]
				Output: 2
				Explanation: 1 is in the array but 2 is missing.

			Example 3:
				Input: nums = [7,8,9,11,12]
				Output: 1
				Explanation: The smallest positive integer 1 is missing.

			Constraints:
				1 <= nums.length <= 10^5
				-2^31 <= nums[i] <= 2^31 - 1

		// Not Optimized:
			class Solution {
				public:
				int firstMissingPositive(vector<int>& nums) {
					int n=1;
					while(find(begin(nums), end(nums), n) != nums.end()){
						// nums.erase(nums.begin()+abs(nums.begin()-find(begin(nums), end(nums), n)));			// this statement find the index of n in array & deletes it.
						n++;
					}
					return n;
				}
			};
		
		// Optimized:
			class Solution {
				public:
				int firstMissingPositive(vector<int>& nums) {

					// removing the duplicates values from array nums
					set<int> s (begin(nums), end(nums));
					nums.assign(begin(s), end(s));
					int n=1;

					// delete all elements which are less than 1
					while(nums.size() >= 1 && nums[0] < 1)
						nums.erase(nums.begin());

					// finding the smallest +ve missing integer
					while(nums.size() >= 1 && nums[0] == n){
						nums.erase(nums.begin());
						n++;
					}
					return n;
				}
			};

	601) Sort The Tuples:
		Problem statement
			You are given an array of tuples ‘ARR’ of length ‘N’. All the tuples are of length ‘L’. Sort the tuples in non-decreasing order by the last element of tuples. If the last element of two tuples are equal then the tuple with the smallest index should be placed first.
			Note: The length of all the tuples will be the same.
			Example:
				Input: ‘N’ = 3, ‘L’ = 2,  ‘ARR’ = [(1, 1), (5, 3), (8, 2)]. 
				Output: [(1, 1), (8, 2), (5, 3)].

			The last values of each type are (1, 3, 2). Sorting them in non-decreasing order we get (1, 2, 3). Hence the final result is [(1, 1), (8, 2), (5, 3)].
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^5
				Sum of total number of integers <= 10^5
				1 <= ARR[i].length <= 1000

				Time Limit: 1 sec
			Sample Input 1 :
				2
				4 2
				1 2
				1 1
				3 5
				2 3
				4 3
				1 2 3
				3 2 1
				4 5 6
				3 1 2
				Sample Output 1 :
				1 1 
				1 2 
				2 3 
				3 5 
				3 2 1 
				3 1 2 
				1 2 3 
				4 5 6 
				Explanation Of Sample Input 1 :
				For the first case:
				The last elements of the tuples are [2, 1, 5, 3]. Sorting them in non-decreasing order we get [1, 2, 3, 5]. So, the final output is [ (1, 1), (1, 2), (2, 3), (3, 5) ].

				For the second case:
				The last elements of the tuples are [3, 1, 6, 2]. Sorting them in non-decreasing order we get [1, 2, 3, 6]. So, the final output is [ (3, 2, 1), (3, 1, 2), (1, 2, 3), (4, 5, 6) ].
				Sample Input 2 :
				2
				1 4
				1 4 5 7
				3 4
				7 81 2 10
				1 2 4 1
				90 28 2 19
				Sample Output 2 :
				1 4 5 7
				1 2 4 1
				7 81 2 10
				90 28 2 19

		NOTE: To Reduce a little bit of time Complexity you can use ref variables instead of creating copy of that variables
		eg.	while passing to function pass ref variables not their copies
				bool sortByLastVAL(vector<int>& a, vector<int>& b) 		✔
				bool sortByLastVAL(vector<int> a, vector<int> b) 		❌

		#include <bits/stdc++.h> 
		bool sortByLastVAL(vector<int>& a, vector<int>& b){
			if(a[a.size()-2] == b[b.size()-2])
				return a[a.size()-1]<b[b.size()-1];
			return a[a.size()-2] < b[b.size()-2];
		}

		void sortTuples(vector<vector<int>>&arr){
			for(int i=0; i<arr.size(); i++) arr[i].push_back(i);
			sort(begin(arr), end(arr), sortByLastVAL);
			for(int i=0; i<arr.size(); i++) arr[i].pop_back();
		}
	
	602) Rotate Matrix K times: ❌Pending
		Problem statement
			Given a matrix, clockwise rotate elements in it K times. Rotating the matrix by 90 degrees clockwise will be counted as 1.
			See the sample input.
			Constraints :
				1 <= M <= 10^5
				1 <= N <= 10^5
				1 <= K <= 10^5
			Sample Input :
				3 4
				2 3 8 8 
				8 4 8 1 
				7 6 0 5 
				1
				Sample Output :
				8 2 3 8 
				7 4 8 8 
				6 0 5 1 

		void RotateMatrixByK(int **arr, int row, int col, int k) {
			/*
				*Write your code here. 
				*Don't write main().
				*Don't take input, it is passed as function argument.
				*Don't print output.
				*Taking input and printing output is handled automatically.
			*/
			if(row == 1 || col ==1)
				return ;
			
			while(k--){
				// this all for k=1
				int sr, sc, er, ec;
				sr = sc = 0;
				er=row-1;
				ec=col-1;

				while(sr < er && sc < ec){
					int temp = arr[sr][sc];

					// for start row
					for(int i=sc; i<=ec; i++)
						swap(arr[sr][i], temp);

					sr++;
					// for end col
					for(int i=sr; i<=er; i++)	
						swap(arr[i][ec], temp);
					
					ec--;
					// for end row
					for(int i=ec; i>=sc; i--)
						swap(arr[er][i], temp);

					er--;
					// for start col
					for(int i=er; i>=sr-1; i--)
						swap(arr[i][sc], temp);
					sc++;
				}
			}
		}
	
	603)	Subarray Product Less Than K:
		Problem statement:
			Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.
			Example 1:
				Input: nums = [10,5,2,6], k = 100
				Output: 8
				Explanation: The 8 subarrays that have product less than 100 are:
				[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
				Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

			Example 2:
				Input: nums = [1,2,3], k = 0
				Output: 0
			
			Constraints:
				1 <= nums.length <= 3 * 10^4
				1 <= nums[i] <= 1000
				0 <= k <= 10^6
					
		int speeUp = [](){
			ios_base::sync_with_stdio(0);
			cin.tie(0);
			cout.tie(0);
			return 0;
		}();

		class Solution {
			public:
			int numSubarrayProductLessThanK(vector<int>& nums, int k) {
				int cnt=0;

				for(int i=0; i<nums.size(); i++){
					int prod=1;
					for(int j=i; j<nums.size(); j++){
						prod *= nums[j];
						if(prod < k)
							cnt++;
						else
							break;
					}
				}
				return cnt;
			}
		};
	
	604) Most Cost Efficient Car:
		Problem statement
			You are given the price of ‘Petrol’ cars, the maintenance cost of the car per month, number of kilometers a car runs in one liter, amount of Petrol per liter, and number of kilometers a car can run per month. Similar details are also given for ‘Diesel’ cars.
			Your task is to find which car ( ‘Petrol’ or ‘Diesel’ ) is efficient to use for an exact 6 month period. If your answer is ‘Petrol’ car then print ‘0’, if your answer is ‘Diesel’ car then print ‘1’, if both the cars ( ‘Petrol’ and ‘Diesel’) are efficient then print ‘-1’.
			For example, consider both the cars:

			Price of ‘Petrol’ car = ‘780000’, the maintenance cost of ‘Petrol’ car per month = ‘500’, number of kilometers a ‘Petrol’ car can run in one liter  = ’35’, price of ‘Petrol’ per liter = ‘75’ and number of kilometers a ‘Petrol’ car can run in a month = ‘145’.
			Similar details are given for ‘Diesel’ car, price of ‘Diesel’ car = ‘850000’, the maintenance cost of ‘Diesel’ car per month = ‘1000’, number of kilometers a ‘Diesel’ car can run in a one-liter = ’30’, price of ‘Diesel’ per liter = ‘80’ and number of kilometers a ‘Diesel’ car can run in a month = ‘200’.
			Then the ‘Petrol’ car will be more efficient, so we will print the integer ‘0’.
			Constraints:
				1 <= T <= 10^5
				1 <= priceOfCar, maintenanceCostPerMonth, numberOfkilemeterCarRunInOneLiter, pricePerLiter, numberOfKilometerCarRunInaMonth <= 10^9

				Where ‘T’ is the total number of test cases.
				Time Limit: 1 sec
			Sample Input 1:
				2
				100000 1200 30 60 150
				200000 1300 10 20 120
				80000 1000 20 40 150
				60000 1300 20 100 50
				Sample Output 1:
				0
				1
				Explanation For Sample Input 1:
				In the first test case:

				Cost if we use ‘Petrol’ car = 100000 ( price of ‘Petrol’ car ) + 1200 * 6 ( maintenance cost of ‘Petrol’ car for 6 months ) + 60/30 * 150 * 6 ( cost of ‘Petrol’ for 6 month).
				Total cost = ‘100000+ 7200 + 1800 = 109000’.
				Cost if we use ‘Diesel’ car = 200000 ( price of ‘Diesel’ car ) + 1300 * 6 ( maintenance cost of ‘Diesel’ car for 6 months ) + 20/10 * 120 * 6 ( cost of ‘Diesel’ for 6 month).
				Total cost = ‘200000+ 7800 + 1440 = 209240’.
				The cost of a ‘Diesel’ car (209240) is more than a ‘Petrol’ (109000) car than a ‘Petrol’ car is more cost-efficient, print ‘0’.

				In the second test case:
				Cost if we use ‘Petrol’ car = 80000 ( price of ‘Petrol’ car ) + 1000 * 6 ( maintenance cost of ‘Petrol’ car for 6 months ) + 40/20 * 150 * 6 ( cost of ‘Petrol’ for 6 month).
				Total cost = ‘80000+ 6000 + 1800 = 87800’
				Cost if we use ‘Diesel’ car = 60000 ( price of ‘Diesel’ car ) + 1300 * 6 ( maintenance cost of ‘Diesel’ car for 6 months ) + 100/20 * 50 * 6 ( cost of ‘Diesel’ for 6 month).
				Total cost = ‘60000+ 7800 + 1500 = 69300’
				The cost of ‘Petrol’ car (87800)  is more than ‘Diesel’ (67500) car than ‘Diesel’ car is more cost-efficient, print ‘1’.

				Sample Input 2:
				2
				500000 1100 40 120 200
				200000 1200 20 120 120
				207120 1500 20 40 120
				210000 1000 10 20 130
				Sample Output 2:
				1
				-1
				Explanation For Sample Input 2:
				In the first test case:

				Cost if we use ‘Petrol’ car = 500000 ( price of ‘Petrol’ car ) + 1100 * 6 ( maintenance cost of ‘Petrol’ car for 6 months ) + 120/40 * 200 * 6 ( cost of ‘Petrol’ for 6 month).
				Total cost = ‘500000+ 6600 + 3600 = 510200’.
				Cost if we use ‘Diesel’ car = 200000 ( price of ‘Diesel’ car ) + 1200 * 6 ( maintenance cost of ‘Diesel’ car for 6 months ) + 120/20 * 120 * 6 ( cost of ‘Diesel’ for 6 month).
				Total cost = ‘200000+ 7200 + 4320 = 211520’.
				The cost of a ‘Diesel’ car (211520) is less than a ‘Petrol’ (510200) car so a ‘Diesel’ car is more cost-efficient, print ‘1’.

				In the second test case:
				Cost if we use ‘Petrol’ car = 207120 ( price of ‘Petrol’ car ) + 1500 * 6 ( maintenance cost of ‘Petrol’ car for 6 months ) + 40/20 * 120 * 6 ( cost of ‘Petrol’ for 6 month).
				Total cost = ‘207120 + 9000 + 1440 = 217560’
				Cost if we use ‘Diesel’ car = 210000 ( price of ‘Diesel’ car ) + 1000 * 6 ( maintenance cost of ‘Diesel’ car for 6 months ) + 20/10 * 130 * 6 ( cost of ‘Diesel’ for 6 month).
				Total cost = ‘210000 + 6000 + 1560 = 217560’
				The cost of ‘Petrol’ car (217560)  is the same as ‘Diesel’ (217560) car thus both cars are more cost-efficient, print ‘-1’.

		#include <bits/stdc++.h> 
		/*
		--------------------------- Car class for reference ---------------------------
		
		class Car {
			public:
				int priceOfCar;
				int maintenanceCostPerMonth;
				int numberOfkilometerCarRunInOneLiter;
				int pricePerLiter;
				int numberOfKilometerCarRunInaMonth;

				Car(int priceOfCar, int maintenanceCostPerMonth, int numberOfkilometerCarRunInOneLiter,
					int pricePerLiter, int numberOfKilometerCarRunInaMonth) {
					
					this->priceOfCar = priceOfCar;
					this->maintenanceCostPerMonth = maintenanceCostPerMonth;
					this->numberOfkilometerCarRunInOneLiter = numberOfkilometerCarRunInOneLiter;
					this->numberOfKilometerCarRunInaMonth = numberOfKilometerCarRunInaMonth;
					this->pricePerLiter = pricePerLiter;
					
				}
		};
		*/

		int mostCostEfficientCar(Car petrolCar, Car dieselCar) {
			int totalCostPetrol = petrolCar.priceOfCar + (petrolCar.maintenanceCostPerMonth*6) + (petrolCar.pricePerLiter/petrolCar.numberOfkilometerCarRunInOneLiter) * petrolCar.numberOfKilometerCarRunInaMonth * 6;
			int totalCostDiesel = dieselCar.priceOfCar + (dieselCar.maintenanceCostPerMonth*6) +(dieselCar.pricePerLiter/dieselCar.numberOfkilometerCarRunInOneLiter) * dieselCar.numberOfKilometerCarRunInaMonth * 6;

			if(totalCostPetrol > totalCostDiesel)
				return 1;
			else if(totalCostDiesel > totalCostPetrol)
				return 0;
			else
				return -1;
		}

	605) Count Of 3s (Refer Question 72):
		Problem statement:
			You are given an integer ‘N’. You simply need to find out the number of occurrences of 3 as a digit in the range of numbers from [0, N].
			Note:
				You need to count occurrences at every place of the number.
				For example :
				You are given N = 13, then the number of occurrences of 3 in range [0, 13] = 2 (3, 13), you need to return 2.
			Constraints:
				1 <= T <= 10^2
				0 <= N <= 10^5
				where ‘T’ is the number of test cases and 'N' is the given integer.
				Time Limit: 1 sec

			Sample Input 1:
				2
				13
				24
				Sample Output 1:
				2
				3
				Explanation For Sample Input 1:
				In the first test case, 
				Number of occurrences of 3 in range [0, 13] = 2 (3, 13). Return 2

				In the second test case, 
				Number of occurrences of 3 in range [0, 24] = 3 (3, 13, 23). Return 3
				Sample Input 2:
				2
				10
				33
				Sample Output 2:
				1
				8
				Explanation For Sample Input 2:
				In the first test case, 
				Number of occurrences of 3 in range [0, 10] = 1 (3). Return 1
				In the second test case, 
				Number of occurrences of 3 in range [0, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int countOf3(int x) {
			long long cnt=0;

			int i=0;
			while(i <= x){
				int crntNum = i;

				while(crntNum){
					if(crntNum%10 == 3) cnt++;
					crntNum /= 10;
				}
				i++;
			}
			return cnt;
		}	
	
	606) Return Keypad (Refer Q.441):
		Problem statement
			Given an integer n, using phone keypad find out and return all the possible strings that can be made using digits of input n.
			Note : The order of strings are not important.
			Constraints :
				1 <= n <= 10^6

			Sample Input:
				23
			Sample Output:
				ad
				ae
				af
				bd
				be
				bf
				cd
				ce
				cf

		/***
			You need to save all the strings in the given 2D output array. And return the number of strings(i.e. number of rows filled in output) from the given function.

			Don’t print the strings, just save them in output.
		***/
		#include<bits/stdc++.h>
		using namespace std;

		int keyPad(int n, char output[][100]) {
			map<int, string> mapper = {
				{2,"abc"},
				{3,"def"},
				{4,"ghi"},
				{5,"jkl"},
				{6,"mno"},
				{7,"pqrs"},
				{8,"tuv"},
				{9,"wxyz"}
			};

			string s = to_string(n);
			vector<string> ans;
			string s1 = mapper[s[0] - '0'];
			for(char ch : s1)
				ans.push_back(string(1, ch));

			for(int i = 1; i < s.length(); i++) {
				string s2 = mapper[s[i] - '0'];
				vector<string> temp;
				for(int z = 0; z < ans.size(); z++) {
					for(int traversS2 = 0; traversS2 < s2.size(); traversS2++)
						temp.push_back(ans[z] + s2[traversS2]);
				}
				ans = temp;
			}

			for(int i = 0; i < ans.size(); i++)
				strcpy(output[i], ans[i].c_str()); // Copy string contents to char array

			return ans.size();
		}
	
	607) Highest Occuring Character:
		Problem statement
			For a given a string(str), find and return the highest occurring character.
			Example:
				Input String: "abcdeapapqarr"
				Expected Output: 'a'
				Since 'a' has appeared four times in the string which happens to be the highest frequency character, the answer would be 'a'.
				If there are two characters in the input string with the same frequency, return the character which comes first.
				Consider:Assume all the characters in the given string to be in lowercase always.
			Constraints:
				0 <= N <= 10^6
				Where N is the length of the input string.

			Time Limit: 1 second
			Sample Input 1:
			abdefgbabfba
			Sample Output 1:
			b
			Sample Input 2:
			xy
			Sample Output 2:
			x

		#include<bits/stdc++.h>
		using namespace std;

		char highestOccurringChar(char input[]) {
			map<char, int> F;
			int i=0;
			while(input[i] != '\0')
				F[input[i++]]++;

			int mxN=0;
			char ans;
			for(auto i=F.begin(); i!=F.end(); i++)
				if(i->second > mxN){
					ans = i->first;
					mxN = i->second;
				}
				
			return ans;
		}
	❌Pending 
	608) Binary Search (Recursive):
		Problem statement
			Given an integer sorted array (sorted in increasing order) and an element x, find the x in given array using binary search. Return the index of x.
			Return -1 if x is not present in the given array. Note : If given array size is even, take first mid.
			Input format :
			Line 1 : Array size
			Line 2 : Array elements (separated by space)
			Line 3 : x (element to be searched)
			Sample Input :
				6
				2 3 4 5 6 8 
				5 
				Sample Output:
				3 
				Hint : Use helper function to solve this question.

		// input - input array
		// size - length of input array
		// element - value to be searched
		int binarySearch(int input[], int size, int element) {
		
			int s=0, e=size-1;
			while(s <= e){
				int mid = (s+e)/2;
				
				if(input[mid] == element)
					return mid;
				else if(input[mid] > element)
					e = mid-1;
				else
					s = mid +1;
			}
			return -1;
		}
	
	609) Print 2D Array:
		Problem statement
			Given a 2D integer array with n rows and m columns. Print the 0th row from input n times, 1st row n-1 times…..(n-1)th row will be printed 1 time.
			Sample Input 1:
				3 3
				1 2 3
				4 5 6
				7 8 9
				Sample Output 1 :
				1 2 3
				1 2 3
				1 2 3
				4 5 6
				4 5 6
				7 8 9
	
		#include <iostream>
		#include <bits/stdc++.h>
		using namespace std;

		void print2DArray(int input[][1000], int row, int col) {
			int cnt = row;
			for(int i=0; i<row; i++){
				vector<int> temp;
				int tempCnt=cnt--;
				for(int j=0; j<col; j++)
					temp.push_back(input[i][j]);

				while(tempCnt){
					for(int a=0; a<temp.size(); a++)
						cout<<temp[a]<<" ";
					cout<<"\n";
					tempCnt--;
				}
			}
		}

	610) Min Value:
		Problem statement:
			You are given two integers, ’A’ and ‘B’.
			Your task is to find the integer ‘C’ which does not contain any leading zeroes, has at least ‘A’ digits and it must be divisible by ‘B’.
			If there are multiple possible solutions, print the smallest one.

			For Example:
				Let's say, 'A' = 2 and 'B' = 5,
				Then all the multiples of '5' are:- 5, 10, 15, 20...
				The smallest number which has '2' digits is 10.
				Hence the answer is 10.
			Constraints :
			1 <= T <= 10
			1 <= A < 18
			1 <= B <= 10^A -1

			Time Limit: 1 sec
			Sample Input 1 :
			2
			2 99
			4 55
			Sample Output 1 :
			99
			1045
			Sample Input 2 :
			2
			5 3
			1 1
			Sample Output 2 :
			10002
			1

		// Not Optimized:
			#include <bits/stdc++.h> 
			long long minValue(int &a, long long &b) {
				long long val = b;

				do {
					string s = to_string(b);
					if(s.size() >= a)
						return b;
					b += val;
				} while(1);
			}

			//or
				#include <bits/stdc++.h> 
				long long minValue(int &a, long long &b) {
					long long ans = b;

					while(1){
					int n = (int)log10(b) + 1;
					if(n == a)
						return b;
					b += ans;
					}
				}

	611) Vowels:
		Problem statement
			Ninja has been studying vowels recently. The vowels are 'a', 'e', I 'o', and 'u,' as we all know. So his teacher Hathori has given him a homework assignment in which he must divide a given string 'S' of length 'N' into two non-empty parts. But these parts must satisfy the equality property, that is, to have the same value of the sum of counts of ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’. Because the ninja is currently preoccupied with his life, he requests your assistance. If this string can be divided into two non-empty parts that satisfy the above criteria, you must answer 'Yes' or 'No.'
			For example:
			Let’s say S = ‘xayyqez’.
			There are multiple ways in which we can divide all the characters of string ‘S’ into two parts such that each part has the same number of vowels. Some of them are {‘a’, ‘xyyqez’}, {‘axyy’, ‘qez’} and many more. So the answer for this case is ‘Yes’.
			Constraints -
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^5
				Time Limit: 1 sec

			Sample Input-1
				2
				xayyqez
				ssty
				Sample Output-1
				Yes
				Yes
				Explanation for Sample Input 1:
				For test case 1:    
				There are multiple ways in which we can divide all the characters of string ‘S’ into two parts such that each part has the same number of vowels. Some of them are {‘a’, ‘xyyqez’}, {‘axyy’, ‘qez’} and many more. So the answer for this case is ‘Yes’.

				For test case 2:
				There are no vowels in the string, so we can divide it into two parts in any of the possible ways. So the answer for this case is ‘Yes’.
				Sample Input -2
				2
				aae
				abeec
				Sample Output -2
				No
				No

		#include <bits/stdc++.h> 
		string vowels(string s) {
			map<char, int> F;
			for(char ch: s)
				F[ch]++;

			int sum = F['a'] + F['e'] + F['i'] + F['o'] + F['u'];

			if(sum&1)
				return "No";
			return "Yes";

			// return (((F['a'] + F['e'] + F['i'] + F['o'] + F['u']) & 1) == 0)? "Yes" : "No" ;
		}
		
		// or
			#include <bits/stdc++.h> 
			string vowels(string s) {
				int vowelCnt=0;

				for(char ch: s)
					if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
						vowelCnt++;

				if(vowelCnt&1)				// if odd then we can't distribute vowels into 2 groups equally.
					return "No";
				return "Yes";
			}

	612) Length of Longest Subarray With at Most K Frequency:
		Problem statement:
			You are given an integer array nums and an integer k.
			The frequency of an element x is the number of times it occurs in an array.
			An array is called good if the frequency of each element in this array is less than or equal to k.
			Return the length of the longest good subarray of nums.
			A subarray is a contiguous non-empty sequence of elements within an array.		

			Example 1:
				Input: nums = [1,2,3,1,2,3,1,2], k = 2
				Output: 6
				Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
				It can be shown that there are no good subarrays with length more than 6.
			
			Example 2:
				Input: nums = [1,2,1,2,1,2,1,2], k = 1
				Output: 2
				Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
				It can be shown that there are no good subarrays with length more than 2.

			Example 3:
				Input: nums = [5,5,5,5,5,5,5], k = 4
				Output: 4
				Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.
				It can be shown that there are no good subarrays with length more than 4.
			
			Constraints:
				1 <= nums.length <= 10^5
				1 <= nums[i] <= 10^9
				1 <= k <= nums.length

		// Not Optimized:
			class Solution {
				public:
				int maxSubarrayLength(vector<int>& nums, int k) {
					int mxLen=0;
					for(int i=0; i<nums.size(); i++){
						map<int, int> F;
						int crntLen=0;
						for(int j=i; j<nums.size(); j++){
							F[nums[j]]++;
							if(F[nums[j]] > k)
								break;
							crntLen++;
						}
						mxLen = max(crntLen, mxLen);
					}
					return mxLen;
				}
			};
		
		// Optimized:
			int speedUp = []{
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);
				return 0;
			}();

			class Solution {
				public:
				int maxSubarrayLength(vector<int>& nums, int k) {
					int mxLen=0, crntLen=0, sIndex=0;
					map<int, int> F;
					
					for(int l=0, r=0; r<nums.size(); r++){
						F[nums[r]]++;

						if(F[nums[r]] > k){

							while(F[nums[l]] != F[nums[r]]){
								F[nums[l]]--;
								l++;
							}
							
							F[nums[l]]--;
							l++;
						}
						mxLen = max(mxLen, r-l+1);
					}
					return mxLen;
				}
			};
	
	613) The Ides of March:
		Problem statement:
			Julius Caesar was warned by a soothsayer to be wary of the ides of March — namely, the 15-th of March.
			Today is the N-th day of March. Your task is to tell Caesar whether it is the ides of March, so that he can take extra safety precautions if necessary.
			Input Format
				The only line of input will contain a single integer N, today's date in March.
			Output Format
				Print "Yes" if today is the ides of March, and "No" otherwise (without quotes).
			Each letter of the output may be printed in either uppercase or lowercase, i.e, the strings NO, no, nO, and No will all be treated as equivalent.

			Constraints
				1 ≤ N ≤ 15
			Sample 1:
			Input
			14
			Output
			No
			Explanation:
			The 
			14
			14-th of March is not the ides of March, so Caesar doesn't need to take any extra care.

			Sample 2:
			Input
			15
			Output
			Yes
			Explanation:
			15
			15-th is the ides of March, so Caesar should take extra safety precautions.

		#include <bits/stdc++.h>
		using namespace std;
		int main() {
			int date;
			cin >> date;

			if (date == 15)
				cout << "Yes";
			else
				cout << "NO";
			return 0;
		}

	614) Extreme Basketball:
		Problem statement:
			Alice and Bob are playing a game of basketball against each other, one-versus-one.Currently, Alice has A points, and Bob has B points.
			Each shot of a player can score either 2 or 3 points.

			Alice isn't just out to win - she wants to win in dominant fashion.
			Alice believes that her win is dominant if she ends the game with at least 10 points more than Bob.
			If Alice is able to prevent Bob from scoring any more points, what's the minimum number of shots she further needs to get a dominant victory?

			Input Format
				The first line of input will contain a single integer T, denoting the number of test cases.
				Each test case consists of a single line of input, containing two space-separated integers A and B — the initial scores of Alice and Bob.
			Output Format
				For each test case, output on a new line the minimum number of shots Alice needs to win a dominant victory.

			Constraints
				1 ≤ T ≤ 10^4
				2 ≤ A,B ≤ 100
			Sample 1:
			Input
			3
			11 2
			100 23
			3 5
			Output
			1
			0
			4
			Explanation:
			Test case 1: Alice can shoot a single 2 2-pointer and move to 13 points, which is 11 more than Bob's score of 2 - hence earning her a dominant victory.
			Test case 2: Alice has way more points than Bob already, so no more shots are needed.
			Test case 3: Alice can shoot 4 three-pointers, bringing her score to 15.

		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int T;
			cin>>T;
			
			while(T--){
				int a, b;
				cin>>a>>b;
				
				int OpsCnt=0, var = a;
				int res = b + 10;
				while(a < res){
					OpsCnt++;
					a += 3;
				}
				cout<<OpsCnt<<"\n";
			}
			return 0;
		}

	615) Queue Using Two Stacks
		Problem statement
			You will be given ‘Q’ queries. You need to implement a queue using two stacks according to those queries. Each query will belong to one of these three types:
			1 ‘X’: Enqueue element ‘X’  into the end of the nth queue. Returns true after the element is enqueued.
			2: Dequeue the element at the front of the nth queue. Returns -1 if the queue is empty, otherwise, returns the dequeued element.
			Note:
			Enqueue means adding an element to the end of the queue, while Dequeue means removing the element from the front of the queue.
			Constraints:
				1 <= Q <= 10^5 
				1 <= P <= 2
				1 <= X <= 10^5

			Time limit: 1 sec
			Sample Input 1:
				7
				1 2 
				1 3 
				2 
				1 4 
				1 6 
				1 7 
				2
				Sample Output 1:
				True 
				True
				2
				True
				True
				True
				3
				Explanation of Sample Output 1:
				For this input, we have the number of queries, 'Q' = 7.

				Operations performed on the queue are as follows:

				push(2): Push element ‘2’ into the queue. This returns true.
				push(3): Push element ‘3’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 2.
				push(4): Push element ‘4’ into the queue. This returns true.
				push(6): Push element ‘6’ into the queue. This returns true.
				push(7): Push element ‘7’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 3.
				Sample Input 2:
				7
				1 11 
				1 51 
				1 26 
				2 
				1 6
				2
				2 
				Sample Output 2:
				True
				True
				True
				11
				True
				51
				26
				Explanation for Sample Output 2:
				For this input, we have the number of queries, Q = 7.
				Operations performed on the queue are as follows:
				push(11): Push element ‘11’ into the queue. This returns true.
				push(51): Push element ‘51’ into the queue. This returns true.
				push(26): Push element ‘26’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 11.
				push(6): Push element ‘6’ into the queue. This returns true.
				pop(): Pop the top element from the queue. This returns 51.
				pop(): Pop the top element from the queue. This returns 26.

		#include <bits/stdc++.h> 
		class Queue{
			// Stacks to be used in the operations.
			stack<int> st1, st2;
			
			public:
			// Enqueues 'X' into the queue. Returns true after enqueuing.
			bool enqueue(int X){
				st1.push(X);
				return 1;
			}

			/*
				Dequeues top element from queue. Returns -1 if the queue is empty, 
				otherwise returns the popped element.
			*/
			int dequeue(){
				if(st1.empty() && st2.empty())
					return -1;

				if(st2.empty()){
					while(!st1.empty()){
						st2.push(st1.top());
						st1.pop();
					}
				}

				int val = st2.top();
				st2.pop();
				return val;
			}
		};
		
	616) Median of Three:
		int numberOfElement(int n, vector<int> &v) {
			int elementCnt=0;
			if(n==1)
				return 0;
			
			for(int i=0; i<n; i++){
				int median;
				vector<int> mid;
				if(i == 0 || i == n-1){
					if(i==0){
						mid.push_back(0);
						mid.push_back(v[i]);
						mid.push_back(v[i+1]);
						sort(begin(mid), end(mid));
						median = mid[1];
					}else{
						mid.push_back(0);
						mid.push_back(v[i-1]);
						mid.push_back(v[i]);
						sort(begin(mid), end(mid));
						median = mid[1];
					}
				}else{
					mid.push_back(v[i-1]);
					mid.push_back(v[i]);
					mid.push_back(v[i+1]);
					sort(begin(mid), end(mid));
					median = mid[1];
				}
				
				if(median == v[i])
					elementCnt++;
			}
			return elementCnt;
		}

	617) Count Subarrays Where Max Element Appears at Least K Times:
		Problem Statement:
			You are given an integer array nums and a positive integer k.
			Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.
			A subarray is a contiguous sequence of elements within an array.		

			Example 1:
				Input: nums = [1,3,2,3,3], k = 2
				Output: 6
				Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].

			Example 2:
				Input: nums = [1,4,2,1], k = 3
				Output: 0
				Explanation: No subarray contains the element 4 at least 3 times.

			Constraints:
				1 <= nums.length <= 10^5
				1 <= nums[i] <= 10^6
				1 <= k <= 10^5

		// Not Optimized:
			class Solution {
				public:
				long long countSubarrays(vector<int>& nums, int k) {
					long long mxCnt=0;

					if(k > nums.size())
						return mxCnt;

					int mxEle = *max_element(nums.begin(), nums.end());

					for(int i=0; i <= nums.size()-k; i++){
						map<int, int> cntHolder;
						for(int j=i; j<nums.size(); j++){
							cntHolder[nums[j]]++;
							if(cntHolder[mxEle] >= k)
								mxCnt++;
						}
					}
					return mxCnt;
				}
			};

			// Little bit optimized:
				class Solution {
					public:
					long long countSubarrays(vector<int>& nums, int k) {
						long long mxCnt=0;

						if(k > nums.size())
							return mxCnt;

						int mxEle = *max_element(nums.begin(), nums.end());

						for(int i=0; i <= nums.size()-k; i++){
							map<int, int> cntHolder;

							// generating window of min size k
							int iterator=k, index = i;
							while(index < nums.size() && iterator--)
								cntHolder[nums[index++]]++;
							
							if(cntHolder[mxEle] >= k)
								mxCnt++;

							for(int j=i+k; j<nums.size(); j++){
								cntHolder[nums[j]]++;
								if(cntHolder[mxEle] >= k)
									mxCnt++;
							}
						}
						return mxCnt;
					}
				};

		// Little more optimized (counting the rest subarray that definitely holds mxEle at least k times):
			class Solution {
				public:
				long long countSubarrays(vector<int>& nums, int k) {
					long long mxCnt=0;

					if(k > nums.size())
						return mxCnt;

					int mxEle = *max_element(nums.begin(), nums.end());

					for(int i=0; i <= nums.size()-k; i++){
						map<int, int> cntHolder;

						// generating window of min size k
						int iterator=k, index = i;
						while(iterator--)
							cntHolder[nums[index++]]++;
						
						if(cntHolder[mxEle] == k){
							mxCnt += (nums.size() - index) + 1;
							continue;
						}

						for(int j=i+k; j<nums.size(); j++){
							cntHolder[nums[j]]++;
							if(cntHolder[mxEle] >= k){
								mxCnt += (nums.size() - j);
								break;
							}
						}
					}
					return mxCnt;
				}
			};

		// Optimized:
			int speedUp = [](){
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);
				return 0;
			}();

			class Solution {
				public:
				long long countSubarrays(vector<int>& nums, int k) {
					long long res=0;

					int mx = *max_element(nums.begin(), nums.end());
					int r=0, l=0, n = nums.size(), cnt=0;

					while(r < n){
						if(nums[r] == mx) cnt++;
						while(cnt == k){
							if(nums[l] == mx) cnt--;

							l++;
							res += (n - r);             // this line says add all rest subarray after index r (which is no.of elements remaining after r index)
						}
						r++;
					}
					return res;
				}
			};

	618) Day 25 : Queue Using Stack:
		Problem statement
			Implement a queue data structure which follows FIFO(First In First Out) property, using only the instances of the stack data structure.
			Note:
			1. To implement means you need to complete some predefined functions, which are supported by a normal queue such that it can efficiently handle the given input queries which are defined below.
			2. The implemented queue must support the following operations of a normal queue:
			a. enQueue(data) : This function should take one argument of type integer and place the integer to the back of the queue.
			b. deQueue(): This function should remove an integer from the front of the queue and also return that integer. If the queue is empty, it should return -1.
			c. peek(): This function returns the element present in the front of the queue. If the queue is empty, it should return -1.
			d. isEmpty(): This function should return true if the queue is empty and false otherwise.
			3. You will be given q queries of 4 types:
			a. 1 val - For this type of query, you need to insert the integer val to the back of the queue.
			b. 2 - For this type of query, you need to remove the element from the front of the queue, and also return it.
			c. 3 - For this type of query, you need to return the element present at the front of the queue(No need to remove it from the queue).
			d. 4 - For this type of query, you need to return true if the queue is empty and false otherwise.
			4. For every query of type:
			a. 1, you do not need to return anything.
			b. 2, return the integer being deQueued from the queue.
			c. 3, return the integer present in the front of the queue.
			d. 4, return “true” if the queue is empty, “false” otherwise.
			Example
			Operations: 
			1 5
			1 10
			2
			3
			4

			Enqueue operation 1 5: We insert 5 at the back of the queue.
			Queue: [5]

			Enqueue operation 1 10: We insert 10 at the back of the queue.
			Queue: [5, 10]

			Dequeue operation 2: We remove the element from the front of the queue, which is 5, and print it.
			Output: 5
			Queue: [10]

			Peek operation 3: We return the element present at the front of the queue, which is 10, without removing it.
			Output: 10
			Queue: [10]

			IsEmpty operation 4: We check if the queue is empty.
			Output: False
			Queue: [10]
			Detailed explanation ( Input/output format, Notes, Images )
			Sample Input 1:
			7
			1 1
			1 2
			1 3
			2
			2
			2
			3
			Sample Output 1:
			1 
			2 
			3
			-1
			Explanation of the Sample Output 1:
			Here we have seven queries in total.

			Query 1: Insert 1 to the back of the queue. The queue: 1 
			Query 2: Insert 2 to the back of the queue. The queue: 1 2
			Query 3: Insert 3 to the back of the queue. The queue: 1 2 3
			Query 4: Remove element from the front:  The queue: 2 3
			Query 5: Remove the element from the front:  The queue: 2 
			Query 6: Remove the element from the front:  The queue : 
			Query 7: As the queue is empty, returned -1.
			Sample Input 2:
			2
			1 2
			4
			Sample Output 2:
			false
			Explanation of the Sample Output 2:
			Here we have two queries in total.

			Query 1: Insert 2 to the back of the queue. The queue: 2 
			Query 2: IsEmpty() function returns 'false' as currently the queue is not empty.
			Constraints:
			1 <= Q <= 1000
			1 <= type <= 4
			1<= data <= 10^9 

			Where 'type' represents the type of query and 'data' represents the integer to be enQueued. 
			Time limit: 1 sec

		// #include<bits/stdc++.h>
		class Queue {    
			stack<int> st1, st2;

			public:
			Queue() {}

			void enQueue(int val) {
				st1.push(val);
			}

			int deQueue() {
				if(st1.empty() && st2.empty())
					return -1;

				if(st2.empty()){
					while(!st1.empty()){
						st2.push(st1.top());
						st1.pop();
					}
				}

				int poped = st2.top();
				st2.pop();
				return poped;
			}

			int peek() {
				if(st1.empty() && st2.empty())
					return -1;

				if(st2.empty()){
					while(!st1.empty()){
						st2.push(st1.top());
						st1.pop();
					}
				}
				return st2.top();
			}

			bool isEmpty() {
				if(st1.empty() && st2.empty())
					return 1;
				return 0;
			}
		};

	619) Minimum Difference in an Array (Same Q.1):
		Problem statement
			Given an array of integers, print the minimum of the absolute difference of all possible pairs of elements.

			Example :
			N = 5
			ARR = [ 3, -6, 7, -7, 0 ]
			Out of all pairs, (-7,-6) have a difference of ‘1’, and no other pair has less difference. So ‘ANS’ is ‘1’.    
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints :
			1 <= T <= 10
			2 <= N  <= 10^5
			-10^8 <= ARR[i] <= 10^8
			Sum of N <= 10^5

			Time Limit: 1 sec
			Sample Input 1 :
			2
			4
			1 8 3 10   
			2
			5 5
			Sample Output 1 :
			2
			0
			Explanation Of Sample Input 1 :
			For test case 1, 
			Out of all pairs (1,3) and (8,10) have the minimum difference ‘2’ so the answer is ‘2’.
			For test case 2,
			There is only one possible pair (5,5) so the answer is ‘0’.
			Sample Input 2 :
			2
			3
			8 1 8
			2
			-3 3
			Sample Output 2 :
			0
			6

		// Not Optimized:
			#include <bits/stdc++.h> 
			int minDiff(int n, vector < int > arr) {
				int minAbsDiff=INT_MAX;
				for(int i=0; i<n-1; i++)
					for(int j=i+1; j<n; j++)
					minAbsDiff = min(minAbsDiff, abs(arr[i] - arr[j]));
				
				return minAbsDiff;
			}
		
		// Optimized:
			#include <bits/stdc++.h> 
			int minDiff(int n, vector < int > arr) {
				sort(begin(arr), end(arr));
				
				int minAbsDiff=INT_MAX;
				for(int i=0; i<n-1; i++)
					minAbsDiff = min(minAbsDiff, abs(arr[i] - arr[i+1]));
				
				return minAbsDiff;
			}
	
	620) Quality Array:
		Problem statement
			You are given an array ‘A’ containing ‘N’ positive integers. You consider an integer is good if at least one even number divides it and at least one odd number greater than 1 divides it.
			If all the elements of an array are good integers, then the array is declared a quality array. You can remove some (possibly 0) elements to make the given array quality.
			Your task is to find the minimum number of elements to be removed from the given array to make it a quality array. An empty array is a quality array.
			Example :
			‘N’ = 5, ‘A’ = [3, 7, 6].
			Only the third element of the given array is good. As 6 is divisible by 2 and 3. So we can remove the first and the second elements.
			Hence, the answer is 2.
			Constraints :
				1 ≤ T ≤ 10
				1 ≤ N ≤ 10^5
				2 ≤ A[i] ≤ 100
				It’s guaranteed that sum of ‘N’ overall test cases doesn’t exceed 10^5.
				Time limit: 1 sec

			Sample Input 1 :
			2
			5
			6 6 9 5 2 
			4
			7 5 2 6 
			Sample Output 1 :
			3
			3
			Explanation For Sample Input 1 :
			For test case 1: 
			‘A’ = [6, 6, 9, 5, 2]. Only 6 is a good integer from the given array because it has both even and odd divisors. Every other integer either lacks an even divisor or an odd divisor. So we need to remove 3 elements.
			Hence, the answer is 3.

			For test case 2:
			Like the previous case, only 6 is a good integer from the given array, and we must remove every other element.
			Hence, the answer is 3.
			Sample Input 2 :
			2
			4
			5 7 3 9 
			3
			10 2 3     
			Sample Output 2 :
			4
			2

		int makeQualityArray(vector<int> &a) {
			int good_Int_Cnt=0;

			for(int i: a){
				
				int flag1=0, flag2=0;

				// checking for even divisibility
				for(int z=2; z <= (i/2); z += 2){
					if(i % z == 0){
						flag1 = 1;
						break;
					}
				}

				// checking for odd divisibility
				for(int z=3; z <= (i/2); z += 2){
					if(i % z == 0){
						flag2 = 1;
						break;
					}
				}

				if(flag1 && flag2)
					good_Int_Cnt++;
			}
			
			int n = a.size();
			// elements to be removed is size - good_Int_Cnt
			return abs(good_Int_Cnt - n);
		}

	621) Count Prefix and Suffix Pairs I:
		Problem statement:
			You are given a 0-indexed string array words.
			Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:
			isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.
			For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is false.
			Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

			Example 1:
				Input: words = ["a","aba","ababa","aa"]
				Output: 4
				Explanation: In this example, the counted index pairs are:
				i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
				i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is true.
				i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
				i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is true.
				Therefore, the answer is 4.

			Example 2:
				Input: words = ["pa","papa","ma","mama"]
				Output: 2
				Explanation: In this example, the counted index pairs are:
				i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is true.
				i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is true.
				Therefore, the answer is 2.  

			Example 3:
				Input: words = ["abab","ab"]
				Output: 0
				Explanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix("abab", "ab") is false.
				Therefore, the answer is 0.

			Constraints:
				1 <= words.length <= 50
				1 <= words[i].length <= 10
				words[i] consists only of lowercase English letters.

		int SpeedUp = [](){
			ios_base::sync_with_stdio(0);
			cin.tie(0);
			cout.tie(0);
			return 0;
			}();

		class Solution {
			public:
			bool isPrefixAndSuffix(string &s1, string &s2){
				if(s1.size() > s2.size())
					return 0;

				// going for prefix
				for(int i=0; i<s1.size(); i++)
					if(s1[i] != s2[i])
						return 0;
				
				// going for suffix
				int index = 1;
				for(int i=s1.size()-1; i >=0; i--)
					if(s1[i] != s2[s2.size()-index++])
						return 0;

				return 1;
			}
			int countPrefixSuffixPairs(vector<string>& words) {
				int total=0;

				for(int i=0; i<words.size()-1; i++)
					for(int j=i+1; j<words.size(); j++)
						if(isPrefixAndSuffix(words[i], words[j]))
							total++;
						
				return total;
			}
		};

	622) Find the Length of the Longest Common Prefix:
		Problem statement:
			You are given two arrays with positive integers arr1 and arr2.
			A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.
			A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have a common prefix 565 while 1223 and 43456 do not have a common prefix.
			You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.
			Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.		
			Example 1:
				Input: arr1 = [1,10,100], arr2 = [1000]
				Output: 3
				Explanation: There are 3 pairs (arr1[i], arr2[j]):
				- The longest common prefix of (1, 1000) is 1.
				- The longest common prefix of (10, 1000) is 10.
				- The longest common prefix of (100, 1000) is 100.
				The longest common prefix is 100 with a length of 3.

			Example 2:
				Input: arr1 = [1,2,3], arr2 = [4,4,4]
				Output: 0
				Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.
				Note that common prefixes between elements of the same array do not count.

			Constraints:
				1 <= arr1.length, arr2.length <= 5 * 10^4
				1 <= arr1[i], arr2[i] <= 10^8
		
		// Not optimized:
			class Solution {
				public:
				int checkNewLen(int n1, int n2){
					string s1 = to_string(n1);
					string s2 = to_string(n2);

					int len=0, i=0, j=0;

					while(i < s1.size() && j < s2.size()){
						if(s1[i++] != s2[j++])
							break;
						len++;
					}

					return len;
				}
				int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {
					int mxLen = 0;

					for(int i=0; i<arr1.size(); i++)
						for(int j=0; j<arr2.size(); j++)
							mxLen = max(mxLen, checkNewLen(arr1[i], arr2[j]));
					return mxLen;
				}
			};
	
		// Optimized:
			❌Pending

	623) Minimum element in BST:
		Problem statement:
			Given the root of a Binary Search Tree. The task is to find the minimum valued element in this given BST.
			Example 1:
			Input:
			   	   5
				 /    \
				4      6
			    /        \
			   3          7
  			 /
			1
			Output: 1
			
			Example 2:
				Input:
					9
					 \
					  10
					    \
						11
				Output: 9
			Your Task:
				The task is to complete the function minValue() which takes root as the argument and returns the minimum element of BST. If the tree is empty, there is no minimum element, so return -1 in that case.

			Expected Time Complexity: O(Height of the BST)
			Expected Auxiliary Space: O(1).

			Constraints:
				0 <= n <= 10^4


		/* struct Node {
			int data;
			struct Node* left;
			struct Node* right;
		};
		// Utility function to create a new Tree Node
		Node* newNode(int val) {
			Node* temp = new Node;
			temp->data = val;
			temp->left = NULL;
			temp->right = NULL;

			return temp;
		}
		*/

		class Solution {
			public:
			int minValue(Node* root) {
				if(root == NULL)
					return -1;
					
				if(root->left == NULL)
					return root->data;
				
				return minValue(root->left);
			}
		};
	
	624) Subarrays with K Different Integers:
		Problem statement:
			Given an integer array nums and an integer k, return the number of good subarrays of nums.
			A good array is an array where the number of different integers in that array is exactly k.
			For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.
			A subarray is a contiguous part of an array.

			Example 1:
				Input: nums = [1,2,1,2,3], k = 2
				Output: 7
				Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]

			Example 2:
				Input: nums = [1,2,1,3,4], k = 3
				Output: 3
				Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
	
			Constraints:
				1 <= nums.length <= 2 * 10^4
				1 <= nums[i], k <= nums.length

		// Not Optimized:
			class Solution {
				public:
				int subarraysWithKDistinct(vector<int>& nums, int k) {
					int goodCnt=0;

					for(int i=0; i<nums.size(); i++){
						map<int, int> F;
						for(int j=i; j<nums.size(); j++){
							F[nums[j]]++;
							if(F.size() == k)
								goodCnt++;
							else if(F.size() > k)
								break;
						}
					}
					return goodCnt;
				}
			};

		// Optimized:
			❌Pending

	625) Three in one:
		Problem statement
			Given a sequence of queries of insertion and deletion from 3 stacks, you need to implement three stacks using a single array such that the size of the array doesn’t exceed the number of queries.
			In each query, the input is of two types :
			Id 0: where ‘id’ is the index of the stack ( out of the three ) in which we have to work on, 0 means we have to pop a top element from the stack.
			Id 1 ele: where ‘id’ is the index of the stack ( out of the three ) in which we have to work on, 1 means we have to push ‘ele’ element on top of the stack.
			After each pop operation, you have to print the element which is removed.
			Note: If a pop operation is used in an empty stack nothing happens to the stack, but you have to print -1.
			Constraints :
				1 <= T <= 3
				0 <= Q, ele  <= 10^5
				0 <= id <= 2  , denoting one of the three stack
				Time Limit : 1 sec
			Sample Input 1 :
				1
				6
				0 0
				0 1 5
				0 1 4
				1 1 9
				1 0
				0 0
				Sample Output 1 :
				-1
				9
				4
				Explanation for Sample Input 1 :
				Initially stack_0= {} , stack_1 ={} , stack_2={} , i.e. all are empty

				1st query: pop  from stack 0
				Since stack 0 is empty : print -1
				stack_0= {} , stack_1 ={} , stack_2={}

				2st query: push 5 in stack 0
				stack_0= {5} , stack_1 ={} , stack_2={}

				3st query: push 4 in stack 0
				stack_0= {5,4} , stack_1 ={} , stack_2={}

				4st query: push 9 in stack 1
				stack_0= {5,4} , stack_1 ={9} , stack_2={}

				5st query: pop from stack 1
				Tos of stack_1 is 9 : print 9
				stack_0= {5,4} , stack_1 ={)  , stack_2={}

				6st query: pop from stack 0
				Tos of stack_0 is 4 : print 4
				stack_0= {5} , stack_1 ={} , stack_2={}

				Therefore the output is: -1, 9, 4
				Sample Input 2 :
				1
				3
				0 0
				1 0
				2 0
				Sample Output 2 :
				-1
				-1
				-1

		#include <bits/stdc++.h> 
		void solve( int q, vector<vector<int>> queries ) {
			stack<int> st1, st2, st3;
			for(int i=0; i<q; i++){
				if(queries[i][0] == 0){
					if(queries[i][1] == 0){
						if(st1.empty()){
							cout<<"-1"<<"\n";
							continue;
						}
						cout<<st1.top()<<"\n";
						st1.pop();
					}else{
						st1.push(queries[i][2]);
					}
				}else if(queries[i][0] == 1){
					if(queries[i][1] == 0){
						if(st2.empty()){
							cout<<"-1"<<"\n";
							continue;
						}
						cout<<st2.top()<<"\n";
						st2.pop();
					}else{
						st2.push(queries[i][2]);
					}
				}else{
					if(queries[i][1] == 0){
						if(st3.empty()){
							cout<<"-1"<<"\n";
							continue;
						}
						cout<<st3.top()<<"\n";
						st3.pop();
					}else{
						st3.push(queries[i][2]);
					}
				}
			}
		}

		// using array: ❌Pending
			/*
				Time Complexity: O(Q^2)
				Space Complexity: O(Q)
				where Q is number of Queries
			*/

			int findEmptyIndex(int q,int *arr){	
				for(int i=0;i<q;i++){
					if( arr[i] == -1 ){
						return i;
					}
				}
				return -1;
			}

			void solve( int q, vector<vector<int>> query ) {
				
				int tos[3]= {-1,-1,-1}; // denotes position of top of stack of 3 stacks
				int arr[q] , prev[q];
				fill(arr,arr+q,-1);
				
				for(int i=0;i<q;i++) prev[i]=i-1;
				
				for(auto x:query){
					int id= x[0] ,t= x[1];
					if(t==0){	// pop
						
						if(tos[id]==-1){
							cout<<"-1\n";
						}
						else{
							int cur= tos[id];
							cout<< arr[cur] <<"\n";
							arr[cur]=-1;
							tos[id]= prev[cur];
						}
						
					}else{	// push
						int nxt = findEmptyIndex(q, arr); 
						int cur= tos[id];
						
						prev[nxt]= cur;
						tos[id]=nxt;
						arr[nxt]= x[2];
					}
				}				
			}

	626) Decryption:
		Problem statement
			You are given a string, 'MESSAGE'. The receiver of this ‘MESSAGE’ has a set of instructions on how to decrypt the message. In order to decrypt the message, we need to perform some rotation operations on the string.
			These rotations can either be left rotations or right rotations. The set of instructions contains information about which type of rotation is to be performed and how many times. Your task is to determine the decrypted message.
			Note:
			Performing a 'left rotation' means deleting the first character of the string and appending it to the end of the string.
			Performing a 'right rotation' means deleting the last character of the string and appending it to the beginning of the string.
			For example, if we perform a left rotation on the string “coding”, it will become “odingc”. If we perform a right rotation on the string “ninja”, it will become “aninj”.
			Constraints:
				1 <= T <= 10
				1 <= |MESSAGE| <= 500
				1 <= N <= 1000
				N is always even
				Time Limit: 1sec

			Sample Input 1:
				1
				abcde 
				4
				-1 2
				1 1
				-1 2
				-1 1
				Sample Output 1:
				eabcd
				Explanation for sample input 1:
				Initially, the given string is “abcde”. After performing the left rotation on it two times, we will get “cdeab”. After performing the right rotation on this string once, we will get “bcdea”. Next time, the string will become “deabc”. And finally, the string will become “eabcd”. Hence, we print the final result.
				Sample Input 2:
				1
				babb 
				3
				-1 1
				1 2
				1 3
				Sample Output 2:
				babb
				Explanation for sample input 2:
				Initially, the given string is “babb”. After performing the left rotation on it once, we will get “abbb”. After performing the right rotation on this string two times, we will get “bbab”. And finally, the string will become “babb”. Hence, we print the final result.

		// Not Optimized:
			#include <bits/stdc++.h> 
			string decrypt(string& message, vector<vector<int>>& operations) {
				for(int i=0; i<operations.size(); i++){
					operations[i][1] %= message.size();

					if(operations[i][0] == -1){
						// on left side rotation which is default one
						rotate(begin(message), message.begin()+operations[i][1], message.end());
					}else{
						// on right side rotation
						rotate(begin(message), message.begin()+(message.size() - operations[i][1]), message.end());			
					}
				}
				return message;
			}

		// Optimized:
			#include <bits/stdc++.h> 
			string decrypt(string& message, vector<vector<int>>& operations) {
				for(int i=0; i<operations.size(); i++){
					operations[i][1] %= message.size();

					if(operations[i][0] == -1){
						// on left side rotation which is default one
						message = message.substr(operations[i][1]) + message.substr(0, operations[i][1]);
					}else{
						// on right side rotation
						message = message.substr(message.size()-operations[i][1]) + message.substr(0, message.size()-operations[i][1]);
					}
				}
				return message;
			}
	
	#LeetCode BiweeklyContest-127:
		627) Shortest Subarray With OR at Least K I:
			Problem statement:
				You are given an array nums of non-negative integers and an integer k.
				An array is called special if the bitwise OR of all of its elements is at least k.
				Return the length of the shortest special non-empty subarray
				of nums, or return -1 if no special subarray exists.

				Example 1:
					Input: nums = [1,2,3], k = 2
					Output: 1
					Explanation:
					The subarray [3] has OR value of 3. Hence, we return 1.

				Example 2:
					Input: nums = [2,1,8], k = 10
					Output: 3
					Explanation:
					The subarray [2,1,8] has OR value of 11. Hence, we return 3.

				Example 3:
					Input: nums = [1,2], k = 0
					Output: 1
					Explanation:
					The subarray [1] has OR value of 1. Hence, we return 1.

				Constraints:
					1 <= nums.length <= 50
					0 <= nums[i] <= 50
					0 <= k < 64
				
			class Solution {
				public:
				int minimumSubarrayLength(vector<int>& nums, int k) {
					int size=INT_MAX;
					for(int i=0; i<nums.size(); i++){            
						int val = nums[i], cnt=1;
						for(int j=i; j<nums.size(); j++){
							val |= nums[j];
							if(val >= k)
								size = min(size, cnt);
						
							if(cnt > size)
								break;
							cnt++;                
						}
					}
					if(size == INT_MAX)
						return -1;
						
					return size;
				}
			};

		628) Shortest Subarray With OR at Least K II:
			// Not Optimized:
				class Solution {
					public:
					int minimumSubarrayLength(vector<int>& nums, int k) {
						int size = INT_MAX;
						
						for(int i=0; i<nums.size(); i++){
							int res = nums[i], cnt=1;
							for(int j=i; j<nums.size(); j++){
								res |= nums[j];
								
								if(res >= k)
									size= min(size, cnt);
								
								if(cnt > size)
									break;
								
								cnt++;
							}
						}						
						return (size == INT_MAX) ? -1 : size;
					}
				};
			
			// Optimized:
				❌Pending
	
		629) Minimum Levels to Gain More Points:
			Problem statement:
				You are given a binary array possible of length n.
				Danielchandg and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] == 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it.
				At the start of the game, Danielchandg will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels.
				Danielchandg wants to know the minimum number of levels he should play to gain more points than Bob, if both players play optimally to maximize their points.
				Return the minimum number of levels danielchandg should play to gain more points. If this is not possible, return -1.
				Note that each player must play at least 1 level.

				Example 1:
				Input: possible = [1,0,1,0]
				Output: 1
				Explanation:
					Let's look at all the levels that Danielchandg can play up to:
					If Danielchandg plays only level 0 and Bob plays the rest of the levels, Danielchandg has 1 point, while Bob has -1 + 1 - 1 = -1 point.
					If Danielchandg plays till level 1 and Bob plays the rest of the levels, Danielchandg has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 points.
					If Danielchandg plays till level 2 and Bob plays the rest of the levels, Danielchandg has 1 - 1 + 1 = 1 point, while Bob has -1 point.
					Danielchandg must play a minimum of 1 level to gain more points.

				Example 2:
				Input: possible = [1,1,1,1,1]
				Output: 3
				Explanation:
					Let's look at all the levels that Danielchandg can play up to:
					If Danielchandg plays only level 0 and Bob plays the rest of the levels, Danielchandg has 1 point, while Bob has 4 points.
					If Danielchandg plays till level 1 and Bob plays the rest of the levels, Danielchandg has 2 points, while Bob has 3 points.
					If Danielchandg plays till level 2 and Bob plays the rest of the levels, Danielchandg has 3 points, while Bob has 2 points.
					If Danielchandg plays till level 3 and Bob plays the rest of the levels, Danielchandg has 4 points, while Bob has 1 point.
					Danielchandg must play a minimum of 3 levels to gain more points.

				Example 3:
				Input: possible = [0,0]
				Output: -1
				Explanation:
					The only possible way is for both players to play 1 level each. Danielchandg plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Danielchandg can't gain more points than Bob.

				Constraints:
					2 <= n == possible.length <= 10^5
					possible[i] is either 0 or 1.

			// Not Optimized:
				class Solution {
					public:
					int minimumLevels(vector<int>& possible) {
						int minLvl = -1;
						
						for(int i=0; i<possible.size()-1; i++){
							
							// D Score
							int j = 0, Dscore=0;
							while(j <= i){
								if(possible[j++] == 1)
									Dscore++;
								else
									Dscore--;
							}
							
							// B Score
							int Bscore=0;
							while(j < possible.size()){
								if(possible[j++] == 1)
									Bscore++;
								else
									Bscore--;                    
							}
							
							if(Dscore > Bscore){
								minLvl = i+1;
								break;            
							}
						}
						return minLvl;
					}
				};
			
			// Optimized:
				class Solution {
					public:
					int minimumLevels(vector<int>& possible) {
						int minLvl = -1, Bscore=0;
						
						int totalScore=0;
						for(int i: possible)
							if(i == 1)
								totalScore++;
							else
								totalScore--;
						
						for(int i=0; i<possible.size()-1; i++){
							if(possible[i] == 1){
								Bscore++;
								totalScore--;
							}else{
								Bscore--;
								totalScore++;
							}
							
							
							if(Bscore > totalScore){
								minLvl = i+1;
								break;            
							}
						}
						return minLvl;
					}
				};

	#LeetCode WeeklyContest-391:
		630) Harshad Number:
			Problem statement:
				An integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.
				
				Example 1:
					Input: x = 18
					Output: 9
					Explanation:
					The sum of digits of x is 9. 18 is divisible by 9. So 18 is a Harshad number and the answer is 9.

				Example 2:
					Input: x = 23
					Output: -1
					Explanation:
					The sum of digits of x is 5. 23 is not divisible by 5. So 23 is not a Harshad number and the answer is -1.			

				Constraints:
					1 <= x <= 100
			class Solution {
				public:
				int sumOfTheDigitsOfHarshadNumber(int x) {
					int sum=0;
					int temp = x;
					while(temp){
						sum += temp % 10;
						temp /= 10;
					}
					if(x % sum == 0)
						return sum;
					return -1;
				}
			};

		631) Count Alternating Subarrays:
			Problem statement:
				You are given a binary array nums. We call a 
				subarray alternating if no two adjacent elements in the subarray have the same value.
				Return the number of alternating subarrays in nums.	

				Example 1:
					Input: nums = [0,1,1,1]
					Output: 5
					Explanation:
					The following subarrays are alternating: [0], [1], [1], [1], and [0,1].

				Example 2:
					Input: nums = [1,0,1,0]
					Output: 10
					Explanation:
					Every subarray of the array is alternating. There are 10 possible subarrays that we can choose.		

				Constraints:
					1 <= nums.length <= 10^5
					nums[i] is either 0 or 1.

			// Not Optimized:
				class Solution {
					public:
					long long countAlternatingSubarrays(vector<int>& nums) {
						long long cnt=0;
						
						for(int i=0; i<nums.size(); i++){
							for(int j=i; j<nums.size(); j++){
								int flag=1;
								for(int a=i; a < j; a++){
									if(nums[a] == nums[a+1]){
									flag=0;
									break;
									}
								}
								if(flag)
									cnt++;
							}
						}
						return cnt;
					}
				};

			// Optimized:
				❌Pending		
	
	633) Count Subarrays With Fixed Bounds:
		Problem statement:
			You are given an integer array nums and two integers minK and maxK.
			A fixed-bound subarray of nums is a subarray that satisfies the following conditions:
				The minimum value in the subarray is equal to minK.
				The maximum value in the subarray is equal to maxK.
				Return the number of fixed-bound subarrays.
			A subarray is a contiguous part of an array.

			Example 1:
				Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
				Output: 2
				Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].

			Example 2:
				Input: nums = [1,1,1,1], minK = 1, maxK = 1
				Output: 10
				Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.

			Constraints:
				2 <= nums.length <= 10^5
				1 <= nums[i], minK, maxK <= 10^6

		// Not Optimized:
			class Solution {
				public:
				long long countSubarrays(vector<int>& nums, int minK, int maxK) {
					long long cnt=0;

					for(int i=0; i<nums.size(); i++){
						int crntMin = INT_MAX, crntMax = INT_MIN;
						for(int j=i; j<nums.size(); j++){
							if(crntMin >= nums[j])
								crntMin = nums[j];

							if(crntMax <= nums[j])
								crntMax = nums[j];

							if(crntMin==minK && crntMax == maxK)
								cnt++;
							
							if(crntMin < minK || crntMax > maxK)
								break;
						}
					}
					return cnt;
				}
			};
		
		// Optimized:
			❌Pending
	
	634) Closest Neighbour in BST:
		Problem statement:
			Given the root of a binary search tree and a number n, find the greatest number in the binary search tree that is less than or equal to n. 
			
			Example 1 :
			Input : 
				 5
				/\
			   2   12
			  /\   /\
			 1  3 9 21
			 	   /\
				 19	25

			n = 24
			Output : 21
			Explanation : The greatest element in the tree which is less than or equal to 24, is 21. (Searching will be like 5->12->21)

			Example 2 :
			Input : 
				 5
				/\
			   2   12
			  /\   /\
			 1  3 9 21
			 	   /\
				 19	25

			n = 4
			Output : 
			3
			Explanation : The greatest element in the tree which 
					is less than or equal to 4, is 3. 
					(Searching will be like 5->2->3)
			Your task :
				You don't need to read input or print anything. Your task is to complete the function findMaxForN() which takes the root of the BST, and the integer n as input paramters and returns the greatest element less than or equal to n in the given BST.

				Expected Time Complexity: O(Height of the BST)
				Expected Auxiliary Space: O(Height of the BST).
		
			Constraints:
				1 <= n <= 10^3

		struct Node {
			int key;
			Node* left, *right;
		};


		'N' is the element
		'size' is the total element in BST
		*/

		class Solution {
			public:
			int findMaxForN(Node* root, int n) {
				int val=-1;
				while(root){
					if(root->key <= n){
						val = max(val, root->key);
						root = root->right;
					}else{
						root = root->left;
					}
				}
				return val;
			}
		};

	635) Middle Of Three:
		Problem statement
			You have been given three distinct integers ‘X’, ‘Y’ and ‘Z’. You need to find the number with a value in the middle.
			For example :
			X = 4, Y = 6, Z = 2
			Here the element with value in the middle is 4, because 2 < 4 < 6.
			Note :
			You need to try doing it using minimum comparisons.
			Constraints :
				1 <= T <= 50
				1 <= X, Y, Z <= 10^9

			Where ‘T’ is the number of test cases.
			Where ‘X’, ‘Y’, and ‘Z’ denote the distinct numbers.

			Time limit: 1 sec
			Sample Input 1 :
				2
				2 3 1
				6 8 9   
				Sample Output 1 :
				2 
				8
				Explanation of sample input 1 :
				In the first test case, the three numbers are 2, 3 and 1. The middle element is 2, as 1 < 2 < 3

				In the second test case, the three numbers are 6, 8 and 9. The middle element is 8, as 6 < 8 < 9
				Sample Input 2 :
				2
				15 2 3
				2 3 4
				Sample Output 2 :
				3
				3
				Explanation for sample input 2 :
				In the first test case, the three numbers are 15, 2 and 3. The middle element is 3, as 2 < 3 < 15

				In the second test case, the three numbers are 2, 3 and 4. The middle element is 3, as 2 < 3 < 4

		#include <bits/stdc++.h> 
		int middleOfThree(int x, int y, int z) {
			int arr[3] = {x, y, z};
			sort(arr, arr+3);
			return arr[1];
		}

		// or
			#include <bits/stdc++.h> 
			int middleOfThree(int x, int y, int z) {
				// Checking for x
				if ((y < x && x < z) || (z < x && x < y)) {
					// x is the middle value hence return x
					return x;
				}// Checking for y
				else if ((x < y && y < z) || (z < y && y < x)) {

					// y is the middle value hence return y
					return y;
				}else {
					// Neither x nor y is middle value, means z is the middle value, hence return z
					return z;
				}
			}
	
	636) Length of Last Word:
		Problem statement:
			Given a string s consisting of words and spaces, return the length of the last word in the string.
			A word is a maximal substring consisting of non-space characters only.

			Example 1:
				Input: s = "Hello World"
				Output: 5
				Explanation: The last word is "World" with length 5.

			Example 2:
				Input: s = "   fly me   to   the moon  "
				Output: 4
				Explanation: The last word is "moon" with length 4.

			Example 3:
				Input: s = "luffy is still joyboy"
				Output: 6
				Explanation: The last word is "joyboy" with length 6.
	
			Constraints:
				1 <= s.length <= 10^4
				s consists of only English letters and spaces ' '.
				There will be at least one word in s.

		// Optimized:
			class Solution {
				public:
				int lengthOfLastWord(string s) {
					int i=s.length()-1;
					while(i>=0){
						if(isblank(s[i]))
							s.erase(i,1);
						else 
							break;
						i--;
					}
						
					i = s.size()-1;
					string temp;
					while(i>=0){
						if(isblank(s[i]))
							break;
						temp += s[i];
						i--;
					}
					return temp.length();
				}
			};

		// More Optimized:
			class Solution {
				public:
				int lengthOfLastWord(string s) {
					// ignoring lagging spaces
					int i=s.size()-1;
					while(s[i] == ' '){
						i--;
					}

					int len=0;
					while(i >=0 && s[i--] != ' ')
						len++;

					return len;
				}
			};

			// or
				class Solution {
					public:
					int lengthOfLastWord(string s) {
						// deleting lagging spaces
						int i=s.size()-1;
						while(s[s.size()-1] == ' '){
							s.erase(s.begin()+(s.size()-1));
						}

						int len=0;
						i = s.size()-1;
						while(i >=0 && s[i--] != ' ')
							len++;

						return len;
					}
				};
	
	637) Add Two Numbers:
		Problem statement:
			Your task is very simple: given two integers A and B, write a program to add these two numbers and output the sum.
			Input Format
			The first line contains an integer T, the total number of test cases. Then follow T lines, each line contains two integers, A and B.
			Output Format
			For each test case, add A and B and display the sum in a new line.

			Constraints
				1 ≤ T ≤ 1000
				0 ≤ A,B ≤10000
			Sample 1:
			Input
			3
			1 2
			100 200
			10 40
			Output
			3
			300
			50
			Explanation:
			Testcase 1: 
				1+2=3. Hence the first output is 3.

			Testcase 2: 
				100+200=300. Hence the second output is 300.

		#include <iostream>
		using namespace std;

		int main() {
			int t;
			cin>>t;
			while(t--){
				int a,b;
				cin>>a>>b;
				cout<<a+b<<endl;
			}	
			return 0;
		}
	
	638) Missing number in Arithmetic progression:
		Problem statement
			You are given a sorted array of ‘N’ distinct integers that are in the Arithmetic Progression sequence except for one element which is missing from the sequence. You have to find that missing number from the given sequence.
			Note:
				1. A sequence [arr0, arr1,…, arr(n-1)] is called an Arithmetic progression if for each 'i' ( 0 ≤ i < n - 1) the value arr[i+1] − arr[i] is the same. 
				2. There is exactly one missing number in the given sequence.
				3. All the numbers present in the sequence are distinct.
				4. It is the guarantee that the first and last elements of the sequence are not missing elements.
			Follow Up
			The overall run time complexity should be O(log(N)).
			Constraints:
				1 <= T <= 50
				3 <= N <= 10 ^ 4   
				-10 ^ 9 <= Arr[i] <= 10 ^ 9 

			Where ‘T’ is the number of test cases, ‘N’ is the size of the array and ‘Arr[i]’ is the size of the array elements.

			Time Limit: 1 sec
			Sample Input 1:
				2
				3
				1 4 10
				4
				5 10 20 25 
				Sample Output 1:
				7
				15
				Explanation for sample input 1:
				Test case 1:

				The arithmetic sequence present in the first test case will have its first term as 4 and common difference as 3. So, the complete sequence will look like this ....- 1 4 7 10... Hence 7 is the missing element in the given sequence.

				Test case 2:

				The first term and common difference will be 5. The complete sequence will be ...5 10 15 20 25.... Hence 15 is the missing element from the given sequence.
				Sample Input 2:
				3
				3
				-1 0 2
				5 
				10 20 30 50 60
				4
				12 18 21 24
				Sample Output 2:
				1
				40
				15

		#include <bits/stdc++.h> 
		int missingNumber(vector<int> &arr, int n)  {
			int d;
			int d1= arr[1]-arr[0];
			int d2 = arr[2]-arr[1];

			if(d1 < d2) d = d1;
			else d = d2;

			// or common difference is     int d = (arr[n-1] - arr[0]) / n;
			// (last element - first element) / sizeOfarr

			int miss;
			for(int i=1; i<n; i++){
				miss = arr[i-1] + d;
				if(miss != arr[i])
					break;
			}
			return miss;
		}

	639) Isomorphic Strings:
		Problem statement:
			Given two strings s and t, determine if they are isomorphic.
			Two strings s and t are isomorphic if the characters in s can be replaced to get t.
			All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

			Example 1:
				Input: s = "egg", t = "add"
				Output: true

			Example 2:
				Input: s = "foo", t = "bar"
				Output: false

			Example 3:
				Input: s = "paper", t = "title"
				Output: true

			Constraints:
				1 <= s.length <= 5 * 10^4
				t.length == s.length
				s and t consist of any valid ascii character.

		class Solution {
			public:
			bool isIsomorphic(string s, string t) {
				if(s.size() != t.size())
					return 0;

				map<char, int> F1, F2;
				for(char c: s)
					F1[c]++;

				for(char c: t)
					F2[c]++;
					
				if(F1.size() != F2.size())
					return 0;

				map<char, char> Mapper;
				for(int i=0; i<s.size(); i++)
					Mapper[s[i]] = t[i];

				string checker;
				for(char ch: s)
					checker += Mapper[ch];
				
				if(checker == t)
					return 1;
				return 0;
			}
		};
	
	640) Longest Sub-string With K Distinct Characters: (Easy)
		Problem statement
			You are given a string 'S' of length 'N' consisting of lowercase English alphabet letters. You are also given a positive integer 'K'.
			Now, a substring of this string is good if it contains at most 'K' distinct characters. A string 'X' is a substring of string 'Y' if it can be obtained by deletion of several continuous elements(possibly zero) from the beginning and the end from the string 'Y'.
			Your task is to return the maximum size of any good substring of the string 'S'.

			Example:
				‘S’ = “bacda” and ‘K’ = 3.
				So, the substrings having at most ‘3’ distinct characters are called good substrings. Some possible good substrings are:
				1. “bac”
				2. “acd”
				3. “acda”

				The substring “acda” is the largest possible good substring, as we cannot get any other substring of length 5 or more having distinct characters less than or equal to ‘3’. Thus, you should return ‘4’ as the answer.
			Constraints:
				1 <= T <= 10
				1 <= K <= 26
				1 <= N <= 10^4

				All the characters of the string are lowercase English alphabet letters.
				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				abcbc
				1
				abccc
				Sample Output 1:
				4
				3
				Explanation For Sample Input 1:
				For the first test case :
				K = 2, so we can choose substring “bcbc” having 2 distinct character which is less than or equal to K = 2. 

				We cannot get any other substring of length 5 or more having distinct characters less than or equal to 2. Thus, you should return ‘4’ as the answer.

				For the second test case :
				K = 1, so we can choose substring “ccc” having only 1 distinct character which is less than or equal to K = 1. 

				We cannot get any other substring of length 4 or more having distinct characters less than or equal to 1. Thus, you should return ‘3’ as the answer.
				Sample Input 2:
				1
				6
				abcba
				3
				acbdab
				Sample Output 2:
				5
				4
	
		// Not optimized:
			#include <bits/stdc++.h> 
			int getLengthofLongestSubstring(string s, int k) {
				int mxLen=0;
				for(int i=0; i<s.size(); i++) {

					/* if below lines is not there then it will be partially accepted*/
					// if((s.size()-i) < mxLen)
					//	break;
					
					int cnt=0;
					map<char, int> F;

					for(int j=i; j<s.length(); j++){
						F[s[j]]++;
						if(F.size() > k)
							break;
						cnt++;
					}
					mxLen = max(mxLen, cnt);
				}
				return mxLen;
			}

		// Optimized:
			#include <bits/stdc++.h> 
			int getLengthofLongestSubstring(string s, int k) {
				int mx=0, left=0;
				map<char, int> F;
				for(int i=0; i<s.size(); i++){
					F[s[i]]++;

					while(F.size() > k){
						F[s[left]]--;

						if(F[s[left]] <= 0)
							F.erase(s[left]);

						left++;
					}
					mx = max(mx, i-left+1);
				}
				return mx;
			}

	641) Longest Sub-string with at most K Distinct Characters: (Moderate)
		Problem statement
			You are given string S of length N, and an integer K. Your task is to find the length of the longest substring that contains at most K distinct characters.
			Constraints:
				1 <= T <= 10
				1 <= K <= 26
				1 <= N <= 10^4
				Time Limit: 1sec

			Sample Input 1:
				2
				2
				abcba
				1
				abccc
				Sample Output 1:
				3
				3
				Explanation of the Sample Input1:
				Test Case 1:
				K = 2 in the first test case so we can choose substring ‘bcb’ having 2 distinct characters which are less than equal to K=2. 
				We cannot get any other substring of length 4 or greater having distinct characters less than equal to 2.
				Test Case 2:
				K = 1 in the second test case so we can choose substring ‘ccc’ having only 1 distinct character which is less than equal to K=1. 
				We cannot get any other substring of length 4 or greater having distinct characters less than equal to 1.

		// Not Optimized:
			#include <map>
			int getLengthofLongestSubstring(int k, string s) {
				int mxLen=0;
				for(int i=0; i<s.size(); i++){
					map<char, int> F;
					int cnt=0;
					for(int j=i; j<s.size(); j++){
						F[s[j]]++;
						if(F.size() > k)
							break;
						cnt++;
					}
					mxLen = max(mxLen, cnt);
				}
				return mxLen;
			}

		// Optimized:
			#include <map>
			int getLengthofLongestSubstring(int k, string s) {
				int mx=0, left=0;
				map<char, int> F;
				for(int i=0; i<s.size(); i++){
					F[s[i]]++;

					while(F.size() > k){
						F[s[left]]--;
						if(F[s[left]] <= 0)
							F.erase(s[left]);
						left++;
					}
					mx = max(mx, i-left+1);
				}
				return mx;
			}
		
	642) Look-And-Say Sequence
		Problem statement
			The Look-And-Say sequence is a sequence of positive integers. The sequence is as follows:
			1, 11, 21, 1211, 111221, 312211, 13112221,...
			This sequence is constructed in the following way:
			The first number is 1.
			This is read as “One 1”. 
			Hence, the second number will be 11.

			The second number is read as “Two 1s”. 
			Hence, the third number will be 21.

			The third number is read as “One 2, One 1”. 
			Hence, the fourth number will be 1211. And so on.

			The fourth term is read as “One 1, One 2, Two 1s”.

			Hence, the fifth term will be 111221. And so on.
			Given an integer N, find the Nth term of the sequence.

			Constraints:
				1 <= T <= 30
				1 <= N <= 40

				Where 'T' is the number of test cases and 'N' is the given sequence index.
				Time Limit: 1 sec
			Sample Input 1:
				3
				1
				2
				3
				Sample Output 1:
				1
				11
				21
				Explanation for Sample 1:
				The first term is 1.

				The second term is 11.

				The third term is 21.
				Sample Input 2:
				1
				6
				Sample Output 2:
				312211

		#include <vector>
		string lookAndSaySequence(int n)  {
			vector<string> holder = {"1"};

			while(holder.size() < n) {
				string test = holder[holder.size()-1];
				int cnt=1;
				int i=0;
				string ans;
				while(i<test.size()){
					if((i+1) < test.size() && test[i] == test[i+1])
						cnt++;
					else{
						ans += to_string(cnt);
						ans += test[i];
						cnt=1;
					}
					i++;
				}
				holder.push_back(ans);
			}

			return holder[n-1];
		}

	643) Minimum Sorted Groups:
		Problem statement
			You are given an array ‘ARR’ containing ‘N’ integers.
			You have a simple task, you need to split the elements of this array into different groups, inside each group the relative order between elements must be maintained.
			You need to find the minimum number of groups that are required to be formed such that elements inside each group are sorted in ascending order.
			For Example :
				If ‘N’ = 7 and ‘ARR’ = { 1, 5, 2, 3, 4, 6, 7 }
			Then, we can split the array elements into two groups: { 1, 2, 3, 4 } and { 5, 6, 7 }, this splitting is valid as it maintains the relative ordering of the elements of the original array and after splitting all the groups contain elements in sorted order. Therefore we will print 2.
			Note that a group like { 1, 2, 3, 5 } can’t be formed as it doesn’t have relative ordering the same as the input array.
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints :
				1 ≤ T ≤ 10      
				1 ≤ N ≤ 5000
				-10^9 ≤ ARR[i] ≤ 10^9
				Time limit: 1 sec

			Sample Input 1 :
				2
				7
				1 5 2 3 4 6 7
				6
				-1 0 2 3 4 6
				Sample Output 1 :
				2
				1
				Explanation For Sample Input 1 :
				For test case 1 :
				We will print 2 because:
				We can split the array elements into two groups: { 1, 2, 3, 4 } and { 5, 6, 7 }, this splitting is valid as it maintains the relative ordering of the elements of the original array and after splitting all the groups contain elements in sorted order.

				For test case 2 : 
				We will print 1 because:
				The given array is itself sorted, so all the elements can be grouped together and this will result in the formation of a sorted group while maintaining the relative order of the array elements.
				Sample Input 2 :
				2
				4
				3 1 2 0
				3
				1 1 0
				Sample Output 2 :
				3
				2

		#include <bits/stdc++.h> 
		int minimumSortedGroups(int n, vector<int> arr) {
			vector<vector<int>> holder {{arr[0]}};
			int i=0;
			for(int j=1; j<arr.size(); j++){
				if(holder[i][holder[i].size()-1] <= arr[j])
					holder[i].push_back(arr[j]);
				else{
					incremental:
						i++;
						if(i >= holder.size())
							holder.push_back({arr[j]});
						else{
							if(holder[i][holder[i].size()-1] < arr[j])
							holder[i].push_back(arr[j]);
							else
							goto incremental;
						}
					i=0;
				}
			}
			return holder.size();
		}

		// or
			#include <bits/stdc++.h> 
			int minimumSortedGroups(int n, vector<int> arr) {
				std::vector<std::vector<int>> holder {{arr[0]}};
				
				for (int j = 1; j < arr.size(); j++) {
					bool placed = true; // Flag to indicate if the current element has been placed in any group
					
					for (int i = 0; i < holder.size(); i++) {
						if (holder[i].back() <= arr[j]) {
							holder[i].push_back(arr[j]);
							placed = false; // Mark element as placed
							break;
						}
					}
					
					// If the element couldn't be placed in any existing group, create a new group
					if (placed) {
						holder.push_back({arr[j]});
					}
				}
				return holder.size();
			}
	
	644) Alien Weekday:
		Problem statement
			In a planetary system where a week spans 'N' days, numbered from 1 to 'N', today is denoted as day 'D'. What day will it be 'K' days from now?
			Example:
				‘N’ = 4
				‘D’ = 2
				‘K’ = 3

				Return 1
				Today is 2.
				After 1 day it is 3.
				After another day it is 4
				And finally after another day it is 1.
			Constraints:
				1 <= ‘T’ <= 10^6
				1 <= ‘N’, ‘K’ <= 10^9
				1 <= ‘D’ <= N

				Time Limit: 1 sec
			Sample Input 1:
				2
				2 1 6
				5 2 1
				Sample Output 1:
				1
				3
				Explanation of sample input 1:
				For Test Case 1:
				Today is 1
				After 1 day it is 2.
				After 2 days it is 1.
				After 3 days it is 2.
				After 4 days it is 1.
				After 5 days it is 2.
				After 6 days it is 1.
				For Test Case 2:
				Today is 2
				After 1 day it is 3.
				Sample Input 2:
				3
				7 4 7
				2 1 5
				2 2 7
				Sample Output 2:
				4
				2
				1

		// Not Optimized:
			int alienWeekday(int n,int d,int k){
				int currentDay=d;
				while(k--){
					currentDay++;
					if(currentDay > n)
						currentDay = 1;
				}
				return currentDay;
			}

		// Optimized:
			int alienWeekday(int n,int d,int k){
				int currentDay=d;
				k %= n;
				currentDay += k;
				if(currentDay > n)
					currentDay %= n;
					
				return currentDay;
			}
	
	645) Reach 5 Star:
		Problem Statement:
			Chef loves giving contests on Codechef. Chef wants to become 5 star rated. Currently his rating on Codechef is X.
			After today's contest, his rating will increase by Y. Note that Y can be negative which means that Chef's rating will decrease.
			Find whether Chef will become 5 star rated after today's contest.Chef will be considered 5 star rated if his rating is greater than or equal to 2000.

			Input Format
			The first line contains two space-separated integers X and Y — chef's initial rating and the amount by which his rating will increase, respectively.
			Output Format
				Output YES if chef will become 
			5 star rated, and NO otherwise.

			You may print each character of the string in uppercase or lowercase (for example, the strings YES, yEs, yes, and yeS will all be treated as identical).
			Constraints
				0≤X<2000
				−2000≤Y<2000
			Sample 1:
				Input
				1900 100
				Output
				YES
				Explanation:
				Chef's current rating is 
				1900
				1900, his rating increases by 
				100
				100. So his new rating becomes 
				2000
				2000. Hence chef becomes 
				5
				5 star rated.

				Sample 2:
				Input
				1999 -10
				Output
				NO
				Explanation:
				Chef's current rating is 
				1999
				1999, and his rating decreases by 
				10
				10. So, his new rating becomes 
				1989
				1989. Hence, Chef is unable to become 
				5
				5 star rated.	

		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int A,B;
			cin>>A>>B;
			
			if(A+B >= 2000)
				cout<<"Yes";
			else
				cout<<"No";

			return 0;
		}
		
	646) Maximum Nesting Depth of the Parentheses:
		Problem statement:
			A string is a valid parentheses string (denoted VPS) if it meets one of the following:
			It is an empty string "", or a single character not equal to "(" or ")",
			It can be written as AB (A concatenated with B), where A and B are VPS's, or
			It can be written as (A), where A is a VPS.
			We can similarly define the nesting depth depth(S) of any VPS S as follows:

			depth("") = 0
			depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
			depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
			depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
			For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.
			Given a VPS represented as string s, return the nesting depth of s.

			Example 1:
				Input: s = "(1+(2*3)+((8)/4))+1"
				Output: 3
				Explanation: Digit 8 is inside of 3 nested parentheses in the string.

			Example 2:
				Input: s = "(1)+((2))+(((3)))"
				Output: 3			

			Constraints:
				1 <= s.length <= 100
				s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
				It is guaranteed that parentheses expression s is a VPS.
	
		class Solution {
			public:
			int maxDepth(string s) {
				int mxPara=0, cnt=0;
				for(char c: s){
					if(c == '('){
						cnt++;
						mxPara = max(mxPara, cnt);
					}
					else if(c == ')')
						cnt--;
				}
				return mxPara;
			}
		};

	647) 3Sum: (with sum equals to K)
		Problem statement
			You are given an array/list ARR consisting of N integers. Your task is to find all the distinct triplets present in the array which adds up to a given number K.
			An array is said to have a triplet {ARR[i], ARR[j], ARR[k]} with sum = 'K' if there exists three indices i, j and k such that i!=j, j!=k and i!=j and ARR[i] + ARR[j] + ARR[k] = 'K'.
			Note:
			1. You can return the list of values in any order. For example, if a valid triplet is {1, 2, -3}, then {2, -3, 1}, {-3, 2, 1} etc is also valid triplet. Also, the ordering of different triplets can be random i.e if there are more than one valid triplets, you can return them in any order.
			2. The elements in the array need not be distinct.
			3. If no such triplet is present in the array, then return an empty list, and the output printed for such a test case will be "-1".
			Constraints:
				1 <= T <=  50
				1 <= N <= 10^3  
				-10^6 <= ARR[i] <= 10^6
				-10^9 <= K <= 10^9
				Time Limit: 1 sec

			Sample Input 1:
				1
				5
				10 5 5 5 2
				12
				Sample Output 1:
				5 5 2
				Explanation for Sample Input 1:
				5 5 2 is the only triplet that adds up to 12. Note that the order of the output doesn’t matter, so 5 2 5 or 2 5 5 is also acceptable.
				Sample Input 2:
				3
				6
				1 2 3 1 2 3
				6
				4
				1 2 3 4 
				11
				6
				1 1 2 2 1 1
				4
				Sample Output 2:
				1 2 3
				-1
				1 1 2
				Explanation for Sample Input 2:
				In the first input, (1, 2, 3) is the only unique triplet that adds up to six.
				In the second input, since there are no such triplets, we print -1.
				For the third input, the only distinct triplet is (1, 1, 2), so just print 1 1 2.

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> findTriplets(vector<int>arr, int n, int K) {
				set<vector<int>> s;

				for(int i=0; i<arr.size()-2; i++){
					for(int j=i+1; j<arr.size()-1; j++){
						for(int k=j+1; k<arr.size(); k++){
							if(arr[i]+arr[j]+arr[k] == K){
								vector<int> v;
								v.push_back(arr[i]);
								v.push_back(arr[j]);
								v.push_back(arr[k]);
								sort(begin(v), end(v));
								s.insert(v);
							}
						}
					}
				}
				
				vector<vector<int>> ans (s.begin(), end(s));
				return ans;
			}
	
		// Optimized:
			❌Pending

	648) Three Sum:
		Problem statement
			You are given an array ‘ARR’ containing ‘N’ integers.
			Return all the unique triplets [ARR[i], ARR[j], ARR[k]] such that i != j, j != k and k != i and their sum is equal to zero.
			Example:
				Input: ‘N’ = 5 
				'ARR' =  [-1, -1, 2, 0, 1] 

			Output: 
				-1 -1 2
				-1 0 1

			Explanation:
				(-1 -1 +2) = (-1 +0 +1) = 0.
			Sample Input 1:
				5 
				-1 -1 2 0 1
				Sample Output 1 :
				-1 -1 2
				-1 0 1
				Explanation Of Sample Input 1:
				(-1 -1 +2) = (-1 +0 +1) = 0.
				Sample Input 2:
				4 
				0 0 0 0
				Sample Output 2 :
				0 0 0
			Constraints:
				1  <= N <= 1000
				1 <= ARR[i] <= 1000
				Time Limit: 1 sec

		// Not Optimized:
			#include<set>
			vector<vector<int>> triplet(int n, vector<int> &arr) {
				set<vector<int>> s;
				for(int i=0; i<arr.size()-2; i++){
					for(int j=i+1; j<arr.size()-1; j++){
						for(int k=j+1; k<arr.size(); k++){
							if(arr[i]+arr[j]+arr[k] == 0){
								vector<int> v;
								v.push_back(arr[i]);
								v.push_back(arr[j]);
								v.push_back(arr[k]);
								sort(begin(v), end(v));
								s.insert(v);
							}
						}
					}
				}
				vector<vector<int>> ans (s.begin(), s.end());
				return ans;
			}

		// Optimized:
			❌Pending

	649) Sum of Big integers:
		Problem statement
			You have been given two integers ‘NUM1’ and ‘NUM2’ as a string. Your task is to print the sum of both the numbers.
			Constraints:
				1 <= T <= 10000
				1 <= NUM1 <= 10^50
				1 <= NUM2 <= 10^50
				Where ‘T’ is the number of test cases. ‘NUM1’ and ‘NUM2’ are the numbers whose sum you have to compute.  
				Time Limit: 1sec
			Sample Input 1:
				4
				1 1
				2 1
				17 13
				11 24
				Sample Output 1:
				2
				3
				30
				35
				Explanation For Sample Input 1:
				In the first test case, 2 is the sum of the two numbers. Therefore the answer is 2.
				In the second test case, 3 is the sum of the two numbers. Therefore the answer is 3.
				In the third test case, 30 is the sum of the two numbers. Therefore the answer is 30.
				In the fourth test case, 35 is the sum of the two numbers. Therefore the answer is 35.
				Sample Input 2:
				2
				1555555555555555555500 20
				4 3
				Sample Output 2:
				1555555555555555555520
				7
				Explanation For Sample Input 2:
				In the first test case, 1555555555555555555520 is the sum of the two numbers. Therefore the answer is 1555555555555555555520.
				In the second test case, 7 is the sum of the two numbers. Therefore the answer is 7.
		
		#include <bits/stdc++.h> 
		string findSum(string num1 , string num2) {
			string ans;
			int s1 = num1.size()-1, s2 = num2.size()-1;
			int itr = min(num1.size(), num2.size());
			int carry = 0;
			while(itr--){
				int sum = carry + (num1[s1--] - '0') + (num2[s2--] - '0');
				ans += to_string(sum % 10);
				carry = sum / 10;
			}

			if(num1.size() > num2.size()){
				while(s1 >=0){
					int sum = carry + (num1[s1--] - '0');
					carry = sum / 10;
					ans += to_string(sum % 10);
				}
				if(carry != 0)
					ans += to_string(carry);
			}else if(num1.size() < num2.size()){
				while(s2 >=0){
					int sum = carry + (num2[s2--] - '0');
					carry = sum / 10;
					
					ans += to_string(sum % 10);
				}
				if(carry != 0)
					ans += to_string(carry);
			}else{
				if(carry != 0)
					ans += to_string(carry);
			}
			reverse(begin(ans), end(ans));
			return ans;
		}
	
	#CN WeeklyContest-120:
		650) Spell Casting:
			Problem statement
				You are given a string ‘S’ of length ‘N’ where each character can be either ‘.’ or ‘*’ and are numbered from ‘1’ to ‘N’. The current health value of the player is given by an integer constant ‘K’.
				The player begins the journey from the first character of the string. The character ‘*’ decreases the player's health by ‘2’, while ‘.’ increases the player’s health by ‘1’. If the player’s health drops to ‘0’ or below at any point, the game ends immediately. Your objective is to find the number of characters visited by the player during the game.
				Your task is to tell the number of characters visited by the player during the game and return it.
				NOTE: The characters of the string are given in one-based indexing order.
				Example:
					‘N’ = 4
					‘K’ = 3
					‘S’ = ‘*.**’

				For index ‘1’:
				Here, the health value of the player drops from ‘3’ to ‘1’.
				For index ‘2’
				Here, the current character is ‘.’. So, the health value of the player increases from ‘1’ to ‘2’.
				For index ‘3’: Here, the health value of the player drops from ‘2’ to ‘0’. Now, the player will be unable to move further and the game ends.
				In the example, the number of characters visited by the player is ‘3’.

				Constraints:
					1 <= 'T' <= 10
					1 <= ‘N’ <= 10^5
					1 <= ‘K’ <= 10^9
					‘S[i]’ can be either ‘*’ or ‘.’     
					Time Limit: 1 sec 
				Sample Input 1:
					2
					4 1
					..**
					3 1
					*.. 
					Sample Output 1:
					4   
					1
					Explanation of sample input 1:
					For test case 1:
					For index 1:
					The health of the player increases from ‘1’ to ‘2’.

					For index 2:
					The health of the player increases from ‘2’ to ‘3’.

					For index ‘3’:
					The health of the player drops from ‘3’ to ‘1’.

					For index ‘4’:
					The health of the player drops from ‘1’ to ‘-1’ and the game ends.

					Hence, the number of characters visited by the player is ‘4’.


					For test case 2:

					For index 1:
					The health of the player drops from ‘1’ to ‘-1’ and he’ll be unable to move further.

					Hence, the number of characters visited by the player is ‘1’.
					Sample Input 2:
					2
					5 2
					***..
					5 1
					.....
					Sample Output 2:
					1
					5
			int spellCasting (int n, int k, string &s) {
				int vist=0, i=0;

				while(k > 0 && i < s.size()){
					vist++;
					if(s[i++] == '*')
						k -=2;
					else
						k++;
				}
				return vist;
			}
		
		651) Find Triplets:
			Problem statement
				You are given an array 'A' of 'N' integers indexed from '0' to 'N - 1'.
				Let's define the triplet ('i', 'j', 'k') good, if 'A[i]' < 'A[j]' > 'A[k]'.
				You are required to find a total number of good triplets.
				Example:
					N = 3
					A = [1, 3, 1]
					There are total '4' good triplets ('0', '1', '2'), ('0', '1', '0'), ('2', '1', '2') and ('2', '1', '0').
					So the answer for this case is '4'.
				Constraints:
					1 <= 'N' <= 10^5
					1 <= A[i] <= N

					Time limit: 1 sec
				Sample input 1:
					2
					3
					1 1 1
					4
					1 1 1 4
					Sample output 1:
					0
					9
					Explanation of sample input 1:
					For test case 1:
					As all the elements are equal, there is no good triplet.
					So, the answer for this case is '0'.

					For test case 2:
					We can see that all the triplets where 'j' equal to '3' and 'i' and 'j' have values from '0', '1' and '2' are good.
					As there are '9' such triplets, the answer for this case is '9'.
					Sample input 2:
					2
					4
					1 2 3 4
					5
					1 2 1 2 1
					Sample output 2:
					14
					18

			// Not Optimized:
				long long numberOfGood(int n, vector<int> &v) {
					long long cnt=0;
					
					for(int i=0; i<n; i++)
						for(int j=0; j<n; j++){
							for(int k=0; k<n; k++){
								if(v[i] < v[j] && v[j] > v[k])
									cnt++;
							}       
						}
					return cnt;
				}

			// Optimized:
				❌Pending
				/*
					Time Complexity: O(n)
					Space Complexity: O(n)

					Where 'n' denotes the length of the vector 'v'.
				*/

				long long numberOfGood(int n, vector<int> &v) {

					// Initialize a vector 'frequency' to store the frequency of each element.
					vector<int> frequency(n + 1);

					// Store the frequency of each element.
					for (int i = 0; i < n; i++) {
						frequency[v[i]]++;
					}

					// Initialize the integers 'answer' and 'less' equal to '0'.
					long long answer = 0, less = 0;

					// Iterate through each value from '0' to 'n'.
					for (int i = 0; i <= n; i++) {

						// Find and add the number of good triplets considering the middle element 'j' such that 'v[j] = i'.
						answer += less * less * frequency[i];
						less += frequency[i];
					}
					// Return the 'answer'.
					return answer;
				}
			
		652) Sum Of Digits:
			Problem statement
				Ninja has the number 'M'. Any number 'X' is called good if the difference between 'X' and its sum of digits is less than or equal to 'M'.
				Bob gave the 'N' to the Ninja and asked him to count all good numbers less than or equal to 'N' and greater than or equal to '1'. Ninja is busy with his training, so he asked for your help.
				The score the Ninja will get is equal to 'count of good numbers * count of not good number' modulo '10^9 + 7' (1000000007).
				Your task is to find the score the Ninja will get.
				Example:
					'N' = 11
					'M' = 2
					The numbers '10' and '11' are not good numbers. 
					The sum of digits of '10' is equal to '1', and the difference is '10 - 1 = 9' which is greater than '2'(M). 
					The sum of digits of '11' is equal to '2', and the difference is '11 - 2 = 9' which is greater than '2'(M). 
					Every other number in the range '1' to '9' are good number.
					So, the answer is '9 * 2 = 18'.
				Constraints:
					1 <= T <= 10
					1 <= N <= 10^18
					2 <= M <= 10^18
					Time Limit: 1 second

				Sample Input 1:
					2
					7 3
					15 1
					Sample Output 1:
					0
					54
					Explanation Of Sample Input 1:
					For test case 1:
					Every numbers in the range '[1, 7]' are good numbers.
					So, there are total '7' good numbers and '0' not good numbers.
					So, the answer will be '7 * 0 = 0'.

					For test case 2:
					Every numbers in the range '[1, 9]' are good numbers.
					So, there are total '9' good numbers and '6' not good numbers.
					So, the answer will be '9 * 6 = 54'.
					Sample Input 2:
					2
					22 10
					21 6
					Sample Output 2:
					57
					108

			// Not Optimized:
				long findSum(long long n){
					long S=0;
					while(n){
						S += (n %10);
						n /= 10;
					}
					return S;
				}

				long long countGoodNumbers(long long n, long long m) {
					int MOD = 1e9+7;
					long long cntGN = 0;

					for(long long i = 1; i<=n; i++){
						long long s = findSum(i);
						if((i - s) <= m)
							cntGN++;
					}
					return (cntGN * abs(n-cntGN)) % MOD;
				}
			
			// Optimized:
				❌Pending
				/*
					Time Complexity: O(logN * log10(N)). 
					Space Complexity: O(1).

					Where 'N' is the constant described in the statement.
				*/

				bool isGood(long long x, long long m) {

					// Initialize an integer variable 'temp' with 'X', and 'sum' with '0'.
					long long temp = x, sum = 0;

					// While 'temp' is greater than '0':
					while (temp > 0) {

						// Add 'temp % 10' into the 'sum'.
						sum += (temp % 10);

						// Set 'temp' equal to 'temp / 10'.
						temp = (temp / 10);
					}

					// If 'X - sum' is greater than 'M', then return 'false'.
					if (x - sum > m) {
						return false;
					}

					// Return 'true'.
					return true;
				}

				long long countGoodNumbers(long long n, long long m) {

					// Initialize an integer variable 'L' with '1', and 'R' with 'N'.
					long long l = 1, r = n;

					// Initialize an integer variable 'answer' with '0'.
					long long answer = 0;

					// While 'L' is not equal to 'R':
					while (l <= r) {

						// Initialize an integer variable 'mid' with '(L + R) / 2'.
						long long mid = (l + r) / 2;

						// If 'isGood(mid, M)' is equal to 'true':
						if (isGood(mid, m) == true) {

							// Set 'answer' equal to 'mid'.
							answer = mid;

							// Set 'L' equal to 'mid+1'.
							l = mid + 1;
						}
						else {
							
							// Set 'R' equal to 'mid-1'.
							r = mid - 1;
						}
					}

					// Return '(answer * (n - answer)) modulo (10^9 + 7)'.
					return (answer * (n - answer)) % (1000000007);
				}
		
	653) Make The String Great:
		Problem statement:
			Given a string s of lower and upper case English letters.
			A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:
			0 <= i <= s.length - 2
			s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
			To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.
			Return the string after making it good. The answer is guaranteed to be unique under the given constraints.
			Notice that an empty string is also good.
			Example 1:
				Input: s = "leEeetcode"
				Output: "leetcode"
				Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".

			Example 2:
				Input: s = "abBAcC"
				Output: ""
				Explanation: We have many possible scenarios, and all lead to the same answer. For example:
				"abBAcC" --> "aAcC" --> "cC" --> ""
				"abBAcC" --> "abBA" --> "aA" --> ""

			Example 3:
				Input: s = "s"
				Output: "s"
			
			Constraints:
				1 <= s.length <= 100
				s contains only lower and upper case English letters.

		int SpeedUp =[](){
			ios_base::sync_with_stdio(0);
			cin.tie(0);
			cout.tie(0);
			return 0;
		}();

		class Solution {
			public:
			string makeGood(string s) {
				while(s.size()){
					int flag=1;
					for(int i=0; i<s.size()-1; i++){
						char cur = tolower(s[i+1]);
						char prev = tolower(s[i]);
						if(cur == prev && ((islower(s[i]) && isupper(s[i+1])) || ((islower(s[i+1]) && isupper(s[i]))))){
							flag=0;
							s.erase(s.begin()+i, s.begin()+i+2);
							// or
							// s.erase(i, 2);
							break;
						}
					}
					if(flag)
						break;
				}
				return s;
			}
		};

	654) Number of Good Ways to Split a String:
		Problem statement:
			You are given a string s.
			A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) and the number of distinct letters in sleft and sright is the same.
			Return the number of good splits you can make in s.	
			Example 1:
				Input: s = "aacaba"
				Output: 2
				Explanation: There are 5 ways to split "aacaba" and 2 of them are good. 
				("a", "acaba") Left string and right string contains 1 and 3 different letters respectively.
				("aa", "caba") Left string and right string contains 1 and 3 different letters respectively.
				("aac", "aba") Left string and right string contains 2 and 2 different letters respectively (good split).
				("aaca", "ba") Left string and right string contains 2 and 2 different letters respectively (good split).
				("aacab", "a") Left string and right string contains 3 and 1 different letters respectively.

			Example 2:
				Input: s = "abcd"
				Output: 1
				Explanation: Split the string as follows ("ab", "cd").

			Constraints:
				1 <= s.length <= 105
				s consists of only lowercase English letters.

		// Not Optimized:
			class Solution {
				public:
				int numSplits(string s) {
					int Gsplit=0;

					for(int i=0; i<s.size(); i++){
						string a = s.substr(0,i+1);
						string b = s.substr(i+1);
						
						set<char> s1 (a.begin(), a.end());
						set<char> s2 (b.begin(), b.end());

						if(s1.size() == s2.size())
							Gsplit++;
					}
					return Gsplit;
				}
			};

		// Optimized:
			int SpeedUp =[](){
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				coutd.tie(0);
				return 0;
			}();

			class Solution {
				public:
				int numSplits(string s) {
					int Gsplit=0;
					map<char, int> F1, F2;
					F1[s[0]]++;
					int z=1;

					while(z < s.size())
						F2[s[z++]]++;
					
					if(F1.size() == F2.size())
							Gsplit++;
				
					for(int i=1; i<s.size(); i++){
						F1[s[i]]++;
						F2[s[i]]--;

						if(F2[s[i]] <= 0)
							F2.erase(s[i]);
						
						if(F1.size() == F2.size())
							Gsplit++;
					}
					return Gsplit;
				}
			};

	655) Vowels of All Substrings:
		Problem statement:
			Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word.
			A substring is a contiguous (non-empty) sequence of characters within a string.
			Note: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.

			Example 1:
			Input: word = "aba"
			Output: 6
			Explanation: 
			All possible substrings are: "a", "ab", "aba", "b", "ba", and "a".
			- "b" has 0 vowels in it
			- "a", "ab", "ba", and "a" have 1 vowel each
			- "aba" has 2 vowels in it
			Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. 

			Example 2:
				Input: word = "abc"
				Output: 3
				Explanation: 
				All possible substrings are: "a", "ab", "abc", "b", "bc", and "c".
				- "a", "ab", and "abc" have 1 vowel each
				- "b", "bc", and "c" have 0 vowels each
				Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.

			Example 3:
				Input: word = "ltcd"
				Output: 0
				Explanation: There are no vowels in any substring of "ltcd".
		
			Constraints:
				1 <= word.length <= 10^5
				word consists of lowercase English letters.
		
		// Not Optimized:
			class Solution {
				public:
				long long countVowels(string word) {
					long long Vcnt=0;

					for(int i=0; i<word.size(); i++){
						int cnt=1;
						for(int j=i; j<word.size(); j++){
							string s = word.substr(i, cnt++);

							for(char c: s){
								if(c == 'a' || c == 'i' || c == 'e' || c == 'o' || c == 'u')
								Vcnt++;
							}
						}
					}
					return Vcnt;
				}
			};

		// Little Optimized:
			class Solution {
				public:
				long long countVowels(string s) {
					long long Vcnt=0;

					for(int i=0; i<s.size(); i++){
						int cnt=0;
						for(int j=i; j<s.size(); j++){
							if(s[j] == 'a' || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u')
								cnt++;

							Vcnt += cnt;
						}
					}
					return Vcnt;
				}
			};

		// Optimized:
			❌Pending

	656) Merge Two Sorted Lists:
		Problem statement:
			You are given the heads of two sorted linked lists list1 and list2.
			Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
			Return the head of the merged linked list.		

			Example 1:
				Input: list1 = [1,2,4], list2 = [1,3,4]
				Output: [1,1,2,3,4,4]

			Example 2:
				Input: list1 = [], list2 = []
				Output: []

			Example 3:
				Input: list1 = [], list2 = [0]
				Output: [0]
			
			Constraints:
				The number of nodes in both lists is in the range [0, 50].
				-100 <= Node.val <= 100
				Both list1 and list2 are sorted in non-decreasing order.

		/**
			* Definition for singly-linked list.
			* struct ListNode {
			*     int val;
			*     ListNode *next;
			*     ListNode() : val(0), next(nullptr) {}
			*     ListNode(int x) : val(x), next(nullptr) {}
			*     ListNode(int x, ListNode *next) : val(x), next(next) {}
			* };
		*/

		class Solution {
			public:
			ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
				ListNode* ans = NULL;
				ListNode* Tail = NULL;

				// Combine check
				while(list1 && list2){
					if(list1->val <= list2->val){
						ListNode * newNode = new ListNode(list1->val);
						if(!ans){
							ans = newNode;
							Tail = newNode;
						}else{
							Tail -> next = newNode;
							Tail = newNode;
						}
						list1 = list1 -> next;
					}else{
						ListNode * newNode = new ListNode(list2->val);
						if(!ans){
							ans = newNode;
							Tail = newNode;
						}else{
							Tail -> next = newNode;
							Tail = newNode;
						}
						list2 = list2->next;
					}
				}

				// Individual check list1
				while(list1) {
					ListNode * newNode = new ListNode(list1->val);
					if(!ans){
						ans = newNode;
						Tail = newNode;
					}else{
						Tail -> next = newNode;
						Tail = newNode;
					}
					list1 = list1 -> next;
				}

				// List2
				while(list2) {
					ListNode * newNode = new ListNode(list2->val);
					if(!ans){
						ans = newNode;
						Tail = newNode;
					}else{
						Tail -> next = newNode;
						Tail = newNode;
					}
					list2 = list2 -> next;
				}

				/*
					// instead of above 2 while loops, you can use below simple code
					if(!list1)
						Tail -> next = list2;
					else
						Tail -> next = list1;				
				*/

				return ans;
			}
		};
	
	657) Linked List Cycle:
		Problem statement:
			Given head, the head of a linked list, determine if the linked list has a cycle in it.
			There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.
			Return true if there is a cycle in the linked list. Otherwise, return false.

			Example 1:
				Input: head = [3,2,0,-4], pos = 1
				Output: true
				Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

			Example 2:
				Input: head = [1,2], pos = 0
				Output: true
				Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.

			Example 3:
				Input: head = [1], pos = -1
				Output: false
				Explanation: There is no cycle in the linked list.
			
			Constraints:
				The number of the nodes in the list is in the range [0, 104].
				-10^5 <= Node.val <= 10^5
				pos is -1 or a valid index in the linked-list.
			Follow up: Can you solve it using O(1) (i.e. constant) memory?
				
		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode(int x) : val(x), next(NULL) {}
		* };
		*/
		class Solution {
			public:
			bool hasCycle(ListNode *head) {
				vector<ListNode*> holder;

				while(head){
					if(find(holder.begin(), holder.end(), head) != holder.end())
						return 1;

					holder.push_back(head);
					head = head->next;
				}
				return 0;
			}
		};
	
	658) Delete Node in a Linked List:
		Problem statement:
			There is a singly-linked list head and we want to delete a node node in it.
			You are given the node to be deleted node. You will not be given access to the first node of head.
			All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.
			Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:

			The value of the given node should not exist in the linked list.
			The number of nodes in the linked list should decrease by one.
			All the values before node should be in the same order.
			All the values after node should be in the same order.
			Custom testing:
				For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.
				We will build the linked list and pass the node to your function.
				The output will be the entire list after calling your function.
			
			Example 1:
				Input: head = [4,5,1,9], node = 5
				Output: [4,1,9]
				Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.

			Example 2:
				Input: head = [4,5,1,9], node = 1
				Output: [4,5,9]
				Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
			
			Constraints:
				The number of the nodes in the given list is in the range [2, 1000].
				-1000 <= Node.val <= 1000
				The value of each node in the list is unique.
				The node to be deleted is in the list and is not a tail node.

		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode(int x) : val(x), next(NULL) {}
		* };
		*/
		class Solution {
			public:
			void deleteNode(ListNode* node) {
				node->val = node->next->val;
				node->next = node->next->next;
				return ;
			}
		};
	
	659) Middle of the Linked List:
		Problem statement:
			Given the head of a singly linked list, return the middle node of the linked list.
			If there are two middle nodes, return the second middle node.
			Example 1:
				Input: head = [1,2,3,4,5]
				Output: [3,4,5]
				Explanation: The middle node of the list is node 3.
				
			Example 2:
				Input: head = [1,2,3,4,5,6]
				Output: [4,5,6]
				Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
			Constraints:
				The number of nodes in the list is in the range [1, 100].
				1 <= Node.val <= 100
		
		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			int getLenLL(ListNode* &H){
				ListNode* T = H;
				int L=0;
				while(T){
					L++;
					T = T->next;
				}
				return L;
			}
			ListNode* middleNode(ListNode* head) {
				int len = getLenLL(head) / 2;
				ListNode* ans = nullptr;
				while(len--)
					head = head->next;

				ans = head;f
				return ans;
			}
		};

		// Or
			class Solution {
				public:
				ListNode* middleNode(ListNode* head) {
					ListNode* ans = head;
					int len=1, mid =1;
					
					while(head){
						len++;

						if(len > 2*mid){
							mid++;
							ans=ans->next;
						}

						head = head->next;
					}

					return ans;        
				}
			};
	
	660) Game of Stones:
		Problem statement
			Given the count of total stones in a game. Two-player ‘Ale’ and ‘Bob’ are playing the game. Your task is to find who will win the game if both the players are playing optimally.
			Rules of the game.
			1. In a single turn, a player can choose a single stone or ‘even’ number of stones.
			2. They will play alternatively, which means in the first chance ‘Ale’ will collect the stones, in second-chance ‘Bob’ will collect the stones. And always ‘Ale’ will start the game.
			3. If any player is not able to take any stones then another player will win the game.
			Constraints:
				1 <= T <= 10^5
				1 <= number of stones <= 10^9

				Where ‘T’ is the total number of test cases.
				Time limit: 1 second
			Sample Input 1:
				2
				2
				3
				Sample Output 1:
				Ale
				Bob
				Explanation of sample input 1:
				Test Case 1:

				Given the number of stones is ‘2’.
				Then first player ‘Ale’ can choose both the stones because 2 is an even number.
				So ‘Ale’ will the game.
				Return ‘Ale’.

				Test Case 2:

				Given the number of stones is ‘3’.
				In the first turn ‘Ale’ can choose ‘1’ stone or ‘2’ store, but not ‘3’ stone because ‘3’ is neither ‘1’ or even number.
				If ‘Ale’ chooses ‘1’ in the first turn. Then in the second turn, ‘Bob’ will collect the remaining ‘2’ stone, so ‘Bob’ will win.
				If ‘Ale’ chooses ‘2’ stones in the first turn. Then in the second turn, ‘Bob’ will collect the remaining ‘1’ stone, again ‘Bob’ will win the game.
				So in both cases ‘Bob’ is winning the game. Hence Return ‘Bob’. 
				Sample Input 2:
				2
				4
				6
				Sample Output 2:
				Ale
				Ale

		string gameOfStones(int num) {
			if(num ==1)
				return "Ale";
				
			if(num&1){
				if(num > 3)
					return "Ale";
				return "Bob";
			}
			return "Ale";
		}

	661) Remove Duplicates from Sorted List:
		Problem statement:
			Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.	
			Example 1:
				Input: head = [1,1,2]
				Output: [1,2]

			Example 2:
				Input: head = [1,1,2,3,3]
				Output: [1,2,3]
				
			Constraints:
				The number of nodes in the list is in the range [0, 300].
				-100 <= Node.val <= 100
				The list is guaranteed to be sorted in ascending order.

		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			ListNode* deleteDuplicates(ListNode* head) {
				if(!head || head->next == NULL)
					return head;

				ListNode* cur = head->next;
				ListNode* pre = head;

				while(cur){
					if(pre->val == cur->val){
						cur= cur->next;
						pre->next = cur;
					}else{
						pre=pre->next;
						cur=cur->next;
					}
				}
				return head;
			}
		};

	662) Remove Linked List Elements:
		Problem statement:
			Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.			
			Example 1:
				Input: head = [1,2,6,3,4,5,6], val = 6
				Output: [1,2,3,4,5]

			Example 2:
				Input: head = [], val = 1
				Output: []

			Example 3:
				Input: head = [7,7,7,7], val = 7
				Output: []
			
			Constraints:
				The number of nodes in the list is in the range [0, 104].
				1 <= Node.val <= 50
				0 <= val <= 50
		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			ListNode* removeElements(ListNode* head, int val) {
				ListNode* T = head;
				ListNode* pre = nullptr;

				while(T) {
					if(T->val == val && pre != NULL){
						pre->next = T->next;
						T = T->next;
					}else if(T->val == val && pre == NULL){
						head = head->next;
						T = head;
					}else{
						pre = T;
						T = T->next;
					}
				}
				return head;
			}
		};

	#LeetCode WeeklyContest-392:
		663) Longest Strictly Increasing or Strictly Decreasing Subarray:
			Problem statement:
				You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.

				Example 1:
				Input: nums = [1,4,3,3,2]
				Output: 2
				Explanation:
				The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].
				The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].
				Hence, we return 2.

				Example 2:
				Input: nums = [3,3,3,3]
				Output: 1
				Explanation:
				The strictly increasing subarrays of nums are [3], [3], [3], and [3].
				The strictly decreasing subarrays of nums are [3], [3], [3], and [3].
				Hence, we return 1.

				Example 3:
				Input: nums = [3,2,1]
				Output: 3
				Explanation:
				The strictly increasing subarrays of nums are [3], [2], and [1].
				The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].
				Hence, we return 3.
				
				Constraints:
					1 <= nums.length <= 50
					1 <= nums[i] <= 50
		
			class Solution {
				public:
				int longestMonotonicSubarray(vector<int>& nums) {
					int mxCnt=1;
					
					// increasing check
					for(int i=0; i<nums.size()-1; i++){
						int cnt=1;
						for(int j=i+1; j<nums.size(); j++){
							if(nums[j-1] >= nums[j])
								break;
							
							cnt++;
							mxCnt = max(mxCnt, cnt);
						}
					} 
					
					// decreasing check
					for(int i=0; i<nums.size()-1; i++){
						int cnt=1;
						for(int j=i+1; j<nums.size(); j++){
							if(nums[j-1] <= nums[j])
								break;
							
							cnt++;
							mxCnt = max(mxCnt, cnt);
						}
					} 
					
					return mxCnt;
				}
			};

		664) Minimum Operations to Make Median of Array Equal to K:
			Problem statement:
				You are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.
				Return the minimum number of operations needed to make the median of nums equal to k.		
				Example 1:
				Input: nums = [2,5,6,8,5], k = 4
				Output: 2
				Explanation:
				We can subtract one from nums[1] and nums[4] to obtain [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.

				Example 2:
				Input: nums = [2,5,6,8,5], k = 7
				Output: 3
				Explanation:
				We can add one to nums[1] twice and add one to nums[2] once to obtain [2, 7, 7, 8, 5].

				Example 3:
				Input: nums = [1,2,3,4,5,6], k = 4
				Output: 0
				Explanation:
				The median of the array is already equal to k.
		
				Constraints:
					1 <= nums.length <= 2 * 10^5
					1 <= nums[i] <= 10^9
					1 <= k <= 10^9

			// Not Optimized:
				class Solution {
					public:
					long long minOperationsToMakeMedianK(vector<int>& nums, int k) {
						long long MinOps=0;
						sort(begin(nums), end(nums));
						int median = nums.size()/2;
						
						while(nums[median] != k){
							if(nums[median] > k)
								nums[median]--;
							else
								nums[median]++;
							sort(begin(nums), end(nums));
							MinOps++;
						}
						return MinOps;        
					}
				};

			// Little bit optimized:
				class Solution {
					public:
					long long minOperationsToMakeMedianK(vector<int>& nums, int k) {
						long long MinOps=0;
						sort(begin(nums), end(nums));
						int median = nums.size()/2;
						
						while(nums[median] != k){
							MinOps += abs(nums[median]-k);
							nums[median] = k;
							sort(begin(nums), end(nums));
						}
						return MinOps;        
					}
				};
		
			// Optimized:
				int speedUp = [](){
					ios_base::sync_with_stdio(0);
					cin.tie(0);
					cout.tie(0);
					return 0;
				}();
				class Solution {
					public:
					long long minOperationsToMakeMedianK(vector<int>& nums, int k) {
						long long MinOps=0;
						// ranges::sort(nums);
						sort(nums.begin(), nums.end());
						int m = nums.size()/2;
						MinOps += abs(nums[nums.size()/2] - k);
						nums[m] = k;

						// checking for m+1 till n elements
						for(int i=m+1; i<nums.size(); i++){
							if(nums[i] >= k)
								break;

							MinOps += abs(nums[i] - k);
							nums[i] = k;
						}

						// checking for m-1 till 0 elements
						for(int i=m-1; i>=0; i--){
							if(nums[i] <= k)
								break;

							MinOps += abs(nums[i] - k);
							nums[i] = k;
						}
						return MinOps;
					}
				};

	665) Find the lone set bit:
		Problem statement:
			You are given a single non-negative integer ‘N’ who’s binary representation consists of a single ‘1’ digit and the rest of the digits are ‘0’s. Your task is to find the position of the only ‘1’ digit. In other words, your task is to find the position of the only set bit in the binary representation of the input integer ‘N’.
			The position of the set bit must be counted from the LSB (Least Significant Bit) end of the Binary number. If the count of set bits in the Binary number is not equal to 1, then your function should return ‘-1’ as output.
			Example:-
			INPUT   : N = 4
			OUTPUT  : 3
			In the above example, N = 4, whose Binary representation is “0100”. It is clearly visible that the binary number contains a single set bit, at a position 3 from the LSB end. Hence the output is 3

			INPUT : N = 8
			OUTPUT: 4
			In the above example, N = 8, whose Binary representation is “1000”. It is clearly visible that the binary number contains a single set bit, at a position 4 from the LSB end. Hence the output is 4

			INPUT   : N = 9
			OUTPUT  : -1
			In the above example, N = 9, whose Binary representation is “1001”.  Now, the binary number contains 2 set bits, at a position 4 and 1 from LSB end. Hence the output is -1.

			INPUT   : N = 0
			OUTPUT  : -1
			In the above example, N = 0, whose Binary representation is “0000”.  Now, the binary number contains no set bits at all. Hence the output will be -1.
			Constraints:
				1 <= T <= 100    
				0 <= N <= 10^5

			Time limit: 1 second
			Sample Input 1:
				4
				2
				8
				11
				0
				Sample Output 1:
				2
				4
				-1
				-1
				Explanation For Sample Input 1:
				In the first test case, N = 2, whose Binary equivalent is “10”. The set bit is at position 2 from the LSB end. Hence the output is 2
				In the second test case, N = 8, whose Binary equivalent is “1000”. The set bit is at position 4 from the LSB end. Hence the output is 4
				In the third test case, K = 11, whose Binary equivalent is “1011”. The count of the total number of set bits is 3 which is not equal to 1. Hence the output is -1

				In the fourth test case, K = 0, whose Binary equivalent is “0000”, which contains no set bits at all. Hence the output is -1.
				Sample Input 2:
				5
				16
				21
				32
				58
				64
				Sample Output 2:
				5
				-1
				6
				-1
				7  

		#include <bits/stdc++.h> 
		int findSetBit(int N) {
			int cnt=0, nBits=0, m;
			while(N){
				cnt++;
				if(N&1){
					nBits++;
					m = cnt;
				}
				N >>=1;
			}

			if(nBits == 1)
				return m;
			return -1;
		}
	
	666) Palindrome Linked List:
		Problem statement
			You have been given a head to a singly linked list of integers. Write a function check to whether the list given is a 'Palindrome' or not.
			Constraints :
				1 <= t <= 10^2
				0 <= M <= 10^5
				Time Limit: 1sec

			Where 'M' is the size of the singly linked list.
			Sample Input 1 :
				1
				9 2 3 3 2 9 -1
				Sample Output 1 :
				true
				Sample Input 2 :
				2
				0 2 3 2 5 -1
				-1
				Sample Output 2 :
				false
				true
				Explanation for the Sample Input 2 :
				For the first query, it is pretty intuitive that the the given list is not a palindrome, hence the output is 'false'.
				For the second query, the list is empty. An empty list is always a palindrome , hence the output is 'true'.
			
		/****************************************************************	
		Following is the class structure of the Node class:

			class Node {
			public:
				int data;
				Node *next;
				Node(int data) {
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/
		#include<bits/stdc++.h>
		bool isPalindrome(Node *H) {
			vector<string> s1;
			while(H){
				s1.push_back(to_string(H->data));
				H = H->next;
			}

			for(int i=0; i < s1.size()/2; i++)
				if(s1[i] != s1[s1.size()-1-i])
					return 0;
			return 1;
		}

	667) Check If Linked List Is Palindrome:
		Problem statement
			You are given a Singly Linked List of integers. You have to return true if the linked list is palindrome, else return false.
			A Linked List is a palindrome if it reads the same from left to right and from right to left.
			Example:
				The lists (1 -> 2 -> 1), (3 -> 4 -> 4-> 3), and (1) are palindromes, while the lists (1 -> 2 -> 3) and (3 -> 4) are not.
			Sample Input 1:
				1 2 2 1 -1
				Sample Output 1:
				True
				Explanation for Sample Input 1:
				The given list is a palindrome.
				Sample Input 2:
				3 2 1 -1
				Sample Output 2:
				False
				Constraints :
				1 <= 'N' <= 5 * 10^4
				-10^9 <= 'data' <= 10^9 and 'data' != -1
				Where 'N' is the number of nodes in the linked list and ‘data’ represents the value of the list's nodes.
				Time Limit: 1sec

		// Solution using vector
		/****************************************************************
			Following is the class structure of the Node class:
			class Node {
				public:
				int data;
				Node *next;
				Node(){
					this->data = 0;
					next = NULL;
				}
				Node(int data) {
					this->data = data;
					this->next = NULL;
				}
				Node(int data, Node* next) {
					this->data = data;
					this->next = next;
				}
			};
		*****************************************************************/

		bool isPalindrome(Node *H) {
			vector<string> s1;
			while(H){
				s1.push_back(to_string(H->data));
				H = H->next;
			}

			for(int i=0; i < s1.size()/2; i++)
				if(s1[i] != s1[s1.size()-1-i])
					return 0;
			return 1;
		}

		// Solution using stack:
			#include<bits/stdc++.h>
			bool isPalindrome(Node *H1) {
				stack<int> holder;
				Node *H = H1;

				while(H){
					holder.push(H->data);
					H = H->next;
				}

				while(!holder.empty()){
					if(holder.top() != H1->data)
							return 0;
					holder.pop();
					H1 = H1->next;
				}
				return 1;
			}
	
	668) Find a Node in Linked List:
		Problem statement
			You have been given a singly linked list of integers. Write a function that returns the index/position of integer data denoted by 'N' (if it exists). Return -1 otherwise.
			Note :
			Assume that the Indexing for the singly linked list always starts from 0.
			Constraints :
				1 <= T <= 10^2
				0 <= M <= 10^5
				Where 'M' is the size of the singly linked list.
				Time Limit: 1 sec

			Sample Input 1 :
				2
				3 4 5 2 6 1 9 -1
				5
				10 20 30 40 50 60 70 -1
				6
				Sample Output 1 :
				2
				-1
				Explanation for Sample Output 1:
				In test case 1, 'N' = 5 appears at position 2 (0-based indexing) in the given linked list.

				In test case 2, we can see that 'N' = 6 is not present in the given linked list.
				Sample Input 2 :
				2
				1 -1
				2
				3 4 5 2 6 1 9 -1
				6
				Sample Output 2 :
				-1
				4
				Explanation for Sample Output 2:
				In test case 1, we can see that 'N' = 2 is not present in the given linked list.
				In test case 2, 'N' = 6 appears at position 4 (0-based indexing) in the given linked list.

		/****************************************************************
			Following is the class structure of the Node class:

			class Node {
				public:
				int data;
				Node *next;
				Node(int data) {
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/

		int findNode(Node *head, int n){
			Node* Traverse = head;
			int cnt=0;
			while(Traverse){
				if(n == (*Traverse).data)
					return cnt;
				cnt++;
				Traverse = Traverse ->next;
			}
			return -1;
		}
	
	669) Number of Students Unable to Eat Lunch:
		Problem statement:
			The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.
			The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:
			If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
			Otherwise, they will leave it and go to the queue's end.
			This continues until none of the queue students want to take the top sandwich and are thus unable to eat.
			You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

			Example 1:
				Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
				Output: 0 
				Explanation:
				- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
				- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
				- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
				- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
				- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
				- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
				- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
				- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
				Hence all students are able to eat.

			Example 2:
				Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
				Output: 3
			
			Constraints:
				1 <= students.length, sandwiches.length <= 100
				students.length == sandwiches.length
				sandwiches[i] is 0 or 1.
				students[i] is 0 or 1.

		class Solution {
			public:
			int countStudents(vector<int>& students, vector<int>& sandwiches) {

				while(sandwiches.size() > 0){
					int i, found=1;
					for(i=0; i<students.size(); i++){
						if(students[i] == sandwiches[0]){
							students.erase(students.begin()+i);
							sandwiches.erase(sandwiches.begin());
							found=0;
							break;
						}
					}
					
					// this means students don't have sandwiches of their type
					if(found)
						break;
				}
				return students.size();
			}
		};

		// or using Queue
			class Solution {
				public:
				int countStudents(vector<int>& students, vector<int>& sandwiches) {
					queue<int> q;
					for(int i: students)
						q.push(i);

					int itr=0, cnt=0;
					while(q.size() > 0){
						if(q.front() == sandwiches[itr]){
							itr++;
							q.pop();
							cnt=0;
						}else{
							q.push(q.front());
							q.pop();
							cnt++;

							if(cnt >= q.size())
								break;
						}
					}
					return q.size();
				}
			};
	
	670) Time Needed to Buy Tickets:
		Problem statement:
			There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.
			You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].
			Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.
			Return the time taken for the person at position k (0-indexed) to finish buying tickets.
		
			Example 1:
				Input: tickets = [2,3,2], k = 2
				Output: 6
				Explanation: 
				- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
				- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
				The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.

			Example 2:
				Input: tickets = [5,1,1,1], k = 0
				Output: 8
				Explanation:
				- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
				- In the next 4 passes, only the person in position 0 is buying tickets.
				The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.
		
			Constraints:
				n == tickets.length
				1 <= n <= 100
				1 <= tickets[i] <= 100
				0 <= k < n
		
		class Solution {
			public:
			int timeRequiredToBuy(vector<int>& tickets, int k) {
				int time=0;

				while(tickets[k] != 0){
					for(int i=0; i<tickets.size(); i++){
						if(tickets[i] > 0) time++;
						
						tickets[i]--;
						if(tickets[k] == 0) break;
					}
				}
				return time;    
			}
		};

	671) Cubic Square:
		Problem statement
			You are given three positive integers ‘A’, ‘B’, and ‘M’. Your task is to find out the result of ‘A^B’ mod ‘M’.
			This task was too easy for Ninja, and being a top-class ninja, he likes to make things a little difficult in order to enjoy solving them. So he converted B into base 3 and is now trying to find the answer.
			But it seems like he made the task a little too difficult for himself. Being a good friend of Ninja, can you help find him ‘A^B mod M’ when ‘A’, ‘M’ is given in base 10 and ‘B’ is in base 3?

			Sample Input 1 :
				1
				2 11 6
				Sample Output 1 :
				4
				Explanation for sample input 1 :
				‘B’ is ‘10’ in base 3 which is equal to 4 in base 10. Hence the answer is 2^4 mod 6 which is equal to 4.
				Sample Input 2 :
				2
				5 201 7
				6 120 9
				Sample Output 2 :
				5
				0
				Explanation for sample input 2 :
				For test case 1, ‘B’ equals 19 in base 10. 5^19 mod 7 = 5.
				For test case 1, ‘B’ equals 15 in base 10. 6^15 mod 9 = 0.
	
		// Not Optimized:
			#include <bits/stdc++.h> 
			int cubicSquare(int m, int a, string &b) {
				int B = stoi(b, 0, 3);          // this line will convert string b from base 3 to decimal
				// cout<<B<<endl;
				
				int holder = 1;
				for(int i=0; i<B; i++){
					holder *= a;
					holder %= m;
				}
				return holder%m;
			}

		// Optimized:
			❌Pending

	672) Robot moves:
		Problem statement
			On an infinite plane, a robot initially stands at (0, 0) and faces north.
			Note that:
			The north direction is the positive direction of the y-axis.
			The south direction is the negative direction of the y-axis.
			The east direction is the positive direction of the x-axis.
			The west direction is the negative direction of the x-axis.

			The robot can receive one of three instructions:
			'G': go straight 1 unit.
			'L': turn 90 degrees to the left (i.e., anti-clockwise direction).
			'R': turn 90 degrees to the right (i.e., clockwise direction).
			You are given the 'N' instruction as a string containing characters 'G', 'L', and 'R'. The robot performs the instructions given in order.
			You are required to find the number of indices 'i' ('0' <= 'i' <= 'N - 2'') such that if we swap the 'S[i]' and 'S[i + 1], the robot will end on the same point after performing all the instructions.
			Example:
			N = 3
			S = 'GGL'
			If we don't swap any characters, then the robot will end on ('0', '2').
			For 'i' equal to '0', by swapping 'S[i]' and 'S[i + 1]', the robot will end on the same point i.e. ('0', '2').
			For 'i' equal to '1', by swapping 'S[i]' and 'S[i + 1]', the robot will end on a different point i.e. ('-1', '1').
			So, the answer for this case is '1'.
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints:
			2 <= 'N' <= 10^5
			'S[i]' belongs to {'G', 'L', 'R'}.

			Time limit: 1 sec
			Sample input 1:
				2
				3
				GGG
				4
				GRGL
				Sample output 1:
				2
				0
				Explanation of sample input 1:
				For test case 1:
				If we don't swap any characters, then the robot will end on ('0', '3').
				For 'i' equal to '0', '1' and '2', by swapping 'S[i]' and 'S[i + 1]', the robot will end on the same point i.e. ('0', '3').
				So, the answer for this case is '3'.


			For test case 2:
			If we don't swap any characters, then the robot will end on ('1', '1').
			For 'i' equal to '0', by swapping 'S[i]' and 'S[i + 1]', the robot will end on a different point i.e. ('2', '0').
			For 'i' equal to '1', by swapping 'S[i]' and 'S[i + 1]', the robot will end on a different point i.e. ('0', '2').
			For 'i' equal to '2', by swapping 'S[i]' and 'S[i + 1]', the robot will end on a different point i.e. ('0', '2').
			So, the answer for this case is '0'.
			Sample input 2:
			2
			6
			GGLLRR
			5
			GLRGL
			Sample output 2:
			4
			1

		string indexfinder(string s){
			int x,y, Lcnt, Rcnt;
			x=y=0;
			string ans;

			char Directions[] = {'N', 'E', 'S', 'W'};
			int directIndex=0;
			char FacingDir = Directions[directIndex];

			for(char ch: s){
				if(ch == 'G' && FacingDir == 'N')
					y++;
				else if(ch == 'G' && FacingDir == 'W')
					x--;
				else if(ch == 'G' && FacingDir == 'E')
					x++;
				else if(ch == 'G' && FacingDir == 'S')
					y--;
				else if(ch == 'L'){
					directIndex--;
					if(directIndex <0)
						directIndex = 3;
					FacingDir = Directions[directIndex];
				}else if(ch == 'R'){
					directIndex++;
					if(directIndex > 3)
						directIndex = 0;
					FacingDir = Directions[directIndex];
				}
			}

			ans += to_string(x);
			ans += to_string(y);
			return ans;
		}
		int numberOfIndices(int n, string &s) {
			int cnt=0;
			string mainIndexes = indexfinder(s);

			for(int i=0; i<n-1; i++){
				string test = s;
				swap(test[i], test[i+1]);
				string currIndex = indexfinder(test);
				if(currIndex == mainIndexes)
					cnt++;
			}

			return cnt;
		}

		// Simpler:
			int numberOfIndices(int n, string &s) {
				int cnt=0;
				
				for(int i=0; i<n-1; i++)
					if(s[i] == s[i+1] || (s[i] != 'G'  && s[i+1] != 'G'))
						cnt++;

				return cnt;
			}
	
	673) Party of Couples
		Problem statement:
			You are given an integer array arr[] of size n, representing n number of people in a party, each person is denoted by an integer. Couples are represented by the same number ie: two people have the same integer value, it means they are a couple. Find out the only single person in the party of couples.
			NOTE: It is guarantee that there exist only one single person in the party.

			Example 1:
				Input:
				n = 5
				arr = {1, 2, 3, 2, 1}
			Output: 
				3
			Explaination: Only the number 3 is single.
			Example 2:

			Input: 
			n = 11 
			arr = {1, 2, 3, 5, 3, 2, 1, 4, 5, 6, 6} 
			Output: 
			4 
			Explaination: 4 is the only single.
			Your Task:
				You do not need to read input or print anything. Your task is to complete the function findSingle() which takes the size of the array n and the array arr[] as input parameters and returns the only single person.

				Expected Time Complexity: O(n)
				Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ n ≤ 10^4
				1 ≤ arr[i] ≤ 10^6

		class Solution{
			public:
			int findSingle(int n, int arr[]){
				int ans=0;
				for(int i=0; i<n; i++)
					ans ^= arr[i];
					
				return ans;
			}
		};

	674) Missing number in shuffled array:
		Problem statement:
			Given an array A of size N. The contents of A are copied into another array B and numbers are shuffled. Also, one element is removed from B. The task is to find the missing element.
			Example 1:
			Input : 
			A[] = {4, 8, 1, 3, 7}
			B[] = {7, 4, 3, 1}
			Output : 8
			Explanation:
			8 is the only element missing from B.
			
			Example 2:
			Input : 
			A[] = {12, 10, 15, 23, 11, 30}
			B[] = {15, 12, 23, 11, 30}
			Output : 10

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function findMissing() which takes the array A[], B[] and its size N and N-1, respectively as inputs and returns the missing number.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)
			

			Constraints:
				2 <= N <= 10^6
				1 <= A, B <= 10^18
				Array may also contain duplicates.

		class Solution{
			public:
			long long findMissing(long long a[], long long b[], int n) {
				long long ans;
				sort(a, a+n);
				sort(b, b+(n-1));
				
				for(int i=0; i<(n-1); i++){
					if(a[i] != b[i])
						return a[i];
				}
				
				ans = a[n-1];
				return ans;
			}
		};
	
	675) Sum Of Digits:	
		Problem statement:
			Given a number, N. Find the sum of all the digits of N
			Example 1:
			Input:
			N = 12
			Output:
			3
			Explanation:
			Sum of 12's digits:
			1 + 2 = 3
			Example 2:
			Input:
			N = 23
			Output
			5
			Explanation:
			Sum of 23's digits:
			2 + 3 = 5

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function sumOfDigits() which takes an integer N as input parameters and returns an integer, total sum of digits of N.

			Expected Time Complexity: O(log10N)
			Expected Space Complexity: O(1)
			
			Constraints:
				1<=N<=10^5

		class Solution{
			public:
			int sumOfDigits(int N){
				int s=0;
				
				while(N){
					s += N%10;
					N /= 10;
				}
				return s;
			}
		};
	
	#CN WeeklyContest-121:
		676) Candies Distribution:
			Problem statement
				You have ‘N’ candies that need to be distributed among ‘3’ children, ‘c1’, ‘c2’, and ‘c3’. The distribution must follow the given rules:

				Each candy should be given to exactly one student.
				Each student should receive at least one candy.
				The number of candies given to ‘c2’ must be greater than the candies given to ‘c1’.
				The number of candies given to ‘c3’ must be greater than the candies given to ‘c2’.
				You have to tell whether it is possible to distribute ‘N’ candies among ‘3’ children by following the given rules.

				Your task is to tell whether it is possible to distribute ‘N’ candies among ‘3’ children and return ‘1’, if possible, otherwise return ‘0’.

				Example:
				‘N’ = 12

				One of the possible ways is to distribute first ‘2’ candies to ‘c1’, then next ‘4’ candies to ‘c2’, and the last ‘6’ candies to ‘c3’. The distribution is following all the given rules.
				So, the answer for this example is ‘1’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^9

				Time Limit: 1 sec 
				Sample Input 1:
				2
				15
				2
				Sample Output 1:
				1
				0
				Explanation of sample input 1:
				For test case 1:
				One of the possible ways is to distribute first ‘3’ candies to ‘c1’, then next ‘5’ candies to ‘c2’, and the last ‘7’ candies to ‘c3’. The distribution is following all the given rules.

				For test case 2:
				It is impossible to distribute ‘2’ candies among ‘3’ children by following the given rules. So, the answer for this test case is ‘0.
				Sample Input 2:
				2
				9
				3
				Sample Output 2:
				1
				0

			int candiesDistribution (int n) {
				return (n >= 6) ? 1 : 0;  
			}

		677) Swap Function:
			Problem statement
				Given two strings of lowercase English letters 'A' and 'B', each of length 'N',
				The function 'F(A, B)' efficiently checks whether making both strings equal by performing a single swap operation is possible. The operation entails choosing indices 'i' and 'j', and swapping the characters 'A[i]' and 'B[j]'.
				Your task is to write the function 'F', which should return '1' if it's possible to make the strings equal using this operation exactly once, and '0' otherwise.

				Example:
				'N' = 4
				'A' = 'accd'
				'B' = 'abbd'
				Choose 'i = 2' and 'j = 3', the new strings will be as follows:
				'A' = 'accd' → 'abcd'
				'B' = 'abbd' → 'abcd'

				So, the answer is '1'.
				Constraints:
					1 <= T <= 10
					1 <= N <= 10^5
					'a' <= A[i] <= 'z'
					'a' <= B[i] <= 'z'

					It is guaranteed that the sum of 'N' overall test cases won't exceed '10^5'.
					Time Limit: 1 second
				Sample Input 1:
					2
					3
					sdv
					kiv
					3
					nnz
					mmz
					Sample Output 1:
					0
					1
					Explanation Of Sample Input 1:
					For test case 1:
					There is no way we can make both strings equal by doing an operation.
					So, the answer is '0'.

					For test case 2:
					Choose 'i = 1' and 'j = 2', the new strings will be as follows:
					'A' = 'nnz' → 'mnz'
					'B' = 'mmz' → 'mnz'

					So, the answer is '1'.
					Sample Input 2:
					2
					6
					emgpwp
					pgemwp
					5
					sqrpz
					asgvr
					Sample Output 2:
					0
					0


			// Not Optimized:
				int isEqualPossible(int n, string a, string b) {
					sort(begin(a), end(a));
					sort(begin(b), end(b));
					if(a == b)
						return 0;

					map<char, int> F;
					// if F contains only even Frequencies then it will return 1 else 0;
					for(char ch: a)
						F[ch]++;
					
					for(char ch: b)
						F[ch]++;

					// if the item count is odd then it is not possible, even after swap function.
					for(auto itr: F)
						if(itr.second % 2 != 0)
							return 0;

					return 1;    
				}
			
			// Optimized:
				int isEqualPossible(int n, string a, string b) {
					vector<int> diffPos;
					for(int i=0; i<n; i++)
						if(a[i] != b[i])
							diffPos.push_back(i);
						
					if(diffPos.size() == 0)
						return 0;

					if(diffPos.size() == 2)
						if(a[diffPos[0]] == a[diffPos[1]] && b[diffPos[0]] == b[diffPos[1]])
							return 1;
					
					return 0;
				}

	678) Sum of Products:
		Problem statement:
			Given an array arr[] of size n. Calculate the sum of Bitwise ANDs ie: calculate sum of arr[i] & arr[j] for all the pairs in the given array arr[] where i < j.
			Example 1:
			Input:
			n = 3
			arr = {5, 10, 15}
			Output:
			15
			Explanation:
			The bitwise Ands of all pairs where i<j are (5&10) = 0, (5&15) = 5 and (10&15) = 10.
			Therefore, the total sum = (0+5+10) = 15.

			Example 2:
			Input:
			n = 4
			arr = {10, 20, 30, 40}
			Output:
			46
			Explanation:
			The sum of bitwise Ands 
			of all pairs = (0+10+8+20+0+8) = 46.
			Your Task:
			You don't need to read input or print anything.Your Task is to complete the function pairAndSum() which takes an Integer n and an array arr[]  of size n as input parameters and returns the sum of bitwise Ands of all pairs.

			Expected Time Complexity:O(n)
			Expected Auxillary Space:O(1)

			Constraints:
				1 <= n <= 10^5
				1 <= arr[i] <= 10^8

		// Not Optimized:
			class Solution {
				public:
				long long pairAndSum(int n, long long arr[]) {
					long long sum=0;
				
					for(int i=0; i<n; i++)
						for(int j=i+1; j<n; j++)
							sum += (arr[i]&arr[j]);
					
					return sum;
				}
			};
		
		// Optimized:
			❌Pending

	679) Complete Sum:
		Problem statement
			Ninja has an array ‘A’ of size ‘N’. He recently created a topic ‘Complete Sum’ and defined the term ‘completeSum[i]’ = Sum ( A[0] … A[i] ).
			Output the complete sum array of array ‘A’.
			Example :
			N = 3
			A = [ 1, 2, 3 ] 

			Explanation : 
			Complete sum for index 0 is ‘A[0]=1’.
			Complete sum for index 1 is ‘A[0] + A[1]’ = 3.
			Complete sum for index 2 is ‘A[0] + A[1] + A[2]’ = 6.
			So, we output [ 1, 3, 6 ].
			Constraints :
				1 <= T <= 5
				1 <= N <= 10^5
				0 <= A[i] <= 10^4

				Time Limit : 1 sec
			Sample Input 1 :
				2
				3
				3 1 2
				4
				1 1 1 1
				Sample Output 1 :
				3 4 6
				1 2 3 4
				Explanation Of Sample Input 1 :
				For test case 1 we have, 
				Complete sum for index 0 is ‘A[0]=3’.
				Complete sum for index 1 is ‘A[0] + A[1]’ = 4.
				Complete sum for index 2 is ‘A[0] + A[1] + A[2]’ = 6.
				So, we output [ 3, 4, 6 ].

				For test case 2 we have, 
				Complete sum for index 0 is ‘A[0]=1’.
				Complete sum for index 1 is ‘A[0] + A[1]’ = 2.
				Complete sum for index 2 is ‘A[0] + A[1] + A[2]’ = 3
				Complete sum for index 3 is ‘A[0] + A[1] + A[2] + A[3]’ = 4.

				So, we output [ 1, 2, 3, 4 ].
				Sample Input 2 :
				2
				2
				7 2 
				5
				4 1 7 5 1     
				Sample Output 2 :
				7 9
				4 5 12 17 18

		#include <bits/stdc++.h> 
		vector<int> completeSum(vector<int> &a, int n) {
			vector<int> ans(n);
			int sum=0;
			for(int i=0; i<n; i++){
				sum += a[i];
				ans[i] = sum;
			}
			return ans;
		}

		// or
			#include <bits/stdc++.h> 
			vector<int> completeSum(vector<int> &a, int n) {
				vector<int> ans(n);
				ans[0] = a[0];

				for(int i=1; i<n; i++)
					ans[i] = ans[i-1] + a[i];

				return ans;
			}

	680) Print all Divisors of a number:
		Problem statement
			Given an integer ‘N’, your task is to write a program that returns all the divisors of ‘N’ in ascending order.
			For example:
			'N' = 5.
			The divisors of 5 are 1, 5.
			Sample Input 1 :
			10
			Sample Output 1 :
			1 2 5 10
			Explanation of Sample Input 1:
			The divisors of 10 are 1,2,5,10.
			Sample Input 2 :
			6
			Sample Output 2 :
			1 2 3 6
			Explanation of Sample Input 2:
			The divisors of 6 are 1, 2, 3, and 6.
			Constraints :
			1 <= 'N' <= 10^5 

		int* printDivisors(int n, int &size){
			vector<int> holder;

			for(int i=1; i<=n; i++)
				if(n % i == 0)
					holder.push_back(i);

			size = holder.size();
			int  *divisors = new int[size];

			for(int i=0; i<size; i++)
				divisors[i] = holder[i];

			return divisors;
		}

	681) Super score of Array
		Problem statement
			Ninja is in search of happiness.
			Ninja has 'N' integers in an array 'ARR', he wants to find the super score of the
			array 'ARR' to find happiness.
			The super score of the array is defined as the sum of the scores of all subarrays
			in the array.
			The score of a subarray is defined as the square of the minimum element in the
			array.
			Can you find the Super score for the given array and help Ninja in finding
			happiness?
			Example :
			N = 3
			ARR = [1,2, 3]
			The six subarrays and their respective scores are
			[1]1.1
			[1.2]1,
			[1,2,3]1,
			[2]4.
			[2, 3]4.
			[3]9
			The score of the array 'ARR' is '1 + 1 + 1 + 4 + 4 + 9' = 20.

			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5
				1 <= ARR[i] <= 1e3
				Sum of N <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
			2
			4
			1 2 3 4
			1
			5
			Sample Output 1 :
			50
			25
			Explanation Of Sample Input 1 :
			For test case 1,
			We will get, '1 * 1' as '1' from subarrays { [ 1]. [ 1, 2]. [ 1, 2, 3 ]. [ 1, 2, 3. 4]}
			, '2 * 2' as '4' from { [ 2]. [2, 3]. [2, 3, 4]}. '3 * 3' as '9' { [3]. [ 3, 4] } and '4
			* 4' ( [4]). so answer is 4 * 1 + 3 * 4 + 2 * 9 + 1 * 16 = 50.
			For test case 2,
			There is only one subarray '5 * 5' so the answer is '25.
			Sample Input 2:
			2
			2
			4 4
			3
			0 3 0
			Sample Output 2 :
			48
			9

		// Not Optimized:
			#include <bits/stdc++.h> 
			long long int superScore(int n, vector < int > arr) {
				long long sum=0;

				for(int i=0; i<n; i++){
					vector<int> holder;
					for(int j=i; j<n; j++){
					holder.push_back(arr[j]);
					int minE = *min_element(holder.begin(), holder.end());
					minE *= minE;
					sum += minE;
					}
				}
				return sum;
			}

			// Little bit optimized:
				#include <bits/stdc++.h> 
				long long int superScore(int n, vector < int > arr) {
					long long sum=0;

					for(int i=0; i<n; i++){
						int minE = arr[i];
						for(int j=i; j<n; j++){
							minE = min(minE, arr[j]);
							sum += (minE*minE);
						}
					}
					return sum;
				}
	
		// Optimized:
			❌Pending

	#LeetCode BiweeklyContest-128:
		682) Score of a String:
			Problem statement:
				You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.
				Return the score of s.
			
				Example 1:
				Input: s = "hello"
				Output: 13
				Explanation:
				The ASCII values of the characters in s are: 'h' = 104, 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13.

				Example 2:
				Input: s = "zaz"
				Output: 50
				Explanation:
				The ASCII values of the characters in s are: 'z' = 122, 'a' = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50.

				Constraints:
					2 <= s.length <= 100
					s consists only of lowercase English letters.
					
			class Solution {
				public:
				int scoreOfString(string s) {
					int scr=0;
					
					for(int i=0; i<s.size()-1; i++)
						scr += abs(s[i]-s[i+1]);
					
					return scr;        
				}
			};

		683) Find the Number of Subarrays Where Boundary Elements Are Maximum:
			Problem statement:
				You are given an array of positive integers nums.
				Return the number of subarrays of nums, where the first and the last elements of the subarray are equal to the largest element in the subarray.

				Example 1:
				Input: nums = [1,4,3,3,2]
				Output: 6

				Explanation:
				There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:
				subarray [1,4,3,3,2], with its largest element 1. The first element is 1 and the last element is also 1.
				subarray [1,4,3,3,2], with its largest element 4. The first element is 4 and the last element is also 4.
				subarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [1,4,3,3,2], with its largest element 2. The first element is 2 and the last element is also 2.
				subarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.
				Hence, we return 6.

				Example 2:
				Input: nums = [3,3,3]
				Output: 6
				Explanation:
				There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:
				subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
				subarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.
				Hence, we return 6.

				Example 3:
				Input: nums = [1]
				Output: 1
				Explanation:
				There is a single subarray of nums which is [1], with its largest element 1. The first element is 1 and the last element is also 1.
				Hence, we return 1.
			
				Constraints:
					1 <= nums.length <= 10^5
					1 <= nums[i] <= 10^9

			// Not Optimized:
				class Solution {
					public:
					long long numberOfSubarrays(vector<int>& nums) {
						long long ans = nums.size();
						
						for(int i=0; i<nums.size(); i++){
							int first = nums[i], mx = nums[i];
							for(int j=i+1; j<nums.size(); j++){
								int last = nums[j];
								if(mx <= nums[j])
									mx = nums[j];
								
								if(first == mx && last == mx)
									ans++;
							}
						}
						return ans;
					}
				};
		
	#LeetCode WeeklyContest-393:
		684) Latest Time You Can Obtain After Replacing Characters:
			Problem statement:
				You are given a string s representing a 12-hour format time where some of the digits (possibly none) are replaced with a "?".
				12-hour times are formatted as "HH:MM", where HH is between 00 and 11, and MM is between 00 and 59. The earliest 12-hour time is 00:00, and the latest is 11:59.
				You have to replace all the "?" characters in s with digits such that the time we obtain by the resulting string is a valid 12-hour format time and is the latest possible.
				Return the resulting string.
		
				Example 1:
				Input: s = "1?:?4"
				Output: "11:54"
				Explanation: The latest 12-hour format time we can achieve by replacing "?" characters is "11:54".

				Example 2:
				Input: s = "0?:5?"
				Output: "09:59"
				Explanation: The latest 12-hour format time we can achieve by replacing "?" characters is "09:59".			

				Constraints:
					s.length == 5
					s[2] is equal to the character ":".
					All characters except s[2] are digits or "?" characters.
					The input is generated such that there is at least one time between "00:00" and "11:59" that you can obtain after replacing the "?" characters.

			class Solution {
				public:
				string findLatestTime(string s) {
					if(s[3] == '?')
							s[3] = '5';
					
					if(s[4] == '?')
						s[4] = '9';
					
					if(s[0] == '0' && s[1] == '?')
						s[1] = '9';
				
					if(s[0] == '1' && s[1] == '?')
						s[1] = '1';        
					
					if((s[1] == '1' || s[1] == '0') && s[0] == '?')
						s[0] = '1';
					
					if(s[0] == '?' && s[1] == '?')
						s[0] = s[1] = '1';
					else if(s[1] != '1' && s[0] == '?')
						s[0] = '0';
					
					return s;
				}
			};
	
		685) Kth Smallest Amount With Single Denomination Combination:
			Problem statement:
				You are given an integer array coins representing coins of different denominations and an integer k.
				You have an infinite number of coins of each denomination. However, you are not allowed to combine coins of different denominations.
				Return the kth smallest amount that can be made using these coins.
		
				Example 1:
				Input: coins = [3,6,9], k = 3
				Output:  9
				Explanation: The given coins can make the following amounts:
				Coin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.
				Coin 6 produces multiples of 6: 6, 12, 18, 24, etc.
				Coin 9 produces multiples of 9: 9, 18, 27, 36, etc.
				All of the coins combined produce: 3, 6, 9, 12, 15, etc.

				Example 2:
				Input: coins = [5,2], k = 7
				Output: 12 
				Explanation: The given coins can make the following amounts:
				Coin 5 produces multiples of 5: 5, 10, 15, 20, etc.
				Coin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.
				All of the coins combined produce: 2, 4, 5, 6, 8, 10, 12, 14, 15, etc.
		
				Constraints:
					1 <= coins.length <= 15
					1 <= coins[i] <= 25
					1 <= k <= 2 * 10^9
					coins contains pairwise distinct integers.
				
			// Memory Limit Exceeded:
				class Solution {
					public:
					long long findKthSmallest(vector<int>& coins, int k) {
						
						vector<long long> holder;
						for(int i=0; i<coins.size(); i++){
							int val = coins[i];
							holder.push_back(val);
							int temp = k;
							
							while(temp--)
								holder.push_back(holder.back() + val);

						}
						set<long long> unique (holder.begin(), holder.end());
						holder.assign(unique.begin(), unique.end());
						return holder[k-1];
					}
				};

		686) Maximum Prime Difference:
			Problem statement:
				You are given an integer array nums.
				Return an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.
		
				Example 1:
				Input: nums = [4,2,9,5,3]
				Output: 3
				Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is |4 - 1| = 3.

				Example 2:
				Input: nums = [4,8,2,8]
				Output: 0
				Explanation: nums[2] is prime. Because there is just one prime number, the answer is |2 - 2| = 0.			

				Constraints:
					1 <= nums.length <= 3 * 10^5
					1 <= nums[i] <= 100
					The input is generated such that the number of prime numbers in the nums is at least one.
			auto speedUp = [](){
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);
				return 0;
			}();

			class Solution {
				public:
				bool isPrime(int n){
					if(n < 2)
						return 0;

					int itr = 2;
					while(itr <= n/2){
						if(n % itr == 0)
							return 0;
						itr++;
					}
					return 1;
				}
				int maximumPrimeDifference(vector<int>& nums) {
					vector<int> indicesHolder;
					
					for(int i=0; i<nums.size(); i++)
						if(isPrime(nums[i]))
							indicesHolder.push_back(i);

					return abs(indicesHolder.back() - indicesHolder[0]);
				}
			};
	
	687) Xoring and Clearing:
		Problem Statement:
			You are given an array arr[] of size n. You need to do the following:
			You need to calculate the bitwise XOR of each element in the array with its corresponding index (indices start from 0).
			After step1, print the array.
			Now, set all the elements of arr[] to zero.
			Now, print arr[].

			Example 1:
			Input:
			n = 10
			arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
			Output:
			1 3 1 7 1 3 1 15 1 3
			0 0 0 0 0 0 0 0 0 0
			Explanation:
			First we take xor of every element with
			their indices, like (1xor0), (2xor1), (3xor2), (4xor3) and so on.
			Now print the resultant array
			Now set all the elements of array to zero
			Now print the resultant array

			Example 2:
			Input:
			n = 4
			arr[] = {10, 20, 30, 40}
			Output:
			10 21 28 43
			0 0 0 0
			Explanation:
			First we take xor of every element with
			their indices, like (1xor0), (2xor1), (3xor2).
			Now print the resultant array
			Now set all the elements of array to zero
			Now print the resultant array
			Your Task:
			Since this is a function problem, you don't need to take any input. Just complete the provided functions. In a new line, print the output.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 1000
				1 <= arr[i] <= 1000

		class Solution {
			public:
			void printArr(int n, int arr[]) {
				for(int i=0; i<n; i++)
					cout<<arr[i]<<" ";
				cout<<endl;
			}

			void setToZero(int n, int arr[]) {
				for(int i=0; i<n; i++)
					arr[i] = 0;
			}

			void xor1ToN(int n, int arr[]) {
				for(int i=1; i<n; i++)
					arr[i] ^= i;
			}
		};
	
	688) Count the elements:
		Problem statement:
			Given two arrays a and b both of size n. Given q queries in an arrray query each having a positive integer x denoting an index of the array a. For each query, your task is to find all the elements less than or equal to a[x] in the array b.
			Example 1:

			Input:
			n = 3
			a[] = {4,1,2}
			b[] = {1,7,3}
			q = 2
			query[] = {0,1}
			Output : 
			2
			1

			Explanation: 
			For 1st query, the given index is 0, a[0] = 4. There are 2 elements(1 and 3) which are less than or equal to 4.
			For 2nd query, the given index is 1, a[1] = 1. There exists only 1 element(1) which is less than or equal to 1.

			Example 2:
			Input:
			n = 4
			a[] = {1,1,5,5}
			b[] = {0,1,2,3}
			q = 4
			query[] = {0,1,2,3}
			Output : 
			2
			2
			4
			4
			Explanation: 
			For 1st query and 2nd query, the given index is 0 and 1 respectively, a[0] = a[1] = 1. There are 2 elements(0 and 1) which are less than or equal to 1. 
			For 3rd query and 4th query, the given index is 2 and 3 respectively, a[2] = a[3] = 5. All the 4 elements are less than or equal to 5.   

			Your Task:
				You don't need to take any input, as it is already accomplished by the driver code. You just need to complete the function countElements() that takes array a and b of size n, and array query of size q as parameters and returns an array that contains the answer to the corresponding queries. 

				Expected Time Complexity: O(n+q+maximum of a and b).
				Expected Auxiliary Space: O(maximum of a and b).

			Constraints:
				1 ≤ q ≤ n ≤ 10^5
				1 ≤ a[i], b[i] ≤ 10^5
				0 ≤ query[i] < n

		// Not Optimized:
			class Solution {
				public:
				vector<int> countElements(vector<int> &a, vector<int> &b, int n, vector<int> &query, int q) {
					vector<int> ans;
					for(int i=0; i<q; i++){
						int val = a[query[i]];
						
						int cnt=0;
						for(int z=0; z<n; z++)
							if(b[z] <= val)
								cnt++;
							
						ans.push_back(cnt);
					}
					
					return ans;
				}
			};
	
		// Optimized:
			class Solution {
				public:
				int GreaterElementIndex(vector<int> b, int n, int val){
					int s=0, e = n-1;
					while(s <= e){
						int mid = e + (s-e)/2;
						if(b[mid] == val){
							s = mid + 1;
						}else if(b[mid] > val){
							e = mid - 1;
						}else{
							s = mid + 1;
						}
					}
					return s;
				}
				vector<int> countElements(vector<int> &a, vector<int> &b, int n, vector<int> &query, int q) {
					vector<int> ans;
					sort(b.begin(), b.end());
					
					for(int i=0; i<q; i++){
						int val = a[query[i]];
						
						int index = GreaterElementIndex(b, n, val);
						ans.push_back(index);
					}
					return ans;
				}
			};

	689) Sort Odd Even:
		Problem statement
			You are given a 0-indexed array ‘NUMS’ consisting of ‘N’ integers. Sort the array ‘NUMS’ in such a way that the first half of the array contains only odd numbers sorted in non-increasing order and the second half contains only even numbers sorted in non-decreasing order.

			Example:
			Input: ‘N’ = 4,  ‘NUMS’ = [2, 5, 3, 6] 
			Output: [5, 3, 2, 6]

			Sorting the odd numbers of the array ‘NUMS’ in non-increasing order, the result is 5, 3
			Then, Sorting the even numbers in non-decreasing order, the result is 2, 6.
			Since the final array should contain the odd numbers in non-increasing order in the first half and even numbers in non-decreasing order in the other half.
			So, the final array is [5, 3, 2, 6].
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^5
				Sum of ‘N’ <= 10^5
				1 <= NUMS[i] <= 10^9

				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				9 4 2 6
				2
				2 1
				Sample Output 1 :
				9 2 4 6
				1 2
				Explanation Of Sample Input 1 :
				For the first case:
				Sorting odd integers in non-increasing order we get = 9
				Sorting even integers in non-decreasing order we get = 2 4 6
				So, the final array is [9, 2, 4, 6].    

				For the second case:
				Sorting odd integers in non-increasing order we get = 1
				Sorting even integers in non-decreasing order we get = 2
				So, the final array is [1, 2].
				Sample Input 2 :
				2
				6
				20 12 1 28 16 20 
				5
				2 14 29 21 11 
				Sample Output 2 :
				1 12 16 20 20 28
				29 21 11 2 14 

		#include <bits/stdc++.h> 
		void sortOddEven(vector<int>& nums){
			vector<int>  odds, evens;

			sort(nums.begin(), nums.end());
			
			for(int i: nums)
				if(i&1)
					odds.push_back(i);
				else
					evens.push_back(i);
				
			nums.clear();
			reverse(odds.begin(), odds.end());
			nums.assign(odds.begin(), odds.end());
			
			copy(evens.begin(), evens.end(), back_inserter(nums));
		}
	
	690) Minimize the Difference:
		Problem statement:
			You are given an array arr of size n. You have to remove a subarray of size k , such that the difference between the maximum and minimum values of the remaining array is minimized.
			Find the minimum value obtained after performing the operation of the removal of the subarray and return it.

			Example 1:
			Input:
			n = 5
			k = 3
			arr = {1, 2, 3, 4, 5}
			Output: 
			1
			Explanation: 
			We can remove first subarray of length 3(i.e. {1, 2, 3}) then remaining array will be {4,5} and the difference of maximum and minimum element will be 1 i.e 5 - 4 = 1

			Example 2:
			Input:
			n = 6
			k = 3
			arr = {2, 3, 1, 4, 6, 7}
			Output: 
			2
			Explanation:
			If we remove the subarray {2,3,1} then remaining array will be {4,6,7} and the difference  = 7-4 = 3
			If we remove the subarray {3,1,4} then remaining array will be {2,6,7} and the difference  = 7-2 = 5
			If we remove the subarray {1,4,6} then remaining array will be {2,3,7} and the difference  = 7-2 = 5
			If we remove the subarray {4,6,7} then remaining array will be {2,3,1} and the difference  = 3-1 = 2
			So the answer will be min(3,5,5,2) = 2

			Your Task: 
				You have to complete the function minimizeDifference( ), which takes two integers n and k and an integer array arr of size n. You have to return the minimum difference of maximum and minimum elements of the remaining array after removing one k length subarray of it.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				2 <= n <= 10^5
				1 <= k <= n-1
				0 <= arr[i] <= 10^9

		// Not Optimized:
			class Solution {
				public:
				int minimizeDifference(int n, int k, vector<int> &arr) {
					int minValue = INT_MAX;
					
					int itr = 0;
					while(itr <= (n-k)){
						vector<int> holder;
						int i=0;
						
						
						for(; i<n; i++){
							if(itr == i)
								i += k;
							if(i < n)
								holder.push_back(arr[i]);
						}
						
						// for(int z: holder)
						//     cout<<z<<"\t";
						// cout<<endl;
						
						minValue = min(minValue, (*max_element(holder.begin(), holder.end()) - *min_element(holder.begin(), holder.end())));
						itr++;
					}
					return minValue;
				}
			};

		// Optimized:
			❌Pending

	691) Make Friends:
		Problem statement
			Ninja A meets with Ninja B at a party organized by coding ninjas, Both Ninjas Have eaten lots of sweets (sweet ids are from ‘a’ to ‘z’) that are in the represented in form of a string, Ninja ‘A’ becomes happy if they both eaten at least one common sweets.
			Your task is to tell whether ninjas A is happy or not.

			Example :
			A = hraems
			B = siamvh
			Sweet of id ‘a’ is eaten by both the ninjas so the answer is “Yes”. 
			Constraints :
				1 <= T <= 10
				1 <= Length of strings <= 10^5
				Time Limit: 1 sec

			Sample Input 1 :
			2
			hraems siamvh
			maih setww
			Sample Output 1 :
			Yes
			No
			Explanation Of Sample Input 1 :
			For test case 1, 
			Sweet of id ‘a’ is eaten by both the ninjas so the answer is “Yes”. 
			For test case 2,
			None of the sweet is eaten by both the ninjas so the answer is ‘No’.
			Sample Input 2 :
			2
			killer trigger 
			a bcd   
			Sample Output 2 :
			Yes
			No

		#include <bits/stdc++.h> 
		string IsFriend( string s1, string s2 ) {
			for(int i=0; i<s1.size(); i++)
				if(s2.find(s1[i]) != string::npos)
				return "Yes";

			return "No";
		}

		//or
			#include <bits/stdc++.h> 
			string IsFriend( string s1, string s2 ) {
				for(char ch: s1)
				if(s2.find(ch) != string::npos)
					return "Yes";

				return "No";
			}

		// More Optimized:
			#include <bits/stdc++.h> 
			string IsFriend( string s1, string s2 ) {
				vector<int> holder (26, 0);
				for(int i=0; i<s1.size(); i++)
					holder[s1[i]-'a'] = 1;

				for(int i=0; i<s2.size(); i++)
					if(holder[s2[i] - 'a'] == 1)
						return "Yes";

				return "No";
			}
		
		// or
			#include <bits/stdc++.h> 
			string IsFriend( string s1, string s2 ){
				int n;
				if(s1.size() < s2.size()){
					n = s1.size();

				}else{
					n = s2.size();
					swap(s1, s2);
				}
				
				for(int i=0; i<n; i++){
					if(s2.find(s1[i]) != string::npos)
						return "Yes";
				}
				return "No";
			}
	
	692) Count Pairs in an Array:
		Problem statement:
			Given an array arr of n integers, count all pairs (arr[i], arr[j]) in it such that i*arr[i] > j*arr[j] and 0 ≤ i < j < n.
			Note: 0-based Indexing is followed.

			Example 1:
				Input :
				n = 4
				arr[] = {8, 4, 2, 1}
				Output :
				2
				Explanation:
				If we see the array after operations
				[0*8, 1*4, 2*2, 3*1] => [0, 4, 4, 3]
				Pairs which hold the condition i*arr[i] > j*arr[j] are (4,1) and (2,1), so in total 2 pairs are available.

			Example 2:
				Input :
				n = 7
				arr[] = {5, 0, 10, 2, 4, 1, 6}
				Output:
				5
				Explanation :
				Pairs which hold the condition i*arr[i] > j*arr[j] are (10,2), (10,4), (10,1), (2,1) and (4,1), so in total 5 pairs are there.
				Your Task:  
				You don't need to read input or print anything. Your task is to complete the function countPairs() which takes the array arr[] and its size n as inputs and returns the required result.

			Expected Time Complexity: O(n*log(n))
			Expected Auxiliary Space: O(n*log(n))

			Constraints:
				1 ≤ n ≤ 10^4
				0 ≤ arr[i] ≤ 10^4

		// Not Optimized:
			class Solution{
				public:
				int countPairs(int arr[] , int n ) {
					
					vector<int> holder;
					for(int i=0; i<n; i++)
						holder.push_back(i*arr[i]);
						
					
					int cnt=0;
					
					for(int i=0; i<n; i++)
						for(int j=i+1; j<n; j++)
							if(holder[i] > holder[j])
								cnt++;
								
					return cnt;
				}
			};
		
		// Optimized:
			❌Pending

	693) Reverse Linked List:
		Problem statement:
			Given the head of a singly linked list, reverse the list, and return the reversed list.
			Example 1:
			Input: head = [1,2,3,4,5]
			Output: [5,4,3,2,1]

			Example 2:
			Input: head = [1,2]
			Output: [2,1]

			Example 3:
			Input: head = []
			Output: []
			
			Constraints:
				The number of nodes in the list is the range [0, 5000].
				-5000 <= Node.val <= 5000
			
			Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			ListNode* reverseList(ListNode* head) {
				ListNode* cur = head;
				ListNode* prev = NULL;

				while(cur != NULL){
					head = head -> next;
					cur-> next = prev;
					prev = cur;
					cur = head;
				}
				return prev;
			}
		};

	694) Reverse Linked List:
		Problem statement
			You are given a Singly Linked List of integers. You need to reverse the Linked List by changing the links between nodes.

			Example:
			Input:
			2 4 5 -1
			Output:
			5 4 2 -1

			Explanation: 2->4->5 is the initial linked list. If we reverse this, we get 5->4->2.
			Sample Input 1 :
			1 2 4 -1
			Sample Output 1 :
			4 2 1 -1
			Explanation for Sample Input 1 :
			1->2->4 is the initial linked list. If we reverse this, we get 4->2->1.
			Sample Input 2 :
			1
			1 1 1 -1
			Sample Output 2 :
			1 1 1 -1
			Constraints :
				1 <= 'N' <= 10^4
				0 <= 'data' <= 10^9
				Where 'N' is the number of nodes in the linked list.
				Time Limit: 1 sec

		/****************************************************************
			Following is the class structure of the Node class:

				class Node {
					public:
					int data;
					Node *next;
					Node() {
						this->data = 0;
						next = NULL;
					}
					Node(int data) {
						this->data = data;
						this->next = NULL;
					}
					Node(int data, Node* next) {
						this->data = data;
						this->next = next;
					}
				};
		*****************************************************************/

		Node* reverseLinkedList(Node *head) {
			Node * cur = head;
			Node * prev = nullptr;

			while(cur != nullptr){
				head = head -> next;
				cur -> next = prev;
				
				prev = cur;
				cur = head;
			}
			return  prev;
		}

		// recursive solution:
			void solve(Node * &H, Node *cur, Node *prev) {

				if(cur == nullptr){
					H = prev;
					return;
				}

				Node * temp = cur -> next;
				cur -> next = prev;
				prev = cur;
				cur = temp;
				
				solve(H, cur, prev);
			}

			Node* reverseLinkedList(Node *head) {

				// if LL contains 1 element or empty
				if(head == NULL  || head -> next == nullptr)
					return head;

				Node *cur = head, *prev = nullptr;
				
				solve(head, cur, prev);
				return head;
			}
	
	695) Middle Of Linked List:
		Problem statement
			Given a singly linked list of 'N' nodes. The objective is to determine the middle node of a singly linked list. However, if the list has an even number of nodes, we return the second middle node.
			Sample Input 1 :
			5
			1 2 3 4 5
			Sample Output 1 :
			3 4 5
			Explanation Of Sample Input 1 :
			We can clearly see that there are 5 elements in the linked list therefore the middle node is the node with value '3'.

			Sample Input 2 :
			6
			1 2 3 4 5 6
			Sample Output 2 :
			4 5 6
			Explanation Of Sample Input 2 :

			We can clearly see that there are 6 elements in the linked list and the middle nodes are  nodes with values 3 and 4 hence we return a second middle node having value '4'.
			Constraints :
				1 <= 'N' <= 10^4
				0 <= 'data' <= 10^3
			Where 'N' is the length of the linked list.
			Time Limit: 1 sec

		/*
			Following is the class structure of the Node class:
			class Node {
				public:
				int data;
				Node *next;
				Node() {
					this->data = 0;
					next = NULL;
				}
				Node(int data) {
					this->data = data; 
					this->next = NULL;
				}
				Node(int data, Node* next) {
					this->data = data;
					this->next = next;
				}
			};
		*/

		Node *findMiddle(Node *head) {
			Node * mid = nullptr;
			Node * temp = head;
			
			int fastCnt=0, slowCnt=0;
			while(head != nullptr){
				fastCnt++;
				if(fastCnt >= slowCnt*2 ){
					slowCnt++;
					if(mid == nullptr)
						mid = temp;
					else{
						mid = mid -> next;
					}
				}
				head = head -> next;
			}
			return mid;
		}

		// or Simpler:
			Node *findMiddle(Node *head) {
				int fastCnt=0, slowCnt=0;
				Node * mid = head;

				while(head != nullptr){
					if(fastCnt > slowCnt * 2){
						slowCnt ++ ;
						mid = mid -> next;
					}
					fastCnt++;
					head = head ->next;
				}
				return mid;
			}

		// or
			Node* Middle(Node *head){
				Node *slow = head, *fast = head;
				while(fast){
					fast = fast -> next;
					if(fast){
						fast = fast -> next;
						slow = slow -> next;
					}
				}
				return slow;
			}
	
		// Brute force:
			Node *findMiddle(Node *head) {
				Node * temp = head;

				// finding the length of LL
				int L =0;
				while(head){
					L++;
					head = head -> next;
				}

				int mid = L/2;
				while(mid--)
					temp = temp -> next;

				return temp;
			}

	696) Add One To Number: (Refer Q. 41)
		Problem statement
			Given a non-negative number represented as an array of digits, you have to add 1 to the number, i.e, increment the given number by one.
			The digits are stored such that the most significant digit is at the starting of the array and the least significant digit is at the end of the array.
			For Example
			If the given array is {1,5,2}, the returned array should be {1,5,3}.
			Note
			Input array can contain leading zeros, but the output array should not contain any leading zeros (even if the input array contains leading zeroes).
			For Example: 
			If the given array is {0,2}, the returned array should be {3}.
			Constraints
				1 <= T <= 10
				1 <= N <= 5 * 10^4
				0 <= Arr[i] <= 9

				Where Arr[i] is the i-th digit in the number.
			Sample Input 1
				3
				3
				1 2 3
				2
				9 9
				1
				4
				Sample Output 1
				1 2 4
				1 0 0
				5
				Explanation For Sample Input 1
				In the 1st test case, the number is 123 after adding 1 number becomes 124, hence the output will be {1,2,4}.

				In the 2nd test case, the number is 99 after adding 1 number becomes 100, hence the output will be {1,0,0}.

				In the 3rd test case, the number is 4 after adding 1 number becomes 5, hence the output will be {5}.
				Sample Input 2
				3
				4
				2 4 6 8 
				1
				0
				2
				0 2
				Sample Output 2
				2 4 6 9
				1
				3

		#include <bits/stdc++.h> 
		vector<int> addOneToNumber(vector<int> arr) {
			arr[arr.size()-1]++;

			int i=arr.size()-1, c=0;
			
			while(i >=0) {
				arr[i] += c;
				c =0;
				if(arr[i] < 10)
					break;
				
				c = arr[i] / 10;
				arr[i] %= 10;
				i--;
			}

			if(c != 0)
				arr.insert(arr.begin(), c);

			// removo leading zeros
			while(arr[0] == 0)
				arr.erase(arr.begin());
				
			return arr;
		}
		
	#CN BeginnerConstest-58:
		697) Maximum books:
			Problem statement
				You are given 'N' boxes numbered from '0' to 'N - 1' containing a different number of books in each box. More specifically there are 'A[i]' books in the box 'i'.
				As you don't like odd numbers you want to collect the maximum number of books from the boxes such that every box has an even number of books.
				Also keep in mind that no box should be empty (with a '0' number of books) after collecting the books.
				Return an integer denoting the maximum number of books you can collect and return '-1' if there doesn't exist a way to collect books such that conditions are satisfied.

				Example:
					N = 3
					A = [2, 5, 3]
					You can take '3' books from box '1' and '1' book from the box '2'. So every box has at least '1' book and all the boxes have an even number of books.
					It can be proved that you can not collect more than '4' books according to the given conditions.
					So, the answer for this case is '4'.
				Constraints:
					1 <= 'N' <= 10^5
					'0' <= A[i] <= '10^9'

					Time limit: 1 sec
				Sample input 1:
					2
					3
					0 2 3
					2
					2 3
					Sample output 1:
					-1
					1
					Explanation of sample input 1:
					For test case 1:
					It can be proved that there doesn't exist a way to collect books such that conditions are satisfied.
					So, the answer for this case is '-1'.

					For test case 2:
					You can take the '1' book from box '1'. So every box has at least '1' book and all the boxes have an even number of books.
					It can be proved that you can not collect more than '1' book according to the given conditions.
					So, the answer for this case is '1'.
					Sample input 2:
					2
					6
					4 2 5 4 3 2
					6
					2 3 4 3 2 3
					Sample output 2:
					8
					5
			
			int maximumBooks(int n, vector<int> &v) {
				int mxBooksTaken =0;

				for(int i=0; i<n; i++){
					if(v[i] == 0 || v[i] == 1)
						return -1;

					int val=0;
					if(v[i] > 2)
						val = v[i] - 2;
					mxBooksTaken += val;
				}
				return mxBooksTaken;
			}

		699) Equations:
			Problem statement
				You are given three numbers 'A', 'B' and 'C'.
				You have to find an array 'P' of size 3 such that:

				P[0] + P[1] = A
				P[0] + P[2] = B
				P[1] + P[2] = C
				It is guaranteed that an array P exists and all the elements of this array are integers.

				Example:
				'A' = 4
				'B' = 3
				'C' = 5

				'P' can be {1, 3, 2} as
				1 + 3 = 4 = A
				1 + 2 = 3 = B
				3 + 2 = 5 = C


				Constraints:
					1 <= 'T' <= 1000
					1 <= 'A','B' & 'C' <= 10^9
					Time Limit: 1 sec
					
				Sample Input 1:
					2
					7 8 11
					7 6 3
					Sample Output 1:
					2 5 6
					5 2 1
					Explanation of sample input 1:
					For test case 1:
					'P' can be {2, 3, 6} as
					2 + 5 = 7 = A
					2 + 6 = 8 = B
					5 + 6 = 11 = C

					For test case 2:
					'P' can be {5, 2, 1} as
					5 + 2 = 7 = A
					5 + 1 = 6 = B
					2 + 1 = 3 = C
					Sample Input 2:
					3
					16 14 16
					7 7 10
					6 9 11
					Sample Output 2:
					7 9 7
					2 5 5
					2 4 7


			vector<int> solve(int a,int b,int c) {
				int x,y,z;
				y = b - (a+c);
				y /= -2;

				// should take abs() of y that's why divided with -2, coz we want answer in +ve.
				x = a - y;
				z = c- y;

				vector<int> ans {x, y, z};
				
				return ans;
			}

		698) Duel Counter:
			Problem statement
				There are 'N' participants registered for an event on Coding Ninjas. The organizers decided to organize a duel and assigned random numbers to every participant. An array 'A' represents these numbers, where the 'i'-th element denotes the number provided by the Coding Ninjas team. This numbering is not unique and can be negative as well.
				In the event, there is a round of duels. To form a duel, the team decided to pair two participants with opposite numbers as opponents. Opposite numbering means if there is a duel between the participants 'i' and 'j', then 'A[i] + A[j]' needs to be equal to '0'.
				Your task is to find the count of possible duels.
				Example:
					'N' = 4
					'A' = [1, -1, 0, 1]

					The possible duels are as follows
					A Duel between participants '1' and '2'. A Duel between participants '2' and '3'. So, the answer is '2'.

				Constraints:
					1 <= T <= 10
					1 <= N <= 10^5
					-10^5 <= A[i] <= 10^5
					It is guaranteed that the sum of 'N' over all test cases won't exceed '10^5'.
					Time Limit: 1 second

				Sample Input 1:
					2
					4
					7 -7 3 -3 
					3
					5 -5 4 
					Sample Output 1:
					2
					1
					Explanation Of Sample Input 1:
					For test case 1:
					The possible duels are as follows
					- A Duel between participants '1' and '2'.
					- A Duel between participants '3' and '4'.
					So, the answer is '2'.

					For test case 2:
					The possible duels are as follows
					- A Duel between participants '1' and '2'.
					So, the answer is '1'.
					Sample Input 2:
					2
					6
					-12 2 12 -5 -2 5 
					5
					-3 -7 3 -6 6 
					Sample Output 2:
					3
					2


			// Not Optimized:
				long long countDuels(int n, vector<int> a) {
					long long pairCnt=0;

					for(int i=0; i<n ; i++)
						for(int j=i+1; j<n; j++)
							if(a[i] + a[j] == 0)
								pairCnt++;

					return pairCnt;
				}
			
			// Optimized:
				long long countDuels(int n, vector<int> a) {
					long long pairCnt=0;

					map<int, int> F_pos_holder;  
					map<int, int> F_neg_holder;

					for(int i=0; i<n ; i++){
						if(a[i] > 0)
							F_pos_holder[a[i]]++;
						else if(a[i] < 0)
							F_neg_holder[a[i]]++;
					}

					for(auto i: F_pos_holder){
						int val = -i.first, reps = i.second;
						if(F_neg_holder[val] != 0)
							pairCnt += reps * F_neg_holder[val];
					}		
					return pairCnt;
				}
			
		700) XORing the XORs:
				Problem statement
					You are given an array 'A' containing 'N' numbers and a two dimensional array 'Q' with 'M' queries. Each query is represented as a pair of indices ( ‘L’, ‘R’ ) indicating a subarray of 'A'.
					Your task is to find the XOR of XORs for all subarrays within each query range. In other words, you need to calculate the XOR of all elements in each subarray within the given query range and then XORing all these calculated XOR values together.
					Return an array of size ‘M’ which contains the answer for each query respectively.
					Example:
						‘N’ = [4, 1, 2, 3, 5]
						‘Q’ = [[2,4]]

						Return [2]
					The Query is on the subarray [1, 2, 3].
					All subarrays of the subarray are listed below with their XOR of elements.
						[1] -> 1
						[2] -> 2
						[3] -> 3
						[1, 2] -> 3
						[2, 3] -> 1
						[1, 2, 3] -> 0
						Finally, 1 ⊕ 2 ⊕ 3 ⊕ 3 ⊕ 1 ⊕ 0 = 2
					Constraints:
						1 <= ‘T’ <= 10
						1 <= ‘N’ <= 10^5
						1 <= ‘M’ <= 10^5
						1 <= ‘A[i]’ <= 10^9
						1 <= L[i],R[i] <= N

						Time Limit: 1 sec
					Sample Input 1:
						2
						9 1
						6 5 2 1 7 9 7 2 5 
						3 9
						6 1
						6 2 2 8 7 7 
						3 5
						Sample Output 1:
						7
						5
						Explanation of sample input 1:
						For both test cases:
						After calculating the XOR of XORs of all subarrays in the query subarray, we get these answers.
						For in depth explanation refer to the example above.
						Sample Input 2:
						3
						4 1
						6 10 8 8 
						4 4
						7 1
						9 1 10 5 8 1 10 
						5 7
						5 2
						6 5 1 10 2 
						5 5
						2 4
						Sample Output 2:
						8 
						2 
						2 15 

				// Not Optimized:
					int GenerateXOR(vector<int> temp){
						int val = 0;
						vector<int> holder;
						for(int i=0; i<temp.size(); i++){
							for(int j=i; j<temp.size(); j++){
								val ^= temp[j];
								holder.push_back(val);
							}
							val =0;
						}

						val = 0;
						for(int i=0; i<holder.size(); i++)
							val ^= holder[i];

						return val;
					}

					vector<int> xoRage(vector<int> &a, vector<vector<int>> &q){
						vector<int> subArr;
						for(int i=0; i<q.size(); i++){
							int s  = q[i][0], e = q[i][1];
							vector<int> holder;
							for(int z = s-1; z < e; z++)
								holder.push_back(a[z]);

							int val = GenerateXOR(holder);
							subArr.push_back(val);
						}
						return  subArr;
					}
				
				// Optimized:
					❌Pending

	701) Reverse Nodes in k-Group:
		Problem statement:
			Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
			k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.
			You may not alter the values in the list's nodes, only nodes themselves may be changed.

			Example 1:
			Input: head = [1,2,3,4,5], k = 2
			Output: [2,1,4,3,5]

			Example 2:
			Input: head = [1,2,3,4,5], k = 3
			Output: [3,2,1,4,5]
			
			Constraints:
			The number of nodes in the list is n.
			1 <= k <= n <= 5000
			0 <= Node.val <= 1000
			
			Follow-up: Can you solve the problem in O(1) extra memory space?

		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			int LL_len(ListNode* H){
				int l=0;
				while(H){
					l++;
					H = H -> next;
				}
				return l;
			}
			ListNode* reverseKGroup(ListNode* head, int k) {
				if(head == NULL || head->next == NULL)
					return head;

				if(LL_len(head) < k)
					return head;

				int cnt = k;
				ListNode* cur = head;
				ListNode* prev = NULL;

				while(cnt-- && cur){
					ListNode* temp = cur -> next;

					cur -> next = prev;
					prev = cur;

					cur = temp;
				}

				if(cur != NULL)
					head -> next = reverseKGroup(cur, k);
				
				return prev;
			}
		};
	
	702) Reverse a Linked List in groups of given size:
		Problem statement:
			Given a linked list of size N. The task is to reverse every k nodes (where k is an input to the function) in the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should be considered as a group and must be reversed (See Example 2 for clarification).
			Example 1:
			Input:
			LinkedList: 1->2->2->4->5->6->7->8
			K = 4
			Output: 4 2 2 1 8 7 6 5 
			Explanation: 
			The first 4 elements 1,2,2,4 are reversed first 
			and then the next 4 elements 5,6,7,8. Hence, the 
			resultant linked list is 4->2->2->1->8->7->6->5.

			Example 2:
			Input:
			LinkedList: 1->2->3->4->5
			K = 3
			Output: 3 2 1 5 4 
			Explanation: 
			The first 3 elements are 1,2,3 are reversed 
			first and then elements 4,5 are reversed.Hence, 
			the resultant linked list is 3->2->1->5->4.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function reverse() which should reverse the linked list in group of size k and return the head of the modified linked list.

			Expected Time Complexity : O(N)
			Expected Auxilliary Space : O(1)

			Constraints:
				1 <= N <= 10^5
				1 <= k <= N
		
		/*
			Reverse a linked list
			The input list will have at least one element  
			Return the node which points to the head of the new LinkedList
			Node is defined as 
			struct node {
				int data; 
				struct node* next;
			
				node(int x){
					data = x;
					next = NULL;
				}
			
			}*head;
		*/

		class Solution {
			public:
			struct node *reverseIt (struct node *head, int k) {
				if(head == NULL || head -> next == NULL)
					return head;
					
				int cnt = k;
				node* cur = head;
				node* prev = NULL;
				
				while(cnt-- && cur){
					node* temp = cur -> next;
					
					cur -> next = prev;
					prev = cur;
					cur = temp;
				}
				
				if(cur != NULL)
					head -> next = reverseIt(cur, k);
				
				return prev;
			}
		};
	
	703) Search in a Linked List:
		Problem statement
			You are given a Singly Linked List of integers with a head pointer. Every node of the Linked List has a value written on it.
			A sample Linked List:
			Now you have been given an integer value, 'K'. Your task is to check whether a node with a value equal to 'K' exists in the given linked list. Return 1 if node exists else return 0.

			Sample Input 1:
				3 6 2 7 9 -1
				2
				Sample Output 1:
				1
				Explanation for Sample Input 1:
				As value 2 exists in the given linked list. So we will return 1 in this case.

				Sample Input 2:
				1 2 3 7 -1
				7
				Sample Output 2:
				1
				Explanation for Sample Input 2:
				As the value 7 exists in the Linked List, our answer is 1.

				Expected Time Complexity:
				Try solving this in O(L).


			Constraints:
				1 <= 'L' <= 10^5
				1 <= 'data' <= 10^9 and 'data' != -1
				1 <= 'K' <= 10^9   

			Where 'L' represents the total number of nodes in the Linked List, 'data' represents the value at each node, and 'K' is the given integer.
			Time Limit: 1 sec.

		/****************************************************************
			Following is the class structure of the Node class:
			template <typename T>
			class Node {
			public:
				T data;
				Node<T> *next;
				Node() {
					this->data = 0;
					this->next = NULL;
				}
				Node(T data) {
					this->data = data;
					this->next = NULL;
				}
				Node(T data, T* next) {
					this->data = data;
					this->next = next;
				}
			};
		*****************************************************************/

		int searchInLinkedList(Node<int> *head, int k) {
			while(head){
				if(head -> data == k)
					return 1;
				head = head ->next;
			}
			return  0;
		}
	
	#Floyd’s Cycle Detection Algorithm:
		Floyd’s cycle detection algorithm is a pointer algorithm that uses only two pointers, moving through the sequence at different speeds. 
		Floyd's Cycle Detection Algorithm, well known as the ‘tortoise-hare’ algorithm. 
		704) Cycle Detection in a Singly Linked List: (Check If A Linked List Is Circular Linked List)
			Problem statement
				You are given a Singly Linked List of integers. Return true if it has a cycle, else return false.
				A cycle occurs when a node's next points back to a previous node in the list.
				Example:
				In the given linked list, there is a cycle, hence we return true.
				Sample Input 1 :
				1 2 3 4 -1
				1

				Sample Output 1 :
				true

				Explanation of Sample Input 1:
				The linked list given in the input is as follows:

				Sample Input 2 :
				1 2 3 4 -1
				0

				Sample Output 2 :
				true

				Explanation of Sample Input 2:
				The linked list given in the input is as follows:

				Sample Input 3 :
				5 -1
				-1

				Sample Output 3 :
				false

				Explanation of Sample Input 3:
				The linked list given in the input is as follows:

				Expected Time Complexity:
				Try to solve this problem in O(n).

				Expected Space Complexity:
				Try to solve this problem in O(1).

				Constraints :
					0 <= n <= 10^6
					-1 <= pos < n
					-10^9 <= data <= 10^9 and data != -1

				Where 'n' is the size of the singly linked list, 'pos' represents the position (0-indexed) in the linked list where the tail connects to, and 'data' is the Integer data of the singly linked list.
				Time Limit: 1 sec

			/****************************************************************
				Following is the class structure of the Node class:
				class Node {
					public:
						int data;
						Node *next;
						Node() {
							this->data = 0;
							next = NULL;
						}
						Node(int data) {
							this->data = data;
							this->next = NULL;
						}
						
						Node(int data, Node* next) {
							this->data = data;
							this->next = next;
						}
					};
			*****************************************************************/

			bool detectCycle(Node *head) {
				Node* hare = head;
				Node* tortoise = head;

				while(hare){
					hare = hare -> next;
					if(hare != NULL)
						hare = hare -> next;

					tortoise = tortoise -> next;
					
					if(tortoise == hare && hare != NULL)
						return 1;
				}
				return 0;
			}

			// OR using Map
				#include<bits/stdc++.h>
				bool detectCycle(Node *head) {
					map<Node*, bool> Vis;

					while(head) {
						Vis[head] = true;
						head = head -> next;
						if(Vis[head])
							return 1;
					}
					return 0;
				}
			
			// or not optimized: using vector & find function
				#include<bits/stdc++.h>
				bool detectCycle(Node *head) {
					vector<Node*> holder;
					while(head){
						if(find(holder.begin(), holder.end(), head) != holder.end())
							return 1;
							
						holder.push_back(head);
						head = head ->next;
					}

					return 0;
				}

		705) Linked List Cycle II:
			Problem statement
				You are given a singly linked list that may or may not contain a cycle. You are supposed to return the node where the cycle begins, if a cycle exists, else return 'NULL'.
				A cycle occurs when a node's next pointer returns to a previous node in the list.

				Example:
				In the given linked list, there is a cycle starting at position 0, hence we return 0.
				Sample Input 1 :
				1 2 3 4 -1
				1
				Sample Output 1 :
				1

				Explanation For Sample Input 1 :
				For the first test case,

				Sample Input 2 :
				1 2 3 4 -1
				0

				Sample Output 2 :
				0
				Explanation For Sample Input 2 :
				For the first test case,

				Follow-Up:
				Can you do this in O(n) time and using constant space?
				Constraints :
					-10^4 <= n <= 10^4
					-1 <= pos < n
					-10^9 <= data <= 10^9 and data != -1
					Time Limit: 1 sec

			/****************************************************************
				Following is the class structure of the Node class:
					class Node {
					public:
						int data;
						Node *next;
						Node() {
							this->data = 0;
							next = NULL;
						}
						Node(int data) {
							this->data = data;
							this->next = NULL;
						}
						Node(int data, Node* next) {
							this->data = data;
							this->next = next;
						}
					};
			*****************************************************************/

			Node *firstNode(Node *head) {

				// checking the LL contains a cycle or not
				Node *fast = head, *slow = head;

				while(fast) {
					fast = fast -> next;
					if(fast != nullptr)
						fast = fast -> next;
					
					// this condition states that cycle is not exist in LL
					if(fast == nullptr)
						return  nullptr;

					slow = slow -> next;

					// this stats that cycle is exist in LL
					if(slow == fast)
						break;
				}

				slow = head;		// followed the tutorial

				// if cycle found in LL 
				// set slow pointer back to head & check are slow and fast are same
				// if they are same then return slow/fast else increment both by one
				while(slow != fast){
					if(slow == fast)
						return slow;
					slow = slow -> next;
					fast = fast -> next;
				}
			}
	
	#CN WeeklyContest-122:
		706) Team Score:
			Problem statement
				There are ‘4’ rangers labelled from ‘0’ to ‘3’, each with a unique power denoted by integers ‘A’, ‘B’, ‘C’, and ‘D’. Your goal is to form ‘2’ teams, each consisting of ‘2’ rangers, with each ranger belonging to only one team.
				The score of the team is calculated by multiplying the powers of the rangers in that team.Your objective is to maximise the total score achieved by both teams.
				Your task is to tell the maximum total score of the two teams and return it.

				Example:
				‘A’ = 2
				‘B’ = 1
				‘C’ = 5
				‘D’ = 3

				‘1st way’: Put rangers with the powers ‘A’, ‘B’ in one team and ‘C’, ‘D’ in another team.
				Here, the total score will be equal to ‘((2 * 1) + (5 * 3))’ that is ‘17’.

				‘2nd way’: Put rangers with the powers ‘A’, ‘C’ in one team and ‘B’, ‘D’ in another team.
				Here, the total score will be equal to ‘((2 * 5) + (1 * 3))’ that is ‘13’.

				‘3rd way’: Put rangers with the powers ‘A’, ‘D’ in one team and ‘B’, ‘C’ in another team.
				Here, the total score will be equal to ‘((2 * 3) + (1 * 5))’ that is ‘11’.

				So, the maximum total score we can achieve is ‘17’.
				Constraints:
					1 <= 'T' <= 10
					0 <= ‘A’, ‘B’, ‘C’, ‘D’ <= 10^4

				Time Limit: 1 sec 
				Sample Input 1:
					2
					1 0 5 8
					0 1 0 2
					Sample Output 1:
					40
					2
					Explanation of sample input 1:
					For test case 1:
					Here, the most optimal way is to put rangers with the powers ‘A’, ‘B’ in one team and ‘C’, ‘D’ in another team. The score in this case will be equal to ‘((1 * 0) + (5 * 8))’ that is ‘40’.

					For test case 2:
					Here, the most optimal way is to put rangers with the powers ‘A’, ‘C’ in one team and ‘B’, ‘D’ in another team. The score in this case will be equal to ‘((0 * 0) + (2 * 2))’ that is ‘2’.
					Sample Input 2:
					2
					1 5 7 2
					0 1 0 0
					Sample Output 2:
					37
					0

			int teamScore (int a, int b, int c, int d) {
				int mxScore=0;
				mxScore = max(mxScore, (a*b)+(c*d));
				mxScore = max(mxScore, (a*c)+(b*d));
				mxScore = max(mxScore, (a*d)+(c*b));
				return mxScore;
			}
			
		707) Two cities:
			Problem statement
				You are given three integers 'X', 'Y', and 'Z' representing the coordinates of the location of three different cities. Also, you are given an integer 'S' representing your location. (Note that the coordinate system is '1'-dimensional)
				To travel from the coordinate 'A' to 'B', you need '| A - B |' units of time.
				You want to explore any two different cities in the minimum time. You can assume that the time for exploring the city is negligible.
				Find the minimum traveling time to travel to at least two different cities.
				Note that '| N |' represents the absolute value of 'N'.
				Example:
				X = -2
				Y = 0
				Z = 8
				S = 5
				You can use the path 'S' -> 'Y' -> 'X'. Traveling time for the same is '| 5 - 0 | + | 0 - (-2) |' = '7'.
				It can be proved that you can not explore two cities in less than '7' units of time.
				So, the answer for this case is '7'.
				Constraints:
					1 <= 'N' <= 10^5
					-10^8 <= 'X', 'Y', 'Z', 'S' <= 10^8
					It is guaranteed that given '4' integers are distinct.

					Time limit: 1 sec
				Sample input 1:
					2
					0 1 2 3 
					0 11 13 12
					Sample output 1:
					2
					3
					Explanation of sample input 1:
					For test case 1:
					You can use the path 'S' -> 'Z' -> 'Y'. Traveling time for the same is '| 3 - 2 | + | 2 - 1 |' = '2'.
					It can be proved that you can not explore two cities in less than '2' units of time.
					So, the answer for this case is '2'.


					For test case 2:
					You can use the path 'S' -> 'Y' -> 'Z'. Traveling time for the same is '| 12 - 11 | + | 11 - 13 |' = '3'.
					It can be proved that you can not explore two cities in less than '3' units of time.
					So, the answer for this case is '3'.
					Sample input 2:
					2
					-5 0 8 -4
					0 10 11 3
					Sample output 2:
					6
					8

			int minimumTime(int x, int y, int z, int s) {
				int ans = INT_MAX;

				ans = min(ans, abs(s-x)+abs(x-y));
				ans = min(ans, abs(s-y)+abs(y-x));
				
				ans = min(ans, abs(s-x)+abs(x-z));
				ans = min(ans, abs(s-z)+abs(z-x));

				ans = min(ans, abs(s-y)+abs(y-z));
				ans = min(ans, abs(s-z)+abs(z-y));   

				return ans;
			}
			
		708) String Maker:
			Problem statement
				A string 'S' is called a good string if there is no such 'S[i]' which is equal to 'S[i + 1]' and has 'M' distinct characters.
				You are given the number 'N', and your task is to find the lexicographically smallest string 'S'.
				A string 'a' is called lexicographically smaller than a string 'b' if and only if one of the following holds:
				'a' is a prefix of 'b', but 'a ≠ b'.
				in the first position where 'a' and 'b' differ, the string 'a' has a letter that appears earlier in the alphabet than the corresponding letter in 'b'.

				Example:
				'N' = 3
				'M' = 2

				The all possible good strings 'S' are:
				'S' = 'aba' 
				'S' = 'bab'

				The string 'S' = 'aba' is the lexicographically smallest string.
				So, the answer is 'aba'.
				Constraints:
					1 <= T <= 10
					1 <= N <= 10^5
					2 <= M <= min(26, N)
				It is guaranteed that the sum of 'N' over all test cases won't exceed '10^5'.
				Time Limit: 1 second

				Sample Input 1:
					2
					6 3
					7 2
					Sample Output 1:
					abababc
					ababab
					Explanation Of Sample Input 1:
					For test case 1:
					There are many possible good strings of length '7'(N), that contain '3'(M) distinct characters, but the string 'abababc' is the lexicographically smallest among them.
					So, the answer is 'abababc'.

					For test case 2:
					There are many possible good strings of length '6'(N), that contain '2(M) distinct characters, but the string 'ababab' is the lexicographically smallest among them.
					So, the answer is 'ababab'.
					Sample Input 2:
					2
					8 4
					8 3
					Sample Output 2:
					abababcd
					abababac

			string generateString(int n, int m) {
				vector<char> chars;
				char ch = 'a';

				int temp = m;
				while(temp--)
					chars.push_back(ch++);

				string ans;

				int val = m - 2, i=0;
				int looper = n - val;

				int flag = 0;
				while(looper--){
					ans += chars[i];
					(flag == 0) ? (flag =1, i++) : (flag =0, i--);
				}

				i = 2;
				while(val--)
					ans += chars[i++];

				return ans;
			}

		709) Score sum:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’. The score of some element ‘i’ is given by the minimum value of ‘(A[i] * A[j])’ where, ‘j’ <= ‘i’ and ‘(j | i)’ should be equal to ‘i’.
				Here ‘|’ denotes the bitwise ‘OR’ operation. You have to calculate the score of all the elements from ‘0’ to ‘N - 1’.
				Your task is to tell the sum of scores of all the elements from ‘0’ to ‘N - 1’ and return it.

				Example:
				‘N’ = 4
				‘A’ = [4, 10, 6, 2]

				For element ‘i’ = ‘0’:
				Only ‘j’ = ‘0’ follows the given condition which gives the score of ‘(A[0] * A[0])’ that is ‘16’.

				For element ‘i’ = ‘1’:
				Here, the score is given by taking ‘j’ = ‘0’, (as ‘0’ OR ‘1’ is ‘1’), which is ‘40’. We can also take ‘j’ = ‘1’ but it is not giving us a minimum value.

				For element ‘i’ = ‘2’:
				Here, the score is given by taking ‘j’ = ‘0’, which is ‘(4 * 6 = 24)’.

				For element ‘i’ = ‘3’:
				We can choose any value of ‘j’ from ‘0’ to ‘3’, all are following the given condition but the minimum value is given by  ‘j’ = ‘3’. So, the score of this element is ‘4’.

				The sum of scores of all the elements is: ‘84’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					0 <= A[i] <= 10^5

					Time Limit: 1 sec 
				Sample Input 1:
					2
					3
					1 5 0
					2
					2 4
					Sample Output 1:
					6
					12
					Explanation of sample input 1:
					For test case 1:
					For element ‘i’ = 0:
					Only ‘j’ = ‘0’ follows the given condition which gives the score of ‘(A[0] * A[0])’ that is ‘1’.

					For element ‘i’ = 1:
					Here, the score is given by taking ‘j’ = 0, which is ‘(1 * 5 = 5)’.

					For element ‘i’ = 2:
					Here, the score is given by taking ‘j’ = 2, which is ‘0’.
					Hence, the sum of scores of all the elements is ‘6’.

					For test case 2:
					For element ‘i’ = 0:
					Only ‘j’ = ‘0’ follows the given condition which gives the score of ‘(A[0] * A[0])’ that is ‘4’.

					For element ‘i’ = 1:
					Here, the score is given by taking ‘j’ = 0, which is ‘(2 * 4 = 8)’.

					Hence, the sum of scores of all the elements is ‘12’.
					Sample Input 2:
					2
					7
					11 2 0 12 4 30 11
					4
					12 1 1 0
					Sample Output 2:
					201
					146

			// Says Wrong:
				#include <bits/stdc++.h>
				long long scoreSum (int n, vector <int> &a) {
					long long total=0;
					for(int i=0; i<n; i++){
						long long curMin = INT_MAX;
						for(int j=0; j<=i; j++)
							if(i == (j|i))
								curMin = min(curMin, a[i]*a[j]*1LL);
								
						total += curMin;
					}
					return total;
				}
			
			// Optimized Working:
				#include <bits/stdc++.h>
				long long scoreSum (int n, vector <int> &a) {
					long long total=0;
					for(int i=0; i<n; i++){
						int small = a[i];
						for(int j=1; j<=i;j *= 2){
							if((i&j) == 0)
								continue;
							small = min(small, a[i^j]);
						}
						total += a[i] * small * 1LL;
						a[i] = small;
					}
					return total;
				}
		
	710) Find missing in second array:
		Problem statement:
			Given two arrays a of size n and b of size m, the task is to find numbers which are present in the first array, but not present in the second array.
			Example 1:
			Input: 
			n = 6, m = 5
			a[] = {1, 2, 3, 4, 5, 10}
			b[] = {2, 3, 1, 0, 5}
			Output: 
			4 10
			Explanation: 
			4 and 10 are present in first array, but not in second array.
			
			Example 2:
			Input: 
			n = 5, m = 5
			a[] = {4, 3, 5, 9, 11}
			b[] = {4, 9, 3, 11, 10}
			Output: 
			5  
			Explanation: 
			Second array does not contain element 5.

			Your Task:
				This is a function problem. You don't need to take any input, as it is already accomplished by the driver code. You just need to complete the function findMissing() that takes array a, array b, integer n, and integer m as parameters and returns an array that contains the missing elements and the order of the elements should be the same as they are in array a.

			Expected Time Complexity: O(n+m).
			Expected Auxiliary Space: O(m).

			Constraints:
				1 ≤ n, m ≤ 10^5
				-10^9 ≤ A[i], B[i] ≤ 10^9

		// Not Optimized
			class Solution{
				public:
				vector<int> findMissing(int a[], int b[], int n, int m) {
					vector<int> res;				
					for(int i=0; i<n; i++)
						if(find(b, b+m, a[i]) == b+m)
							res.push_back(a[i]);
					
					return res;
				} 
			};
		
		// Optimized:
			class Solution{
				public:
				vector<int> findMissing(int a[], int b[], int n, int m) {
					vector<int> res;
					set<int> temp (b, b+m);
					
					for(int i=0; i<n; i++)
						if(temp.find(a[i]) == temp.end())
							res.push_back(a[i]);
					
					return res;
				} 
			};

	711) Zig-Zag String: (Easy)
		Problem statement
			You are given a string ‘STR’ of size ‘N’ and an integer ‘M’ (the number of rows in the zig-zag pattern of ‘STR’). Your task is to return the string formed by concatenating all ‘M’ rows when string ‘STR’ is written in a row-wise zig-zag pattern.
			Example:
			N = 12, M = 3 and STR = ‘CODINGNINJAS’
			There are three rows (‘M = 3’) in the zig-zag pattern. Row one contains ‘CNN’, row two contains ‘OIGIJS’, and row three contains ‘DNA’. After concatenating the three rows, we get the string ‘CNNOIGIJSDNA’. So, the answer is ‘CNNOIGIJSDNA’.
			Note:
			1. The string ‘STR’ consists of capital letters only (i.e., characters from ‘A-Z’).
			Constraints:
				1 <= T <= 10^2
				1 <= N <= 10^3
				1 <= M <= N
				‘STR’ contains only ‘A-Z’ characters.
				Time Limit: 1 second

			Sample Input 1:
				2
				7 3
				ABCDEFG
				5 2
				NINJA
				Sample Output 1:
				AEBDFCG
				NNAIJ
				Explanation For Sample Input 1:
				Test Case 1:
				There are three rows (‘m = 3’) in the zig-zag pattern. Row one contains ‘AE’, row two contains ‘BDF’, and row three contains ‘CG’. After concatenating the three rows, we get the string ‘AEBDFCG’. So, the answer is ‘AEBDFCG’.

				Test Case 2:
				There are two rows (‘m = 2’) in the zig-zag pattern. Row one contains ‘NNA’, and row two contains ‘IJ’. After concatenating the two rows, we get the string ‘NNAIJ’. So, the answer is ‘NNAIJ’.
				Sample Input 2:
				2
				4 2
				PQRS
				6 6
				ZIGZAG
				Sample Output 2:
				PRQS
				ZIGZAG

		#include <bits/stdc++.h> 
		string zigZagString(string str, int n, int m) {
			if(str.length() < 3 || m == 1)
				return str;
			
			vector<vector<char>> holder(m);
			int i=0, row=0, flag=1;

			while(i < str.size()){
				if(flag){
					holder[row++].push_back(str[i]);
					if(row >= m){
						row = m-2;
						flag =0;
					}
				}else{
					holder[row--].push_back(str[i]);
					if(row < 0){
						flag =1;
						row = 1;
					}
				}
				i++;
			}

			string res;
			for(int i=0; i<holder.size(); i++)
				for(int j =0; j < holder[i].size(); j++)
					res += holder[i][j];
			return res;
		}
	
	712) Zig-Zag Conversion: (Medium)
		Problem statement
			You are given a string ‘S’ and an integer ‘ROW’, convert the row into a zig-zag pattern with rows equal to ‘ROW’ and output it row-wise. You may refer to the example below to better understand what the zig-zag pattern means.
			Example :
			If ‘S’ = “beaninjacoder” and ‘ROW’ = 4
			Then the zig-zag pattern is:
				b         j        r
				e     n   a     e
				a   i     c   d
				n         o

			Therefore, we will print “bjrenaeaicdno”.
			Constraints :
			1 ≤ ‘T’ ≤ 10      
			1 ≤ |S| ≤ 10000
			1 ≤ ‘ROW’ ≤ 10000
			S only contains lower case English alphabets
			Time limit: 1 sec
			Sample Input 1 :
			2
			beaninjacoder
			4
			codingninjas
			2
			Sample Output 1 :
			bjrenaeaicdno
			cdnnnaoigijs
			Explanation For Sample Input 1 :
			For test case 1 :
			We will print “bjrenaeaicdno” because the zig-zag pattern is:
			b         j        r
			e     n   a     e
			a   i     c   d
			n         o
			And, we will now row-wise output the letters from this pattern formed.

			For test case 2 : 
			We will print “cdnnnaoigijs” because the zig-zag pattern is:
			c  d  n  n  n  a     
			o  i  g  i  j  s
			Sample Input 2 :
				2
				canyousolvethisproblem
				5
				canyousolvethisproblem
				3
				Sample Output 2 :
				clraovponsesbyutilmohe
				colhreayuovtipolmnsesb

		// Not Optimized:
			#include <bits/stdc++.h> 
			string zigzagConversion(string s, int row) {
				if(s.size() < 3 || row == 1)
					return s;

				vector<vector<char>> V(row);
				int i=0, flag=1, m=0;
				while(i < s.size()){
					if(flag){
						V[m++].push_back(s[i]);
						if(m >= row){
							flag =0;
							m -=2;
						}
					}else{
						V[m--].push_back(s[i]);
						if(m < 0){
							flag =1;
							m += 2;
						}
					}
					i++;
				}
				
				string res;
				for(int i=0; i<row; i++)
					for(int j=0; j<V[i].size(); j++)
						res += V[i][j];
						
				return res;
			}

	713) Union of Two Sorted Arrays:
		Problem Statement:
			Given two sorted arrays of size n and m respectively, find their union. The Union of two arrays can be defined as the common and distinct elements in the two arrays. 
			Example 1:
			Input: 
			n = 5, arr1[] = {1, 2, 3, 4, 5}  
			m = 5, arr2 [] = {1, 2, 3, 6, 7}
			Output: 
			1 2 3 4 5 6 7
			Explanation: 
			Distinct elements including both the arrays are: 1 2 3 4 5 6 7.

			Example 2:
			Input: 
			n = 5, arr1[] = {2, 2, 3, 4, 5}  
			m = 5, arr2[] = {1, 1, 2, 3, 4}
			Output: 
			1 2 3 4 5
			Explanation: 
			Distinct elements including both the arrays are: 1 2 3 4 5.

			Example 3:
			Input:
			n = 5, arr1[] = {1, 1, 1, 1, 1}
			m = 5, arr2[] = {2, 2, 2, 2, 2}
			Output: 
			1 2
			Explanation: 
			Distinct elements including both the arrays are: 1 2.

			Your Task: 
				You do not need to read input or print anything. Complete the function findUnion() that takes two arrays arr1[], arr2[], and their size n and m as input parameters and returns a list containing the union of the two arrays.

			Expected Time Complexity: O(n+m).
			Expected Auxiliary Space: O(n+m).

			Constraints:
				1 <= n, m <= 10^5
				-10^9 <= arr1[i], arr2[i] <= 10^9

		class Solution{
			public:
			//arr1,arr2 : the arrays
			// n, m: size of arrays
			//Function to return a list containing the union of the two arrays. 
			vector<int> findUnion(int arr1[], int arr2[], int n, int m) {
				set<int> s (arr1, arr1+n);
				s.insert(arr2, arr2+m);
				
				vector<int> v (s.begin(), s.end());
				return v;
			}
		};

	714) Reverse The Array:
		Problem statement
			Given an array/list 'ARR' of integers and a position ‘M’. You have to reverse the array after that position.

			Example:
			We have an array ARR = {1, 2, 3, 4, 5, 6} and M = 3 , considering 0 
			based indexing so the subarray {5, 6} will be reversed and our 
			output array will be {1, 2, 3, 4, 6, 5}.
			Constraints:
				1 <= T <= 10
				0 <= M <= N <= 5*10^4
				-10^9 <= ARR[i] <= 10^9

				Time Limit: 1 sec
			Sample Input 1:
				2
				6 3
				1 2 3 4 5 6
				5 2
				10 9 8 7 6
				Sample Output 1:
				1 2 3 4 6 5
				10 9 8 6 7
				Explanation 1:
				For the first test case, 
				Considering 0-based indexing we have M = 3 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {1, 2, 3, 4, 6, 5}.

				For the second test case, 
				Considering 0-based indexing we have M = 2 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {10, 9, 8, 6, 7}.
				Sample Input 2:
				2
				7 3
				1 4 5 6 6 7 7 
				9 3
				10 4 5 2 3 6 1 3 6
				Sample Output 2:
				1 4 5 6 7 7 6
				10 4 5 2 6 3 1 6 3 

			Hints:
				1. Try to think by creating another array
				2. Try to think which elements are beign swapped.

		void reverseArray(vector<int> &arr , int m){
			if(arr.size() == 1 || arr.size() <= m)
				return ;

			int i = m + 1, j = arr.size()-1;
			while(i < j)
				swap(arr[i++], arr[j--]);
		}

	715) Replace The Linked List:
		Problem statement
			Given a linked list containing a series of numbers that are separated by ‘0’. You need to find the sum of the series and replace the series’s elements with its sum.
			For Example :
			If the given linked list is 3 ->4 ->0 ->5 ->0, you should return linked list as - 7 -> 5.
			Note :
			You need to replace the sum values in the linked list without using any extra space.

			It is guaranteed that there will be no two consecutive zeroes in the linked list.
			Constraints :
				1 <= T <= 50
				1 <= N <= 10^5
				-10^9 <= data <= 10^9
				data ≠ -1.

				Time Limit: 1 sec
			Sample Input 1 :
				2
				2 5 7 0 3 4 0 -1
				1 2 3 0 -1
				Sample Output 1 :
				14 7
				6
				Explanation For Sample Input 1 :
				Test Case 1: In the given linked list sum of series 2, 5, 7 is 14, and the sum of series 3,4 is 7. So the modified, linked list will be 14 -> 7.

				Test Case 2: The only series formed in the linked list 1,2,3 have sum = 6. Therefore modified linked list will be 6.
				Sample Input 2 :
				2
				5 3 8 2 -1
				0 6 0 4 0 -1
				Sample Output 2 :
				5 3 8 2
				6 4

		#include <bits/stdc++.h> 
		/*
			Following is the Node Structure written below	
			class Node {
				public:
					int data;
					Node * next;
				Node(int x) {
					data=x;
					next=NULL;
				}
			};
		*/

		Node* replaceWithSum(Node *head) {
			if(head -> data == 0)
				head = head -> next;

			if(!head)
				return head;

			int flag, firstTimeFlag, sum=0;
			flag = firstTimeFlag = 1;
			
			Node* trvrs = head, *temp = NULL;	

			while(trvrs){
				if(firstTimeFlag && trvrs -> data == 0){
					head = trvrs;
					firstTimeFlag = 0;
					trvrs -> data = sum;
					sum=0;
					trvrs = trvrs -> next;
					continue;
				}

				if(trvrs -> data == 0){
					if(flag){
						flag = 0;
						temp = trvrs;
						head -> next = temp;
						trvrs -> data = sum;
					}else{
						temp -> next = trvrs;
						temp = trvrs;
						trvrs -> data = sum;
					}
					sum =0;
				}else{
					sum += trvrs -> data;
				}
				trvrs = trvrs -> next;
			}

			if(firstTimeFlag)
				return head;	
			return head;
		}
	
	#LeetCode WeeklyContest-394:
		716) Count the Number of Special Characters I:
			Problem Statement:
				You are given a string word. A letter is called special if it appears both in lowercase and uppercase in word.
				Return the number of special letters in word.		

				Example 1:
				Input: word = "aaAbcBC"
				Output: 3
				Explanation:
				The special characters in word are 'a', 'b', and 'c'.

				Example 2:
				Input: word = "abc"
				Output: 0
				Explanation:
				No character in word appears in uppercase.

				Example 3:
				Input: word = "abBCab"
				Output: 1
				Explanation:
				The only special character in word is 'b'.
				Constraints:
					1 <= word.length <= 50
					word consists of only lowercase and uppercase English letters.

			class Solution {
				public:
				int numberOfSpecialChars(string word) {
					int cnt=0;
					set<char> s (word.begin(), word.end());
					word.clear();
					word.insert(word.end(), s.begin(), s.end());
					
					for(int i=0; i < word.size(); i++){
						if(islower(word[i])){
							char ch = toupper(word[i]);
							if(word.find(ch) != string::npos)
								cnt++;
						}
					}        
					return cnt;
				}
			};

			//or 
			class Solution {
				public:
				int numberOfSpecialChars(string word) {
					set<char> s (word.begin(), word.end());
					string str (s.begin(), s.end());
					// or
					// word.assign(s.begin(), s.end());

					int cnt=0;
					for(int i=0; i<str.size(); i++){
						if(islower(str[i])){
							if((str.find(str[i]) != string::npos) && (str.find(toupper(str[i])) != string::npos))
								cnt++;
						}            
					}
					return cnt;
				}
			};
		
		717) Count the Number of Special Characters II:
			Problem Statement:
				You are given a string word. A letter c is called special if it appears both in lowercase and uppercase in word, and every lowercase occurrence of c appears before the first uppercase occurrence of c.
				Return the number of special letters in word.		

				Example 1:
				Input: word = "aaAbcBC"
				Output: 3
				Explanation:
				The special characters are 'a', 'b', and 'c'.

				Example 2:
				Input: word = "abc"
				Output: 0
				Explanation:
				There are no special characters in word.

				Example 3:
				Input: word = "AbBCab"
				Output: 0
				Explanation:
				There are no special characters in word.		

				Constraints:
					1 <= word.length <= 2 * 10^5
					word consists of only lowercase and uppercase English letters.

			class Solution {
				public:
				int numberOfSpecialChars(string word) {
					int cnt=0;
					
					set<char> holder;
					
					for(int i=0; i<word.size(); i++){
						if(islower(word[i]) && holder.find(word[i]) == holder.end()){

							// finding upperversion
							int flag_Up_present = 0, flag_again_not = 1;
							int j;
							for(j=i+1; j<word.size(); j++){
								if(toupper(word[i]) == word[j]){
								flag_Up_present = 1;
								break;
								}
							}
							
							// checking lower version should not be there after upper version
							j++;
							for(j; j<word.size(); j++)
								if(word[i] == word[j])
								flag_again_not = 0;
							
							if(flag_Up_present && flag_again_not)
								cnt++;
						}
						holder.insert(tolower(word[i]));
					}
					
					return cnt;
				}
			};

	718) Three way partitioning:
		Problem Statement:
			Given an array of size n and a range [a, b]. The task is to partition the array around the range such that the array is divided into three parts.
			1) All elements smaller than a come first.
			2) All elements in range a to b come next.
			3) All elements greater than b appear in the end.
			The individual elements of three sets can appear in any order. You are required to return the modified array.
			Note: The generated output is 1 if you modify the given array successfully.
			Geeky Challenge: Solve this problem in O(n) time complexity.

			Example 1:
			Input: 
			n = 5
			array[] = {1, 2, 3, 3, 4}
			[a, b] = [1, 2]
			Output: 
			1

			Explanation: 
			One possible arrangement is: {1, 2, 3, 3, 4}. If you return a valid arrangement, output will be 1.

			Example 2:
			Input: 
			n = 6 
			array[] = {1, 4, 3, 6, 2, 1}
			[a, b] = [1, 3]
			Output: 
			1

			Explanation: 
			One possible arrangement is: {1, 3, 2, 1, 4, 6}. If you return a valid arrangement, output will be 1.

			Your Task:
				You don't need to read input or print anything. The task is to complete the function threeWayPartition() which takes the array array, a, and b as input parameters and modifies the array in place according to the given conditions.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 10^6
				1 <= array[i], a, b <= 10^9

		/* TC: O(n) & SC: O(n)*/
		class Solution{
			public:
			//Function to partition the array around the range such 
			//that array is divided into three parts.
			void threeWayPartition(vector<int>& array,int a, int b) {
				vector<int> smaller, middle, last;
				
				int start, mid, end;
				start = mid = end = 0;
				
				for(int i=0; i<array.size(); i++){
					if(array[i] < a){
						smaller.push_back(array[i]);
					}else if(array[i] > b){
						last.push_back(array[i]);
					}else{
						middle.push_back(array[i]);
					}
				}
				array = smaller;
				array.insert(array.end(), middle.begin(), middle.end());
				array.insert(array.end(), last.begin(), last.end());

				//for(auto i: array)
				//	cout<<i <<"\t";
			}
		};

		/* TC: O(n) & SC: O(1)*/
			-Based on DNF (Dutch Nation Flag) Algorithm:
			void threeWayPartition(vector<int>& array,int a, int b) {
				int low, mid, high;
				
				low = mid = 0;
				high = array.size()-1;
				
				while(mid <= high){
					if(array[mid] < a){
						swap(array[low], array[mid]);
						low++;
						mid++;
					}else if(array[mid] > b){
						swap(array[mid], array[high]);
						high--;
					}else{
						mid++;
					}
				}
			}

		/* TC: O(n log(n)) & SC: O(1) (call stack space will be O(log n) */
			void threeWayPartition(vector<int>& array,int a, int b) {
				sort(array.begin(), array.end());
			}
		
	719) Interleave The First Half Of The Queue With The Second Half:
		Problem statement
			You have been given a queue of integers. You need to rearrange the elements of the queue by interleaving the elements of the first half of the queue with the second half.
			Note :
			The given queue will always be of even length.
			For example :
			If N= 10
			and Q = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
			then the output will be
			Q = [10, 60, 20, 70, 30, 80, 40, 90, 50, 100]
			Constraints:
				1 <= T <= 10^2
				2 <= N <= 10^3
				0 <= data <= 10^4
				Where ‘T’ is the number of test cases, “data” is the value of the element of the queue.
			Sample Input 1:
				1
				10
				10 20 30 40 50 60 70 80 90 100
				Sample Output 1:
				10 60 20 70 30 80 40 90 50 100
				Sample Input 2:
				1
				6
				10 20 30 40 50 60 
				Sample Output 2:
				10 40 20 50 30 60 

		#include <bits/stdc++.h> 
		void interLeaveQueue(queue < int > & q) {
			queue<int> clearedQueue, temp1, temp2;
			int cnt=0;

			swap(q, clearedQueue);			// this statement is to delete all elements from queue 'q'.

			while(!clearedQueue.empty()){
				cnt++;
				temp2.push(clearedQueue.front());
				clearedQueue.pop();
			}

			int half = cnt / 2;

			while(half--){
				temp1.push(temp2.front());
				temp2.pop();
			}

			int altering=1;

			while(cnt--){
				if(altering){
					altering=0;

					q.push(temp1.front());
					temp1.pop();
					
				}else{
					altering=1;

					q.push(temp2.front());
					temp2.pop();
				}
			}
		}
	
	720) Rearrange Linked List:
		Problem statement
			You have been given a singly Linked List in the form of 'L1' -> 'L2' -> 'L3' -> ... 'Ln'. Your task is to rearrange the nodes of this list to make it in the form of 'L1' -> 'Ln' -> 'L2' -> 'Ln-1' and so on. You are not allowed to alter the data of the nodes of the given linked list.
			For example:
			If the given linked list is 1 -> 2 -> 3 -> 4 -> 5 -> NULL.
			Then rearrange it into 1 -> 5 -> 2 -> 4 -> 3 -> NULL. 
			Constraints :
				1 <= 'T' <= 10
				0 <= 'L' <= 1000
				1 <= data <= 10 ^ 9 and data != -1
				Where ‘T’ is the number of test-cases and ‘L’ is the number of nodes in the Linked List, and ‘data’ is the data in each node of the list.
				Time Limit: 1 sec.

			Sample Input 1 :
				2
				1 2 3 4 5 6 -1
				1 2 -1
				Sample Output 1 :
				1 6 2 5 3 4 -1
				1 2 -1
				Explanation for sample 1:
				For the first test case, we have 1 as the starting element followed by 6, 2, 5, 3 and 4 respectively in the linked list after rearrangement.

				For the second test case, we will get the same linked list after rearrangement, Therefore 1 2.
				Sample Input 2 :
				2
				2 4 6 8 10 -1
				-1
				Sample Output 2 :
				2 10 4 8 6 -1
				-1

		#include <bits/stdc++.h> 
		/************************************************************
			Following is the linked list node structure

			template <typename T>
			class Node {
				public:
				T data;
				Node* next;

				Node(T data) {
					next = NULL;
					this->data = data;
				}

				~Node() {
					if (next != NULL) {
						delete next;
					}
				}
			};
		************************************************************/
		Node<int>* rearrangeList(Node<int>* head) {
			Node<int>*  ans = head;

			vector<int> holder;
			while(ans){
				holder.push_back(ans->data);
				ans = ans -> next;
			}

			if(holder.size() <= 2)
				return head;

			int i=0, j= holder.size()-1, flag=1;
			Node<int>* n = new Node(holder[i++]);
			
			ans = n;
			Node<int>* temp = n;

			while(i <= j){
				if(flag){
					Node<int>* n2 = new Node(holder[j--]);
					temp -> next = n2;
					temp = n2;
					flag=0;
				}else{
					Node<int>* n2 = new Node(holder[i++]);
					temp -> next = n2;
					temp = n2;
					flag=1;
				}
			}
			return ans;
		}

	721) Maximum Difference:
		Problem statement
			You are given an array 'ARR' of the 'N' element. Your task is to find the maximum difference between any of the two elements from 'ARR'.
			If the maximum difference is even print “EVEN” without quotes. If the maximum difference is odd print “ODD” without quotes.

			For example:
			Given 'ARR' = [1, 10, 5, 2, 8, 1 ] , answer is "ODD".
			Here the maximum difference is between 10 and 1, 10 - 1 = 9
			Constraints:
				1 <= T <= 100
				1 <= N <= 5000 
				1 <= ARR[i] <= 10 ^ 9
			where ‘N’ is the length of the array 'ARR', and 'ARR[i]' is an element of the 'ARR' respectively.
			Time limit: 1 sec.

			Sample Input 1:
				2
				4
				2 9 3 4
				6
				1 1 1 1 1 1 
				Sample Output 1:
				ODD
				EVEN
				Explanation of Sample Input 1:
				For the first test case, the maximum difference is 7, between 9 and 2.

				For the second test case, all elements are the same, the maximum difference is 0.
				Sample Input 2:
				2
				2
				567 11
				1
				28
				Sample Output 2:
				EVEN
				EVEN 

		// Not Optimized:
			#include <bits/stdc++.h> 
			string maximumDifference(int n, vector<int>& arr) {
				sort(arr.begin(), arr.end());
				return ((arr.back() - arr[0]) & 1) ? "ODD" : "EVEN";
			}

		// Optimized:
			#include <bits/stdc++.h> 
			string maximumDifference(int n, vector<int>& arr) {
				int mn = *min_element(arr.begin(), arr.end());
				int mx = *max_element(arr.begin(), arr.end());
				return ((mx-mn) & 1) ? "ODD" : "EVEN";
			}
	
	722) Row with minimum number of 1's:
		Problem Statement:
			Given a 2D binary matrix(1-based indexed) a of dimensions nxm , determine the row that contains the minimum number of 1's.
			Note: The matrix contains only 1's and 0's. Also, if two or more rows contain the minimum number of 1's, the answer is the lowest of those indices.

			Example 1:
			Input:
			n = 4,m = 4
			a = [[1, 1, 1, 1],
				[1, 1, 0, 0], 
				[0, 0, 1, 1],
				[1, 1, 1, 1]]
			Output:
			2
			Explanation:
			Rows 2 and 3 contain the minimum number 
			of 1's(2 each).Since,row 2 is less than row 3.
			Thus, the answer is 2.
			
			Example 2:
			Input:
			n = 3,m = 3
			a = [[0, 0, 0],
				[0, 0, 0],
				[0, 0, 0]]
			Output:
			1
			Explanation:
			All the rows contain the same number 
			of 1's(0 each).Among them, index 1 
			is the smallest, so the answer is 1.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function minRow() which takes the two integers n, m as well as the 2D binary matrix a as input parameters and returns the minimum index of the row which contains the least number of 1's.

			Expected Time Complexity:O(n*m)
			Expected Auxillary Space:O(1)

			Constraints:
				1 <= n,m <= 1000
				0 <= a[i][j] <= 1

		class Solution {
			public:
			int minRow(int n, int m, vector<vector<int>> a) {
				int minAns = 1, prev=0;;
				
				for(int i=0; i<1; i++)
					for(int j=0; j<m; j++)
						if(a[i][j] == 1)
							prev++;
				
				for(int i=1; i<a.size(); i++){
					int cnt =0;
					
					for(int j=0; j<m; j++)
						if(a[i][j] == 1)
							cnt++;
							
					if(cnt < prev){
						prev = cnt;
						minAns = i+1;
					}
				}

				return minAns;
			}
		};

	723) Detect Loop in linked list:
		Problem Statement:
			Given a linked list of N nodes. The task is to check if the linked list has a loop. Linked list can contain self loop.
			Example 1:
			Input:
			N = 3
			value[] = {1,3,4}
			x(position at which tail is connected) = 2
			Output: True
			Explanation: In above test case N = 3.
			The linked list with nodes N = 3 is
			given. Then value of x=2 is given which
			means last node is connected with xth
			node of linked list. Therefore, there
			exists a loop.

			Example 2:
			Input:
			N = 4
			value[] = {1,8,3,4}
			x = 0
			Output: False
			Explanation: For N = 4 ,x = 0 means
			then lastNode->next = NULL, then
			the Linked list does not contains
			any loop.

			Your Task:
				The task is to complete the function detectloop() which contains reference to the head as only argument.  This function should return true if linked list contains loop, else return false.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 10^4
				1 ≤ Data on Node ≤ 10^3
		
		/*
			struct Node {
			int data;
			struct Node *next;
			Node(int x) {
				data = x;
				next = NULL;
			}   
		*/
		class Solution {
			public:
			//Function to check if the linked list has a loop.
			bool detectLoop(Node* head) {
				map<Node*, bool> isPresent;
				while(head){
					if(isPresent[head])
						return 1;
					isPresent[head] = 1;
					head = head -> next;
				}
				return 0;
			}
		};

		// or
			class Solution {
				public:
				//Function to check if the linked list has a loop.
				bool detectLoop(Node* head) {
					Node *fast, *slow;
					fast = slow = head;
					while(fast){
						fast = fast -> next;
						if(!fast)
							break;
						fast = fast -> next;
						slow = slow -> next;
						if(slow == fast)
							return 1;
					}
					return 0;
				}
			};
	
	724) Remove Duplicates from Sorted Array:
		Problem statement
			You are given a sorted integer array 'arr' of size 'n'.
			You need to remove the duplicates from the array such that each element appears only once.
			Return the length of this new array.
			Note:
			Do not allocate extra space for another array. You need to do this by modifying the given input array in place with O(1) extra memory. 
			For example:
			'n' = 5, 'arr' = [1 2 2 2 3].
			The new array will be [1 2 3].
			So our answer is 3.
			Sample input 1:
				10
				1 2 2 3 3 3 4 4 5 5 
				Sample output 1:
				5
				Explanation of sample input 1:
				The new array will be [1 2 3 4 5].
				So our answer is 5.
				Sample input 2:
				9
				1 1 2 3 3 4 5 5 5 
				Sample output 2:
				5
				Expected time complexity:
				The expected time complexity is O(n).
				Constraints :
					1 <= 'n' <= 10^6
					-10^9 <= 'arr[i]' <=10^9
					Where ‘arr[i]’ is the value of elements of the array.
					Time limit: 1 sec

		// Without using extra space:
			-In the average case, if there are fewer duplicate elements, the time complexity would be closer to O(n), but in the worst case where every element is a duplicate, it could indeed be O(n^2).
			int removeDuplicates(vector<int> &arr, int n) {
				for(int i=1; i<arr.size();){
					if(arr[i] != arr[i-1]){
						i++;
					}else{
						arr.erase(arr.begin()+i);
					}
				}
				return arr.size();
			}

		// Using set: Not Optimized
			#include<bits/stdc++.h>
			int removeDuplicates(vector<int> &arr, int n) {
				set<int> s (arr.begin(), arr.end());
				// arr.assign(s.begin(), s.end())
				return s.size();
			}

		// without using set or hashMap:
			#include<bits/stdc++.h>
			int removeDuplicates(vector<int> &arr, int n) {
				vector<int> holder = {arr[0]};
				for(int i=1; i<arr.size(); i++)
					if(holder.back() != arr[i])
						holder.push_back(arr[i]);

				arr.assign(holder.begin(), holder.end());
				return holder.size();
			}
	
		// or
			int removeDuplicates(vector<int> &arr, int n) {
				vector<int> res;
				for(int i : arr){
					if(res.empty()){
						res.push_back(i);
					}else{
						if(res.back() != i)
							res.push_back(i);
					}
				}
				arr = res;
				return arr.size();
			}
	
		// Not Optimized:
			#include <set>
			int removeDuplicates(vector<int> &arr, int n) {
				set<int> s (arr.begin(), arr.end());
				arr.assign(s.begin(), s.end());
				return arr.size();
			}

	725) Remove duplicate elements from sorted Array:
		Problem Statement:
			Given a sorted array a[] of size n, delete all the duplicated elements from a[] & modify the array such that only distinct elements should be present there.
			Note:
				1. Don't use set or HashMap to solve the problem.
				2. You must return the modified array size where only distinct elements are present in the array, the driver code will print all the elements of the modified array.

			Example 1:
				Input:
				N = 5
				Array = {2, 2, 2, 2, 2}
				Output: 
				1
				Explanation: After removing all the duplicates only one instance of 2 will remain i.e. {2} so modify array will contains 2 at first position and you should return 1 after modify the array.

			Example 2:
				Input:
				N = 4
				Array = {1, 2, 2, 4}
				Output: 3
				Explation: After removing all duplicates modify array will contains {1, 2, 4} at first 3 positions so you should return 3 after modify the array.

			Your Task:  
				You don't need to read input or print anything. Complete the function remove_duplicate() which takes the array a[] and its size n as input parameters and modifies it in place to delete all the duplicates. The function must return an integer X denoting the no. of distinct elements in the array keeping the first X elements of an array in increasing order. 

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 10^4
				1 ≤ A[i] ≤ 10^6

		class Solution{
			public:
			int remove_duplicate(int a[],int n){
				vector<int> holder = {a[0]};
				
				for(int i=1; i<n; i++)
					if(holder.back() != a[i])
						holder.push_back(a[i]);
				
				for(int i=0; i<holder.size(); i++)
					a[i] = holder[i];

				return holder.size();
			}
		};

	726)	Remove Duplicates:
		Problem statement
			Ninja is playing with numbers but hates when he gets duplicate numbers. Ninja is provided an array, and he wants to remove all duplicate elements and return the array, but he has to maintain the order in which the elements were supplied to him.
			Constraints:
				1 <= T <= 10
				1 <= N <= 5*10^3
				-10^5 <= arr[i] <= 10^5
				Time Limit: 1 sec

			Sample Input 1 :
				2
				5
				1 2 2 3 4
				5
				10 11 23 23 23 
				Sample Output 1:
				1 2 3 4
				10 11 23
				Explanation for Sample Input 1:
				In the first test case, ‘2’ is a duplicate element, and there are two occurrences of ‘2’, so one ‘2’ is removed, and the resultant array becomes [1 2 3 4].

				In the second test case, ‘23’ is a duplicate element, and there are three occurrences of ‘23’, so two occurrences of ‘23’ must be removed, and the resultant array becomes [10 11 23].
				Sample Input 2 :
				2
				10
				1 3 3 3 3 3 4 9 23 35
				5
				10 10 10 10 10 
				Sample Output 2:
				1 3 4 9 23 35
				10 

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<int> removeDuplicates(vector<int> arr) {
				vector<int> ans;

				for(int i : arr)
					if(find(ans.begin(), ans.end(), i) == ans.end())
						ans.push_back(i);
				
				return ans;
			}
		
		// Optimized:
			#include <bits/stdc++.h> 
			vector<int> removeDuplicates(vector<int> arr) {
				vector<int> ans;
				unordered_map<int, int> mp;

				for(int i : arr)
					mp[i]++;

				for(int i: arr){
					if(mp.find(i) != mp.end()){
						ans.push_back(i);
						mp.erase(i);
					}
				}
				return ans;
			}
	
	727) Remove duplicate element from sorted Linked List:
		Problem Statement:
			Given a singly linked list consisting of N nodes. The task is to remove duplicates (nodes with duplicate values) from the given list (if exists).
			Note: Try not to use extra space. The nodes are arranged in a sorted way.
			
			Example 1:
			Input:
			LinkedList: 2->2->4->5
			Output: 2 4 5
			Explanation: In the given linked list 
			2 ->2 -> 4-> 5, only 2 occurs more 
			than 1 time. So we need to remove it once.

			Example 2:
			Input:
			LinkedList: 2->2->2->2->2
			Output: 2
			Explanation: In the given linked list 
			2 ->2 ->2 ->2 ->2, 2 is the only element
			and is repeated 5 times. So we need to remove
			any four 2.

			Your Task:
				The task is to complete the function removeDuplicates() which takes the head of input linked list as input. The function should remove the duplicates from linked list and return the head of the linkedlist.

			Expected Time Complexity : O(N)
			Expected Auxilliary Space : O(1)

			Constraints:
				1 <= Number of nodes <= 10^5

		/*
			struct Node {
				int data;
				struct Node *next;
				Node(int x) {
					data = x;
					next = NULL;
				}
			};
		*/

		//Function to remove duplicates from sorted linked list.
		Node *removeDuplicates(Node *head) {
			Node *cur = head -> next;
			Node *prev = head;
			
			while(cur){
				if(prev -> data == cur -> data){
					Node *removeNODE = cur;
					
					cur = cur -> next;
					prev -> next = cur;
					
					delete removeNODE;
				}else{
					prev = cur;
					cur = cur -> next;
				}
			}
			return head;
		}

		// using single pointer:
			Node *removeDuplicates(Node *head) {			
				Node *cur = head;
				
				while(cur -> next){         // while(cur -> next != NULL)
					if(cur -> data == cur -> next -> data){
						Node *NodeToBeDeleted = cur -> next;
						cur -> next = cur -> next -> next;
						delete NodeToBeDeleted;
					}else{
						cur = cur -> next;
					}
				}
				return head;
			}
	
		// using extra space: (not recommended)
			Node *removeDuplicates(Node *head) {
				set<int> s;
				Node *temp = head;
				while(temp){
					s.insert(temp -> data);
					Node *cur = temp;
					temp = temp -> next;
					
					delete cur;
				}
				
				Node *H1;
				int flag=1;
				
				for(int i: s){
					Node * n = new Node(i);
					if(flag){
						flag=0;
						temp = n;
						H1 = n;
					}else{
						temp -> next = n;
						temp = n;
					}
				}
				
				return H1;
			}

	728) Remove duplicates from a sorted Doubly Linked List:
		Problem statement
			A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference to both the previous and the next nodes in the sequence of nodes.
			You are given a sorted doubly linked list of size 'n'.
			Remove all the duplicate nodes present in the linked list.
			Example :
			Input: Linked List: 1 <-> 2 <-> 2 <-> 2 <-> 3
			Output: Modified Linked List: 1 <-> 2 <-> 3
			Explanation: We will delete the duplicate values ‘2’ present in the linked list.

			Sample Input 1 :
			5
			1 2 2 2 3

			Sample Output 1 :
			1 2 3

			Explanation For Sample Input 1 :
			We will delete the duplicate values ‘2’ present in the linked list.

			Sample Input 2 :
			4
			1 2 3 4

			Sample Output 2 :
			1 2 3 4

			Explanation For Sample Input 2 :
			The list contains no duplicates, so the final list is unchanged.

			Expected time complexity :
				The expected time complexity is O('n').

			Constraints :
				1 <= 'n' <= 10^5
				1 <= 'data' in any node <= 10^6
				Time limit: 1 sec

		/**
		* Definition of doubly linked list:
		* class Node {
		* public:
		*      int data;
		*      Node *prev;
		*      Node *next;
		*      Node() {
		*          this->data = 0;
		*          this->prev = NULL;
		*          this->next = NULL;
		*      }
		*      Node(int data) {
		*          this->data = data;
		*          this->prev = NULL;
		*          this->next = NULL;
		*      }
		*      Node (int data, Node *next, Node *prev) {
		*          this->data = data;
		*          this->prev = prev;
		*          this->next = next;
		*      }
		* };
		*
		*************************************************************************/

		Node * removeDuplicates(Node *head) {
			Node *cur = head;

			while(cur -> next){
				if(cur -> data == cur -> next -> data){
					Node * NodeToBeDeleted = cur -> next;

					if(NodeToBeDeleted -> next == nullptr){
						cur -> next = nullptr;
					}else{
						Node *temp = cur -> next -> next;
						cur -> next = cur -> next -> next;
						temp -> prev = cur;				// this line is not necessary.
					}
					NodeToBeDeleted -> next = nullptr;
					NodeToBeDeleted -> prev = nullptr;
					delete NodeToBeDeleted;
				}else
					cur = cur -> next;
			}

			return head;
		}

	729) Finding middle element in a linked list:
		Problem Statement:
			Given a singly linked list of N nodes.
			The task is to find the middle of the linked list. For example, if the linked list is
			1-> 2->3->4->5, then the middle node of the list is 3.
			If there are two middle nodes(in case, when N is even), print the second middle element.
			For example, if the linked list given is 1->2->3->4->5->6, then the middle node of the list is 4.

			Example 1:
				Input:
				LinkedList: 1->2->3->4->5
				Output: 3 
				Explanation: 
				Middle of linked list is 3.
			Example 2: 
				Input:
				LinkedList: 2->4->6->7->5->1
				Output: 7 
				Explanation: 
				Middle of linked list is 7.

			Your Task:
				The task is to complete the function getMiddle() which takes a head reference as the only argument and should return the data at the middle node of the linked list.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <= 5000

		/* Link list Node 
			struct Node {
				int data;
				Node* next;
				
				Node(int x){
					data = x;
					next = NULL;
				}
			}; 
		*/
		class Solution{
			public:
			/* Should return data of middle node. If linked list is empty, then  -1*/
			int getMiddle(Node *head) {
				// if(head == NULL)
				//     return -1;
					
				Node *slow, *fast;
				slow = fast = head;
				
				while(fast){
					fast = fast -> next;
					
					if(fast == NULL)
						break;
					
					fast = fast -> next;
					slow = slow -> next;
				}
				return slow -> data;
			}
		};

		// using extra space:
			class Solution{
				public:
				/* Should return data of middle node. If linked list is empty, then  -1*/
				int getMiddle(Node *head) {
					// if(head == NULL)
					//     return -1;
						
					vector<int> v;
					int cnt=0;
					while(head){
						cnt++;
						v.push_back(head -> data);
						head = head -> next;
					}
					return v[cnt/2];
				}
			};
	
	730) Reverse a linked list (Refer Q.693):
		Problem Statement:
			Given a linked list of N nodes. The task is to reverse this list.
			Example 1:
				Input:
				LinkedList: 1->2->3->4->5->6
				Output: 6 5 4 3 2 1
				Explanation: After reversing the list, 
				elements are 6->5->4->3->2->1.

			Example 2:
				Input:
				LinkedList: 2->7->8->9->10
				Output: 10 9 8 7 2
				Explanation: After reversing the list,
				elements are 10->9->8->7->2.

			Your Task:
				The task is to complete the function reverseList() with head reference as the only argument and should return new head after reversing the list.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <= 10^4

		/* Linked List Node structure:
			struct Node {
				int data;
				struct Node *next;
			}
		*/

		class Solution {
			public:
			//Function to reverse a linked list.
			struct Node* reverseList(struct Node *head) {
				Node* cur = head;
				Node* prev = NULL;
				
				while(cur){
					Node* temp = cur -> next;
					
					cur -> next = prev;
					prev = cur;
					cur = temp;
				}
				
				return prev;
			}
		};
	
	731) Nth node from end of linked list:
		Problem Statement:
			Given a linked list consisting of L nodes and given a number N. The task is to find the Nth node from the end of the linked list.
			Example 1:
				Input:
				N = 2
				LinkedList: 1->2->3->4->5->6->7->8->9
				Output: 8
				Explanation: In the first example, there
				are 9 nodes in linked list and we need
				to find 2nd node from end. 2nd node
				from end is 8.  
			
			Example 2:
				Input:
				N = 5
				LinkedList: 10->5->100->5
				Output: -1
				Explanation: In the second example, there
				are 4 nodes in the linked list and we
				need to find 5th from the end. Since 'n'
				is more than the number of nodes in the
				linked list, the output is -1.

			Your Task:
				The task is to complete the function getNthFromLast() which takes two arguments: reference to head and N and you need to return Nth from the end or -1 in case node doesn't exist.

			Note:
				Try to solve in a single traversal.
				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(1).

			Constraints:
				1 <= L <= 10^6
				1 <= N <= 10^6

		/*
			struct Node {
				int data;
				struct Node *next;
				Node(int x) {
					data = x;
					next = NULL;
				}
			};
		*/

		//Function to find the data of nth node from the end of a linked list.
		class Solution{
			public:
			int getNthFromLast(Node *head, int n) {
				Node *N_index_prev = head;
				int cnt = 0;
				while(head){
					cnt++;
					if(cnt > n)
						N_index_prev = N_index_prev -> next;
					head = head -> next;
				}
				if(cnt < n)
					return -1;
				return N_index_prev -> data;
			}
		};
	
	732) Multiply 2 matrices:
		Problem Statement:
			For 2 given matrices of size n x n. Your task is to multiply them.	
			Example 1:
			Input: 
			matrixA = {{1, 1, 1}, {1, 1, 1}, 
					{1, 1, 1}}
			matrixB = {{1, 1, 1}, {1, 1, 1},
					{1, 1, 1}}
			Output: {{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}
			
			Example 2:
			Input: 
			matrixA = {{1, 2}, {3, 4}},
			matrixB = {{4, 3}, {2, 1}}
			Output: {{8, 5}, {20, 13}}
			
			Your Task:
				You don't need to read or print anything. Your task is to complete the function Multiply() which takes two matrices matrixA amd matrixB as input parameter and multiply the two matrices. You don't have to return anything. Copy the values of output matrix into matrixA.
			
			Expected Time Compelxity: O(n^3)
			Expected Space Complexity: O(n^2)
			

			Constraints:
				1 <= n <= 100
				1 <= elements of matrices <= 100

		class Solution {
			public:
			void Multiply(vector<vector<int>>& matrixA, vector<vector<int>>&matrixB) {
				vector<vector<int>> ans;
				
				for(int i=0; i<matrixA.size(); i++){
					vector<int> temp;
					for(int j=0; j<matrixA.size(); j++){
						int c=0, sum=0;
						while(c < matrixA.size()){
							sum += (matrixA[i][c] * matrixB[c][j]);
							c++;
						}
						temp.push_back(sum);
					}
					ans.push_back(temp);
				}
				matrixA = ans;
			}
		};

	733) Rohan's Love for Matrix:
		Problem Statement:
			Rohan has a special love for the matrices especially for the first element of the matrix. Being good at Mathematics, he also loves to solve the different problem on the matrices. So one day he started to multiply the matrix with the original matrix.  The elements of the original matrix a are given by [a00=1 , a01=1, a10=1, a11=0].
			Given the power of the matrix, n calculate the an and return the a10 element mod 1000000007.

			Example 1:
			Input: 
			n = 3
			Output: 
			2 
			Explanation: Take the cube of the original matrix 
			i.e a3 and the (a10)th element is 2.

			Example 2:
			Input: 
			n = 4
			Output: 
			3
			Explanation: Take the cube of the original matrix 
			i.e a4 and the (a10)th element is 3.
			Your Task:  
				You dont need to read input or print anything. Complete the function firstElement() which takes n as input parameter and returns the a10 element mod 1000000007 of an.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1<= n <=10^6

		class Solution {
			public:
			int firstElement(int n) {
				if(n == 1 || n == 2)
					return 1;
				
				int MOD = 1e9+7;
				int matx[2][2] = {{1,1}, {1,0}};
				int newMtx[2][2] = {{2,1}, {1,1}};
				
				int i = 3;
				while(i <= n){
					// multiplication logic
					int tempMtx[2][2] ={{0,0}, {0,0}};
					for(int x=0; x<2; x++){
						for(int y=0; y<2; y++){
							int sum = 0, change=0;
							
							while(change < 2){
							sum += (newMtx[x][change] * matx[change][y]);
							change++;
							}
							
							tempMtx[x][y] = sum % MOD;
						}
					}
					
					for(int x=0; x<2; x++)
						for(int y=0; y<2; y++)
							newMtx[x][y] = tempMtx[x][y];
					
					i++;
				}
				
				return newMtx[1][0] % MOD;
			}
		};
	
	734) Merge LinkedList:
		Problem statement
			You are given two LinkedList of length ‘N’. Your task is to insert the elements of the second LinkedList in the first LinkedList at the alternate positions.
			For example: Let 1 -> 3 -> 5 be the first LinkedList and 2 -> 4 -> 6 be the second LinkedList. Then after merging the first LinkedList will look like 1 -> 2 -> 3 -> 4 -> 5 -> 6.
			Constraints -
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^5
				All the elements in both of the LinkedList lie in the range [-10^9, 10^9] - {1}.
				Note- the sum of ‘N’ over all test cases does not exceed 10^5.
				Time Limit: 1 sec

			Sample Input-1
				2
				3 
				1 3 5 -1 
				2 4 6 -1
				1 
				3 -1
				6 -1
				Sample Output-1
				1 2 3 4 5 6
				3 6
				Explanation for Sample Input 1:
				For test case 1: 
				It is explained above.
				For test case 2: 
				We added the first element of the second LinkedList next to the first element of the first LinkedList. Hence the first LinkedList will look like 3 -> 6. 
				Sample Input -2
				2
				3 
				1 2 3 -1
				-5 -2 -3 -1
				3 
				24 42 13 -1
				91 42 13 -1
				Sample Output -2
				1 -5 2 -2 3 -3
				24 91 42 42 13 13

		// Not Optimized:
			#include <bits/stdc++.h> 
			/************************************************************
				Following is the linkedList class structure:
				class Node {
					public:
					int data;
					Node *next;

					Node(int val) {
						this->data = val;
						next = NULL;
					}
					~Node() {
						if (next != NULL) {
							delete next;
						}
					}
				};
			************************************************************/
			void merge(Node* head1, Node* head2) {
				Node *cur1 = head1 -> next;
				Node *cur2 = head2;
				head1 -> next = cur2;

				int flag = 1;
				while(cur1){
					if(flag){
						Node * temp = cur2;
						
						cur2 = cur2 -> next;

						temp -> next = cur1;
						flag=0;
					}else{
						Node *temp = cur1;
						
						cur1 = cur1 -> next;

						temp -> next = cur2;
						flag=1;
					}
				}
			}

			// or

	735) Yet another Pattern:
		Problem statement
			Ninja was playing with her sister to solve a puzzle pattern. However, even after taking several hours, they could not solve the problem.
			A value of N is given to them, and they are asked to solve the problem. Since they are stuck for a while, they ask you to solve the problem. Can you help solve this problem?
			Example : Pattern for N = 4
			****
 			 ***
			  **
			   *
			Constraints:
				1 <= T <= 50
				1 <= N <= 300
				Time Limit: 1 sec

			Sample Input 1:
			2
			3
			2
			Sample Output 1:
			***
			 **     
			  *

			**
			 *     
			Explanation for Sample Input 1:
			In the first test case, the value of ‘N’ is 3, so three rows are to be printed from 1 to 3 where each row starts from 3, which goes on till 1. Hence the answer is [“***”,”**”,”*”].

			In the second test case, the value of ‘N’ is 2, so the two rows are to be printed from 1 to 3 where each row starts from 3, which goes on till 1. Hence the answer is [“**”,”*”].
			Sample Input 2:
			2
			4
			5
			Sample Output 2:
			****
			 ***
			  **
			   *

			*****
			 ****     
			  ***
			   **
			    *

		#include <bits/stdc++.h> 
		void ninjaPuzzle(int n) {
			for(int i=0; i<n; i++){
				// spacing
				for(int j=0; j<i; j++)
					cout<<" ";
				
				string s = string(n-i, '*');
				cout<<s<<"\n";
			}
		}
	
	736) Monotone Increasing Digits:
		Problem statement
			You are given a non-negative integer ‘N’. Your task is to find the largest number that is less than or equal to ‘N’ with monotone increasing digits.
			Note:
			An integer has a monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.
			For example:
			Given ‘N’ = 987
			The answer is 899 because that is the greatest monotone increasing number possible that is less than ‘N’.
			Sample Input 1:
				2
				789
				987
				Sample Output 1:
				789
				899
				Explanation of the Sample Input 1:
				For the first test case:
				The answer is 789 because that is the greatest monotone increasing number possible that is equal to ‘N’.

				For the second test case:
				The answer is 899 because that is the greatest monotone increasing number possible.
				Sample Input 2:
				2
				10
				11
				Sample Output 2:
				9
				11
		
		// Not Optimized:
			#include <bits/stdc++.h> 
			int monotoneIncreasingDigits(int n) {
				while(n){
					string temp = to_string(n);

					int flag=1;
					for(int i=1; i<temp.size(); i++){
						if(temp[i-1] > temp[i]){
							flag = 0;
							break;
						}
					}

					if(flag)
						return n;

					n--;
				}
				// return 0;	
			}
	
		// Optimized:
			❌Pending

	737) Remove Duplicates From an Unsorted Linked List:
		Problem statement
			You are given a linked list of N nodes. Your task is to remove the duplicate nodes from the linked list such that every element in the linked list occurs only once i.e. in case an element occurs more than once, only keep its first occurrence in the list.
			For example :
			Assuming the linked list is 3 -> 2 -> 3 -> 4 -> 2 -> 3 -> NULL.
			Number ‘2’ and ‘3’ occurs more than once. Hence we remove the duplicates and keep only their first occurrence. So, our list becomes : 3 -> 2 -> 4 -> NULL.
			Constraints :
				1 <= T <= 100   
				1 <= N <= 10 ^ 4
				1 <= data <= 10 ^ 5 
				Where ‘N’ is the number of nodes in the list and 'data' is the value of list nodes.
				Time Limit: 1sec
			Sample Input 1 :
				2
				4 2 5 4 2 2 -1
				1 2 1 2 2 2 7 7 -1
				Sample Output 1 :
				4 2 5 -1
				1 2 7 -1
				Explanation of Sample Input1 :
				For the first test case, the linked list is 4 -> 2 -> 5 -> 4 -> 2 -> 2 -> NULL. Number ‘4’ and ‘2’ occurs more than once. Hence, we remove the duplicates and keep only their first occurrence. So, our list becomes : 4 -> 2 -> 5 -> NULL.

				For the second test case, the linked list is 1 -> 2 -> 1 -> 2 -> 2 -> 2 -> 7 -> 7 -> NULL. Number ‘1’, ‘2’ and ‘7’ occurs more than once. Hence, we remove the duplicates and keep only their first occurrence. So, our list becomes : 1 -> 2 -> 7 -> NULL.
				Sample Input 2 :
				2
				3 3 3 3 3 -1
				10 20 10 20 30 10 20 30 -1
				Sample Output 2 :
				3 -1
				10 20 30 -1

		// Not Optimized: using map
			#include <bits/stdc++.h> 
			/****************************************************************
				Following is the class structure of the Node class:
				class Node {
				public:
					int data;
					Node *next;
					Node(int data) {
						this->data = data;
						this->next = NULL;
					}
				};
			*****************************************************************/
			Node *removeDuplicates(Node *head) {
				Node *cur = head;
				Node *prev = NULL;
				map<int, bool> vis;
				
				while(cur){
					if(vis[cur -> data]){
						Node *temp = cur;

						prev -> next = cur -> next;
						cur = cur -> next;

						delete temp;
					}else{
						vis[cur -> data] = 1;
						prev = cur;
						cur =cur -> next;
					}
				}
				return head;
			}

			// or TC: O(N²) & SC: O(1), Using loop
				Node *removeDuplicates(Node *head){
					Node *i, *j;
					i = head;
					while(i){
						j = i -> next;
						Node *prev = i;

						while(j){
							if(i -> data == j -> data){
								prev -> next = j -> next;

								delete j;

								j = prev -> next;
							}else{
								prev = j;        
								j= j-> next;
							}
						}
						i = i-> next;
					}
					return head;
				}
		
		// Optimized: using Map
			Node *removeDuplicates(Node *head){
				unordered_map<int, bool> vis;
				if(!head)
					return head;

				vis[head -> data] = 1;
				Node *cur = head;

				while(cur -> next){
					if(vis[cur -> next -> data]){
						cur -> next = cur -> next -> next;
					}else{
						vis[cur -> next -> data] = 1;
						cur = cur -> next;
					}
				}
				return head;
			}
	
	738) Split A Circular Linked List:
		Problem statement
			You are given a circular linked list having N number of nodes, where N is even. You have to split this linked list into two equal-sized circular linked lists.
			Here splitting means you have to make two separate circular linked lists, one for the first N/2 nodes and one for the last N/2 nodes.
			For Example :
			Let the circular linked list be 1, 2, 3, 4. We have to split this into two equal-sized circular linked lists.
			Constraints :
				1 <= T <= 10
				2 <= N <= 10000, N is even
				-10 ^ 9 <= node data <= 10 ^ 9

			Where  ‘node data’ is the value of nodes of the list. 
			Time limit: 1 sec
			Sample Input 1 :
				2
				4
				1 2 3 4
				2
				1 2
				Sample Output 1 :
				1 2
				3 4
				1
				2
				Explanation for sample input 1 :
				Test Case 1: Refer to the example described above.

				Test Case 2:
				The given circular linked list will be splitted as follows:

				Here 1 and 2 will point to themselves as they are the only nodes in the circular linked list.
				Sample Input 2 :
				2
				6
				2 4 3 5 2 1
				4
				1 1 1 1
				Sample Output 2 :
				2 4 3
				5 2 1
				1 1
				1 1

		#include <bits/stdc++.h> 
		/********************************
			class Node {
				public:
				int data;
				Node *next;
				Node(int data) {
					this->data = data;
					this->next = NULL;
				}
			};
		********************************/
		void splitCircularList(Node *head) {
			if(head == NULL)
				return ;
			
			Node *slow, *fast;
			slow = fast = head;

			while(fast -> next != head){
				fast = fast -> next;
				if(fast -> next == head)
					break;

				fast = fast -> next;
				slow = slow -> next;
			}
			fast -> next = slow -> next;
			slow -> next = head;
		}

		// Brute Force:
		int getLen(Node *h){
			int l=0;
			Node *Same = h;
			
			while(h){
				l++;
				h = h-> next;

				if(Same == h)
					break;
			}
			return l;
		}
		void splitCircularList(Node *head) {
			if(!head)
				return ;
			int len = getLen(head) / 2;
			Node *first = head;

			while(--len)
				first = first -> next;

			Node *second = first -> next;
			Node *temp = second;

			while(second -> next != head)
				second = second -> next;

			first -> next = head;
			second -> next = temp;
		}	
	
	739) Split a Circular Linked List into two halves:
		Problem Statement:
			Given a Cirular Linked List of size N, split it into two halves circular lists. If there are odd number of nodes in the given circular linked list then out of the resulting two halved lists, first list should have one node more than the second list. The resultant lists should also be circular lists and not linear lists.
			Example 1:
			Input:
			Circular LinkedList: 1->5->7
			Output:
			1 5
			7

			Example 2:
			Input:
			Circular LinkedList: 2->6->1->5
			Output:
			2 6
			1 5

			Your Task:
				Your task is to complete the given function splitList(), which takes 3 input parameters: The address of the head of the linked list, addresses of the head of the first and second halved resultant lists and Set the head1_ref and head2_ref to the first resultant list and second resultant list respectively.

			Expected Time Complexity: O(N)
			Expected Auxilliary Space: O(1)
			Constraints:
				2 <= N <= 100

		void splitList(Node *head, Node **head1_ref, Node **head2_ref) {
			Node *slow = head;
			Node *fast = head;

			while(fast -> next != head){
				fast = fast -> next;
				if(fast -> next == head)
					break;
					
				fast = fast -> next;
				slow = slow -> next;
			}
			
			fast -> next = slow -> next;
			slow -> next = head;
			
			*head1_ref = head;
			*head2_ref = (fast -> next);
		}

	740) Add One to Linked List:
		Problem statement
			Ninja has been given a number that is represented in the form of a linked list such that each digit corresponds to a node. He has been asked to add 1 to it and return the updated list.
			For Example:
			1234 is represented as (1 -> 2 -> 3 -> 4) and adding 1 to it should change it to (1 -> 2 -> 3 -> 5).
			Note:
			The input Linked list does not have any trailing zeros.
			Constraints:
				1 <= T <= 5
				1 <= N <= 10000
				0 <= |nodeValue| <= 9
				Where ‘N’ denotes the size of the linked list.
				Time Limit: 1 sec
			Sample Input 1:
				1
				4 2 9 -1 
				Sample Output 1:
				4 3 0 -1
				Explanation of Sample Input 1:
				Test case 1:
				For the first test case of sample output 1, our input number is ‘429’. On adding ‘1’ to it, we get output as ‘430’.
				Sample Input 2:
				2 
				9 -1
				9 5 6 5 4 3 5 -1
				Sample Output 2:
				1 0 -1
				9 5 6 5 4 3 6 -1
				Explanation of Sample Input 2:
				Test case 1:
				For the first test case of sample output 2, our given input is ‘9’. On adding 1 to it, we get ‘10’ for which we will have to create a new node and the number of digits has increased from ‘1’ to’2’.

		#include <bits/stdc++.h> 
		/*****************************************************************
			Following is the Linked list node structure already written
			template <typename T>
			class LinkedListNode {
				public:
				T data;
				LinkedListNode<T>* next;
				LinkedListNode(T data) { 
					this->data = data;
					next = NULL;
				}
			};
		*****************************************************************/
		LinkedListNode<int>* addOneToList(LinkedListNode<int> *head) {
			vector<int> v;
			LinkedListNode<int>* T = head;
			while(T){
				v.push_back(T->data);
				T = T -> next;
			}

			v.pop_back();
			v[v.size()-1]++;
			reverse(v.begin(), v.end());

			int c=0;
			for(int i=0; i<v.size(); i++){
				v[i] += c;
				if (v[i] > 9) {
					c = v[i] / 10;
					v[i] %= 10;
				}else{
					c=0;
				}
			}

			if(c!=0)
				v.push_back(c);
			reverse(v.begin(), v.end());

			v.push_back(-1);			
			// for(int i: v)
			//     cout<< i<<"\t";

			int i=0;
			LinkedListNode<int>* nt = new LinkedListNode<int>(v[i++]);
			T = nt;
			LinkedListNode<int>* prev =nt;
			while(i < v.size()){
				LinkedListNode<int>* n = new LinkedListNode<int>(v[i++]);
				prev -> next = n;
				prev = n;        
			}
			prev-> next = nullptr;
			return T;
		}
	
	741) N-th Tribonacci Number:
		Problem Statement:
			The Tribonacci sequence Tn is defined as follows: 
			T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
			Given n, return the value of Tn.		

			Example 1:
				Input: n = 4
				Output: 4
				Explanation:
				T_3 = 0 + 1 + 1 = 2
				T_4 = 1 + 1 + 2 = 4

			Example 2:
				Input: n = 25
				Output: 1389537
			
			Constraints:
				0 <= n <= 37
				The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.
				
		// Not Optimized:
			class Solution {
				public:
				int calculate(int n){
					if(n <= 0)
						return 0;
					else if(n == 1 || n == 2)
						return 1;
					return calculate(n-1) + calculate(n-2) + calculate(n-3);      
				}

				int tribonacci(int n) {
					if(n == 0)
						return 0;
					else if(n == 1 || n == 2)
						return 1;
					return calculate(n-1) + calculate(n-2) + calculate(n-3);
				}
			};

		// Optimized:
			auto init = [](){
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);
				return 0;
			}();

			class Solution {
				public:
				int tribonacci(int n) {
					vector<int> v = {0, 1, 1};

					while(v.size() <= n){
						int ans = v[v.size()-1] + v[v.size()-2] + v[v.size()-3];
						v.push_back(ans);
					}
					return v[n];
				}
			};

	742) Fish Eater:
		Problem statement
			There is a river which flows in one direction. One day, the river has 'N' number of fishes. You are given an array 'FISHES' of integers representing the size of 'N' fishes. The fishes are present in the river from left to right(0th index represents the size of the leftmost fish). As the river flows from left to right so the fishes also swim from left to right. The fishes are of different sizes and have different speeds. The larger fishes are faster than the smaller fishes. Also, larger fishes can eat smaller fishes but can’t eat fishes of the same size.
			Can you find the number of fishes that survive at the end of the day?
			Example:
			Let the size of fishes present in the river from left to right be{ 4, 2, 3, 1, 5 }.
			1. As fish 4 is faster and bigger than fish 2, so fish 4 will eat fish 2.
			Remaining fishes: { 4, 3, 1, 5 }
			2. As fish 3 is faster and bigger than fish 1, so fish 3 will eat fish 1.
			Remaining fishes: { 4, 3, 5 }
			3. As fish 4 is faster and bigger than fish 3, so fish 4 will eat fish 3.
			Remaining fishes: { 4, 5 }
			Now fish 5 cannot eat fish 4, as fish 5 is faster than fish 4 and they swim from left to right. Thus, fish 4 will never reach fish 5.
			Finally, we are left with only 2 fishes.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^4
				1 <= FISHES[i] <= 10^9
				Where 'FISHS[i]' denotes the size of the ith fish in the river.
				Time limit: 1 sec

			Sample Input 1:
				2
				5
				4 2 3 1 5
				3
				8 1 3
				Sample Output 1:
				2
				1
				Explanation of Sample Output 1:
				In test case 1, Refer to the example in problem description.

				In test case 2,
				Fishes: { 8, 1, 3 }
				As fish 8 is faster and bigger than fish 1, so fish 8 will eat fish 1.
					Remaining fishes: { 8, 3 }
				As fish 8 is faster and bigger than fish 3, so fish 8 will eat fish 3.
					Remaining fishes: { 8 }

				Here, only 1 fish is left at last.
				Sample Input 2:
				2
				4
				1 2 3 4
				4
				4 4 2 4
				Sample Output 2:
				4
				3
				Explanation of Sample Output 2:
				In test case 1, As eachfish on the left side is smaller than fish on its right side and thus no fish can eat any other fish and the number of surviving fishes will be 4.

				In test case 2,
				Fishes: { 4, 4, 2, 4}
				As fish with equal size cannot eat each other as having the same speed, All the Fishes with size 4 will survive.
				Fish 2 with size 4 will eat the fish 3 with size 2.
					Remaining fishes: { 4, 4, 4 }
				Here, 3 fishes is left at last.

		#include <bits/stdc++.h> 
		int fishEater(vector<int> &fishes) {
		
			int i=0;
			int val = fishes[i++];

			while(i < fishes.size()){
				if(val > fishes[i]){
					fishes.erase(fishes.begin()+i);
				}else{
					val = fishes[i++];
				}
			}

			return fishes.size();
		}

	743) Sort linked list of 0s 1s 2s:
		Problem statement
			Given a linked list of 'N' nodes, where each node has an integer value that can be 0, 1, or 2. You need to sort the linked list in non-decreasing order and the return the head of the sorted list.
			Example:
			Given linked list is 1 -> 0 -> 2 -> 1 -> 2. 
			The sorted list for the given linked list will be 0 -> 1 -> 1 -> 2 -> 2.
			Sample Input 1:
				7
				1 0 2 1 0 2 1

			Sample Output 1:
				0 0 1 1 1 2 2
			Explanation Of Sample Input 1:
				Input: 1 -> 0 -> 2 -> 1 -> 0 -> 2 -> 1
				Output: 0 -> 0 -> 1 -> 1 -> 1 -> 2 -> 2
			Explanation: 
				In this example, the original linked list contains two 0s, three 1s, and two 2s. The sorted linked list has all the 0s at the beginning, followed by all the 1s, and finally, all the 2s at the end.
			Sample Input 2:
				8
				2 1 0 2 1 0 0 2

			Sample Output 2:
				0 0 0 1 1 2 2 2

			Follow Up:
				Can you solve this without updating the Nodes of the given linked list?


			Constraints :
				1 <= N <= 10^3
				0 <= data <= 2 
				Where 'N' is the length of the linked list.
				Time Limit: 1 sec

		/*
			Following is the class structure of the Node class:
			class Node {
				public:
					int data;
					Node *next;
				Node() {
					this->data = 0;
					next = NULL;
				}
				Node(int data) {
					this->data = data; 
					this->next = NULL;
				}
				Node(int data, Node* next) {
					this->data = data;
					this->next = next;
				}
			};
		*/
		// Approach-1: storing the counts of 0s, 1s, & 2s. then replacing the data of LinkedList based on counts
			Node* sortList(Node *head){
				int zeroCnt, oneCnt, twoCnt;
				zeroCnt = oneCnt = twoCnt = 0;
				Node *cur = head;

				while(cur){
					if(cur -> data == 0)
						zeroCnt++;
					else if(cur -> data == 1)
						oneCnt++;
					else
						twoCnt++;
					
					cur = cur -> next;
				}

				cur = head;
				while(zeroCnt--){
					cur -> data = 0;
					cur = cur -> next;
				}
				
				while(oneCnt--){
					cur -> data = 1;
					cur = cur -> next;
				}
				
				while(twoCnt--){
					cur -> data = 2;
					cur = cur -> next;
				}
				return head;
			}
		
			// or using just one loop to replace the data in LL:
				Node* sortList(Node *head){
					int zeroCnt, oneCnt, twoCnt;
					zeroCnt = oneCnt = twoCnt = 0;
					Node *cur = head;

					while(cur){
						if(cur -> data == 0)
							zeroCnt++;
						else if(cur -> data == 1)
							oneCnt++;
						else
							twoCnt++;
						
						cur = cur -> next;
					}
					cur = head;

					// or using just one loop to replace the data
					while(cur){
						if(zeroCnt){                // if(zeroCnt != 0)
							cur -> data = 0;
							zeroCnt--;
						}else if(oneCnt){              //else if(oneCnt != 0)
							cur -> data = 1;
							oneCnt--;
						}else{
							cur -> data = 2;
							twoCnt--;
						}        
						cur = cur -> next;
					}
					return head;
				}

		// Approach-2: Creating 3 separate LinkedList for storing zero's nodes, ones nodes & 2's nodes & then merging them back	
			Node* sortList(Node *head){
				Node* zeroH = new Node(-1);
				Node* oneH = new Node(-1);
				Node* twoH = new Node(-1);

				// creating Tails for every Node to insert new upcoming node after it
				Node *zeroT = zeroH;
				Node *oneT = oneH;
				Node *twoT = twoH;

				Node *cur = head;
				while(cur){
					if(cur -> data == 0){
						zeroT -> next = cur;
						zeroT = cur;
					}else if(cur -> data == 1){
						oneT -> next = cur;
						oneT = cur;
					}else{
						twoT -> next = cur;
						twoT = cur;
					}
					cur = cur -> next;
				}

				// merging logic
				if(zeroH -> next != nullptr){
					head = zeroH -> next;

					if(oneH -> next != nullptr){
						zeroT -> next = oneH -> next;
						oneT -> next = twoH -> next;

						twoT -> next = nullptr;
					}else{
						zeroT -> next = twoH -> next;
						twoT -> next = nullptr;
					}
				}else if(oneH -> next != nullptr){
					head = oneH -> next;

					oneT -> next = twoH -> next;
					twoT -> next = nullptr;
				}else{
					head =twoH -> next;
					twoT -> next = nullptr;
				}

				// deleting the starting extra/dummy -1 node
				delete zeroH;
				delete oneH;
				delete twoH;

				return head; 
			}

	744) Merge Two Sorted Linked Lists:
		Problem statement
			You are given two sorted linked lists. You have to merge them to produce a combined sorted linked list. You need to return the head of the final linked list.
			Note:
			The given linked lists may or may not be null.
			For example:
			If the first list is: 1 -> 4 -> 5 -> NULL and the second list is: 2 -> 3 -> 5 -> NULL
			The final list would be: 1 -> 2 -> 3 -> 4 -> 5 -> 5 -> NULL
			Constraints:
				1 <= L <= 10^5
				1 ≤ data ≤ 10^6 and data != -1
				Where L is the number of nodes in either of the two Linked List.
				Time Limit: 1 sec 

			Follow-up:
				Try to solve this problem in linear time complexity and constant space complexity.
			Sample Input 1:
				7 8 -1
				1 3 4 6 -1
				Sample Output 1:
				1 3 4 6 7 8 -1
				Explanation of Input 1:
				In this testcase, the first list is: 7 -> 8 -> NULL
				The second list is: 1 -> 3 -> 4 -> 6 -> NULL
				The final list would be: 1 -> 3 -> 4 -> 6 -> 7 -> 8 -> NULL
				Sample Input 2:
				5 -1
				1 3 6 10 -1
				Sample Output 2
				1 3 5 6 10 -1

		#include <bits/stdc++.h>
		/************************************************************
			Following is the linked list node structure.
			template <typename T>
			class Node {
				public:
					T data;
					Node* next;
				Node(T data) {
					next = NULL;
					this->data = data;
				}

				~Node() {
					if (next != NULL) {
						delete next;
					}
				}
			};
		************************************************************/
		
		Node<int>* sortTwoLists(Node<int>* first, Node<int>* second) {
			if(first == NULL)
				return second;
			else if(second == nullptr)
				return first;
			else{
				// checking first smaller element from both list
				Node<int> * ansH = nullptr;

				if(first -> data <= second ->data){
					ansH = first;
					first = first -> next;
				}else{
					ansH = second;
					second = second -> next;
				}

				Node<int>* curTail = ansH;

				while(first && second){
					if(first -> data <= second -> data){
						curTail -> next = first;
						curTail = first;

						first = first -> next;
					}else{
						curTail -> next = second;
						curTail = second;
						
						second = second -> next;
					}
				}

				if(second == nullptr)
					curTail -> next = first;
				else
					curTail -> next = second;
				
				return ansH;
			}
		}

		// or
			
			Node<int>* solve(Node<int>* first, Node<int>* second){
				if(first -> next == nullptr){
					first -> next = second;
					return first;
				}

				Node<int>* cur1 = first, *next1 = first -> next;
				Node<int>* cur2 = second, *next2 = second -> next;

				while(next1 && cur2) {
					if ((cur2->data) >= (cur1->data) && (cur2->data) <= (next1->data)) { 
						next2 = cur2->next; 
						cur1->next = cur2; 
						cur2->next = next1; 
				
						// Let cur1 and cur2 to point to their immediate next pointers.
						cur1 = cur2; 
						cur2 = next2; 
					} 
					else { 
						// if there are more nodes in first list.
						if (next1->next) { 
							next1 = next1->next; 
							cur1 = cur1->next;
						}

						// else point the last node of first list to the remaining nodes of
						// second list.
						else {
							next1->next = cur2;
							return first;
						}
					}
				}

				return first;
			}

			Node<int>* sortTwoLists(Node<int>* first, Node<int>* second) {
				if(first == NULL)
					return second;
				else if(second == nullptr)
					return first;
				else{
					if(first -> data <= second -> data){
						return solve(first, second);
					}else{
						return solve(second, first);
					}
				}
			}

	745) Maximum sum of hour glass:
		Problem Statement:
			Given two integers n, m and a 2D matrix mat of dimensions nxm, the task is to find the maximum sum of an hourglass.
			An hourglass is defined as a part of the matrix with the following form:
				A B C
				  D
				E F G
			Return -1 if any hourglass is not found.
			Example 1:
			Input:
				n = 3, m = 3
				mat = [[1, 2, 3],
					[4, 5, 6],
					[7, 8, 9]]
				Output: 35
			Explanation:
			There is only one hour glass which is
			1 2 3
			  5
			7 8 9   
			and its sum is 35.
			
			Example 2:
			Input:
			n = 2, m = 3
			mat = [[1, 2, 3],
				[4, 5, 6]]
			Output:
			-1
			Explanation:
			There are no hour glasses in this matrix.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function findMaxSum() which takes the two integers n, m, and the 2D matrix mat as input parameters and returns the maximum sum of an hourglass in the matrix. If there are no hourglasses, it returns -1.

			Expected Time Complexity: O(n*m)
			Expected Auxillary Space: O(1)

			Constraints:
				1 <= n <= 150
				3 <= m <= 150
				0 <= mat[i][j] <= 10^6

		class Solution {
			public:
			int findMaxSum(int n, int m, vector<vector<int>> mat) {
				if(n <=2 || m <=2)
					return -1;

				int mxSum = 0;
				for(int i=0; i < n-2; i++){
					for(int j=0; j < m-2; j++){
						int tempSum =0;
						tempSum += mat[i][j] + mat[i][j+1] + mat[i][j+2];
						tempSum += mat[i+1][(j + (j+2))/2];
						tempSum += mat[i+2][j] + mat[i+2][j+1] + mat[i+2][j+2];
						
						mxSum = max(tempSum, mxSum);
						// cout<< tempSum << "\t";
					}
				}
				// cout<<"\n";
				return mxSum;
			}
		};

	746) Rotate array:
		Problem statement
			Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative.
			Example:
			'arr '= [1,2,3,4,5]
			'k' = 1  rotated array = [2,3,4,5,1]
			'k' = 2  rotated array = [3,4,5,1,2]
			'k' = 3  rotated array = [4,5,1,2,3] and so on.
			Detailed explanation ( Input/output format, Notes, Images )
			Sample Input 1:
			8
			7 5 2 11 2 43 1 1
			2
			Sample Output 1:
			2 11 2 43 1 1 7 5
			Explanation of Sample Input 1:
			Rotate 1 steps to the left: 5 2 11 2 43 1 1 7
			Rotate 2 steps to the left: 2 11 2 43 1 1 7 5
			Sample Input 2:
			4
			5 6 7 8
			3
			Sample Output 2:
			8 5 6 7
			Explanation of Sample Input 2:
			Rotate 1 steps to the left: 6 7 8 5
			Rotate 2 steps to the left: 7 8 5 6
			Rotate 2 steps to the left: 8 5 6 7
			Expected Time Complexity:
			O(n), where ‘n’ is the size of the array ‘arr’ and ‘k’ is the number of rotations.
			Constraints:
				1 <= 'n' <= 10^3
				1 <= 'arr'[i] <= 10^9
				1 <= 'k' < 'n'
			Hints:
				1. For an index ‘i’, find where it lands after k swaps.
				2. When performing rotation once observe how the positions of all elements change.

		vector<int> rotateArray(vector<int>arr, int k) {
			int n = arr.size();

			if(n == k)
				return arr;
			
			reverse(arr.begin(), arr.end());
			reverse(arr.begin(), arr.begin()+(n-k));
			reverse(arr.begin()+(n-k), arr.end());
			
			return arr;
		}
	
	747) Check if Linked List is Palindrome:
		Problem Statement:
			Given a singly linked list of size N of integers. The task is to check if the given linked list is palindrome or not.
			Example 1:
			Input:
			N = 3
			value[] = {1,2,1}
			Output: 1
			Explanation: The given linked list is
			1 2 1 , which is a palindrome and
			Hence, the output is 1.

			Example 2:
			Input:
			N = 4
			value[] = {1,2,3,4}
			Output: 0
			Explanation: The given linked list
			is 1 2 3 4 , which is not a palindrome
			and Hence, the output is 0.

			Your Task:
				The task is to complete the function isPalindrome() which takes head as reference as the only parameter and returns true or false if linked list is palindrome or not respectively.

			Expected Time Complexity: O(N)
			Expected Auxialliary Space Usage: O(1)  (ie, you should not use the recursive stack space as well)

			Constraints:
				1 <= N <= 10^5

		/*
			struct Node {
				int data;
				struct Node *next;
				Node(int x) {
					data = x;
					next = NULL;
				}
			};
		*/

		/* TC: O(N) & SC: O(N)*/
			#include<bits/stdc++.h>
			class Solution{
				public:
				//Function to check whether the list is palindrome.
				bool isPalindrome(Node *head) {
					vector<int> v;
					Node *temp = head;
					while(temp){
						v.push_back(temp -> data);
						temp = temp -> next;
					}
					
					// checking reverse
					int s = 0, e = v.size()-1;
					
					while(s < e)
						if(v[s++] != v[e--])
							return 0;
					return 1;
				}
			};
		
		/* TC: O(N) & SC: O(1)*/
			-find out the middle node
			-reverse all the nodes after that middle node
			-compare both head & next of middle node's data
			class Solution{
				Node* getMid(Node *head){
					// for odd length both slow & fast pointer you can keep on head, it will work
					// but in case of even length you need to keep the fast pointer one step ahead of slow pointer at start
					
					Node* slow = head, *fast = head -> next;
					while(fast && fast -> next){
						fast = fast -> next -> next;
						slow = slow -> next;
					}
					return slow;
				}
				
				Node* reverse(Node* &temp){
					Node* cur = temp;
					Node* prev = nullptr;
					Node* next;
					
					while(cur){
						next = cur -> next;
						cur -> next = prev;
						prev = cur;
						
						cur = next;
					}
					
					return prev;
				}
				
				public:
				//Function to check whether the list is palindrome.
				bool isPalindrome(Node *head) {
					if(head == nullptr || head -> next == nullptr)
						return 1;
						
					Node *mid = getMid(head);
					
					// this lines reversing the LL after mid point.
					mid -> next = reverse(mid -> next);
					
					// checking palindrome or not
					Node* h1 = head;
					Node* h2 = mid -> next;
					
					while(h2){
						if(h1 -> data != h2 ->data){
							mid -> next = reverse(mid -> next);
							return 0;
						}
						h2 = h2 -> next;
						h1 = h1 -> next;
					}
					
					// this lines makes the LL as it is previously
					mid -> next = reverse(mid -> next);
					return 1;
				}
			};

	748) Majority Element (Refer Q.352)
		Problem Statement:
			Given an array A of N elements. Find the majority element in the array. A majority element in an array A of size N is an element that appears strictly more than N/2 times in the array. 
			Example 1:
			Input:
			N = 3 
			A[] = {1,2,3} 
			Output:
			-1
			Explanation:
			Since, each element in 
			{1,2,3} appears only once so there 
			is no majority element.

			Example 2:
			Input:
			N = 5 
			A[] = {3,1,3,3,2} 
			Output:
			3
			Explanation:
			Since, 3 is present more
			than N/2 times, so it is 
			the majority element.

			Your Task:
				The task is to complete the function majorityElement() which returns the majority element in the array. If no majority exists, return -1.
			
			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ N ≤ 10^7
				0 ≤ Ai ≤ 10^6

		// Not Optimized 		/*TC: O(N²) & SC:O(1)*/
			class Solution{
				public:
				int majorityElement(int a[], int size) {
					for(int i=0; i<size; i++){
						int cnt=0;
						for(int j=i; j<size; j++)
							if(a[i] == a[j])
								cnt++;
							
						if(cnt > size/2)
							return a[i];
					}
					return -1;
				}
			};

		/*TC: O(N) & SC:O(N)*/
			class Solution{
				public:
				// Function to find majority element in the array
				// a: input array
				// size: size of input array
				int majorityElement(int a[], int size) {
					map<int, int> mp;
					for(int i=0; i<size; i++)
						mp[a[i]]++;
						
					for(auto i: mp)
						if(i.second > (size/2))
							return i.first;
					
					return -1;
				}
			};

		/*TC: O(N) & SC:O(1)*/
			class Solution{
				public:
				int majorityElement(int nums[], int size) {
					int count = 0;    
					int element = 0; 
					
					for (int i = 0; i < size; i++) {
						if (count == 0) {
							element = nums[i];
							count = 1;
						} else if (element == nums[i]) {
							count++;
						} else {
							count--;
						}
					}

					int cnt=0;
					for(int i=0; i<size; i++)
						if(nums[i] == element)
							cnt++;
					
					if(cnt > size/2)
						return element;
						
					return -1;
				}
			};
	
	749) Delete Node In A Linked List:
		Problem statement
			You are given a Singly Linked List of integers and a reference to the node to be deleted. Every node of the Linked List has a unique value written on it. Your task is to delete that node from the linked list.
			A singly linked list is a linear data structure in which we can traverse only in one direction i.e. from Head to Tail. It consists of several nodes where each node contains some data and a reference to the next node.
			Note:
			• The reference to the head of the linked list is not given.
			• The node to be deleted is not a tail node.
			• The value of each node in the Linked List is unique.
			• It is guaranteed that the node to be deleted is present in the linked list.
			A sample Linked List-
			Constraints:
				1 <= T <= 100
				2 <= N <= 5000
				-10 ^ 9 <= NODE.DATA <= 10 ^ 9 and node.data != -1
				Where 'N' denotes the total number of nodes in the Linked List and 'NODE.DATA' is the value of the node present.
				Time limit: 1 sec.

			Sample Input 1:
			2
			2 5 7 10 -1
			7
			-8 3 4 -2 1 -1
			4
			Sample Output 1:
			2 5 10 -1
			-8 3 -2 1 -1
			Explanation for sample input 1:
			For the first test case, the given Linked List is
			So, after deleting the node 7, the Linked List becomes 2 → 5 → 10 → NULL, which is shown in the below figure.
			For the second test case, the given Linked List is
			So, after deleting the node 4, the Linked List becomes  -8 → 3 → -2 → 1 → NULL.
			Sample Input 2:
			2
			4 9 10 -1
			4
			-7 7 -1
			-7
			Sample Output 2:
			9 10 -1
			7 -1
			Explanation for sample input 2:
			For the first test case, the given Linked List is
			So, after deleting the node 4, the Linked List becomes 9 → 10 → NULL.
			For the second test case, the given Linked List is
			So, after deleting the node -7, the Linked List becomes 7 → NULL.

		#include <bits/stdc++.h>
		/****************************************************************
			Following is the class structure of the LinkedListNode class:
			template <typename T>
			class LinkedListNode {
			public:
				T data;
				LinkedListNode<T> *next;
				LinkedListNode(T data)
				{
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/
		void deleteNode(LinkedListNode<int> * node) {
			node -> data = node -> next -> data;
			node -> next = node -> next -> next;
		}
	
	#CN WeeklyContest-123:
		750) Alice's Nickname:
			Problem statement
				As Alice is bored with her original name, she wants a nickname for her, so she asks Bob to give her a nickname.
				Bob also has a nickname which can be represented by a string of 'N' lowercase English letters. He thinks new name for Alice which contains 'N' lowercase English letters and tells her the name.
				As Alice loves Bob's nickname she wants every letter of her nickname must be there in Bob's nickname. Also, she wants her name to be unique, so she wants that for each 'i', the 'i-th' character of her nickname must be different from the 'i-th' character of Bob's nickname.
				You are given strings 'A' and 'B' representing Bob's nickname and the nickname Bob thought for Alice. Determine whether the nickname Bob thought follows the conditions given by Alice or not.
				Return '1' if Alice's conditions for her nickname are fulfilled and return '0' otherwise.
				Example:
				N = 3
				A = 'aab'
				B = 'bba
				We can see that every character ('a' and 'b') in Alice's name is there in Bob's name and for each 'i', 'A[i]' is different from 'B[i]'. So the conditions are fulfilled.
				So, the answer for this case is '1'.
				Detailed explanation ( Input/output format, Notes, Images )
				Constraints:
					1 <= 'N' <= 100
					'a' <= 'A[i]' <= 'z'
					'a' <= 'B[i]' <= 'z'
					Time limit: 1 sec
				Sample input 1:
					2
					3
					aaa
					bbb
					2
					ab
					ba
					Sample output 1:
					0
					1
					Explanation of sample input 1:
					For test case 1:
					You can see there is character 'a' in Alice's nickname which is not in Bob's nickname.
					So, the answer for this case is '0'.

					For test case 2:
					We can see that every character ('a' and 'b') in Alice's name is there in Bob's name and for each 'i', 'A[i]' is different from 'B[i]'. So the conditions are fulfilled.
					So, the answer for this case is '1'.
					Sample input 2:
					2
					6
					acbbcd
					bacdef
					1
					a
					a
					Sample output 2:
					1
				0

			// Own Solution:
				int isNicknameGood(int n, string a, string b) {
					for(int i=0; i<n; i++)
						if(a[i] == b[i])
							return 0;

					set<char> sa (a.begin(), a.end());
					set<char> sb (b.begin(), b.end());

					string s1 (sa.begin(), sa.end());
					string s2 (sb.begin(), sb.end());
					
					if(s1 == s2)
						return 1;

					int i=0;
					while(i < s1.size()){
						if(s2.find(s1[i]) == string::npos)
							return 0;
						i++;
					}
					return 1;
				}
			
			// Main Solution:
				int isNicknameGood(int n, string a, string b) {
					for(int i=0; i<a.size(); i++){
						int p = 1;

						for(int j=0; j<b.size(); j++){
							if(b[j] == a[i]){               // every char of b should be present in a
								p = 0;
								break;
							}
						}
						
						if (p || a[i] == b[i]) return 0;
					}
					return 1;
				}

		751) Maximum Number:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’ You can apply the following operation at most once.
				Select any element ‘A[i]’ in the array and change any digit within it to a digit ‘D’.
				The digit ‘D’ should be in between ‘1’ and ‘9’, and ‘(D & (D - 1))’ should be equal to ‘0’.
				Here, ‘&’ denotes the bitwise ‘AND’ operation.
				You have to find the maximum possible integer you can make after applying this operation no more than one time.
				Your task is to tell the maximum possible integer you can make after applying the given operation no more than one time and return it.
				Example:
				‘N’ = 3
				‘A’ = [92, 939, 61]
				Here, the best possible way is to choose the ‘1st’ element and replace ‘3’ to ‘8’, as ‘(8 & (8 - 1))’ is equal to ‘0’.
				Now, the integer ‘939’ will be converted to ‘989’, which is the best possible answer we can make.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					1 <= A[i] <= 10^8
					Time Limit: 1 sec 
				Sample Input 1:
					2
					4
					217 9999 10 233
					2
					87 9
					Sample Output 1:
					9999
					88
					Explanation of sample input 1:
					For test case 1:
					Here, the ‘1st’ element is the best possible answer we can make. There is no need to apply the given operation. 

					For test case 2:
					The most optimal way is to select the ‘0th’ element and replace its digit ‘7’ to ‘8’. Now, the element ‘87’ will be converted to ‘88’, which is the best possible answer we can make.
					Sample Input 2:
					2
					3
					89 899 99
					2
					10 17
					Sample Output 2:
					899
					87

			int maximumNumber (int n, vector <int> &a) {
				sort(a.begin(), a.end(), greater<int>());

				int z = 0;
				int mxINT = a[0];

				while(z < a.size()) {
					int f = a[z];
					string s = to_string(f);

					for(int i=0; i<s.size(); i++)
					if(s[i] != '9' && s[i] != '8'){
						s[i] = '8';
						break;
					}
					mxINT = max(mxINT, stoi(s));
					z++;
				}
				return mxINT;
			}
		
		752) Even minus Odd:
			Problem statement
				You are given an array 'A' of 'N' integers from '0' to 'N - 1' and an integer 'K'.
				Good subarray is a subarray of 'A' in which 'number of even elements - number of odd elements' is equal to 'K'.
				You are required to find the number of good subarrays of the array 'A'.
				Example:
				N = 4
				K = 1
				A = [1, 4, 6, 3]
				There are total '4' good subarrays ['1', '4', '6'], ['4', '6', '3'], ['4'], and ['6'].
				It can be proved that there is no other good subarray of the array 'A'.
				So, the answer for this case is '4'.
				Constraints:
					1 <= 'N' <= 10^5
					'1' <= A[i] <= '10^9'

					Time limit: 1 sec
				Sample input 1:
					2
					2 0
					1 1
					3 1
					1 2 2
					Sample output 1:
					0
					3
					Explanation of sample input 1:
					For test case 1:
					It can be proved that there is no good subarray in the array 'A'.
					So, the answer for this case is '0'.

					For test case 2:
					There are total '3' good subarrays ['1', '2', '2'], ['2'], and ['2']. (Note that ['2'] is counted two times as there are two different subarrays ['2'] in the given array.)
					It can be proved that there is no other good subarray of the array 'A'.
					So, the answer for this case is '3'.
					Sample input 2:
					2
					4 2
					1 2 2 4
					5 2
					1 4 1 4 4
					Sample output 2:
					3
					2

			// Not Optimized:
				bool areEqualToK(int s, int e, vector<int> &v, int k){
					int even, odd;
					
					even = odd = 0;
					for(int i=s; i<=e; i++)
						if(v[i] & 1)
							odd++;
						else
							even++;
					
					if((even - odd) == k)
						return 1;
					return 0;
				}
				int numberOfsubarrays(int n, int k, vector<int> &v) {
					int ttlCnt=0;

					for(int i=0; i<n; i++)
						for(int j=i; j<n; j++)
							if(areEqualToK(i, j, v, k))
								ttlCnt++;

					return ttlCnt;
				}

			// Optimized: ❌Pending
				int numberOfsubarrays(int n, int k, vector<int> &v) {
					int diff=0, ttlCnt = 0;

					map<int, int> fr;
					fr[diff]++;

					for(int i=0; i<n; i++){
						if(v[i] & 1)
							diff--;
						else
							diff++;

						if(fr.find(diff - k) != fr.end())
							ttlCnt += fr[diff-k];
						
						fr[diff]++;
					}

					return ttlCnt;
				}

	753) Intersection of Multiple Arrays:
		Problem Statement:
			Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.
			Example 1:
			Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
			Output: [3,4]

			Explanation: 
			The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].

			Example 2:
			Input: nums = [[1,2,3],[4,5,6]]
			Output: []
			Explanation: 
			There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
			
			Constraints:
				1 <= nums.length <= 1000
				1 <= sum(nums[i].length) <= 1000
				1 <= nums[i][j] <= 1000
				All the values of nums[i] are unique.
		
		class Solution {
			public:
			vector<int> intersection(vector<vector<int>>& nums) {
				vector<int> ans;

				vector<int> temp = nums[0];

				if(nums.size() == 1){
					sort(temp.begin(), temp.end());
					return temp;
				}
				
				for(int i=0; i<temp.size(); i++){
					int p = 0;
					for(int j = 1; j< nums.size(); j++){
						p=0;
						if(find(nums[j].begin(), nums[j].end(), temp[i]) != nums[j].end())
							p=1;

						if(p == 0)
							break;
					}
					if(p)
						ans.push_back(temp[i]);
				}
				
				sort(begin(ans), end(ans));
				return ans;
			}
		};

	#LeetCode BiweeklyContest-129:
		754) Make a Square with the Same Color:
			https://leetcode.com/problems/make-a-square-with-the-same-color/description/
			Problem Statement:
				You are given a 2D matrix grid of size 3 x 3 consisting only of characters 'B' and 'W'. Character 'W' represents the white color, and character 'B' represents the black color.
				Your task is to change the color of at most one cell so that the matrix has a 2 x 2 square where all cells are of the same color.
				Return true if it is possible to create a 2 x 2 square of the same color, otherwise, return false.	
				Example 1:			
					Input: grid = [
								["B","W","B"],
								["B","W","W"],
								["B","W","B"]
							]

					Output: true
					Explanation:
					It can be done by changing the color of the grid[0][2].

				Example 2: 
					Input: grid = [
								["B","W","B"],
								["W","B","W"],
								["B","W","B"]
							]
					Output: false
					Explanation:
					It cannot be done by changing at most one cell.
				Example 3:
					Input: grid = [
								["B","W","B"],
								["B","W","W"],
								["B","W","W"]
							]
					Output: true
					Explanation:
					The grid already contains a 2 x 2 square of the same color.

				Constraints:
					grid.length == 3
					grid[i].length == 3
					grid[i][j] is either 'W' or 'B'.

			// Brute Force:
				-for 3x3 matrix only.
				class Solution {
					public:
					bool canMakeSquare(vector<vector<char>>& grid) {
						int cnt = 0;
						
						for(int i=0; i<2; i++){
							for(int j=0; j<2; j++){
								if(grid[i][j] == 'B')
									cnt++;
							}
						}
						
						if(cnt == 3 || cnt == 1 || cnt == 4 || cnt == 0)
								return 1;
						
						cnt =0;
						for(int i=0; i<2; i++){
							for(int j=1; j<3; j++){
								if(grid[i][j] == 'B')
									cnt++;
							}
						}
						
						if(cnt == 3 || cnt == 1 || cnt == 4 || cnt == 0)
								return 1;
						
						cnt =0;
						for(int i=1; i<3; i++){
							for(int j=0; j<2; j++){
								if(grid[i][j] == 'B')
									cnt++;
							}
						}
						
						if(cnt == 3 || cnt == 1 || cnt == 4 || cnt == 0)
								return 1;
						
						cnt =0;
						for(int i=1; i<3; i++){
							for(int j=1; j<3; j++){
								if(grid[i][j] == 'B')
									cnt++;
							}
						}
						
						if(cnt == 3 || cnt == 1 || cnt == 4 || cnt == 0)
								return 1;
						return 0;
					}
				};

			// Generic Code:
				-for larger input:
				class Solution {
					public:
					bool isPossible(vector<vector<char>>& grid, int i, int j){
						int W = 0, B = 0;
						for(int x = i; x < i + 2; x++){
							for(int y = j; y < j + 2; y++){
								if(grid[x][y] == 'W') W++;
								else B++;
							}
						}
						if(W > 2 || B > 2) return 1;
						return 0;
					}
					bool canMakeSquare(vector<vector<char>>& grid){
						int n = grid.size();
						for(int i = 0; i <= n - 2; i++){ // n- 2 since square size is 2
							for(int j = 0; j <= n - 2; j++){
								if(isPossible(grid, i, j)) return 1;
							}
						}
						return 0;
					}
				};
		
	755) Fold and Merge Linked List:
		Problem statement
			You are given a singly linked list containing ‘N’ nodes (‘N’ is even), where every node in the linked list contains a pointer ‘NEXT’, which points to the next node in the list and has an integer value associated with it.
			Your task is to break LinkedList into two halves and then take the first half, fold it over the second half and merge all the intersecting nodes by taking their product.
			Note :
			You will apply this operation only once, check example for better understanding.
			Example :
			N = 4
			NODE = 1 -> 2 -> 3 -> 4
			In the following example, first, you break your List into two equal half, [ 1 -> 2 ] and [ 3 -> 4 ], 
			Now you will fold the first half over the second half and merge them with their product.
			So the answer is [ 3 * 2 -> 4 * 1 ] i.e. [ 6 -> 4 ].
			Constraints :
				1 <= T <= 10
				1 <= N <= 1e5
				Sum of N <= 10^5

				Time Limit: 1 sec
			Sample Input 1 :
				2
				2 2 2 2 -1
				4 5 3 1 2 6 -1
				Sample Output 1 :
				4 4 -1
				3 10 24 -1
				Explanation Of Sample Input 1 :
				For test case 1, 
				First, we will break into two equal halves, [ 2 -> 2 ] and [ 2 -> 2 ], now folding and merging with the product, so the result is [ 2 * 2 -> 2 * 2 ] i.e. [ 4 -> 4 ].

				For test case 2,
				For this case the two halves are [ 4 -> 5 -> 3 ] and [ 1 -> 2 -> 6 ], now folding and merging with product [ 3 * 1 -> 5 * 2 -> 6 * 4 ] i.e [ 3 -> 10 -> 24 ] 
				Sample Input 2 :
				2
				3 1 2 2 -1
				5 5 1 2 1 2 -1
				Sample Output 2 :
				2 6 -1
				2 5 10 -1

		#include <bits/stdc++.h> 
		/************************************************
			Following is the linkedList class structure:
			class List {
				public:
					int data;
					List *next;

				List(int val) {
					this->data = val;
					next = NULL;
				}
				~List() {
					if (next != NULL) {
						delete next;
					}
				}
			};
		*************************************************/
		List* reverse(List* h, List* mid){
			List* prev = nullptr;
			List* cur = h;

			List* T;

			while(cur != mid){
				T = cur -> next;

				cur -> next = prev;
				prev = cur;
				cur = T;
			}
			return prev;
		}

		List* getMid(List* temp){
			List* fast = temp -> next;
			while(fast && fast -> next){
				fast = fast -> next -> next;
				temp = temp -> next;
			}
			return temp;
		}

		List* foldAndMerge(List *head) {
			List* mid = getMid(head);
			List* itr2 = mid;

			// reverse the first half
			List* itr1 = reverse(head, mid);

			// cout<<itr1 -> data << "\t"<< itr2 ->data << "\t\t";

			head = itr1;
			List* holder = nullptr;
			while(itr1){
				itr1 -> data =(itr1 -> data *  itr2->data);
				// cout<<itr1 -> data <<"\t"<<itr2->data<<"\n";

				holder = itr1;

				itr1 = itr1 -> next;
				itr2 = itr2 -> next;   
			}
			
			List * n = new List(-1);
			holder -> next = n;
			return head;
		}

		// Simpler:
			int length(List* h){
				int l=0;

				while(h){
					l++;
					h = h -> next;
				}
				return l;
			}

			List* finder(List* h, int n){
				while(--n)
					h = h-> next;
				return h;
			}

			List* reverse(List* h, List* midNext){
				List* cur = h;
				List* pre = nullptr;
				List* next =0;

				while(cur != midNext){
					next = cur -> next;
					cur -> next = pre;
					pre =cur;
					cur = next;
				}
				return pre;
			}

			List* foldAndMerge(List *head) {
				// firstly find the length of LL
				int len = length(head);
				List* mid = finder(head, len/2);

				// reverse the LL from mid Node
				List* itr2 = mid -> next;
				List* itr1 = reverse(head, mid->next);
				
				head = itr2;
				while(itr2 && itr1){
					itr2 -> data = itr1 -> data * itr2 ->data;
					itr2 = itr2 -> next;
					itr1 = itr1 -> next;
				}
				return head;
			}
	
	756) Fahrenheit to Celsius:
		Problem statement
			Ninja has been assigned to convert temperature from Fahrenheit to Celsius. He has been given a starting Fahrenheit Value (S), ending Fahrenheit value (E), and step size (W). Unfortunately, he does not know how to convert from Fahrenheit to Celsius. Please help him to find the result.
			Constraints:
				1 <= T <= 5
				1 <= S <= E <= 10000
				1 <= W <= 50

				Time limit: 1 sec.
			Sample Input 1:
				2
				0 100 20
				25 50 25
				Sample Output 1:
				0 -17
				20 -6
				40 4
				60 15
				80 26
				100 37
				25 -3
				50 10
				Explanation Of Sample Input 1:
				Test case 1:
				For the first test case of sample output 1, we start from Fahrenheit temperature 0 and move up to 100 with a step size of 20 units. For every temperature, we have a corresponding celsius temperature present in the output table.

				Test case 2:   
				For the second test case of sample output 1, we start from Fahrenheit temperature 25 and move up to 50 with a step size of 25 units. For every temperature, we have a corresponding celsius temperature present in the output table.
				Sample Input 2:
				2
				50 150 15
				600 650 7
				Sample Output 2:
				50 10
				65 18
				80 26
				95 35
				110 43
				125 51
				140 60
				600 315
				607 319
				614 323
				621 327
				628 331
				635 335
				642 338
				649 342
				Explanation Of Sample Input 2:
				Test case 1:
				For the first test case of sample output 2, we have all celsius temperatures for the Fahrenheit range of 50 to 150.
		
		#include <bits/stdc++.h> 
		vector<vector<int>> fahrenheitToCelsius(int s, int e, int w) {
			vector<vector<int>> ans;

			for(int i=s; i<=e; i += w){
				vector<int> temp;
				temp.push_back(i);
				temp.push_back((i-32) * 5/9);
				ans.push_back(temp);
			}
			return ans;
		}
	
	757) Maximum XOR of Two Numbers in an Array:
		Problem statement
			An array ‘A’ of ‘N’ integers is provided. Return the maximum possible number which can be created by taking bitwise XOR of any 2 integers of the array.
			Example:
			If the array is 2,5 and 6
			2 XOR 5 is 7
			2 XOR 6 is 4
			5 XOR 6 is 3
			Hence the answer is 7.
			Sample Input 1:
				3
				2 1 4
				Sample Output 1:
				6
				Explanation for Sample Input 1:
				Select the 1st and 3rd element leading to a xor value of 6.
				Sample Input 2:
				2
				3 2
				Sample Output 2:
				1
				Constraints:
				1 <= N <= 10^4
				1 <= A[i] <= 10^9 

				Time Limit: 1 sec

		//Not Optimized:
			int maximumXor(vector<int> A) {
				int mxNum = 0;
				
				for(int i=0; i<A.size(); i++)					// instead of using this A.size(), assign it to some variable & used that variable it reduces time complexity	
					for(int j=i+1; j<A.size(); j++)
						mxNum = max(mxNum, (A[i] ^ A[j]));

				return mxNum;
			}

		// Optimized:
			int maximumXor(vector<int> A) {
				int mxN = 0, n = A.size();

				for(int i=0; i<n; i++)
					for(int j=i+1; j<n;j++)
						mxN = max(mxN, (A[i]^A[j]));

				return mxN;
			}
	
	758) Delete Middle of Linked List:
		Problem Statement:
			Given a singly linked list, delete middle of the linked list. For example, if given linked list is 1->2->3->4->5 then linked list should be modified to 1->2->4->5.
			If there are even nodes, then there would be two middle nodes, we need to delete the second middle element. For example, if given linked list is 1->2->3->4->5->6 then it should be modified to 1->2->3->5->6.
			If the input linked list has single node, then it should return NULL.

			Example 1:
				Input:
				LinkedList: 1->2->3->4->5
				Output: 
				1 2 4 5

			Example 2:
				Input:
				LinkedList: 2->4->6->7->5->1
				Output: 
				2 4 6 5 1
			Your Task:
				The task is to complete the function deleteMid() which takes head of the linkedlist  and return head of the linkedlist with middle element deleted from the linked list. If the linked list is empty or contains single element then it should return NULL.
			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(1).
			Constraints:
				1 <= n <= 10^5
				1 <= value[i] <= 10^9

		/* Link list Node:
			struct Node {
				int data;
				struct Node* next;

				Node(int x){
					data = x;
					next = NULL;
				}
			};
		*/

		// Deletes middle of linked list and returns head of the modified list
		class Solution{
			public:
			Node* deleteMid(Node* head) {
				
				// handling edge cases where one element in LL
				if(head -> next == nullptr)
					return nullptr;
				
				// edge cases where 2 element in LL
				if(head -> next -> next == nullptr){
					head -> next = nullptr;
					return head;
				}
				
				// cases where more than 2 element in LL
				Node* mid = head;
				Node* fast = head;
				
				while(fast && fast -> next){
					fast = fast -> next-> next;
					mid = mid -> next;
				}
				
				mid -> data = mid -> next -> data;
				mid -> next = mid -> next -> next;
				
				return head;
			}
		};

	759) Add two numbers represented by linked lists:
		Problem Statement:
			Given two decimal numbers, num1 and num2, represented by linked lists of size n and m respectively. The task is to return a linked list that represents the sum of these two numbers.
			For example, the number 190 will be represented by the linked list, 1->9->0->null, similarly 25 by 2->5->null. Sum of these two numbers is 190 + 25 = 215, which will be represented by 2->1->5->null. You are required to return the head of the linked list 2->1->5->null.
			Note: There can be leading zeros in the input lists, but there should not be any leading zeros in the output list.
			Example 1:
			Input:
			n = 2
			num1 = 45 (4->5->null)
			m = 3
			num2 = 345 (3->4->5->null)
			Output: 
			3->9->0->null  
			Explanation: 
			For the given two linked list (4 5) and (3 4 5), after adding the two linked list resultant linked list will be (3 9 0).

			Example 2:
			Input:
			n = 4
			num1 = 0063 (0->0->6->3->null)
			m = 2
			num2 = 07 (0->7->null)
			Output: 
			7->0->null
			Explanation: 
			For the given two linked list (0 0 6 3) and (0 7), after adding the two linked list resultant linked list will be (7 0).

			Your Task:
				The task is to complete the function addTwoLists() which has node reference of both the linked lists and returns the head of the sum list.   

			Expected Time Complexity: O(n+m)
			Expected Auxiliary Space: O(max(n,m)) for the resultant list.

			Constraints:
				1 <= n, m <= 10^4

		/* node for linked list:
			struct Node {
				int data;
				struct Node* next;
				Node(int x) {
					data = x;
					next = NULL;
				}
			};
		*/

		class Solution {
			Node* reverse(Node* &h){
				Node* cur = h;
				Node* prev = nullptr;
				
				while(cur){
					Node* upcoming = cur -> next;
					cur -> next = prev;
					prev = cur;
					cur = upcoming;
				}
				return prev;
			}
			
			Node* addLL(Node* &a, Node* &b){
				Node* h = nullptr;
				Node* tail = nullptr;
				int c=0;
				
				while(a && b){
					int sum = a->data + b->data + c;
					
					c = sum / 10;
					Node * n = new Node(sum%10);
					
					if(h == nullptr){
						h = n;
						tail = n;
					}else{
						tail -> next = n;
						tail = n;
					}
					
					a = a-> next;
					b = b-> next;
				}
				
				while(a){
					int sum = c + a->data;
					
					c = sum / 10;
					
					Node* n = new Node(sum%10);
					
					tail -> next = n;
					tail = n;
					
					a = a -> next;
				}
				
				while(b){
					int sum = c + b->data;
					
					c = sum / 10;
					
					Node* n = new Node(sum%10);
					
					tail -> next = n;
					tail = n;
					
					b = b -> next;
				}
				
				if(c != 0) {
					Node* n = new Node(c % 10);
					tail -> next = n;
					tail = n;
				}
				return h;
			}
			
			public:
			//Function to add two numbers represented by linked list.
			Node* addTwoLists(struct Node* num1, struct Node* num2) {
				Node* first = reverse(num1);
				Node* second = reverse(num2);
				
				Node* main = addLL(first, second);
				main = reverse(main);
				
				// "main -> next != nullptr" this condition is to handle the addition of 0's only
				while(main -> next != nullptr && main -> data == 0)
					main = main -> next;
				
				return main;
			}
		};

		// Or using single loop
			class Solution {
				Node* reverse(Node* &h){
					Node* cur = h;
					Node* prev = nullptr;
					
					while(cur){
						Node* upcoming = cur -> next;
						cur -> next = prev;
						prev = cur;
						cur = upcoming;
					}
					return prev;
				}
				
				Node* addLL(Node* &a, Node* &b){
					Node* h = nullptr;
					Node* tail = nullptr;
					int c=0;
					
					while(a || b || c){                      //while(a != NULL || b != NULL || c != 0){
					
						int v1 = 0;
						if(a != NULL)
							v1 = a->data;
						
						int v2 = 0;
						if(b != NULL)
							v2 = b->data;
							
						int sum = v1 + v2 + c;
						
						c = sum / 10;
						Node * n = new Node(sum%10);
						
						if(h == nullptr){
							h = n;
							tail = n;
						}else{
							tail -> next = n;
							tail = n;
						}
						
						if(a != NULL)
							a = a-> next;
						
						if(b != NULL)
							b = b-> next;
					}

					return h;
				}
				
				public:
				//Function to add two numbers represented by linked list.
				Node* addTwoLists(struct Node* num1, struct Node* num2) {
					Node* first = reverse(num1);
					Node* second = reverse(num2);
					
					Node* main = addLL(first, second);
					main = reverse(main);
					
					// "main -> next != nullptr" this condition is to handle the addition of 0's only
					while(main -> next != nullptr && main -> data == 0)
						main = main -> next;
					
					return main;
				}
			};
	
	760) Clone a linked list with next and random pointer:
		https://www.geeksforgeeks.org/problems/clone-a-linked-list-with-next-and-random-pointer/1
		Problem Statement:
			You are given a special linked list with N nodes where each node has a next pointer pointing to its next node. You are also given M random pointers, where you will be given M number of pairs denoting two nodes a and b  i.e. a->arb = b (arb is pointer to random node).
			Construct a copy of the given list. The copy should consist of exactly N new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.
			For example, if there are two nodes X and Y in the original list, where X.arb --> Y, then for the corresponding two nodes x and y in the copied list, x.arb --> y.
			Return the head of the copied linked list.
			ArbitLinked List1
			Note :- The diagram isn't part of any example, it just depicts an example of how the linked list may look like.
			Example 1:
			Input:
				N = 4, M = 2
				value = {1,2,3,4}
				pairs = {{1,2},{2,4}}
				Output: 1
				Explanation: In this test case, there
				are 4 nodes in linked list.  Among these
				4 nodes,  2 nodes have arbitrary pointer
				set, rest two nodes have arbitrary pointer
				as NULL. Second line tells us the value
				of four nodes. The third line gives the
				information about arbitrary pointers.
				The first node arbitrary pointer is set to
				node 2.  The second node arbitrary pointer
				is set to node 4.
			Example 2:
				Input:
				N = 4, M = 2
				value[] = {1,3,5,9}
				pairs[] = {{1,1},{3,4}}
				Output: 1
				Explanation: In the given testcase ,
				applying the method as stated in the
				above example, the output will be 1.

			Your Task:
				The task is to complete the function copyList() which takes one argument the head of the linked list to be cloned and should return the head of the cloned linked list.

			NOTE : 
				1. If there is any node whose arbitrary pointer is not given then it's by default NULL. 
				2. Your solution return an output 1 if your clone linked list is correct, else it returns 0.
				3. Don't make any changes to the original linked list.

			Expected Time Complexity : O(n)
			Expected Auxilliary Space : O(1)

			Constraints:
				1 <= N <= 100
				1 <= M <= N
				1 <= a, b <= 100

		/* TC: O(n) & SC: O(n) used map*/
			#include <bits/stdc++.h>
			using namespace std;
			/* Link list Node */
			struct Node {
				int data;
				Node *next;
				Node *arb;

				Node(int x) {
					data = x;
					next = NULL;
					arb = NULL;
				}
			};

			class Solution {
				public:
				Node* copyList(Node *head) {
					Node* ans = NULL;
					Node* temp = head;
					Node* tail = NULL;
					map<Node*, Node*>   oldLL_ClonedLL;		// to extract the random pointers
					
					while(temp){
						Node* n = new Node(temp->data);
						if(ans == NULL){
							ans = n;
							tail = n;
						}else{
							tail -> next = n;
							tail = n;
						}
						
						// storing the mappings to extract the random links arb
						oldLL_ClonedLL[temp] = tail;
						
						temp = temp -> next;
					}
					
					Node* cloned = ans;
					Node* original = head;
					
					while(original){
						cloned -> arb = oldLL_ClonedLL[original -> arb];
						cloned = cloned -> next;
						original = original -> next;
					}
					return ans;
				}
			};

		/* TC: O(n) & SC: O(1)*/
			class Solution {
				public:
				Node* copyList(Node *head) {
					//1. create clone of main list
						Node* cloned = NULL;
						Node* Tail = NULL;
						
						Node* temp = head;
						
						while(temp){
							Node* n = new Node(temp -> data);
							
							if(Tail == NULL){
								cloned = n;
								Tail = n;
							}else{
								Tail -> next = n;
								Tail = n;
							}
							
							temp = temp -> next;
						}
						
					// 2. add cloned Nodes inbetween original LL nodes
						Node* original = head;
						Node* copied = cloned;
						
						while(copied && original){                                  // or while(original){
							Node* next = original -> next;
							
							original -> next = copied;
							original = next;
							
							next = copied -> next;
							copied -> next = original;
							copied = next;
						}
					
					// 3. copy random pointers / arb
						temp = head;
						while(temp){
							temp -> next -> arb = temp -> arb ? temp -> arb -> next : temp -> arb; 
							temp = temp -> next -> next;
						}
					
					// 4. undo the step 2
						original = head;
						copied = cloned;
						
						while(copied && original){							// or while(original)   or while(copied)
							original -> next = copied -> next;					// you can keep both or if you want keep any one of it in copied or original inside while loop.
							original = original -> next;
							
							if(original != NULL)
								copied -> next = original -> next;
							
							copied = copied -> next;
						}

					// return cloned LL
						return cloned;
				}
			};

	#LeetCode WeeklyContest-395:
		761) Find the Integer Added to Array I:
			Problem Statement:
				You are given two arrays of equal length, nums1 and nums2.
				Each element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.
				As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
				Return the integer x.
			
				Example 1:
				Input: nums1 = [2,6,4], nums2 = [9,7,5]
				Output: 3
				Explanation:
				The integer added to each element of nums1 is 3.

				Example 2:
				Input: nums1 = [10], nums2 = [5]
				Output: -5
				Explanation:
				The integer added to each element of nums1 is -5.

				Example 3:
				Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
				Output: 0
				Explanation:
				The integer added to each element of nums1 is 0.
				
				Constraints:
					1 <= nums1.length == nums2.length <= 100
					0 <= nums1[i], nums2[i] <= 1000
					The test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by adding x to each element of nums1.

			class Solution {
				public:
				int addedInteger(vector<int>& nums1, vector<int>& nums2) {
					int x;
					
					// int i = 0;
					// for(i=0; i<nums1.size(); i++)
					//     if(nums1[i] != nums2[i])
					//         break;

					// if(i == nums1.size())
					//     return 0;

					// if(nums1.size() == 1)
					//     return nums2[0] - nums1[0];
					
					for(int i=0; i<nums1.size(); i++){
						for(int j=0; j<nums2.size(); j++){
							x = nums2[j] - nums1[i];
							
							int f=1;
							for(int z=0; z<nums1.size(); z++)
								if(find(nums2.begin(), nums2.end(), nums1[z]+x) == nums2.end()){
								f = 0;
								break;
								}
							
							if(f)
								return x;
						}
					} 
					return x;
				}
			};

			// Simpler:
				class Solution {
					public:
					int addedInteger(vector<int>& nums1, vector<int>& nums2) {
						sort(nums1.begin(), nums1.end());
						sort(nums2.begin(), nums2.end());
						
						return nums2[0] - nums1[0];
					}
				};

	762) Ninja And Editor:
		Problem statement
			Ninja wants to print a book of stories. He created a doc file and sent it to his editor to make some edits. But the file got corrupted due to some reasons and made changes in the original file. Ninja did not have a duplicate file of the same, so he wants to correct the same file. He found that the file has been changed in such a way that all the spaces have been removed from the file and the first letter after each space that used to be has been changed to the equivalent uppercase characters.
			Example:
			If the corrupted file looks like “CodingNinjasIsACodingPlatform”, then the original file was: “coding ninjas is a coding platform”.
			Ninja needs to change the corrupted file to the original file.
			Note:
			You need to convert all the uppercase characters to lowercase characters, and you need to add a single space between every two words.
			Constraints:
				1 <= T <= 50
				0 <= size of S <= 10000

				where ‘T’ is the number of test cases.
				where 'S’ is the corrupted string that you need to to change.
				Time limit: 1 sec

			Sample Input 1:
			2
			CodingNinjasIsACodingPlatform
			Hello
			Sample Output 1:
			coding ninjas is a coding platform
			hello
			Explanation of sample input 1:
			In the first test case, 
			After replacing the uppercase characters with a space followed by the lowercase conversion of the character we get: 
			coding ninjas is a coding platform

			In the second test case, 
			After replacing the uppercase characters with a space followed by the lowercase conversion of the character we get: 
			hello
			Sample Input 2:
			3
			HelloWorld
			ILoveCoding
			YouCanPracticeCodingOnCodezen
			Sample Output 2:
			hello world
			i love coding
			you can practice coding on codezen

		#include <bits/stdc++.h> 
		string editSentence(string &s) {
			if(s.size() == 0)
				return s;
			
			s[0] = tolower(s[0]);
			
			for(int i=1; i<s.size(); i++){
				if(isupper(s[i])){
					s[i] = tolower(s[i]);
					s.insert(s.begin()+i, ' ');
				}
			}

			// transform(s.begin(), s.end(), s.begin(), ::tolower);
			return s;
		}
	
	763) Add Two Numbers:
		Problem statement
			You are given two non-negative numbers 'num1' and 'num2' represented in the form of linked lists.
			The digits in the linked lists are stored in reverse order, i.e. starting from least significant digit (LSD) to the most significant digit (MSD), and each of their nodes contains a single digit.
			Calculate the sum of the two numbers and return the head of the sum list.

			Example :
			Input:
			'num1' : 1 -> 2 -> 3 -> NULL
			'num2' : 4 -> 5 -> 6 -> NULL
			Output: 5 -> 7 -> 9 -> NULL
			Explanation: 'num1' represents the number 321 and 'num2' represents 654. Their sum is 975.
			Sample Input 1 :
			3
			1 2 3
			3
			4 5 6

			Sample Output 1 :
			5 7 9
			Explanation for Sample Input 1 :
			'num1' represents the number 321 and 'num2' represents 654. Their sum is 975.
			Sample Input 2 :
			2
			0 1
			1
			0

			Sample Output 2 :
			0 1

			Explanation for Sample Input 2 :
			'num1' represents 10 and 'num2' represents 0. Their sum is 10.

			Sample Input 3 :
			1
			2
			2
			9 9

			Sample Output 3 :
			1 0 1

			Explanation for Sample Input 3 :
			'num1' represents 2 and 'num2' represents 99. Their sum is 101.

			Expected Time Complexity :
			The expected time complexity is O('m' + 'n').

			Constraints :
				1 <= 'm', 'n' <= 5 * 10^4
				0 <= 'data' in any Linked List node <= 9
				The numbers do not contain any leading zeros.
				If the number is zero, then there is one node having 'data' = 0.
				Time Limit: 1 sec
		/**************************************************************************
			* Definition of linked list:
			*
			* class Node {
			* public:
			*      int data;
			*      Node *next;
			*      Node() {
			*          this->data = 0;
			*          this->next = NULL;
			*      }
			*      Node(int data) {
			*          this->data = data;
			*          this->next = NULL;
			*      }
			*      Node (int data, Node *next) {
			*          this->data = data;
			*          this->next = next;
			*      }
			* };
		*************************************************************************/

		Node *addTwoNumbers(Node *n1, Node *n2){
			int c=0;
			Node* ans = n1;
			Node* Tail = n1;
			while(n1 || n2 || c) {

				int v1, v2;
				v1 = v2 = 0;
				if(n1)
					v1 = n1 -> data;
				
				if(n2)
					v2 = n2 -> data;

				int sum = v1 + v2  + c;
				c = sum / 10;

				if(n1){
					n1 -> data = sum % 10;
				}else{
					Node *newNode = new Node(sum % 10);                             // here inserting newNodes at the ends of n1 LL
					Tail -> next = newNode;
					Tail = newNode;
				}

				if(n1){
					Tail = n1;                  // passing n1 as answer, if the length of n1 < n2 then inserting new nodes at the end of LL
					n1 = n1 -> next;
				}

				if(n2)
					n2 = n2 -> next;
			}
			return ans;                 
		}

	764) Container with Maximum Water/ Container With Most Water:
		Refer Q.92 Also
		Problem statement
			You have been given an array/list ‘ARR‘ of length ‘N’ consisting of non-negative integers ARR1, ARR2, ..., ARRN. The i’th integer denotes a point with coordinates (i, ARR[i]). ‘N’ vertical lines are drawn such that the two endpoints of the i’th line are at (i, arr[i]) and (i,0).
			Your task is to find two lines, which, together with the x-axis, form a container, such that the container contains the most water. Return the maximum area of the container.
			Note:
			1. Consider the container to be 2-dimensional for simplicity. 
			2. For any pair of sides ignore all the lines that lie inside that pair of sides. 
			3. You are not allowed to slant the container.

			Example:
			Consider 'ARR'= {1,8,6,2,5,4,8,3,7} then the vertical lines are represented by the above image. The blue section denotes the maximum water than a container can contain.
			Constraints:
				1 <= T <= 100
				2 <= N <= 5000
				1 <= ARR[i] <= 10^5

				Where 'ARR[i]' denotes the elements of the given array/list.

				Time limit: 1 sec
			Sample Input 1 :
				2
				5
				2 4 7 1 3
				3
				7 5 9
				Sample Output 1:
				9
				14
				Explanation of Sample Input 1:
				In the first test case, we will get the maximum area if we choose the container coloured blue in the above image. The length of the base of the container is 3, and the height of the container is min(4, 3) which is 3. Thus, the area of the container is 3 * 3 = 9.
				In the second test case, we will get the maximum area if we choose the container coloured blue in the above image. The length of the base of the container is 2, and the height of the container is min(7, 9) which is 7. Thus, the area of the container is 2 * 7 = 14.
				Sample Input 2:
				2
				5
				1 5 12 2 1
				5
				7 12 9 20 8
				Sample Output 2:
				5
				28
				Explanation of Sample Input 2:
				In the first test case, we will get the maximum area if we choose the container coloured blue in the above image. The length of the base of the container is 1, and the height of the container is min(5, 12) which is 5. Thus, the area of the container is 1 * 5 = 5.
				In the second test case, we will get the maximum area if we choose the container coloured blue in the above image. The length of the base of the container is 4, and the height of the container is min(7, 8) which is 7. Thus, the area of the container is 4 * 7 = 28.

		#include <bits/stdc++.h> 
		int maxAreaContainer(vector<int> &arr) {
			int mxCover=0;
			int s = 0, e = arr.size()-1;

			while(s < e){
				int dist = e - s;
				int index = min(arr[s], arr[e]);

				int val = dist * index;
				mxCover = max(mxCover , val);
				
				if(arr[s] < arr[e])
					s++;
				else
					e--;
			}

			return mxCover;
		}

	765) Funny Divisors:
		Problem statement
			Ninja is bored with his previous game of numbers, so now he is playing with divisors.
			He is given 'N' numbers, and his task is to return the sum of all numbers which is divisible by 2 or 3.
			Let the number given to him be - 1, 2, 3, 5, 6. As 2, 3, and 6 is divisible by either 2 or 3 we return 2 + 3 + 6 = 11.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^3
				0 <= input[i] <= 10^3

				Where ‘T’ denotes the number of test cases and ‘N’ is the elements given to Ninja and input[i] denotes theith input.
				Time Limit: 1 sec  
			Sample Input 1 :
				2
				3
				1 2 3
				4
				5 6 9 8
				Sample Output 1 :
				5
				23  
				Explanation for Sample Input 1 :
				In the first test case, 1 is neither divisible by 2 or 3. 2 is divisible by 2, and 3 is divisible by 3. So here we return the sum of 2 + 3 which is equal to 5.

				In the second test case, 5 is divisible by neither 5 nor 6.6 is divisible by 2, 9 is divisible by 3, and 8 is divisible by 2. So here we return 6 + 9 + 8 = 23. 
				Sample Input 2 :
				2
				7
				7 5 11 3 5 2 9
				2
				3 4
				Sample Output 2 :
				14
				7

		#include <bits/stdc++.h> 
		int findSum(int n, vector<int>& arr) {
			int ans=0;
			for(int i: arr)
				if(i % 2 == 0 || i%3 == 0)
					ans += i;
			return ans;
		}
	
	766) Frequency of every Element: (GFG WeeklyContest-152)
		Problem Statement:
			You are given an array a of size n. For every i (0<=i<=n-1) you need to find the frequency of a[i] from index i to
			n-1. Finally you need to return an array of size n.
			Example 1:
			Input:
			n = 5
			all = {1, 1, 1, 2, 2}
			Output:
			3 2 1 2 1
			Explanation:
			For i=0, a[i] i.e. 1 have frequency 3 from index 0 to 4.
			For i=1, ali] i.e. 1 have frequency 2 from index 1 to 4.
			Example 2:
			Input:
			n = 7
			al] = {1, 1, 2, 2, 3, 3, 1}
			Output:
			3 2 2 1 2 1 1
		
			Explanation:
				For i=0, a[i] i.e. 1 have frequency 3 from index 0 to 6.
				For i=2, ali] i.e. 2 have frequency 2 from index 2 to 6.
			
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function frequency) which take
				integer n and array a as input and returns an array containing the frequencies of ith element of the array from
				from index i to n-1.
			Constraints:
				1 <=n <= 10^5
				-10^3 <= a[i] <= 10^3
			
		class Solution{
			public:
			vector<int> frequency(int n, vector<int> &a){
				vector<int> ans(n);
				
				map<int, int> Fr;
				for(int i: a)
					Fr[i]++;
					
				for(int i=0; i<n; i++){
					ans[i] = Fr[a[i]]--;
				}
				return ans;
			}
		};
	
	767) Number of Wonderful Substrings:
		Problem Statement:
			A wonderful string is a string where at most one letter appears an odd number of times.
			For example, "ccjjc" and "abab" are wonderful, but "ab" is not.
			Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.
			A substring is a contiguous sequence of characters in a string.

			Example 1:
			Input: word = "aba"
			Output: 4
			Explanation: The four wonderful substrings are underlined below:
			- "aba" -> "a"
			- "aba" -> "b"
			- "aba" -> "a"
			- "aba" -> "aba"

			Example 2:
			Input: word = "aabb"
			Output: 9
			Explanation: The nine wonderful substrings are underlined below:
			- "aabb" -> "a"
			- "aabb" -> "aa"
			- "aabb" -> "aab"
			- "aabb" -> "aabb"
			- "aabb" -> "a"
			- "aabb" -> "abb"
			- "aabb" -> "b"
			- "aabb" -> "bb"
			- "aabb" -> "b"

			Example 3:
			Input: word = "he"
			Output: 2
			Explanation: The two wonderful substrings are underlined below:
			- "he" -> "h"
			- "he" -> "e"
			
			Constraints:
				1 <= word.length <= 10^5
				word consists of lowercase English letters from 'a' to 'j'.

		// Not Optimized:
			class Solution {
				public:
				long long wonderfulSubstrings(string word) {
					long long ans = word.size();
					for(int i = 0; i < word.size()-1; i++) {
						for(int j = i+1; j < word.size(); j++) {
							map<int, int> Fr;

							for(int z=i; z<=j; z++)
								Fr[word[z]]++;
							
							int cnt = 0;
							for(auto i: Fr)
								if(i.second & 1)
								cnt++;
								
							if(cnt == 1 || Fr.size() == 1 || cnt == 0)
								ans++;
						}
					}
					return ans;
				}
			};

			// Little Bit Optimization:
				class Solution {
					public:
					long long wonderfulSubstrings(string word) {
						long long ans = word.size();

						for(int i = 0; i < word.size()-1; i++) {
							map<int, int> Fr;
							Fr[word[i]]++;

							for(int j = i+1; j < word.size(); j++) {                
								int cnt = 0;
								Fr[word[j]]++;

								for(auto i: Fr)
									if(i.second & 1)
									cnt++;

								if(cnt == 1 || Fr.size() == 1 || cnt == 0)
									ans++;
							}
						}
						return ans;
					}
				};
		
		// Optimized: ❌Pending

	768) The Chunin Ninja:
		Problem statement
			You are the Supreme Ninja Warrior on a visit to Ninja Class, and class can be represented as a rectangular matrix ‘ARR’ of ‘N’ rows and ‘M’ columns.
			Each Ninja has a skill level, and each element in matrix ‘ARR’ represents the skill level of the Ninja present in the class. More formally, ‘ARR[i][j]’ represents the skill level of Ninja sitting in the ‘jth’ column of the ‘ith’ row.
			A ninja is said to be ‘Chunin’ if he has maximum skill among all Ninjas in his column and minimum skill level among all Ninjas in his row.
			Can you find all the ‘Chunin’ Ninjas present in the class?
			Example :
			N = 3 M = 3
			ARR = [ [3, 4, 5], [2, 7, 6] , [1, 2, 4] ]
			Ninja at Position (0,0) has maximum skill in ‘0th’ column and minimum skill in ‘0th’ row, it is the only Chunin Ninja.
			So, we return [ 3 ] as our ‘ANS’. 
			Constraints :
				1 <= T <= 10
				1 <= N , M <= 10^5
				0 <= ARR[i][j] <= 10^9
				Sum of N*M over all Test cases <= 10^5
				Time Limit: 1 sec

			Sample Input 1 :
			2
			2 2
			3 4 
			2 5 
			2 3
			3 4 5
			4 5 6
			Sample Output 1 :
			3 
			4
			Explanation Of Sample Input 1 :
			For test case 1, 
			With skill level '3' at position (0,0), the Ninja is the only 'Chunin' Ninja as it has maximum skill level in its column and minimum skill level in its row.

			For test case 2,
			With skill level '4' at position (1,0), the Ninja is the only 'Chunin' Ninja as it has maximum skill level in its column and minimum skill level in its row.
			Sample Input 2 :
			1
			1 1
			1
			Sample Output 2 :
			1 

		#include <bits/stdc++.h> 
		vector <int> chuninNinja(int n , int m , vector < vector < int > > arr){

			// we need to return the min_element when there is one row only
			/*
				if(n == 1)
				return {*min_element(arr[0].begin(), arr[0].end())};
			*/
			if(n == 1){
				int val = *min_element(arr[0].begin(), arr[0].end());
				return {val};
			}

			// we need to return the max_element when there is one column only
			if(m == 1){
				int mxVal = arr[0][0];
				for(int i=1; i<n; i++)
				mxVal = max(mxVal, arr[i][0]);
				return {mxVal};
			}

			vector <int> ans;

			// need to find the min element in the row (going through every row)
			// & then confirm that the same element is max element for that column
			for(int i=0; i<n; i++){
				for(int j=0; j<m; j++){
				int f = 1;
				int cur = arr[i][j];

				// checking mini-mality in row
				for(int z=0; z<m; z++)
					if(cur > arr[i][z]){
						f=0;
						break;
					}
				
				if(f){
					// checking maxi-mality in col
					for(int z=0; z<n; z++)
					if(cur < arr[z][j]){
						f=0;
						break;
					}
				}

				if(f)
					ans.push_back(cur);
				}   
			}
			return ans;
		}
	
	769) MergeSort Linked List:
		Problem statement
			For a given Singly Linked List of integers, sort the list using the 'Merge Sort' algorithm.
			Constraints :
				1 <= N <= 10^5
				1 <= DATA <= 10^9
				Where 'DATA' denotes the value of node of Linked List.
				Time Limit: 1sec

			Sample Input 1 :
				1 4 5 2 -1
			Sample Output 1 :
				1 2 4 5
			Sample Input 2 :
				10 9 8 7 6 5 4 -1
			Sample Output 2 :
				4 5 6 7 8 9 10

		/********************************************************************
			Following is the representation of the Singly Linked List Node:
			class node{
				public:
					int data;
					node * next;
				node(int data){
					this->data=data;
					this->next=NULL;
				}
			};    
		********************************************************************/
		/* TC: O(N logN) & SC: O(N), Used extra space */
			#include <vector>
			#include <algorithm>
			node* mergeSort(node *head) {
				vector<int> v;
				node* temp = head;

				while(temp){
					v.push_back(temp -> data);
					temp = temp -> next;
				}

				sort(v.begin(), v.end());
				
				int i=0;
				temp = head;
				while(temp){
					temp ->data = v[i++];
					temp = temp -> next;
				}
				return head;
			}

		/* Expected:- TC: O(N logN) & SC: O(log n)  */
			node* getMid(node* head){
				node* fast = head -> next;
				node* slow = head;

				while(fast && fast -> next){                                    //or while(fast != NULL && fast -> next != NULL )
					fast = fast -> next -> next;
					slow = slow -> next;
				}
				return slow;
			}

			node* merge(node* f, node* s) {

				if(!f)                               // if(f == nullptr)
					return s;
				
				if(s == nullptr)                // if(!s)
					return f;

				node* h = new node(-1);
				node* temp = h;

				while(f && s){
					if(f->data < s->data){
						temp -> next = f;
						temp = f;
						f = f -> next;
					}else{
						temp -> next = s;
						temp = s;
						s = s-> next;
					}
				}

				// while(f){
				//     temp -> next = f;
				//     temp = f;
				//     f = f -> next;
				// }

				// while(s){
				//     temp -> next = s;
				//     temp = s;
				//     s = s -> next;
				// }

				// instead of above 2 while loops you can use this below if conditions
				if(f)
					temp -> next = f;

				if(s)
					temp -> next = s;

				temp = h -> next;
				// deleting that dummy node which is there at start (-1).
				delete h;

				return temp;
			}

			node* mergeSort(node *head) {
				// if(!head) it means head == NULL, if(!NULL) == if(1) then if block will gets executed.
				// if(!head -> next) it means head -> next == NULL, means LL contains one element better to use parenthesis like this !(head -> next)
				
				if(!head || !(head -> next))
					return head;

				// breaking LL into 2 halves
				node* mid = getMid(head);

				node* left = head;
				node* right = mid -> next;
				mid -> next = nullptr;

				left = mergeSort(left);
				right = mergeSort(right);

				// merge left & right half back
				node* res = merge(left, right);
				return res;
			}
	
	770) Flatten A Linked List:
		Problem statement
			You are given a linked list containing 'n' 'head' nodes, where every node in the linked list contains two pointers:
			(1) ‘next’ which points to the next node in the list
			(2) ‘child’ pointer to a linked list where the current node is the head.
			Each of these child linked lists is in sorted order and connected by 'child' pointer.
			Your task is to flatten this linked such that all nodes appear in a single layer or level in a 'sorted order'.
			Example:
			Input: Given linked list is:
			Output:
			1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 12 → 20 → null.
			Explanation:
			The returned linked list should be in a sorted order. All the elements in this returned linked list are connected by 'child' pointers and 'next' pointers point to null.

			Sample Input 1 :
				4
				3
				1 2 3
				3
				8 10 15
				2
				18 22
				1
				29
				Sample Output 1 :
				1 2 3 8 10 15 18 22 29

				Explanation For Sample Input 1:
				The given linked list is 

				Therefore after flattening the list will become-
				1 -> 2 -> 3 -> 8 -> 10 -> 15 -> 18 -> 22 -> 29 ->null

			Sample Input 2 :
				5
				2
				4 6
				2
				5 71
				3
				7 8 9
				3 
				11 12 19
				3
				14 15 17


				Sample Output 2 :
				4 5 6 7 8 9 11 12 14 15 17 19 71

				Expected Time Complexity:
				Try solving this in O(n*n*k), where ‘n’ denotes the number of head nodes and ‘k’ is the average number of child nodes in all 'n' sub-lists.     

				Expected Space Complexity:
				Try solving this without using any extra space.   

				Constraints:
					1 <= n <= 100
					1 <= k <= 20
					1 <= Node.data <= 10^9
					Time Limit: 1 sec

		/*
			* Definition for linked list.
			* class Node {
			*  public:
			*		int data;
			*		Node *next;
			* 		Node *child;
			*		Node() : data(0), next(nullptr), child(nullptr){};
			*		Node(int x) : data(x), next(nullptr), child(nullptr) {}
			*		Node(int x, Node *next, Node *child) : data(x), next(next), child(child) {}
			* };
		*/

		// Used extra space:
			#include <algorithm>
			Node* flattenLinkedList(Node* head) {
				Node* ans = new Node(1);
				Node* temp = head;
				vector<int> v;

				while(head){
					head = head -> next;

					while(temp){
						v.push_back(temp -> data);
						temp = temp -> child;
					}
					temp = head;
				}

				sort(v.begin(), v.end());
				int i=0;
				temp = ans;
				while(i < v.size()){
					Node* n = new Node(v[i++]);

					temp -> child = n;
					temp = n;
				}			
				ans = ans -> child;
				return ans;
			}

		// without using extra space:
			#include <algorithm>
			Node* sortMerge(Node* f, Node* s){
				Node* n = new Node(1);
				Node* Tail = n;

				while(f && s){
					if(f->data < s -> data){
						Tail -> child = f;
						Tail = f;
						f = f -> child;
					}else{
						Tail -> child = s;
						Tail = s;
						s = s -> child;
					}
				}

				if(f)
					Tail -> child = f;
				
				if(s)
					Tail -> child = s;

				Node* t = n;
				n = n -> child;
				delete t;

				return n;
			}

			Node* getMid(Node* h){
				Node* slow = h;
				Node* fast = h -> child;

				while(fast && fast ->child){
					fast = fast -> child -> child;
					slow = slow -> child;
				}
				return slow;
			}

			Node* solve(Node* a){
				if(a -> child == NULL)
					return a;
				
				Node* mid = getMid(a);

				Node* first = a;
				Node* sec = mid-> child;
				mid -> child = NULL;

				first = solve(first);
				sec = solve(sec);

				Node* n =  sortMerge(first, sec);
				return n;
			}

			Node* flattenLinkedList(Node* head) {
				Node* ans = head;
				Node* temp = head;

				while(head){
					while(temp -> child)
						temp = temp -> child;
					temp -> child = head -> next;

					Node* sample = head;
					head = head -> next;

					sample -> next =NULL;
				}

				// need to sort the LL
				ans = solve(ans);
				return ans;
			}

	771) Flattening a Linked List:
		Problem Statement:
			Given a Linked List of size N, where every node represents a sub-linked-list and contains two pointers:
			(i) a next pointer to the next node,
			(ii) a bottom pointer to a linked list where this node is head.
			Each of the sub-linked-list is in sorted order.
			Flatten the Link List such that all the nodes appear in a single level while maintaining the sorted order. 

			Note: The flattened list will be printed using the bottom pointer instead of the next pointer.
			For more clarity have a look at the printList() function in the driver code.

			Example 1:
			Input:
				5 -> 10 -> 19 -> 28
				↓     ↓     ↓     ↓ 
				7     20    22   35
				↓           ↓     ↓ 
				8          50    40
				↓                 ↓ 
				30               45

			Output:  5-> 7-> 8- > 10 -> 19-> 20->22-> 28-> 30-> 35-> 40-> 45-> 50.
			Explanation:
			The resultant linked lists has every node in a single level.
			(Note: ↓ represents the bottom pointer.)

			Example 2:
				5 -> 10 -> 19 -> 28
				↓          ↓                
				7          22   
				↓          ↓                 
				8          50 
				↓                           
				30

			Input: 
			Output: 5->7->8->10->19->22->28->30->50
			Explanation:
			The resultant linked lists has every
			node in a single level.

			(Note: ↓ represents the bottom pointer.)
			
			Your Task:
				You do not need to read input or print anything. Complete the function flatten() that takes the head of the linked list as input parameter and returns the head of flattened link list.

			Expected Time Complexity: O(N*N*M)
			Expected Auxiliary Space: O(N)

			Constraints:
				0 <= N <= 50
				1 <= Mi <= 20
				1 <= Element of linked list <= 10^3	
	
		/* Node structure  used in the program
			struct Node{
				int data;
				struct Node * next;
				struct Node * bottom;

				Node(int x){
					data = x;
					next = NULL;
					bottom = NULL;
				}
			};
		*/

		/*  Function which returns the  root of the flattened linked list. */
		Node* flatten(Node *root) {
			Node* temp = root;
			vector<int> v;
			
			while(temp){
				Node* childs = temp;
				temp = temp -> next;
				
				while(childs){
					v.push_back(childs -> data);
					
					childs = childs -> bottom;
				}
			}

			sort(v.begin(), v.end());
			
			Node* ans = new Node(-1);
			Node* Tail = ans;
			
			int i=0;
			while(i<v.size()){
				Node* n = new Node(v[i++]);
				Tail -> bottom = n;
				Tail = n;
			}
			
			ans = ans -> bottom;
			return ans;
		}

	772) Reverse Prefix of Word:
		Problem Statement:
			Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.
			For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
			Return the resulting string.
			
			Example 1:
			Input: word = "abcdefd", ch = "d"
			Output: "dcbaefd"
			Explanation: The first occurrence of "d" is at index 3. 
			Reverse the part of word from 0 to 3 (inclusive), the resulting string is "dcbaefd".

			Example 2:
			Input: word = "xyxzxe", ch = "z"
			Output: "zxyxxe"
			Explanation: The first and only occurrence of "z" is at index 3.
			Reverse the part of word from 0 to 3 (inclusive), the resulting string is "zxyxxe".

			Example 3:
			Input: word = "abcd", ch = "z"
			Output: "abcd"
			Explanation: "z" does not exist in word.
			You should not do any reverse operation, the resulting string is "abcd".
		
			Constraints:
				1 <= word.length <= 250
				word consists of lowercase English letters.
				ch is a lowercase English letter.

		class Solution {
			public:
			string reversePrefix(string word, char ch) {
				string rev;

				int f=0;
				while(word.size())
					if(word[0] == ch){
						rev += word[0];
						f=1;
						word.erase(word.begin());
						break;
					}else{
						rev += word[0];
						word.erase(word.begin());
					}

				if(f){
					reverse(rev.begin(), rev.end());
					rev += word;
					return rev;
				}
				return rev;
			}
		};

		// or
			class Solution {
				public:
				string reversePrefix(string word, char ch) {
					int i = word.find(ch);
					if(i != -1)
						reverse(word.begin(), word.begin()+i+1);
					return word;        
				}
			};

		// or
			class Solution {
				public:
				string reversePrefix(string word, char ch) {
					int i = word.find(ch);

					if(i != -1){
						int x=0, y=i;
						while(x < y)
							swap(word[x++], word[y--]);
					}

					return word;        
				}
			};

	773) Arrange Consonants and Vowels:
		Problem Statement:
			Given a singly linked list having n nodes containing english alphabets ('a'-'z'). Rearrange the linked list in such a way that all the vowels come before the consonants while maintaining the order of their arrival. 
			Example 1:
			Input:
			n = 9
			linked list: a -> b -> c -> d -> e -> f -> g -> h -> i 
			Output: 
			a -> e -> i -> b -> c -> d -> f -> g -> h
			Explanation: 
			After rearranging the input linked list according to the condition the resultant linked list will be as shown in output.

			Example 2:
			Input:
			n = 8
			linked list: a -> b -> a -> b -> d -> e -> e -> d 
			Output: 
			a -> a -> e -> e -> b -> b -> d -> d

			Explanation: 
				After rearranging the input linked list according to the condition the resultant linked list will be as shown in output.
			
			Your Task:
				Your task is to complete the function arrangeCV(), which takes head of linked list and arranges the list in such a way that all the vowels come before the consonants while maintaining the order of their arrival and returns the head of the updated linked list.

			Expected Time Complexity :  O(n)
			Expected Auxiliary Space :  O(1)

			Constraints:
				1 <= n <= 10^4
				'a' <= elements of linked list <= 'z'

		/*
			Structure of the node of the linked list is as
			struct Node {
				char data;
				struct Node *next;

				Node(char x) {
					data = x;
					next = NULL;
				}
			};
		*/

		class Solution {
			public:
			// task is to complete this function
			// function should return head to the list after making
			// necessary arrangements
			struct Node* arrangeCV(Node* head) {
				vector<char> Vowels, Consonants;
				
				while(head){
					if(head -> data == 'a' || head -> data == 'e' || head -> data == 'i' || head -> data == 'o' || head -> data == 'u')
						Vowels.push_back(head -> data);
					else
						Consonants.push_back(head -> data);
						
					head = head -> next;
				}
				
				
				int i=0;
				if(Vowels.size()){
					head = new Node(Vowels[i++]);
					Node* Tail = head;
					
					while(i < Vowels.size()){
						struct Node* n = new Node(Vowels[i++]);
						Tail -> next = n;
						Tail = n;
					}
					
					i=0;
					while(i < Consonants.size()){
						struct Node* n = new Node(Consonants[i++]);
						Tail -> next = n;
						Tail = n;
					}
				}
				else{
					head = new Node(Consonants[i++]);
					Node* Tail = head;
					while(i < Consonants.size()){
						struct Node* n = new Node(Consonants[i++]);
						Tail -> next = n;
						Tail = n;
					}
				}		
				return head;
			}
		};

		/* TC: O(n) & SC: O(1)*/
			class Solution {
				public:
				// task is to complete this function
				// function should return head to the list after making
				// necessary arrangements
				struct Node* arrangeCV(Node* head) {
					// these are dummy Nodes, if you want you can delete them later
					struct Node* Vowels = new Node('1');
					struct Node* Consonants = new Node('1');
					
					struct Node* Vt = Vowels;
					struct Node* Ct = Consonants;
					
					while(head){
						if(head -> data == 'a' || head -> data == 'e' || head -> data == 'i' || head -> data == 'o' || head -> data == 'u'){
							Vt -> next = head;
							Vt = head;
						}else{
							Ct -> next = head;
							Ct = head;
						}
						head = head -> next;
					}
					
					// ending both list properly
					Vt -> next = NULL;
					Ct -> next = NULL;
					
					if(Vowels -> next != nullptr){
						Vt -> next = Consonants -> next;
						return Vowels -> next;
					}
					
					return Consonants -> next;
				}
			};
	
	774) Ninja And His Old Friends:
		Problem statement
			Ninja wants to meet his ‘N’ old friends standing in a row. All the friends along with Ninja are very happy because they are meeting after a long time. The happiness of each friend can be represented as a positive integer. Initially, Ninja has some happiness value ‘K’. Ninja shakes hands with all of his ‘N’ friends standing in a row one by one.
			While shaking hands if the happiness value of Ninja matches with that of his friend, then the happiness value of Ninja becomes double. Ninja wants to calculate his happiness value after he shakes hands with all of his friends.
			For Example: For ‘FRIENDS’ = [3, 2, 1, 4]. And ‘K’ = 2, following are the results after each hand shake:

			1. At index 0 the happiness value of his friend is 3 and the happiness value of Ninja is 2. Both are unequal so ‘K’ remains the same.
			2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 2. Both are equal so ‘K’ becomes 4.
			3. At index 2 the happiness value of his friend is 1 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same.
			4. At index 3 the happiness value of his friend is 4 and the happiness value of Ninja is 4. Both are equal so ‘K’ becomes 8.
			As Ninja is busy with his friends so he needs your help. Can you help Ninja to find his final happiness value after all the handshakes?
			Constraints:
				1 <= T <= 100
				1 <= N <= 10 ^ 4
				1 <= K <= 10 ^ 3
				1 <= FRIENDS[i] <= 10 ^ 6
				Where 'FRIENDS[i]' denotes the happiness value of the friend at the ‘i’th index, respectively.
				Time Limit: 1 sec 
				
			Sample Input 1:
				2
				3 1
				1 2 4 
				2 4 
				1 2
				Sample Output 1:
				8
				4 
				Explanation of Sample Input 1:
				For the first test case:
				1. At index 0 the happiness value of his friend is 1 and the happiness value of Ninja is 1. Both are equal so ‘K’ becomes 2.
				2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 2. Both are equal so ‘K’ becomes 4.
				3. At index 2 the happiness value of his friend is 4 and the happiness value of Ninja is 4. Both are equal so ‘K’ becomes 8.

				For the second test case:
				1. At index 0 the happiness value of his friend is 1 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same. 
				2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same. 
				Sample Input 2:
				2
				2 5
				5 5 
				3 8
				2 4 8 
				Sample Output 2:
				10
				16
				Explanation of Sample Input 2:
				For the first test case:
				1. At index 0 the happiness value of his friend is 5 and the happiness value of Ninja is 5. Both are equal so ‘K’ becomes 10.
				2. At index 1 the happiness value of his friend is 5 and the happiness value of Ninja is 10. Both are unequal so ‘K’ remains the same.    

				For the second test case:
				1. At index 0 the happiness value of his friend is 2 and the happiness value of Ninja is 8. Both are unequal so ‘K’ remains the same.
				2. At index 1 the happiness value of his friend is 4 and the happiness value of Ninja is 8. Both are unequal so ‘K’ remains the same.
				3. At index 2 the happiness value of his friend is 8 and the happiness value of Ninja is 8. Both are equal so ‘K’ becomes 16.

		#include <bits/stdc++.h> 
		int shakeHands(vector<int> &friends ,int n, int k){
			for(int i: friends)
				if(i == k)
					k *= 2;
			return k;
		}
	
	#CN BeginnerContest-59:
		775) 2 Power:
			Problem statement
				You are given a string 'S' which denotes the binary representation of a large number.
				Your task is to return the highest power of 2 that divides the number represented by the binary string.
				Example:
					‘S’ = ‘11000’
					Return 3 
					‘S’ is 24
				24 is divisible by 2 to the power 3 which is 8 
				But it is not divisible by 2 to the power 4 which is 16
				Hence 3 is the highest.
				Constraints:
					1 <= 'T' <= 10
					1 <= |’S’| <= 10^5 where |’S’ represents the length of ‘S’
					Time Limit: 1 sec

				Sample Input 1:
					2
					100000
					10010
					Sample Output 1:
					5
					1
					Explanation of sample input 1:
					For test case 1:
					The number is 32 and it itself is a power of two.
					As it is not divisible by 2 to the power 6 the highest possible is 5.
					For test case 2:
					The number is 18 and it is divisible by 2 to the power 1.
					As it is not divisible by 2 to the power 2 the highest possible is 1.
					Sample Input 2:
					3
					11100
					1110001001
					111110
					Sample Output 2:
					2
					0
					1

			int power2divisble(string &s){
				if(s[s.size()-1] == '1')
					return 0;

				int i = s.size() - 2, cnt=0;
				while(i >=0){
					cnt++;
					if(s[i--] == '1')
						break;
				}
				return cnt;
			}
		
		776) Linear Sort:
			Problem statement
				You have an array 'A' with 'N' integers and an empty array 'B'.
				In one operation, you will remove the first or last element of array 'A' and push it at the back of the array 'B'.
				You must perform the above operation until the array 'A' becomes empty.
				Your task is to determine if it is possible to have the array 'B' sorted in non-decreasing order after performing all the operations. Return '1' in that case. Otherwise, return '0'.

				Example:
				N = 3
				A = [4, 8, 1]
				In the first operation, you will choose the last element of the array 'A' to remove. So after performing the operation, 'A' and 'B' are ['4', '8'] and ['1'], respectively.
				In the second operation, you will choose the first element of the array 'A' to remove. So, after performing the operation, 'A' and 'B' are ['8'] and ['1', '4'], respectively.
				In the third operation, only one element is remaining in the array 'A' to remove. So, after performing the operation, 'A' is empty, and 'B' is ['1', '4', '8'], respectively.
				After performing all the operations, we see that array 'B' is sorted in a non-decreasing order. So the answer for this case is '1'.

				Constraints:
					1 <= 'N' <= 10^5
					1 <= 'A[i]' <= 10^5
					Time limit: 1 sec

				Sample input 1:
					2
					2
					2 1
					4
					1 2 1 2
					Sample output 1:
					1
					0
					Explanation of sample input 1:
					For the test case 1:
					In the first operation, you will choose the last element of the array 'A' to remove. So after performing the operation, 'A' and 'B' are ['2'] and ['1'], respectively.
					In the second operation, only one element is remaining in the array 'A' to remove. So, after performing the operation, 'A' is empty, and 'B' is ['1', '2'], respectively.
					After performing all the operations, we see that array 'B' is sorted in a non-decreasing order.
					So the answer for this case is '1'.    

					For the test case 2:
					We can prove that it is impossible to have the array 'B' sorted after performing all the operations. 
					So, the answer for this case is '0'.
					Sample input 2:
					2
					3
					1 2 3
					5
					1 3 2 1 1
					Sample output 2:
					1
					1
			
			#include<algorithm>
			int canBeSorted(int n, vector<int> a) {
				vector<int> b;
				while(a.size()){
					// choosing first or last (smaller one)
					if(a[0] < a[a.size()-1]){
						b.push_back(a[0]);
						a.erase(a.begin());
					}else{
						b.push_back(a.back());

						// to remove the last element

						// a.erase(a.begin()+a.size()-1);
						//or
						a.pop_back();
					}
				}
				// if(is_sorted(b.begin(), b.end()))
				//     return 1;
				// return 0;

				// or instead of above three lines,
				for(int i=0; i<b.size()-1; i++)
					if(b[i] > b[i+1])
						return 0;
				return 1;
			}
	
	777) Removing Digits:
		Problem Statement:
			You are given an integer n. On each step, you may subtract one of the digits from the number.
			How many steps are required to make the number equal to 0?
		
			Input
				The only input line has an integer n.
			Output
				Print one integer: the minimum number of steps.

			Constraints
				1 <= n <= 10^6

			Example
				Input:
					27
				Output:
					5
				Explanation: An optimal solution is 27 → 20 → 18 → 10 → 9 → 0.

		#include <iostream>
		#include<algorithm>
		using namespace std;

		int main() {
			int n;
			cin>> n;
			int minStep = 0;
			
			if(n == 0)
				return minStep;
			
			string s = to_string(n);

			
			while(s.size()){
				char mxV = *max_element(s.begin(), s.end());
				int i= s.find(mxV);
				s.erase(s.begin()+i);
				
				n -= (mxV - '0');
				// cout<< n <<"\t";
				
				if(n == 0)
					break;
					
				s = to_string(n);
				minStep++;
			}
			std::cout << minStep+1 << std::endl;
			return 0;
		}
	
	778) Largest Positive Integer That Exists With Its Negative:
		Problem Statement:
			Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.
			Return the positive integer k. If there is no such integer, return -1.

			Example 1:
				Input: nums = [-1,2,-3,3]
				Output: 3
				Explanation: 3 is the only valid k we can find in the array.
			Example 2:
				Input: nums = [-1,10,6,7,-7,1]
				Output: 7
				Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
			Example 3:
				Input: nums = [-10,8,6,7,-2,-3]
				Output: -1
				Explanation: There is no a single valid k, we return -1.
		
			Constraints:
				1 <= nums.length <= 1000
				-1000 <= nums[i] <= 1000
				nums[i] != 0

		class Solution {
			public:
			int findMaxK(vector<int>& nums) {
				sort(nums.begin(), nums.end());

				for(int i= nums.size()-1; i >=0; i--){
					if(find(nums.begin(), nums.end(), -nums[i]) != nums.end())
						return nums[i];
				}
				return -1;
			}
		};
	
	779) Find Pair:
		Problem statement
			Bob likes mathematics. So, he gave you the task of finding the two numbers whose sum is 'X' and the difference is 'Y'.
			Return a vector of size 2 containing the values of the two numbers specified above in any order if it is possible to get the two numbers else return [-1, -1].

			For example:
				Let 'X' = 8, 'Y' = 4.
				So, the numbers can be 6 and 2 as their sum is 8 and their difference is 4.
			Constraints:-
				1 <= 'T' <= 10^5
				1 <= 'X', 'Y' <= 10^9
				Time Limit: 1-sec.
			Sample Input 1:-
				2
				5 1
				4 0
				Sample Output 1:-
				2 3
				2 2
				Explanation of sample input 1:-
				First test case:-
				'X' = 5, 'Y' = 1.
				So, the numbers are 3 and 2 as their sum is 5 and their difference is 1.

				Second test case:-
				The numbers are 2 and 2 as their sum is 4 and their difference is 0.
				Sample Input 2:-
				2
				5 2
				4 2
				Sample Output 2:-
				-1 -1
				1 3

		vector<int> findPair(int X, int Y) {
			if (X % 2 != Y % 2) {
				return {-1, -1};  // Not possible to find numbers with different parity
			}

			// Calculate the first number (average of sum and difference)
			int num1 = (X + Y) / 2;

			// Check if the first number is negative or overflows the integer range
			if (num1 < 0 || num1 > INT_MAX) {
				return {-1, -1};
			}

			// Calculate the second number (difference between first number and Y)
			int num2 = num1 - Y;

			return {num1, num2};
		}

	780) Ninja and Chocolates:
		Problem statement
			Ninja is at a shop to buy his favourite chocolates.
			The cost of a chocolate is 10 Rupees. There is an ongoing offer where the shop offers a discount of 48 Rupees on every 5 chocolates bought by the customer.
			If Ninja buys ‘N’ chocolates, return the amount he must pay to the shopkeeper.
			It is guaranteed that the answer fits in a 32-bit integer.
			Example :
			‘N’ = 20
			The total amount without discount is 20 x 10 = 200. Since Ninja has bought 20 chocolates, he will get a discount of (floor(20/5)) x (5) = 4 x 48 = 192 Rupees. 
			Hence, he will pay a total amount of 200 - 192 = 8 Rupees to the shopkeeper.
			Constraints :
				1 <= T <= 10
				1 <= N <= 2 ^ 31 - 1
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				32
				Sample Output 1 :
				40
				32
				Explanation Of Sample Input 1 :
				For test case 1:
				Ninja pays a total of 4 * 10 = 40 Rupees for the chocolates as no discount is offered.
				For test case 2:
				The total amount without discount is 10 x 32 = 320.        
				The discount offered is (floor (32/5)) x  (48) = 6 x 48 = 288 Rupees. 
				Hence, he will pay a total amount of (320 - 288) = 32 Rupees to the shopkeeper
				Sample Input 2 :
				2
				86
				192
				Sample Output 2 :
				44
				96

		#include <bits/stdc++.h> 
		int chocPrice(int n){
			if(n < 5)
				return n * 10;

			int grps = n / 5;
			int discForEachGrp = 48 * grps;
			int totalCost = n * 10;
			return totalCost - discForEachGrp;
		}
	
	781) Rotate a Linked List:
		Problem Statement1:
			Given a singly linked list of size N. The task is to left-shift the linked list by k nodes, where k is a given positive integer smaller than or equal to length of the linked list.
			Example 1:
				Input:
				N = 5
				value[] = {2, 4, 7, 8, 9}
				k = 3
				Output: 8 9 2 4 7
				Explanation:
				Rotate 1: 4 -> 7 -> 8 -> 9 -> 2
				Rotate 2: 7 -> 8 -> 9 -> 2 -> 4
				Rotate 3: 8 -> 9 -> 2 -> 4 -> 7
			Example 2:
				Input:
				N = 8
				value[] = {1, 2, 3, 4, 5, 6, 7, 8}
				k = 4
				Output: 5 6 7 8 1 2 3 4

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function rotate() which takes a head reference as the first argument and k as the second argument, and returns the head of the rotated linked list.
				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <= 10^3
				1 <= k <= N

		/* TC: O(n) & SC: O(n)*/
			/*
				struct Node {
					int data;
					struct Node *next;
					Node(int x) {
						data = x;
						next = NULL;
					}
				};
			*/
			
			class Solution {
				public:
				//Function to rotate a linked list.
				Node* rotate(Node* head, int k) {

					vector<int> v;
					Node* temp1 =head;
					
					while(k--)
						temp1 = temp1 -> next;
						
					// if(temp1 == NULL)
					//     return head;
						
					Node* temp2 = temp1;
					
					while(temp1){
						v.push_back(temp1 -> data);
						temp1 = temp1 -> next;
					}
					
					temp1 = head;
					while(temp1 != temp2){
						v.push_back(temp1 -> data);
						temp1 = temp1 -> next;
					}
					
					temp1 = head;
					int i=0;
					while(temp1){
						temp1 -> data = v[i++];
						temp1 = temp1 -> next;
					}
					
					return head;
				}
			};

		/*TC: O(n) & SC: O(1)*/
			class Solution {
				public:
				//Function to rotate a linked list.
				Node* rotate(Node* head, int k) {
					
					Node* temp1 =head;
					Node* prev = temp1;
					
					while(k--){
						prev = temp1;
						temp1 = temp1 -> next;
					}
					
					// need to handle the case where k & no.of nodes are same
					if(temp1 == NULL)
						return head;
						
					prev -> next = NULL;
					Node* temp2 = temp1;
					
					while(temp2 -> next)            // or         while(temp2 -> next  != NULL)
						temp2 = temp2 -> next;
					
					temp2 -> next = head;
					return temp1;
				}
			};

	782) Reorder List:
		Problem Statement:
			Given a singly linked list: A0→A1→...→An-2→An-1, reorder it to: A0→An-1→A1→An-2→A2→An-3→...
			For example: Given 1->2->3->4->5 its reorder is 1->5->2->4->3.
			Note: It is recommended do this in-place without altering the node's values.
			Example 1:
			Input:
			LinkedList: 1->2->3
			Output: 1 3 2
			Explanation:
			Here n=3, so the correct
			order is A0→A2→A1

			Example 2:
			Input:
			Explanation: 1->7->3->4
			Output: 1 4 7 3
			Explanation:
			Here n=4, so the correct
			order is A0→A3→A1→A2

			Your Task:
				The task is to complete the function reorderList() which should reorder the list as required. The reorder list is automatically printed by the driver's code.
				Note: Try to solve without using any auxilliary space.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 5*105
				0 <= A[ i ] <= 105

		/*
			struct Node {
				int data;
				struct Node* next;

				Node(int x){
					data = x;
					next = NULL;
				}
			};
		*/

		/*TC: O(n) & SC: O(n)*/
			class Solution{ 
				public:
				void reorderList(Node* head) {
					vector<int> v;
					Node* temp = head;
					
					while(temp){
						v.push_back(temp -> data);
						temp = temp -> next;
					}
					
					int f =1, s = 0, e = v.size()-1;
					temp = head;
					while(s <= e){
						if(f){
							temp -> data = v[s++];
						}else{
							temp -> data = v[e--];
						}
						temp = temp -> next;
						f = f ? 0:1;
					}
				}
			};

		/*TC: O(n) & SC: O(1)*/
			❌Pending			
	
	783) Reverse a String:
		Problem Statement:
			You are given a string s. You need to reverse the string.
			Example 1:
			Input:
			s = Geeks
			Output: skeeG
			
			Example 2:
			Input:
			s = for
			Output: rof

			Your Task:
				You only need to complete the function reverseWord() that takes s as parameter and returns the reversed string.
			
			Expected Time Complexity: O(|S|).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= |s| <= 10000

		class Solution {
			public:
			string reverseWord(string str) {
				reverse(str.begin(), str.end());
				return str;
			}
		};
		
		// or
			class Solution {
				public:
				string reverseWord(string str) {
					for(int i=0; i < str.size()/2; i++)
						swap(str[i], str[str.size()-1-i]);
					return str;
				}
			};

	784) Magical String[Duplicate Problem]:
		Problem Statement:
			You are given a string S, convert it into a magical string.
			A string can be made into a magical string if the alphabets are swapped in the given manner: a->z or z->a, b->y or y->b, and so on.  
			Note: All the alphabets in the string are in lowercase.

			Example 1:
			Input:
			S = varun
			Output:
			ezifm
			Explanation:
			Magical string of "varun" 
			will be "ezifm" 
			since v->e , a->z , 
			r->i , u->f and n->m.
		
			Example 2:
			Input:
			S = akshay
			Output:
			zphszb
			Explanation:
			Magical string of "akshay" 
			will be "zphszb" 
			since a->z , k->p , s->h , 
			h->s , a->z and y->b.
			
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function magicalString() which takes the string S and returns the magical string.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1<=Length of String<=100

		class Solution{   
			public:
			string magicalString(string S){
				map<char, char> mapping = {
										{'a','z'}, {'b','y'}, {'c','x'},
										{'d','w'}, {'e','v'}, {'f','u'},
										{'g','t'}, {'h','s'}, {'i','r'},
										{'j','q'}, {'k','p'}, {'l','o'},
										{'m','n'}, {'n','m'}, {'o','l'},
										{'p','k'}, {'q','j'}, {'r','i'},
										{'s','h'}, {'t','g'}, {'u','f'},
										{'v','e'}, {'w','d'}, {'x','c'},
										{'y','b'}, {'z','a'}
									};

				string ans;
				for(int i=0; i<S.size(); i++)
						ans += mapping[S[i]];
						
				return ans;
			}
		};

		// or
			class Solution{   
				public:
				string magicalString(string S){
					string ans;
					for(int i=0; i<S.size(); i++)
						ans += 'a' - S[i] + 'z';					//or             ans += 'z' - S[i] + 'a';
					
					return ans;
				}
			};

	785) Perfect Reversible String:
		Problem Statement:
			You are given a string ‘str’, the task is to check that reverses of all possible substrings of ‘str’ are present in ‘str’. If yes then the answer is 1, otherwise, the answer will be 0.

			Example 1:
				Input: n = 2, str = "ab"
				Output: 0
				Explanation: All substrings are "a",
				"b","ab" but reverse of "ab" is not 
				present in str.
			Example 2:
				Input: n = 3, str = "aba"
				Output: 1
				Explanation: Reverse of all possible 
				substring is present in str.

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function isReversible() which takes the string str and n (the length of str) as inputs and returns the answer.
				
			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
			1 ≤ n ≤ 2 * 105

		// Optimized:
			class Solution{
				public:
				int isReversible(string str, int n) {
					// the string contains all reverse substring if & only if that string is palindrome, else any of substring's reverse will not present
					for(int i=0; i < (n/2); i++)
						if(str[i] != str[n-1-i])
							return 0;
					return 1;   
				}
			};

		// Not Optimized
			class Solution{
				public:
				int isReversible(string str, int n) {
					for(int i=0; i<n-1; i++){
						int mxChar = n - i -1;
						for(int j = 2; j <= mxChar+1; j++){
							string sub = str.substr(i, j);
							
							// cout<<sub<<"\t";
							reverse(sub.begin(), sub.end());
							if(str.find(sub) == string::npos)
								return 0;
						}
					}		
					return 1;   
				}
			};
	
	786) String with numbers at its end:
		Problem Statement:
			Given string s that is appended with a number at last. The task is to check whether the length of string excluding that number is equal to that number.

			Example 1:
			Input:  s = "geeks5"
			Output: 1
			Explanation: Length of geeks is 5
			and the last number is also 5.
			
			Example 2:
			Input:  s = "geek5"
			Output: 0
			Explanation: Length of geek is 4
			and the last number is 5.
			User Task:
				Your task is to complete the function isSame() which takes a single string as input and returns 1 in case the answer is true, otherwise 0. You do not need to take any input or print anything.

			Expected Time Complexity: O(|s|)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= |s| <= 10^5

		class Solution{ 
			public:
			int isSame(string s) {
				int num =0, cnt=0;
				
				for(char ch: s)
					if(isdigit(ch)){
						num = (num * 10) + (ch - '0');
						cnt++;
					}
				return num == (s.size() - cnt);
			}
		};
	
	787) Compare two Large Numbers:
		// if there are 2 string the larger string is decided by the size of string
		// if first string has larger size than second string then first string is larger
		// if second string has larger size than first string then second string is larger
		// if both the strings have same size then the comparison is done character by character,
		// if we found the character which has larger ascii value in the first string than the first string is considered as larger one, & viceversa

		Problem Statement:
			You will be given two numbers a and b. Your task is to print 1 if a < b, print 2 if a > b and print 3 if a = b.

			Example 1:
			Input: 
			a = 1234
			b = 12345
			Output: 1
			Explanation: a < b so answer is 1.

			Example 2:
			Input:
			a = 100
			b = 1
			Output: 2
			Explanation: a > b, so answer is 2.
			User Task:
			Your task is to complete the function check() which takes 2 arguments(string a, string b) and returns the answer. You need not take input or print anything.
			Expected Time Complexity: O(|a| + |b|).
			Expected Auxiliary Space: O(|a| - |b|).

			Constraints:
			1 ≤ |a|, |b| ≤ 155      
			'0' ≤  ai,bi  ≤  '9'



		int check(string a,string b){
			while(a.size() && a[0] == '0')
				a.erase(a.begin());
			
			while(b.size() && b[0] == '0')
				b.erase(b.begin());
			
			if(a.size() < b.size())
				return 1;
			else if(a.size() > b.size())
				return 2;
			
			int i=0;
			while(i < a.size()){
				if(a[i] != b[i]){
					if(a[i] < b[i])
						return 1;
					else
						return 2;
				}
				i++;
			}
			return 3;
		}
	
	788) The Penalty Shootout:
		Problem Statement:
			Given a string S contains 0's, 1's, and 2's, the task is to find the number of goals on the penalty.
			'1' stands for "goal".
			'0' stands for "no goal".
			'2' stands for a foul which gives a penalty.

			Example 1:
			Input: S = "1012012112110"
			Output: 2
			Explanation: There are 3 penalties,
			of which he scores only 2.
			1012012112110

			Example 2:
			Input: S = "111122"
			Output: 0
			Explanation: No goal on penalty

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function penaltyScore() which takes a string S as input and returns the goals count on the penalty.

			Expected Time Complexity: O(|S|).
			Expected Auxiliary Space: O(1).

			Constraints:
			1 <= |N| <= 10^5

		class Solution{
			public:	
			int penaltyScore(string s) {
				int GoalPenalty=0;
				int i=0;
				while(i < s.size()){
					if(s[i] == '2' && i+1 < s.size() && s[i+1] == '1')
						GoalPenalty++;
					i++;
				}
				return GoalPenalty; 
			}
		};
	
	789) Good String:
		Problem Statement:
			Given a string s of length N, you have to tell whether it is good or not. A good string is one where the distance between every two adjacent character is exactly 1. Here distance is defined by minimum distance between two character when alphabets from 'a' to 'z' are put in cyclic manner. For example distance between 'a' to 'c' is 2 and distance between 'a' to 'y' is also 2. The task is to print "YES" or "NO" (without quotes) depending on whether the given string is Good or not.
			Note: Unit length string will be always good.
			Example 1:
			Input: s = "aaa"
			Output: NO
			Explanation: distance between 'a' and 'a' is not 1.

			Example 2:
			Input: s = "cbc"
			Output: YES
			Explanation: distance between 'b' and 'c' is 1.

			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function isGoodString() which accepts a string as input parameter and returns "YES" or "NO" (without quotes) accordingly. 
			
			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)
			
			Constraints:
				String contains only lower case english alphabets.
				1 <= N <= 10^5

		string isGoodString(string s) {
			for(int i=0; i<s.size()-1; i++){
				char ch1 = s[i] + 1, ch2 = s[i+1];
				char ch3 = s[i] - 1;
				
				if(ch1 > 'z')
					ch1 = 'a';
				
				if(ch3 < 'a')
					ch3 = 'z';
				
				if(ch1 != ch2 && ch2 != ch3)
					return "NO";
			}
			return "YES";
		}

		// or
			string isGoodString(string s) {
				for(int i=0;i<s.length()-1;i++){
					if(abs(s[i]-s[i+1]) != 1 && abs(s[i]-s[i+1]) != 25)
						return "NO";
				}
				return "YES";
			}

	#CN WeeklyContest-124:
		790) Battle Begins:
			Problem statement
				There is a number line where points are numbered from ‘0’ to infinity. There are also two players Alice and Bob, where Alice is currently present at point ‘X’ and Bob is currently present at point ‘Y’.
				In each iteration of the game, Alice moves ‘A’ steps right and Bob moves ‘B’ steps left. More formally, if Alice is present at some point ‘P’, she’ll move to point ‘(P + A), and if Bob is present at some point ‘Q’, he’ll move to point ‘(Q - B)’.
				You have to determine whether both the players meet at the same point after some iterations.
				Your task is to tell whether Alice and Bob can meet at the same point after some iterations of the game. Return ‘1’, if possible, otherwise return ‘0’.

				Example:
				‘X’ = 2
				‘Y’ = 8
				‘A’ = 2
				‘B’ = 1

				During the first iteration of the game, Alice will move from ‘2’ to ‘4’ and Bob will move from ‘8’ to ‘7’.
				During the second iteration of the game, Alice will move from ‘4’ to ‘6’ and Bob will move from ‘7’ to ‘6’.
				Now, both the players are present at the same point after two iterations. So, the answer for this example is ‘1’.
				Constraints:
					1 <= 'T' <= 10
					0 <= ‘X’, ‘Y’ <= 10^9 
					1 <= ‘A’, ‘B’ <= 10^9
					Time Limit: 1 sec 

				Sample Input 1:
					2
					3 15 2 4
					1 5 3 2
					Sample Output 1:
					1
					0
					Explanation of sample input 1:
					For test case 1:
					During the first iteration of the game, Alice will move from ‘3’ to ‘5’ and Bob will move from ‘15’ to ‘11’.
					During the second iteration of the game, Alice will move from ‘5’ to ‘7’ and Bob will move from ‘11’ to ‘7’. 
					Now, both the players are present at the same point. So, the answer for this test case is ‘1’.
					For test case 2:
					During the first iteration of the game, Alice will move from ‘1’ to ‘4’ and Bob will move from ‘5’ to ‘3’. 
					Now, Bob is present on the left side of Alice. So, they’ll never meet.
					Hence, the answer for this test case is ‘0’.
					Sample Input 2:
					2
					3 2 1 5
					0 10 5 5
					Sample Output 2:
					0
					1

			int battleBegins (int x, int y, int a, int b) {
				while(x <= y){
					if(x == y)
					return 1;
					x += a;
					y -= b;
				}
				return 0;
			}
		
		791) Alternate Sum:
			Problem statement
				You are given an array 'A' of 'N' integers numbered from '0' to 'N - 1'.
				Let's define the alternate sum of the array 'B' of length 'X' as the value 'B[0] - B[1] + B[2] - B[3] …. B[X - 1]'.
				You are required to remove exactly one element from the array 'A' without changing the order of the remaining elements.
				Find the maximum alternate sum of the array 'A' after removing one element.
				Example:
					N = 4
					A = [4, 2, 5, 5]
					You can remove the last element from the array 'A', resulting in ['4', '2', '5'].
					The alternate sum of the array is '4 - 2 + 5' = '7'.
					It can be proved that you can not achieve an alternate sum greater than '7' by removing one element.
					So, the answer for this case is '7'.
				Constraints:
					2 <= 'N' <= 10^5
					1 <= A[i] <= 10^4
					Time limit: 1 sec
				Sample input 1:
					2
					3
					1 1 1
					4
					1 2 1 2
					Sample output 1:
					0
					3
					Explanation of sample input 1:
					For test case 1:
					You can remove any element from the array 'A', resulting in ['1', '1'].
					The alternate sum of the array is '1 - 1' = '0'.
					It can be proved that you can not achieve an alternate sum greater than '0' by removing one element.
					So, the answer for this case is '0'.

					For test case 2:
					You can remove the first element from the array 'A', resulting in ['2', '1', '2'].
					The alternate sum of the array is '2 - 1 + 2' = '3'.
					It can be proved that you can not achieve an alternate sum greater than '3' by removing one element.
					So, the answer for this case is '3'.
					Sample input 2:
					2
					6
					4 1 1 5 1 5
					7
					5 1 4 1 3 1 2
					Sample output 2:
					12
					9

			int maximumAlternateSum(int n, vector<int> &v) {
				int mxValue= INT_MIN;

				for(int i=0; i<v.size(); i++){
					int sum =0, f=1;
					for(int j=0; j<v.size(); j++){
						if(i == j)
							continue;
						// if(f){
						//     sum += v[j];
						// }else{
						//     sum -= v[j];
						// }

						f ? sum += v[j] : sum -= v[j];
						f = f ? 0 : 1;
					}
					mxValue = max(mxValue, sum);
				}
				return mxValue;
			}

		792) Good Index:
			Problem statement
				You are given two arrays 'A' and 'B' of lengths 'N' and 'M', respectively.
				Let's define the index 'X' as good if we remove the element 'B[X]' from the array 'B' without changing the orders of other elements, it becomes the subsequence of the array 'A'.
				Find the number of the good indices in the array 'B'.
				Example:
				N = 4
				M = 3
				A = [1, 5, 2, 4]
				B = [1, 2, 5]
				We can see that only indices '1' and '2' are good as the corresponding resulting arrays are ['1', '5'] and ['1', '2'], which are subsequences of the array 'A'.
				So, the answer for this case is '2'.
				Constraints:
					1 <= 'N' <= 10^5
					1 <= 'M' <= 10^5
					1 <= 'A[i]' <= 10^9
					1 <= 'B[i]' <= 10^9
					Time limit: 1 sec
				Sample input 1:
					2
					3 3
					1 2 3
					1 3 4
					4 3
					1 2 2 1
					1 1 1
					Sample output 1:
					1
					3
					Explanation of sample input 1:
					For test case 1:
					We can see that only index '2' is good as the corresponding resulting array is ['1', '3'], which is a subsequence of the array 'A'.
					So, the answer for this case is '1'.

					For test case 2:
					We can see that every index is good as the corresponding resulting array is ['1', '1'], which is a subsequence of the array 'A'.
					So, the answer for this case is '3'.
					Sample input 2:
					2
					6 4
					1 2 1 2 2 5
					1 2 5 1
					2 2
					1 2
					3 4
					Sample output 2:
					2
					0

			// Not Optimized:
				void subSequencesGenerator(vector<int> &main, int indx, vector<int> &temp, set<vector<int>> &storer){
					if(indx == main.size()){
						storer.insert(temp);
						return;
					}

					temp.push_back(main[indx]);
					subSequencesGenerator(main, indx+1, temp, storer);

					temp.pop_back();
					subSequencesGenerator(main, indx+1, temp, storer);
				}

				int howManyGoods(int n, int m, vector<int> &a, vector<int> &b) {
					int GoodCnt=0;
					set<vector<int>>  subSequences;
					vector<int> temp;

					subSequencesGenerator(a, 0,  temp, subSequences);
					
					for(int i=0; i<m; i++){
						vector<int> test = b;
						test.erase(test.begin()+i);

						if(subSequences.find(test) != subSequences.end())
							GoodCnt++;
					}
					return GoodCnt;
				}

			// Optimized:
				❌Pending

		793) Perfect Substrings:
			Problem statement
				You are given a string ‘S’ of length ‘N’ where each character is numbered from ‘0’ to ‘N - 1’. A string ‘T’ is considered to be a perfect string if it satisfies the following conditions:
				‘T’ is a concatenation of ‘3’ strings, where the first string should be equal to the last string.
				You can write ‘T’ as:(‘S1’ + ‘S2’ + ‘S1’), where ‘S1’ and ‘S2’ are two non-empty strings which may or may not be equal.
				For example: “abbghiabb”, is a perfect string because you can write it as: (“abb” + “ghi” + “abb”).
				You will be given an array ‘Queries’ which stores ‘Q’ queries of type ‘(L, R)’. You have to tell whether the substring from ‘L’ to ‘R’ is perfect or not.
				Your task is to answer all the queries and return an array of ‘1’s and ‘0’s where ‘1’ means the substring is perfect and ‘0’ means the substring is not perfect.
				Example:
					‘N’ = 11
					‘S’ = “acdafkbgb”
					‘Q’ = 1
					‘Queries’ = [[0, 3]]

				Here, you have to check whether “acda” is perfect or not. You can write “acda” as: “a” + “cd” + “a”, which satisfies the criteria of perfect string.
				So the answer for this example is: [1].

				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 5000
					‘a’ <= ‘S[i]’ <= ‘z’
					1 <= ‘Q’ <= 10^6
					0 <= ‘Queries[i][0]’ <= ‘Queries[i][1]’ <= ‘N - 1’.
					Time Limit: 1 sec 

				Sample Input 1:
					2
					13
					abaabacefffcd
					2
					0 4
					8 10
					3
					klo
					1
					2 2
					Sample Output 1:
					1 1
					0
					Explanation of sample input 1:
					For test case 1:
					‘1st’ query is “abaab”. You can write it as: “ab” + “a” + “ab” which follows the criteria of perfect string.
					‘2nd’ query is “fff”. You can write it as: “f” + “f” + “f” which also satisfies the criteria of perfect string.
					So, the answer for this test case is: [1, 1].
					For test case 2:
					Here we have only one query: “o”. It is not a perfect string.
					So, the answer for this test case is: [0].
					Sample Input 2:
					2
					10
					zbaczbakkk
					3
					1 3
					0 2
					1 6
					18
					aaabbbcccdddeeefff
					2
					0 2
					3 5
					Sample Output 2:
					0 0 1
					1 1

			// Not Optimized:
				vector <int> perfectSubstrings (int n, string &s, int q, vector <vector<int>> &queries) {
					vector<int> ans;
					for(int i=0; i<q; i++){
						if(queries[i][0] == queries[i][1]){
							ans.push_back(0);
							continue;
						}
						
						string test;
						for(int z= queries[i][0]; z <= queries[i][1]; z++)
							test += s[z];
						
						//finding prefix & suffix
						int mxReverse = test.size() / 2 + 1;
						int z=0;

						while(mxReverse < test.size() && test[z] != test[mxReverse])
							mxReverse++;
							
						int midtemp = mxReverse +1;

						while(1){
							while(mxReverse < test.size() && test[z] == test[mxReverse]){
								z++, mxReverse++;
							}

							if(mxReverse >= test.size())
								break;
							z=0;
							mxReverse = midtemp;
							midtemp++;
						}

						int f = 0;
						if(test[--z] == test[--mxReverse])
							f = 1;
						
						if(f)
							ans.push_back(1);
						else
							ans.push_back(0);
					}

					return ans;
				}

			// Optimized:
				❌Pending
		
	794) Min Stack:
		Problem statement
			Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
				1. Push(num): Push the given number in the stack.
				2. Pop: Remove and return the top element from the stack if present, else return -1.
				3. Top: return the top element of the stack if present, else return -1.
				4. getMin: Returns minimum element of the stack if present, else return -1.

			For Example:
			For the following input: 
				1
				5
				1 1
				1 2
				4
				2
				3
			For the first two operations, we will just insert 1 and then 2 into the stack which was empty earlier. So now the stack is => [2,1]
			In the third operation, we need to return the minimum element of the stack, i.e., 1. So now the stack is => [2,1]
			For the fourth operation, we need to pop the topmost element of the stack, i.e., 2. Now the stack is => [1]
			In the fifth operation, we return the top element of the stack, i.e. 1 as it has one element. Now the stack is => [1]

			So, the final output will be: 
			1 2 1
			Sample Input 1 :
			2
			5
			1 1
			1 2
			4
			2
			3
			4
			1 13
			2
			3
			4
			Sample Output 1 :
			1 2 1
			13 -1 -1
			Explanation For Sample Input 1 :
			For First Case - Similar to the example explained above. 

			For Second Case - 
			For the first operation, we will just insert 13 into the stack which was empty earlier. So now the stack is => [13]
			In the second operation, we need to remove the topmost element 13 and return it for printing. Now the stack is => [] (empty)
			For the third operation, we need to return the topmost element of the stack. As the stack is empty we will return -1. Now the stack is => [] (empty)
			In the fourth operation, we return the minimum element of the stack if it is not empty, i.e. -1 as it has no elements. Now the stack is => [] (empty)
			Sample Input 2 :
			2
			4 
			4
			2
			1 4
			3
			6
			1 19
			1 45
			3
			4
			2
			3
			Sample Output 2 :
			-1 -1 4
			45 19 45 19

		// Not Optimized:
			#include <bits/stdc++.h> 
			// Implement class for minStack.
			class minStack {
				stack<int> st;
				vector<int> v;
				public:
					
				// Constructor
				minStack() {

				}
				
				// Function to add another element equal to num at the top of stack.
				void push(int num) {
					st.push(num);
					v.push_back(num);
				}
				
				// Function to remove the top element of the stack.
				int pop() {
					if(!st.empty()){
						int val = st.top();
						st.pop();
						v.pop_back();
						return val;
					}
					return -1;
				}
				
				// Function to return the top element of stack if it is present. Otherwise return -1.
				int top() {
					if(st.empty())
						return -1;
					return st.top();
				}
				
				// Function to return minimum element of stack if it is present. Otherwise return -1.
				int getMin() {
					if(st.empty())
						return -1;
					
					return *min_element(v.begin(), v.end());
				}
			};
	
		// Optimized:
			❌Pending

	795) Rahul And Minimum Subarray:
		Problem statement
			Rahul is a programming enthusiast. He is currently learning about arrays/lists. One day his teacher asked him to solve a very difficult problem. The problem was to find the length of the smallest subarray(subarray is a contiguous part of an array/list) in a given array/list ‘ARR’ of size ‘N’ with its sum greater than a given value. If there is no such subarray return 0.
			Example: Given an ‘ARR’: [1, 2, 21, 7, 6, 12] and a number ‘X’: 23. The length of the smallest subarray is 2 as the subarray is [21, 7].
			Note: Here are multiple subarrays whose sum is greater than ‘X’ such as [1, 2, 21] or [7, 6, 12] but we have to choose the minimum length subarray.
			Constraints:
				1 <= T <= 10^2
				1 <= N <= 10^3
				1 <= X <= 10^9
				0 <= A[i] <= 10^9
				Time Limit: 1 sec

			Sample Input 1:
				2
				5 11
				9 1 5 3 9
				4 8
				5 1 2 1 
				Sample Output 1:
				2
				4
				Explanation For Sample Input 1:
				In the first test case, the length of the minimum subarray is 2. The subarray is [3, 9] as the sum is 12 which is greater than the given value 11.

				In the second test case, the length of the minimum subarray is 4. The subarray is [5,1, 2, 1] as the sum is 9 which is greater than the given value 8.
				Sample Input 2:
				2
				7  32
				27 1 2 4 15 12 8 
				6 10
				9 1 2 11 4 1 
				Sample Output 2:
				3
				1
				Explanation For Sample Input 2:
				In the first test case, the length of the minimum subarray is 3. The subarray is [15,12, 8] as the sum is 35 which is greater than the given value 32.
				In the second test case, the length of the minimum subarray is 1. The subarray is [11] as the sum is 11 which is greater than the given value 10.

		// Not Optimized:
			#include <bits/stdc++.h> 
			int minSubArrayLen(vector<int>& arr, int target, int n) {
				int minSize = INT_MAX;

				if(accumulate(arr.begin(), arr.end(),0) <= target)
					return 0;

				vector<int> temp;
				for(int i=0; i<n; i++){
					vector<int> test;
					int s =0, f=0;

					for(int j=i; j<n; j++){
						test.push_back(arr[i]);
						s += arr[j];

						if(s > target){
							f = 1;
							break;
						}
					}
					if(f && minSize > test.size()){
						minSize = test.size();
						temp = test;
					}
				}
				return minSize;
			}
	
		// Optimized:
			❌Pending

	796) Transactions:
		Problem statement
			Alex is going to some stores where he will carry out some transactions. In each store, he will either pay some money, or he will receive some money. Initially, Alex has 0 amount with him. So he currently has an array 'money' containing the transaction amounts (both positive and negative) in the same order he did at stores. Can you find out the maximum amount that he will have with him after any(possibly 0) number of transactions?
			Note: that at some point, the amount left with Alex can become negative. For example, in the transactions [1, -3], after the second transaction, the money left with Alex is -2.
			Example: Let the transaction amounts be [1, -2, 5]. Here we can see that the amount left after the first transaction is 1 after the second is -1 and after the third is 4. So the maximum value is 4.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^4
				-10^5 <= money[i] <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				6
				1 -3 5 -6 4 -3
				1
				11
				Sample Output 1:
				3
				11
				Explanation for Sample Input 1:
				In the first test case, the transaction values are [1, -3, 5, -6, 4, -3]. We can see that after the first transaction, the money left with Alex is 1. After the second, it is -2, then 3, then -3, then 1, and finally -2. We can see that after the third transaction, the money left with Alex is 3, which is the maximum money that he can have.
				In the second test case, there is only one transaction. He receives 11 in the first transaction, which is also the highest that he can have.
				Sample Input 2:
				2
				5
				5 7 11 3 5
				3
				-20 -19 -21
				Sample Output 2:
				31
				0

		long long transactions(vector<int> &money) {
			long long ans = 0;
			// if(money.size()==1)
			//     return money[0];

			long long s=0;
			for(int i=0; i<money.size(); i++){
				s += money[i];
				ans =  max(ans, s);
			}
			return ans;
		}
	
	797) Count vowels, consonants, and spaces:
		Problem statement
			Given a string, write a program to count the number of vowels, consonants, and spaces in that string.
			EXAMPLE :
			Input: ‘N’= 25, ‘s’ =”Take u forward is Awesome”
			Output: 10 11 4
			Constraints :
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				It is guaranteed that sum of ‘N’ over all test cases is <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
			2
			25
			Take u forward is Awesome
			27
			India won the cricket match
			Sample Output 1 :
			10 11 4
			8 15 4
			Explanation Of Sample Input 1 :
			Note: Ignore the inverted commas at the start and end of the string, they are just to make it visually better to understand the given string.
			The first test case is the same as the explanation above.
			For the second test case, the vowels are at indices {1, 4, 5, 8, 13, 17, 20, 24} and spaces are at indices {6, 10, 14, 22} rest indices are consonants i.e. (27 - 8 - 4) = 15.
			Hence, the output will be: 8 15 4
			Sample Input 2 :
			2
			12
			hEllOWorlD
			2
			Sample Output 2 :
			3 7 2
			0 0 2

		#include <bits/stdc++.h> 
		vector<int> countVowelsConsonantsSpaces(string &s, int n) {
			int sp, vow, conso;
			sp = vow = conso = 0;

			// shifting the string to lower-case
			transform(s.begin(), s.end(), s.begin(), ::tolower);
			
			for(char ch: s)
				if(isblank(ch))
					sp++;
				else if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
					vow++;
				else
					conso++;

			return {vow, conso, sp};
		}
	
	798) Insertion In A Singly Linked List:
		Problem statement
			You are given a Singly Linked List of ‘N’ positive integers. Your task is to add a node having the value ‘VAL’ at position ‘POS’ in the linked list.
			Note:
				Assume that the Indexing for the linked list starts from 0.
				EXAMPLE:
				Input: ‘N’ = 5, 'LIST' = [1, 1, 2, 3, 4, -1], ‘VAL’ = 2, ‘POS’ = 1.
				Output: 1 -> 2 -> 1 -> 2 -> 3 -> 4 
				Here in the given list we can see that the node having value 2 is inserted at position 1.
			Constraints :
				1 <= ‘T’ <= 10 
				1 <= ‘N’ <= 10^4 
				0 <= ‘POS <= N  
				1 <= ‘data’, 'VAL' <= 10^7
				Where 'N' is the size of the singly linked list, and ‘data’ is the Integer data of the singly linked list.
				Time Limit: 1 sec

			Sample Input 1 :
				2
				5
				1 1 2 3 4 -1
				2 1
				1
				1 -1
				3 1
				Sample Output 1 :
				1 2 1 2 3 4
				1 3
				Explanation Of Sample Input 1 :
				For the first test case,
				‘N’ = 5, 'LIST' = [1, 1, 2, 3, 4, -1], ‘VAL’ = 2, ‘POS’ = 1.
				After inserting the node having value = 2 at position 1 the list will be:
				1 -> 2 -> 1 -> 2 -> 3 -> 4.

				For the second test case,
				‘N’ = 1,  'LIST' = [1, -1], ‘VAL’ = 3, ‘POS’ = 1.
				After inserting the node having value = 3 at position 1 the list will be:
				1 -> 3.
				Sample Input 2 :
				2
				2
				1 2 -1
				3 0
				2
				3 4 -1
				5 1
				Sample Output 2 :
				3 1 2  
				3 5 4

		/************************************************************
			Following is the LinkedList class structure:
			class Node {
			public:
				int data;
				Node *next;

				Node(int val) {
					this->data = val;
					next = NULL;
				}
				~Node() {
					if (next != NULL) {
						delete next;
					}
				}
			};
		************************************************************/

		Node * insert(Node * head, int n, int pos, int val) {
			Node* newNode = new Node(val);

			if(pos == 0){
				newNode -> next = head;
				head = newNode;

				return head;
			}

			Node *cur = head;
			Node *prev = head;

			while(pos--){
				prev = cur;
				cur = cur -> next;
			}

			prev -> next = newNode;
			newNode -> next = cur;

			return head;
		}
	
	799) Boolean Queries:
		Problem statement
			You are given a stream of boolean values. Your task is to maintain a data structure that supports the following functions.
			setAllTrue(): Sets all the indicies to true
			setAllFalse(): Sets all the indices to false
			setIndexTrue(index): Set the value at position index to true
			setIndexFalse(index): Set the value at position index to False
			getIndex(index): Return the value of position index
			Note:
			Initially, all the values of the data structure are set to false.
			The Queries are in the format below-:
			(1, index, value): Set the value at the given index
			(2, index): Get the value at the given index 
			(3, value): Set all the indices to the boolean value given.
			The value 1 represents true and 0 represents false.
			For example:

			You are given Q = [[1, 2, 1], [3, 0], [2, 4]], Here 
			Q[0] is the query that sets the boolean value at index 2 to True.
			Q[1] is the query that sets the value of all indices to False.
			Q[2] is the query that gets the value at index 4 that is False.
			Hence the answer is [False].
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints:
			1 <= T <= 10
			2 <= Q <= 10^6
			1 <= index <= 10^5

			Time Limit: 1 sec
			Note:
			You do not need to print anything. It has already been taken care of. Just implement the function.
			Sample Input 1:
			2
			3
			1 2 1
			3 0
			2 4 
			3
			3 1
			2 6
			2 5
			Sample Output 1:
			False
			True
			True    
			Explanation:
			For first test case,  Q = [[1, 2, 1], [3, 0], [2, 4]], Here 
			Q[0] is the query that sets the boolean value at index 2 to True
			Q[1] is the query that sets the value of all indices to False
			Q[2] is the query that gets the value at index 4 that is False.
			Hence the answer is in a single line [False]

			For the second test case, Q = [[3, 1], [2, 6], [2, 5]], Here
			Q[0] is the query that sets all the indices to True.
			Q[1] is the query that gets the value at index 6, this is True.
			Q[2] is the query that gets the value at index 5 that is True.
			Hence the answer is [True, True].
			Sample Input 2:
			2
			5
			2 4
			1 4 1
			2 4
			3 0
			2 4
			2
			3 1
			2 9
			Sample Output 2:
			False
			True
			False
			True

		// commented lines are not mandatory
		// Not Optimized:
			class InfiniteArray {
				public: 
				vector<bool> v;

				InfiniteArray() {
					v.resize(100000, false);
				}
					
				void setAllTrue() {
					fill(v.begin(), v.end(), true);
				}

				void setAllFalse() {
					fill(v.begin(), v.end(), false);
				}

				void setIndexTrue(int index) {
					// if(index >=0 && index < v.size())
						v[index] = true;
				}

				void setIndexFalse(int index) {
					// if(index >=0 && index < v.size())
						v[index] = false;
				}

				bool getIndex(int index){
					// if(index >=0 && index < v.size())
						return v[index];
					// return false;
				}
			};
		
		// Optimized:
			#include<bits/stdc++.h>
			class InfiniteArray {
				public:
				bool flag = false;
				unordered_map<int, bool> mp;
				InfiniteArray() {}

				void setAllTrue() {
					mp.clear();
					flag = true;
				}

				void setAllFalse() {
					mp.clear();
					flag = false;
				}

				void setIndexTrue(int i) { mp[i] = true; }
				void setIndexFalse(int i) { mp[i] = false; }

				bool getIndex(int i) {
					if (mp.find(i) != mp.end())
						return mp[i];
					else
						return flag;
					
					/* or
						if (indexMap.count(index) == 0) {
							return DefaultValue;
						} else {
							return indexMap[index];
						}
					*/
				}
			};
	
	#AtCoder BeginnerContest-352
		800) A - AtCoder Line:
			Problem Statement
				The AtCoder railway line has N stations, numbered 1,2,…,N.
				On this line, there are inbound trains that start at station 1 and stop at the stations 2,3,…,N in order, and outbound trains that start at station 
				N and stop at the stations N−1,N−2,…,1 in order.

				Takahashi is about to travel from station X to station Y using only one of the inbound and outbound trains.
				Determine whether the train stops at station Z during this travel.

				Constraints
				3 ≤ N ≤ 100
				1 ≤ X,Y,Z ≤ N
				X, Y, and Z are distinct.
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:
				N X Y Z
				Output
				If the train stops at station Z during the travel from station X to station Y, print Yes; otherwise, print No.

				Sample Input 1
				7 6 1 3
				Sample Output 1
				Yes
				To travel from station 
				6 to station 1, Takahashi will take an outbound train.

				After departing from station 6, the train stops at stations 5,4,3,2,1 in order, which include station 3, so you should print Yes.
				Sample Input 2
				10 3 2 9
				Sample Output 2
				No
				Sample Input 3
				100 23 67 45
				Sample Output 3
				Yes

			- The Z should be in between X & Y, else print "No".
			#include <iostream>
			using namespace std;

			int main() {
				int N, x,y,z;
				cin>>N>>x>>y>>z;
				
				if((x < z && z < y) || (x > z && z > y))
					std::cout << "Yes" << std::endl;
				else
					std::cout << "No" << std::endl;
				return 0;
			}
		
		801) B - Typing:
			Problem Statement
				Takahashi tried to type a string S consisting of lowercase English letters using a keyboard.
				He was typing while looking only at the keyboard, not the screen.
				Whenever he mistakenly typed a different lowercase English letter, he immediately pressed the backspace key. However, the backspace key was broken, so the mistakenly typed letter was not deleted, and the actual string typed was T.
				He did not mistakenly press any keys other than those for lowercase English letters.
				The characters in T that were not mistakenly typed are called correctly typed characters.

				Determine the positions in T of the correctly typed characters.
				Constraints
				S and T are strings of lowercase English letters with lengths between 
				1 and 2×10^5 , inclusive.
				T is a string obtained by the procedure described in the problem statement.
				Input
				The input is given from Standard Input in the following format:
					S
					T
				Output
				Let ∣S∣ be the length of S. If the correctly typed characters are the 
				Ensure that the output is in ascending order. That is, Ai < Ai+1 should hold for each 1 ≤ i ≤ ∣S∣−1.

				Sample Input 1
				abc
				axbxyc
				Sample Output 1
				1 3 6
				The sequence of Takahashi's typing is as follows:

				Type a.
				Try to type b but mistakenly type x.
				Press the backspace key, but the character is not deleted.
				Type b.
				Try to type c but mistakenly type x.
				Press the backspace key, but the character is not deleted.
				Try to type c but mistakenly type y.
				Press the backspace key, but the character is not deleted.
				Type c.
				The correctly typed characters are the first, third, and sixth characters.

				Sample Input 2
				aaaa
				bbbbaaaa
				Sample Output 2
				5 6 7 8
				Sample Input 3
				atcoder
				atcoder
				Sample Output 3
				1 2 3 4 5 6 7
				Takahashi did not mistakenly type any characters.

			#include <iostream>
			using namespace std;

			int main() {
				string s,t;
				cin>>s>>t;
				int cnt = 0;
				
				int i, j;
				i=j=0;
				
				while(i < s.size() && j < t.size()){
					cnt++;
					if(s[i] == t[j++]){
						i++;
						std::cout << cnt << " ";
					}
				}
				return 0;
			}

	802) Boats to Save People:
		Problem Statement:
			You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.
			Return the minimum number of boats to carry every given person.
			Example 1:
			Input: people = [1,2], limit = 3
			Output: 1
			Explanation: 1 boat (1, 2)

			Example 2:
			Input: people = [3,2,2,1], limit = 3
			Output: 3
			Explanation: 3 boats (1, 2), (2) and (3)

			Example 3:
			Input: people = [3,5,3,4], limit = 5
			Output: 4
			Explanation: 4 boats (3), (3), (4), (5)

			Constraints:
				1 <= people.length <= 5 * 10^4
				1 <= people[i] <= limit <= 3 * 10^4
		
		class Solution {
			public:
			int numRescueBoats(vector<int>& people, int limit) {
				int nums=0, s=0;
				sort(people.begin(), people.end());
				int i=0, j= people.size()-1;
				
				while(i <= j){
					if(i == j){
						i++,j--;
						nums++;
					}else if((people[i] + people[j]) <= limit){
						i++,j--;
						nums++;
					}else{
						j--;
						nums++;
					}
				}
				return nums;
			}
		};

	803) Minimum Rotations:
		Problem statement
			You’re given a string 'S' of length 'N'. Your task is to find the minimum number of rotations to get the same string 'S'.
			NOTE :
			The string only consists of lowercase English alphabets.
			Constraints :
				1 <= T <= 100
				1 <= N <= 10 ^ 4
				Time Limit: 1 sec
				The string 'S' only contains lowercase English characters.     

				Where 'T' denotes the number of test cases and 'N' denotes the length of string 'S'. 
			Sample Input 1 :
			1
			5
			ninja
			Sample Output 1 :
			5
			Explanation of Sample Input 1 :
			After five rotations we get the same string i.e “ninja”.  
			Sample Input 2 :
			1
			5
			ccccc
			Sample Output 2 :
			1
			Explanation of Sample Input 2 :
			Just after one rotation, we get the same string i.e “ccccc”.

		#include <bits/stdc++.h> 
		int minimumRotations(int n, string s){
			// string test = s;
			// int cnt=0;

			// if at least one different char we found in string then to achieve the same string again we have to rotate it by its size times.
			for(int i=0; i<n-1; i++)
				if(s[i] != s[i+1])
					return n;

			return 1;
		}

	804) Append Nodes:
		Problem statement
			You have been given an integer Linked List.
			After every 'M' nodes, you have to take the sum of the next 'N' nodes and append that sum to the linked list. Do this till the end of the Linked List.
			Note:
			You just need to return the head of the new linked list.
			In case the linked list ends after adding K nodes, where K is any positive integer less than 'N'.Append the sum of those K nodes at the end of the linked list.
			Constraints:
				1 <= T <= 10        
				1 <= n <= 10^4
				1 <= N <= 10^4
				1 <= M <= 10^4
				-10^5 <= VAL <= 10^5
				Where 'n' denotes the length of the linked list and 'VAL' represents a node value of the linked list.
				Time limit: 1 sec

			Sample Input 1:
				2
				1 2 3 4 5 6 7 8 9 10 11 12 -1
				2 3
				5 4 3 7 9 -1
				4 3
				Sample Output 1:
				1 2 3 4 5 9 6 7 8 9 10 19 11 12
				5 4 3 7 9 16
				Explanation of the Sample Output 1:
				In test case 1, for the linked list,  the value of 'M' is 3. So we skip the first 3 nodes(1->2->3). The value of 'N' is 2, hence we add the next 2 nodes(4->5). The sum is 9, so we add 9 after node 5. Now repeating the same process again, we skip the next 3 nodes(6->7->8). Now we add the next 2 nodes(9->10), for which the sum is 19. Hence we add 19 to the list after 10. Now while skipping the next 3 nodes we encounter the end of a linked list, hence the updated linked list is our answer.

				In test case 2, for the linked list,  the value of 'M' is 3. So we skip the first 3 nodes(5->4->3). The value of 'N' is 4 so ideally we should add the next 4 nodes, but there are only two nodes remaining before we encounter the end of the linked list, hence we add those 2 nodes(7->9). The sum is 16, therefore we add 16 to the end of the linked list. Because we have encountered the end of the linked list, the updated linked list is our answer.
				Sample Input 2:
				2
				10 30 10 40 5 5 -1
				2 3
				1 -2 1 2 2 -4 2 4 -1
				2 4
				Sample Output 2:
				10 30 10 40 5 45 5 
				1 -2 1 2 2 -4 -2 2 4
				Explanation of the Sample Output 2:
				In test case 1, for the linked list,  the value of 'M' is 3. So we skip the first 3 nodes(10->30->10). The value of 'N' is 2, hence we add the next 2 nodes(40->5). The sum is 45, so we add 45 after node 5. Now repeating the same process again, while skipping the next 3 nodes we encounter the end of a linked list, hence the updated linked list is our answer.

				In test case 2, for the linked list,  the value of 'M' is 4. So we skip the first 4 nodes(1->-2->1->2). The value of 'N' is 2, hence we add the next 2 nodes(2->-4). The sum is -2, so we add -2 after node 6. Now repeating the same process again, while skipping the next 4 nodes we encounter the end of a linked list, hence the updated linked list is our answer.

		#include <bits/stdc++.h> 
		/****************************************************************
			Following is the class structure of the Node class:
			class Node {
				public:
				int data;
				Node *next;
				Node(int data)
				{
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/

		Node* addNodes(Node* head, int n, int m) {
			Node* temp = head;
			while(temp){
				int skipVal = m;
				while(temp && skipVal--)
					temp = temp -> next;
				
				int s=0, addVal = n;
				Node* prev = NULL;
				while(temp && addVal--){
					s += temp -> data;
					prev = temp;
					temp = temp -> next;
				}
				if(s != 0){
					Node* newOne = new Node(s);
					prev -> next = newOne;
					newOne -> next = temp;
				}
			}
			return head;
		}

	805) Unlucky Number:
		Problem statement
			Tushar is very superstitious. So naturally he hates the number 13. Not just that,
			he even hates numbers that consist of only 1s and/or 3s. He calls them 'Unlucky
			Numbers'
			One day (Friday the 13th) he sat down and wondered what the N-th unlucky
			number would be. Help him figure it out!
			Constraints:
				1 ≤ N≤ 10^9
			Sample input 1
			1
			Sample output 1
			1
			Sample input 2
			2
			Sample output 2
			3
			Sample input 3
			5
			Sample output 3
			31

		// Not Optimized:
			#include<bits/stdc++.h>
			using namespace std;
			bool consist1s_3s(int n){
				while(n){
					if(n % 10 != 1 && n%10 != 3)
						return 0;
					n /= 10;
				}
				return 1;
			}

			int main() {
				int n;
				cin>>n;
				int ans = 0;
				while(n){
					ans++;
					if(consist1s_3s(ans))
						n--;
				}
				cout<<ans;
				return 0;
			}

		// Optimized:
			❌Pending

	806) Longest Common Prefix:
		Problem Statement:
			Write a function to find the longest common prefix string amongst an array of strings.
			If there is no common prefix, return an empty string "".
			Example 1:
				Input: strs = ["flower","flow","flight"]
				Output: "fl"

			Example 2:
				Input: strs = ["dog","racecar","car"]
				Output: ""
				Explanation: There is no common prefix among the input strings.

			Constraints:
				1 <= strs.length <= 200
				0 <= strs[i].length <= 200
				strs[i] consists of only lowercase English letters.

		auto init = []{
			ios_base::sync_with_stdio(0);
			cin.tie(0);
			cout.tie(0);
			return 0;
		}();
		class Solution {
			public:
			string longestCommonPrefix(vector<string>& strs) {
				string temp = strs[0], ans;
				for(int i=1; i<strs.size(); i++){
					int z =0, itr = min(temp.size(), strs[i].size());

					while(z < itr){
						if(temp[z] != strs[i][z])
							break;
						ans += temp[z++];
					}
					temp = ans;
					ans.clear();
				}
				return temp;
			}
		};

		// or
			class Solution {
				public:
				string longestCommonPrefix(vector<string>& v) {
					string ans="";
					int n=v.size();

					sort(v.begin(), v.end());
					string first=v[0],last=v[n-1];
					
					for(int i=0; i < min(first.size(),last.size());i++){
						if(first[i]!=last[i]){
							return ans;
						}
						ans+=first[i];
					}
					return ans;
				}
			};
	
	#LeetCode WeeklyContest-396:
		807) Valid Word:
			Problem Statement:
				A word is considered valid if:
				It contains a minimum of 3 characters.
				It consists of the digits 0-9, and the uppercase and lowercase English letters. (Not necessary to have all of them.)
				It includes at least one vowel.
				It includes at least one consonant.
				You are given a string word.
				Return true if word is valid, otherwise, return false.
				Notes:
				'a', 'e', 'i', 'o', 'u', and their uppercases are vowels.
				A consonant is an English letter that is not a vowel.
				Example 1:
					Input: word = "234Adas"
					Output: true
					Explanation:
					This word satisfies the conditions.

				Example 2:
					Input: word = "b3"
					Output: false
					Explanation:
					The length of this word is fewer than 3, and does not have a vowel.

				Example 3:
					Input: word = "a3$e"
					Output: false
					Explanation:
					This word contains a '$' character and does not have a consonant.

				Constraints:
					1 <= word.length <= 20
					word consists of English uppercase and lowercase letters, digits, '@', '#', and '$'.

			class Solution {
				public:
				bool isValid(string word) {
					if(word.size() < 3)
						return 0;
					
					transform(word.begin(), word.end(), word.begin(), ::tolower);
					
					int vow=0, conso=0, dig=0;
					for(char ch: word){            
						if(isalpha(ch)){
							if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
								vow = 1;
							else
								conso = 1;
						}else if(ispunct(ch)){
							return 0;
						}
					}
					if(vow && conso)
						return 1;
					return 0;
				}
			};

		808) Minimum Number of Operations to Make Word K-Periodic:
			Problem Statement:
				You are given a string word of size n, and an integer k such that k divides n.
				In one operation, you can pick any two indices i and j, that are divisible by k, then replace the substring
				of length k starting at i with the substring of length k starting at j. That is, replace the substring word[i..i + k - 1] with the substring word[j..j + k - 1].
				Return the minimum number of operations required to make word k-periodic.
				We say that word is k-periodic if there is some string s of length k such that word can be obtained by concatenating s an arbitrary number of times. For example, if word == “ababab”, then word is 2-periodic for s = "ab".

				Example 1:
				Input: word = "leetcodeleet", k = 4
				Output: 1
				Explanation:
				We can obtain a 4-periodic string by picking i = 4 and j = 0. After this operation, word becomes equal to "leetleetleet".

				Example 2:
					Input: word = "leetcoleet", k = 2
					Output: 3
					Explanation:
					We can obtain a 2-periodic string by applying the operations in the table below.
					i	j	word
					0	2	etetcoleet
					4	0	etetetleet
					6	0	etetetetet
		
				Constraints:
					1 <= n == word.length <= 105
					1 <= k <= word.length
					k divides word.length.
					word consists only of lowercase English letters.

			// Not Optimized:
				class Solution {
					public:
					int minimumOperationsToMakeKPeriodic(string word, int k) {
						int minCnt = INT_MAX;
						
						for(int i=0; i < word.size(); i += k){
							string s1 = word.substr(i, k);
							// cout<<s1<<"\t";
							int cnt = 0;
							for(int j=0; j < word.size(); j += k){
								string s2 = word.substr(j, k);
								// cout<<s2<<"\t";
								if(s1 != s2)
									cnt++;
							}
							minCnt = min(minCnt, cnt);
						}
						return minCnt;
					}
				};

			// Optimized:
				class Solution {
					public:
					int minimumOperationsToMakeKPeriodic(string word, int k) {
						map<string, int> Fr;
						
						for(int i=0; i < word.size(); i += k){
							string s1 = word.substr(i, k);
							Fr[s1]++;
						}

						vector<int> v;
						int mxV=0;
						for(auto i: Fr){
							v.push_back(i.second);
							mxV = max(mxV, i.second);   
						}

						int once = 1, OpsCnt=0;
						for(int i: v){
							if(once && i == mxV){
								once =0;
								continue;
							}
							OpsCnt += i;
						}      
						return OpsCnt;
					}
				};
		
	809) Double a Number Represented as a Linked List:
		Problem Statement:
			You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.
			Return the head of the linked list after doubling it.
			Example 1:
			Input: head = [1,8,9]
			Output: [3,7,8]
			Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.

			Example 2:
			Input: head = [9,9,9]
			Output: [1,9,9,8]
			Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. 

			Constraints:
				The number of nodes in the list is in the range [1, 104]
				0 <= Node.val <= 9
				The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.

		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			ListNode* ReverseIt(ListNode* h){
				ListNode* prev = NULL;
				ListNode* cur = h;
				while(cur){
					ListNode* upcoming = cur -> next;
					cur -> next = prev;
					prev = cur;

					cur = upcoming;
				}
				return prev;
			}
			ListNode* doubleIt(ListNode* head) {
				head = ReverseIt(head);

				int carry = 0;
				ListNode* cur = head;
				ListNode* LastPlace = NULL;
				while(cur){
					int v = (cur -> val * 2) + carry;
					cur -> val = (v % 10);
					carry = v / 10;
					
					LastPlace = cur;
					cur = cur -> next;
				}

				if(carry != 0){
					ListNode* newNode = new ListNode(carry);
					LastPlace -> next = newNode;
				}

				head = ReverseIt(head);
				return head;
			}
		};
	
	810) Queries on Stack:
		Problem statement
			You are given an empty stack and an integer ‘LIMIT’. The size of the stack cannot exceed the ‘LIMIT’.
			You are given ‘Q’ queries of the following three types -:
			1. PUSH ‘X’ -: Push integer ‘X’ at top of the if its size is less than ‘X’, else do nothing.
			2. POP -: Pops and returns the top element of stack or -1 if the stack is empty.
			3. INC ‘K’, ‘Y’-: Increments the bottom ‘K’ elements of the stack by ‘Y’. If there are fewer than X elements in the stack, just increment all the elements in the stack.
			Your task is to return an array/list, that consists of all elements returned by a query of type ‘POP’ in the same order in which these queries are executed. See the example for more clarity.
			Note:
			1. It is guaranteed that there is at least one query of type ‘POP’.
			For Example:
			Let there be the following 10  queries and ‘LIMIT’ be 3.
			[PUSH 3, PUSH 2, PUSH 1, INC 2 1, PUSH 1, POP, INC 3 3, POP, POP, POP].
			Stack after 0th query, i.e PUSH 3,  be [3]
			Stack after 1st query, i.e PUSH 2, be [3, 2] (top to bottom of the stack is represented by right to the left of list)
			Stack after 2nd query, i.e PUSH 1, be [3, 2, 1].
			Stack after 3rd query, i.e INC 2 1, be [4, 3, 1]. We increment the bottom 2 elements by 1.
			Stack after 4th query, i.e PUSH 1, be [4, 3, 1] as the size of the stack cannot exceed 3.
			Stack after 5th query, i.e POP, be [4, 3] and we should return 1 for this query.
			Stack after 6th query, i.e INC 3 3, be [7, 6] as stack size is less than 3, so we every element.
			Stack after the 7th query, i.e POP, be [7] and we should return 6 for this query.
			Stack after 8th query, i.e POP, be [] and we should return 7 for this query.
			Stack after the 9th query, i.e POP, be [] and we should return -1 for this query.

			Thus we should return an array/list [1, 6, 7, -1].
			Constraints:
				1 <= T <= 50
				1 <= Q <= 10000
				1 <= LIMIT <= 10000
				1 <= X <= 10000
				1 <= K <= 10000
				1 <= Y <= 10000
				Where ‘T’ is the number of test cases,  ‘Q’, ‘LIMIT’, representing the number of queries, and maximum size of stack respectively, and ‘X’, ‘K’, ‘Y’ are integers described in problem statements.
				Time limit: 1 sec

			Sample Input 1:
			2
			1 1
			POP
			10 3
			PUSH 3 
			PUSH 2 
			PUSH 1
			INC 2 1 
			PUSH 1 
			POP
			INC 3 3
			POP 
			POP
			POP
			Sample Output 1:
			-1
			1 6 7 -1
			Explanation of sample input 1:
			In the first test case,  there is only 1 ‘POP’ query, as the stack initially is empty so we should return -1.

			For the second test case, refer the problem statement for an explanation.
			Sample Input 2:
			1
			5 5
			PUSH 2
			PUSH 3
			INC 1 1
			INC 2 1
			POP
			Sample Output 2:
			4

		// Not Optimized:
			#include <bits/stdc++.h> 
			/*
				Here, queries[i] is a vector of integer representing the ith query, 
				in which for different type of queries i.e -:
				1. PUSH 'X' -: queries[i][0] = 1, and queries[i][1] = 'X';
				2. POP -: queries[i][0] = 2;
				3. INC 'K', 'Y' -: queries[i][0] = 3, queries[i][1] = 'K' and queries[i][2] = 'Y';
				
			*/

			void increBottomK(stack<int> &s, int bottomK, int byVal){
				stack<int> another;
				while(!s.empty()){
					another.push(s.top());
					s.pop();
				}

				while(!another.empty()){
					if(bottomK > 0){
						s.push(another.top()+byVal);
						bottomK--;
					}
					else
						s.push(another.top());
					another.pop();
				}
			}

			vector<int> answerQueries(vector<vector<int>> &queries, int limit) {
				stack<int> st;
				vector<int> ans;
				int temp = limit;

				for(int i=0; i<queries.size(); i++){
					if(queries[i][0] == 1){
						// push operation
						if(limit > 0){
							limit--;
							st.push(queries[i][1]);
						}
					}else if(queries[i][0] == 2){
						// pop operation
						if(st.empty()){
							ans.push_back(-1);
						}else{
							ans.push_back(st.top());
							st.pop();
							limit++;
						}
					}else{
						// increment operation
						increBottomK(st, queries[i][1], queries[i][2]);
					}
				}
				return ans;
			}

		// Optimized:
			vector<int> answerQueries(vector<vector<int>> &queries, int limit) {
				vector<int> stack;
				vector<int> ans;

				for(vector<int> q : queries){           // or     for(vector<int> q : queries){     "here q considering as without reference"
					int qType = q[0];

					if(qType == 1){
						if(stack.size() < limit){
							stack.push_back(q[1]);
						}else{

						}
					}else if(qType == 2){
						if(stack.empty()){
							ans.push_back(-1);
						}else{
							ans.push_back(stack.back());
							stack.pop_back();
						}
					}else{
						int k = q[1];
						int byVal = q[2];

						int minIncrement = min(k, (int)stack.size());
						for(int i=0; i<minIncrement; i++){
							stack[i] += byVal;
						}
					}
				}
				return ans;
			}

	811) Relative Ranks:
		Problem Statement:
			You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.
			The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:

			The 1st place athlete's rank is "Gold Medal".
			The 2nd place athlete's rank is "Silver Medal".
			The 3rd place athlete's rank is "Bronze Medal".
			For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is "x").
			Return an array answer of size n where answer[i] is the rank of the ith athlete.
	
			Example 1:
				Input: score = [5,4,3,2,1]
				Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
				Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].
			Example 2:
				Input: score = [10,3,8,9,4]
				Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
				Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].
	
			Constraints:
				n == score.length
				1 <= n <= 10^4
				0 <= score[i] <= 10^6
				All the values in score are unique.

		class Solution {
			public:
			vector<string> findRelativeRanks(vector<int>& score) {
				vector<int> temp = score;
				sort(score.begin(), score.end(), greater<int>());

				map<int, string> mapper;
				int cnt =1;
				for(int i: score){
					if(cnt == 1){
						mapper[i] = "Gold Medal";
					}else if(cnt == 2){
						mapper[i] = "Silver Medal";
					}else if(cnt == 3){
						mapper[i] = "Bronze Medal";
					}else{
						mapper[i] = to_string(cnt);
					}
					cnt++;
				}

				vector<string> result;
				for(int i: temp){
					result.push_back(mapper[i]);
				}
				return result;
			}
		};

		// More Optimized:
			class Solution {
				public:
				vector<string> findRelativeRanks(vector<int>& score) {
					map<int, int> mapper;
					int n = score.size();

					for(int i=0; i<n; i++)
						mapper[score[i]] = i;

					sort(score.begin(), score.end(), greater<int>());
					vector<string> ans(n);
					for(int i=0; i<n; i++){
						if(i == 0){
							ans[mapper[score[i]]] = "Gold Medal";
						}else if(i == 1){
							ans[mapper[score[i]]] = "Silver Medal";
						}else if(i == 2){
							ans[mapper[score[i]]] = "Bronze Medal";
						}else{
							ans[mapper[score[i]]] = to_string(i+1);
						}
					}
					return ans;    
				}
			};

	812) Remove All Nodes with Value K:
		Problem statement
			You are given a Singly Linked List of integers and an integer 'K'. Your task is to remove all such nodes from the linked list whose value is equal to 'K'.
			A singly linked list is a linear data structure in which we can traverse only in one direction i.e., from Head to Tail. It consists of several nodes where each node contains some data and a reference to the next node.
			A sample Linked List-

			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5
				0 <= node.data <= 10^9 and node.data != -1 
				0 <= K <= 10^9
				Where 'node.data' denotes the value of a Linked list node, and 'K' denotes the value of the nodes to be removed.
				Time limit: 1 sec

			Sample Input 1:
				2
				2 5 7 10 -1
				7
				4 9 10 -1
				3
				Sample Output 1:
				2 5 10 -1
				4 9 10 -1
				Explanation Of Sample Input 1:
				For the first test case, the given Linked List is
				So, after deleting the node with value 7, the Linked List becomes 
				For the second test case, the given Linked List is
				As no node in the Linked List has value 3,  the Linked List remains unchanged.
				Sample Input 2:
				2
				4 9 4 -1
				4
				1 2 -1
				6
				Sample Output 2:
				9 -1
				1 2 -1
				Explanation Of Sample Input 2:
				For the first test case, the given Linked List is [4, 9, 4]. So, after deleting both the node with value 4, the Linked List becomes [9].
				For the second test case, the given Linked List is [1, 2]. As no node in the Linked List has value 6,  the Linked List remains unchanged.

		#include <bits/stdc++.h> 
		/****************************************************************
			Following is the Linked List node structure
			class Node {
			public:
				int data;
				Node *next;
				Node(int data) {
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/

		Node *removeNodes(Node *head, int k) {
			while(head && head -> data == k)
				head = head -> next;

			if(head == NULL)
				return head;
			
			Node *cur = head -> next;
			Node *prev = head;

			while(cur){
				if(cur -> data == k){
					prev -> next = cur -> next;    
				}else{
					prev = cur;
				}
				cur = cur -> next;
			}
			return head;    
		}
	
	813) Smallest number on left:
		Problem Statement:
			Given an array a of integers of length n, find the nearest smaller number for every element such that the smaller element is on left side.If no small element present on the left print -1.
			Example 1:
				Input: n = 3
				a = {1, 6, 2}
				Output: -1 1 1
				Explaination: There is no number at the 
				left of 1. Smaller number than 6 and 2 is 1.

			Example 2:
				Input: n = 6
				a = {1, 5, 0, 3, 4, 5}
				Output: -1 1 -1 0 3 4
				Explaination: Upto 3 it is easy to see 
				the smaller numbers. But for 4 the smaller 
				numbers are 1, 0 and 3. But among them 3 
				is closest. Similary for 5 it is 4.

			Your Task:
				You do not need to read input or print anything. Your task is to complete the function leftSmaller() which takes n and a as input parameters and returns the list of smaller numbers.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n ≤ 10000
				0 ≤ a[i] ≤ 10^4

		// TC: O(n²) && SC:O(n)
		class Solution{
			public:
			vector<int> leftSmaller(int n, int a[]){
				vector<int> ans(n, -1);
				for(int i=0; i<n; i++){
					for(int j = i-1; j>=0; j--){
						if(a[j] < a[i]){
							ans[i] = a[j];
							break;
						}
					}
				}
				
				return ans;
			}
		};

		// TC:O(n) && SC:O(n)
			class Solution{
				public:
				vector<int> leftSmaller(int n, int a[]){
					vector<int> res(n, -1);
					stack<int> st;
					
					for(int i=0; i<n; i++){
						while(!st.empty() && st.top() >= a[i])
							st.pop();
						
						if(!st.empty())
							res[i] = st.top();
						st.push(a[i]);
					}
					return res;
				}
			};
	
	814) Help Classmates:
		Problem Statement:
			Professor X wants his students to help each other in the chemistry lab. He suggests that every student should help out a classmate who scored less marks than him in chemistry and whose roll number appears after him. But the students are lazy and they don't want to search too far. They each pick the first roll number after them that fits the criteria. Find the marks of the classmate that each student picks.
			Note: one student may be selected by multiple classmates.

			Example 1:
			Input: N = 5, arr[] = {3, 8, 5, 2, 25}
			Output: 2 5 2 -1 -1
			Explanation: 
				1. Roll number 1 has 3 marks. The first person 
				who has less marks than him is roll number 4, 
				who has 2 marks.
				2. Roll number 2 has 8 marks, he helps student 
				with 5 marks.
				3. Roll number 3 has 5 marks, he helps student 
				with 2 marks.
				4. Roll number 4 and 5 can not pick anyone as 
				no student with higher roll number has lesser 
				marks than them. This is denoted by -1.
				Output shows the marks of the weaker student that 
				each roll number helps in order. ie- 2,5,2,-1,-1

			Example 2:
				Input: N = 4, a[] = {1, 2, 3, 4}
				Output: -1 -1 -1 -1 
				Explanation: As the marks ars in increasing order. 
				None of the students can find a classmate who has 
				a higher roll number and less marks than them.

			Your Task:
				You don't need to read input or print anything. Complete the function help_classmate() which takes the array arr[] and size of array N as input parameters and returns a list of numbers. If a student is unable to find anyone then output is -1.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 ≤ N ≤ 5*10^5

		// TC: O(n²) SC: O(n)
			class Solution{
				public:
				vector<int> help_classmate(vector<int> arr, int n) {
					vector<int> ans(n, -1);
					for(int i=0; i<n; i++){
						for(int j=i+1; j<n; j++){
							if(arr[i] > arr[j]){
								ans[i] = arr[j];
								break;
							}
						}
					}
					return ans;
				} 
			};

		// Optimized:
			class Solution{
				public:
				vector<int> help_classmate(vector<int> arr, int n) {
					vector<int> ans(n, -1);
					stack<int> st;
					
					for(int i=n-1; i>=0; i--){
						while(!st.empty() && st.top() >= arr[i])
							st.pop();
						
						if(!st.empty())
							ans[i] = st.top();
						
						st.push(arr[i]);
					}
					return ans;
				} 
			};
	
	815) Divisor Game:
		Problem Statement:
			Alice and Bob take turns playing a game, with Alice starting first.
			Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:
			Choosing any x with 0 < x < n  and n % x == 0.
			Replacing the number n on the chalkboard with n - x.
			Also, if a player cannot make a move, they lose the game.
			Return true if and only if Alice wins the game, assuming both players play optimally.
			Example 1:
				Input:
				n = 2
				Output: True
				Explanation: Alice chooses 1, and Bob has no more moves.
		
			Example 2:
				Input:
				n = 3
				Output: False
				Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.
			

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function divisorGame() which takes an integer n as a parameter and returns true if Alice wins the game.

			Expected Time Complexity: O(1)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ n ≤ 10^3

		class Solution {
			public:
			bool divisorGame(int n) {
				if(n&1)
					return 0;
				return 1;
			}
		};

	#GFG Weekly-153:
		816) Character Matrix Conundrum:
			Problem Statement:
				You've been provided with a matrix mat comprising lowercase English letters, arranged in n
				rows and m columns. Your objective is to determine whether it's feasible to choose four
				distinct columns from left to right such that the first column contains 'p', the second contains
				'I', the third contains 'a', and the fourth contains 'y'. If all these conditions can be met, the
				function should return 1; otherwise, it should return 0.
				Example 1:
					Input:
					n = 1
					m = 4
					mat = [ ['p, l, a, y] ]
					Output:
					1
					Explanation:
					Choose the columns numbered 1,2,3,4 and they satisfy the required condition as
					they have the characters 'p' in column 1, 'I' in column 2, 'a' in column 3, 'y' in
					column 4.
				Example 2:
					Input:
					n = 3
					m = 3
					mat = [['a', 'b' , 'c'], ['d', 'e', 'f'], ['g', 'h, 'i']]
					Output:
					0
					Explanation:
					It is not possible to choose 4 distinct columns.
					Your Task:
					You don't need to read input or print anything. Your task is to complete the function
					matrixConundrum(), which takes 2 integers n and m and a string array mat as input and
					returns a boolean value as an answer to the question.

				Constraints:
					1 <= n, m <= 1000

			class Solution {
				public:
				bool matrixConundrum(int n, int m, vector<string> &mat) {
					if(m < 4)
						return 0;
					
					char chrs[] = {'p','l','a','y'};
					int i =0;
					
					for(int col=0; col<m; col++){
						char curChar = chrs[i];
						for(int row=0; row<n; row++){
							if(mat[row][col] == curChar){
								i++;
								break;
							}
						}
					}

					if(i < 4)
						return 0;
					return 1;
				}
			};
		
		817) Maximum Doublet XOR:
			Problem Statement:
				You are given the head of a LinkedList containing an even number of nodes, your task is to
				find the maximum doublet XOR of the LinkedList.
				NOTE: If n is the length of the LinkedList, then doublet of ith node is (n-1-i)th
				node. For example, if n = 6, the 0th node is a doublet of the 5th node.
				Example 1:
				Input:
				10 20 12 4
				LinkedList: 10 -> 20 -> 12 -> 4
				Output:
				24
				Explanation:
				0th and 3rd node are doublet and their XOR is = 10 XOR 4 => 14
				1st and 2nd node are doublet and their XOR is = 20 XOR 12 => 24
				Hence, the maximum possible doublet XOR is 24.
				Example 2:
					Input: 3 2 1 4 12 4
					LinkedList: 3 -> 2 > 1 -> 4 -> 12 -> 4
					Output:
					14
					Explanation:
					0th and 5th node are doublet and their XOR is = 3 XOR 4 => 7
					1st and 4th node are doublet and their XOR is = 2 XOR 12 => 14
					2nd and 3rd node are doublet and their XOR is = 1 XOR 4 => 5
					Hence, the maximum possible doublet XOR is 14.
					Your Task:
					The task is to complete the function maximumDoubletXOR) which takes the head of the LinkedList as
					input and return the maximum doublet XOR of the LinkedList.
					Expected Time Complexity: O(N).
					Expected Auxiliary Space: 0(1).
				Constraints:
					2 <= Number of Nodes (always even) <= 10^5
					1 <= Value of Nodes <= 10^5
		
			/*
				Definition for singly Link List Node
				struct Node {
				int data;
				Node* next;
				Node(int x) {  data = x;  next = NULL; }
				};

				You can also use the following for printing the link list.
				printList(Node* node);
			*/

			class Solution {
				public:
				int getLength(Node* temp){
					int l=0;
					while(temp){
						l++;
						temp = temp -> next;
					}
					return l;
				}
				
				Node* reverseLL(Node* temp){
					Node* cur = temp;
					Node* prev = NULL;
					
					while(cur){
						Node* hold = cur -> next;
						
						cur -> next = prev;
						prev = cur;
						
						cur = hold;
					}
					return prev;
				}
				
				int maximumDoubletXOR(struct Node* head) {
					int mxAns = 0;
					
					// LL has even length ie. given in question so need to reverse the second half of LL & take XOR ops of first mid element
					// increment both, start & mid
					int len = getLength(head);
					len /= 2;
					Node* mid = head;
					
					while(len--)
						mid = mid -> next;
					
					mid = reverseLL(mid);
					
					while(mid){
						int value = (head -> data ^ mid -> data);
						mxAns = max(mxAns, value);
						
						head = head -> next;
						mid = mid -> next;
					}
					return mxAns;
				}
			};

	#CN WeeklyContest-125:
		818) Even Sum:
			Problem statement
				You are given an array 'A' of length 'N'.
				Your task is to modify the array so that the sum of its elements is even.
				You can achieve this by removing any number of elements from the array, including none.
				What is the maximum even sum you can achieve after performing these operations?

				Example:
				‘N’ = 4
				‘A’ = [2, 4, 7, 8]
				We can remove 7 to make the sum of the array even.
				Hence the maximum even sum is 14.

				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					1 <= 'A[i]' <= 10^9
					Time Limit: 1 sec
				Sample Input 1:
					2
					2
					15 6 
					5
					12 1 7 9 17 
					Sample Output 1:
					6
					46
					Explanation of sample input 1:
					For test case 1:
					You can remove 15 to achieve the maximum even sum of 6.

					For test case 2:
					You can remove 1 to achieve the maximum even sum of 46.
					Sample Input 2:
					3
					2
					15 5 
					2
					4 17 
					6
					12 2 8 17 17 19 
					Sample Output 2:
					20
					4
					58

			int solve(vector<int> &a) {
				int s = accumulate(a.begin(), a.end(), 0);
				if(s % 2 == 0)
					return s;

				vector<int> temp;
				for(int i: a)
					if(i&1)
						temp.push_back(i);
					
				int minV = *min_element(temp.begin(), temp.end());
				return s - minV;            
			}

			//or
			int solve(vector<int> &a) {
				int s = accumulate(a.begin(), a.end(), 0);
				if(s % 2 == 0)
					return s;

				int minOdd = INT_MAX;
				for(int i: a)
					if(i&1)
						minOdd = min(minOdd, i);

				return s - minOdd;
			}
	
		819) Robot Moves:
			Problem statement
				There is a Robot named ‘Travis’ positioned at coordinates ‘(X, Y)’. You are given a string ‘S’ of length ‘N’ representing the robot’s movements: ‘L’ for Left, ‘R’ for Right, ‘U’ for Up, and ‘D’ for Down.
				You can either delete any character from the string or insert any character into it with each move. You have to determine the minimum number of moves required to ensure that ‘Travis’ finishes its journey at the same starting coordinates ‘(X, Y)’.
				Your task is to tell the minimum number of moves required to ensure that the Robot finishes its journey at the same starting coordinates and return it.
				Example:
				‘X’ = 1
				‘Y’ = 2
				‘N’ = 4
				‘S’ = “DLLR”

				One of the optimal ways is to remove the ‘0th’ character of the string and insert ‘R’ at the end of the string. Now, the string becomes “LLRR” and requires ‘2’ moves.
				The movement of the Robot following the given directions “LLRR” will be:
				(1, 2) -> (0, 2) -> (-1, 2) -> (0, 2) -> (1, 2).
				Constraints:
					1 <= 'T' <= 10
					0 <= ‘X’, ‘Y’ <= 10^5
					1 <= 'N' <= 10^5
					‘S[i]’ belongs to the set {‘L’, ‘R’, ‘U’, ‘D’}
					Time Limit: 1 sec 
				Sample Input 1:
				2
				0 0
				5   
				UUDDL
				3 5
				5
				LLLRL
				Sample Output 1:
				1
				3
				Explanation of sample input 1:
				For test case 1:
				Here, you can remove the last character of the string and it will change to “UUDD”.
				The movements of the Robot will be: (0, 0) -> (0, 1) -> (0, 2) -> (0, 1) -> (0, 0).
				For test case 2:
				One of the possible ways is to remove the first two characters of the string and insert a character ‘R’ at the end of the string. It will take ‘3’ moves.
				The string will change to: “LRLR”.
				The movements of the Robot will be: (3, 5) -> (2, 5) -> (3, 5) -> (2, 5) -> (3, 5).
				Sample Input 2:
				2
				1 5
				2
				LR
				0 0
				8
				RRRRUUUU
				Sample Output 2:
				0
				8

			int robotMoves (int x, int y, int n, string &s) {
				int Ucnt, Dcnt, Lcnt, Rcnt;
				Ucnt = Dcnt = Lcnt = Rcnt = 0;
				
				for(char ch : s)
					if(ch == 'U')
						Ucnt++;
					else if(ch == 'D')
						Dcnt++;
					else if(ch == 'L')
						Lcnt++;
					else
						Rcnt++;
					
				return abs(Ucnt-Dcnt) + abs(Rcnt-Lcnt);
			}
	
		820) fizziness Evaluation:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’. The fizziness ‘F(i, j, k)’ is given by ‘((A[i] ^ A[j] ^ A[k]) | (A[i] & A[j] & A[k]))’. Your task is to evaluate the given expression:
				∑∑∑ F(i, j, k), where ‘i’ is ranging from ‘0’ to ‘N - 3’, ‘j’ is ranging from ‘i + 1’ to ‘N - 2’ and ‘k’ is ranging from ‘j + 1’ to ‘N - 1’.
				Here, ‘^’ denotes the bitwise ‘XOR’ operation, ‘|’ denotes the bitwise ‘OR’ operation, and ‘&’ denotes the bitwise ‘AND’ operation.
				Your task is to evaluate the given expression and return the answer modulo ‘10^9 + 7’.
				Example:
				‘N’ = 4
				‘A’ = [1, 5, 2, 7]

				For ‘i’ = 0, ‘j’ = 1, and ‘k’ = 2:
				‘F(0, 1, 2)’ = ‘((1 ^ 5 ^ 2) | (1 & 5 & 2))’ which is equal to ‘6’.

				For ‘i’ = 0, ‘j’ = 1, and ‘k’ = 3:
				‘F(0, 1, 3)’ = ‘((1 ^ 5 ^ 7) | (1 & 5 & 7))’ which is equal to ‘3’.

				For ‘i’ = 0, ‘j’ = 2 and ‘k’ = 3:
				‘F(0, 2, 3)’ = ‘((1 ^ 2 ^ 7) | (1 & 2 & 7))’ which is equal to ‘4’.

				For ‘i’ = 1, ‘j’ = 2, and ‘k’ = 3:
				‘F(1, 2, 3)’ = ‘((5 ^ 2 ^ 7) | (5 & 2 & 7))’ which is equal to ‘0’.

				The sum of ‘fizziness’ between all these triplets is equal to ‘13’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					0  <= A[i] <= 10^9
					Time Limit: 1 sec 
				Sample Input 1:
					2
					4
					1 0 11 9
					3
					2 2 2
					Sample output 1:
					23
					2
					Explanation of sample input 1:
					For test case 1:

					For ‘i’ = 0, ‘j’ = 1, and ‘k’ = 2:
					‘F(0, 1, 2)’ = ‘((1 ^ 0 ^ 11) | (1 & 0 & 11))’ which is equal to ‘10’.

					For ‘i’ = 0, ‘j’ = 1, and ‘k’ = 3:
					‘F(0, 1, 3)’ = ‘((1 ^ 0 ^ 9) | (1 & 0 & 9))’ which is equal to ‘8’.

					For ‘i’ = 0, ‘j’ = 2 and ‘k’ = 3:
					‘F(0, 2, 3)’ = ‘((1 ^ 11 ^ 9) | (1 & 11 & 9))’ which is equal to ‘3’.

					For ‘i’ = 1, ‘j’ = 2, and ‘k’ = 3:
					‘F(1, 2, 3)’ = ‘((0 ^ 11 ^ 9) | (0 & 11 & 9))’ which is equal to ‘2’.

					The sum of ‘fizziness’ between all these triplets is equal to ‘23’.

					For test case 2:
					There is only one triplet ‘(0, 1, 2)’ whose ‘fizziness’ is equal to ‘2’.
					Sample Input 2:
					2
					5
					1 4 10 0 3
					3
					1 5 2
					Sample Output 2:
					90
					6

			// Not Optimized:
				long long fizzinessEvaluation (int n, vector <int> &a) {
					int mod = 1e9+7;
					long long sum = 0;

					for(int i=0; i<n-2; i++) {
						for(int j=i+1; j<n-1; j++) {
							for(int k=j+1; k<n; k++) {
								int val = (a[i] ^ a[j] ^ a[k]) | (a[i] & a[j] & a[k]);
								sum = (sum + val) % mod;
							}
						}
					}
					return sum % mod;
				}

			// Optimized:
				❌Pending

	821)	K-th Smallest Prime Fraction:
		Problem Statement:
			You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.
			For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].
			Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].
			
			Example 1:
				Input: arr = [1,2,3,5], k = 3
				Output: [2,5]
				Explanation: The fractions to be considered in sorted order are:
				1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
				The third fraction is 2/5.
			Example 2:
				Input: arr = [1,7], k = 1
				Output: [1,7]
			
			Constraints:
				2 <= arr.length <= 1000
				1 <= arr[i] <= 3 * 10^4
				arr[0] == 1
				arr[i] is a prime number for i > 0.
				All the numbers of arr are unique and sorted in strictly increasing order.
				1 <= k <= arr.length * (arr.length - 1) / 2
			
			Follow up: Can you solve the problem with better than O(n2) complexity?

		// Not Optimized:
			class Solution {
				public:
				bool static sortingByValues(pair<string, float> &a1, pair<string, float> &b1){
					if(a1.second < b1.second)
						return 1;
					return 0;
				}

				vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
					if(arr.size() == 2)
						return arr;

					map<string, float> mapper;
					// fractions extracted
					for(int i=0; i < arr.size() - 1; i++){
						for(int j= i+1; j < arr.size(); j++){
							string s = to_string(arr[i]) + "/" + to_string(arr[j]);
							float a = arr[i];
							float b = arr[j];

							mapper[s] = a / b;
						}
					}

					vector<pair<string, float>> holder;
					for(auto i: mapper)
						holder.push_back(i);

					// sort the fractions based on values in ascending
					sort(holder.begin(), holder.end(), sortingByValues);

					// for(auto i: holder)
					//     cout<<i.first << "\t"<< i.second <<"\n";
					
					string res = holder[k-1].first;
					string sub1 = res.substr(0,res.find('/'));
					string sub2 = res.substr(res.find('/')+1);

					return {stoi(sub1), stoi(sub2)};
				}
			};

	822) Juggler Sequence:
		Problem Statement:
			Juggler Sequence is a series of integers in which the first term starts with a positive integer number a and the remaining terms are generated from the immediate previous term using the below recurrence relation:
			Juggler Formula
			Given a number n, find the Juggler Sequence for this number as the first term of the sequence until it becomes 1.
			Example 1:
			Input: n = 9
			Output: 9 27 140 11 36 6 2 1
			Explaination: We start with 9 and use 
			above formula to get next terms.
			
			Example 2:
			Input: n = 6
			Output: 6 2 1
			Explaination: 
			[6^1/2] = 2. 
			[2^1/2] = 1.
			
			Your Task:
				You do not need to read input or print anything. Your Task is to complete the function jugglerSequence() which takes n as the input parameter and returns a list of integers denoting the generated sequence.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n ≤ 100

		// Not Optimized:
			class Solution {
				public:
				vector<int> jugglerSequence(int n) {
					vector<int> ans = {n};
					while(n != 1){
						if(n&1){
							int val = n * n * n;
							n = sqrt(val);
							ans.push_back(n);
						}else{
							n = sqrt(n);
							ans.push_back(n);
						}
					}
					return ans;
				}
			};

		// Optimized:
			class Solution {
				public:
				vector<int> jugglerSequence(int n) {
					vector<int> ans {n};
					while(n != 1){
						n = (n&1) ? pow(n, 1.5) : pow(n, 0.5);
						ans.push_back(n);
					}
					return ans;
				}
			};
	
	#AtCoder BeginnerContest-353
		823) A - Buildings:
			https://atcoder.jp/contests/abc353/tasks/abc353_a
			Problem Statement
				There are N buildings aligned in a row. The i-th building from the left has a height of Hi.
				Determine if there is a building taller than the first one from the left. If such a building exists, find the position of the leftmost such building from the left.

				Constraints
					1≤ N ≤100
					1≤ Hi ≤100
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:
				N
				H1 H2 … Hn
				Output
				If no building is taller than the first one from the left, print -1.
				If such a building exists, print the position (index) of the leftmost such building from the left.

				Sample Input 1
					4
					3 2 5 2
				Sample Output 1
					3
				The building taller than the first one from the left is the third one from the left.
				Sample Input 2
				3
				4 3 2
				Sample Output 2
				-1
				No building is taller than the first one from the left.

				Sample Input 3
				7
				10 5 10 2 10 13 15
				Sample Output 3
				6
				The buildings taller than the first one from the left are the sixth and seventh ones. Among them, the leftmost is the sixth one.
			
			// Code:
				#include <iostream>
				#include<vector>
				using namespace std;

				int main() {
					int size;
					cin>>size;
					
					vector<int> holder(size);
					
					for(int i=0; i<size; i++)
						cin>>holder[i];
						
					int cnt=1, found = 1;
					
					for(int i =1; i<size; i++){
						cnt++;
						if(holder[i] > holder[0]){
							found = 0;
							std::cout << cnt;
							break;
						}
					}
					
					if(found)
						std::cout << -1;
						
					return 0;
				}
			
		824) B - AtCoder Amusement Park:
			https://atcoder.jp/contests/abc353/tasks/abc353_b
			Problem Statement
				The AtCoder amusement park has an attraction that can accommodate 
				K people. Now, there are N groups lined up in the queue for this attraction.

				The i-th group from the front 
				(1 ≤ i ≤ N) consists of Ai people. For all i ( 1 ≤ i ≤ N), it holds that Ai ≤ K.

				Takahashi, as a staff member of this attraction, will guide the groups in the queue according to the following procedure.
				Initially, no one has been guided to the attraction, and there are K empty seats.
				1. If there are no groups in the queue, start the attraction and end the guidance.
				2. Compare the number of empty seats in the attraction with the number of people in the group at the front of the queue, and do one of the following:
					● If the number of empty seats is less than the number of people in the group at the front, start the attraction. Then, the number of empty seats becomes K again.
					● Otherwise, guide the entire group at the front of the queue to the attraction. The front group is removed from the queue, and the number of empty seats decreases by the number of people in the group. Go back to step 1.
				Here, no additional groups will line up after the guidance has started. Under these conditions, it can be shown that this procedure will end in a finite number of steps.
				Determine how many times the attraction will be started throughout the guidance.

				Constraints
					1 ≤ N ≤ 100
					1 ≤ K ≤ 100
					1 ≤ Ai ≤ K (1 ≤ i ≤ N)
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:

				N K
				A1 A2 … AN
				
				Output
				Print the answer.

				Sample Input 1
				7 6
				2 5 1 4 1 2 3
				Sample Output 1
				4
				Initially, the seven groups are lined up as follows:
				Part of Takahashi's guidance is shown in the following figure:
				Initially, the group at the front has 
				2 people, and there are 
				6 empty seats. Thus, he guides the front group to the attraction, leaving 
				4 empty seats.
				Next, the group at the front has 
				5 people, which is more than the 
				4 empty seats, so the attraction is started.
				After the attraction is started, there are 
				6 empty seats again, so the front group is guided to the attraction, leaving 
				1 empty seat.
				Next, the group at the front has 
				1 person, so they are guided to the attraction, leaving 
				0 empty seats.
				In total, he starts the attraction four times before the guidance is completed. Therefore, print 4.



				Sample Input 2
				7 10
				1 10 1 10 1 10 1
				Sample Output 2
				7
				Sample Input 3
				15 100
				73 8 55 26 97 48 37 47 35 55 5 17 62 2 60
				Sample Output 3
				8

			// Code:
				#include <iostream>
				#include<vector>
				using namespace std;

				int main() {
					int size;
					cin>>size;
					
					int k;
					cin>>k;

					vector<int> holder(size);
					
					for(int i=0; i<size; i++)
						cin>>holder[i];
						
					int ans = 0, curSum=0;
					for(int i =0; i<holder.size(); ){
						if((curSum+holder[i]) <= k) {
							curSum += holder[i];
							i++;
						}
						else{
							curSum =0;
							ans++;
						}
					}
					
					if(curSum != 0)
						ans++;
					
					std::cout << ans << std::endl;
					return 0;
				}

		825) C - Sigma Problem:
			https://atcoder.jp/contests/abc353/tasks/abc353_c
			Problem Statement
				For positive integers x and y, define f(x,y) as the remainder of (x+y) divided by 10^8 You are given a sequence of positive integers 
				A=(A1,…,AN) of length N. Find the value of the following expression:
				Constraints
				2 ≤ N ≤ 3×10^5
				1≤ Ai < 10^8
				All input values are integers.

				Input
				The input is given from Standard Input in the following format:
				N 
				A1 ... AN
				​
				
				Output
				Print the answer.
				Sample Input 1
				3
				3 50000001 50000002
				Sample Output 1
				100000012
				f(A1,A2​)=50000004
				f(A1,A3)=50000005
				f(A2,A3)=3
				Thus, the answer is  f(A1,A2)+f(A1,A3)+f(A2,A3)=100000012.
				Note that you are not asked to compute the remainder of the sum divided by 10^8.
				Sample Input 2
				5
				1 3 99999999 99999994 1000000
				Sample Output 2
				303999988

			// Not Optimized:
				#include <iostream>
				#include<vector>
				using namespace std;

				inline long long f(long a, long b){
					int md = 1e8;
					return (a+b) % md;
				}

				int main() {
					int N;
					cin>>N;
					
					vector<int> hold(N);
					
					long long sum=0;
					
					for(int i=0; i<N; i++)
						cin >> hold[i];
						
					for(int i=0; i<N; i++)
						for(int j = i+1; j<N; j++)
							sum += f(hold[i], hold[j]);
						
					std::cout << sum << std::endl;
					return 0;
				}
			
			// Optimised:
				❌Pending

	#LeetCode BiweeklyContest-130:
		826) Check if Grid Satisfies Conditions:
			Problem Statement:
				You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is:
				Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).
				Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).
				Return true if all the cells satisfy these conditions, otherwise, return false.

				Example 1:
					Input: grid = [[1,0,2],[1,0,2]]
					Output: true
					Explanation:
					All the cells in the grid satisfy the conditions.

				Example 2:
					Input: grid = [[1,1,1],[0,0,0]]
					Output: false
					Explanation:
					All cells in the first row are equal.

				Example 3:
					Input: grid = [[1],[2],[3]]
					Output: false
					Explanation:
					Cells in the first column have different values.
					
				Constraints:
					1 <= n, m <= 10
					0 <= grid[i][j] <= 9

			class Solution {
				public:
				bool satisfiesConditions(vector<vector<int>>& grid) {
					int r = grid.size(), c = grid[0].size();
					if(r == 1){
						for(int i=0; i<c-1; i++)
							if(grid[0][i] == grid[0][i+1])
								return 0;
					}
					
					if(c==1){
						for(int i=0; i<r-1; i++)
							if(grid[i][0] != grid[i+1][0])
								return 0;
					}
					
					for(int i=0; i<r-1; i++){
						// for each row
						for(int j=0; j < c-1; j++)
							if(grid[i][j] == grid[i][j+1])
								return 0;            
					}
					
					for(int i=0; i<c; i++){
						for(int j=0; j<r-1; j++){
							if(grid[j][i] != grid[j+1][i])
								return 0;
						}
					}		
					return 1;
				}
			};
	
	827) Mirror String:
		Problem statement
			You are given a string S containing only uppercase English characters. Find whether S is the same as its reflection in the mirror.
			For Example, S = “AMAMA” is the same as its reflection in the mirror.
			Constraints
				1 <= T <=10
				1 <= Length(S) <= 10 ^ 5
				Where ‘T’ is the number of test cases, ‘S’ is the string given in input.
				Time limit: 1sec.
			Sample Input 1:
				1
				ITATI
			Sample Output 1:
				YES
			Explanation of sample input 1:
			String “ITATI” is the same as its reflection in the mirror.
			Sample Input 2:
			2
			MMMM
			MZM
			Sample Output 2:
			YES
			NO

		#include <bits/stdc++.h> 
		bool isReflectionEqual(string &s) {
			for(char ch: s)
				if(ch != 'A' && ch != 'H' && ch != 'I' && ch != 'M' && 
					ch != 'O' && ch != 'T' && ch != 'U' && ch != 'V' && 
					ch != 'W' && ch != 'X' && ch != 'Y')
					return 0;

			int i=0, j = s.size()-1;
			while(i < j)
				if(s[i++] != s[j--])
					return 0;
				
			return 1;	
		}
	
	828) Minimum steps to destination: ❌Pending
		Problem Statement:
			Given an infinite number line. You start at 0 and can go either to the left or to the right. The condition is that in the ith move, you must take i steps. Given a destination d, find the minimum number of steps required to reach that destination.
			Example 1:
			Input: d = 2
			Output: 3
			Explaination: The steps takn are +1, -2 and +3.

			Example 2:
			Input: d = 10
			Output: 4
			Explaination: The steps are +1, +2, +3 and +4.

			Your Task:
				You do not need to read input or print anything. Your task is to complete the function minSteps() which takes the value d as input parameter and returns the minimum number of steps required to reach the destination d from 0.

			Expected Time Complexity: O(d)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ d ≤ 10000

		class Solution {
			public:
			int minSteps(int d) {
				int steps=0, total=0;
				
				while(total < d)
					total += ++steps;
				
				while((total - d) % 2 != 0)
					total += ++steps;
				
				return steps;
			}
		};

	829) Largest Local Values in a Matrix:
		Problem Statement:
			You are given an n x n integer matrix grid.
			Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:
			maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.
			In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.
			Return the generated matrix.
			
			Example 1:
				Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
				Output: [[9,9],[8,6]]
				Explanation: The diagram above shows the original matrix and the generated matrix.
				Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.
			Example 2:
				Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
				Output: [[2,2,2],[2,2,2],[2,2,2]]
				Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.
			
			Constraints:
				n == grid.length == grid[i].length
				3 <= n <= 100
				1 <= grid[i][j] <= 100

		class Solution {
			public:
			vector<vector<int>> largestLocal(vector<vector<int>>& grid) {
				int n = grid.size();
				vector<vector<int>> ans(n-2, vector<int>(n-2, 0));

				for(int i=0; i<(n-2); i++){
					for(int j=0; j<(n-2); j++){
						int times1 = 3;
						int times2 = 3;

						int mxValue =0;

						for(int row = i; row<n && times1--; row++){
							times2 = 3;
							for(int col = j; col < n && times2--; col++){
								mxValue = max(mxValue, grid[row][col]);
							}
						}
						ans[i][j] = mxValue;
					}
				}

				/* // or
					for(int i=0; i<(n-2); i++){
						for(int j=0; j<(n-2); j++){
							int mxValue =0;

							for(int row = i; row <= (i+2); row++){
								for(int col = j; col <= (j+2); col++){
									mxValue = max(mxValue, grid[row][col]);
								}
							}
							ans[i][j] = mxValue;
						}
					}

				*/

				return ans;
			}
		};
	
	830) Check if the door is open or closed:
		Problem statement
			There are ‘N’ doors and ‘N’ people in a house. Each person and door has a unique ID ranging from 1 to ‘N’. A person can change the status of the door i.e, if the door is open then a person can close the door and vice versa. Initially, all the doors are closed and each person wants to change the status of all doors whose ID is a multiple of the ID of the person. You need to find out the final status of all the doors.
			The answer should be given in a form of a binary string where ‘0’ represents the closed door and ‘1’ represents the open door. For example, the status “close open close” will form a binary string “010”.
			Constraints:
				1 <= T <= 100
				1 <= N <= 10^4  
				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				4
				Sample Output 1:
				10
				1001    
				Explanation for sample input 1:
				Test case 1:
				Initially, all the doors are closed -> 00
				The first person has an ID 1 so it will change the status of doors 1(1 * 1) and 2(1 * 2) -> 11
				The second person has an ID 2 so it will change the status of door 2 (2 * 1)-> 10

				Test case 2:
				Initially, all the doors are closed -> 0000
				The first person has an ID 1 so it will change the status of door 1, 2, 3 and 4 -> 1111
				The second person has an ID 2 so it will change the status of door  2 and 4 -> 1010
				The third person has an ID 3 so it will change the status of door 3-> 1000
				The fourth person has an ID 4 so it will change the status of door 4 -> 1001
				Sample Input 2:
				2
				6
				8
				Sample Output 2:
				100100
				10010000

		#include <bits/stdc++.h> 
		string doorStatus(int n) {
			string s = string(n, '0');
			int i=1;
			while(i <= n){

				for(int z=i-1; z < s.size(); z += i)
					s[z] = (s[z] == '0') ? '1' : '0';

				i++;
			}
			return s;
		}

	831) Chess Tournament:
		Problem statement:
			You played a chess tournament consisting of 'N' rounds. You know each round's
			result, which can be a Win, Draw, or Loss. Your score is updated based on the
			result of each round.
			A. Loss means 1 will be subtracted from your score.
			B. Draw means there will be no change in your score.
			C. Win. If you are on a winning streak means you won your previous round, then
			add 2 to the score; otherwise, add 1.
			Your task is to find your final score based on the results.
			Example :
			'N' = 4. 'result' = "WWDL"
			The tournament consisted of 4 rounds. Here are the results of each round.
			1. Won, 2. Won, 3. Draw, and 4. Loss
			After round 1 score will be 1, as we won, and there is no winning streak. After
			round 2 score will be 3 because we won the current round, and there is a streak
			going on, so add 2. After round 3, there is no change, and after round 4, the
			score will be 2.
			Hence, the answer is 2.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5
				It's guaranteed that sum of N over all cases does not exceed 1015.
				Time limit: 1 sec
			Sample Input 1 :
				2
				5
				DWWLW
				WDDWW
				Sample Output 1
				3
				4:
				Explanation For Sample Input 1:
				For test case 1:
				Here are our scores after every round.
				R1 - 0. R2 - 1, R3 - 3. R4 - 2. R5 - 3.
				Hence, the answer is 3.
				For test case 2:
				Scores after every round.
				R1 - 1. R2 - 1. R3 - 1. R4 - 2. R5 - 4
				Hence, the answer is 4.
				Sample Input 2 :
				2
				3
				LLW
				4
				DWDW
				Sample Output 2 :
				-1
				2

		int findScore(string &result) {
			int streak = 0, ans = 0;

			for(char ch: result){
				if(ch == 'W' && streak){
					ans += 2;
				}else if(ch == 'W'){
					ans++;
					streak++;
				}else if(ch == 'L'){
					ans--;
					streak=0;
				}else{
					streak=0;
				}
			}
			return ans;
		}
	
	#AtCoder Regular Contest-177
		832) A - Exchange:
			https://atcoder.jp/contests/arc177/tasks/arc177_a
			Problem Statement
				In Japan, there are six types of coins in circulation: 1 yen, 5 yen, 10 yen, 50 yen, 100 yen, and 500 yen. Answer the following question regarding these coins.
				Mr. AtCoder's wallet contains A 1-yen coins, B 5-yen coins, C 10-yen coins, D 50-yen coins, E 100-yen coins, and F 500-yen coins.
				He is planning to shop at 
				N stores in sequence. Specifically, at the i-th store (1 ≤ i ≤ N), he plans to buy one item that costs Xi yen (including tax).
				Giving and receiving change takes time, so he wants to choose his coins so that he can pay the exact amount at each store. Determine if this is possible.

				Constraints
					0 ≤ A ≤ 200
					0 ≤ B ≤ 200
					0 ≤ C ≤ 200
					0 ≤ D ≤ 200
					0 ≤ E ≤ 200
					0 ≤ F ≤ 200
					1 ≤ N ≤ 10
					1 ≤ Xi ≤ 10000 (1 ≤ i ≤ N)
					All input values are integers.
				Input
					The input is given from Standard Input in the following format:
					A B C D E F
					N
					X1 X2 ⋯ Xn			
				Output
					Print Yes if the objective is achievable, and No otherwise.
				Sample Input 1
				0 0 6 3 4 1
				3
				700 250 160
				Sample Output 1
				Yes
				For example, he can make exact payments at all three stores as follows:

				At the first store: Use two 
					100-yen coins and one 
					500-yen coin.
					At the second store: Use five 
					10-yen coins and two 
					100-yen coins.
					At the third store: Use one 
					10-yen coin and three 
					50-yen coins.
				Sample Input 2
				0 0 0 2 4 0
				3
				100 200 300
				Sample Output 2
				No
				The total amount in the wallet is 
				500 yen, but a total payment of 
				100+200+300=600 yen is required, so it is impossible to purchase all the items.

				Sample Input 3
				0 0 0 0 8 8
				1
				250
				Sample Output 3
				No
				There are no 50-yen or smaller coins in the wallet, so it is impossible to pay exactly 
				250 yen.

				Sample Input 4
				20 5 9 7 10 6
				5
				177 177 177 177 177
				Sample Output 4
				Yes
				Sample Input 5
				17 5 9 7 10 6
				5
				177 177 177 177 177
				Sample Output 5
				No

			#include <iostream>
			#include<vector>
			using namespace std;

			int main() {
				int A,B,C,D,E,F;
				cin>>A>>B>>C>>D>>E>>F;
				
				// A 1
				// B 5
				// C 10
				// D 50
				// E 100
				// F 500
				
				int N;
				cin>>N;
				vector<int> v(N);

				for(int i=0; i<N; i++)
					cin>>v[i];
				
				int flag = 0;
				for(int i=0; i<N; i++){
					int curVal = v[i];
					
					while(curVal){
						if(curVal >= 500 && F){
							curVal -= 500;
							F--;
						}else if(curVal >= 100 && E){
							curVal -= 100;
							E--;
						}else if(curVal >= 50 && D){
							curVal -= 50;
							D--;
						}else if(curVal >= 10 && C){
							curVal -= 10;
							C--;
						}else if(curVal >= 5 && B){
							curVal -= 5;
							B--;
						}else if(curVal >= 1 && A){
							curVal -= 1;
							A--;
						}else{
							break;
						}
					}
					
					if(curVal){
						flag = 1;
						break;
					}
				}
				
				if(flag){
					cout<<"No";
				}else{
					std::cout << "Yes" << std::endl;
				}
				return 0;
			}
		
	#GFG Weekly-154:
		833) Check Anagram Existence:
			Problem Statement:
				jlkjlk
			
			class Solution {
				public:
				string doesExists(string s) {
					
					int n = s.size();
					for(int i=0; i<n-1; i++)
						if(s[i] != s[i+1])
							return "YES";

					return "NO";
				}
			};
		
		834) Minimise the Distance:
			Problem Statement:
				jklj

			// Not Optimized:
				class Solution {
					public:
					int minimumDis(int N, vector<int> X) {
						int HouseIndex = 0, ActualSum = INT_MAX;
						int minValue = INT_MAX;
						
						for(int i=0; i<N; i++){
							int CurSum =0;
							for(int j=0; j<N; j++){
								if(i == j)
									continue;
								CurSum += abs(X[i] - X[j]);
							}
							// cout<<"House :" << X[i] << "\t" << CurSum<<"\n";
							if(CurSum <= ActualSum){
								if(CurSum < ActualSum){
									minValue = X[i];
								}else{
									if(minValue > X[i]){
										minValue = X[i];
									}
								}
								ActualSum = CurSum;
							}
						}
						return minValue;
					}
				};

			// Optimized:
				❌Pending		
		
	#LeetCode WeeklyContest-397:
		835)	Permutation Difference between Two Strings:
			Problem Statement:
				You are given two strings s and t such that every character occurs at most once in s and t is a permutation of s.
				The permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t.
				Return the permutation difference between s and t.
			
				Example 1:
					Input: s = "abc", t = "bac"
					Output: 2
					Explanation:
					For s = "abc" and t = "bac", the permutation difference of s and t is equal to the sum of:
					The absolute difference between the index of the occurrence of "a" in s and the index of the occurrence of "a" in t.
					The absolute difference between the index of the occurrence of "b" in s and the index of the occurrence of "b" in t.
					The absolute difference between the index of the occurrence of "c" in s and the index of the occurrence of "c" in t.
					That is, the permutation difference between s and t is equal to |0 - 1| + |2 - 2| + |1 - 0| = 2.
				Example 2:
					Input: s = "abcde", t = "edbac"
					Output: 12
					Explanation: The permutation difference between s and t is equal to |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.
				
				Constraints:
					1 <= s.length <= 26
					Each character occurs at most once in s.
					t is a permutation of s.
					s consists only of lowercase English letters.
		
			class Solution {
				public:
				int findPermutationDifference(string s, string t) {
					int total=0, curIndex=0;
					for(char ch: s){
						int val = t.find(ch);
						total += abs(curIndex - val);
						curIndex++;
					}
					return total;
				}
			};

		836) Taking Maximum Energy From the Mystic Dungeon:
			Problem Statement:
				In a mystic dungeon, n magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you.
				You have been cursed in such a way that after absorbing energy from magician i, you will be instantly transported to magician (i + k). This process will be repeated until you reach the magician where (i + k) does not exist.
				In other words, you will choose a starting point and then teleport with k jumps until you reach the end of the magicians' sequence, absorbing all the energy during the journey.
				You are given an array energy and an integer k. Return the maximum possible energy you can gain.
				Example 1:
					Input: energy = [5,2,-10,-5,1], k = 3
					Output: 3
					Explanation: We can gain a total energy of 3 by starting from magician 1 absorbing 2 + 1 = 3.
				Example 2:
					Input: energy = [-2,-3,-1], k = 2
					Output: -1
					Explanation: We can gain a total energy of -1 by starting from magician 2.
				Constraints:
					1 <= energy.length <= 10^5
					-1000 <= energy[i] <= 1000
					1 <= k <= energy.length - 1

			// Not Optimized:
				class Solution {
					public:
					int maximumEnergy(vector<int>& energy, int k) {
						int mxEnergyStore = INT_MIN, n = energy.size();
						
						// considering each & every index
						for(int i=0; i<n; i++){
							int curEnergy = 0;
							for(int j=i; j<n; j += k)
								curEnergy += energy[j];
							mxEnergyStore = max(mxEnergyStore, curEnergy);
						}
						return mxEnergyStore;
					}
				};	

			// Optimized:
				❌Pending
		
	837) Minimum Window Substring:
		Problem statement
			You are given two strings ‘A’ and ‘B’. Your task is to return a substring ‘S’ of ‘A’ such that the following conditions hold true :
			• You can make ‘B’ from ‘S’ by removing some characters and rearranging some characters zero or more times.
			• Length of ‘S’ must be as minimum as possible.
			Note :
			Testcases are generated such that a substring always exists and is unique.
			Example :
			A = ninjas, B = sin
			All possible substrings with which 'B' can be created are
			"ninjas", "injas".
			Hence the substring with minimum length is "injas".
			Sample Input 1 :
			fight it 
			Sample Output 1 :
			ight
			Explanation Of Sample Input 1 :
			Given A = “fight” and B = “it” 
			Consider the substring “ight” of A. 
			We can remove g and h from it to get “it”.
			We can also get "it" from "fight" but it is not the substring with minimum length.
			Sample Input 2 :
			coding cin
			Sample Output 2 :
			codin
			Constraints :
				1 <=  |A| = |B| <= 3000
				Both A, B contain only lowercase English letters.
				Where |A| and |B| are the length of strings.
				Time Limit: 1 sec

		// Not Optimized:
			string minSubstring(string &a, string &b) {
				string ans = a;
				for(int i=0; i<a.size(); i++){
					string temp;
					for(int j=i; j<a.size(); j++){
						temp += a[j];

						// find every letter of string b in temp
						int flg = 1;
						string t2 = temp;
						for(int y=0; y<b.size(); y++){
							if(t2.find(b[y]) == string::npos){
								flg = 0;
								break;
							}else{
								t2.erase(t2.begin() + t2.find(b[y]));
							}
							// cout<<t2<<"\n";
						}

						if(flg){
							if(temp.size() <= ans.size()){
								ans = temp;
							}
						}
					}
				}
				return ans;
			}
		
		// Optimized:
			❌Pending

	838) Special Stack:
		Problem Statement:
			Design a data-structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. Your task is to complete all the functions, using stack data-Structure.

			Example 1:
				Input:
				Stack: 18 19 29 15 16
				Output: 15
				Explanation:
				The minimum element of the stack is 15.

			Your Task:
				Since this is a function problem, you don't need to take inputs. You just have to complete 5 functions, push() which takes the stack and an integer x as input and pushes it into the stack; pop() which takes the stack as input and pops out the topmost element from the stack; isEmpty() which takes the stack as input and returns true/false depending upon whether the stack is empty or not; isFull() which takes the stack and the size of the stack as input and returns true/false depending upon whether the stack is full or not (depending upon the
				given size); getMin() which takes the stack as input and returns the minimum element of the stack. 
				Note: The output of the code will be the value returned by getMin() function.

			Expected Time Complexity: O(N) for getMin, O(1) for remaining all 4 functions.
			Expected Auxiliary Space: O(1) for all the 5 functions.

			Constraints:
				1 ≤ N ≤ 10^4

		int minEle;
		void push(stack<int>& s, int a){
			if(s.empty()){
				minEle = a;
				s.push(a);
			}else{
				if(minEle > a){
					s.push(2*a - minEle);
					minEle = a;
				}else{
					s.push(a);
				}
			}
		}

		bool isFull(stack<int>& s,int n){
			return (s.size() == n);
		}

		bool isEmpty(stack<int>& s){
			return s.empty();
		}

		int pop(stack<int>& s){
			int val;
			if(s.top() < minEle){
				val = 2*minEle - s.top();
			}else{
				val = s.top();
			}
			s.pop();
			return val;
		}

		int getMin(stack<int>& s){
			return minEle;
		}
	
	#CN BeginnerContest-60:
		839) First vs Last:
			Problem statement
				You are given a string 'S' containing 'N' lowercase English characters.
				In one operation, you can perform the left or right shift on the string 'S'.
				Determine if you can make the first and last characters equal by performing the operation any number of times. Return '1' if you can. Otherwise, return '0'.
				The left shift operation on the string 'S' includes updating all the 'S[i]' equal to 'S[i + 1]' for each 'i' from '0' to 'i - 2' and 'S[N - 1]' to 'S[0]' simultaneously. Similarly, the right shift operation on the string 'S' includes updating all the 'S[i]' equal to 'S[i - 1]' for each 'i' from '1' to 'N - 1' and 'S[0]' to 'S[N - 1]' simultaneously. (Note that we are using '0'-based indexing.)
				Example:
					N = 3
					S = 'abb'
					In the first operation, we will perform the right shift on 'S', so the resultant string is 'bab'.
					As the first and last characters are equal, the answer for this case is '1'.
				Constraints:
					2 <= 'N' <= 10^5
					'a' <= S[i] <= 'z'
					Time limit: 1 sec

				Sample input 1:
					2
					3
					aba
					4
					abab
					Sample output 1:
					1
					0
					Explanation of sample input 1:
					For test case 1:
					We can see that the first and last characters of the string are already equal.
					So, the answer for this case is '1'.

					For test case 2:
					It can be proved that we can not make the first and last characters of the string equal by performing the given operations.
					So, the answer for this case is '0'.
					Sample input 2:
					2
					6
					abcaac
					6
					dcdcdc
					Sample output 2:
					1
					0

			int canYouMakeEqual(int n, string &s) {
				if(s[0] == s[n-1])
					return 1;
				
				for(int i=0; i<n-1; i++)
					if(s[i] == s[i+1])
						return 1;
				return 0;
			}
		
		840) Thala For A Reason:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers where each element is numbered from ‘0’ to ‘N - 1’. A pair ‘(i, j)’ is said to be a special pair, if it satisfies the following conditions:
				‘i’ < ‘j’
				The last digit of ‘(A[i] * A[j])’ is ‘7’.
				You have to find the number of special pairs in the given array.
				Your task is to tell the total number of special pairs in the given array and return it.
				Example:
				‘N’ = 5
				‘A’ = [21, 3, 7, 29, 0]

				The first special pair is ‘(0, 2)’:
				As ‘(A[0] * A[2])’ gives ‘147’ whose last digit is ‘7’.

				The second special pair is ‘(1, 3)’.
				As ‘(A[1] * A[3])’ gives ‘87’ whose last digit is ‘7’.

				So, the total number of special pairs is ‘2’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					0 <= A[i] <= 10^6
					Time Limit: 1 sec

					Sample Input 1:
					2
					4
					1 17 37 47
					4
					10 23 24 12
					Sample Output 1:
					3
					0
					Explanation of sample input 1:
					For test case 1:

					The first special pair is: ‘(0, 1)’:
					As ‘(A[0] * A[1])’ gives ‘17’ whose last digit is ‘7’.

					The second special pair is ‘(0, 2)’:
					As ‘(A[0] * A[2])’ gives ‘37’ whose last digit is ‘7’.

					The third special pair is ‘(0, 3)’:
					As ‘(A[0] * A[3])’ gives ‘47’ whose last digit is ‘7’.

					So, the total number of special pairs is ‘3’.

					For test case 2:

					In this case, it is impossible to find any special pair. So, the answer for this test case is ‘0’.
					Sample Input 2:
					2   
					3
					9 3 9
					5
					99 33 17 1 1
					Sample Output 2:
					2   
					3

			// Says Wrong ❌Pending
				long long thalaForAReason(int n, vector<int> &a) {
					long long SplPairs = 0;
					for (int i = 0; i < n - 1; i++) {
						for (int j = i + 1; j < n; j++) {
							if(((a[i] * a[j]) % 10) == 7)
							SplPairs++;
						}
					}
					return SplPairs;
				}
			
			// Solution:
				/*
					Time complexity: O( N  )
					Space complexity: O( 1 )
					where 'N' is the length of the array 'A'.

				*/

				long long thalaForAReason(int n, vector <int> &a) {
					// Count number of lastdigits which are equal to '1', '7', '9', and '3'.
					long long cnt1 = 0, cnt7 = 0, cnt3 = 0, cnt9 = 0;
					for (int i = 0; i < n; i ++) {
						int lastDigit = (a[i] % 10);
						if (lastDigit == 1) {
							cnt1 += 1;
						}else if (lastDigit == 7) {
							cnt7 += 1;
						}else if (lastDigit == 3) {
							cnt3 += 1;
						}else if (lastDigit == 9) {
							cnt9 += 1;
						}
					}
					// Count the pairs.
					long long ans = (cnt1 * cnt7) + (cnt3 * cnt9);
					return ans;
				}

		841) Radioactive:
			Problem statement
				You've been provided with an array 'A' of size 'N'. Odd numbers within this array are radioactive, exerting pressure on all elements within the array. A number is deemed safe if the pressure on both of its sides is equal. More precisely, a number is considered safe if it has an equal number of odd numbers on both its left and right sides.
				You have to return the count of safe numbers.
				Example:
				‘N’ = 5
				‘A’ = [1, 2, 3, 4, 10, 12, 5, 6, 7] 
				Return 3
				The numbers 4, 10, 12 are safe as they has 2 odd numbers on the left and 2 odd numbers in the right.
				Constraints:
					1 <= ‘T’ <= 10
					1 <= ‘N’ <= 10^5
					10^9 <= A[i] <= 10^9
					Time Limit: 1 sec

				Sample Input 1:
					2
					6
					5 6 5 2 1 7 
					7
					7 2 5 5 2 4 7 
					Sample Output 1:
					1
					0
					Explanation of sample input 1:
					For Test case 1:
					The only safe number is 2.
					As it has 2 odd numbers on the left and 2 odd number in the right 
					For Test case 2:
					There are no safe numbers.
					Sample Input 2:
					3
					6
					2 2 8 7 7 9 
					6
					1 9 6 10 8 8 
					8
					10 3 3 9 1 10 5 8 
					Sample Output 2:
					1
					0
					1
		
			int radioactive(int n, vector<int> &a){
				int OnRightSide, OnLeftSide;
				OnRightSide = OnLeftSide =0;

				//counting the total no.of odds elements in array
				for(int i: a)
					if(i & 1)
						OnRightSide++;
					
				// checking the safe numbers
				int safe=0;
				for(int i=0; i<n; i++){
					if(a[i] & 1)
						OnRightSide--;

					if(OnLeftSide == OnRightSide)
						safe++;
					
					if(a[i] & 1)
						OnLeftSide++;            
				}       
				return safe;
			}
		
	842) Maximum Subarray Sum: (Refer Q.376 & Q.377 about Kadane's algorithm)
		Problem statement
			You are given an array 'arr' of length 'n', consisting of integers.
			A subarray is a contiguous segment of an array. In other words, a subarray can be formed by removing 0 or more integers from the beginning and 0 or more integers from the end of an array.
			Find the sum of the subarray (including empty subarray) having maximum sum among all subarrays.
			The sum of an empty subarray is 0.
			Example :
				Input: 'arr' = [1, 2, 7, -4, 3, 2, -10, 9, 1]
				Output: 11
				Explanation: The subarray yielding the maximum sum is [1, 2, 7, -4, 3, 2].
			Sample Input 1 :
			9
			1 2 7 -4 3 2 -10 9 1
			Sample Output 1 :
			11
			Explanation for Sample 1 :
			The subarray yielding the maximum sum is [1, 2, 7, -4, 3, 2].

			Sample Input 2 :
			6
			10 20 -30 40 -50 60
			Sample Output 2 :
			60

			Sample Input 3 :
			3
			-3 -5 -6
			Sample Output 3 :
			0

			Expected time complexity :
				The expected time complexity is O(n).
			Constraints :
				1 <= 'n' <= 10 ^ 6
				-10 ^ 6 <= 'arr[i]' <= 10 ^ 6
				Time limit: 1sec

		long long maxSubarraySum(vector<int> arr, int n) {
			long long mxAns = 0;
			long long curSum = 0;
			for (int i : arr) {
				curSum += i;
				if (curSum < 0)
					curSum = 0;
				mxAns = max(mxAns, curSum);
			}
			return mxAns;
		}

		// or
		long long maxSubarraySum(vector<int> arr, int n) {
			long long maxSubValue=0, curValue =0;
			for(int i=0; i<n; i++){
				curValue = max((int)arr[i],(int)(curValue + arr[i]));				// curValue = fmax(arr[i],(curValue + arr[i]));		
																		// either specify its (int) type value or use fmax functino instead
																		// (int) won't work for long long returntype
				maxSubValue = max(maxSubValue, curValue);
			}
			return maxSubValue;
		}
	
	843) Maximum Subarray Sum:
		Problem statement
			Given an array of numbers, find the maximum sum of any contiguous subarray of the array.
			For example, given the array [34, -50, 42, 14, -5, 86], the maximum sum would be 137, since we would take elements 42, 14, -5, and 86.
			Given the array [-5, -1, -8, -9], the maximum sum would be -1.
			Follow up: Do this in O(N) time.
			Constraints:
				1 <= N <= 10^6
				1 <= K <= N
				Time limit: 1 sec 
			Sample Input 1:
				4 1
				1 2 3 4
				Sample Output 1:
				4
				Sample Input 2:
				6 2
				2 7 3 6 7 7 
				Sample Output 2:
				14
				Explanation for Sample Output 2:
				There are 5 subarrays of size 2 in this array. They are {2, 7}, {7, 3}, {3, 6}, {6, 7}, {7, 7}. Since the subarray {7, 7} has the maximum sum among all the subarrays, the output will be 7 + 7 = 14

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			int n;
			cin>>n;

			int *arr = new int[n];
			for(int i=0; i<n; i++)
				cin>>arr[i];

			long long mxAns= *max_element(arr, arr+n);				// or long long mxAns= INT_MIN;
			long long curSum = 0;
			for(int i=0; i<n; i++){
				curSum += arr[i];
				if(curSum < 0)
					curSum = 0;
				mxAns = max(mxAns, curSum);
			}
			cout<<mxAns<<endl;
			return 0;
		}

	#CN WeeklyContest-126:
		844) War:
			Problem statement
				There are 'N' nations at war, each with its own power denoted by the array 'P'. Nations have the option to form alliances, where their powers combine and they are considered as a single entity. For example, if nations A, B, and C form an alliance, their combined power is P[A] + P[B] + P[C].
				You aim to establish a new nation. Your current power is 0 and you want to invest in increasing its power. What is the minimum amount the power needs to be increased so that your nation can defeat any other nation, either when standing alone or when combined in any possible alliance? You cannot form alliances; defeating a nation means having strictly greater power than it.
				Example:
				‘N’ = 5
				‘A’ = [1, 2, -1, 0, 1] 
				Return 5
				The most powerful enemy can be Nations 1,2 and 5 in alliance which have a total power of 4.
				Hence you need at least 5 power to defeat them.
				Constraints:
					1 <= ‘T’ <= 10
					1 <= ‘N’ <= 10^5
					-10^4 <= A[i] <= 10^4
					Time Limit: 1 sec
				Sample Input 1:
					2
					6
					6 10 3 -10 4 0 
					5
					-1 -2 -3 -4 -5
					Sample Output 1:
					24
					0
					Explanation of sample input 1:
					For Test case 1:
					The most powerful enemy can be Nations 1, 2, 3 and 5 in alliance which have a total power of 23.
					Hence you need at least 24 power to defeat them.
					For Test case 2:
					There doesn't exist any alliance which when combined has increased power.
					The most powerful nation is -1 and as your power is 0 already you don't need to increase your power.
					Sample Input 2:
					3
					5
					7 9 -5 2 7 
					9
					3 -2 0 9 4 1 2 6 8 
					5
					4 2 -8 7 9 
					Sample Output 2:
					26
					34
					23

			int powerIncrease(int n, vector<int> &p){
				int ttl_pwr = 0;

				for(int i: p)
					if(i > 0)
						ttl_pwr += i;

				return (ttl_pwr)? ttl_pwr+1 : ttl_pwr;
			}
		
		845) Contrasting properties:
			Problem statement
				You are given two strings 'S' and 'T' of 'N' lowercase English letters.
				You are required to generate string 'G' of length 'N' which satisfies the given conditions:
				The string 'G' must be sorted in non-increasing order and for each 'i', 'G[i]' must be equal to either 'S[i]' or 'T[i]'.
				You are required to find the lexicographically minimum string 'G' which satisfies the mentioned conditions. It is guaranteed that there exists at least '1' string 'G' that satisfies the given conditions.
				Example:
				N = 3
				S = 'eac'
				T = 'cdc'
				One possible string 'G' is 'edc'.
				It can be proved that you can not find a lexicographically smaller string 'G' than 'edc' which follows the mentioned conditions.
				So, the answer for this case is 'edc'.
				Constraints:
					1 <= 'N' <= 10^5
					'a' <= S[i] <= 'z'
					'a' <= T[i] <= 'z'
					Time limit: 1 sec

				Sample input 1:
					2
					3
					cba
					dcb
					4
					fbbc
					cdcc
					Sample output 1:
					cba
					fdcc
					Explanation of sample input 1:
					For test case 1:
					One possible string 'G' is 'cba'.
					It can be proved that you can not find a lexicographically smaller string 'G' than 'cba' which follows the mentioned conditions.
					So, the answer for this case is 'cba'.


					For test case 2:
					One possible string 'G' is 'fdcc'.
					It can be proved that you can not find a lexicographically smaller string 'G' than 'fdcc' which follows the mentioned conditions.
					So, the answer for this case is 'fdcc'.
					Sample input 2:
					2
					5
					axdfs
					zdvcf
					2
					aa
					bb
					Sample output 2:
					zxvff
					aa

			string lexicographicallyMinimum(int n, string &s, string &t) {
				string ans(n, '0');

				// starting from end & appending the min element every time 
				// to generate the string which is decreasing in order

				for(int i=n-1; i>=0; i--){
					char min = s[i], max = t[i];

					if(max < min)
						swap(min, max);

					if(ans[i+1] <= min)
						ans[i] = min;
					else
						ans[i] = max;
				}
				return ans;
			}

			// or Explanative
				/*
					Time Complexity: O(n)
					Space Complexity: O(n)

					Where 'n' denotes the lengths of the strings 's' and 't'.
				*/
				string lexicographicallyMinimum(int n, string &s, string &t) {

					// Initialize a string 'g' of length 'n'.
					string g = string(n, '?');

					// Update 'g[n - 1]' equal to the minimum of 's[n - 1]' and 't[n - 1]'.
					g[n - 1] = min(s[n - 1], t[n - 1]);

					// Iterate the strings in reverse direction.
					for (int i = n - 2; i >= 0; i--) {

						// Initialize characters 'min' and 'max' equal to 's[i]' and 't[i]', respectively.
						char min = s[i], max = t[i];

						// Swap 'min' and 'max' if 'min' is greater than 'max'.
						if (min > max) {
							swap(min, max);
						}

						// Update 'g[i]' according to the characters 'g[i + 1]', 'min' and 'max'.
						if (min >= g[i + 1]) {
							g[i] = min;
						}
						else {
							g[i] = max;
						}
					}

					// Return the string 'g'.
					return g;
				}
				
		845) Three Array Triplets:
			Problem statement
				You are given three arrays ‘A’, ‘B’ and ‘C’ each of size ‘N’ where elements in the corresponding arrays are numbered from ‘0’ to ‘N - 1’. You have to count the number of triplets {‘i’, ‘j’, ‘k’} such that ‘(A[i] <= 2 * B[j] <= 3 * C[k])’.
				Your task is to count the number of triplets following the given condition mentioned above and return it.
				Example:
				‘N’ = 3
				‘A’ = [1, 4, 2]
				‘B’ = [3, 0, 2]
				‘C’ = [4, 0, 1]

				Here, the number of triplets following the given condition are:
				(0, 2, 0): As ‘A[0]’ <= ‘2 * B[2]’ <= ‘3 * C[0]’.
				(0, 0, 0): As ‘A[0]’ <= ‘2 * B[0]’ <= ‘3 * C[0]’.
				(2, 0, 0): As ‘A[2]’ <= ‘2 * B[0]’ <= ‘3 * C[0]’.
				(2, 2, 0): As ‘A[2]’ <= ‘2 * B[2]’ <= ‘3 * C[0]’.
				The count of these triplets is ‘4’.
				Constraints:
					1 <= ‘T’ <= 10
					1 <= ‘N’ <= 10^5
					1 <= ‘A[i]’ <= 10^6
					1 <= ‘B[i]’ <= 10^6
					1 <= ‘C[i]’ <= 10^6
					Time Limit: 1 sec
				Sample Input 1:
					2
					3
					5 0 1
					1 0 2
					2 0 3
					2
					1 1
					1 1
					1 1
					Sample Output 1:
					11
					8
					Explanation of sample input 1:
					For test case 1:
					The number of triplets following the given condition are: (1, 1, 0), (1, 1, 1), (1, 1, 2), (1, 0, 0), (1, 0, 2), (1, 2, 0), (1, 2, 2), (2, 0, 0), (2, 0, 2), (2, 2, 0), and (2, 2, 2).
					The total count of these triplets is ‘11’.

					For test case 2:
					The number of triplets following the given condition are: (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), and (1, 1, 1).
					The total count of these triplets is ‘8’.
					Sample Input 2:
					2
					1
					3
					0
					7
					2
					1 0
					4 5
					0 4
					Sample Output 2:
					0
					4

			// Not Optimized:
				long long threeArrayTriplets (int n, vector <int> &a, vector <int> &b, vector <int> &c) {
					long long cnt =0;

					for(int i=0; i<n; i++){
						for(int j=0; j<n; j++){
							for(int k=0; k<n; k++){
								long long v1 = a[i];
								long long v2 = 2*b[j];
								long long v3 = 3*c[k];
								if((v1 <= v2) && (v2 <= v3))
									cnt++;
							}
						}    
					}
					return cnt;
				}
			
			// Optimized:
				❌Pending
		
		847) Stacking Skill:
			Problem statement
				You recently learned about stacks, where you can push elements to the back and pop one element at a time from the back.
				Now, you are playing with a stack. To test your skills, the Ninja has provided you with 'N' queries. There are two types of queries:
				'1 L R': Add elements 'L, L+1, L+2, ..., R` into the stack.
				'2 K': Remove the last 'K' elements from the stack and print the sum of them modulo '10^9 + 7'
				Perform all the queries and return the array of answers to queries of type '2' modulo '10^9+7'.
				Example:
				'N' = 2
				'Queries' = [[1, 4, 5], [2, 2]] 
				The stack is initially empty.
				Adding elements '4' and '5' to the stack results in'`[4, 5]'.
				Removing the top '2' elements from the stack ('5' and '4') yields an answer of '4 + 5 = 9'. The stack will become empty.
				So, the answer will be '[9]'.
				Detailed explanation ( Input/output format, Notes, Images )
				Constraints:
					1 <= T <= 10
					1 <= N <= 10^5
					1 <= L <= 10^12
					L <= R <= 10^12
					1 <= K <= min(number in stacks, 10^12)
					Time Limit: 1 second

				Sample Input 1:
					2
					3
					1 4 9 
					2 3 
					2 1 
					3
					1 1 4 
					2 2 
					2 1 
					Sample Output 1:
					24 6
					7 2
					Explanation Of Sample Input 1:
					For test case 1:
					The stack is initially empty.
					Adding elements '4', '5', '6', '7', '8' and '9' to the stack results in'`[4, 5, 6, 7, 8, 9]'.
					Removing the top '3' elements from the stack ('9', '8' and '7') yields an answer of '9 + 8 + 7 = 24'. The stack will become '[4, 5, 6]'.
					Removing the top '1' elements from the stack ('6') yields an answer of '6'. The stack will become '[4, 5]'.
					So, the answer will be '[24, 6]'.

					For test case 2:
					The stack is initially empty.
					Adding elements '1', '2', '3', and '4' to the stack results in'`[1, 2, 3, 4]'.
					Removing the top '2' elements from the stack ('4' and '3') yields an answer of '4 + 3 = 7'. The stack will become '[1, 2]'.
					Removing the top '1' elements from the stack ('2') yields an answer of '2'. The stack will become '[1]'.
					So, the answer will be '[7, 2]'.
					Sample Input 2:
					2
					7
					1 9 34 
					2 13 
					2 1 
					1 13 36 
					2 16 
					1 4 25 
					2 26 
					7
					1 13 36 
					1 6 30 
					2 20 
					2 6 
					1 1 42 
					2 32 
					2 24 
					Sample Output 2:
					364 21 456 393 
					410 76 848 454 

			// Not Optimized:
				vector<int> solveQueries(int n, vector<vector<long long>> queries) {
					vector<int> ans;
					int mod = 1e9+7;
					stack<int> st;

					for(int i=0; i < queries.size(); i++){
						if(queries[i][0] == 1){
							int s = queries[i][1], e = queries[i][2];
							
							while(s <= e)
								st.push(s++);

						}else{
							int K = queries[i][1];
							int Sum =0;
							while(K-- && !st.empty()){						//not necessary to check empty condition you can do just this 'while(K--)'
								Sum += st.top();
								st.pop();
								Sum %= mod;
							}
							ans.push_back(Sum);
						}
					}
					return ans;
				}
			
			// Optimized:
				❌Pending
	
	848) Find Pair Given Difference:
		Problem Statement:
			Given an array arr[] of size n and an integer x, return 1 if there exists a pair of elements in the array whose absolute difference is x, otherwise, return -1.
			Example 1:
				Input:
				n = 6
				x = 78
				arr[] = {5, 20, 3, 2, 5, 80}
				Output:
				1
				Explanation:
				Pair (2, 80) have absolute difference of 78.

			Example 2:
				Input:
				n = 5
				x = 45
				arr[] = {90, 70, 20, 80, 50}
				Output:
				-1
				Explanation:
				There is no pair with absolute difference of 45.
			Your Task:
				You need not take input or print anything. Your task is to complete the function findPair() which takes integers n, x, and an array arr[] as input parameters and returns 1 if the required pair exists, return -1 otherwise.

			Expected Time Complexity: O(n* Log(n)).
			Expected Auxiliary Space: O(1).

			Constraints:
				1<=n<=10^6 
				1<=arr[i]<=10^6
				0<=x<=10^5

		// Not Optimized:
			class Solution {
				public:
				int findPair(int n, int x, vector<int> &arr) {
					for(int i=0; i<n-1; i++){
						for(int j=i+1; j<n; j++){
							if(abs(arr[i] - arr[j]) == x)
								return 1;
						}
					}
					return -1;
				}
			};

		// Optimized:
			class Solution {
				public:
				int findPair(int n, int x, vector<int> &arr) {
					
					sort(arr.begin(), arr.end());
					int i=0, j=1;
					
					while(i < n && j < n){
						int diff = (arr[j]-arr[i]);
						if(diff == x && i != j)
							return 1;
						else if(diff < x)
							j++;
						else
							i++;
					}
					return -1;
				}
			};

	849) Special Sum:
		Problem statement
			You are given an array ‘ARR’ of length ‘N’. There are two operations, ‘FIRST_SUM’ and ‘LAST_SUM’ for every index ‘i’ (1 <= i <= N) in the array,
			i) FIRST_SUM(i) calculates the sum of first i numbers.
			ii) LAST_SUM(i) calculates the sum of last N-i+1 numbers.
			Also for every ‘i’, SPECIAL_SUM(i) can be calculated as:
			SPECIAL_SUM(i) = FIRST_SUM(i) + LAST_SUM(i)
			Your task is to return the minimum SPECIAL_SUM for 0 <= i <= N - 1.
			For example:
			Given ‘N’ = 4 and ‘ARR’ = [1, 2, 3, 4].
			Then the minimum special sum will be 5 for i = 0 (0-based indexing), which is (1 + 4) = 5.Sum of 1 integer from beginning and end.
			For i = 1 it will be (1 + 2) + (3 + 4) = 10
			For i = 2 it will be (1 + 2 + 3) + (2 + 3 + 4) = 15
			For i = 3 it will be (1 + 2 + 3 + 4) + (1 + 2 + 3 + 4) = 20
			All of which are greater than 5.
			Constraints:
				1 <= T <= 5
				1 <= N <= 5 *10^3
				-5 *10^2 <= ARR[i] < 5 *10^2
				Time limit: 1 sec

			Sample Input 1:
			2
			4
			1 2 3 4
			4
			1 -2 -3 4
			Sample Output 1:
			5
			-5
			Explanation of the Sample Input 1:
			For the first test case:
			The  minimum special sum will be 5 for i = 0 (0-based indexing), which is (1 + 4) = 5.
			For i = 1 it will be (1 + 2) + (3 + 4) = 10
			For i = 2 it will be (1 + 2 + 3) + (2 + 3 + 4) = 15
			For i = 3 it will be (1 + 2 + 3 + 4) + (1 + 2 + 3 + 4) = 20
			All of which are greater than 5.  

			For the second test case:
			The  minimum special sum will be -5 for i = 2 (0-based indexing), which is (1 + (-2) + (-3)) +  (-2 + (-3) + (4)) = -5.
			For i = 0 it will be (1) + (4) = 5
			For i = 1 it will be (1 + (-2) ) + ( (-3) + 4) = 0 
			For i = 3 it will be (1 + (-2) + (-3) + 4)  + (1 + (-2) + (-3) + 4) = 0.
			All of which are less than -5.
			Sample Input 2:
			2
			5
			1 2 -5 3 1
			5 
			1 1 1 1 1
			Sample Output 2:
			-3
			2

		// Not Optimized:
			#include <bits/stdc++.h> 
			int specialSum(vector<int> &arr, int n) {
				int ans = INT_MAX;

				for(int i=0; i<n; i++){
					int z = i;

					int curAns =0;
					while(z >= 0){
						curAns += arr[z];				// first sum
						curAns += arr[n-1-z];		 // last sum
						z--;
					}
					// cout<<ans <<"\t"<<curAns<<endl;
					ans = min(ans, curAns);
				}
				return ans;
			}

		// Optimized:
			#include <bits/stdc++.h> 
			int specialSum(vector<int> &arr, int n) {
				int ans = INT_MAX;

				int curAns =0;
				for(int i=0; i<n; i++){
					curAns += arr[i];
					curAns += arr[n-1-i];
					// cout<<ans <<"\t"<<curAns<<endl;
					ans = min(ans, curAns);
				}
				return ans;
			}
	
	850) Add K Nodes:
		Problem statement
			You are given a Singly Linked List of integers and an integer 'K'.
			Your task is to modify the linked list by inserting a new node after every 'K' node in the linked list with the node value being equal to the sum of the previous 'K' nodes.
			Note :
			If you reach a situation when the number of nodes remaining in the linked list is less than 'K' but greater than zero, just insert a node with the value equal to the sum of the remaining nodes.
			Constraints:
				0 <= L <= 5 * 10^5
				-10^3 <= data <= 10^3 and data != -1
				1 <= K <= 10^6
				where 'L' is the number of nodes in the linked list and 'data' is the value of elements present in the given linked list.
				Time Limit: 1 sec
			Sample Input 1:
				1 2 3 4 5 6 7 -1
				3
				Sample Output 1:
				1 2 3 6 4 5 6 15 7 7 -1
				Explanation For Sample Output 1:
				For the given input, K = 3, so we have inserted a node after the first 3 nodes with a value of 6 as (1 + 2 + 3).

				Similarly, we insert a node after the next 3 nodes with a value of 15 as (4 + 5 + 6). Now only 1 node is left (with a value 7) and 0 < 1 < K, so we insert a node with the value 7 at the end of the list.
				Sample Input 2:
				0 6 1 5 -1
				2
				Sample Output 2:
				0 6 6 1 5 6 -1

		#include <bits/stdc++.h> 
		/****************************************************************
			Following is the class structure of the Node class:

			class Node{
				public:
					int data;
					Node *next;
				Node(int data){
					
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/
		Node *getListAfterAddingNodes(Node *head, int k){
			int s, cnt;
			s = cnt = 0;
			Node* temp = head;
			Node* prev = head;

			while(temp){
				s += temp->data;
				cnt++;

				prev = temp;
				temp = temp -> next;

				if(cnt == k){
					Node* nn = new Node(s);
					nn -> next = temp;
					prev -> next = nn;
				
					s = cnt = 0;
				}
			}

			if(s){
				Node* nn = new Node(s);
				prev -> next = nn;
			}
			return head;
		}

	851) Intersection of Linked Lists:
		Problem statement
			You are given two linked lists L1 and L2 which are sorted in ascending order. You have to make a linked list with the elements which are present in both the linked lists and are present in ascending order.
			Example:-
			L1 = 1->2->3->4->7
			L2 = 2->4->6->7

			ANSWER:- The answer should be 2->4->7 because 2,4, and 7 are present in both the linked lists.
			Constraints :
				1 <= T <= 5
				1 <= Length of the the two linked lists <= 10^5 
				Time Limit = 1 sec
			Sample Input 1 :
				2
				1 3 5 -1
				1 2 4 -1
				2 3 -1
				2 3 4 -1
				Sample Output 1 :
				1 -1
				2 3 -1
				Explanation for Sample Output 1 :
				In the first test case, the intersecting linked list is 1, so the node containing 1 is returned.

				In the second test case, the intersecting linked list is 2->3, so the node containing 2 is returned.
				Sample Input 2 :
				1
				2 3 4 -1
				1 5 6 -1
				Sample Output 2 :
				-1 

		#include <bits/stdc++.h> 
		/************************************************************
			Following is the linkedList class structure:

			class Node {
				public:
					int data;
					Node *next;
				Node(int val) {
					this->data = val;
					next = NULL;
				}
				~Node() {
					if (next != NULL) {
						delete next;
					}
				}
			};
		************************************************************/
			
		Node* intersect_ll(Node* L1, Node *L2){
			Node* ans = nullptr;
			Node* trvrs = nullptr;

			while(L1 && L2){
				if(L1 -> data == L2 -> data){
					if(ans == nullptr){
						ans = L1;
						trvrs = L1;
					}else{
						trvrs -> next = L1;
						trvrs = trvrs -> next;
					}
					L1 = L1 -> next;
					L2 = L2 -> next;
				}else if(L1 -> data < L2 ->data){
					L1 = L1 -> next;
				}else{
					L2 = L2 -> next;
				}
			}
			if(trvrs)
				trvrs -> next = nullptr;		
			return ans;
		}
	
	852) Add First and Second Reversed Half:
		Problem statement
			You have been given a Linked List of 'N' nodes such that each node represents a single digit.
			Your task is to return a node 'X', where 'X' represents the head of the Linked List storing the digits of the sum(most significant digit at the head) formed by adding 1st half and reverse of 2nd half of the given linked list.
			Note:
			1. When 'N' is odd consider the middle element to be part of 1st half.
			2. The sum should not contain any leading zero, except the number 0 itself.
			For example:
			Given a Linked List: 1-2-3-4-5-5-6
			First half: 1-2-3-4   
			Reversed second half: 6-5-5
			Output linkedlist: 1-8-8-9 = (1234 + 655 = 1889)
			Follow Up:
			Can you add both halves without finding the length of LinkedList and in O(1) space?
			Constraints :
				0 <= 'N' <= 10 ^ 5
				0 <= 'DATA' <= 9

			Where 'N' is the number of nodes in linked list and 'DATA' is the integer value in each node.
			Time Limit: 1 sec
			Sample Input 1:
			1 2 4 5 6 -1
			Sample Output 1:
			189
			Explanation for Sample Input 1:
			The first half of the given linkedlist is: 1-2-4
			The second half of the given linkedlist is: 6-5
			Sum of both parts = 124 + 65 = 189
			Sample Input 2:
			3 9 0 1 1 0 -1
			Sample Output 2:
			401
		
		#include <bits/stdc++.h> 
		/****************************************************************
			Following is the class structure of the Node class:
				class Node {
					public:
						int data;
						Node *next;
					Node(int data) {
						this->data = data;
						this->next = NULL;
					}
				};
		*****************************************************************/
		Node* findMid(Node* h){
			Node* slow = h;
			Node* fst = h -> next;

			while(fst && fst -> next){
				slow = slow -> next;
				fst = fst -> next -> next;
			}
			// cout<< slow -> data<<"\n";
			return slow;
		}

		Node* reverseIt(Node* h){
			Node* cur = h;
			Node* prev = NULL;

			while(cur){
				Node* tempNxt = cur -> next;
				cur -> next = prev;
				prev = cur;

				cur = tempNxt;
			}
			return prev;
		}

		Node* addFirstAndReversedSecondHalf(Node* head) {
			if(!head)
				return head;
				
			if(!head -> next)
				return head;
			
			Node* mid = findMid(head);
			Node* secondHf = mid -> next;
			mid -> next = NULL;
			mid = reverseIt(head);

			Node* ans = new Node(0);

			int c = 0;
			Node* temp = ans;

			while(mid or secondHf or c){
				int v1 =0, v2=0;
				if(mid)
				v1 = mid -> data;

				if(secondHf) 
				v2 =  secondHf -> data;

				int sum =  v1 + v2 + c;
				c = sum / 10;

				Node* nn = new Node(sum % 10);
				temp -> next = nn;
				temp = nn;

				if(secondHf)
				secondHf = secondHf -> next;

				if(mid)
				mid = mid -> next;
			}

			ans = ans -> next;        //ignoring the dummy node
			ans = reverseIt(ans);

			// erasing leading zeros
			while(ans -> next && ans->data == 0)
				ans = ans -> next;

			return ans;
		}

		Practice:
			Node* FindMid(Node* h){
				Node* s = h;
				Node* f = h-> next;
				while(f && f-> next){
					s = s -> next;
					f = f -> next -> next;
				}
				return s;
			}

			Node* reverseLL(Node* h){
				Node* prev = NULL;
				Node* cur = h;

				while(cur){
					Node* nxtND = cur -> next;
					cur -> next = prev;
					prev = cur;

					cur = nxtND;
				}
				return prev;
			}

			Node* addFirstAndReversedSecondHalf(Node* head) {
				if(!head)
					return head;
				
				Node* mid = FindMid(head);
				Node* second = mid -> next;
				mid -> next = NULL;

				Node* first = reverseLL(head);

				int c =0;
				
				Node* ans = new Node(0);
				Node* temp = ans;

				while(first or second or c){
					int v1, v2;
					v1 = v2 = 0;
					if(first)
						v1 = first -> data;
					
					if(second)
						v2 = second -> data;

					int sum = v1 + v2 + c;

					c = sum / 10;
					Node* nn = new Node(sum % 10);
					temp -> next = nn;
					temp = nn;

					if(second)
						second = second -> next;
						
					if(first)
						first = first -> next;
				}
				ans = ans -> next;
				ans = reverseLL(ans);

				while(ans && ans -> next && ans -> data == 0)
					ans = ans -> next;
				return ans;
			}

	853) Merge k sorted lists:
		Problem statement
			Given 'k' sorted linked lists, each list is sorted in increasing order. You need to merge all these lists into one single sorted list. You need to return the head of the final linked list.
			For example:
			Input:
			3
			3
			4 6 8
			3
			2 5 7 
			2
			1 9

			Output:
			1 2 4 5 6 7 8 9 

			Explanation:
			First list is: 4 -> 6 -> 8 -> NULL
			Second list is: 2 -> 5 -> 7 -> NULL
			Third list is: 1 -> 9 -> NULL
			The final list would be: 1 -> 2 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> NULL
			Sample Input 1:
			2
			2
			2 6 
			2
			-5 7 
			Sample Output 1:
			-5 2 6 7
			Explanation for input 1:
			First list is: 2 -> 6 -> NULL
			Second list is: -5 -> 7 -> NULL
			The final list would be: -5 -> 2 -> 6 -> 7 -> NULL
			Sample Input 2:
			2
			3
			8 9 11 
			2
			1 2 
			Sample output 2:
			1 2 8 9 11 
			Constraints:
				1 <= 'k' <= 10^3
				1 <= 'n' <= 100
				-10^9  <= 'data' <=  10^9 

				where 'n' is the size of the list.
				Time limit: 1 sec.
		
		/*
			Following is the class structure of the Node class:
			class Node {
				public:
					int data;
					Node *next;
				Node() {
					this->data = 0;
					next = NULL;
				}
				Node(int data) {
					this->data = data; 
					this->next = NULL;
				}
				Node(int data, Node* next) {
					this->data = data;
					this->next = next;
				}
			};
		*/

		// used extra space
		/* TC: O(n * log n) & SC: O(n*m) */
		Node* mergeKLists(vector<Node*> &listArray){
			int i=0, n = listArray.size();
			Node* head = NULL;

			// connecting all lists
			head = listArray[i++];
			Node* temp = head;

			while(temp -> next)
				temp = temp -> next;  

			while(i < n){
				temp -> next = listArray[i++];
				while(temp -> next)
					temp = temp -> next;
			}

			// sorting all lists
			vector<int> v;
			temp = head;
			while(temp){
				v.push_back(temp -> data);
				temp = temp -> next;
			}

			sort(v.begin(), v.end());
			temp = head;
			i =0;
			while(temp){
				temp -> data = v[i++];
				temp = temp -> next;
			}
			return head;
		}

		// without using extra space:
			❌Pending

	#AtCoder BeginnerContest-354
		854) A - Exponential Plant:
			Problem Statement
				Takahashi is growing a plant. Its height at the time of germination is 0cm. Considering the day of germination as day 0, its height increases by 
				2^icm day i's night (0≤i).
				Takahashi's height is H cm.
				Every morning, Takahashi measures his height against this plant. Find the first day such that the plant's height is strictly greater than Takahashi's height in the morning.
				Constraints
				1 ≤ H ≤ 10^9
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:
					H
				Output
					Print an integer representing the first day such that the plant's height is greater than Takahashi's height in the morning.

				Sample Input 1
				54
				Sample Output 1
				6
				The plant's height in the mornings of days 
				1,2,3,4,5,6 will be 1cm, 3cm, 7cm, 15cm, 31cm, 63cm, respectively. The plant becomes taller than Takahashi in the morning day 6, so print 6.

				Sample Input 2
				7
				Sample Output 2
				4
				The plant's height will be 7cm in the morning of day 3 and 15cm in the morning day 4. The plant becomes taller than Takahashi in the morning of day 
				4, so print 4.
				Note that, in the morning of day 3, the plant is as tall as Takahashi, but not taller.

				Sample Input 3
					262144
				Sample Output 3
					19

			#include <iostream>
			#include <math.h>
			using namespace std;
			int main() {
				int H;
				cin>>H;
				
				int curH = 0, day=1;
				while(curH < H){
					curH = pow(2, day) - 1;
					if(curH <= H)
						day++;
					// std::cout << curH<< std::endl;
				}
				std::cout << day << std::endl;
				return 0;
			}
		
	#LeetCode WeeklyContest-398:
		855) Special Array I:
			Problem Statement:
				An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
				You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.
		
				Example 1:
				Input: nums = [1]
				Output: true
				Explanation:
				There is only one element. So the answer is true.

				Example 2:
				Input: nums = [2,1,4]
				Output: true
				Explanation:
				There is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.

				Example 3:
				Input: nums = [4,3,1,6]
				Output: false
				Explanation:
				nums[1] and nums[2] are both odd. So the answer is false.
				
				Constraints:
				1 <= nums.length <= 100
				1 <= nums[i] <= 100
		
			class Solution {
				public:
				bool isArraySpecial(vector<int>& nums) {
					ios_base::sync_with_stdio(0);
					cin.tie(0);
					cout.tie(0);
					
					int n = nums.size();
					if(n == 1)
						return 1;
					
					for(int i=0; i<n-1; i++)
						if((nums[i]&1 == nums[i+1]&1) || (nums[i] % 2 == nums[i+1] % 2))
							return 0;
					return 1;        
				}
			};

		856) Special Array II:
			Problem Statement:
				An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
				You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that 
				subarray nums[fromi..toi] is special or not.
				Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.

				Example 1:
				Input: nums = [3,4,1,2,6], queries = [[0,4]]
				Output: [false]
				Explanation:
				The subarray is [3,4,1,2,6]. 2 and 6 are both even.

				Example 2:
				Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
				Output: [false,true]
				Explanation:
				The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false.
				The subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true.

				Constraints:
					1 <= nums.length <= 10^5
					1 <= nums[i] <= 10^5
					1 <= queries.length <= 10^5
					queries[i].length == 2
					0 <= queries[i][0] <= queries[i][1] <= nums.length - 1

			// Not Optimized
				class Solution {
					public:
					bool checkSpecial(vector<int>& n, int s, int e){
						while(s < e){
							if((n[s]&1 == n[s+1]&1) || (n[s] % 2 == n[s+1] % 2))
								return 0;
							s++;
						}
						return 1;
					}
					
					vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {
						int q = queries.size(), n = nums.size();
						
						// initialized all ans as false
						vector<bool> ans(q, 0);             
						for(int i=0; i<q; i++)
							ans[i] = checkSpecial(nums, queries[i][0], queries[i][1]);
						
						return ans;
					}
				};
				
			// Optimized
				❌Pending
					
	857) Find the closest number:
		Problem Statement:
			Given a sorted array arr[] of positive integers. The task is to find the closest value in the array to the given number k. The array may contain duplicate values.
			Note: If the difference with k is the same for two values in the array return the greater value.

			Example 1:
				Input: 
				n = 4
				k = 4
				arr[] = {1, 3, 6, 7}
				Output: 
				3
				Explanation:
				We have array arr={1, 3, 6, 7} and target is 4. If we look at the absolute difference of target with every element of the array we will get { |1-4|, |3-4|, |6-4|, |7-4| }  = {3, 1, 2, 3}. So, the closest number is 3.

			Example 2:
				Input:
				n = 7
				k = 4
				arr[] = {1, 2, 3, 5, 6, 8, 9}
				Output:
				5
				Explanation:
				The absolute difference of 4 is 1 from both 3 and 5. According to the question, we have to return greater value, which is 5.
			Your Task:
			This is a function problem. The input is already taken care of by the driver code. You only need to complete the function findClosest() that takes integers n and k and sorted array arr[] of size n as input parameters and return the closest number in the array to k. 

			Expected Time Complexity: O(log(n)).
			Expected Auxiliary Space: O(1).

			Constraints:
			1 ≤ n ≤ 10^6
			1 ≤ k ≤ 10^9
			1 ≤ arr[i] ≤ 10^9

		class Solution{
			public:
			int findClosest( int n, int k,int arr[]) {
				int closer = arr[0];
				int minV = abs(k - arr[0]);
				
				for(int i=1; i<n; i++){
					int val = abs(k - arr[i]);
					if(minV >= val){
						closer = arr[i];
						minV = val;
					}
				}
				return closer;
			} 
		};

	#GFG Weekly-155:
		858) Eye's Contact:
			Problem Statement:
				Alice and Bob were invited to Geek's birthday party. While there, Bob noticed Alice, who caught his
				eye. Bob glanced into Alice's eyes every n seconds. Little did he know, Alice was also doing the same,
				looking in Bob's eyes every m seconds.
				Your task is to find the exact second when Bob and Alice will find themselves locked in a moment of
				mutual eye contact for the first time. Bob and Alice begin looking into each other's eyes as soon as they
				enter the party venue at an intervals of n and m respectively, and you can assume they entered at the
				same time.
				Example 1:
				Input:
				N = 1, M = 3
				Output: 3
				Explanation:
				Bob looks into Alice's eyes every 1 second, while Alice looks into Bob's eyes every 3
				seconds. Since Bob looks into Alice's eyes every second, he will make eye contact with her
				on the third second, which coincides with Alice's glance at Bob's eyes. Therefore, the first
				mutual eye contact occurs at the 3rd second. So, the output is 3.
				Example 2:
				Input:
				N = 3, M = 4
				Output: 12
				Explanation:
				Bob looks into Alice's eyes every 3 seconds, while Alice does the same every 4 seconds.
				They will make eye contact for the first time at the 12th second.
				Your Task:
					You don't need to read input or print anything. Your task is to find the exact second when Bob and Alice
					will find themselves locked in a moment of mutual eye contact for the first time.
				Constraints:
					• 1 ≤ N ≤ 10^5
					• 1 ≤ M ≤ 10^5
			
			class Solution {
				public:
				long long firstContact(int n, int m) {
					int val = min(n,m);
					long long sec = val;
					
					while(1){
						if(sec % n == 0 && sec % m == 0)
							return sec;
						sec += val;
					}
					return 0;
				}
			};

		859) Matching Characters:
			Problem Statement:
				You are given an array of strings. For each string in the array, calculate the sum of matching characters
				between that string and every subsequent string in the array. Return an array containing the sum of
				matching characters for each string, where each element at index i in the array corresponds to the sum
				of matching characters of the ith string with every subsequent string.
				Two characters are considered matching if they are the same and occur at the same index in both
				strings. If the length of the two strings being compared is not equal, only check up to the length of the
				shorter string.
				Example - "geeksfor" and "recks" are matching at indices 2,4,5 (1-based). Therefore matching count of
				these two strings is 3.
				Example 1:
				Input:
				N = 3
				X = {"abc", "ade", "bbc"}
				Output: [3, 0, 0]
				Explanation:
				For String "abc"(i = 1), the subsequent strings are "ade" and "bbc". The matching characters
				of "abc" with "ade" is 1 which is 'a' at index 1 and the matching characters of "abc" with
				"bbc" is 2 which are 'b' and 'c' at index 2 and 3. The answer for "abc" is 1 + 2 = 3
				For String "ade"(i = 2), the subsequent string is "bbc". The matching characters of "ade"
				with "bbc' is 0. The answer for "ade" is 0.
				For String "bbc"(i = 3), there are no subsequent strings. The answer for "bbc" is O.
				We can note that the answer for the last string in the input array will always be 0 as
				there are no subsequent strings.

				Example 2:
				Input:
				N = 3
				X = {"abc", "ade", "abc"}
				Output: [4, 1, 0]
				Explanation: |
				For String "abc"(i = 1), the subsequent strings are "ade" and "abc". The matching characters
				of "abc" with "ade" is 1 which is 'a' at index 1 and the matching characters of "abc" with
				"abc" is 3. The answer for "abc" is 1 + 3 = 4
				For String "ade"(i = 2), the subsequent string is "abc". The matching characters of "ade"
				with "abc' is 1. The answer for "ade" is 1.
				For String "abc"(i = 3), there are no subsequent strings. The answer for "abc" is O.
				Your Task:
					You don't need to read input or print anything. Your task is to complete the function
					matchingCnt() which takes the integers n and a String array X] and returns an integer array
					with the sum of matching characters for each string with the subsequent strings in the input
					array.
				Constraints:
					• 1 ≤ N ≤ 2 * 10^5
					• Each String consists of lowercase English letters.
					• Sum of lengths of Strings in String array(X[]) is ≤ 2 * 10^5

			// Not Optimized:
				class Solution {
					public:
					int counter(string s1, string s2){
						int i=0, minI = min(s1.size(), s2.size());
						
						int cnt = 0;
						while(i < minI){
							if(s1[i] == s2[i])
								cnt++;
							i++;
						}
						return cnt;
					}
					vector<int> matchingCnt(int n, vector<string>& X) {
						vector<int> ans (n, 0);
						
						for(int i=0; i<n-1; i++){
							string cur = X[i];
							int cnt =0;
							for(int j=i+1; j<n; j++){
								string nxt = X[j];
								
								cnt += counter(cur, nxt);
							}
							ans[i] = cnt;
						}
						
						return ans;
					}
				};
		
			// Optimized:
				❌Pending

	860) Modular Exponentiation for large numbers:
		Problem Statement:
			Implement pow(x, n) % M.
			In other words, for a given value of x, n, and M, find  (xn) % M.
			Example 1:
				Input:
				x = 3, n = 2, m = 4
				Output:
				1
				Explanation:
				32 = 9. 9 % 4 = 1.

			Example 2:
				Input:
				x = 2, n = 6, m = 10
				Output:
				4
				Explanation:
				26 = 64. 64 % 10 = 4.

			Your Task:
				You don't need to read or print anything. Your task is to complete the function PowMod() which takes integers x, n, and M as input parameters and returns xn % M.

			Expected Time Complexity: O(log(n))
			Expected Space Complexity: O(1)
		
			Constraints:
				1 ≤ x, n, M ≤ 10^9

		// Not Optimized:
			class Solution {
				public:
				long long int PowMod(long long int x,long long int n,long long int M) {
					long long int temp = x;
					for(int i=1; i<n; i++)
						x = (x * temp) % M;
					return x % M;
				}
			};
		
		// Optimized (Binary Exponential)
			class Solution {
				public:
				long long int PowMod(long long int x,long long int n,long long int M) {
					long long int temp = 1;
					
					while(n){
						if(n&1){
							temp = (temp * x) % M;
							n--;
						}
						x = (x*x)%M;
						n /=2;
					}
					return temp % M;
				}
			};

	861) Sum of All Subset XOR Totals:
		Problem Statement:
			The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.
			For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
			Given an array nums, return the sum of all XOR totals for every subset of nums. 
			Note: Subsets with the same elements should be counted multiple times.
			An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.
			
			Example 1:
			Input: nums = [1,3]
			Output: 6
			Explanation: The 4 subsets of [1,3] are:
			- The empty subset has an XOR total of 0.
			- [1] has an XOR total of 1.
			- [3] has an XOR total of 3.
			- [1,3] has an XOR total of 1 XOR 3 = 2.
			0 + 1 + 3 + 2 = 6

			Example 2:
			Input: nums = [5,1,6]
			Output: 28
			Explanation: The 8 subsets of [5,1,6] are:
			- The empty subset has an XOR total of 0.
			- [5] has an XOR total of 5.
			- [1] has an XOR total of 1.
			- [6] has an XOR total of 6.
			- [5,1] has an XOR total of 5 XOR 1 = 4.
			- [5,6] has an XOR total of 5 XOR 6 = 3.
			- [1,6] has an XOR total of 1 XOR 6 = 7.
			- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
			0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

			Example 3:
				Input: nums = [3,4,5,6,7,8]
				Output: 480
				Explanation: The sum of all XOR totals for every subset is 480.
			

			Constraints:
				1 <= nums.length <= 12
				1 <= nums[i] <= 20

		void solve(vector<int> &n, vector<vector<int>> &hold, vector<int>temp, int i){
			if(i == n.size()){
				hold.push_back(temp);
				return ;
			}

			// include call
			temp.push_back(n[i]);
			solve(n, hold, temp, i+1);

			// exclude call
			temp.pop_back();
			solve(n, hold, temp, i+1);
		}
		class Solution {
			public:
			int subsetXORSum(vector<int>& nums) {
				vector<vector<int>> hold;
				vector<int> temp;
				solve(nums, hold, temp, 0);

				int total = 0;
				for(int i=0; i<hold.size(); i++){
					if(hold[i].size() == 1){
						total += hold[i][0];
					}else{
						int x = 0;
						for(int j=0; j<hold[i].size(); j++)
							x ^= (hold[i][j]);

						total += x;
					}
				}
				return total;
			}
		};
			
	862) Odd Before Even:
		Problem statement
			You are given two sorted linked lists of length ‘N1’ and ‘N2’ respectively. Your task is to create a linked list with common elements such that all common odd elements are before common even elements.
			Note: The relative order inside both the even and odd groups should remain as it was in the input.
			You just need to return the head of the new linked list formed, don't print the elements.
			Constraints:
				1 <= T <= 5
				0 <= N <= 5 * 10 ^ 6
				1 <= nodeVal[i] <= 10 ^ 9
				Time Limit: 1 sec.
			Sample Input 1:
				2
				1 2 3 4 5 7 8 -1
				2 4 4 7 8 10 -1
				1 2 7 10 20 23 -1
				2 7 23 -1
				Sample Output 1:
				7 2 4 8
				7 23 2
				Explanation of Sample Input 1:
				In the first test case, the common elements are {2, 4, 7, 8 }. So the elements of the new linked list is 7 -> 2 -> 4 -> 8 -> NULL as odd will come before even maintaining the relative order.
				In the second test case, the common elements are {2, 7, 23 }. So the elements of the new linked list is 7 -> 23 -> 2 -> NULL as odd will come before even maintaining the relative order..
				Sample Input 2:
				2
				10 11 12 -1
				1 2 8 9 10 12 12 -1
				1 2 3 3 4 -1
				1 2 3 4 -1
				Sample Output 2:
				10 12
				1 3 2  4

		// Not Optimized:
			#include <bits/stdc++.h> 
			/****************************************************************
				Following is the Linked list node structure already written
				template <typename T>
				class LinkedListNode {
					public:
						T data;
						LinkedListNode<T>* next;
					LinkedListNode(T data) {
						this->data = data;
						next = NULL;
					}
				};
			*****************************************************************/
			LinkedListNode<int>* commonOddEven(LinkedListNode<int> *head1, LinkedListNode<int> *head2){
				LinkedListNode<int>* ansHead = NULL;
				LinkedListNode<int>* Tail = NULL;

				LinkedListNode<int>* headHolder = head1;
				LinkedListNode<int>* headHolder2 = head1;

				while(head1 && head2){
					if(head1 -> data == head2 -> data){
						if(ansHead == nullptr){
							ansHead = head2;
							Tail = head2;
							
						}else{
							Tail -> next = head2;
							Tail = head2;
						}
						head1 = head1 -> next;
						head2 = head2 -> next;

					}else if((head1 -> data) < (head2 -> data)){
						head1 = head1 -> next;
					}else{
						head2 = head2 -> next;
					}
				}

				if(Tail != NULL)
					Tail -> next = nullptr;
				else{
					return nullptr;
				}

				LinkedListNode<int>* temp1 = ansHead;
				LinkedListNode<int>* temp2 = ansHead;
				LinkedListNode<int>* temp3 = ansHead;

				vector<int> v;
				while(temp1){
					if((temp1 -> data)&1)
						v.push_back(temp1->data);
					temp1 = temp1 -> next;
				}  

				while(temp2){
					if(!((temp2 -> data)&1))
						v.push_back(temp2->data);
					temp2 = temp2 -> next;
				}

				int n = v.size(), i=0;
				while(i < n){
					temp3 -> data = v[i++];
					temp3 = temp3 -> next;
				}
				return ansHead;
			}

		// Optimized:
			❌Pending
	
	863) Excel Sheet | Part-2:
		Problem statement
			You are given a string STR representing the column title in an Excel Sheet. You need to find its corresponding column number.
			For example: A corresponds to 1, B to 2, C to 3, … , Z to 26, AA to 27, .. and so on.
			Constraints:
				1 ≤ T ≤ 50
				1 ≤ |STR| ≤ 12
				where 'T' denotes number of testcases, and |STR| denotes the length of the string.
				Time Limit : 1 sec 
			Sample Input 1:
				3
				A
				AB
				F
				Sample Output 1:
				1
				28
				6
				Explanation of Input 1:
				The first test case, STR = “A”. This corresponds to column number 1.

				The second test case, STR = “AB”. This corresponds to column number 28.

				The third test case, STR = “F”. This corresponds to column number 6.
				Sample Input 2:
				3
				AZ
				COD
				ZZZ
				Sample Output 2
				52
				2422
				18278

		#include <bits/stdc++.h> 
		long long titleToNumber(string str) {
			long long ans =0;
			map<char, int> mapping = {
												{'A', 1}, {'B', 2}, {'C', 3}, {'D', 4},
												{'E', 5}, {'F', 6}, {'G', 7}, {'H', 8}, 
												{'I', 9}, {'J', 10}, {'K', 11}, {'L', 12}, 
												{'M', 13}, {'N', 14}, {'O', 15}, {'P', 16}, 
												{'Q', 17}, {'R', 18}, {'S', 19}, {'T', 20}, 
												{'U', 21}, {'V', 22}, {'W', 23}, {'X', 24}, 
												{'Y', 25}, {'Z', 26}
											};

			// if(str.size() == 1)
			//     return mapping[str[0]];
			// else if(str.size() == 2)
			//     return mapping[str[1]] + mapping[str[0]] * 26;

			long long place = 26;
			for(int i=str.size()-1; i>=0; i--){
				if(i == str.size()-1){
					ans += mapping[str[i]];
				}else{
					ans += mapping[str[i]] * place;
					place *= 26;
				}        
			}
			return ans;
		}

		// Simpler:
			#include <bits/stdc++.h> 
			long long titleToNumber(string str) {
				long long ans =0;

				for(auto s: str) {						// for(char s: str){
					ans *= 26;
					ans += s - 'A' + 1;
				}
				return ans;
			}
	
	864) Excel Column Number:
		Problem statement
			You have been given a column title as appears in an Excel sheet, return its corresponding column number.
			For example:
			A -> 1
			B -> 2
			C -> 3
			...
			Z -> 26
			AA -> 27
			AB -> 28 
			...
			Constraints:
				1 <= |S| <= 10
				Input contains only uppercase English Alphabet letters

				Time Limit : 1 sec
			Output Format
			The only line of output will print the column number corresponding to given column title 
			Sample Input 1
			AB
			Sample Output 1
			28
			Sample Input 2
			ZZZ
			Sample Output 2
			18278

		long long excelColumnNumber(string input) {
			long long ans =0;
			for(char ch: input)
				ans = ans*26 + (ch - 'A' + 1);

			return ans;
		}
	
	866) Excel Sheet Column Number:
		Problem Statement:
			Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.
			For example:
			A -> 1
			B -> 2
			C -> 3
			...
			Z -> 26
			AA -> 27
			AB -> 28 
			...

			Example 1:
				Input: columnTitle = "A"
				Output: 1

			Example 2:
				Input: columnTitle = "AB"
				Output: 28

			Example 3:
				Input: columnTitle = "ZY"
				Output: 701
			
			Constraints:
				1 <= columnTitle.length <= 7
				columnTitle consists only of uppercase English letters.
				columnTitle is in the range ["A", "FXSHRXW"].

		class Solution {
			public:
			int titleToNumber(string columnTitle) {
				int ans = 0;

				for(char ch: columnTitle)
					ans = (ans*26)  + (ch - 'A' + 1);

				return ans;
			}
		};

	867) Excel Sheet | Part - 2:
		Problem Statement:
			Given a string S that represents column title of an Excel sheet, find the number that represents that column.
			In excel A column is number 1, AA is 27 and so on.

			Example 1:
				Input:
				S = A
				Output: 1

			Example 2:
				Input:
				S = AA
				Output: 27
			Your Task:
				Complete the function ExcelColumnNumber() which takes a string as input and returns an integer.
			Expected Time Complexity: O(|S|)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ |S| <=7

		class Solution{
			public:
			int ExcelColumnNumber(string s) {
				int ans = 0;
				
				for(char ch: s){
					int val = ch - 'A' + 1;
					ans *= 26;
					ans += val;
				}
				return ans;
			}
		};

	865) Multigram
		Problem statement
			Pero is a passionate lover of riddles. The newest type of riddles he has come
			across requires the solver to check whether the given word is a multigram.
			A multigram is a word that consists of concatenating two or more words that
			are all mutually anagrams. The first of these words is called the root of the
			multigram. For instance, the word bbabab is a multigram with the root bba
			because it consists of anagrams bba and bab.
			Help Pero solve the riddle by determining whether his word is a multigram and
			determining its root in case it is. If there are multiple possible roots of the
			multigram, output the shortest.
			Please note: Two words are mutually anagrams if one of them can be obtained
			from the other by changing the letter order

			Constraints:
				length of word is at most 100000.
				Time limit: 1 sec

			Input Format:
				The first and only line of input contains a word of length at most 100000
				lowercase English characters.

			Output Format:
				If the given word is not a multigram, output -1.
				Otherwise, output the shortest root of the given word in one line.
			Sample Input 1:
			aaaa
			Sample Output 1:
			a

			Sample Input 2:
			ab
			Sample Output 2:
			-1
		
		// Not Optimized:
			#include<bits/stdc++.h>
			using namespace std;
			bool checkAreTheyEqual(vector<string>& h){
				for(int i=0; i<h.size()-1; i++){
					string s1 = h[i];
					string s2 = h[i+1];

					sort(s1.begin(), s1.end());
					sort(s2.begin(), s2.end());

					if(s1 != s2)
						return 0;
				}
				return 1;
			}

			int main() {
				string out = "-1";

				string s;
				cin>>s;

				//checking every subsequence
				for(int i=1; i <= s.size(); i++){
					vector<string> hold;
					for(int j=0; j <= s.size() - i; j+=i){
						string cur = s.substr(j, i);
						hold.push_back(cur);
					}
					if(checkAreTheyEqual(hold)){
						out = hold[0];
						break;
					}
				}

				cout<<out<<endl;
				return 0;
			}
	
		// Optimized:
			❌Pending
	
	868) K-Palindrome:
		Problem Statement:
			Given a string str of length n, find if the string is K-Palindrome or not. A k-palindrome string transforms into a palindrome on removing at most k characters from it.
			Example 1:
			Input: str = "abcdecba"
			n = 8, k = 1
			Output: 1
			Explaination: By removing 'd' or 'e' 
			we can make it a palindrome.

			Example 2:
			Input: str = "abcdefcba"
			n = 9, k = 1
			Output: 0
			Explaination: By removing a single 
			character we cannot make it a palindrome.

			Your Task:
				You do not need to read input or print anything. Your task is to complete the function kPalindrome() which takes string str, n, and k as input parameters and returns 1 if str is a K-palindrome else returns 0.


			Expected Time Complexity: O(n*n)
			Expected Auxiliary Space: O(n*n)


			Constraints:
				1 ≤ n, k ≤ 10^3

		// Not Optimized:
			class Solution{
				public:
				bool solve(string s, int k){
					int i=0, j=s.size()-1;
					
					while(i < j){
						if(s[i] != s[j] && k <= 0){
							return 0;
						}else if(s[i] != s[j]){
							k--;
							
							// left side
							string t1 = s;
							t1.erase(t1.begin() + i);
							if(solve(t1, k))
								return 1;
							
							// right side
							string t2 = s;
							t2.erase(t2.begin() + j);
							if(solve(t2, k))
								return 1;
						}
						i++,j--;
					}
					return 1;
				}
				
				int kPalindrome(string str, int n, int k) {
					int i=0, j = n-1;
					while(i < j && k) {
						if(str[i] != str[j]) {
							k--;
							
							// left side
							string t1 = str;
							t1.erase(t1.begin() + i);
							if(solve(t1, k))
								return 1;
							
							// right side
							string t2 = str;
							t2.erase(t2.begin() + j);
							if(solve(t2, k))
								return 1;
								
						}
						i++,j--;
					}
						
					i=0, j=n-1;
					while(i < j)
						if(str[i++] != str[j--])
							return 0;
					
					return 1;
				}
			};
	
		// Optimized:
			❌Pending

	#CN WeeklyContest-127:
		869) Jump string:
			Problem statement
				You are given a string ‘S’ of length ‘N’ where characters are numbered from ‘0’ to ‘N - 1’. Initially you have an empty string ‘K’ and you start at index ‘0’ of ‘S’ and proceed through the following steps until you reach the end of the string or beyond its boundary.
				If the current character is ‘*’, skip the character and move forward by ‘1’.
				If the current character is ‘#’, skip the character and move forward by ‘2’.
				Otherwise, append the character at the end of ‘K’ and move forward by ‘1’.
				You have to determine the resulting string ‘K’ formed by the given steps.
				Your task is to tell the string ‘K’ formed by the given steps and return it. Return “-1”, if the string ‘K’ is empty.
				Example:
				‘N’ = 5
				‘S’ = “a*#ck”
				Initially the string ‘K’ is “”.

				Step 1: You are at index ‘0’, and ‘S[0]’ is ‘a’.
				Append the character at the end of ‘K’, now ‘K’ becomes “a”.
				Move forward by ‘1’.

				Step 2: You are at index ‘1’ and ‘S[1]’ is ‘*’.
				Skip the character and move forward by ‘1’.

				Step ‘3’ You are at index ‘2’ and ‘S[2]’ is ‘#’.
				Skip the character and move forward by ‘2’.

				Step 4: You are at index ‘4’ and ‘S[4]’ is ‘k’.
				Append the character at the end of ‘K’, now ‘K’ becomes “ak”.

				The final string formed is “ak”.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					‘a’ <= ‘S[i]’ <= ‘z’ or ‘S[i]’ belongs to the set {‘*’, ‘#’}

					Time Limit: 1 sec 
				Sample Input 1:
					2
					4
					ff#h
					3
					*#*
					Sample Output 1:
					ff
					-1
					Explanation of sample input 1:
					For test case 1:
					Step 1: Append ‘f’ at the end of the string ‘K’ and move forward by ‘1’.
					Step 2: Append ‘f’ at the end of the string ‘K’ and move forward by ‘1’.
					Step 3: The current element is ‘#’, so skip the character and move forward by ‘2’.
					The final string formed is: “ff”.

					For test case 2:
					Step 1: The current element is ‘*’, so skip the character and move forward by ‘1’.
					Step 2: The current element is ‘#’, so skip the character and move forward by ‘2’.
					The final string ‘K’ is an empty string. So, the answer for this test case is “-1”.
					Sample Input 2:
					2
					5
					youkn 
					6
					pp#ppk
					Sample Output 2:
					youkn 
					pppk 

			string jumpString (int n, string &s) {
				string k;
				int i=0;
				
				while(i < n){
					if(s[i] == '*')
						i++;
					else if(s[i] == '#')
						i += 2;
					else
						k += s[i++];
				}

				return (k.size()) ? k : "-1";
			}
		
		870) Max Score: ❌Pending
			Problem statement
				You have two arrays ‘A’ and ‘B’ consisting of ‘N’ and ‘M’ numbers respectively. The compatibility score of the two arrays is the maximum possible value of ‘abs(X-Y)’ which is the absolute value of X-Y.
				'X' denotes a number shared by both arrays, while 'Y' represents a number unique to one of the arrays. If such numbers don't exist return -1.
				Example:
				‘A’ = [1, 2, 4, 1]
				‘B’ = [3, 2, 4]
				Return 3,
				X can be chosen as 4 as it is in both arrays.
				Y can be chosen as 1 as it is unique to array ‘A’.
				It can be shown that we can't obtain any value higher than 3 with any other values of X and Y.

				Constraints:
					1 <= 'T' <= 10
					1 <= ’N’,’M’ <= 10^5 
					1 <= ’A[i], B[i]’ <= 10^9 
					Time Limit: 1 sec
				Sample Input 1:
					2
					5 6
					6 2 7 7 5 
					2 4 7 6 2 2 
					7 4
					7 8 9 10 8 10 3 
					10 8 1 10 
					Sample Output 1:
					3
					9
					Explanation of sample input 1:
					For test case 1:
					X can be chosen as 7 as it is in both arrays.
					Y can be chosen as 4 as it is unique to array ‘B’.
					It can be shown that we can't obtain any value higher than 3 with any other values of X and Y.
					For test case 2:
					X can be chosen as 10 as it is in both arrays.
					Y can be chosen as 1 as it is unique to array ‘B’.
					It can be shown that we can't obtain any value higher than 9 with any other values of X and Y.
					Sample Input 2:
					3
					6 7
					1 7 4 6 1 2 
					1 4 1 1 7 7 4 
					6 7
					5 5 1 1 5 2 
					5 1 6 2 9 9 7 
					5 7
					2 3 2 10 8 
					2 2 2 9 10 3 1 
					Sample Output 2:
					5
					8
					9

			int score(vector<int> &a,vector<int> &b){
				set<int> ua (a.begin(), a.end());
				set<int> ub (b.begin(), b.end());

				map<int, int> mp;
				for(auto i: ua)
					mp[i]++;
				
				for(auto i: ub)
					mp[i]++;

				int min1, min2;
				min1 = min2 = 1e9+1;          // to find the min elements

				int mx1, mx2;
				mx1 = mx2 = 0;                  // to find the max elements

				for(auto i: mp){
					if(i.second == 1) {
						min1 = min(min1, i.first);
						mx1 = max(mx1, i.first);
					}else {
						min2 = min(min2, i.first);
						mx2 = max(mx2, i.first);
					}
				}
				if(mx1 == 0 || mx2 == 0) 
					return -1;  
				return max(mx1-min2, mx2 - min1);
			}

	871) Different Bits Sum Pairwise:
		Problem statement
			You are given an arbitrary array ‘arr’ consisting of 'N' non-negative integers. You need to find the sum of bit differences of all the pairs that can be formed in the given array.
			In simple words, let us define f(x, y) as the count of different bits at the same position in the binary representations of two integers, x and y.
			You need to find the summation of f over all possible values of x and y in the input array I.e sum( f(arr[i], arr[j])) for all 0 <= i < N and 0 <= j < N.
			For Example :
			f(2, 3) = 1, as 2 → 0010 and 3 → 0011, only the last bit is different in both the numbers, hence f(2, 3) is 1.
			Note :
			As the final answer may be very large, return your answer modulo 10^9 + 7.
			Constraints :
				1 <= T <= 100
				1 <= N <= 10^4
				0 <= arr[i] < 10^9
				Time Limit: 1sec

			Sample Input 1 :
				2
				2
				1 2
				2
				6 6
				Sample Output 1 :
				4
				0
				Explanation for Sample Input 1 :
				Test Case 1:
				All the possible pairs in the given array are:-
				f(1, 1) - as both numbers are same, no. of bit differences is 0
				f(1, 2) - 1 in binary is (0001) and 2 in binary is (0010). There are 2 bits which are different in both the numbers. Hence, no. of bit differences is 2.
				f(2, 2) - as both numbers are the same, no, of bit differences is 0
				f(2, 1) - same as (1, 2), hence no. of bit differences is 2.
				Summing the above values (0+2+0+2) we get 4. Hence, the output is 4.

				Test Case 2:
				There is only one possible pair (6,6). As both the numbers are sum, the output is 0.
				Sample Input 2 :
				2
				3 
				1 3 5
				4
				4 6 7 8
				Sample Output 2 :
				8
				26
		
		// Not Optimized:
			#include <bits/stdc++.h> 
			int cnt(int a, int b){
				int z=0;
				while(a || b){
					if((a & 1) != (b  & 1))
						z++;
						
					a >>= 1;
					b >>= 1;
				}

				return z;
			}

			int differentBitsSumPairwise(vector<int> &arr, int n) {
				int ans =0, mod = 1e9+7;

				map<pair<int, int>, int> keyValuePair;
				for(int i=0; i<n; i++){
					for(int j=0; j<n; j++){
						int diff;
						if((keyValuePair.find({arr[i], arr[j]}) != keyValuePair.end()))
							diff = keyValuePair[{arr[i], arr[j]}];
						else if(keyValuePair.find({arr[j], arr[i]}) != keyValuePair.end())
							diff = keyValuePair[{arr[j], arr[i]}];
						else{
							diff = cnt(arr[i], arr[j]);
							keyValuePair[{arr[i], arr[j]}] = diff;
						}
						ans = (ans + diff) % mod;
					}
				}
				return ans % mod;
			}

			// Or
			#include <bits/stdc++.h> 
			int countDiff(int a, int b){
				int cnt = 0;
				while(a || b){
					if((a & 1) != (b & 1))
						cnt++;
					
					a >>= 1;
					b >>= 1;
				}
				return cnt;
			}

			int differentBitsSumPairwise(vector<int> &arr, int n) {
				int mod = 1e9+7;
				int ans =0;

				for(int i=0; i<n; i++){
					for(int j=0; j<n; j++){
						int diffCnt = countDiff(arr[i], arr[j]);
						ans = (ans + diffCnt) % mod;
					}
				}
				return ans % mod;
			}

		// Optimized:
			❌Pending (bit manipulation)

	872) Check If One String Is A Rotation Of Another String:
		Problem statement
			You are given two Strings 'P' and 'Q' of equal length.
			Your task is to return 1 if String 'P' can be converted into String 'Q' by cyclically rotating it to the right any number of times ( Possibly Zero ), else return 0.
			A cyclic rotation to the right on String 'A' consists of taking String 'A' and moving the rightmost character to the leftmost position. For example, if 'A' = "pqrst", then it will be "tpqrs" after one cyclic rotation on 'A'.
			For example:
			Consider the two strings 'P' = "abfyg" and 'Q' = "gabfy" 
			If we cyclically rotate String 'P' to the right once. The resulting string P becomes "gabfy" which is equal to String 'Q'. 
			Therefore it is possible to convert String 'P' to String 'Q'.

			Sample Input 1:
			abac
			baca
			Sample Output 1:
			1
			Explanation For Sample Input 1:
			Let's try rotating the String 'P' to the right and try all the possible rotations:
			1) If we rotate "abac" to the right, the resulting string becomes "caba".
			2) If we rotate "caba" to the right, the resulting string becomes "acab".
			3) If we rotate "acab" to the right, the resulting string becomes "baca" which is equal to String 'Q'.
			Therefore it is possible to convert String 'P' to String 'Q'. Hence, we will return 1 in this case.
			Sample Input 2:
			aabca
			bacaa
			Sample Output 2:
			0
			Constraints:
				1 <= |P| , |Q| <= 10^5
				|P| = |Q|
				String 'P' and 'Q' have the same length and contain only lowercase English letters.
				Time Limit: 1 sec
			Follow Up:
				Can you solve this in O(N) time?

		// Not Optimized:
			int isCyclicRotation(string &p, string &q) {
				if(p == q)
					return 1;
					
				int val = p.size()-1;
				for(int i=0; i<val; i++){
					char ch = p[0];
					p.erase(p.begin());
					p += ch;
					if(p == q)
						return 1;
				}
				return 0;
			}

		// Optimized:
			❌Pending

	873) You and your books:
		Problem Statement:
			You have n stacks of books. Each stack of books has some nonzero height arr[i] equal to the number of books on that stack ( considering all the books are identical and each book has a height of 1 unit ). In one move, you can select any number of consecutive stacks of books such that the height of each selected stack of books arr[i] <= k. Once such a sequence of stacks is chosen, You can collect any number of books from the chosen sequence of stacks.
			What is the maximum number of books that you can collect this way?
			Example 1
			Input
			8 1
			3 2 2 3 1 1 1 3
			Output
			3
			Explanation 
			We can collect maximum books from consecutive stacks numbered 5, 6, and 7 having height less than equal to K.

			Example 2
			Input
			8 2
			3 2 2 3 1 1 1 3
			Output
			4
			Explanation
			We can collect maximum books from consecutive stacks numbered 2 and 3 having height less than equal to K.

			Your Task:
				You don't have to read input or print anything. Your task is to complete the function max_Books() which takes the integer arr, n, and k returns the maximum number of books you can collect.

			Expected Time Complexity: O(n)
			Expected Space Complexity: O(1)

			Constraints:
				1 <= n <= 10^5
				1 <= k <= 10^9
				1 <= arr[i] <= 10^9

		class Solution {
			public:
			/*You are requried to complete this method */
			long long max_Books(int arr[], int n, int k) {
				long long ans = 0, cur = 0;
				for(int i=0; i<n; i++){
					if(arr[i] <= k){
						cur += arr[i];
					}else{
						cur = 0;
					}
					ans = max(ans, cur);
				}
				return ans;
			}
		};
	
	#AtCoder BeginnerContest-355:
		874) A - Who Ate the Cake?:
			https://atcoder.jp/contests/abc355/tasks/abc355_a
			Problem Statement
				Takahashi's cake has been eaten by someone. There are three suspects: person 1, person 2, and person 3.
				There are two witnesses, Ringo and Snuke. Ringo remembers that person A is not the culprit, and Snuke remembers that person B is not the culprit.
				Determine if the culprit can be uniquely identified based on the memories of the two witnesses. If the culprit can be identified, print the person's number.
				Constraints
					1 ≤ A,B ≤ 3
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:
				A B
				Output
				If the culprit can be uniquely identified based on the memories of the two witnesses, print the person's number; otherwise, print -1.
				Sample Input 1
				1 2
				Sample Output 1
				3
				From the memories of the two witnesses, it can be determined that person 
				3 is the culprit.

				Sample Input 2
				1 1
				Sample Output 2
				-1
				From the memories of the two witnesses, it cannot be determined whether person 2 or person 3 is the culprit. Therefore, print -1.
				Sample Input 3
				3 1
				Sample Output 3
				2

			#include <iostream>
			using namespace std;
			int main() {
				int a,b;
				
				cin>>a>>b;
				
				if(a==b)
					cout<<-1;
				else{
					if((a == 1 && b == 2) || (a == 2 && b == 1))
						cout<<3;
					else if((a == 1 && b == 3) || (a == 3 && b == 1))
						cout<<2;
					else
						cout<<1;
				}
				return 0;
			}		
		
		875) B - Piano 2:
			https://atcoder.jp/contests/abc355/tasks/abc355_b
			Problem Statement
				You are given a sequence A=(A1, A2​, …, AN) of length N and a sequence 
				B=(B1, B2,…,BM) of length M. Here, all elements of A and B are pairwise distinct. Determine whether the sequence 
				C=(C1,C2,…,CN+M) formed by sorting all elements of A and B in ascending order contains two consecutive elements appearing in A.
				Constraints
					1 ≤ N,M ≤ 100
					1 ≤ Ai,Bj ≤ 200
					A1​, A2​, …, AN, B1, B2, …, BM are distinct.
					All input values are integers.
				Input
					The input is given from Standard Input in the following format:
					N M
					A1​ A2​ … AN
					​B1 B2 … BM
				Output
					If C contains two consecutive elements appearing in A, print Yes; otherwise, print No.

				Sample Input 1
					3 2
					3 2 5
					4 1
					Sample Output 1
					Yes
					C=(1,2,3,4,5). Since 
					2 and 
					3 from 
					A occur consecutively in 
					C, print Yes.

					Sample Input 2
					3 2
					3 1 5
					4 2
					Sample Output 2
					No
					C=(1,2,3,4,5). Since no two elements from 
					A occur consecutively in 
					C, print No.

					Sample Input 3
					1 1
					1
					2
					Sample Output 3
					No

			#include <iostream>
			#include<vector>
			#include<algorithm>
			using namespace std;
			int main() {
				int n, m;
				cin>>n>>m;
				
				vector<int> A(n);
				vector<int> B(m);
				
				for(int i=0; i<n; i++)
					cin>>A[i];
					
				for(int i=0; i<m; i++)
					cin>>B[i];
					
				if(A.size() == 1){
					cout<<"No";
					return 0;
				}
				
				sort(A.begin(), A.end());
				sort(B.begin(), B.end());
				
				int s = A.size();
				for(int i=0; i<(s-1); i++){
					int start = A[i], end = A[i+1];
					vector<int> test;
					
					for(int z = start; z <= end; z++)
						test.push_back(z);
					
					int s2 = test.size();
					int flag = 1;
					for(int x=0; x<s2; x++)
						if(find(B.begin(), B.end(), test[x]) != B.end()){
							flag = 0;
						}
					
					if(flag){
						cout<<"Yes";
						return 0;
					}
				}
				cout<<"No";
				return 0;
			}

		876) C - Bingo 2:
			https://atcoder.jp/contests/abc355/tasks/abc355_c
			Problem Statement
				There is an N×N grid, where the cell at the i-th row from the top and the j-th column from the left contains the integer N×(i−1)+j.
				Over T turns, integers will be announced. On Turn i, the integer Ai​ is announced, and the cell containing Ai is marked. Determine the turn on which Bingo is achieved for the first time. If Bingo is not achieved within T turns, print -1.
				Here, achieving Bingo means satisfying at least one of the following conditions:

				There exists a row in which all 
				N cells are marked.
				There exists a column in which all 
				N cells are marked.
				There exists a diagonal line (from top-left to bottom-right or from top-right to bottom-left) in which all 
				N cells are marked.
				Constraints
					2≤N≤2×10 
					3
					
					1≤T≤min(N^2,2×10^5)
					1≤Ai≤N^2
					Ai != Aj if i != j.
					All input values are integers.
				Input
					The input is given from Standard Input in the following format:
				N T
				A1 A2 … AT
				Output
				If Bingo is achieved within 
				T turns, print the turn number on which Bingo is achieved for the first time; otherwise, print -1.

				Sample Input 1
				3 5
				5 1 8 9 7
				Sample Output 1
				4
				The state of the grid changes as follows. Bingo is achieved for the first time on Turn 
				4.
				Sample Input 2
				3 5
				4 2 9 7 5
				Sample Output 2
				Copy
				-1
				Bingo is not achieved within five turns, so print -1.

				Sample Input 3
				4 12
				13 9 6 5 2 7 16 14 8 3 10 11
				Sample Output 3
				9

			// Not Optimized:
				#include <iostream>
				#include<vector>
				using namespace std;

				bool checkIsBingo(vector<vector<int>> &v, int n){
					
					// for(auto &out: v){
					//     for(int i: out)
					//         cout<<i<<"\t";
					//     cout<<"\n";
					// }
					
					// check any column which is completely zero
					for(int i=0; i<n; i++){
						int cnt=0;
						for(int j=0; j<n; j++){
							if(v[j][i] == 0)
								cnt++;
						}
						if(cnt == n)
							return 1;
					}
					
					// check any row which is completely zero
						for(int i=0; i<n; i++){
						int cnt=0;
						for(int j=0; j<n; j++){
							if(v[i][j] == 0)
								cnt++;
						}
						if(cnt == n)
							return 1;
					}
					
					// check top-left to bottom-right diagonal which is completely zero
					int cnt = 0;
					for(int i=0; i<n; i++){
						if(v[i][i] == 0)
							cnt++;
					}
					if(cnt == n)
						return 1;
					
					// check top-left to bottom-right diagonal which is completely zero
					cnt =0;
					int var = n-1;
					
					for(int i=0; i<n; i++)
						if(v[i][var--] == 0)
							cnt++;
					
					if(cnt == n)
						return 1;
					
					return 0;
				}

				int main() {
					int N, T;
					
					cin>>N>>T;
					
					if(T < N){
						std::cout << -1;
						return 0;
					}
					
					vector<vector<int>> v(N, vector<int>(N));
					int cnt = 1;
					
					for(int i=0; i<N; i++)
						for(int j=0; j<N; j++)
							v[i][j] = cnt++;
					
					vector<int> input(T);
					for(int i=0; i<T; i++)
						cin>>input[i];
					
					int Turn = 0;
					for(int i=0; i<T; i++){
						Turn++;
						
						// index where input[i] matches replacing it with zero, searching index
						for(int x=0; x<N; x++){
							int flag = 0;
							for(int y=0; y<N; y++){
								if(v[x][y] == input[i]){
									v[x][y] = 0;
									flag = 1;
									break;
								}
							}
							if(flag)
								break;
						}
						
						if(Turn >= N && checkIsBingo(v, N)){
							cout<< Turn;
							return 0;
						}
					}
					// Bingo not possible
					std::cout << -1 << std::endl;
					return 0;
				}

			// Optimised:
				❌Pending
		
	#LeetCode BiweeklyContest-131:
		877) Find the XOR of Numbers Which Appear Twice:
			Problem Statement:
				You are given an array nums, where each number in the array appears either once or twice.
				Return the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.
				Example 1:
				Input: nums = [1,2,1,3]
				Output: 1
				Explanation:
				The only number that appears twice in nums is 1.
				Example 2:
				Input: nums = [1,2,3]
				Output: 0
				Explanation:
				No number appears twice in nums.
				Example 3:
				Input: nums = [1,2,2,1]
				Output: 3
				Explanation:
				Numbers 1 and 2 appeared twice. 1 XOR 2 == 3.
				Constraints:
					1 <= nums.length <= 50
					1 <= nums[i] <= 50
					Each number in nums appears either once or twice.

			class Solution {
				public:
				int duplicateNumbersXOR(vector<int>& nums) {
					vector<int> twice;
					map<int, int> Fr;
					for(int i: nums)
						Fr[i]++;
					
					for(auto i: Fr)
						if(i.second == 2)
							twice.push_back(i.first);
					
					int ans = 0;
					for(int i: twice)
						ans ^= i;
					return ans;
				}
			};

			//or Advance:
				class Solution {
					public:
					int duplicateNumbersXOR(vector<int>& nums) {
						unordered_set<int> s(begin(nums), end(nums));
						return accumulate(begin(nums), end(nums), accumulate(begin(s), end(s), 0, bit_xor{}), bit_xor{});
					}
				};
		
		878) Find Occurrences of an Element in an Array:
			Problem Statement:
				You are given an integer array nums, an integer array queries, and an integer x.
				For each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.
				Return an integer array answer containing the answers to all queries.
				
				Example 1:
				Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
				Output: [0,-1,2,-1]
				Explanation:
				For the 1st query, the first occurrence of 1 is at index 0.
				For the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.
				For the 3rd query, the second occurrence of 1 is at index 2.
				For the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.

				Example 2:
				Input: nums = [1,2,3], queries = [10], x = 5
				Output: [-1]
				Explanation:
				For the 1st query, 5 doesn't exist in nums, so the answer is -1.
		
				Constraints:
					1 <= nums.length, queries.length <= 10^5
					1 <= queries[i] <= 10^5
					1 <= nums[i], x <= 10^4

			// Not Optimized:
				class Solution {
					public:
					vector<int> occurrencesOfElement(vector<int>& nums, vector<int>& queries, int x) {
						int countOfX=0;
						for(int i: nums)
							if(i == x)
								countOfX++;
						
						int n = queries.size();
						vector<int> ans(n, -1);
						for(int i=0; i<n; i++){
							if(queries[i] > countOfX)
								continue;
							
							int curCnt =0, index=0;
							for(int j: nums){
								if(j == x)
									curCnt++;
								
								if(curCnt == queries[i])
									break;
								index++;
							}
							ans[i] = index;
						}
						return ans;
					}
				};
			
			// Optimized: ❌Pending
				class Solution {
					public:
					vector<int> occurrencesOfElement(vector<int>& nums, vector<int>& queries, int x) {
						vector<int> ans, index;
						int curIndex=0;
						for(int i: nums){
							if(i == x)
								index.push_back(curIndex);
							curIndex++;
						}

						for(auto q: queries){
							int val;
							if(q-1 < index.size()){
								val = index[q-1];
							}else{
								val = -1;
							}
							ans.push_back(val);
						}
						return ans;
					}
				};

	#LeetCode WeeklyContest-399:
		879) Find the Number of Good Pairs I:
			Problem Statement:
				You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
				A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
				Return the total number of good pairs.
				Example 1:
				Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
				Output: 5
				Explanation:
				The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

				Example 2:
				Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
				Output: 2
				Explanation:
				The 2 good pairs are (3, 0) and (3, 1).
		
				Constraints:
					1 <= n, m <= 50
					1 <= nums1[i], nums2[j] <= 50
					1 <= k <= 50

			class Solution {
				public:
				int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
					int cnt=0;
					
					for(int i=0; i<nums1.size(); i++){
						for(int j=0; j<nums2.size(); j++){
							int val = nums2[j]*k;
							if(nums1[i] % val == 0)
								cnt++;
						}
					}
					return cnt;
				}
			};

		880) String Compression III:
			Problem Statement:
				Given a string word, compress it using the following algorithm:
				Begin with an empty string comp. While word is not empty, use the following operation:
				Remove a maximum length prefix of word made of a single character c repeating at most 9 times.
				Append the length of the prefix followed by c to comp.
				Return the string comp.
				Example 1:
				Input: word = "abcde"
				Output: "1a1b1c1d1e"
				Explanation:
				Initially, comp = "". Apply the operation 5 times, choosing "a", "b", "c", "d", and "e" as the prefix in each operation.
				For each prefix, append "1" followed by the character to comp.

				Example 2:
				Input: word = "aaaaaaaaaaaaaabb"
				Output: "9a5a2b"
				Explanation:
				Initially, comp = "". Apply the operation 3 times, choosing "aaaaaaaaa", "aaaaa", and "bb" as the prefix in each operation.
				For prefix "aaaaaaaaa", append "9" followed by "a" to comp.
				For prefix "aaaaa", append "5" followed by "a" to comp.
				For prefix "bb", append "2" followed by "b" to comp.
			
				Constraints:
					1 <= word.length <= 2 * 10^5
					word consists only of lowercase English letters.

			class Solution {
				public:
				string compressedString(string word) {
					string comp;
					int cnt=1;
					for(int i=0; i<word.size()-1; i++){
						if(cnt == 9 || word[i] != word[i+1]){
							comp += to_string(cnt);
							comp += word[i];
							cnt=1;
						}else{
							cnt++;
						}
					}
					
					// inserting the count of the last char
					comp += to_string(cnt);
					comp += word.back();
					
					return comp;
				}
			};

			// Or
				class Solution {
					public:
					string compressedString(string word) {
						string ans;
						int i=0, n = word.size(), cnt=1;

						while(i < n-1){
							if(word[i] == word[i+1] && cnt < 9) cnt++;
							else{
								ans += to_string(cnt) + word[i];
								cnt = 1;
							}
							i++;
						}

						// including the last char
						ans += to_string(cnt) + word[i];
						return ans;
					}
				};
		
		881) Find the Number of Good Pairs II:
			Problem Statement:
				You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
				A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
				Return the total number of good pairs.

				Example 1:
				Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
				Output: 5
				Explanation:
				The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

				Example 2:
				Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
				Output: 2
				Explanation:
				The 2 good pairs are (3, 0) and (3, 1).
				
				Constraints:
					1 <= n, m <= 105^
					1 <= nums1[i], nums2[j] <= 10^6
					1 <= k <= 10^3

			// Not Optimized:
				class Solution {
					public:
					long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
						long long cnt = 0;
						int n = nums1.size(), m = nums2.size();
						
						for(int i=0; i<n; i++){
							for(int j=0; j<m; j++){
								int val = nums2[j] * k;
								if(nums1[i] % val == 0)
									cnt++;
							}
						}
						return cnt;
					}
				};
			
			// Optimized:
				❌Pending
		
	#GFG Weekly-156:
		882) Geekland Fair:
			Problem Statement:
				It is Geekland fair 2024, Geek and Geekina are enjoying the fair. They went to a juice shop in the fair.
				There are n types of juices each having k units of juice. If Geekina drinks x units of juice of any type,
				Geek drinks the remaining units (k-x) of that type. Given the units of juice drank by the Geekina in the
				array a, find the minimum value of k such that the sum of juices (total units of juice) drank by Geek is
				strictly greater than Geekina. Also ensure that the remaining units (k-x) of any juice that Geek drinks is
				always non-negative (k-x>=0).
				Example 1:
				Input:
				n = 8
				a = (5, 7, 4, 8, 10, 9, 0, 6}
				Output:
				13
				Explanation:
				It can be proven that 13 is the minimum value of k such that units drank by Geek is
				strictly greater than Geekina. Geek drinks 55 units and Geekina drinks 49 units.
				Example 2:
				Input:
				n = 4
				a = (1 1 1 8)
				Output:
				8
				Explanation:
				8 is the minimum value for k such that units drank by Geek is strictly greater than Geekina.
				Geek drinks 21 units and Geekina drinks 11 units.
				
				Your Task:
					You don't need to read input or print anything. Your task is to complete the function minimumK() which
					takes interger n and an array of integers a as an input and returns the minimum value of k.
				Constraints:
					1 <= n <= 10^5
					0 <= ai<= 10^9
		
			// Not Optimized:
				class Solution {
					public:
					long long minimumK(int n, vector<int> &a) {
						int minK = *max_element(a.begin(), a.end());
						long long sum = accumulate(a.begin(), a.end(), 0LL);
						long long curS = 0;
						
						while(curS < sum){
							for(int i: a)
								curS += abs(minK-i);
							
							// cout<<curS<<"\t";
							if(curS > sum)
								break;
							curS = 0;
							minK++;
						}
						return minK;
					}
				};
			
			// Optimized
				❌Pending

		883) Geekland Elections:
			Problem Statement:
				In 2024, the king of Geekland would be decided through the general elections. There are n persons in
				Geekland who would be voting. You are given a binary string s, where s; = '1' menas the ith person has
				voted for Geek and si = 'O' means ith person has voted against Geek. Geek has an ability to flip the votes
				of any person. But he can do this atmost k times. Given n, k and s answer whether Geek wins the
				election or not. Winning criteria is simple, get strictly more votes than the opponent.
				Example 1:
				Input:
				n = 8, k = 3, s = 10110001
				Output:
				1
				Explanation:
				Geek has 4 votes for him, he can flip any of the zeros to one and get 5 votes and his
				opponent gets only 3 votes.
				Example 2:
				Input:
				n = 8, k = 2, s = 10000001
				Output:
				0
				Explanation:
				Geek has 2 votes for him, he can flip any two zeros to ones but can only get 4 votes
				which are not enough to win the elections as per the criteria.
				Your Task:
					You don't need to read input or print anything. Your task is to complete the function geeklandElections()
				which takes intergers n and k and a string s an input and returns true or false depending on whether
				Geek wins or does not wins the election.
				Constraints:
					1 <= n <= 10^5
					0 <= k <= n
			
			class Solution {
				public:
				bool geeklandElections(int n, int k, string &s) {
					// count the no.of ones if no.of ones is already greater than zero then return 1
					// if both ones & zeros have same counts & k > 0 then return 1 else return 0
					int count1=0;
					for(char ch: s)
						if(ch == '1')
							count1++;
					
					int count0 = n - count1;
					if((count1 > count0) || (count1+k)>(count0-k))
						return 1;
					return 0;
				}
			};

	884) Count Even Or Odd:
		Problem statement
			Tanmay and Rohit are best buddies. One day Tanmay gives Rohit a problem to test his intelligence and skills. He gives him an array of N natural numbers and asks him to solve the following queries:-
			Query 0 :
			0 x y
			This operation modifies the element present at index x to y.

			Query 1 :
			1 x y 
			This operation counts the number of even numbers in range x to y inclusive.

			Query 2 :
			2 x y 
			This operation counts the number of odd numbers in range x to y inclusive.

			Constraints :
				1 <= N, Q <= 10^5
				0 <= l <=  r  <= N - 1 
				0 <= arr[i] <= 10 ^ 9
				1 <= x <= N
				0 <= y <= 10 ^ 9

			Where 'arr[i]' denotes the 'ith' element of arr.
			Time limit: 1 sec
			Note :
				You do not need to print anything, it has already been taken care of. Just implement the given function.
			Sample Input 1 :
			6
			1 2 3 4 5 6
			4
			1 1 4
			2 0 3
			0 4 4
			1 0 5
			Sample Output 1 :
			2
			2
			4
			Explanation Of Sample Input 1 :
			The first query consists of 1 1 4 .It means we have to count the number of even numbers from 1st index to 4th index. Hence even numbers in the given range are 2 and 4. So the answer for the first query is 2.So the answer is 2.
			The second query consists of 2 0 3. It means we have to count odd numbers from 0th index to 3rd index. Hence odd numbers in the given range are 1 and 3.So the answer is 2.
			The third query consists of 0 4 4. It means we have to modify the element at 4th index to 4. So the array becomes 1 2 3 4 4 6.
			The fourth query consists of 1 0 5 .It means we have to count even numbers from 0th index to 5th index. Hence even numbers in the given range are 2 4 4 6. So the answer is 4.
			Sample Input 2 :
			16
			525 327 227 725 833 860 255 803 625 766 200 383 712 935 422 937 
			9
			2 12 14
			1 14 15
			1 1 6
			1 10 15
			0 10 430
			2 2 12
			0 10 905
			2 4 10
			1 15 15
			Sample Output 2 :
			1
			1
			1
			3
			7
			5
			0

		vector<int> solve(int n, vector<int> &arr, int q, vector<vector<int>> &queries) {
			vector<int> ans;

			for(int i=0; i<q; i++){
				int decision = queries[i][0];
				if(decision == 0){
					arr[queries[i][1]] = queries[i][2];
				}else if(decision == 1){
					// even
					int cnt=0;
					int s = queries[i][1], e = queries[i][2];
					for(int z = s; z<=e; z++)
						if(arr[z] % 2 == 0)
							cnt++;
					ans.push_back(cnt);
				}else{
					// odd
					int cnt=0;
					int s = queries[i][1], e = queries[i][2];
					for(int z = s; z<=e; z++)
						if(arr[z]&1)
							cnt++;
					ans.push_back(cnt);
				}
			}
			return ans;
		}
	
	885) Ninja and Subarrays:
		Problem Statement:
			One day Ninja got an array and started to play with it. He is finding subarrays of the array randomly and suddenly starts to wonder about the maximum of the sum of the smallest and the second smallest elements of all the subarrays possible of size at least 2.
			For Example:
			For the array [3 2 1]
			All the subarrays of size at least 2 are:
			[3 2], [2 1], [3 2 1]
			For the first subarray, the smallest and second smallest elements are 2 and 3, and their sum is 5.
			For the second subarray, the smallest and second smallest elements are 1 and 2, and their sum is 3.
			For the third subarray, the smallest and second smallest elements are 1 and 2, and their sum is 3.
			So the maximum among these sums is 5.
			Since Ninja is too lazy to do this task, he asked you for help. You have to find the maximum of the sum of the smallest and the second smallest elements of all the subarray possible of size at least 2.
			Constraints:
				1 <= T <= 5
				2 <= N <= 10^5
				1 <= A[i] <= 10^4
				Time Limit: 1 sec.
			Sample Input 1:
			2
			4
			1 2 3 4
			2
			3 8
			Sample Output 1:
			7
			11
			Explanation For Sample Output 1:
			For the first test case, all the possible subarrays of size at least 2 are:
			[1 2], [1 2 3], [1 2 3 4], [2 3], [2 3 4], [3 4].
			The respective sum of the smallest and second smallest elements are 3, 3, 3, 5, 5, 7.
			So the answer will be the maximum of all of them, i.e., 7.

			For the second test case, there is only one subarray possible [3 8]. So the answer will be 11. 
			Sample Input 2:
			2
			5
			8 3 7 2 4
			4
			6 4 7 5
			Sample Output 2:
			11
			12
		
		// Not Optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int ans = 0;
				vector<vector<int>> hold;
				
				for(int i=0; i<n-1; i++){
					vector<int> temp = {arr[i]};
					for(int j=i+1; j<n; j++){
						temp.push_back(arr[j]);
						hold.push_back(temp);
					}
				}

				for(auto &outer: hold){
					sort(outer.begin(), outer.end());
					ans = max(ans, (outer[0]+outer[1]));
				}
				return ans;
			}
		
		// Optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int ans = 0;
				for(int i=1; i< n; i++)
					ans = max(ans, arr[i]+arr[i-1]);
				return ans;
			}
	
	886) IPL 2021 - Match Day 2:
		Problem Statement:
			Due to the rise of covid-19 cases in India, this year BCCI decided to organize knock-out matches in IPL rather than a league.
			Today is matchday 2 and it is between the most loved team Chennai Super Kings and the most underrated team - Punjab Kings. Stephen Fleming, the head coach of CSK, analyzing the batting stats of Punjab. He has stats of runs scored by all N players in the previous season and he wants to find the maximum score for each and every contiguous sub-list of size K to strategize for the game.
			Example 1:
			Input:
			N = 9, K = 3
			arr[] = 1 2 3 1 4 5 2 3 6
			Output: 
			3 3 4 5 5 5 6 
			Explanation: 
			1st contiguous subarray = {1 2 3} Max = 3
			2nd contiguous subarray = {2 3 1} Max = 3
			3rd contiguous subarray = {3 1 4} Max = 4
			4th contiguous subarray = {1 4 5} Max = 5
			5th contiguous subarray = {4 5 2} Max = 5
			6th contiguous subarray = {5 2 3} Max = 5
			7th contiguous subarray = {2 3 6} Max = 6

			Example 2:
			Input:
			N = 10, K = 4
			arr[] = 8 5 10 7 9 4 15 12 90 13
			Output: 
			10 10 10 15 15 90 90
			Explanation: 
			1st contiguous subarray = {8 5 10 7}, Max = 10
			2nd contiguous subarray = {5 10 7 9}, Max = 10 
			3rd contiguous subarray = {10 7 9 4}, Max = 10 
			4th contiguous subarray = {7 9 4 15}, Max = 15
			5th contiguous subarray = {9 4 15 12}, Max = 15 
			6th contiguous subarray = {4 15 12 90}, Max = 90 
			7th contiguous subarray = {15 12 90 13}, Max = 90 

			Your Task:  
				You don't need to read input or print anything. Complete the function max_of_subarrays() which takes the array, N, and K as input parameters and returns a list of integers denoting the maximum of every contiguous subarray of size K.

			Constraints:
				1 ≤ N ≤ 10^6
				1 ≤ K ≤ N
				0 ≤ arr[i] ≤ 10^6

		// Not Optimized:
			class Solution {
				public:
				vector<int> max_of_subarrays(vector<int> arr, int n, int k) {
					vector<int> ans;
					
					for(int i=0; i <= (n-k); i++){
						int curMax = arr[i];
						int val = k-1, j=i+1;
						
						while(val--)
							curMax = max(curMax, arr[j++]);

						ans.push_back(curMax);
					}
					
					return ans;
				}
			};
	
		// Optimized:
			❌Pending			

	887) Get Equal Substrings Within Budget:
		Problem Statement:
			You are given two strings s and t of the same length and an integer maxCost.
			You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).
			Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.
			
			Example 1:
			Input: s = "abcd", t = "bcdf", maxCost = 3
			Output: 3
			Explanation: "abc" of s can change to "bcd".
			That costs 3, so the maximum length is 3.

			Example 2:
			Input: s = "abcd", t = "cdef", maxCost = 3
			Output: 1
			Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.

			Example 3:
			Input: s = "abcd", t = "acde", maxCost = 0
			Output: 1
			Explanation: You cannot make any change, so the maximum length is 1.
			
			Constraints:
				1 <= s.length <= 10^5
				t.length == s.length
				0 <= maxCost <= 10^6
				s and t consist of only lowercase English letters.

		// Not Optimized:
			class Solution {
				public:
				int equalSubstring(string s, string t, int maxCost) {
					int mxLen = 0, n = s.size();

					for(int i=0; i<n ; i++){
						int curCost = maxCost;
						string test;
						
						for(int j=i; j<n; j++){
							int val = abs(s[j] - t[j]);
							if(val <= curCost){
								curCost -= val;
								test += s[j];
							}else{
								break;
							}
						}
						// int size = test.size();
						mxLen = max(mxLen, (int) test.size());
					}
					return mxLen;
				}
			};
			
		// Optimized:
			class Solution {
				public:
				int equalSubstring(string s, string t, int maxCost) {
					int mxLen = 0, n = s.size();

					for(int i=0; i<n ; i++){
						int curCost = maxCost, cnt=0;
						
						for(int j=i; j<n; j++){
							int val = abs(s[j] - t[j]);
							if(val <= curCost){
								curCost -= val;
								cnt++;
							}else{
								break;
							}
						}
						// int size = test.size();
						mxLen = max(mxLen, cnt);
					}
					return mxLen;
				}
			};
	
	888) Custom Sort String:
		Problem statement
			You are provided with the two strings named X and Y respectively. Y has its own specific order and has no repeating characters. Your task is to arrange the characters of the first string i.e. X in such a way that the order of characters in X is exactly the same as in Y, which means if ‘d’ occurs after ‘c’ in Y then it should also occur after ‘c’ in X ( obviously if X has ‘d’ and ‘c’ as characters in it ). All you have to do is, convert string X in the specific order with respect to string Y.
			Note :

			Both the strings have only lowercase English alphabets. 
			There may be more than one correct solution, you have to return any one of the possible solutions.
			Constraints :
				1 <= T <= 10
				1 <= |X| <= 10000
				1 <= |Y| <= 26
				where ‘T’ is the number of test cases, |X| is the length of the first string and |Y| is the length of the second string.
				Time Limit: 1 sec
			Sample Input 1:
				1
				acabd
				abc
				Sample Output 1:
				aabcd
				Explanation of Sample Input 1:
				String Y has ‘a’ first then ‘b’ and then ‘c’ and therefore string X must be ordered as ‘aabcd’ to keep the respective order of characters same as in string Y.
				Other possible answers are: ‘daabc’ , ‘adabc’ , ‘aadbc’, ‘aabdc’.
				Sample Input 2:
				4
				dfhfgk
				h
				aabbb
				gd
				abababab
				ab
				cag
				abcdef
				Sample Output 2:
				hdffgk
				aabbb
				aaaabbbb
				acg

		#include <bits/stdc++.h> 
		// here it is important that the ans is stored in x or if you are storing the ans in
		// different string then don't change the actual x

		// here storing the answer in ans & assign it back to x, Means storing ans in X
		string specificOrder(string &x, string &y) {
			string ans;
			int n = y.size();
			for(int i=0; i<n; i++){
				char ch = y[i];
				for(int j=0; j<x.size();){
					if(ch == x[j]){
						ans += ch;
						x.erase(x.begin()+j);
					}else{
						j++;
					}
				}
			}

			ans += x;
			x = ans;

			return ans;
		}

		// here storing it in another var ans & not changing x
			#include <bits/stdc++.h> 
			string specificOrder(string & x, string & y) {
				string temp = x;
				string ans;
				int n = y.size();

				for(int i=0; i<n; i++){
					char ch = y[i];
					for(int j=0; j<temp.size(); ){
						if(ch == temp[j]){
							ans += ch;
							temp.erase(temp.begin()+j);
						}else{
							j++;
						}
					}
				}

				ans += temp;
				return ans;
			}
	
	889) Inverted Triangle Of Stars:
		Problem statement
			You have been given an integer ‘N’. You need to print an inverted isosceles triangle of stars such that the height of the triangle is N.
			For example :
			If N = 4 then the output will
			*******
			 *****
			  ***
			   *
			Constraints:
				1 <= T <= 100
				1 <= N <= 100
				Time Limit : 1 sec

			Sample Input 1:
			1
			4
			Sample Output 1:
			*******
			 *****
			  ***
			   *
			Sample Input 2:
			1
			3
			Sample Output 2:
			*****
			 ***
			  *

		#include <bits/stdc++.h> 
		vector<string> Triangle(int n) {
			vector<string> ans;
			int sp = 0;
			for(int i=n; i>0; i--){
				string s;
				int j=0;
				while(j < sp){
					s += " ";
					j++;
				}
				sp++;
				string s2(i*2-1, '*');
				s += s2;
				ans.push_back(s);
			}
			return ans;
		}

	890) Number of Steps to Reduce a Number in Binary Representation to One:
		Problem Statement:
			Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:
			If the current number is even, you have to divide it by 2.
			If the current number is odd, you have to add 1 to it.
			It is guaranteed that you can always reach one for all test cases.
			
			Example 1:
				Input: s = "1101"
				Output: 6
				Explanation: "1101" corressponds to number 13 in their decimal representation.
				Step 1) 13 is odd, add 1 and obtain 14. 
				Step 2) 14 is even, divide by 2 and obtain 7.
				Step 3) 7 is odd, add 1 and obtain 8.
				Step 4) 8 is even, divide by 2 and obtain 4.  
				Step 5) 4 is even, divide by 2 and obtain 2. 
				Step 6) 2 is even, divide by 2 and obtain 1.  
			Example 2:
				Input: s = "10"
				Output: 1
				Explanation: "10" corressponds to number 2 in their decimal representation.
				Step 1) 2 is even, divide by 2 and obtain 1.  
			Example 3:
				Input: s = "1"
				Output: 0
			
			Constraints:
				1 <= s.length <= 500
				s consists of characters '0' or '1'
				s[0] == '1'

		class Solution {
			public:
			int numSteps(string s) {
				int stps =0;

				while(s.size() > 1){
					if(s[s.size()-1] == '1'){
						// adding one
						string temp = s;
						int i=temp.size()-1;
						int c = 1;

						while(i >=0 && c){
							if(temp[i] == '1' && c){
							temp[i] = '0';
							c = 1;
							}else{
							temp[i] = '1';
							c = 0;
							}
							i--;
						}
						if(c)
							temp.insert(temp.begin(), '1'); 
						
						s = temp;
					}else{
						s.erase(s.begin()+(s.size()-1));
					}
					stps++;
				}

				return stps;
			}
		};

		// More Optimized:
			class Solution {
				public:
				int numSteps(string s) {
					int ans=0;

					while(s != "1"){
						if(s.back() == '0'){
							s.pop_back();
						}else{
							int i=s.size()-1;
							while(i >=0 && s[i] == '1'){
								s[i] = '0';
								i--;
							}
							// this means s contains all 1's
							if(i < 0){
								s = '1' + s;
							}else{
								s[i] = '1';
							}
						}
						ans++;
					}
					return ans;
				}
			};
	
	#CodeChef Starters-136 Division-4: 
		891) Who Makes P1:
			https://www.codechef.com/START136D/problems/WHOMAKESP1
			Problem Statement:
				Tyro and Dom are fighting over who makes the first problem of the contest. Both of them are very lazy so they don't want to make it.
				Tyro has a patience level of A, meaning he will only be convinced on the 𝐴𝑡ℎ time when Dom asks him to make the problem.
				Dom, on the other hand, has decided to convince Tyro at most B times. If Tyro is not convinced by the 𝐵𝑡ℎ time, Dom will proceed to make it himself.
				Given the values of 
				𝐴 and 𝐵, find out who will end up making the problem.
				Input Format
				The first and only line of input contains 2 integers, A and B - Tyro's patience level, and the number of times Dom tries to convince Tyro respectively.
				Output Format
				For each test case, output on a new line, Dom or Tyro corresponding to who ends up making the problem.
				You can print each character in uppercase or lowercase. For example, the strings DOM, dom, Dom, and dOM are considered identical.

				Constraints
				1≤A,B≤10
				Sample 1:
				Input
				5 5
				Output
				Tyro
				Explanation:
				Dom will convince Tyro for at most 5 times. Tyro agrees on the 5𝑡ℎ time and makes the problem.
				Sample 2:
				Input
				4 3
				Output
				Dom
				Explanation:
				Dom will convince Tyro for at most 3 times. However, Tyro has decided to agree on the 4𝑡ℎ time. Thus, Dom makes the problem.

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int a, b;
				cin>>a>>b;
				
				if(a > b)
					cout<<"Dom";
				else
					cout<<"Tyro";
				
				return 0;
			}

		892) Even Sum Subarray:
			https://www.codechef.com/START136D/problems/EVENSUMSUB
			Problem Statement:
				Given an array A of size N, find the size of the largest subarray of A which has an even sum.
				For example, for the array 2, 1, 2 the answer is just 1 as the largest subarray with an even sum is 2.
				Note that a subarray is a contiguous part of an array. For the array [1, 3, 2], some possible subarrays
				are [11, [2], [1, 3], [1, 3, 2]. However, [1, 2] is not a subarray for this array.
				Input Format
				• The first line of input will contain a single integer 1, denoting the number of test cases.
				• Each test case consists of multiple lines of input.
				• The first line of each test case contains a single integer N — the size of the array.
				• The next line contains N space-separated integer - A1, A2, •••, AN.
				Output Format
				For each test case, output on a new line, the size of the largest subarray with even sum.
				Constraints
					• 1 ≤ T ≤ 50
					• 1≤ N≤ 50
					• 1 ≤ Ai ≤ 10^4
				input:
					4
					3
					2 1 2
					3
					1 3 2
					6
					2 2 1 1 1 2
					1
					1
				output:
					1
					3
					4
					0
				Explanation:
					Test case 1: The largest subarray with even sum is the subarray [2] having size 1.
					Test case 2: The largest subarray with even sum is the subarray [1,3,2] having size 3.
					Test case 3: The largest subarray with even sum is the subarray [2,2,1,1] having size 4.
					Test case 4: No subarray has even sum.

			#include <bits/stdc++.h>
			using namespace std;
			int Finder(vector<int> &v){
				int n = v.size();
				int mxSize = 0;
				for(int i=0; i<n; i++){
					int curSum = 0, cnt=0;
					for(int j=i; j<n; j++){
						curSum += v[j];
						cnt++;
						if(!(curSum&1))
							mxSize = max(mxSize, cnt);
					}
				}
				return mxSize;
			}

			int main() {
				int T;
				cin>>T;
				
				while(T--) {
					int n;
					cin >> n;
					
					vector<int> v(n);
					for(int i=0; i<n; i++)
						cin>>v[i];
						
					int largeSize = Finder(v);
					cout<< largeSize << endl;
				}
				return 0;
			}
		
	#CN BeginnerContest-61:
		893) Conversion:
			Problem statement
				You are given two integers ‘A’ and ‘B’. You can apply following operations on ‘B’:
				‘Operation 1’: Subtract ‘3’ from ‘B’.
				‘Operation 2’: Subtract ‘5’ from ‘B’.
				‘Operation 1’ can be applied any number of times but ‘Operation 2’ can be applied at most two times. You have to determine whether you can convert ‘B’ to ‘A’.
				Your task is to tell whether you can convert ‘B’ to ‘A’ by using given operations and return ‘1’ if possible, otherwise return ‘0’.
				Example:
				‘A’ = 5
				‘B’ = 16

				‘1st’ operation: Subtract ‘3’ from ‘B’. Now, ‘B’ becomes ‘13’.
				‘2nd’ operation: Subtract ‘3’ from ‘B’. Now, ‘B’ becomes ‘10’.
				‘3rd’ operation: Subtract ‘5’ from ‘B’. Now, ‘B’ becomes ‘5’.
				So, it is possible to convert ‘B’ to ‘A’ by using the given operations.
				Constraints:
					1 <= 'T' <= 10
					0 <= ‘A’, ‘B’ <= 10^8

					Time Limit: 1 sec 
				Sample Input 1:
					2
					10 19
					0 2
					Sample Output 1:
					1
					0
					Explanation of sample input 1:
					For test case 1:

					‘1st’ operation: Subtract ‘3’ from ‘B’. Now ‘B’ becomes ‘16’.
					‘2nd’ operation: Subtract ‘3’ from ‘B’. Now ‘B’ becomes ‘13’.
					‘3rd’ operation: Subtract ‘3’ from ‘B’. Now, ‘B’ becomes ‘10’.
					Here, it is possible to convert ‘B’ to ‘A’.
					For test case 2:
					It is impossible to convert ‘B’ to ‘A’ by using the given operations any number of times.
					Sample Input 2:
					2
					2 6
					1 11
					Sample Output 2:
					0
					1

			// Not Optimized:
				int conversion (int a, int b) {
					int temp = b;

					// 0 times 5
					while(temp > a)
						temp -= 3;

					if(temp == a)
						return  1;
					
					// 1 times 5
					temp = b;
					temp -= 5;
					while(temp > a)
						temp -= 3;

					if(temp == a)
						return 1;

					// 2 times 5
					temp = b - 10;
					while(temp > a)
						temp -=3;
					
					if(temp == a)
						return 1;

					return 0;
				}
		
			// Optimized:
				int conversion (int a, int b) {
					if((b-a) >= 0 && (b-a) % 3 ==0){
						return 1;
					}else if((b-a-5) >=0 && (b-a-5) % 3== 0)
						return 1;
					else if((b-a-10) >=0 && (b-a-10) % 3== 0)
						return 1;
					return 0;
				}

				//or
				int conversion (int a, int b) {
					if(((b-a) >= 0 && (b-a) % 3 ==0) || ((b-a-5) >=0 && (b-a-5) % 3== 0) || ((b-a-10) >=0 && (b-a-10) % 3== 0))
						return 1;
					return 0;
				}

		894) L Shaped Grid:
			Problem statement
				A grid of size ‘N * N’ is called an ‘L’ shaped grid if it contains the numbers from ‘1’ to ‘N’ such that any number ‘K’ (‘1’ <= ‘K’ <= ‘N’) is filled vertically from position ‘(K, K)’ to ‘(N, K)’ and horizontally from ‘(K, K)’ to ‘(K, N)’. For instance, a ‘(4 * 4)’ grid would look like:
				[1, 1, 1, 1]
				[1, 2, 2, 2]
				[1, 2, 3, 3]
				[1, 2, 3, 4]
				You will be given an integer ‘R’ denoting the row of the grid of size ‘N * N’. You have to compute the sum of the ‘Rth’ row. All the given inputs are based on ‘1-based’ indexing.
				Your task is to tell the sum of the ‘Rth’ row and return it.

				Example:
				‘N’ = 3
				‘R’ = 2
				The grid would look like: [[1, 1, 1], [1, 2, 2], [1, 2, 3]].

				The ‘2nd’ Row is ‘[1, 2, 2]’, and its sum is ‘5’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^9
					1 <= ‘R’ <= ‘N’
					Time Limit: 1 sec 
				Sample Input 1:
				2
				4 3
				2 2
				Sample Output 1:
				9
				3
				Explanation of sample input 1:
				For test case 1:
				Here, the grid would look like: [[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3], [1, 2, 3, 4]].
				The ‘3rd’ row is ‘[1, 2, 3, 3]’, and its sum is ‘9’.
				For test case 2:
				Here, the grid would look like: [[1, 1][1, 2]].
				The ‘2nd’ row is ‘[1, 2]’, and its sum is ‘3’.
				Sample Input 2:
				2
				5 2
				6 1
				Sample Output 2:
				9
				6

			// Not Optimized:
				long long lShapedGrid (int n, int r) {
					vector<vector<int>> Grid;
					int row = 1;
					for(int i=0; i<n; i++){
						vector<int> temp;
						int cnt = 0;

						for(int j=0; j<= i; j++)
						temp.push_back(++cnt);
						
						for(int j=i+1; j<n; j++)
						temp.push_back(cnt);
						
						Grid.push_back(temp);
					}

					long long s = 0;
					for(int i=0; i<n; i++)
						s += Grid[r-1][i];
					return s;
				}

			// Little Bit Optimized:
				long long lShapedGrid (int n, int r) {
					long long s=0;
					int cnt=0;

					int remain =  n - r;

					while(r--)
						s += ++cnt;
					
					while(remain--)
						s += cnt;
					return s;
				}

			// Optimized:
				Don't forget to convert each & every int variable to long long (you *1ll or *1LL)
				long long lShapedGrid (int n, int r) {
					long long s1 = (r * 1ll * (r+1))/2LL;
					long long s2 = (n-r) * 1LL * r * 1ll;
					long long ans = s1 + s2;
					return ans;
				}

				// or
					long long lShapedGrid (int n, int r) {
						return (r * 1ll * (r+1))/2LL + (n-r) * 1LL * r * 1ll;
					}

	895) String Subsequence
		Problem Statement:
			Given two strings, s1 and s2, count the number of subsequences of string s1 equal to string s2.
			Return the total count modulo 1e9+7.
			Example 1:
			Input: 
			s1 = geeksforgeeks
			s2 = gks
			Output:
			4
			Explaination: 
				We can pick characters from s1 as a subsequence from indices {0,3,4}, {0,3,12}, {0,11,12} and {8,11,12}.So total 4 subsequences of s1 that are equal to s2.Example 2:

			Example 2:
				Input: 
				s1 = problemoftheday
				s2 = geek
				Output:
				0
				Explaination: 
				No subsequence of string s1 is equal to string s2.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function countWays() which takes the string s1 and s2 as input parameters and returns the number of subsequences of s1 equal to s2.

			Expected Time Complexity: O(n*m)   	     [n and m are lengths of the strings s1 and s2]
			Expected Auxiliary Space: O(n*m)        	[n and m are lengths of the strings s1 and s2]

			Constraints:
				1 ≤ n, m ≤ 500  [n and m are lengths of the strings s1 and s2]

		// Not Optimized:
			class Solution {
				public:
				void SubSecGen(string main, string store, vector<string> &ans, int i){
					if(i == main.size()){
						ans.push_back(store);
						return;
					}
					
					// exclude call
					SubSecGen(main, store, ans, i+1);
					
					// include call
					store += main[i];
					SubSecGen(main, store, ans, i+1);
				}
				
				int countWays(string s1, string s2) {
					string s;
					vector<string> hold;
					SubSecGen(s1, s, hold, 0);
					
					int mod = 1e9+7;
					for(string test: hold)
						if(test == s2)
							cnt++;
					
					return cnt % mod;
				}
			};
	
		// Optimized:
			❌Pending

	896) Count Triplets That Can Form Two Arrays of Equal XOR
		Problem Statement:
			Given an array of integers arr.
			We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).
			Let's define a and b as follows:
			a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
			b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
			Note that ^ denotes the bitwise-xor operation.
			Return the number of triplets (i, j and k) Where a == b.
	
			Example 1:
				Input: arr = [2,3,1,6,7]
				Output: 4
				Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
			Example 2:
				Input: arr = [1,1,1,1,1]
				Output: 10
			

			Constraints:
				1 <= arr.length <= 300
				1 <= arr[i] <= 10^8

		/* Time Complexity (TC): O(n⁴) Space Complexity (SC): O(1) */		
		// Not Optimized:
			class Solution {
				public:
				int countTriplets(vector<int>& arr) {
					int cnt =0, n = arr.size();

					for(int i=0; i<n-1; i++){
						for(int j=i+1; j<n; j++){
							for(int k=j; k<n; k++){
								int a = 0, curI = i;
								
								while(curI < j)
									a ^= arr[curI++];

								int b = 0, curJ = j;
								while(curJ <= k)
									b ^= arr[curJ++];
								
								if(a==b)
									cnt++;
							}
						}
					}
					return cnt;
				}
			};
	
		// Optimized:
			❌Pending

	#CN WeeklyContest-128:
		897) Bottle Pickup:
			Problem statement
				There are 'N' bottles numbered from '1' to 'N' on the table. You are given an array 'filled' of length 'N', where if 'filled[i]' is equal to '1', then the 'i'-th bottle is filled. If 'filled[i]' is equal to '0', then the 'i'-th bottle is empty.
				You can pick bottles by performing the following operation:
				Choose two integers 'L' and 'R' (L <= R), and pick every bottle in the range '[L, R]'.
				You want to pick every filled bottle in exactly one operation. So, find the minimum number of bottles you must pick up.
				Note: It is guaranteed that there will be at least one filled bottle.

				Example:
					'N' = 3
					'filled' = [0, 1, 0]
					Perform the operation in the following way:
				Choose 'L' and 'R' equal to '2'. So, you can pick a filled bottle by just picking only the filled bottle. So, the answer is '1'.

				Constraints:
					1 <= T <= 10
					1 <= N <= 10^5
					0 <= filled[i] <= 1
					It is guaranteed that the sum of 'N' over all test cases does not exceed '2*10^5'.
					Time Limit: 1 second

				Sample Input 1:
					2
					3
					1 0 0 
					4
					1 1 0 1 
					Sample Output 1:
					1
					4
					Explanation Of Sample Input 1:
					For test case 1:
					Perform the operation in the following way:
					-  Choose 'L' and 'R' equal to '1'.
					So, you can pick a filled bottle by just picking only the filled bottle.
					So, the answer is '1'.

					For test case 2:
					Perform the operation in the following way:
					-  Choose 'L' equal to '1' and 'R' equal to '4'.
					So, you can pick a filled bottle by just picking only the filled bottle.
					So, the answer is '4'.
					Sample Input 2:
					2
					6
					0 0 0 0 1 0 
					7
					0 1 1 1 0 1 0 
					Sample Output 2:
					1
					5

			int countBottles(int n, vector<int> filled){
			int L, R;
			int cnt= 0;
			for(int i: filled){
				if(i == 1){
					L = cnt;
					break;
				}
				cnt++;
			}

			for(int i=n-1; i>=0; i--){
				if(filled[i] == 1){
					R = i;
					break;
				}
			}
			return (L == R) ? 1 : (R-L+1);
			}
		
		898) Vague String:
			Problem statement
				A string is considered to be Vague if it contains a palindromic substring having length greater than ‘1’.
				For example: “rfgugfo” is a Vague String because it contains “fgugf” as a palindromic substring.
				You are given a string ‘S’ of size ‘N’ where each character is numbered from ‘0’ to ‘N - 1’. You are also given a ‘Queries’ array of size ‘Q’ where each query is of the given format:
				‘(L, R)’ : Check whether a substring from ‘L’ to ‘R’ is vague or not.
				Your task is to answer all the queries and return an array of ‘0s’ and ‘1s’ where ‘1’ shows that the substring is Vague and ‘0’ shows that the substring is not Vague.

				Example:
				‘N’ = 5
				‘S’ = “fpaka”
				‘Q’ = 2
				‘Queries’ = [[2, 4], [1, 3]]

				‘1st’ query: From ‘L’ = 2 to ‘R’ = 4
				Here the whole string from ‘L’ = 2 to ‘R’ = 4 is a palindrome. So, the answer for this case will be ‘1’.

				‘2nd’ query: From ‘L’ = 1 to ‘R’ = 3
				Here, we have to check whether “pak” is Vague or not. As it does not contain any palindromic substring having length greater than ‘1’, So it is not Vague.
				Hence the answer for this example is: [1, 0].

				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					‘a’ <= ‘S[i]’ <= ‘z’
					1 <= ‘Q’ <= 10^5
					0 <= ‘Queries[i][0]’, ‘Queries[i][1]’ <= ‘N - 1’
					Time Limit: 1 sec 

				Sample Input 1:
					2
					7
					pqgffgo
					2
					1 6
					3 5
					1
					a
					1
					0 0
					Sample Output 1:
					1 1
					0
					Explanation of sample input 1:
					For test case 1:
					‘1st’ Query: The substring is “qgffgo” 
					Here, the given substring contains a palindrome “gffg” having length greater than ‘1’. So, it is a Vague Substring.
					‘2nd’ Query: The substring is “ffg”
					Here, the given substring contains a palindrome “ff” having length greater than ‘1’. So, it is a Vague Substring.
					Hence, the answer for this test case is: [1, 1].

					For test case 2:
					‘1st’ Query: The substring is “a”
					Here, we don’t have any palindrome with length greater than ‘1’. So, it is not a Vague Substring.

					Hence, the answer for this test case is: [0].
					Sample Input 2:
					2
					6
					wwaapp 
					3
					0 3
					1 2
					2 4
					2
					ab
					2
					0 0
					1 1
					Sample Output 2:
					1 0 1
					0 0
		
			// Not Optimized:
				bool isPalindrome(string& s){
					int i=0, j=s.size()-1;

					while(i < j)
						if(s[i++] != s[j--])
							return 0;

					return 1;
				}

				bool AnyPalindromFound(vector<string> &v){
					// checking each & every substring, is it palindrome or not
					for(string s: v){
						if(isPalindrome(s))
							return 1;
					}
					return 0;
				}

				vector <int> vagueString (int n, string &s, int q, vector<vector<int>> &queries) {
					vector<int> res;
					for(int i=0; i<q; i++){
						int L = queries[i][0], R = queries[i][1];
						if((R-L) > 1){
							// need to generate all substrings & check are any of the substring is palindrome
							vector<string> holder;

							for(int z=L; z<R; z++){
								string test;
								test += s[z];
								for(int y=z+1; y <= R; y++){
									test += s[y];
									// cout<<test<<"\t";
									holder.push_back(test);
								}
								// cout<<"\n";
							}

							if(AnyPalindromFound(holder))
								res.push_back(1);
							else
								res.push_back(0);
						}else{
							res.push_back(0);
						}
					}
					return res;
				}

			// Optimized:
				❌Pending

		899) Blue vs Red:
			Problem statement
				You are given an array 'A' of 'N' distinct integers numbered from '0' to 'N - 1'.
				All the integers of the array are colored with either blue or red color.
				Let's define the profit for each element of the array 'A' as mentioned below. For the index 'i':
				If the element on the 'i-th' index is red, the profit of the element is equal to 'A[i] * A[j]' where 'A[j]' is the maximum element such that 'j < i' and the color of 'A[j]' is blue. If there is no such 'A[j]' then the profit of 'A[i]' is equal to '0'.
				If the element on the 'i-th' index is blue, the profit of the element is equal to '0'.
				Let's define the beauty of the array 'A' as the sum of the profit of all the elements.
				You are given an array 'color' where 'color[i]' is '1' if the element on index 'i' is red and '0' if the element is blue. You can shuffle the elements of the array 'A' and want to maximize the beauty of the array.
				Note that 'color[i]' will remain the same even if the element on the index 'i' changes.
				Let's denote 'max' is the maximum beauty of the array 'A' that is possible after shuffling the elements of the array 'A'. Find the total number of different arrays with beauty equal to 'max' that can be generated by shuffling the elements of the array 'A'.
				As the answer might be large and can not fit inside a 64-bit integer, return the answer modulo '10^9 + 7'.
				Example:
				N = 4
				A = [1, 5, 2, 6]
				color =  [1, 0, 1, 0]
				It can be proved that the maximum beauty of the array 'A' after shuffling the elements is '30'.
				There are total '4' different arrays with beauty equal to '30' which are ['1', '5', '6', '2'], ['1', '6', '5', '2'], ['2', '5', '6', '1'] and ['2', '6', '5', '1'].
				So, the answer for this case is '4'.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					1 < 'A[i]' <= 10^5
					0 <= 'color[i]' <= 1
					It is guaranteed that all the elements of the array 'A' are distinct from each other.
					Time limit: 1 sec
				Sample input 1:
					2
					3
					1 2 3
					0 1 1
					3
					1 2 4
					1 1 0
					Sample output 1:
					2
					6
					Explanation of sample input 1:
					For test case 1:
					It can be proved that the maximum beauty of the array 'A' after shuffling the elements is '9'.
					There are '2' different arrays with beauty equal to '9' which are ['3', '2', '1'] and ['3', '1', '2'].
					So, the answer for this case is '2'.


					For test case 2:
					We can see that there is no blue-colored element on the left side of any red element. So, beauty will be always '0'.
					There are '6' different arrays with beauty equal to '0' which are ['1', '2', '4'], ['1', '4', '2'], ['2', '1', '4'], ['2', '4', '1'], ['4', '1', '2'] and ['4', '2', '1'].
					So, the answer for this case is '6'.
					Sample input 2:
					2
					5
					4 5 1 2 6 
					0 0 0 1 0
					7
					7 6 3 1 2 4 5
					0 0 1 1 0 0 1
					Sample output 2:
					36
					72

			// Not Optimized:
				long long CurVectorAns(vector<int>& ops, vector<int>& col){
					int n = col.size();
					long long prof = 0;
					int curMx = 0;
					for(int i=0; i<n; i++){
						if(col[i] == 1){
							prof += (ops[i] * curMx);
						}else{
							curMx = max(curMx, ops[i]);
						}
					}
					return prof;
				}

				int numberOfArrays(int n, vector<int> &v, vector<int> &color) {
					// need to generate the permutation of v.
					
					vector<vector<int>> hold;
					sort(v.begin(), v.end());
					hold.push_back(v);

					while(next_permutation(v.begin(), v.end()))
						hold.push_back(v);

					// finding the max of every subsequence
					long long mx = 0;
					vector<long long> storer;
					for(auto out: hold){
						long long val = CurVectorAns(out, color);
						storer.push_back(val);
						mx = max(mx, val);
					}

					int cnt =0, mod = 1e9+7;
					for(long long i: storer)
						if(i == mx)
							cnt++;
					return cnt % mod;;
				}
		
			// Optimized:
				❌Pending

	900) Lexicographical Numbers:
		Problem Statement:
			Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.
			You must write an algorithm that runs in O(n) time and uses O(1) extra space. 
			Example 1:
				Input: n = 13
				Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]

			Example 2:
				Input: n = 2
				Output: [1,2]
		
			Constraints:
				1 <= n <= 5 * 10^4

		class Solution {
			public:
			vector<int> lexicalOrder(int n) {
				vector<int> store;
				vector<string> temp;
				for(int i=0; i<n; i++){
					temp.push_back(to_string(i+1));
				}
				sort(temp.begin(), temp.end());
				for(string s: temp)
					store.push_back(stoi(s));
				
				return store;
			}
		};

		// Using DFS (Depth First Search) approach
			class Solution {
				public:
				void solve(int currNum, int n, vector<int> &res){
					if(currNum > n) return ;
					for(int i=0; i<=9; i++){
						int newNum = currNum * 10 + i;
						if(newNum > n) return ;
						res.push_back(newNum);
						solve(newNum, n, res);
					}
				}
				vector<int> lexicalOrder(int n) {
					vector<int> res;

					for(int i=1; i<=9; i++){
						if(i > n) continue;
						res.push_back(i);
						solve(i, n, res);
					}
					return res;
				}
			};
	
	901) Swap two nibbles in a byte:
		Problem Statement:
			Given a number n, Your task is to swap the two nibbles and find the resulting number. 
			A nibble is a four-bit aggregation, or half an octet. There are two nibbles in a byte. For example, the decimal number 150 is represented as 10010110 in an 8-bit byte. This byte can be divided into two nibbles: 1001 and 0110.

			Example 1:
			Input: n = 100
			Output: 70
			Explanation: 100 in binary is 01100100, two nibbles are (0110) and (0100). If we swap the two nibbles, we get 01000110 which is 70 in decimal.

			Example 2:
			Input: n = 129
			Output: 24
			Explanation: 129 in binary is 10000001, two nibbles are (1000) and (0001). If we swap the two nibbles, we get 00011000 which is 24 in decimal.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function swapNibbles() which takes an integer n as input parameter and returns an integer after swapping nibbles in the binary representation of n.

			Expected Time Complexity: O(1)
			Expected Space Complexity: O(1)

			Constraints:
				0 ≤ n ≤ 255

		class Solution {
			public:
			int swapNibbles(int n) {
				string s = bitset<8>(n).to_string();
				string s1 = s.substr(0, 4);
				string s2 = s.substr(4);
				s = s2 + s1;

				return stoi(s,0,2);
			}
		};

		// or
			1. (n & 0x0F) << 4: 
				This operation first masks the lower nibble of n using the bitwise AND operator (&) with 0x0F (which is 00001111 in binary). This effectively zeroes out the higher nibble. The result is then shifted left (<<) by 4 bits, moving the lower nibble to the place of the higher nibble.
			2. (n & 0xF0) >> 4: 
				Similarly, this operation masks the higher nibble of n using the bitwise AND operator with 0xF0 (which is 11110000 in binary), and then shifts it right (>>) by 4 bits, moving the higher nibble to the place of the lower nibble.
			The results of these two operations are then combined using the bitwise OR operator (|), which effectively merges the two nibbles into a single byte, with the original nibbles swapped.
			
			class Solution {
				public:
				int swapNibbles(int n) {
					return (((n & 0x0F) << 4) | (n & 0xF0) >> 4);
				}
			};

	902) Find prime numbers:
		Problem statement
			You are given a positive integer ‘N’. Your task is to print all prime numbers less than or equal to N.
			Note: A prime number is a natural number that is divisible only by 1 and itself. Example - 2, 3, 17, etc.
			You can assume that the value of N will always be greater than 1. So, the answer will always exist.
			Constraints:
				2 <= N <= 10^7
				Where ‘N’ is the given positive integer.
				Time Limit: 1sec

			Sample Input 1 :
			7
			Sample Output 1 :
			2 3 5 7
			Sample Output 1 Explanation:
			For the given input, all prime numbers from 2 to 7 are 2, 3, 5 and 7.
			Sample Input 2 :
			30
			Sample Output 2 :
			2 3 5 7 11 13 17 19 23 29

		// Not Optimized:
			bool isPrime(int n){
				int s = 2;
				while(s <= n/2){
					if(n % s == 0)
						return 0;
					s++;	
				}
				return 1;
			}

			vector<int> primeNumbersTillN(int N) {
				vector<int> ans;
				int i = 2;
				while(i <= N){
					if(isPrime(i))
						ans.push_back(i);
					i++;
				}
				return ans;
			}

		// Optimized:
			❌Pending

	903) Uncommon Words from Two Sentences:
		Problem Statement:
			A sentence is a string of single-space separated words where each word consists only of lowercase letters.
			A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.
			Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.

			Example 1:
				Input: s1 = "this apple is sweet", s2 = "this apple is sour"
				Output: ["sweet","sour"]
			Example 2:
				Input: s1 = "apple apple", s2 = "banana"
				Output: ["banana"]
			
			Constraints:
				1 <= s1.length, s2.length <= 200
				s1 and s2 consist of lowercase English letters and spaces.
				s1 and s2 do not have leading or trailing spaces.
				All the words in s1 and s2 are separated by a single space.

		class Solution {
			public:
			vector<string> uncommonFromSentences(string s1, string s2) {
				vector<string> ans;
				map<string, int> Fr;

				string temp;
				for(char ch: s1){
					if(ch == ' '){
						Fr[temp]++;
						temp.clear();
					}else{
						temp += ch;
					}
				}
				Fr[temp]++;            // the last word

				temp.clear();
				for(char ch: s2){
					if(ch == ' '){
						Fr[temp]++;
						temp.clear();
					}else{
						temp += ch;
					}
				}
				Fr[temp]++;            // the last word

				for(auto at: Fr)
					if(at.second == 1)
						ans.push_back(at.first);

				return ans;
			}
		};
		
	#AtCoder BeginnerContest-356
		904) A - Subsegment Reverse:
			Problem Statement:
				You are given positive integers N, L, and R.
				For a sequence A=(1,2,…,N) of length 
				N, an operation of reversing the L-th through R-th elements was performed once.
				Print the sequence after this operation.
				Constraints
				All input values are integers.
					1≤L≤R≤N≤100
				Input
				The input is given from Standard Input in the following format:

				N L R
				Output
				Let 
				A′ =(A1′, A2′,…,AN′) be the sequence after the operation. Print it in the following format:
				A1′,A2′…,AN′
		
				Sample Input 1
				5 2 3
				Sample Output 1
				1 3 2 4 5
				Initially, 
				A=(1,2,3,4,5).
				After reversing the second through third elements, the sequence becomes 
				(1,3,2,4,5), which should be printed.

				Sample Input 2
				7 1 1
				Sample Output 2
				1 2 3 4 5 6 7
				It is possible that 
				L=R.

				Sample Input 3
				10 1 10
				Sample Output 3
				10 9 8 7 6 5 4 3 2 1
				It is possible that 
				L=1 or 
				R=N.

			#include <iostream>
			#include <vector>
			using namespace std;
			int main() {
				
				int N, L, R;
				cin>>N>>L>>R;
				
				vector<int> v;
				for(int i=1; i<= N; i++)
					v.push_back(i);
					
				L--, R--;
				while(L < R)
					swap(v[L++], v[R--]);
					
				for(int i: v)
					cout<<i<<" ";
				return 0;
			}
		
	#LeetCode WeeklyContest-400:
		905) Minimum Number of Chairs in a Waiting Room:
			Problem Statement:
				You are given a string s. Simulate events at each second i:
				If s[i] == 'E', a person enters the waiting room and takes one of the chairs in it.
				If s[i] == 'L', a person leaves the waiting room, freeing up a chair.
				Return the minimum number of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially empty.

				Example 1:
				Input: s = "EEEEEEE"
				Output: 7
				Explanation:
				After each second, a person enters the waiting room and no person leaves it. Therefore, a minimum of 7 chairs is needed.

				Example 2:
				Input: s = "ELELEEL"
				Output: 2
				Explanation:
				Let's consider that there are 2 chairs in the waiting room. The table below shows the state of the waiting room at each second.
				Second	Event	People in the Waiting Room	Available Chairs
					0	Enter		1						1
					1	Leave		0						2
					2	Enter		1						1
					3	Leave		0						2
					4	Enter		1						1
					5	Enter		2						0
					6	Leave		1						1
					
				Example 3:
				Input: s = "ELEELEELLL"
				Output: 3
				Explanation:
				Let's consider that there are 3 chairs in the waiting room. The table below shows the state of the waiting room at each second.
				Second	Event	People in the Waiting Room	Available Chairs
				0		Enter			1						2
				1		Leave			0						3
				2		Enter			1						2
				3		Enter			2						1
				4		Leave			1						2
				5		Enter			2						1
				6		Enter			3						0
				7		Leave			2						1
				8		Leave			1						2
				9		Leave			0						3
				

				Constraints:

				1 <= s.length <= 50
				s consists only of the letters 'E' and 'L'.
				s represents a valid sequence of entries and exits.

			class Solution {
				public:
				int minimumChairs(string s) {
					int maxReached=0, curCnt=0;
					for(char ch: s){
						if(ch == 'E')
							curCnt++;
						else
							curCnt--;
						maxReached = max(maxReached, curCnt);
					}
					return maxReached;
				}
			};

		906) Count Days Without Meetings:
			Problem Statement:
				You are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive).
				Return the count of days when the employee is available for work but no meetings are scheduled.
				Note: The meetings may overlap.
				
				Example 1:
				Input: days = 10, meetings = [[5,7],[1,3],[9,10]]
				Output: 2
				Explanation:
				There is no meeting scheduled on the 4th and 8th days.

				Example 2:
				Input: days = 5, meetings = [[2,4],[1,3]]
				Output: 1
				Explanation:
				There is no meeting scheduled on the 5th day.

				Example 3:
				Input: days = 6, meetings = [[1,6]]
				Output: 0
				Explanation:
				Meetings are scheduled for all working days.
				
				Constraints:
					1 <= days <= 10^9
					1 <= meetings.length <= 10^5
					meetings[i].length == 2
					1 <= meetings[i][0] <= meetings[i][1] <= days

			// Not Optimized:
				class Solution {
					public:
					int countDays(int days, vector<vector<int>>& meetings) {
						int cnt=0;

						vector<int> v(days, 1);
						for(int z=0; z<meetings.size(); z++){
							int start = meetings[z][0], end = meetings[z][1];
							for(int i=start; i<=end; i++)
								v[i-1] = 0;
						}

						/*
							for(auto cur: meetings){                         // for(vector<int> cur: meetings){
								int start = cur[0], end = cur[1];
								for(int i=start; i<=end; i++)
									v[i-1] = 0;
							}
						*/

						for(int i: v){
							// cout<<i<<"\t";
							if(i != 0)
								cnt++;
						}

						return cnt;
					}
				};
			
			// Optimized:
				class Solution {
					public:
					int countDays(int days, vector<vector<int>>& meetings) {
						sort(meetings.begin(), meetings.end());
						vector<vector<int>> test;
						test.push_back(meetings[0]);

						for(int i=1; i<meetings.size(); i++){
							if(test.back()[1] >= meetings[i][0]){
								test.back()[1] = max(test.back()[1], meetings[i][1]);
							}else{
								test.push_back(meetings[i]);
							}
						}

						int cnt =0;
						for(int i=0; i<test.size(); i++)
							cnt += (test[i][1] - test[i][0] + 1);

						return days - cnt;
					}
				};
			
		907) Lexicographically Minimum String After Removing Stars:
			Problem Statement:
				You are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.
				While there is a '*', do the following operation:
				Delete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.
				Return the 
				lexicographically smallest
				resulting string after removing all '*' characters.
				
				Example 1:
				Input: s = "aaba*"
				Output: "aab"
				Explanation:
				We should delete one of the 'a' characters with '*'. If we choose s[3], s becomes the lexicographically smallest.

				Example 2:
				Input: s = "abc"
				Output: "abc"
				Explanation:
				There is no '*' in the string.
				
				Constraints:
				1 <= s.length <= 10^5
				s consists only of lowercase English letters and '*'.
				The input is generated such that it is possible to delete all '*' characters.

			// Not Optimized:
				class Solution {
					public:
					string clearStars(string s) {
						for(int i=0; i<s.size();){
							if(s[i] == '*'){
								s.erase(s.begin()+i);
								i--;
								char cur = s[i];
								int index = i;
								for(int z=i-1; z>=0; z--){
									if(s[z] < cur){
									index = z;
									cur = s[z];
									}
								}
								s.erase(s.begin()+index);
							}else{
								i++;
							}
						}
						return s;
					}
				};
			
			// Optimized:
				❌Pending
		
		908) Find Subarray With Bitwise AND Closest to K:
			Problem Statement:
				You are given an array nums and an integer k. You need to find a subarray
				of nums such that the absolute difference between k and the bitwise AND of the subarray elements is as small as possible. In other words, select a subarray nums[l..r] such that |k - (nums[l] AND nums[l + 1] ... AND nums[r])| is minimum.
				Return the minimum possible value of the absolute difference.
				A subarray is a contiguous non-empty sequence of elements within an array.
				
				Example 1:
				Input: nums = [1,2,4,5], k = 3
				Output: 1
				Explanation:
				The subarray nums[2..3] has AND value 4, which gives the minimum absolute difference |3 - 4| = 1.

				Example 2:
				Input: nums = [1,2,1,2], k = 2
				Output: 0
				Explanation:
				The subarray nums[1..1] has AND value 2, which gives the minimum absolute difference |2 - 2| = 0.

				Example 3:
				Input: nums = [1], k = 10
				Output: 9
				Explanation:
				There is a single subarray with AND value 1, which gives the minimum absolute difference |10 - 1| = 9.
			
				Constraints:
				1 <= nums.length <= 10^5
				1 <= nums[i] <= 10^9
				1 <= k <= 10^9

			// Not Optimized:
				class Solution {
					public:
					int AndValue(vector<int>& n, int l, int r){
						int val = n[l];
						for(int i = l+1; i<=r; i++)
							val &= n[i];
						
						return val;
					}
					int minimumDifference(vector<int>& nums, int k) {
						int minValue = INT_MAX;

						for(int i=0; i<nums.size(); i++){
							for(int j=i; j<nums.size(); j++){
								minValue = min(minValue, abs(k-AndValue(nums, i, j)));
							}
						}
						return minValue;
					}
				};
		
			// Optimized:
				❌Pending

	909) Merge Intervals/ Overlapping Intervals:
		Problem Statement:
			Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
			Example 1:
			Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
			Output: [[1,6],[8,10],[15,18]]
			Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

			Example 2:
			Input: intervals = [[1,4],[4,5]]
			Output: [[1,5]]
			Explanation: Intervals [1,4] and [4,5] are considered overlapping.
		
			Constraints:
				1 <= intervals.length <= 10^4
				intervals[i].length == 2
				0 <= starti <= endi <= 10^4

		class Solution {
			public:
			vector<vector<int>> merge(vector<vector<int>>& intervals) {
				sort(intervals.begin(), intervals.end());
				vector<vector<int>> ans = {intervals[0]};

				for(int i=1; i<intervals.size(); i++) {
					if(ans.back()[1] >= intervals[i][0]) {
						if(intervals[i][1] > ans.back()[1])
							ans.back()[1] = intervals[i][1];
					}else{
						ans.push_back(intervals[i]);
					}
				}
				return ans;
			}
		};

		// or
			class Solution {
				public:
				vector<vector<int>> mergeOverlap(vector<vector<int>>& arr) {
					sort(arr.begin(), arr.end());
					vector<vector<int>> ans;
					ans.push_back(arr[0]);
					int n = arr.size();
					
					for(int i=1; i<n; i++){
						int start = arr[i][0];
						int lastBack = ans.back()[1];
						if(start <= lastBack){
							ans.back()[1] = max(lastBack, arr[i][1]);
						}else{
							ans.push_back(arr[i]);
						}
					}
					return ans;
				}
			};

	910) Insert Interval:
		Problem Statement:
			You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
			Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
			Return intervals after the insertion.
			Note that you don't need to modify intervals in-place. You can make a new array and return it.

			Example 1:
			Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
			Output: [[1,5],[6,9]]

			Example 2:
			Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
			Output: [[1,2],[3,10],[12,16]]
			Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
			

			Constraints:
				0 <= intervals.length <= 10^4
				intervals[i].length == 2
				0 <= starti <= endi <= 10^5
				intervals is sorted by starti in ascending order.
				newInterval.length == 2
				0 <= start <= end <= 10^5

		class Solution {
			public:
			vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
				intervals.push_back(newInterval);
				sort(intervals.begin(), intervals.end());
				vector<vector<int>> ans = {intervals[0]};

				for(int i=1; i<intervals.size(); i++) {
					if(ans.back()[1] >= intervals[i][0]) {
						if(intervals[i][1] > ans.back()[1])
							ans.back()[1] = intervals[i][1];
					}else{
						ans.push_back(intervals[i]);
					}
				}
				return ans;
			}
		};

		// or
			class Solution {
				public:
				vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
					vector<vector<int>> ans;

					int n = intervals.size();
					int i=0;

					while(i < n && intervals[i][1] < newInterval[0]){
						ans.push_back(intervals[i]);
						i++;
					}

					while(i < n && intervals[i][0] <= newInterval[1]){
						newInterval[0] = min(intervals[i][0], newInterval[0]);
						newInterval[1] = max(intervals[i][1], newInterval[1]);
						i++;
					}
					ans.push_back(newInterval);

					while(i < n){
						ans.push_back(intervals[i]);
						i++;
					}
					return ans;
				}
			};
		
		Problem Statement:
			Geek has an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith event and intervals is sorted in ascending order by starti. He wants to add a new interval newInterval= [newStart, newEnd] where newStart and newEnd represent the start and end of this interval.
			Help Geek to insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
			Examples:
			Input: intervals = [[1,3], [4,5], [6,7], [8,10]], newInterval = [5,6]
			Output: [[1,3], [4,7], [8,10]]
			Explanation: The newInterval [5,6] overlaps with [4,5] and [6,7].
			Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,9]
			Output: [[1,2], [3,10], [12,16]]
			Explanation: The new interval [4,9] overlaps with [3,5],[6,7],[8,10].
			Constraints:
				1 ≤ intervals.size() ≤  10^5
				0 ≤ start[i], end[i] ≤ 10^9

		class Solution {
			public:
			vector<vector<int>> insertInterval(vector<vector<int>> &intervals, vector<int> &newInterval) {
				intervals.push_back(newInterval);
				sort(intervals.begin(), intervals.end());
				int n = intervals.size();
				vector<vector<int>> ans = {intervals[0]};
				
				for(int i=1; i<n; i++){
					int last = ans.back()[1];
					if(last >= intervals[i][0]){
						ans.back()[1] = max(ans.back()[1], intervals[i][1]);
					}else{
						ans.push_back(intervals[i]);
					}
				}
				return ans;
			}
		};
	
	#GFG Weekly-157:
		911) Valid Triangle:
			Problem Statement:
				You are given three sticks of lengths a, b and c. You need to check whether it is possible to make a triangle with a positive area using these three sticks.
				Return "YES" if it is possible else return "NO".
				Example 1:
				Input:
				a = 3
				b = 4
				с = 5
				Output:
				YES
				Explanation:
				we can form a triangle of positive area with the help of these sticks which is also a right-angle triangle.
				Example 2:
				Input:
				a = 1
				b = 1
				c = 3
				Output:
				NO
				Explanation:
				it is impossible to make a triangle of positive area with the help of these sticks.
				Your Task:
					You have to complete the function isPossible(), which takes three integers a, b and c as input parameters and return "YES" if it is possible to make a triangle of positive area else "NO".

				Constraints:
					1 <= a , b, c<= 10^9

			class Solution {
				public:
				string isPossible(int a, int b, int c) {
					if((a+b) > c && (b+c) > a && (c+a) > b)
						return "YES";
					return "NO";
				}
			};

		912) Super Palindrome:
			Problem Statement:
				You are given two integers I and r. You have to count how many super palindrome numbers are there in the range [l,r] (both inclusive).
				A number is called super palindrome if it is a palindrome in its decimal representation as well as a perfect square number.
				Example 1:
				Input:
					l = 1
					r = 10
					Output:
					3
					Explanation:
					1, 4, 9 are three numbers in the range [1,10] which are palindrome as well as perfect square.
				Example 2:
					Input:
					1 = 100
					r = 1000
					Output:
					3
					Explanation:
					121, 484, 676 are three numbers in the range [100,1000] which are palindrome as well as perfect square.

				Constraints:
					1 <= l <= r <= 10^9
				Your Task:
					You have to complete the function countSuperPalindrome() , which takes two integers l and r and returns number of super palindrome numbers in the range [l,r].
				
			class Solution {
				public:
				int countSuperPalindrome(int l, int r) {
					int cnt=0;
					
					for(int i=1; i <= r; i++){
						int val1 = i * i;
						
						if(val1 > r)
							break;
							
						int rev = 0;
						int temp = val1;
						
						while(temp){
							rev = rev*10 + temp % 10;
							temp /= 10;
						}
						// cout<<rev<<"\t"<<val1<<endl;
						if(rev == val1 && l <= val1 && val1 <= r)
							cnt++;
					}
					return cnt;
				}
			};
			
		913) String Replacement:
			Problem Statement:
				You are given a string s , containing only characters 'a' and 'b'. In one operation you can replace substring "ab" with "bba".
				Find the minimum number of operations required to make so that no substring "ab" is present in the string s.
				Answer can be large so return it with modulo 109+7.

				Example 1:

				Input:
				s = "bab"
				Output: 
				1
				Explanation:
				In one operation string s becomes "bbba" , and there is no "ab" substring in "bbba".
				Example 2:

				Input:
				s = "abab"
				Output:
				4
				Explanation:
				Replace the first  "ab" substring from "abab" and string s becomes "bbaab" .
				Replace the last "ab" substring from "bbaab" and string s becomes "bbabba".
				Replace "ab" substring from "bbabba" and string s becomes "bbbbaba".
				Replace last "ab" substring from "bbbbaba" and string s becomes "bbbbbbaa".
				As we can see there is no substring in s after 4 operations.
				Your Task:
					You have to complete the function countOperations( ) , which takes string s as input parameters and return the number of operations  required to make such that there is no substring "ab" in s ,with modulo 10^9 + 7 .

				Constraints:
					1 <= length(s) <= 10^6
					s contains only 'a' and 'b'
					
			-Reference:
				#include <iostream>
				using namespace std;
				int main() {
					
					string s = "Hello World";
					std::cout << s << std::endl;						// Hello World
					
					int index = s.find("lo");
					s.erase(s.begin()+(index),s.begin()+(index)+2);
					std::cout << s << std::endl;						// Hel World
					
					s.insert(index, "Vi");
					std::cout << s << std::endl;						// HelVi World

					return 0;
				}
			
			// Not Optimized:
				class Solution {
					public:
					int countOperations(string s) {
						int cnt =0, mod = 1e9+7;
						
						while(s.find("ab") != string::npos){
							int index = s.find("ab");
							s.erase(s.begin()+index,s.begin()+index+2);
							s.insert(index, "bba");
							cnt++;
							cnt %= mod;
						}
						return cnt % mod;
					}
				};
			
			// Optimized:
				❌Pending

		914) Make Array Zero:
			Problem Statement:
				You are given a positive integer array arr of length n and two integers p and q .
				In one operation you can select any element from the array and decrease it by p and other remaining elements are decreased by q.If any element becomes negative then you can replace it with 0.
				You have to return minimum number of operations to make all elements of the array zero i.e. arr[i] = 0

				Example 1:
				Input:
				n = 3
				arr = {1, 2, 3}
				p = 2
				q = 1
				Output:
				2
				Explanation:
				First perform the operation on arr[1] then arr[0] becomes 1-1 = 0 , arr[1] becomes 2-2 = 0 and arr[2] becomes 3-1 = 2. i.e. arr becomes {0, 0, 2}
				Perform the second operation on arr[2] and arr becomes = {-1, -1, 0} and after replacing the negative element by zero arr becomes {0, 0, 0}.
				So there are two operation are required.

				Example 2:
				Input:
				n = 4
				arr = {4, 5, 6, 7}
				p = 3
				q = 1
				Output:
				4
				Explanation:
				First perform the operation on arr[3] then arr becomes {3, 4, 5, 4} .
				Perform the second operation on arr[2] and arr becomes {2, 3, 2, 3} .
				Perform the third operation on arr[3] and arr becomes {1, 2, 1, 0} .
				Perform the fourth operation on arr[1] and arr becomes = {0, 0, 0, 0} .
				So total 4 operations are required.

				Your Task:
					You have to complete the function minimumOperations() , which takes integer n , and positive integer array arr of length n and two integers p and q as input parameters and returns the number of operations required to make arr zero.
				Constraints:
					1 <= n <= 10^4
					0 <= arr[i] <= 10^5
					1 <= q < p <= 10^5 

			// Not Optimized:
				class Solution {
					public:
					bool checkAllZero(vector<int> &v){
						for(int i: v)
							if(i > 0)
								return 0;
						return 1;
					}
					
					int minimumOperations(int n, vector<int> &arr, int p, int q) {
						int minOps = 0;
						sort(begin(arr), end(arr));
						
						// if(checkAllZero(arr))
						//     return minOps;
							
						while(!checkAllZero(arr)){
							// last element decreasing it by p
							arr.back() -= p;
							
							// rest all elements decreasing them by q
							for(int i=0; i<arr.size()-1; i++)
								arr[i] -= q;
							
							sort(arr.begin(), arr.end());
							minOps++;
						}
						return minOps;
					}
				};
			
			// Optimized:
				❌Pending
		
	915) Append Characters to String to Make Subsequence:
		Problem Statement:
			You are given two strings s and t consisting of only lowercase English letters.
			Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.
			A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.
			
			Example 1:
			Input: s = "coaching", t = "coding"
			Output: 4
			Explanation: Append the characters "ding" to the end of s so that s = "coachingding".
			Now, t is a subsequence of s ("coachingding").
			It can be shown that appending any 3 characters to the end of s will never make t a subsequence.

			Example 2:
			Input: s = "abcde", t = "a"
			Output: 0
			Explanation: t is already a subsequence of s ("abcde").

			Example 3:
			Input: s = "z", t = "abcde"
			Output: 5
			Explanation: Append the characters "abcde" to the end of s so that s = "zabcde".
			Now, t is a subsequence of s ("zabcde").
			It can be shown that appending any 4 characters to the end of s will never make t a subsequence.
		
			Constraints:
				1 <= s.length, t.length <= 10^5
				s and t consist only of lowercase English letters.

		class Solution {
			public:
			int appendCharacters(string s, string t) {
				int i,j, found;
				i=j=found=0;
				int n = s.size();
				int m = t.size();
				for(i; i<n && j <m; i++)
					if(s[i] == t[j]){
						found++;
						j++;
					}
				return t.size() - found;
			}
		};
	
	916) Trail of ones:
		Problem Statement:
			Given a number n, find the number of binary strings of length n that contain consecutive 1's in them. Since the number can be very large, return the answer after modulo with 1e9+7.
			Example 1:
			Input:
			n = 2
			Output:
			1
			Explanation:
			There are 4 strings of 
			length 2, the strings 
			are 00, 01, 10, and 
			11. Only the string 11 
			has consecutive 1's.

			Example 2:
			Input:
			n = 5
			Output:
			19
			Explanation:
			There are 19 strings
			having consecutive 1's.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function numberOfConsecutiveOnes() which takes an integer n and returns the number of binary strings that contain consecutive 1's in them.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints
				2 <= n <= 10^5

		// Not Optimized:
			class Solution {
				public:
				bool containsConsective1s(string &s){
					int n = s.size();
					for(int i=0; i < n-1; i++)
						if(s[i] == '1' && s[i+1] == '1')
							return 1;
						
					return 0;
				}
				
				void BinaryAddition(string &s){
					char carryChar = '1';
					
					for(int i=s.size()-1; i>=0; i--){
						if(s[i] == '1' && carryChar == '1'){
							s[i] = '0';
						}else{
							s[i] = '1';
							carryChar = '0';
							break;
						}
					}
					
					if(carryChar == '1')
						s.insert(s.begin(), carryChar);
				}

				// or
				/* 
					void BinaryAddition(string &s){
						char carryChar = '1';
						int i;
						
						for(i=s.size()-1; i>=0; i--){
							if(s[i] == '1')
								s[i] = '0';
							else
								break;
						}
						
						if(i >= 0){
							s[i] = '1';
							carryChar = '0';
						}
						
						if(carryChar == '1')
							s.insert(s.begin(), carryChar);
					}			
				*/
						
				int numberOfConsecutiveOnes(int n) {
					int mod = 1e9+7, cnt=0;
					string s = "11";
					while(s.size() <= n){
						if(containsConsective1s(s))
							cnt++;
							
						// cout<<s<<endl;
						cnt %= mod;
						BinaryAddition(s);          // to generate the next number
					}
					return cnt % mod;
				}
			};

		// Optimized:
			❌Pending
	
	917) Palindrome Count:
		Problem statement
			Ninja loves to play with strings and anagrams. A palindrome is a string that is read the same backward or forward. An anagram is a string that is formed by rearranging the characters of the string. Ninjas have been given a string ‘STR’, and asked to find the number of substrings whose anagram is palindromic.
			Constraints :
				1 <= T <= 10
				1 <= |STR| <= 5*10^3
				The string ‘STR’ contains small letters only.   
				Time Limit : 1 sec
			Sample Input 1 :
				2
				aa
				abc
				Sample Output 1 :
				3
				3
				Explanation For Sample Input 1 :
				For first test case :

				Substring are: {a, a, aa}
				Since, all the substrings are palindromes.
				So, the result is 3.

				For second test :

				Substring are: {a, b, c, ab, bc, abc}
				Since, all {a, b, c} are palindromes. And no anagram of {ab, bc, abc} have palindromes. 
				So, the result is 3.
				Sample Input 2 :
				2
				aaa
				aab
				Sample Output 2 :
				6
				5

		// Not Optimized:
			bool isPalin(string s){
				map<char, int> Fr;
				for(char ch: s){
					Fr[ch]++;
				}

				int cnt = 0;
				for(auto i: Fr){
					if(i.second&1)
						cnt++;
					if(cnt > 1)
						return 0;
				}
				return 1;
			}

			int palinCount(string s) {
				// need to generate all the substring of s
				vector<string> v;
				int n = s.size();
				for(int i=0; i<n-1; i++){
					string temp = string(1, s[i]);
					for(int j=i+1; j<n; j++){
						temp += s[j];
						v.push_back(temp);
					}
				}

				int totalCnt = n;
				// checking substring is palidrom or not
				for(string sample: v)
					if(isPalin(sample))
						totalCnt++;

				return totalCnt;
			}
		
		// Optimized:
			❌Pending
	
	918) Binary representation of next number:
		Problem Statement:
			Given a binary representation in the form of a string(s) of a number n, the task is to find a binary representation of n+1.
			Example 1:
			Input: s = "10"
			Output: 11
			Explanation: "10" is the binary representation of 2 and binary representation of 3 is "11"

			Example 2:
				Input: s = "111"
				Output: 1000
				Explanation: "111" is the binary representation of 7 and binary representation of 8 is "1000"

			Your Task:  
				You don't need to read input or print anything. Complete the function binaryNextNumber()which takes s as input parameter and returns the string.
				
			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n) to store resultant string  

			Constraints:
				1 <= n <= 10^5

		class Solution {
			public:
			string binaryNextNumber(string s) {
				char carryChar = '1';
				
				for(int i=s.size()-1; i>=0; i--){
					if(s[i] == '1')
						s[i] = '0';
					else{
						s[i] = '1';
						carryChar = '0';
						break;
					}
				}
				
				if(carryChar == '1')
					s.insert(s.begin(), '1');
				
				// removes leading zeros
				// s = s.substr(s.find('1'));               // finding the first occurence of 1 to remove the leading zero
				
				// or
				// while(s[0] == '0')
				//     s.erase(s.begin());                 // manualy removing the leading zeros one by one
				
				// or
				int index = s.find('1');                // finding the index of first occurence of char 1 in string
				s = s.substr(index);                    // from that index considering as new string, without leading zeros
				
				return s;
			}
		};
	
	919) Longest Palindrome:
		Problem Statement:
			Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome
			that can be built with those letters.
			Letters are case sensitive, for example, "Aa" is not considered a palindrome.

			Example 1:
			Input: s = "abccccdd"
			Output: 7
			Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.

			Example 2:
			Input: s = "a"
			Output: 1
			Explanation: The longest palindrome that can be built is "a", whose length is 1.
			
			Constraints:
				1 <= s.length <= 2000
				s consists of lowercase and/or uppercase English letters only.

		class Solution {
			public:
			static bool DESC_By_values(pair<char, int> &a, pair<char, int> &b){
				return a.second > b.second;
			}

			int longestPalindrome(string s) {
				map<char, int> Fr;

				for(char ch: s)
					Fr[ch]++;
				
				if(Fr.size() == 1)
					return s.size();
				
				vector<pair<char, int>> v;
				for(auto i: Fr)
					v.push_back(i);

				sort(v.begin(), v.end(), DESC_By_values);
				
				// for(auto i: v)
				//     cout<<i.first << "\t"<<i.second<<endl;

				int flagOddOnce = 1, cnt = 0;
				for(auto i: v){
					if(i.second&1 && flagOddOnce){       // once add full odd
						cnt += i.second;
						flagOddOnce = 0;
					}else if(i.second&1){               // decrement by one & then add
						cnt += (i.second)-1;
					}else{                              // if it is even then just add
						cnt += i.second;
					}
				}
				return cnt;
			}
		};

		// or simpler:
			class Solution {
				public:
				int longestPalindrome(string s) {
					set<char> st;
					int cnt =0;

					for(char ch: s){
						if(st.count(ch)){               // count method returns the 1 if element is present in set, else 0
							cnt += 2;
							st.erase(ch);
						}else{
							st.insert(ch);
						}
					}

					if(!st.empty())
						cnt++;

					return cnt;   
				}
			};
	
	920) PRETTY JSON:
		Problem statement
			You are given a string 'STR' representing JSON object. Return an array of strings denoting JSON objects with proper indentation.
			Rules for proper indentation:
			1. Every inner brace should increase one indentation to the following lines.
			2. Every close brace should decrease one indentation to the same line and the following lines.
			3. Every ‘,’ will mean a separate line.
			4. The indents can be increased with an additional 4 spaces or ‘/t’.
			Example:
			Let the input be: "{A:"B",C:{D:"E",F:{G:"H",I:"J"}}}"
			Then we return the following array of strings: 
			{ 
				A:"B",
				C: 
				{ 
					D:"E",
					F: 
					{ 
						G:"H",
						I:"J"
					} 
				} 
			}

			Note that for every new brace we are putting an additional 4 spaces or \t.
			Note:
			1. [] and {} are only acceptable braces in this case.
			Constraints:
				1 <= T <= 100
				1 <= N <= 2*10^3
				Where 'N' denotes the length of the string.
				Time limit: 1 sec
			Sample Input 1:
			2
			["foo", {"bar":["baz",null,1.0,2]}]
			[{"EmployeeID":1,"Name":"Abhishek","Designation":"SoftwareEngineer"}]
			Sample Output 1:
			[
				"foo",
				{
					"bar":
					[
						"baz",
						null,
						1.0,
						2
					]
				}
			]
			[
				{
					"Employee ID":1,
					"Name":"Abhishek",
					"Designation":"SoftwareEngineer"
				}
			]
			Explanation of sample input 1 :
			Test Case 1:

			In the first test case,
			We can see that we have 3 braces so we print when we encounter ‘[‘ we indent by leaving 4 spaces and then put “foo” in the string. 
			Then we indent 4 more spaces and put “bar”.
			Finally, we indent 4 more spaces for the last opening brace and then print baz.
			Since we have ‘,’ after ‘bazz’ we make a new line for null and the numbers. 
			Finally, we close the brackets taking care of the proper indentation.


			In the second test case,
			We have 2 braces only. After the first ‘[‘ we leave 4 spaces and put ‘{‘ in the string.
			Then we put the string data taking care to change the line after every ‘,’  and de-indent for every closing brace.
			Sample Input 2:
			1
			{"EmployeeID":2,"Name":"Garima","Designation":"EmailMarketing Specialist"}
			Sample Output 2:
			{
				"Employee ID":2,
				"Name":"Garima",
				"Designation":"EmailMarketing Specialist"
			}

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<string> prettyJSON(string &str) {
				vector<string> ans;
				string cur, spacer;

				for(char ch: str){
					if(ch == '{' or ch == '['){
						if(!cur.empty()){
							cur = spacer + cur;
							ans.push_back(cur);
							cur.clear();
						}
						ans.push_back(spacer + ch);
						spacer += "\t";
					}else if(isdigit(ch) or isalpha(ch) or ch == '.'  or ch == '"' or ch == ':' or ch == '_' or ch == '-'){
						cur += ch;
					}else if(ch == ','){
						if(ans.back().find('}') != string::npos or ans.back().find(']') != string::npos){
							string test = ans.back() + ch;
							ans.pop_back();
							ans.push_back(test);
						}else{
							cur += ch;
							cur = spacer + cur;
							ans.push_back(cur);
							cur.clear();
						}
					}else{
						if(!cur.empty()){
							ans.push_back(spacer+cur);
							cur.clear();
						}
						spacer.pop_back();
						ans.push_back(spacer+ch);
					}
				}
				return ans;
			}
	
		// Optimized:
			❌Pending

	921) Fair Indexes:
		Problem statement
			Levi Ackerman has two arrays, ‘A’ and ‘B’ consisting of ‘N’ integers each. He wants to divide these two arrays into two parts each, such that the sum of all the elements in the first part is equal to the sum of elements in the second part, and the index ‘k’ where the splitting is done, must be the same in both the arrays.
			In simple terms, If he splits the array at index k, then (A[0]+A[1]....A[k]), (A[k + 1] + A[k + 2]....A[n - 1]), (B[0] + B[1]....B[k]), (B[k + 1] + B[k + 2]....B[n - 1]) are all equal.
			Find the total number of all the Indexes which satisfy the given condition.
			For Example :
			n = 4, A = {2, 4, 5, 1}, B = {3, 3, 10, -4}
			Now in this example, if we split the array at index 1 then the sum of all the subarrays is 2 + 4 = 6, 5 + 1 = 6, 3 + 3 = 6, 10 + (-4) = 6, and no other index satisfies this condition, hence the answer is 1.
			Constraints :
				1 <= T <= 100
				2 <= N <= 10^5
				-10^9 <= A[i], B[i] <= 10^9
				Time Limit: 1 second
			Sample Input 1 :
				2
				3
				1 2 3
				2 1 3
				2
				6 6
				10 2
				Sample Output 1 :
				1
				0
				Explanation For Sample Output 1 :
				In the first test case, at index 1, the sum of the first array is 3, 3, and the sum of the second array is also 3, 3. Hence the answer is 1.

				In the second test case, There is no index satisfying the given condition. Hence, the answer is 0.
				Sample Input 2 :
				2
				5
				-5 2 -10 -3 6
				-5 -10 3 4 -2
				5  
				1 4 2 -2 5 
				7 -2 -2 2 5  
				Sample Output 2 :
				1
				2

		#include<bits/stdc++.h>
		int totalIndexes(vector<int> &A, vector<int> &B) {
			int cnt=0;

			long long sumA = accumulate(A.begin(), A.end(), 0LL);
			long long sumB = accumulate(B.begin(), B.end(), 0ll);
			int n = A.size();
			
			long long curSumA = 0;
			long long curSumB = 0;
			
			for(int i=0; i<n-1; i++){
				curSumA += A[i];
				curSumB += B[i];

				sumA -= A[i];
				sumB -= A[i];

				if(curSumB == sumB && curSumA == sumA && sumA == sumB)
					cnt++;
			}
			return cnt;
		}

	922) Swapping pairs make sum equal:
		Problem Statement:
			Given two arrays of integers a[] and b[] of size n and m, the task is to check if a pair of values (one value from each array) exists such that swapping the elements of the pair will make the sum of two arrays equal.

			Example 1:
				Input: n = 6, m = 4, a[] = {4, 1, 2, 1, 1, 2}, b[] = (3, 6, 3, 3)
				Output: 1
				Explanation: Sum of elements in a[] = 11, Sum of elements in b[] = 15, To get same sum from both arrays, we can swap following values: 1 from a[] and 3 from b[]

			Example 2:
				Input: n = 4, m = 4, a[] = {5, 7, 4, 6}, b[] = {1, 2, 3, 8}
				Output: 1
				Explanation: We can swap 6 from array a[] and 2 from array b[]

			Your Task
				You don't need to read or print anything. You need to complete the function findSwapValues() that takes array a, array b, integer n, and integer m as parameters and returns 1 if there exists any such pair otherwise returns -1.

			Expected Time Complexity: O(mlogm+nlogn).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ n, m ≤ 10^6

		// Not Optimized:
			class Solution {
				public:
				bool areSumEqual(int a[], int b[], int n, int m){
					
					long long sumA = accumulate(a, a+n, 0LL);				// long sumA = accumulate(a, a+n, 0L);
					long long sumB = accumulate(b, b+m, 0ll);				// long sumB = accumulate(b, b+m, 0l); 
					
					if(sumA == sumB)
						return 1;
					return 0;
				}
				int findSwapValues(int a[], int n, int b[], int m) {
					for(int i=0; i<n; i++){
						for(int j=0; j<m; j++){
							swap(a[i], b[j]);
							if(areSumEqual(a, b, n, m))
								return 1;
							swap(a[i], b[j]);
						}
					}
					return -1;
				}
			};
			
		// Optimized:
			❌Pending

	923) Insert Interval (Refer Q.910):
		https://www.naukri.com/code360/problems/insert-interval_1102297
		Problem statement
			You are given a list of ‘N’ non-overlapping intervals (each interval can be represented using two integers ‘start’ and ‘end’), sorted in ascending order (based on ‘start’ values). Your task is to insert a given interval in the list, such that all the intervals are present in sorted order.
			In case the given interval overlaps with other intervals, merge all necessary intervals to produce a list containing only non-overlapping intervals.
			Example:
			Let’s say the list of intervals is: [[1,3], [5,7], [8,12]] and we need to insert the interval [4,6] into the list. [4,6] must be inserted in the second position. After insertion, since [4,6] overlaps with [5,7], we merge them into one interval [4,7]. So, our resulting list is:  [[1,3], [4,7], [8,12]]
			Constraints:
				1 <= T <= 10 
				1 <= N <= 5 * 10^4
				1 <= start <= end <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				3
				1 3
				5 7
				8 12
				4 6
				2
				2 3
				5 8
				1 9
				Sample Output 1:
				1 3
				4 7
				8 12
				1 9
				Explanation 1:
				For the first test case,  The list of intervals is: [[1,3], [5,7], [8,12]] and we need to insert the interval [4,6] into the list. [4,6] must be inserted in the second position. After insertion, since [4,6] overlaps with [5,7], we merge them into one interval [4,7]. So, our resulting list is:  [[1,3], [4,7], [8,12]]

				For the second test case, N = 2. The list of intervals is: [[2,3], [5,8]] and we need to insert the interval [1,9] into the list. [4,6] must be inserted in the first position. After insertion, since it overlaps with [2,3] and [5,8], we merge them into one interval [1,9]. So, our resulting list is:  [[1,9]].
				Sample Input 2:
				2
				3
				1 3
				5 7
				8 12
				4 10
				2
				2 3
				5 10
				1 4
				Sample Output 2:
				1 3 
				4 12
				1 4
				5 10

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> insertInterval(vector<vector<int>> &intervals, vector<int> &newInterval) {
				intervals.push_back(newInterval);
				sort(intervals.begin(), intervals.end());

				vector<vector<int>> ans {intervals[0]};

				for(int i=1; i<intervals.size(); i++){
					if(ans.back()[1] >= intervals[i][0]){
						// if(ans.back()[0] >= intervals[i][0]){
						//     ans.pop_back();
						//     ans.push_back(intervals[i]);
						// }else{
							if(ans.back()[1] < intervals[i][1])
								ans.back()[1] = intervals[i][1];
						// }
					}else{
						ans.push_back(intervals[i]);
					}
				}
				return ans;
			}

		// Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> insertInterval(vector<vector<int>> &intervals, vector<int> &newInterval) {
				int i=0, n = intervals.size();
				vector<vector<int>> ans;

				while(i<n && intervals[i][1] < newInterval[0])
					ans.push_back(intervals[i++]);
				
				while(i<n && intervals[i][0] <= newInterval[1]){
					newInterval[0] = min(intervals[i][0], newInterval[0]);
					newInterval[1] = max(intervals[i][1], newInterval[1]);
					i++;
				}

				ans.push_back(newInterval);
				while(i<n)
					ans.push_back(intervals[i++]);

				return ans;
			}
	
	924) Rotate DLL
		https://www.naukri.com/code360/problems/rotate-dll_1115782
		Problem statement
			You are given a doubly-linked list with 'N' nodes, rotate the linked list counter-clockwise by 'K' nodes. 'K' is a positive integer and is smaller than the number of nodes in the linked list, that is 'N'.
			A doubly linked List (DLL) contains an extra pointer, called the previous pointer, together with the next pointer and data which are there in the singly linked list such that both forward and backward navigation is possible.
			For example
			The given linked list is - 
			If K = 3, then the list after rotating it by K nodes is:
			Note:
			1. The value of any node in the linked list will not be equal to -1.
			Constraints:
				1 <= T <= 5
				1 <= N <= 3000
				1 <= K < N
				-10 ^ 7 <= data <= 10 ^ 7
				where ‘T’ is the total number of test cases, 'N' is the total number of nodes in the linked list and ‘data’ is the value of any node of the linked list.

			Sample Input 1 :
			2
			4 3 9 1 7 8 -1
			4
			1 2 3 4 5 -1
			2
			Sample Output 1 :
			7 8 4 3 9 1 
			3 4 5 1 2
			Explanation of The Sample Input 1:
			For the first test case:
			The given linked list is :
			4 <-> 3 <->  9 <->  1 <-> 7 <-> 8 <-> NULL

			And K = 4 therefore we have to rotate the linked list by 4 nodes. So after the rotation, list will become  
			7 <-> 8 <->  4 <-> 3 <-> 9 <-> 1 <-> NULL

			For the second test case:
			The given linked list is 
			1 <-> 2 <->  3 <->  4 <-> 5  <-> NULL                                                          
			And K = 2 therefore we have to rotate the linked list by 2 nodes. So after the rotation, list will become  
			3 <-> 4 <->  5 <-> 1 <-> 2 <-> NULL
			Sample Input 2 :
			2
			6 2 4 2 1 4 -1
			2
			12 33 55 11 22 -1
			3
			Sample Output 2 :
			4 2 1 4 6 2
			11 22 12 33 55

		// Not Optimized:
			#include <bits/stdc++.h> 
			/****************************************************
				Following is the class structure of the DLLNode class:
				class DLLNode {
				public:
					int data;
					Node *next;

					DLLNode(int data) {
						this->data = data;
						this->next = NULL;
						this->prev = NULL;
					}
				}
			*****************************************************/

			DLLNode* rotateDLL(DLLNode* head, int k) {
				// finding the Tail
				DLLNode* Tail = head;
				while(Tail -> next)
					Tail = Tail -> next;

				// Tail found now need to attach every upcoming node to Tail now
				while(k--){
					DLLNode * temp = head;
					head = head -> next;
					head -> prev = NULL;

					Tail -> next = temp;
					temp -> prev = Tail;
					temp -> next = NULL;
					Tail = Tail -> next;
				}
				return head;
			}

		// Optimized:
			❌Pending

	925) Find Common Characters:
		Problem Statement:
			Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.
			Example 1:
				Input: words = ["bella","label","roller"]
				Output: ["e","l","l"]

			Example 2:
				Input: words = ["cool","lock","cook"]
				Output: ["c","o"]
			

			Constraints:
				1 <= words.length <= 100
				1 <= words[i].length <= 100
				words[i] consists of lowercase English letters.

		class Solution {
			public:
			vector<string> commonChars(vector<string>& words) {
				vector<map<char, int>> everyWord;
				for(string s: words){
					map<char, int> Fr;
					for(char ch: s)
						Fr[ch]++;
					everyWord.push_back(Fr);
				}

				map<char, int> mainFr = everyWord[0];
				vector<string> ans;
				for(auto i: mainFr){
					char curCh = i.first;
					int iteration = i.second;
					int flag = 1;
					while(iteration--){
						for(int i=1; i<everyWord.size(); i++){
							if(everyWord[i][curCh] > 0){
							everyWord[i][curCh]--;
							}else{
							flag = 0;
							break;
							}
						}
						if(flag)
							ans.push_back(string(1, curCh));
					}
				}
				return ans;
			}
		};
	
	926) Level order traversal:
		Problem Statement:
			Given a root of a binary tree with n nodes, find its level order traversal.
			Level order traversal of a tree is breadth-first traversal for the tree.

			Example 1:

			Input:
			     1
			    / \ 
			   3   2
			Output:
			1 3 2
			Example 2:

			Input:
				   10
			  	 /   \
			    20	 30
			  /   \
			 40   60
			Output:
			10 20 30 40 60
			Your Task:
				You don't have to take any input. Complete the function levelOrder() that takes the root node as input parameter and returns a list of integers containing the level order traversal of the given Binary Tree.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n ≤ 10^5
				0 ≤ Data of a node ≤ 10^9

		/* A binary tree Node
			struct Node {
				int data;
				struct Node* left;
				struct Node* right;
				
				Node(int x){
					data = x;
					left = right = NULL;
				}
			};
		*/
		class Solution {
			public:
			void LevelTraversal(Node* r, vector<int> &a){
				queue<Node *> q;
				q.push(r);
				
				while(!q.empty()){
					Node *temp = q.front();
					q.pop();
					
					if(temp -> left)
						q.push(temp -> left);
					
					if(temp -> right)
						q.push(temp -> right);
					
					a.push_back(temp -> data);
				}
			}
			//Function to return the level order traversal of a tree.
			vector<int> levelOrder(Node* root) {
				vector<int> ans;
				
				LevelTraversal(root, ans);
				return ans;
			}
		};

		// or concise:
			class Solution {
				public:
				//Function to return the level order traversal of a tree.
				vector<int> levelOrder(Node* root) {
					vector<int> ans;
					if(!root) return ans;
					
					queue<Node*> q;
					q.push(root);
					
					while(!q.empty()){
						Node* cur = q.front();
						q.pop();
						
						ans.push_back(cur -> data);
						
						if(cur -> left) q.push(cur -> left);
						if(cur -> right) q.push(cur -> right);
					}
					return ans;
				}
			};
	
	927) Reverse Level Order Traversal:
		Problem Statement:
			Given a binary tree of size n, find its reverse level order traversal. ie- the traversal must begin from the last level.
			Example 1:
			Input :
				  1
				/   \
			    3     2

			Output: 
			3 2 1
			Explanation:
			Traversing level 1 : 3 2
			Traversing level 0 : 1
			Example 2:

			Input :
				 10
				/  \
			    20   30
			   /  \ 
			  40  60

			Output: 
			40 60 20 30 10
			Explanation:
			Traversing level 2 : 40 60
			Traversing level 1 : 20 30
			Traversing level 0 : 10
			Your Task: 
				You don't need to read input or print anything. Complete the function reverseLevelOrder() which takes the root of the tree as input parameter and returns a list containing the reverse level order traversal of the given tree.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n ≤ 10^4
		
		Using vector
		// Reference:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;
			int main() {
				vector<vector<int>> v {{1,2,3}, {4,5,6}, {7,8,9}};
				vector<int> a;
				for(int i=2; i>=0; i--)
					a.insert(a.end(), v[i].begin(), v[i].end());
				
				for(int i: a)
					std::cout << i << "\t";	
				return 0;
			}

		/*
			struct Node {
				int data;
				Node* left;
				Node* right;
			};
		*/

		void LevelOrderTraversal(Node *r, vector<vector<int>> &v){
			queue<Node *> q;
			q.push(r);
			q.push(NULL);
			
			vector<int> test;
			
			while(!q.empty()){
				Node* curNode = q.front();
				q.pop();
				
				if(curNode){
					test.push_back(curNode -> data);
					
					if(curNode -> left)
						q.push(curNode -> left);
					
					if(curNode -> right)
						q.push(curNode -> right);
				}else{
					if(!test.empty())
						v.push_back(test);
					test.clear();
					if(!q.empty())
						q.push(NULL);
				}
			}
		}

		vector<int> reverseLevelOrder(Node *root) {
			vector<vector<int>> holder;
			LevelOrderTraversal(root, holder);
			
			// reverse level order, reversing the sequence
			vector<int> ans;
			for(int i=holder.size()-1; i>=0; i--){
				vector<int> cur = holder[i];
				
				ans.insert(ans.end(), cur.begin(), cur.end());
			}
			return ans;
		}

	#CodeChef Starters-137:
		928) Election Hopes:
			https://www.codechef.com/problems/ELHP
			Problem Statement:
				The elections in Chefland have concluded, and the results are in Chef received X votes, and his rival Chefu received Y.
				Chef thinks he dominated the election if and only if he received at least double the number of votes Chefu received.
				Did Chef dominate the election?

				Input Format
					The only line of input contains two space-separated integers X and 𝑌 — the number of votes received by Chef and Chefu, respectively.
				Output Format
					Print a single line containing the answer: either "Yes" or "No" (without quotes), depending on whether Chef dominated the election or not.
				Each letter of the output may be printed in either uppercase or lowercase, i.e, the strings No, no, NO, and nO will all be treated as equivalent.

				Constraints
				1≤X,Y≤100
				Sample 1:
				Input
				79 40
				Output
				No
				Explanation:
				Chef received 79 votes, and Chefu received 40.Twice of 40 is 80, and since Chef didn't receive ≥ 80 votes, he didn't dominate the election.

				Sample 2:
				Input
				28 14
				Output
				Yes
				Explanation:
				Chef received 28 votes, and Chefu received 14.
				Twice of 14 is 28, and since Chef received ≥ 28 votes, he dominated the election.
			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int x,y;
				cin>>x>>y;
				
				if(x >= y*2)
					cout<<"Yes";
				else
					cout<<"No";
				return 0;
			}
		
		929) Spell Splice:
			https://www.codechef.com/START137D/problems/CMIX
			Problem Statement:
				Chef has N magic spells. The i-th spell has a volatility of Vi and a strength of Ai.
				When spells 𝑖 and 𝑗 (1 ≤ i < j ≤ N) are activated together, they merge to form a single spell of strength (𝐴𝑖 × 𝑉𝑗 + 𝑉𝑖 × 𝐴𝑗).
				What's the maximum possible strength of a spell Chef can obtain by activating exactly two of his spells?

				Input Format
					The first line of input will contain a single integer T, denoting the number of test cases. Each test case consists of multiple lines of input.
				The first line of each test case contains a single integer N, the number of spells.
				The next N lines describe the spells. The i-th of them contains two space-separated integers 𝑉𝑖 and Ai — the volatility and strength of the i-th spell.
				Output Format
					For each test case, output on a new line the maximum possible power of a combined spell.

				Constraints
					1≤T≤100
					2≤N≤100
					1 ≤ 𝐴𝑖 , 𝑉𝑖 ≤ 1000
				Sample 1:
					Input
						3
						2
						1 10
						5 5
						4
						4 7
						8 9
						10 2
						6 6
						4
						35 45
						5 50
						50 5
						45 35
					Output
						55
						106
						3250
				Explanation:
				Test case 1: There are only two spells. Combining them results in a spell of strength 1×5+5×10=55.
				Test case 2: It's optimal to choose the second and third spells. Combining them results in a spell of strength 8×2+10×9=106.
				Test case 3: It's optimal to choose the first and fourth spells. Combining them results in a spell of strength 45×45+35×35=3250.

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int T;
				cin>>T;
				
				while(T--){
					int n;
					cin>>n;
					vector<vector<int>> v;
					
					int mx =0;
					for(int i=0; i<n; i++){
						int f,s;
						cin>>f>>s;
						v.push_back({f,s});
					}
					
					for(int i=0; i<n-1; i++){
						for(int j=i+1; j<n; j++){
							mx = max(mx, ((v[i][0] * v[j][1])+ (v[i][1] * v[j][0])));
						}
					}
					cout<<mx<<endl;
				}
				return 0;
			}
		
		930) Large Differences:
			https://www.codechef.com/START137D/problems/HIDIF
			Problem Statement:
				You are given an array A of length N, and a positive integer K.
				It is guaranteed that 1 ≤ Ai ≤ K for every index i from 1 to N.
				You can do the following at most once:
				Choose an index i(1 ≤ i ≤ N) and a value (1 ≤ x ≤ K).
				Then, set Ai := x.
				Find the maximum possible value of the sum of adjacent differences of A after performing this operation at most once.
				That is, maximize the quantity
				Input Format
				The first line of input will contain a single integer T, denoting the number of test cases.
				Each test case consists of two lines of input.
				The first line of each test case contains two space-separated integers N and 𝐾
				K — the length of the array and the maximum allowed integer K, respectively.
				The second line contains N space-separated integers 𝐴1, 𝐴2,…,𝐴𝑁 the elements of array A.
				Output Format
				For each test case, output on a new line the answer: the maximum possible sum of adjacent differences of A after replacing at most one element.
				
				Constraints
					1≤T≤100
					1≤N≤1000
					1≤K≤2⋅10^6 
					1 ≤ Ai ≤ K
				The sum of N across all tests won't exceed 1000.
				Sample 1:
				Input
					3
					2 5
					1 5
					3 8
					7 2 7
					5 20
					18 3 1 4 19
				Output
					4
					12
					63
				Explanation:
				Test case 1: It's best to leave the array unchanged, giving us a difference of ∣1−5∣=4.
				Test case 2: It's optimal to set A2 :=1, giving us the array [7,1,7]. The sum of adjacent differences is 6+6=12.
				Test case 3: It's optimal to set A3 :=20, to obtain [18,3,20,4,19]. The sum of adjacent differences is 63.

			// Not Optimized:
				#include <bits/stdc++.h>
				using namespace std;

				int AdjacentDiffSum(vector<int> &v){
					int val = 0, n=v.size();
					for(int i=0; i<n-1; i++){
						val += abs(v[i]-v[i+1]);
					}
					return val;
				}

				int main() {
					int T;
					cin>>T;
					
					while(T--){
						int n, k;
						cin>>n>>k;
						
						vector<int> v(n);
						for(int i=0; i<n; i++)
							cin >> v[i];
						
						int mxDiff = 0;
						
						for(int i=0; i<n; i++){
							// trying brute force checking every element by putting (1 to k) as value & finding the adjacent difference sum
							int temp = v[i];
							mxDiff = max(mxDiff, AdjacentDiffSum(v));
							int curValue = 1;
							while(curValue <= k){
								if(curValue == v[i]){
									curValue++;
									continue;
								}
								v[i] = curValue++;
								mxDiff = max(mxDiff, AdjacentDiffSum(v));
							}
							v[i] = temp;
						}
						cout<<mxDiff<<endl;
					}
					return 0;
				}

			// Optimized:
				❌Pending

	931) Max sum in the configuration:
		Problem statemene:
			Given an integer array(0-based indexing) a of size n. Your task is to return the maximum value of the sum of i*a[i] for all 0 <= i <= n-1, where a[i] is the element at index i in the array. The only operation allowed is to rotate(clockwise or counterclockwise) the array any number of times.
			Example 1:
			Input: n = 4, a[] = {8, 3, 1, 2}
			Output: 29
			Explanation: All the configurations possible by rotating the elements are:
			3 1 2 8 here sum is 3*0+1*1+2*2+8*3 = 29
			1 2 8 3 here sum is 1*0+2*1+8*2+3*3 = 27
			2 8 3 1 here sum is 2*0+8*1+3*2+1*3 = 17
			8 3 1 2 here sum is 8*0+3*1+1*2+2*3 = 11, so the maximum sum will be 29.

			Example 2:
			Input: n = 3, a[] = {1, 2, 3}
			Output: 8
			Explanation: All the configurations possible by rotating the elements are:
			1 2 3 here sum is 1*0+2*1+3*2 = 8
			3 1 2 here sum is 3*0+1*1+2*2 = 5
			2 3 1 here sum is 2*0+3*1+1*2 = 5, so the maximum sum will be 8.

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(1).

			Constraints:
				1<=n<=10^5
				1<=a[]<=10^6

		// Not Optimized:
			class Solution {
				public:
				long long max_sum(int a[], int n) {
					long long mxAns = 0;
					int times = n;
					while(times--){
						long long CurSum = 0;
						for(int i=0; i<n; i++){
							CurSum += (i * a[i]);
						}
						mxAns = max(mxAns, CurSum);
						rotate(a, a+1, a+n);
					}
					return mxAns;
				}
			};
		
		// Optimized:
			❌Pending

	932) Diagonal Traversal of a binary tree:
		https://www.naukri.com/code360/problems/diagonal-traversal-of-a-binary-tree_920477
		Problem statement
			You have been given a binary tree of integers. You are supposed to find the diagonal traversal(refer to Example) of the given binary tree.
			Example:
			Consider lines at an angle of 135 degrees(with respect to standard X- axis)  in between nodes. Then, all nodes between two consecutive lines belong to the same diagonal
			The diagonal traversal for the above tree is: 
			0 2 6 1 5 3 4 7 
			Constraints :
				1 <= T <= 100
				0 <= N <= 3000
				0 <= data <= 10^5 and data!=-1
				Where ‘N’ is the total number of nodes in the binary tree, and 'data' is the value of the binary tree node
				Time limit : 1 sec

			Sample Input 1 :
			2
			1 2 3 4 -1 -1 -1 -1 -1
			0 1 2 4 5 3 6 -1 -1 7 -1 -1 -1 -1 -1 -1 -1
			Sample Output 1 :
			1 3 2 4
			0 2 6 1 5 3 4 7
			Explanation of Sample Output 1 :
			In test case 1,
			Nodes 1 and 3 belong to diagonal number 0, node 2 belongs to diagonal 1, and node 4 belongs to diagonal number 2.
			In test case 2, nodes 0,2,6 belong to diagonal 0, nodes 1,5,3 belong to diagonal 1, and nodes 4,7 belong to diagonal number 2.
			Sample Input 2 :
			2
			1 -1 2 -1 -1
			5 7 8 -1 -1 -1 -1
			Sample Output 2 :
			1 2
			5 8 7
			Explanation of Sample Output 2 :
			In test case 1, nodes 1,2 both belong to diagonal number 0. 
			In test case 2, nodes 5,8 belong to diagonal number 0, and node 7 belongs to diagonal number 1.

		#include <bits/stdc++.h> 
		/************************************************************
			Following is the TreeNode class structure:
			template <typename T>
			class TreeNode {
				public:
					T data;
					TreeNode<T> *left;
					TreeNode<T> *right;

				TreeNode(T data) {
					this->data = data;
					left = NULL;
					right = NULL;
				}
			};
		************************************************************/
		vector<int> diagonalTraversal(TreeNode<int> *root) {
			vector<int> ans;
			queue<TreeNode<int>*> q;

			if(root == NULL)
				return ans;

			q.push(root);   
			while(!q.empty()){
				TreeNode<int> *temp = q.front();
				q.pop();

				while(temp){
					if(temp -> left)
						q.push(temp -> left);

					ans.push_back(temp -> data);
					temp = temp -> right;
				}
			}
			return ans;
		}
	
	933) Diagonal Traversal: (Used extra vector to put the new lines after diagonal traversal ends)
		https://www.naukri.com/code360/problems/diagonal-traversal_920391
		Problem statement
			You are given a binary tree having ‘N’ nodes. Your task is to return its diagonal traversal.
			A binary tree is a hierarchical data structure in which each node has at most two children.
			For Example:
					  8
					/   \
				    3     10
				   / \	  \
				  1	 6	   \  
				  	/ \ 	    \	
				    4   7	    14
				    		    /
						  13	
			For the above binary tree, the output will be:
			8 10 14
			3 6 7 13
			1 4
			Input Format:
				The first line contains an Integer 'T' which denotes the number of test cases or queries to be run. Then the test cases follow.

				The first line of each test case contains the elements of the tree in the level order form separated by a single space.
				If any node does not have a left or right child, take -1 in its place. Refer to the example below.
			Example:
			Elements are in the level order form. The input consists of values of nodes separated by a single space in a single line. In case a node is null, we take -1 in its place.
			For example, the input for the tree depicted in the below image would be :
				    1
				   / \
				  2   3
			 	/   / \
			    4   5   6
				\
				 7



			1
			2 3
			4 -1 5 6
			-1 7 -1 -1 -1 -1
			-1 -1

			Explanation :
			Level 1 :
			The root node of the tree is 1

			Level 2 :
			Left child of 1 = 2
			Right child of 1 = 3

			Level 3 :
			Left child of 2 = 4
			Right child of 2 = null (-1)
			Left child of 3 = 5
			Right child of 3 = 6

			Level 4 :
			Left child of 4 = null (-1)
			Right child of 4 = 7
			Left child of 5 = null (-1)
			Right child of 5 = null (-1)
			Left child of 6 = null (-1)
			Right child of 6 = null (-1)

			Level 5 :
			Left child of 7 = null (-1)
			Right child of 7 = null (-1)

			The first not-null node (of the previous level) is treated as the parent of the first two nodes of the current level. The second not-null node (of the previous level) is treated as the parent node for the next two nodes of the current level and so on.
			The input ends when all nodes at the last level are null (-1).
			Note: The above format was just to provide clarity on how the input is formed for a given tree. 
			The sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as:
			1 2 3 4 -1 5 6 -1 7 -1 -1 -1 -1 -1 -1
			Output Format :
				For each test case, print each diagonal traversal in a new line.
				The output of each test case should be printed in a separate line.
			Note
				You are not required to print anything, it has already been taken care of. Just implement the function.
			Constraints:
				1 <= T <= 100
				1 <= N <= 3 * 10^3
				1 <= nodeVal <= 10^9
				Time Limit: 1 sec.

			Sample Input 1:
			2
			3 1 2 4 -1 -1 -1 -1 -1
			1 2 3 4 -1 5 -1 -1 -1 -1 6 -1 -1
			Sample Output 1:
			3 2 
			1 
			4
			1 3 
			2 5 6 
			4 
			Explanation For Sample Output 1:
			For the first test case, the tree will be:
			So, the output will be:
			3 2
			1
			4
			For the second test case, the tree will be:
			So, the output will be:
			1 3
			2 5 6
			4
			Sample Input 2:
			2
			1 2 -1 -1 -1
			1 3 2 -1 -1 -1 -1
			Sample Output 2:
			1 
			2 
			1 2 
			3 
	
		#include <bits/stdc++.h> 
		/*
			Following is the Binary Tree node structure for your referance:
			class TreeNode {
				public :
					int data;
					TreeNode *left;
					TreeNode *right;

				TreeNode(int data) {
					this -> data = data;
					left = NULL;
					right = NULL;
				}
				~TreeNode() {
					if (left){
						delete left;
					}
					if (right){
						delete right;
					}
				}
			};
		*/
		vector<vector<int>> diagonal(TreeNode<int>* root){
			vector<vector<int>> ans;

			if(root == NULL)
				return ans;

			queue<TreeNode<int>*> q;
			q.push(root);

			vector<int> a;
			TreeNode<int>* curNode = q.front();
			q.pop();

			while(curNode){
				if(curNode -> left)
					q.push(curNode -> left);

				a.push_back(curNode -> data);
				curNode = curNode -> right;
			}
			ans.push_back(a);
			a.clear();

			if(!q.empty())
				q.push(NULL);

			while(!q.empty()){
				TreeNode<int>* cur = q.front();
				q.pop();
				
				if(cur == NULL){
					ans.push_back(a);
					a.clear();
					if(!q.empty())
						q.push(NULL);
				}

				while(cur){
					a.push_back(cur -> data);
					if(cur -> left)
						q.push(cur -> left);
					
					cur = cur -> right;
				}        
			}
			return ans;    
		}

	934) Diagonal Traversal:
		https://www.naukri.com/code360/problems/diagonal-traversal_893029
		Problem statement
			You have been given a binary tree of integers. You have to return all the diagonal paths of the binary tree. A diagonal path is one in which all the nodes pass through -1 slope line.
			A binary tree is a tree in which each parent node has at most two children.
			Note:
			Order of return of diagonal path’s array/vector: The rightmost diagonal path must come first, and so on.
			Every parent node comes first then the child node. In other words, return the diagonal element from top to bottom.
			Example
			Consider the given binary tree.
			There are 4 diagonal paths:
			1 3 6
			2 5 9
			4 8
			7
			You need to return ‘1 3 6 2 5 9 4 8 7’.
			Let's consider this example
			Diagonal paths are:
			1 3 6
			2 5
			4

			You need to return ‘1 3 6 2 5 4’.
			Sample Input 1:
			2
			1 2 3 4 5 6 7 -1 -1 -1 -1 -1 -1 -1 -1
			1 2 3 -1 -1 4 5 -1 -1 -1 -1
			Sample Output 1:
			1 3 7 2 5 6 4
			1 3 5 2 4
			Explanation For Sample Test 1:

			It is clear that '1 3 7' is the first diagonal path '2 5 6' is the second and '4' is the third diagonal path. But 5 and 6 have the same level and same diagonal path, so we need to consider a node that comes first in the pre-order traversal.
			Hence the diagonal path of the above binary tree is 1 3 7 2 5 6 4.

			Test case 2:
			It is clear that the first diagonal path is '1 3 5', and the second is '2 4'.
			Hence diagonal binary tree traversal when combined is '1 3 5 2 4'.
			Sample Input 2:
			2
			1 -1 2 3 4 -1 -1 -1 -1
			1 2 3 -1 -1 4 -1 -1 -1
			Sample Output 2:
			1 2 4 3
			1 3 2 4

		#include <bits/stdc++.h> 
		/*************************************************************
			Following is the Binary Tree node structure.
			class BinaryTreeNode {
				public:
					T data;
					BinaryTreeNode<T> *left;
					BinaryTreeNode<T> *right;

				BinaryTreeNode(T data) {
					this -> data = data;
					left = NULL;
					right = NULL;
				}

				~BinaryTreeNode() {
					if (left){
						delete left;
					}
					if (right){
						delete right;
					}
				}
			};
		*************************************************************/

		vector<int> diagonalPath(BinaryTreeNode<int>* root) {
			vector<int> ans;

			queue<BinaryTreeNode<int>*> q;
			q.push(root);

			while(!q.empty()){
				BinaryTreeNode<int>* curNode = q.front();
				q.pop();

				while(curNode){
					ans.push_back(curNode -> data);

					if(curNode -> left)
						q.push(curNode -> left);
					
					curNode = curNode -> right;
				}

			}
			return ans;
		}

	935) Diagonal Traversal of Binary Tree:
		Problem Statement:
			Given a Binary Tree, print the diagonal traversal of the binary tree.
			Consider lines of slope -1 passing between nodes. Given a Binary Tree, print all diagonal elements in a binary tree belonging to same line.
			If the diagonal element are present in two different subtress then left subtree diagonal element should be taken first and then right subtree. 

			Example 1:

			Input :
					    8
					 /     \
					3       10
				   /   \       \
				  1     6       14
				 /       \  	/
				4         7   /
						   13
			Output : 8 10 14 3 6 7 13 1 4
			Explanation:
			unnamed
			Diagonal Traversal of binary tree : 
			8 10 14 3 6 7 13 1 4
			Your Task:
				You don't need to read input or print anything. The task is to complete the function diagonal() that takes the root node as input argumets and returns the diagonal traversal of the given tree.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(N).
			Here N is number of nodes.

			Constraints:
				1 <= Number of nodes<= 10^5
				1 <= Data of a node<= 10^5
	
		/* 
			A binary tree node
			struct Node {
				int data;
				Node* left, * right;
			}; 
		*/
		vector<int> diagonal(Node *root) {
			vector<int> ans;
			queue<Node *> q;
			q.push(root);
			
			while(!q.empty()){
				Node *cur = q.front();
				q.pop();
				
				while(cur){
					if(cur -> left)
						q.push(cur -> left);
					
					ans.push_back(cur -> data);
					cur = cur -> right;
				}
			}
			return ans;
		}
	
	936) Hand of Straights:
		Problem Statement:
			Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.
			Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.
			Example 1:
				Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
				Output: true
				Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]
			Example 2:
				Input: hand = [1,2,3,4,5], groupSize = 4
				Output: false
				Explanation: Alice's hand can not be rearranged into groups of 4.

			Constraints:
				1 <= hand.length <= 10^4
				0 <= hand[i] <= 10^9
				1 <= groupSize <= hand.length

		class Solution {
			public:
			bool isNStraightHand(vector<int>& hand, int groupSize) {
				int n = hand.size();
				if(n % groupSize != 0)
					return 0;

				// sort(hand.begin(), hand.end());				// not necessary
				map<int, int> Fr;
				for(int i: hand)
					Fr[i]++;

				while(!Fr.empty()){

					int cur = Fr.begin() -> first;
					for(int i=0; i<groupSize; i++){
						if(Fr[cur+i] < 1)
							return 0;

						Fr[cur+i]--;
						if(Fr[cur+i] < 1)
							Fr.erase(cur+i);
					}
				}
				return 1;
			}
		};
	
	937) Divide Array in Sets of K Consecutive Numbers:
		Problem Statement:
			Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.
			Return true if it is possible. Otherwise, return false.
			Example 1:
				Input: nums = [1,2,3,3,4,4,5,6], k = 4
				Output: true
				Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].
			Example 2:
				Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
				Output: true
				Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].
			Example 3:
				Input: nums = [1,2,3,4], k = 3
				Output: false
				Explanation: Each array should be divided in subarrays of size 3.
			Constraints:
				1 <= k <= nums.length <= 10^5
				1 <= nums[i] <= 10^9

		class Solution {
			public:
			bool isPossibleDivide(vector<int>& nums, int k) {
				int n = nums.size();
				if(n % k != 0)
					return 0;

				map<int, int> Fr;
				for(int i: nums)
					Fr[i]++;

				while(!Fr.empty()){
					int cur = (*Fr.begin()).first;              // or Fr.begin() -> first;           // to access the key
					
					for(int i=0; i<k; i++){
						if(Fr[cur+i] < 1)
							return 0;
						
						Fr[cur+i]--;
						if(Fr[cur+i] < 1)
							Fr.erase(cur+i);
					}
				}
				return 1;
			}
		};
	
	938) Maximum occured integer:
		Problem Statement:
			Given n integer ranges, the task is to return the maximum occurring integer in the given ranges. If more than one such integer exists, return the smallest one.
			The ranges are in two arrays l[] and r[].  l[i] consists of the starting point of the range and r[i] consists of the corresponding endpoint of the range & a maxx which is the maximum value of r[].
			For example, consider the following ranges.
				l[] = {2, 1, 3}, r[] = {5, 3, 9)
			Ranges represented by the above arrays are.
				[2, 5] = {2, 3, 4, 5}
				[1, 3] = {1, 2, 3}
				[3, 9] = {3, 4, 5, 6, 7, 8, 9}
			The maximum occurred integer in these ranges is 3.

			Example 1:
				Input: n = 4, l[] = {1,4,3,1}, r[] = {15,8,5,4}, maxx = 15
				Output: 4
				Explanation: The given ranges are [1,15] [4, 8] [3, 5] [1, 4]. The smallest number that is most common or appears most times in the ranges is 4.

			Example 2:
				Input: n = 5, l[] = {1,5,9,13,21}, r[] = {15,8,12,20,30}, maxx = 30
				Output: 5
				Explanation: The given ranges are [1, 15] [5, 8] [9, 12] [13, 20] [21, 30]. The smallest number that is most common or appears most times in the ranges is 5.

			Expected Time Complexity: O(n+maxx).
			Expected Auxiliary Space: O(maxx), maxx is maximum element in r[]

			Constraints:
				1 ≤ n ≤ 10^6
				0 ≤ l[i], r[i] ≤ 10^6

		// Not Optimized:
			class Solution {
				public:
				// l and r are input array
				// maxx : maximum in r[]
				// n: size of array
				// arr[] : declared globally with size equal to maximum in l[] and r[]
				// Function to find the maximum occurred integer in all ranges.
				int maxOccured(int n, int l[], int r[], int maxx) {
					map<int, int> Fr;
					
					for(int i=0; i<n; i++){
						int s = l[i], e = r[i];
						for(int j=s; j <= e; j++)
							Fr[j]++;
					}
					
					int mxCntofMinNum = INT_MAX;
					int cur = 0;
					for(auto i: Fr)
						if(i.second > cur){
							cur = i.second;
							mxCntofMinNum = i.first;
						}
						
					return mxCntofMinNum;
				}
			};

		// Optimized:
			❌Pending
	
	939) Fibonacci Sum:
		Problem statement
			Given two integers, ‘N’ and ‘M’, your task is to find the sum of Fibonacci numbers between ‘fib(N)’ and ‘fib(M)’ where ‘fib(N)’ represents the Nth Fibonacci number and ‘fib(M)’ represents the Mth Fibonacci number. The sum is given by sum(N, M) = fib(N) + fib(N+1) + fib(N+2) … fib(M). Since the answer could be large, so you have to return the sum modulo 10^9 + 7.
			The fibonacci relation is given by:
			fib(0) = 0 
			fib(1) = 1
			fib(n) = fib(n-1) + fib(n-2), n >= 2, where fib(n) represents the nth fibonacci number.
			Constraints:
				1 <= T <= 1000
				0 <= N <= M <= 10^9
				Where ‘T’ represents the number of test cases, and ‘N’ and ‘M’ represents the starting and ending of the range respectively.
				Time Limit: 1 sec
			Sample Input 1:
			2
			2 6
			0 5
			Sample Output 1:
			19
			12 
			Explanation 1:
			For the first test case, 
			The Fibonacci numbers between fib(2) and fib(6) are {1, 2, 3, 5, 8}. Their sum is equal to 19. Hence the output is 19.

			For the second test case,
			The Fibonacci numbers between fib(0) and fib(5) are {0, 1, 1, 2, 3, 5}. Their sum is equal to 12. Hence the output is 12.
			Sample Input 2:
			2
			3 6
			6 7
			Sample Output 2:
			18
			21

		// Not Optimized:
			#include <bits/stdc++.h> 
			int mod = 1e9+7;
			int fib(int n){
				if(n == 0)
					return 0;
				else if(n == 1)
					return 1;
				else
					return (fib(n-1) + fib(n-2)) % mod;
			}

			int fiboSum(int n , int m) {
				int sum = 0;
				for(int i=n; i<=m; i++){
					sum += fib(i);
					sum %= mod;
				}
				return sum % mod;
			}
	
		// Optimized:
			#include <bits/stdc++.h> 
			int fiboSum(int n , int m) {
				if(m == 0)
					return 0;
				
				vector<int> fibValues(m+1);
				fibValues[0] = 0;
				fibValues[1] = 1;

				int sum =0, mod = 1e9+7;
				for(int i=2; i<=m; i++)
					fibValues[i] = (fibValues[i-1]+fibValues[i-2]) % mod;
				
				for(int i=n; i <= m; i++)
					sum = (sum + fibValues[i]) % mod;

				return sum;
			}

	940) Find K-Th Element From Product Array:
		Problem statement
			You are given an integer array ‘Arr’ of length ‘N’. Your task is to find the Kth element of the ‘product’ array when the ‘product’ array is sorted in non-decreasing order.
			The ‘product’ array of ‘Arr’ is an array of size (N*(N-1)) / 2 which consist multiplication of each pair of elements present in the array ‘Arr’, i.e product[k] = Arr[i] * Arr[j], where 0 ≤ i < j < ‘N’.
			Note :
			Return -1 if the value of ‘K’ exceeds the number of elements in the array ‘product’.
			For Example :
			Input array “arr”= [1, 2, 3, 4] and K = 3
			Output: 4 
			Explanation: The ‘product’ array i.e array formed by multiplying each pair of element of ‘Arr’ is [1*2, 1*3, 1*4, 2*3, 2*4, 3*4] = [2, 3, 4, 6, 8, 12]. So the Kth(K = 3) element in this sorted ‘product’ array is 4.
			Constraints :
				1 <= T <= 50
				1 <= N <= 10^4
				1 <= K <= 10^9
				-10^4 <= Arr[i] <= 10^4
				Time Limit: 1 sec 
			Sample Input 1 :
			2
			4 2
			1 2 3 -1
			3 2
			-1 0 1
			Sample Output 1 :
			-2
			0
			Explanation For Sample Input 1 :
			Test Case 1:
			The ‘product’ array formed by multiplying any two numbers taken two at a time is : [-1 * 1, -1 * 2, -1 * 3, 1 * 2, 1 * 3, 2 * 3] = [-1, -2, -3, 2, 3, 6] and this array after sorting  is: [-3, -2, -1, 2, 3, 6]. So the 2nd element in the sorted ‘product’ array is -2.
			Test Case 2:
			The ‘product’ array formed by multiplying any two numbers taken two at a time is : [-1 * 0, -1 * 1, -0 * 1] [0, -1] and sorted ‘product’ array is: [-1, 0, 0]. So the 2nd element in the sorted ‘product’ array is 0.
			Sample Input 2 :
			2
			3 5
			1 3 4
			1 1
			-1
			Sample Output 2 :
			-1
			-1

		// Not Optimized:
			#include <bits/stdc++.h> 
			int kthSmallest(vector<int> &arr, int k) {
				vector<int> v;
				int n = arr.size();
				for(int i=0; i<n-1; i++){
					for(int j=i+1; j<n; j++){
						v.push_back(arr[i]*arr[j]);
					}
				}
				
				if(k >= v.size())
					return -1;
				sort(v.begin(), end(v));
				return v[k-1];
			}

		// Optimized:
			❌Pending
	
	941) Replace Words:
		Problem Statement:
			In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root "help" is followed by the word "ful", we can form a derivative "helpful".
			Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length.
			Return the sentence after the replacement.
			Example 1:
				Input: dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
				Output: "the cat was rat by the bat"
			Example 2:
				Input: dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
				Output: "a a b c"
		
			Constraints:
				1 <= dictionary.length <= 1000
				1 <= dictionary[i].length <= 100
				dictionary[i] consists of only lower-case letters.
				1 <= sentence.length <= 106
				sentence consists of only lower-case letters and spaces.
				The number of words in sentence is in the range [1, 1000]
				The length of each word in sentence is in the range [1, 1000]
				Every two consecutive words in sentence will be separated by exactly one space.
				sentence does not have leading or trailing spaces.

		// Optimized:
			class Solution {
				public:
				string replaceWords(vector<string>& dictionary, string sentence) {
					string ans;
					vector<string> v;

					string temp;
					istringstream iss(sentence);

					// creating the vector of string from given sentence
					while(iss >> temp)
						v.push_back(temp);
					
					for(int i=0; i<dictionary.size(); i++){
						for(int j=0; j<v.size(); j++){
							string Sdiction = dictionary[i];
							string Sv = v[j];

							int innerFlg = 1;
							for(int z=0; z<Sdiction.size(); z++){
								if(Sdiction[z] != Sv[z]){
									innerFlg=0;
									break;
								}
							}
							if(innerFlg)
								v[j] = Sdiction;
						}
					}
					for(string s: v)
						ans += s +" ";
					ans.pop_back();                 // to remove the last extra space.
					return ans;
				}
			};

		// Not Optimized: Used find function
			class Solution {
				public:
				string replaceWords(vector<string>& dictionary, string sentence) {
					string ans;
					vector<string> v;

					string temp;
					istringstream iss(sentence);

					while(iss >> temp)
						v.push_back(temp);
					
					for(int i=0; i<dictionary.size(); i++){
						for(int j=0; j<v.size(); j++){
							string Sdiction = dictionary[i];
							string Sv = v[j];

							int isPresent = Sv.find(Sdiction);          
							// this statement confirms the dictionary word is present in statement or not, 
							// if present then returns index else return a some larger value like string::npos, 
							// we want if the word is present then index must be first ie. 0, 
							// then will replace the word in sentence with word in dictionary
							
							if(isPresent == 0)
								v[j] = Sdiction;
						}
					}
					for(string s: v)
						ans += s +" ";
					ans.pop_back();                 // to remove the last extra space.
					return ans;
				}
			};
	
	#CN WeeklyContest-129:
		942) Equal Distribution:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers where each element is numbered from ‘0’ to ‘N - 1’ and can occur atmost ‘2’ times. You have to split the given array into two arrays of the same length such that the intersection between the two arrays is ‘0’.
				The intersection between the two arrays is the count of common elements in both the arrays. For example: the intersection between ‘[1, 2, 4]’ and ‘[8, 7, 2]’ is ‘1’ because ‘2’ is present in both the arrays, whereas the intersection between ‘[1, 5]’ and ‘[2, 7]’ is ‘0’.
				Your task is to tell whether it is possible to split the given array into two arrays of the same length having ‘0’ intersection. Return ‘1’, if possible, otherwise return ‘0’.
				Example:
				‘N’ = 6
				‘A’ = [1, 5, 2, 6, 5, 1]
				Here, we can split the given array into: ‘[1, 2, 1]’ and ‘[5, 6, 5]’. Both the arrays have ‘0’ intersection. So, the answer for this example is ‘1’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					0 <= A[i] <= 10^9
					Time Limit: 1 sec 
				Sample Input 1:
					2
					4
					2 5 6 2
					2
					1 1
					Sample Output 1:
					1
					0
					Explanation of sample input 1:
					For test case 1:
					Here, we can split the given array into: ‘[2, 2]’ and ‘[5, 6]’. Both the arrays have ‘0’ intersection. So, the answer for this test case is ‘1’.
					For test case 2:
					It is impossible to split the given array into two arrays of the same length because in that case the intersection between them will be non-zero. So, the answer for this test case is ‘0’.
					Sample Input 2:
					2
					8
					3 7 3 7 2 8 9 9
					2
					1 2
					Sample Output 2:
					1
					1

			int equalDistribution (int n, vector <int> &a) {
				if(n&1){
					return 0;
				}else if(n == 2){
					if(a[0] == a[1])
						return 0;
					return 1;
				}else{
					return 1;
				}
			}

	943) Absolute difference in an array:
		Problem statement
			You are given an array/list 'ARR' consisting of 'N' non - negative integers. Your task is to return the running absolute difference of the elements at even and odd index positions separately.
			The index of the first element in the array is considered to be zero that is 0 - based indexing is considered for calculating the parity of the index.
			Example:
			Consider the array - [1, 2, 3, 4, 5, 6]
			The elements at even positions will be 1, 3, 5. The running absolute difference of elements will be - |1 - 3| = 2 , |2 -5| = 3. Hence our answer will be 3.
			The elements at odd positions will be 2, 4, 6. The running absolute difference of elements will be - |2 - 4| = 2 , |2 - 6| = 4. Hence our answer will be 4.
			Constraints:
				1 <= T <= 10
				1 <= N <= 5 * 10^4
				1 <= ARR[i] <=10^5
				Time Limit: 1 sec

			Sample Input 1:
				2
				5
				5 4 3 4 2
				4
				3 5 3 1
				Sample Output 1:
				0 0
				0 4
				Explanation of Input 1:
				For test case 1:
				• The running absolute difference of elements at even positions will be : |5 - 3| = 2, |2 - 2| = 0.
				• The running absolute difference of elements at odd positions will be : |4 - 4| = 0.
				For test case 2:
				• The running absolute difference of elements at even positions will be : |3 - 3| = 0.
				• The running absolute difference of elements at odd positions will be : |5 - 1| = 4.
				Sample Input 2:
				1
				7
				10 20 30 40 50 60 70
				Sample Output 2:
				40 40

		#include <bits/stdc++.h> 
		pair<int, int> absDiff(vector<int>& arr, int n) {
			if(n == 1)
				return {arr[0],0};
			
			int i=2, j=3;
			int num1 = arr[0];
			int num2 = arr[1];

			for(i; i<n ; i +=2)
				num1 = abs(num1 - arr[i]);

			for(j; j<n ; j +=2)
				num2 = abs(num2 - arr[j]);

			/*	
				// instead of above 2 loops use this one loop only
				for(i, j; j < n or i<n ; i +=2, j +=2){
					if(i < n)
						num1 = abs(num1 - arr[i]);
						
					if(j < n)
						num2 = abs(num2 - arr[j]);
				}
			
			*/

			return {num1, num2};
		}

		// or if the size of arr is odd then one element is remaining to substract from num1
			#include <bits/stdc++.h> 
			pair<int, int> absDiff(vector<int>& arr, int n) {
				if(n == 1)
					return {arr[0],0};
				
				int i=2, j=3;
				int num1 = arr[0];
				int num2 = arr[1];

				for(i, j; j < n && i<n ; i +=2, j +=2){
					num1 = abs(num1 - arr[i]);
					num2 = abs(num2 - arr[j]);
				}

				if(n&1)
					num1 = abs(num1 - arr.back());

				return {num1, num2};
			}
	
		// or using just one looping variable:
			#include <bits/stdc++.h> 
			pair<int, int> absDiff(vector<int>& arr, int n) {
				if(n == 1)
					return {arr[0], 0};
				
				int evenPos, OddPos;
				evenPos = arr[0];
				OddPos = arr[1];

				for(int i=2; i<n; i+=2){
					evenPos = abs(evenPos - arr[i]);
					if(i+1 < n)
						OddPos = abs(OddPos - arr[i+1]);
				}
				
				return {evenPos, OddPos};
			}

	944) Day 8 : Second largest element in the array:
		https://www.naukri.com/code360/problems/second-largest-element-in-the-array_873375
		Problem statement
			You have been given an array/list 'ARR' of integers. Your task is to find the second largest element present in the 'ARR'.
			Note:
			a) Duplicate elements may be present.
			b) If no such element is present return -1.
			Example:
			Input: Given a sequence of five numbers 2, 4, 5, 6, 8.
			Output:  6
			Explanation:
			In the given sequence of numbers, number 8 is the largest element, followed by number 6 which is the second-largest element. Hence we return number 6 which is the second-largest element in the sequence.
			Constraints:
				1 <= T <= 100
				1 <= N <= 5000
				-10 ^ 9 <= 'SIZE' <= 10 ^ 9 
				Where ‘T’ is the total number of test cases, ‘N’ denotes the number of elements in the array and ‘SIZE’ denotes the range of the elements in the array.
				Time limit: 1 sec.
			Sample Input 1:
				2
				6
				12 1 35 10 34 1
				5
				10 10 10 10 10
				Sample Output 1:
				34
				-1
				Explanation of sample input 1:
				Test case 1: In the given sequence of numbers, number 35 is the largest element, followed by number 34 which is the second-largest element. Hence we return number 34 which is the second-largest element in the sequence.

				Test case 2: In the given sequence of numbers, number 10 is the largest element. However, since all the elements are the same, the second largest element does not exist. So, we return -1.
				Sample Input 2:
				1
				6
				7 8 8 1 4 3 
				Sample Output 2:
				7
				Explanation of sample input 2:
				In the given sequence of numbers, 8 exists two times and is the largest element, followed by 7 which is the second-largest element. Hence we return the number 7 as the second-largest element.
			Hints:
				Think about how the sorting of the array can help.

		#include <bits/stdc++.h> 
		int findSecondLargest(int n, vector<int> &arr) {
			set<int> s (arr.begin(), arr.end());
			if(s.size() < 2)
				return -1;
			auto itr = s.end();
			--itr;
			--itr;

			/*
				// or instead of above 3 lines you can use 			
				auto itr = s.rbegin();          // rbegin function consider the last element as first
				itr++;                          // & after incrementing it by once its currently pointing the second last element
			*/
			return *itr;    
		}
	
	945) Continuous Subarray Sum:
		Problem Statement:
			Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.
			A good subarray is a subarray where:
			its length is at least two, and
			the sum of the elements of the subarray is a multiple of k.
			Note that:
			A subarray is a contiguous part of the array.
			An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.
		
			Example 1:
				Input: nums = [23,2,4,6,7], k = 6
				Output: true
				Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
			Example 2:
				Input: nums = [23,2,6,4,7], k = 6
				Output: true
				Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
				42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
			Example 3:
				Input: nums = [23,2,6,4,7], k = 13
				Output: false

			Constraints:
				1 <= nums.length <= 10^5
				0 <= nums[i] <= 10^9
				0 <= sum(nums[i]) <= 2^31 - 1
				1 <= k <= 2^31 - 1
		
		// Not Optimized:
			class Solution {
				public:
				bool checkSubarraySum(vector<int>& nums, int k) {
					int n = nums.size();
					for(int i=0; i<n-1; i++){
						int sum = nums[i];
						for(int j=i+1; j<n; j++){
							sum += nums[j];
							if(sum % k == 0)
								return 1;
						}
					}
					return 0;
				}
			};
	
		// Optimized:
			❌Pending

	946) Index of an Extra Element:
		Problem Statement:
			You have given two sorted arrays arr1[] & arr2[] of distinct elements. The first array has one element extra added in between. Return the index of the extra element.
			Note: 0-based indexing is followed.
			Examples
				Input: n = 7, arr1[] = {2,4,6,8,9,10,12}, arr2[] = {2,4,6,8,10,12}
				Output: 4
				Explanation: In the first array, 9 is extra added and it's index is 4.
				Input: n = 6, arr1[] = {3,5,7,8,11,13}, arr2[] = {3,5,7,11,13}
			Output: 3
				Explanation: In the first array, 8 is extra and it's index is 3.
			Expected Time Complexity: O(log n).
			Expected Auxiliary Space: O(1).

			Constraints:
				1<=n<=10^5
				1<=arr1[i],arr2[i]<=10^6

		// Brute Force:
			class Solution {
				public:
				int findExtra(int n, int arr1[], int arr2[]) {
					for(int i=0; i<n-1; i++)
						if(arr1[i] != arr2[i])
							return i;

					return n-1;
				}
			};

		// Using set
			class Solution {
				public:
				int findExtra(int n, int arr1[], int arr2[]) {
					set<int> s (arr2, arr2+n-1);
					for(int i=0; i<n; i++){
						if(s.count(arr1[i]) == 0)
							return i;
					}
				}
			};
		
			//or
				class Solution {
					public:
					int findExtra(int n, int arr1[], int arr2[]) {
						set<int> s (arr2, arr2+n-1);
						for(int i=0; i<n; i++){
							if(s.count(arr1[i]))
								s.erase(arr1[i]);
							else
								return i;
						}
					}
				};

		// Using Binary search:
			class Solution {
				public:
				int findExtra(int n, int arr1[], int arr2[]) {
					int s =0, e = n-2;
					while(s < e){
						int mid = (s+e)/2;
						
						if(arr1[mid] == arr2[mid])
							s++;
						else
							e = mid;
					}
					if(arr1[s] == arr2[s])
						return ++s;
						
					return s;
				}
			};

	947) Maximal AND Subsequences:
		Problem statement
			You are given an array consisting of N integers. You need to find the number of k-element subsequences of the given array where the bitwise AND of the subsequence's elements is maximal. Also, find the maximal AND value.
			Example:
			Let the array be [1, 3, 6, 7] and K=3. The possible k-element subsequences of the given array are: {1, 3, 6}, {1, 3, 7}, {1, 6, 7}, {3, 6, 7}. Applying AND operation on all possible subsequences we get values: 0, 1, 0, 2 respectively. The maximal AND value of these subsequences is 2, and only 1 subsequence {3, 6, 7} has this value.
			Constraints:
				1 <= T <= 10
				2 <= N <= 5 * 10^4
				2 <= K <= N
				0 <= Arr[i] <= 10^8
				Where  ‘T’ represents the number of test cases, ‘N’ represents the number of elements present in the array and ‘K’ represents the length of the subsequences.
				Time Limit: 1 sec
			Sample Input 1:
				2
				4 3
				1 3 6 7
				3 2
				9 9 9    
				Sample Output 1:
				2 1
				9 3
				Explanation 1:
				For the first test case refer to the example explained above.
				For the second test case we have, array: [9, 9, 9], N = 3 and K = 2. The possible k-element subsequences of the given array are: {9, 9}, {9, 9}, {9, 9}. Applying AND operation on all possible subsequences we get values: 9, 9, 9 respectively. The maximal AND value of these subsequences is 9, and all subsequences have this value.
				Sample Input 2:
				2
				5 2
				1 2 3 4 5
				4 4
				6 3 7 0
				Sample Output 2:
				4 1 
				0 1

		// Not Optimized:
			#include <bits/stdc++.h>
			void Generate(vector<int> &main, vector<int> temp,vector<vector<int>> &InfoHolder, int sizeDoNotCross, int CurIndex){
				if(temp.size() >= sizeDoNotCross or CurIndex >= main.size()){					//    if(temp.size() >= sizeDoNotCross || CurIndex >= main.size()) : "you can use this pipe sign also to denote as or (||)."
					if(temp.size() == sizeDoNotCross)
						InfoHolder.push_back(temp);
					return ;
				}

				Generate(main, temp, InfoHolder, sizeDoNotCross, CurIndex+1);

				// include call
				temp.push_back(main[CurIndex]);
				Generate(main, temp, InfoHolder, sizeDoNotCross, CurIndex+1);
			}

			vector<int> maximalANDSubsequences(vector<int> &arr, int k) {
				// generate all the subsequence of size k
				vector<int> temp;
				vector<vector<int>> InfoHolder;
				Generate(arr, temp, InfoHolder, k, 0);

				// perform AND operation on that generated sequence, 
				int mx = 0, cnt=0;
				for(auto row: InfoHolder){
					vector<int> cur = row;
					int first = cur[0];
					for(int i=1; i<cur.size(); i++)
						first &= cur[i];

					if(mx < first){
						mx = first;
						cnt=1;
					}else if(mx == first){
						cnt++;
					}
				}

				// return the ans
				return {mx, cnt};
			}

		// Optimized:
			❌Pending

	948) K-th Element of Two Sorted Arrays:
		Problem statement
			You're given two sorted arrays 'arr1' and 'arr2' of size 'n' and 'm' respectively and an element 'k'.
			Find the element that would be at the 'kth' position of the combined sorted array.
			Position 'k' is given according to 1 - based indexing, but arrays 'arr1' and 'arr2' are using 0 - based indexing.
			For example :
			Input: 'arr1' = [2, 3, 45], 'arr2' = [4, 6, 7, 8] and 'k' = 4
			Output: 6
			Explanation: The merged array will be [2, 3, 4, 6, 7, 8, 45]. The element at position '4' of this array is 6. Hence we return 6.
			Sample Input 1:
				5
				2 3 6 7 9
				4
				1 4 8 10
				4
				Sample Output 1:
				4
				Explanation of sample input 1 :
				The merged array will be: [1, 2, 3, 4, 6, 7, 8, 9, 10]

				The element at position '4' is 4 so we return 4.
				Sample Input 2:
				5
				1 2 3 5 6
				5
				4 7 8 9 100  
				6
				Sample Output 2:
				6
				Explanation of sample input 2 :
				The merged array will be: [1, 2, 3, 4, 5, 6, 7, 8, 9, 100]

				The element at position '6'  is 6, so we return 6.
				Constraints :
					1 <= 'n' <= 5000
					1 <= 'm' <= 5000
					0 <= 'arr1[i]', 'arr2[i]' <= 10^9
					1 <= 'k' <= 'n' + 'm'

				'n' and 'm' denote the size of 'arr1' and 'arr2'.
				Time limit: 1 second
				Expected time complexity :
				The expected time complexity is O(log('n') + log('m')). 

		// Not Optimized:
			#include<bits/stdc++.h>
			int kthElement(vector<int> &arr1, vector<int>& arr2, int n, int m, int k){
				arr1.insert(arr1.end(), arr2.begin(), arr2.end());
				sort(begin(arr1), end(arr1));
				return arr1[k-1];
			}

		// Optimized:
			#include <bits/stdc++.h>
			int kthElement(vector<int> &arr1, vector<int>& arr2, int n, int m, int k){
				vector<int> v;
				int i,j;
				i=j=0;

				while((i < n or j < m) && v.size() < k){
					if(i < n && j < m){
						if(arr1[i] < arr2[j]){
							v.push_back(arr1[i++]);
						}else{
							v.push_back(arr2[j++]);
						}
					}else if(i < n){                        // this statement indicates (j >= m)
						v.push_back(arr1[i++]);         
					}else{
						v.push_back(arr2[j++]);             // this statement indicates (j < m) but i >= n
					}
				}
				return v.back();
			}
		
	#AtCoder BeginnerContest-357
		949) A - Sanitize Hands:
			Problem Statement
				There is a bottle of disinfectant that can disinfect exactly M hands.
				N aliens come one by one to disinfect their hands.The i-th alien (1≤i≤N) has Hi hands and wants to disinfect all of their hands once.
				Determine how many aliens can disinfect all of their hands. Here, even if there is not enough disinfectant left for an alien to disinfect all of their hands when they start, they will use up the remaining disinfectant.
				Constraints
					1≤N,M≤100
					1 ≤ Hi ≤100
					All input values are integers.
				Input
					The input is given from Standard Input in the following format:
					N M
					H1 H2 … HN
				Output
					Print the number of aliens who can disinfect all of their hands.

				Sample Input 1
					5 10
					2 3 2 5 3
				Sample Output 1
					3
				The aliens disinfect their hands in the following steps:
				The first alien disinfects their two hands. The remaining disinfectant can 10−2=8 hands.
				The second alien disinfects their three hands. The remaining disinfectant can disinfect 8−3=5 hands.
				The third alien disinfects their two hands. The remaining disinfectant can disinfect 5−2=3 hands.
				The fourth alien has five hands, but there is only enough disinfectant for three hands, so they use up the disinfectant without disinfecting all of their hands.
				Thus, the first three aliens can disinfect all of their hands, so print 3.

				Sample Input 2
					5 10
					2 3 2 3 5
				Sample Output 2
				4
				Sample Input 3
				1 5
				1
				Sample Output 3
				1
				All aliens can disinfect their hands.

			#include <iostream>
			using namespace std;
			int main() {
				int n, m;                   // n is hands count, m is total hands can disinfect.
				cin>>n>>m;
				
				// using local array not vector
				int * arr = new int[n];
				for(int i=0; i<n; i++)
					cin>>arr[i];
				
				int cnt=0;
				for(int i=0; i<n; i++){
					if((m - arr[i]) < 0)
						break;
					m -= arr[i];
					cnt++;
				}

				cout<<cnt<<endl;
				return 0;
			}

			// Or
				#include <iostream>
				using namespace std;
				int main() {
					int n, m;                   // n is hands count, m is total hands can disinfect.
					cin>>n>>m;
					
					// using local array not vector
					int * arr = new int[n];
					for(int i=0; i<n; i++)
						cin>>arr[i];
					
					int cnt=0;
					for(int i=0; i<n; i++){
						if((m - arr[i]) >= 0){
							m -= arr[i];
							cnt++;
						}else{
							break;
						}
					}
					cout<<cnt<<endl;
					return 0;
				}

		950) B - Uppercase and Lowercase:
			Problem Statement:
				You are given a string S consisting of lowercase and uppercase English letters. The length of S is odd.
				If the number of uppercase letters in S is greater than the number of lowercase letters, convert all lowercase letters in 
				S to uppercase.Otherwise, convert all uppercase letters in S to lowercase.

				Constraints
					S is a string consisting of lowercase and uppercase English letters.The length of S is an odd number between 1 and 99, inclusive.
				Input
					The input is given from Standard Input in the following format: S
				Output
					Print the string S after converting the letters according to the problem statement.

				Sample Input 1
				AtCoder
				Sample Output 1
				atcoder
				The string AtCoder contains five lowercase letters and two uppercase letters. Thus, convert all uppercase letters in AtCoder to lowercase, which results in atcoder.

				Sample Input 2
				SunTORY
				Sample Output 2
				SUNTORY
				The string SunTORY contains two lowercase letters and five uppercase letters. Thus, convert all lowercase letters in SunTORY to uppercase, which results in SUNTORY.

				Sample Input 3
				a
				Sample Output 3
				a

			#include <iostream>
			#include<algorithm>
			using namespace std;

			int main() {
				string s;
				cin>>s;
				
				int n=s.length();               // int n=s.size(); 
				int Lower_cnt=0;
				
				for(char ch: s)
					if(islower(ch))
						Lower_cnt++;
				
				int Upper_cnt = n - Lower_cnt;
				if(Upper_cnt > Lower_cnt)
					transform(s.begin(), s.end(), s.begin(), ::toupper);
				else
					transform(s.begin(), s.end(), s.begin(), ::tolower);
				
				std::cout << s << std::endl;    
				return 0;
			}

	#LeetCode BiweeklyContest-132:
		951) Clear Digits:
			Problem Statement:
				You are given a string s.
				Your task is to remove all digits by doing this operation repeatedly:
				Delete the first digit and the closest non-digit character to its left.
				Return the resulting string after removing all digits.

				Example 1:
					Input: s = "abc"
					Output: "abc"
					Explanation:
					There is no digit in the string.

				Example 2:
					Input: s = "cb34"
					Output: ""
					Explanation:
					First, we apply the operation on s[2], and s becomes "c4".
					Then we apply the operation on s[1], and s becomes "".
					
				Constraints:
					1 <= s.length <= 100
					s consists only of lowercase English letters and digits.
					The input is generated such that it is possible to delete all digits.
			
			class Solution {
				public:
				string clearDigits(string s) {
					int i=0, n = s.size();

					while(i < s.size()){
						if(isdigit(s[i])){
							s.erase(s.begin()+i);
							s.erase(s.begin()+i-1);          // deleted the left non-digit & the current digit
							i--;
						}else{
							i++;
						}
					}
					return s;
				}
			};

			// or Simple traversing TC: 𝑂(𝑛) SC: 𝑂(𝑛)
				class Solution {
					public:
					string clearDigits(string s) {
						string ans;

						for(char ch: s)
							if(isdigit(ch))
								ans.pop_back();
							else
								ans += ch;

						return ans;        
					}
				};
			
			// or Using Stack: Time Complexity (TC): 𝑂(𝑛) Space Complexity (SC): 𝑂(𝑛)
				class Solution {
					public:
					string clearDigits(string s) {
						string ans;
						stack<char> st;
						for(char ch: s)
							if(isdigit(ch))
								st.pop();
							else
								st.push(ch);

						while(!st.empty()){
							ans = st.top() + ans;               // adding it in reverse fashion
							st.pop();
						}

						return ans;
					}
				};

		952) Find The First Player to win K Games in a Row:
			Problem Statement:
				A competition consists of n players numbered from 0 to n - 1.
				You are given an integer array skills of size n and a positive integer k, where skills[i] is the skill level of player i. All integers in skills are unique.
				All players are standing in a queue in order from player 0 to player n - 1.
				The competition process is as follows:
				The first two players in the queue play a game, and the player with the higher skill level wins.
				After the game, the winner stays at the beginning of the queue, and the loser goes to the end of it.
				The winner of the competition is the first player who wins k games in a row.
				Return the initial index of the winning player.

				Example 1:
					Input: skills = [4,2,6,3,9], k = 2
					Output: 2
					Explanation:
					Initially, the queue of players is [0,1,2,3,4]. The following process happens:
					Players 0 and 1 play a game, since the skill of player 0 is higher than that of player 1, player 0 wins. The resulting queue is [0,2,3,4,1].
					Players 0 and 2 play a game, since the skill of player 2 is higher than that of player 0, player 2 wins. The resulting queue is [2,3,4,1,0].
					Players 2 and 3 play a game, since the skill of player 2 is higher than that of player 3, player 2 wins. The resulting queue is [2,4,1,0,3].
					Player 2 won k = 2 games in a row, so the winner is player 2.

				Example 2:
					Input: skills = [2,5,4], k = 3
					Output: 1
					Explanation:
					Initially, the queue of players is [0,1,2]. The following process happens:
					Players 0 and 1 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].
					Players 1 and 2 play a game, since the skill of player 1 is higher than that of player 2, player 1 wins. The resulting queue is [1,0,2].
					Players 1 and 0 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].
					Player 1 won k = 3 games in a row, so the winner is player 1.

				Constraints:
					n == skills.length
					2 <= n <= 10^5
					1 <= k <= 10^9
					1 <= skills[i] <= 10^6
					All integers in skills are unique.

			// Not Optimized:
				class Solution {
					public:
					int findWinningPlayer(vector<int>& skills, int k) {
						int cnt=0;
						vector<int> temp = skills;
						int prev = temp[0];
						
						while(cnt < k) {
							int cur = temp[1];
							int now = (cur > prev) ? cur : prev;

							if(temp[0] > temp[1]){
								temp.push_back(temp[1]);
								temp.erase(temp.begin()+1);
							}else{
								temp.push_back(temp[0]);
								temp.erase(temp.begin());
							}

							if(now == prev){
								cnt++;
							}else{
								prev = now;
								cnt=1;
							}
						}
						return find(skills.begin(), skills.end(), temp.front()) - skills.begin();
					}
				};

			// Little Optimized:
				class Solution {
					public:
					int findWinningPlayer(vector<int>& skills, int k) {

						// this line make code very optimized
						if((k-1) >= skills.size())
							return (max_element(skills.begin(), skills.end()) - skills.begin());

						// this below code is same as previous but the above line is so much important
						int cnt=0;
						vector<int> temp = skills;
						int prev = temp[0];
						
						while(cnt < k) {
							int cur = temp[1];
							int now = (cur > prev) ? cur : prev;

							if(temp[0] > temp[1]){
								temp.push_back(temp[1]);
								temp.erase(temp.begin()+1);
							}else{
								temp.push_back(temp[0]);
								temp.erase(temp.begin());
							}

							if(now == prev){
								cnt++;
							}else{
								prev = now;
								cnt=1;
							}
						}
						return find(skills.begin(), skills.end(), temp.front()) - skills.begin();
					}
				};

			// Optimized:
				❌Pending
				
	#LeetCode WeeklyContest-401:
		954) Find the Child Who Has the Ball After K Seconds:
			https://leetcode.com/problems/find-the-child-who-has-the-ball-after-k-seconds/description/
			Problem Statement:
				You are given two positive integers n and k. There are n children numbered from 0 to n - 1 standing in a queue in order from left to right.
				Initially, child 0 holds a ball and the direction of passing the ball is towards the right direction. After each second, the child holding the ball passes it to the child next to them. Once the ball reaches either end of the line, i.e. child 0 or child n - 1, the direction of passing is reversed.
				Return the number of the child who receives the ball after k seconds.

				Example 1:
					Input: n = 3, k = 5
					Output: 1
					Explanation:
					Time elapsed	Children
						0		[0, 1, 2]
						1		[0, 1, 2]
						2		[0, 1, 2]
						3		[0, 1, 2]
						4		[0, 1, 2]
						5		[0, 1, 2]

				Example 2:
					Input: n = 5, k = 6
					Output: 2
					Explanation:
					Time elapsed	Children
						0		[0, 1, 2, 3, 4]
						1		[0, 1, 2, 3, 4]
						2		[0, 1, 2, 3, 4]
						3		[0, 1, 2, 3, 4]
						4		[0, 1, 2, 3, 4]
						5		[0, 1, 2, 3, 4]
						6		[0, 1, 2, 3, 4]

				Example 3:
					Input: n = 4, k = 2
					Output: 2
					Explanation:
					Time elapsed	Children
						0		[0, 1, 2, 3]
						1		[0, 1, 2, 3]
						2		[0, 1, 2, 3]

				Constraints:
					2 <= n <= 50
					1 <= k <= 50

			class Solution {
				public:
				int numberOfChild(int n, int k) {
					int ans =0;
					
					while(k){
						while((ans < n-1) and k>0){
							ans++;
							k--;
						}
						
						while((ans > 0) and k>0){
							ans--;                
							k--;
						}
					}
					return ans;
				}
			};
		
		953) Find the N-th Value After K Seconds:
			https://leetcode.com/problems/find-the-n-th-value-after-k-seconds/description/
			Problem Statement:
				You are given two integers n and k.
				Initially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.
				Return the value of a[n - 1] after k seconds.
				Since the answer may be very large, return it modulo 109 + 7.
			
				Example 1:
				Input: n = 4, k = 5
				Output: 56
				Explanation:
				Second	State After
					0	[1,1,1,1]
					1	[1,2,3,4]
					2	[1,3,6,10]
					3	[1,4,10,20]
					4	[1,5,15,35]
					5	[1,6,21,56]

				Example 2:
				Input: n = 5, k = 3
				Output: 35
				Explanation:
				Second	State After
					0	[1,1,1,1,1]
					1	[1,2,3,4,5]
					2	[1,3,6,10,15]
					3	[1,4,10,20,35]
				
				Constraints:
					1 <= n, k <= 1000

			class Solution {
				public:
				int valueAfterKSeconds(int n, int k) {
					vector<int> a(n, 1);
					int mod = 1e9+7;
					
					while(k--){
						for(int i=1; i<n; i++){
							a[i] += a[i-1];
							a[i] %= mod;
						}
					}
					
					return a.back();
				}
			};

		955) Maximum Total Reward Using Operations I:
			Problem Statement:
				You are given an integer array rewardValues of length n, representing the values of rewards.
				Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:
				Choose an unmarked index i from the range [0, n - 1].
				If rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.
				Return an integer denoting the maximum total reward you can collect by performing the operations optimally.
				
				Example 1:
					Input: rewardValues = [1,1,3,3]
					Output: 4
					Explanation:
					During the operations, we can choose to mark the indices 0 and 2 in order, and the total reward will be 4, which is the maximum.

				Example 2:
					Input: rewardValues = [1,6,4,3,2]
					Output: 11
					Explanation:
					Mark the indices 0, 2, and 1 in order. The total reward will then be 11, which is the maximum.

				Constraints:
					1 <= rewardValues.length <= 2000
					1 <= rewardValues[i] <= 2000

			// Memory Limit Exceeded (MLE):
				class Solution {
					public:
					int mxValue=0;
					void subSequence(vector<int>& main, vector<int> temp, int i){
						if(i >= main.size()){
							int curMx=0;
							for(int i: temp){
								if(i > curMx)
									curMx += i;
							}
							mxValue = max(mxValue, curMx);
							return ;
						}
						
						subSequence(main, temp, i+1);
						
						temp.push_back(main[i]);
						subSequence(main, temp, i+1);
					}
					int maxTotalReward(vector<int>& rewardValues) {
						vector<int> sub;
						sort(rewardValues.begin(), rewardValues.end());
						subSequence(rewardValues, sub, 0);
						
						return mxValue;
					}
				};

			// Optimized:
				❌Pending

		956) Maximum Total Reward Using Operations II:
			Problem Statement:
				You are given an integer array rewardValues of length n, representing the values of rewards.
				Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:
				Choose an unmarked index i from the range [0, n - 1].
				If rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.
				Return an integer denoting the maximum total reward you can collect by performing the operations optimally.

				Example 1:
					Input: rewardValues = [1,1,3,3]
					Output: 4
					Explanation:
					During the operations, we can choose to mark the indices 0 and 2 in order, and the total reward will be 4, which is the maximum.

				Example 2:
					Input: rewardValues = [1,6,4,3,2]
					Output: 11
					Explanation:
					Mark the indices 0, 2, and 1 in order. The total reward will then be 11, which is the maximum.
					
				Constraints:
					1 <= rewardValues.length <= 5 * 10^4
					1 <= rewardValues[i] <= 5 * 10^4

			// Memory Limit Exceeded (MLE)
				class Solution {
					public:
					void subSequence(vector<int>& main, vector<vector<int>> &info, vector<int> temp, int i){
						if(i >= main.size()){
							info.push_back(temp);
							return ;
						}
						
						subSequence(main, info, temp, i+1);
						
						temp.push_back(main[i]);
						subSequence(main, info, temp, i+1);
					}
					int maxTotalReward(vector<int>& rewardValues) {
						vector<vector<int>> info;
						vector<int> sub;
						sort(rewardValues.begin(), rewardValues.end());
						subSequence(rewardValues, info, sub, 0);
						
						int mxValue=0;
						for(auto &eachRow: info){
							int curMx=0;
							for(int i: eachRow){
								if(i > curMx)
									curMx += i;
							}
							mxValue = max(mxValue, curMx);
						}        
						return mxValue;
					}
				};
			
			// Optimized:
				❌Pending
			
	#GFG Weekly-158:
		957) Bob's Impression:
			Problem Statement:
				In an assembly ground of a school, the class teacher needs to arrange the students in non-decreasing order of their heights. Mrs. Alice, the vice-principal, is impressed by any class teacher who can arrange students of their class in non-decreasing order of heights by swapping the positions of exactly two students once.
				Mr. Bob, the class teacher of section D, wants to impress Mrs. Alice. Given the initial order of height in which the students of his class are standing, represented by an array arr, where arr[i] denotes the height of the i-th student. Return true if Mr. Bob can impress Mrs. Alice, otherwise return false.
				Example 1:
				Input:
				n = 3, 
				arr = [1, 2, 3]
				Output: False
				Explanation: 
				All the students are already standing in the order of non decreasing order, if Mr. Bob swaps any two students, the class would no longer be standing in the non decreasing order.

				Example 2:
				Input:
				n = 3,
				arr = [1, 3, 2]
				Output: True
				Explanation: 
				If Mr. Bob swaps the pair of students standing at 2nd and 3rd position, the order of heights will be [1, 2, 3] which is following the non decreasing order in a single swap.
				Your Task:
					You don't need to read input or print anything. Your Task is to return True(1) if Mr. Bob can impress Mrs. Alice by arranging the students in non-decreasing order of heights with a single swap among any one pair of students, otherwise return False(0).

				Constraints:
					2 ≤ n ≤ 10^5
					1 ≤ arr[i] ≤ 10^5

			// Not Optimized:
				class Solution {
					public:
					bool ContainsDuplicate(vector<int> &a){
						for(int i=0; i<a.size(); i++)
							if(a[i] == a[i+1])
								return 1;
						return 0;
					}
					bool classArrangement(int n, vector<int> &arr) {
						if(is_sorted(arr.begin(), arr.end())){
							if(ContainsDuplicate(arr))
								return 1;
							else
								return 0;
						}
						
						for(int i=0; i<n-1; i++){
							for(int j=i+1; j<n; j++){
								swap(arr[i], arr[j]);
								if(is_sorted(arr.begin(), arr.end())){
									return 1;
								}
								swap(arr[i], arr[j]);
							}
						}
						return 0;
					}
				};

			// Optimized:
				class Solution {
					public:
					bool classArrangement(int n, vector<int> &arr) {
						bool sameFound = false;
						int cnt=0;
						
						vector<int> desired = arr;
						sort(desired.begin(), desired.end());

						// Bob wants to impress Alice, he can impress only when there are 2 student who are not in sorted order
						// or array is already sorted but contains same element twice else Bob can not impress Alice 

						for(int i=0; i<n; i++){
							if(desired[i] != arr[i])
								cnt++;
							
							if(i > 0 && (arr[i] == arr[i-1]))
								sameFound = 1;
						}
						
						// if(cnt == 0 && sameFound)
						//     return 1;
						// else if(cnt == 2)
						//     return 1;
						// else
						//     return 0;
						// or instead of above if-else ladder use below 
						
						if((cnt == 0 && sameFound) or cnt == 2)
							return 1;
						return 0;
					}
				};
			
		958) Traffic Lights:
			Problem Statement:
				You are responsible for managing the traffic lights on a long stretch of highway. Initially, all traffic lights on the highway are set to red. There are n traffic lights in total. You will be given q queries, each of which instructs you to change the signal of a segment of the traffic lights.
				Each query specifies two indices [ai, bi], indicating that all traffic lights from ai to bi (both inclusive) should change their signals in the following manner:
					A red light ('R') changes to yellow ('Y').
					A yellow light ('Y') changes to green ('G').
					A green light ('G') changes to red ('R'). 

				Return a string of length n with the final state of all n traffic lights where the ith character in the string denotes the state of the ith traffic light after all the queries have been processed in the given order.
				Example 1:
					Input:
					n = 5, q= 3,
					queries = [[1,5], [1,4], [3,4]]
					Output: "GGRRY"
					Explanation: 
					Initial signal of the traffic lights is all red(RRRRR). After 1st query all traffic lights signal changes to Yellow(YYYYY).
					After 2nd query the signal changes for all traffic lights from index 1 to 4. The state of traffic lights is now GGGGY.
					After 3rd query the signal changes for all traffic lights from index 3 to 4. The final state of traffic lights is now GGRRY.

				Example 2:
					Input:
					n = 1, q = 2,
					queries = [[1,1], [1,1]]
					Output: "G"
					Explanation: 
					There is only one traffic light initially it is Red("R"). After first query the signal changes to "Y" and after the second and final query the final state changes to "G".

				Your Task:
					You don't need to read input or print anything. Return a string representing the final state of all n traffic lights after all the queries have been processed in the given order. 

				Constraints:

					1 ≤ n ≤ 10^5
					1 ≤ q ≤ 10^5
					1 ≤ queries[i][0] ≤ queries[i][1] ≤ n

			// Not Optimized:
				class Solution {
					public:
					string trafficLights(int n, int q, vector<vector<int>> &queries) {
						string s(n, 'R');
						
						for(int i=0; i < q; i++){
							int begin = queries[i][0], end = queries[i][1];
							for(int j=begin-1; j<end; j++){
								if(s[j] == 'R'){
									s[j] = 'Y';
								}else if(s[j] == 'Y'){
									s[j] = 'G';
								}else{          // if s[j] == 'G'
									s[j] = 'R';
								}
							}
						}		
						return s;
					}
				};

			// Optimized:
				❌Pending

	959) Convert array into Zig-Zag fashion:
		Problem Statement:
			Given an array arr of distinct elements of size n, the task is to rearrange the elements of the array in a zig-zag fashion so that the converted array should be in the below form: 
			arr[0] < arr[1]  > arr[2] < arr[3] > arr[4] < . . . . arr[n-2] < arr[n-1] > arr[n]. 
			Note: Modify the given arr[] only, If your transformation is correct, the output will be 1 else the output will be 0.
			Examples
			Input: n = 7, arr[] = {4, 3, 7, 8, 6, 2, 1}
			Output: 1
			Explanation:  After modification the array will look like 3 < 7 > 4 < 8 > 2 < 6 > 1, the checker in the driver code will produce 1.
			Input: n = 5, arr[] = {4, 7, 3, 8, 2}
			Output: 1
			Explanation: After modification the array will look like 4 < 7 > 3 < 8 > 2 hence output will be 1.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 10^6
				0 <= arri <= 10^9

		class Solution {
			public:
			void zigZag(int n, vector<int> &arr) {
				int flag =1;
				for(int i=0; i<n-1; i++){
					if(flag){
						if(arr[i] > arr[i+1])
							swap(arr[i], arr[i+1]);
						
						flag=0;
					}else{
						if(arr[i] < arr[i+1])
							swap(arr[i], arr[i+1]);
						
						flag=1;
					}
				}
			}
		};

		// or
			class Solution {
				public:
				void zigZag(int n, vector<int> &arr) {
					for(int i=0; i<n-1; i++){
						if(i&1){
							if(arr[i] < arr[i+1]) swap(arr[i], arr[i+1]);
						}else{
							if(arr[i] > arr[i+1]) swap(arr[i], arr[i+1]);
						}
					}
				}
			};
	
	960) Subarray Sums Divisible by K:
		Problem Statement:
			Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.
			A subarray is a contiguous part of an array.
			Example 1:
				Input: nums = [4,5,0,-2,-3,1], k = 5
				Output: 7
				Explanation: There are 7 subarrays with a sum divisible by k = 5:
				[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
			Example 2:
				Input: nums = [5], k = 9
				Output: 0				
			Constraints:
				1 <= nums.length <= 3 * 10^4
				-10^4 <= nums[i] <= 10^4
				2 <= k <= 10^4

		class Solution {
			public:
			int subarraysDivByK(vector<int>& nums, int k) {
				int n = nums.size(), cnt=0;
				map<int, int> mp;
				mp[0] = 1;
				int sum=0;
				for(int i: nums){
					sum += i;
					int remainder = sum % k;
					if(remainder < 0)
						remainder += k;
					if(mp.find(remainder) !=  mp.end())
						cnt += mp[remainder];
					
					mp[remainder]++;
				}
				return cnt;
			}
		};
	
	961) Nuts and Bolts Problem:
		Problem Statement:
			Given a set of n nuts & bolts. There is a one-on-one mapping between nuts and bolts. You have to Match nuts and bolts efficiently. Comparison of a nut to another nut or a bolt to another bolt is not allowed. It means the nut can only be compared with the bolt and the bolt can only be compared with the nut to see which one is bigger/smaller.
			The elements should follow the following order: { !,#,$,%,&,*,?,@,^ }
			Note: Make all the required changes directly in the given arrays, output will be handled by the driver code.
			Examples
				Input: n = 5, nuts[] = {@, %, $, #, ^}, bolts[] = {%, @, #, $ ^}
				Output: 
				# $ % @ ^
				# $ % @ ^
				Explanation: As per the order # should come first after that $ then % then @ and ^. 
			Input: n = 9, nuts[] = {^, &, %, @, #, *, $, ?, !}, bolts[] = {?, #, @, %, &, *, $ ,^, !}
				Output: 
				! # $ % & * ? @ ^
				! # $ % & * ? @ ^
				Explanation: We'll have to match first ! then  # , $,  %,  &,  *,  @,  ^,  ? as per the required ordering.

			Expected Time Complexity: O(n(logn))
			Expected Auxiliary Space: O(log(n))

			Constraints:
				1 <= n <= 9
				The arrays 'nuts' and 'bolts' can only consist of the following elements: {'@', '#', '$', '%', '^', '&', '?', '*', '!'}.
				All the elements of arrays 'nuts' and 'bolts' should be unique.
	
		class Solution {
			public:
			void matchPairs(int n, char nuts[], char bolts[]) {
				vector<char> hold;
				char ch[] = {'!', '#', '$', '%', '&', '*', '?', '@', '^'};
				for(int i=0; i<9; i++){
					if(find(nuts, nuts+n, ch[i]) != nuts+n)
						hold.push_back(ch[i]);
				}
				for(int i=0; i<n; i++){
					nuts[i] = hold[i];
					bolts[i] = hold[i];
				}
			}
		};

	962) Height Checker:
		Problem Statement:
			A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.
			You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).
			Return the number of indices where heights[i] != expected[i].
			
			Example 1:
				Input: heights = [1,1,4,2,1,3]
				Output: 3
				Explanation: 
				heights:  [1,1,4,2,1,3]
				expected: [1,1,1,2,3,4]
				Indices 2, 4, and 5 do not match.
			Example 2:
				Input: heights = [5,1,2,3,4]
				Output: 5
				Explanation:
				heights:  [5,1,2,3,4]
				expected: [1,2,3,4,5]
				All indices do not match.
			Example 3:
				Input: heights = [1,2,3,4,5]
				Output: 0
				Explanation:
				heights:  [1,2,3,4,5]
				expected: [1,2,3,4,5]
				All indices match.
			
			Constraints:
				1 <= heights.length <= 100
				1 <= heights[i] <= 100

		class Solution {
			public:
			int heightChecker(vector<int>& heights) {
				vector<int> sortedHeight = heights;
				sort(sortedHeight.begin(), sortedHeight.end());
				int cnt=0, n=sortedHeight.size();

				for(int i=0; i<n; i++)
					if(sortedHeight[i] != heights[i])
						cnt++;

				return cnt;
			}
		};

	963) Kth Smallest and Largest Element of Array:
		Problem statement
			You are given an array ‘Arr’ consisting of ‘N’ distinct integers and a positive integer ‘K’. Find out Kth smallest and Kth largest element of the array. It is guaranteed that K is not greater than the size of the array.
			Example:
			Let ‘N’ = 4,  ‘Arr’ be [1, 2, 5, 4] and ‘K’ = 3.  
			then the elements of this array in ascending order is [1, 2, 4, 5].  Clearly, the 3rd smallest and largest element of this array is 4 and 2 respectively.
			Constraints:
				1 <= T <= 50
				1 <= N <= 10^4
				1 <= K <= N
				-10^9 <= Arr[i] <= 10^9
				Where ‘T’ is the total number of test cases, ‘N’ is the size of array ‘Arr’ and Arr[i] is the element of the given array.
				Time limit: 1 sec
			Sample Input 1:
				2
				4 4
				5 6 7 2
				4 3
				1 2 5 4
				Sample Output 1:
				7 2 
				4 2
				Explanation of Sample Input 1:
				Test case 1:
				Here, ‘N’ = 4, ‘Arr’ = [5, 6, 7, 2] and ‘K’ = 3.
				Elements of the array in ascending order are [2, 5, 6, 7]
				Thus the 4rd smallest and 4rd largest elements of this array are 7 and 2 respectively.

				Test case 2:
				See problem statement for an explanation.
				Sample Input 2:
				2
				1 1
				2
				5 1
				5 4 3 2 1
				Sample Output 2:
				2 2
				1 5

		#include <algorithm>
		vector<int> kthSmallLarge(vector<int> &arr, int n, int k) {
			sort(arr.begin(), arr.end());
			return {arr[k-1], arr[n-k]};
		}

	964) Statistics From A Large Sample:
		Problem statement
			You have been given a sample of integers in the range [0, 255]. Since the sample is quite large, you are provided with an array/list “count” whose i-th element denotes the number of times ‘i’ appears in the sample.
			You are supposed to calculate the following statistics :
			1. minimum: The minimum element in the sample.
			2. maximum: The maximum element in the sample.
			3. mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.
			4. median:
				If the sample has an odd number of elements, then the median is the middle element once the sample is sorted.
				If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted.
			5. mode: The number that appears the most in the sample. It is guaranteed to be unique.
			Constraints :
				1 <= T <= 50
				0 <= count[i] <= 1000    
				Where count[i] is the i-th element of the “count” array/list.
				Time limit: 1 sec
				
			Sample Input 1 :
				2
				1 0 1 1 1 1 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
				1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
			Sample Output 1 :
				0.00000 8.00000 4.66667 5.00000 7.00000
				0.00000 2.00000 1.00000 1.00000 1.00000
			Explanation of Sample Input 1 :
				For the first test case, the elements in the sample are [0, 2, 3, 4, 5, 6, 7, 7, 8]. The minimum and maximum element is 0 and 8 respectively. Mean is (0 + 2 + 3 + 4 + 5 + 6 + 7 + 7 + 8) / 9 = 4.66667. Since the sample size is odd, median is the middle element i.e. 5. The mode is 7 as it appears the most in the sample.
				For the second test case, the elements in the sample are [0, 1, 1, 2]. The minimum and maximum element is 0 and 2 respectively. Mean is (0 + 1 + 1 + 2) / 4 = 1.00000. Since the sample size is even, the median is the average of the two middle elements i.e. (1 + 1) / 2 = 1. The mode is 1 as it appears the most in the sample.

		// Not Optimized:
			#include <bits/stdc++.h> 
			vector<double> sampleStats(vector<int> &count) {
				vector<double> ans;
				vector<int> values;
				for(int i=0; i<256; i++){
					int val = count[i];
					while(val--){
						values.push_back(i);
					}
				}

				ans.push_back(values.front());
				ans.push_back(values.back());
				int size = values.size();

				double mean = 0;
				for(int i: values)
					mean += i;
				
				mean /= (double) size;
				ans.push_back(mean);

				double median;
				if(size&1){
					median = values[size/2];
				}else{
					int ind = size/2;
					median = (values[ind] + values[ind - 1])/ 2.0;			// dividing by 2.0 instead of 2 coz it should consider it as double
				}
				ans.push_back(median);

				double mode = (max_element(count.begin(), count.end()) - count.begin());	
				ans.push_back(mode);
				return ans;
			}
	
		// Optimized:
			❌Pending

	965) Relative Sort Array:
		Problem Statement:
			Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.
			Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.
			
			Example 1:
				Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
				Output: [2,2,2,1,4,3,3,9,6,7,19]
			Example 2:
				Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
				Output: [22,28,8,6,17,44]
					
			Constraints:
				1 <= arr1.length, arr2.length <= 1000
				0 <= arr1[i], arr2[i] <= 1000
				All the elements of arr2 are distinct.
				Each arr2[i] is in arr1.

		Time Complexity (TC): O(n⋅m+klogk), where n is the size of arr2, m is the size of arr1, and k is the number of elements in arr1 not in arr2.
		Space Complexity (SC): O(m+k), due to the space used by the auxiliary vectors ans and temp.

		class Solution {
			public:
			vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
				vector<int> ans;
				// we need to sort arr1 according to arr2, so place all elements of arr2 which are there in arr1
				for(int i: arr2){
					for(int z=0; z<arr1.size(); z++){
						if(i == arr1[z]){
							ans.push_back(i);
							arr1[z] = -1;
						}
					}
				}
				vector<int> temp;
				for(int i=0; i<arr1.size(); i++)
					if(arr1[i] != -1)
						temp.push_back(arr1[i]);
					
				sort(begin(temp), end(temp));
				ans.insert(ans.end(), temp.begin(), temp.end());
				return ans;
			}
		};

		// Reference for delete element form map:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;
			int main() {		
				map<int, int> mp;
				mp[1] = 100;
				mp[2] = 200;
				mp[10] = 1000;
				mp[9] = 900;
				mp[8] = 800;

				for(auto i= mp.begin(); i != mp.end(); i++)
					// std::cout << i -> first << "\t" << i -> second << std::endl;
					std::cout << (*i).first << "\t" << (*i).second << std::endl;
					
				// or
				// for(auto i: mp)
				//     std::cout << i.first << "\t" << i.second << std::endl;
				
				auto itr = mp.begin();
				itr++, itr++;
				
				mp.erase(itr);
				std::cout << std::endl;
				for(auto i: mp)
					std::cout << i.first << "\t" << i.second << std::endl;

				itr = mp.end();
				itr--;
				mp.erase(itr);
				std::cout << std::endl;
				for(auto i: mp)
					std::cout << i.first << "\t" << i.second << std::endl;
				
				return 0;
			}

		// Using map:
			class Solution {
				public:
				vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
					map<int, int> mp;
					for(int i: arr1)
						mp[i]++;

					vector<int> ans;

					for(int i: arr2){
						int val = mp[i];
						while(val--)
							ans.push_back(i);
						mp.erase(i);
					}

					for(auto itr = mp.begin(); itr != mp.end(); itr++){
						int val = itr -> second;
						while(val--)
							ans.push_back(itr -> first);

						mp.erase(mp.begin());			// to delete the starting element of map
					}
					return ans;
				}
			};

		// Modification in same array arr1
			class Solution {
				public:
				vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
					map<int, int> mp;
					for(int i: arr1)
						mp[i]++;

						
					int z=0;
					for(int i: arr2){
						int val = mp[i];
						while(val--)
							arr1[z++] =i;
						mp.erase(i);
					}

					for(auto itr: mp){
						int val = itr.second;
						while(val--)
							arr1[z++] = itr.first;
					}
					return arr1;
				}
			};
	
		// Using Lambda function:
			class Solution {
				public:
				vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
					map<int, int> mp;
					for(int i=0; i<arr2.size(); i++)
						mp[arr2[i]] = i;
					
					for(int i: arr1)
						if(!mp.count(i))
							mp[i] = 1e9;
						
					auto CustomSort = [&](int n1, int n2){
						if(mp[n1] == mp[n2])
							return n1 < n2;
						return mp[n1] < mp[n2];
					};

					sort(arr1.begin(), arr1.end(), CustomSort);
					return arr1;
				}
			};

	966) Count Palindromic Subsequences - II:
		Problem Statement:
			You have been given a string ‘S’. Your task is to find the number of non-empty distinct palindromic subsequences in string ‘S’ and return that number modulo 10^9 + 7.
			Note:
			1. A string ‘A’ is a subsequence of a string ‘B’ if ‘A’ can be obtained from ‘B’ by deleting several (possibly, zero or all) characters. 
			2. A sequence is palindromic if it is equal to the sequence reversed.
			3. Two sequences A1, A2,... and B1, B2,... are different if there is some ‘i’ for which ‘Ai’ != ‘Bi’.
			Constraints :
				1 <= T <= 10
				1 <= |S| <= 3*10^3
				Where |S| denotes the length of ‘S’.
				Time limit: 1 sec
			Sample Input 1 :
				2
				abc
				pppp
				Sample output 1 :
				3
				4
				Explanation For Sample Output 1 :
				For the first test case, distinct palindromic subsequences are “a”, “b”, and “c”.

				For the second test case, distinct palindromic subsequences are “p”, “pp”, “ppp”, “pppp”.
				Sample Input 2 :
				2
				aba
				pqqr
				Sample output 2 :
				4
				4

		// Not Optimized:
			#include <bits/stdc++.h> 
			void SubSequenceGenerator(string &s, string temp, vector<string> &hold, int index){
				if(index >= s.size()){
					hold.push_back(temp);
					return ;
				}
				SubSequenceGenerator(s, temp, hold, index+1);

				temp += s[index];
				SubSequenceGenerator(s, temp, hold, index+1);
			}

			bool isPalindrom(string &s){
				int i=0, j=s.size()-1;
				while(i < j)
					if(s[i++] != s[j--])
						return 0;    

				return 1;
			}

			int countPalinSubseq(string &s) {
				string temp;
				vector<string> hold;
				SubSequenceGenerator(s, temp, hold, 0);

				set<string> st;
				int mod =  1e9+7, n;
				for(string ss: hold){
					if(isPalindrom(ss)){
						if(!st.count(ss)){
							
						}
						st.insert(ss);
						n = st.size() % mod;
					}
				}
				return (n-1) % mod ;          // decrementing coz it is considering empty sequence as palindrom
			}

		// Optimized:
			❌Pending

	967) Maximum Tip Calculator:
		Problem Statement:
			In a restaurant, two waiters, A and B, receive n orders per day, earning tips as per arrays arr[i] and brr[i] respectively. If A takes the ith order, the tip is arr[i] rupees; if B takes it, the tip is brr[i] rupees.
			To maximize total tips, they must distribute the orders such that:
			A can handle at most x orders
			B can handle at most y orders
			Given that x + y ≥ n, all orders can be managed by either A or B. Return the maximum possible total tip after processing all the orders.
			Examples
			Input: n = 5, x = 3, y = 3, arr = {1, 2, 3, 4, 5}, brr = {5, 4, 3, 2, 1}
			Output: 21
			Explanation: Person A will serve the 3rd, 4th and 5th order while person B will serve the rest so the total tip from A = 3+4+5 & B = 5 + 4 i.e. 21. 

			Input: n = 8, x = 4, y = 4, arr = {1, 4, 3, 2, 7, 5, 9, 6}, brr = {1, 2, 3, 6, 5, 4, 9, 8}
			Output: 43
			Explanation: Person A will serve 1st, 2nd, 5th and 6th order while Person B will serve the rest & the total tip will be 43.
		
			Input: n = 7, x = 3, y = 4, arr[] = {8, 7, 15, 19, 16, 16, 18}, brr[] = {1, 7, 15, 11, 12, 31, 9}
			Output: 110
			Explanation: Person A will serve orders 8,19,18 while person B will serve 7,15, 12 & 31.

			Expected Time Complexity: O(n*logn)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n ≤ 10^5
				1 ≤ x, y ≤ n
				1 ≤ arr[i], brr[i] ≤ 10^9

		class Solution {
			public:
			long long maxTip(int n, int x, int y, vector<int> &arr, vector<int> &brr) {
				long long mxValue=0;

				vector<pair<int, pair<int, int>>> v;
				for(int i=0; i<n; i++)
					v.push_back({abs(arr[i]-brr[i]), {arr[i], brr[i]}});
					
				sort(v.begin(), v.end(), greater<pair<int, pair<int, int>>>());        // sorting vector of pair is in descending order
				// sort(v.rbegin(), v.rend());
				for(int i=0; i<v.size(); i++){
					if(x == 0){
						mxValue += v[i].second.second;
					}else if(y == 0){
						mxValue += v[i].second.first;
					}else{
						if(v[i].second.first > v[i].second.second){
							mxValue += v[i].second.first;
							x--;
						}else{
							mxValue += v[i].second.second;
							y--;
						}
					}
				}
				return mxValue;
			}
		};
	
	968) Sort Colors:
		Problem Statement:
			Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
			We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
			You must solve this problem without using the library's sort function.
			Example 1:
				Input: nums = [2,0,2,1,1,0]
				Output: [0,0,1,1,2,2]
			Example 2:
				Input: nums = [2,0,1]
				Output: [0,1,2]
		
			Constraints:
				n == nums.length
				1 <= n <= 300
				nums[i] is either 0, 1, or 2.	
			Follow up: Could you come up with a one-pass algorithm using only constant extra space?

		// Using Selection Sort:
			class Solution {
				public:
				void sortColors(vector<int>& nums) {
					for(int i=0; i<nums.size(); i++)
						for(int j=i+1; j<nums.size(); j++)
							if(nums[i] > nums[j])
								swap(nums[i], nums[j]);
				}
			};

		// sort:
			class Solution {
				public:
				void sortColors(vector<int>& nums) {
					sort(nums.begin(), nums.end());
				}
			};

		// Simpler Counting & Loops
			class Solution {
				public:
				void sortColors(vector<int>& nums) {
					int zeros, ones;
					zeros=ones=0;
					for(int i: nums)
						if(i==0)
							zeros++;
						else if(i == 1)
							ones++;

					// for(int i=0; i<zeros; i++)
					//     nums[i] = 0;
					
					// for(int i=zeros; i<zeros+ones; i++)
					//     nums[i] = 1;

					// for(int i=zeros+ones; i<nums.size(); i++)
					//     nums[i] = 2;

					// or
					int i=0;
					while(zeros--)
						nums[i++] = 0;

					while(ones--)
						nums[i++] = 1;

					while(i < nums.size())
						nums[i++] = 2;  
				}
			};

		// Or
			class Solution {
				public:
				void sort012(vector<int>& arr) {
					int ones, zeros, twos;
					zeros = ones = twos = 0;
					
					for(int i: arr)
						if(i == 0) zeros++;
						else if(i == 1) ones++;
						else twos++;
					
					int i;
					for(i=0; i<zeros; i++)
						arr[i] = 0;
					
					for(; i<zeros+ones; i++)
						arr[i] = 1;
						
					for(; i<zeros+ones+twos; i++)
						arr[i] = 2;
				}
			};

		// DNF 0s 1s 2s:
			class Solution {
				public:
				void sortColors(vector<int>& nums) {
					int low, mid, high;
					low = mid = 0;
					high = nums.size()-1;

					while(mid <= high){
						if(nums[mid] == 0){
							swap(nums[low], nums[mid]);
							mid++, low++;
						}else if(nums[mid] == 2){
							swap(nums[mid], nums[high]);
							high--;
						}else{
							mid++;
						}
					}
				}
			};

	969) Count numbers containing 4:
		Problem Statement:
			You are given a number n, Return the count of total numbers from 1 to n containing 4 as a digit.
			Examples:
				Input: n = 9
				Output: 1
				Explanation: 4 is the only number between 1 to 9 which contains 4 as a digit.
			Input: n = 44
				Output: 9
				Explanation: 4, 14, 24, 34, 40, 41, 42, 43 & 44, there are total 9 numbers containing 4 as a digit.

			Expected Time Complexity: O(nlogn)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 10^5

		Time Complexity (TC): O(nlogn) & Space Complexity (SC): O(1)
		class Solution {
			public:
			int countNumberswith4(int n) {
				int cnt = 1, ans=0;
				while(cnt <= n){
					int curDigit = cnt;
					while(curDigit){
						if(curDigit % 10 == 4){
							ans++;
							break;
						}
						curDigit /= 10;
					}
					cnt++;
				}
				return ans;
			}
		};
		
		TC: O(n log(n)) & SC: O(log n)
			class Solution {
				public:
				int countNumberswith4(int n) {
					int cnt=0;
					
					for(int i=1; i<=n; i++){
						string s = to_string(i);
						if(s.find('4') != string::npos)
							cnt++;
					}
					return cnt;
				}
			};

	970) Sort an array of 0s, 1s and 2s:
		Problem Statement:
			Given an array of size N containing only 0s, 1s, and 2s; sort the array in ascending order.
			Example 1:
				Input: 
				N = 5
				arr[]= {0 2 1 2 0}
				Output:
				0 0 1 2 2
				Explanation:
				0s 1s and 2s are segregated 
				into ascending order.
			Example 2:
				Input: 
				N = 3
				arr[] = {0 1 0}
				Output:
				0 0 1
				Explanation:
				0s 1s and 2s are segregated 
				into ascending order.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function sort012() that takes an array arr and N as input parameters and sorts the array in-place.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^6
				0 <= A[i] <= 2

		Using DNF Algorithm:
			class Solution {
				public:
				void sort012(int a[], int n) {
					int low, mid, high;
					low = mid = 0;
					high = n-1;
					
					while(mid <= high){
						if(a[mid] == 2){
							swap(a[mid], a[high]);
							high--;
						}else if(a[mid] == 0){
							swap(a[mid], a[low]);
							mid++, low++;
						}else{
							mid++;
						}
					}
				}
			};

	971) Largest rectangle in a histogram:
		Problem statement
			You have been given an array/list 'HEIGHTS' of length ‘N. 'HEIGHTS' represents the histogram and each element of 'HEIGHTS' represents the height of the histogram bar. Consider that the width of each histogram is 1.
			You are supposed to return the area of the largest rectangle possible in the given histogram.
			For example :
			In the below histogram where array/list elements are {2, 1, 5, 6, 2, 3}.
			The area of largest rectangle possible in the given histogram is 10.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^6
				0 <= HEIGHTS[i] <= 10^9

				Where ‘T’ is the number of test cases.
				'N' is the length of the given array/list.
				And, HEIGHTS[i] denotes the height of the 'ith' histogram bar.
				Time Limit: 1 sec.
			Sample Input 1 :
			2
			10
			1 0 1 2 2 2 2 1 0 2 
			10
			1 2 1 0 1 1 0 0 2 2 
			Sample Output 1 :
			8
			4
			Explanation For Sample Input 1 :
			In the first test case, the area of the largest rectangle of the given histogram is 8 in the rectangle starting from index 4 to index 7 in the given array/list.

			In the second test case, the area of the largest rectangle of the given histogram is 4 in the rectangle starting from index 9 to index 10 in the given array/list.
			Sample Input 2 :
			2
			10
			8 6 3 5 0 0 4 10 2 5 
			10
			6 1 8 10 5 7 0 4 5 8 
			Sample Output 2 :
			12
			20
			Explanation For Sample Input 2 :
			In the first test case, the area of the largest rectangle of the given histogram is 12.
			In the second test case, the area of the largest rectangle of the given histogram is 20.

		// Not Optimized:
			int largestRectangle(vector<int>& heights) {
				int mxArea=0;
				for(int i=0; i < heights.size(); i++){
					int cnt=1;          // considering the current height.
					// going backwards
					for(int j=i-1; j>=0; j--){
						if(heights[i] > heights[j])
						break;
						cnt++;
					}

					// going forwards
					for(int j=i+1; j<heights.size(); j++){
						if(heights[i] > heights[j])
						break;
						cnt++;
					}

					mxArea = max(mxArea, cnt*heights[i]);
				}
				return mxArea;
			}

			// Or
				int largestRectangleArea(vector<int>& heights) {
					int mxArea = 0;
					int n = heights.size();
					vector<int> nextSmaller(n, 0);
					vector<int> prevSmaller(n, 0);

					for (int i = 0; i < n; i++) {
						int cnt = 0;
						for (int j = i + 1; j < n; j++) {
						if (heights[i] > heights[j])
							break;
						cnt++;
						}
						nextSmaller[i] = cnt;
					}

					for (int i = 0; i < n; i++) {
						int cnt = 0;
						for (int j = i - 1; j >= 0; j--) {
						if (heights[i] > heights[j])
							break;
						cnt++;
						}
						prevSmaller[i] = cnt;
					}

					for (int i = 0; i < n; i++) {
						int curValue = (1 + prevSmaller[i] + nextSmaller[i]) * heights[i];
						mxArea = max(mxArea, curValue);
					}
					return mxArea;
				}

		// Optimized: Using logic of Next Greater Element & stack
			❌Pending practice

	972) Subarray with distinct integers:
		Problem statement
			You are given an array/list 'ARR' consisting of 'N' integers and an integer 'B'. A non-empty subarray of 'ARR' is good if it contains exactly 'B' distinct integers.
			Your task is to return the number of good subarrays in the given array/list.
			Example:
			For 'ARR' = [1, 2, 1, 3, 2, 4] and 'B' = 3, one of the good subarrays which contains three distinct integers is [1, 2, 1, 3]. 
			Note:
			An array 'C' is a subarray of array 'D' if it can be obtained by deletion of several elements(possibly zero) from the beginning and the end from array 'D'.
			Constraints:
				1 <= T <= 100
				1 <= N <= 5000
				1 <= B <= N
				1 <= ARR[i] <= 10^9
				Time Limit: 1sec
			Sample Input 1 :
				2
				5 2 
				1 2 1 2 3
				5 3
				1 2 1 3 4
				Sample Output 1:
				7
				3
				Explanation for Sample 1:
				All good subarrays in test case 1 are [1, 2], [2, 1], [1, 2], [2, 3], [1, 2, 1], [2, 1, 2], [1, 2, 1, 2].

				All good subarrays in test case 2 are [1, 2, 1, 3], [2, 1, 3], [1, 3, 4]. So the total good subarray are 3.
				Sample Input 2 :
				1
				5 5
				1 2 1 3 4
				Sample Output 2 :
				0

		// Not Optimized:
			#include <bits/stdc++.h> 
			int goodSubarrays(vector<int>& arr, int n, int b) {
				int cnt=0;
				for(int i=0; i<n; i++){
					set<int> s;
					for(int j=i; j<n; j++){
						s.insert(arr[j]);
						if(s.size() == b)
							cnt++;
							
						if(s.size() > b)
							break;
					}
				}
				return cnt;
			}

		// Optimized:
			❌Pending
	
	973) Reverse The Groups:
		Problem statement
			You are given a stack 'S', of size 'N' consisting of integers only. You are also given an integer 'K'. You are supposed to reverse each group of size 'K' in the stack.
			Start making the group of size 'K' from the top of the stack and then reverse this group. Repeat this process and if there are fewer than 'K' integers in the last group, leave the group as it is.
			Print the stack after reversing each group of size 'K'.
			Example :
			'S' = {1, 2, 3, 4, 5, 6}, 'K' = 2.
			The leftmost element (i.e. 1) is the bottommost element of the stack, and the rightmost element (i.e. 6) is the topmost element of the stack.

			Group 1 : {5, 6}.
			Group 2 : {3, 4}.
			Group 3 : {1, 2}.

			After reversing the groups :

			Group 1 : {6, 5}.
			Group 2 : {4, 3}.
			Group 3 : {2, 1}.

			So, the stack now looks like , 'S' : {2, 1, 4, 3, 6, 5}.
			Constraints :
				1 <= T <= 10
				1 <= N, K <= 10^5
				1 <= S[i] <= 10^5

			The Sum of 'N' over all test cases is <= 10^5.
			Time Limit: 1 sec
			Sample Input 1 :
				2
				4 4
				2 4 6 8
				8 3
				1 3 5 7 9 11 13 15
				Sample Output 1 :
				8 6 4 2
				1 3 9 7 5 15 13 11
				Explanation Of Sample Input 1 :
				For test 1:

				There is only one group of size 4 which is {2, 4, 6, 8}.
				After reversing the group, it becomes {8, 6, 4, 2}.
				The final stack is : {8, 6, 4, 2}.

				For test 2:

				There are two groups of size 3 and one group of size < 3.
				Group 1 : {11, 13, 15}.
				Group 2 : {5, 7, 9}.
				Group 3 : {1, 3}.

				After reversing the groups:
				Group 1 : {15, 13, 11}.
				Group 2 : {9, 7, 5}.
				Group 3 : {1, 3}. This group is not reversed as its size is < 'K'.

				The final stack is : {1, 3, 9, 7, 5, 15, 13, 11}.    
				Sample Input 2 :
				2
				3 1
				9 7 8
				4 3
				1 7 6 5
				Sample Output 2 :
				9 7 8
				1 5 6 7

		#include <bits/stdc++.h> 
		stack<int> reverseTheGroups(stack<int> &s, int n, int k) {
			if(k == 1)
				return s;

			vector<int> v;
			while(!s.empty()){
				v.push_back(s.top());
				s.pop();
			}

			vector<int> temp;
			stack<vector<int>> sample;
			for(int i=0; i<v.size(); i++){
				temp.push_back(v[i]);
				if(temp.size() >= k){
					sample.push(temp);
					temp.clear();
				}
			}

			if(!temp.empty())
				sample.push(temp);

			while(!sample.empty()){
				vector<int> cur = sample.top();
				if(cur.size() % k != 0){
					reverse(cur.begin(), cur.end());
					int i=0;
					while(i<cur.size()){
						s.push(cur[i++]);
					}
				}else{
					int i=0;
					while(i < cur.size()){
						s.push(cur[i++]);
					}
				}
				sample.pop();
			}
			return s;
		}
	
	#CN BeginnerContest-62:
		974) Find Min-Max:
			Problem statement
				You are given '4' integers 'A', 'B', 'C', and 'D'.
				As you like maximum and minimum elements from these, you want to find the sum of them.
				Return the integer denoting the sum of every element which is either minimum or maximum among 'A', 'B', 'C', and 'D'.
				Example:
				A = 4
				B = 5
				C = 1
				D = 5
				We can see that 'B' and 'D' are the maximum and 'C' is a minimum element among 'A', 'B', 'C', and 'D'. The sum of these elements is '5 + 5 + 1' = '11'.
				So, the answer for this case is '11'.
				Constraints:
					1 <= 'T' <= 10
					-10^8 <= 'A', 'B', 'C', 'D' <= 10^8

					Time limit: 1 sec
				Sample input 1:
					2
					4 1 4 1
					1 2 3 4
					Sample output 1:
					10
					5
					Explanation of sample input 1:
					For test case 1:
					We can see that 'A' and 'C' are the maximum and 'B' and 'D' are the minimum elements among 'A', 'B', 'C', and 'D'. The sum of these elements is '4 + 4 + 1 + 1' = '10'.
					So, the answer for this case is '10'.

					For test case 2:
					We can see that 'D' is the maximum and 'A' is the minimum element among 'A', 'B', 'C', and 'D'. The sum of these elements is '1 + 4' = '5'.
					So, the answer for this case is '5'.
					Sample input 2:
					2
					1 -3 1 1
					5 4 -2 5
					Sample output 2:
					0
					8

			// #include<bits/stdc++.h>
			int minMaxSum(int a, int b, int c, int d) {
				int sum =0;
				vector<int> z {a,b,c,d};
				int mn = *min_element(z.begin(), z.end());
				int mx = *max_element(z.begin(), z.end());

				for(int i: z){
					if(i == mn)
						sum += i;
					else if(i == mx)
						sum += i;
				}
				return sum;
			}
		
		975) Dice game:
			Problem statement
				You have a die of six sides numbered from '0' to '5'.
				You are given an array 'A' of '6' integers, where 'A[i]' is the integer written on the side 'i' of the die.
				In one operation, you can choose any two sides 'i' and 'j' of the die and swap the integers written on them.
				Let's call a die perfect if, for each pair of opposite sides, the integers written on them are equal.
				Note that side '0' is opposite of side '3', side '1' is opposite of side '4', and side '2' is opposite of side '5'.
				You are required to find the minimum number of operations you must perform to make the die perfect. It is guaranteed that you can always make the die perfect.
				Example:
				A = [1, 2, 1, 1, 1, 2]
				In one operation, you can select sides '1' and '2'. So, the resulting array ['1', '1', '2', '1', '1', '2'] represents a perfect die.
				It can be proved that you can not make die perfect in less than '1' operation.
				So, the answer for this case is '1'.
				Detailed explanation ( Input/output format, Notes, Images )
				Constraints:
					1 <= 'A[i]' <= 10
					It is guaranteed that input is given in such a way that you can always make the die perfect.
					Time limit: 1 sec
				Sample input 1:
					2
					1 2 3 1 2 3
					10 2 2 2 2 10
					Sample output 1:
					0
					1
					Explanation of sample input 1:
					For test case 1:
					We can see that the given array already represents perfect die.
					So, the answer for this case is '0'.

					For test case 2:
					In one operation, you can select sides '3' and '5'. So, the resulting array ['10', '2', '2', '10', '2', '2'] represents a perfect die.
					It can be proved that you can not make die perfect in less than '1' operation.
					So, the answer for this case is '1'.
					Sample input 2:
					2
					1 1 2 2 3 3 
					1 2 2 1 3 3
					Sample output 2:
					2
					1

			int minimumOperations(vector<int> &v) {
				if(v[0] == v[3] && v[1] == v[4] && v[2] == v[5])
					return 0;
				else if(v[0] == v[3] or v[1] == v[4] or v[2] == v[5])
					return 1;
				else
					return 2;
			}

	#CodeChef Starters-138:
		976) Heat Wave:
			Problem Statement:
				During a scorching heat wave, the temperature in a Chefland reached a record high of X degrees.
				The next day, the recorded temperature was Y degrees. Find whether this was a new record high or not.
				Input Format
					The first and only line of input will contain two space separated integers X and Y denoting the highest recorded temperature and the temperature on a given day respectively.
				Output Format
					Output on a new line, YES, if a new high was created. Otherwise print NO.
					You may print each character of the string in uppercase or lowercase (for example, the strings YES, yEs, yes, and yeS will all be treated as identical).
				Constraints
					100≤X,Y≤150
				Sample 1:
				Input
				135 110
				Output
				NO
				Explanation:
				The temperature recorded is 
				110
				110 which is less than the highest recorded temperature. Thus, it did not make a new high.

				Sample 2:
				Input
				121 121
				Output
				NO
				Explanation:
				The temperature recorded is 
				121
				121 which is equal to the highest recorded temperature. Thus, it did not make a new high.

				Sample 3:
				Input
				101 150
				Output
				YES
				Explanation:
				The temperature recorded is 
				150
				150 which is greater than the highest recorded temperature. Thus, it made a new high.

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int x, y;
				cin>>x>>y;
				
				if(x < y)
					cout<<"Yes";
				else
					cout<<"No";

				return 0;
			}
		
	977) Minimum Number of Moves to Seat Everyone:
		Problem Statement:
			There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.
			You may perform the following move any number of times:
			Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
			Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.
			Note that there may be multiple seats or students in the same position at the beginning.
	
			Example 1:
				Input: seats = [3,1,5], students = [2,7,4]
				Output: 4
				Explanation: The students are moved as follows:
				- The first student is moved from from position 2 to position 1 using 1 move.
				- The second student is moved from from position 7 to position 5 using 2 moves.
				- The third student is moved from from position 4 to position 3 using 1 move.
				In total, 1 + 2 + 1 = 4 moves were used.

			Example 2:
				Input: seats = [4,1,5,9], students = [1,3,2,6]
				Output: 7
				Explanation: The students are moved as follows:
				- The first student is not moved.
				- The second student is moved from from position 3 to position 4 using 1 move.
				- The third student is moved from from position 2 to position 5 using 3 moves.
				- The fourth student is moved from from position 6 to position 9 using 3 moves.
				In total, 0 + 1 + 3 + 3 = 7 moves were used.

			Example 3:
				Input: seats = [2,2,6,6], students = [1,3,2,6]
				Output: 4
				Explanation: Note that there are two seats at position 2 and two seats at position 6.
				The students are moved as follows:
				- The first student is moved from from position 1 to position 2 using 1 move.
				- The second student is moved from from position 3 to position 6 using 3 moves.
				- The third student is not moved.
				- The fourth student is not moved.
				In total, 1 + 3 + 0 + 0 = 4 moves were used.

			Constraints:
				n == seats.length == students.length
				1 <= n <= 100
				1 <= seats[i], students[j] <= 100

		class Solution {
			public:
			int minMovesToSeat(vector<int>& seats, vector<int>& students) {
				ios_base::sync_with_stdio(0);
				cin.tie(0);
				cout.tie(0);
				
				sort(seats.begin(), seats.end());
				sort(students.begin(), students.end());

				int n = seats.size();
				int cnt=0;
				for(int i=0; i<n ; i++) {
					if(students[i] != seats[i])
						cnt += abs(students[i] - seats[i]);
				}
				return cnt;
			}
		};
	
	978) Padovan Sequence
		Problem Statement:
			Given a number n, find the nth number in the Padovan Sequence.
			A Padovan Sequence is a sequence which is represented by the following recurrence relation
			P(n) = P(n-2) + P(n-3)
			P(0) = P(1) = P(2) = 1
			Note: Since the output may be too large, compute the answer modulo 10^9+7.
			Examples :
				Input: n = 3
				Output: 2
				Explanation: We already know, P1 + P0 = P3 and P1 = 1 and P0 = 1
			Input: n = 4
			Output: 2
			Explanation: We already know, P4  = P2 + P1 and P2 = 1 and P1 = 1

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 10^6

		// Not Optimized: TC: O(2^n) SC: O(n)
			class Solution {
				public:
				int mod = 1e9+7;
				int padovanSequence(int n) {
					if(n == 0 or n == 1 or n == 2)
						return 1;
					return (padovanSequence(n-2) + padovanSequence(n-3)) % mod;
				}	
			};

		// Optimized:
			Time Complexity (TC): O(n)  & Space Complexity (SC): O(n)
				class Solution {
					public:
					int padovanSequence(int n) {
						vector<int> v {1, 1, 1};
						int mod = 1e9+7;
						
						if(n == 1)
							return v[0];
						else if(n == 2)
							return v[1];
						else{
							for(int i=3; i<=n; i++){
								int val = v[i-2] + v[i-3];
								val %= mod;
								v.push_back(val);
							}
						}
						return v.back();
					}
				};

			Time Complexity (TC): O(n)  & Space Complexity (SC): O(1)
				class Solution {
					public:
					int padovanSequence(int n) {
						int mod = 1e9+7;
						if(n == 1 or n == 2)
							return 1;
						
						int last, secondLast, thirdLast;
						last = secondLast = thirdLast = 1;
						for(int i=3; i<=n; i++){
							int val = secondLast + thirdLast;
							thirdLast = secondLast;
							secondLast = last;
							last = val % mod;
						}
						return last;
					}
				};
		
	979) Return Subsets Sum to K:
		Problem statement
			Given an integer array 'ARR' of size 'N' and an integer 'K', return all the subsets of 'ARR' which sum to 'K'.
			Subset of an array 'ARR' is a tuple that can be obtained from 'ARR' by removing some (possibly all) elements of 'ARR'.
			Note :
			The order of subsets is not important. 
			The order of elements in a particular subset should be in increasing order of the index.
			Constraints:
				1 <= 'N' <= 16
				- (10 ^ 6) <= ARR[i] <= (10 ^ 6)
				- 16 * (10 ^ 6) <= 'K' <= 16 * (10 ^ 6)
				Where ‘ARR[i]’ denotes the value for ‘ith’ element of the array ‘ARR’ and 'K' is the given sum.
				Time Limit: 1 sec.

			Sample Input 1:
				3
				2 4 6
				6
				Sample Output 1:
				2 4
				6
				Explanation of the Sample Input 1:
				For the array'ARR' = {2, 4, 6}, we can have subsets {}, {2}, {4}, {6}, {2, 4}, {2, 6}, {4, 6}, {2, 4, 6}. Out of these 8 subsets, {2, 4} and {6} sum to the given 'K' i.e. 6. 
				Sample Input 2:
				6 
				5 -1 8 2 7 0
				7
				Sample Output 2:
				-1 8 
				-1 8 0 
				5 2 
				5 2 0 
				7 
				7 0 

		void Generate(vector<int> &main, vector<int> curSeq, vector<vector<int>> &ans, int i){
			if(i >= main.size()){
				ans.push_back(curSeq);        
				return;
			}

			Generate(main, curSeq, ans, i+1);
			
			curSeq.push_back(main[i]);
			Generate(main, curSeq, ans, i+1);
		}

		vector<vector<int>> findSubsetsThatSumToK(vector<int> arr, int n, int k) {
			vector<vector<int>> allSequence;
			vector<int> eachSeq;
			Generate(arr, eachSeq, allSequence, 0);

			vector<vector<int>> sumToK;
			for(auto row: allSequence){
				int sum = 0;
				for(int i: row)
					sum += i;

				if(sum == k)
					sumToK.push_back(row);
			}
			return sumToK;
		}

		// or
			void Generate(vector<int> &main, vector<int> curSeq, vector<vector<int>> &ans, int i, int k){
				if(i >= main.size()){
					int sum = 0;
					for(int i: curSeq)
						sum += i;
					if(sum == k)
						ans.push_back(curSeq);
					return;
				}

				Generate(main, curSeq, ans, i+1, k);
				
				curSeq.push_back(main[i]);
				Generate(main, curSeq, ans, i+1, k);
			}
			
			vector<vector<int>> findSubsetsThatSumToK(vector<int> arr, int n, int k) {
				vector<vector<int>> allSequence;
				vector<int> eachSeq;
				Generate(arr, eachSeq, allSequence, 0, k);
				
				return allSequence;
			}

	#CN WeeklyContest-130:
		980) Same by Swap:
			Problem statement
				You are given two arrays 'A' and 'B' of 'N' integers numbered from '0' to 'N - 1'.
				In one operation, you can select any index 'i' ('0 <= i <= N-1') and swap 'A[i]' and 'B[i]'.
				Determine whether you can make every element of the array 'A' equal after performing the given operation any number of times (Possibly '0' times).
				Return '1' if you can make every element of the array 'A' equal. Otherwise, return '0'.

				Example:
					N = 3
					A = [1, 2, 1]
					B = [2, 1, 4]
					In one operation, you can select 'i' equal to '1', resulting in the array 'A' equal to ['1', '1', '1'] in which every element is the same.
					So, the answer for this case is '1'.
				Constraints:
					2 <= 'N' <= 10^5
					1 <= 'A[i]', 'B[i]' <= 10^5
					Time limit: 1 sec
				Sample input 1:
				2
				3
				1 1 1
				2 2 2
				2
				1 2
				1 2
				Sample output 1:
				1
				0
				Explanation of sample input 1:
				For test case 1:
				You can see that every element of the array 'A' is already equal.
				So, the answer for this case is '1'.

				For test case 2:
				It can be proved that you can not make every element of the array equal by performing the given operations any number of times.
				So, the answer for this case is '0'.
				Sample input 2:
				2
				4
				1 2 2 1
				2 1 1 2
				5
				1 2 2 4 1
				2 1 1 4 2
				Sample output 2:
				1
				0

			bool allAreEqual(vector<int> &v){
				for(int i=0; i<v.size()-1; i++)
					if(v[i] != v[i+1])
						return 0;
				return 1;
			}
			int canYouMakeEqual(int n, vector<int> &a, vector<int> &b) {
				if(allAreEqual(a))
					return 1;
				
				if(allAreEqual(b))
					return 1;

				for(int i=0; i<n; i++){
					vector<int> temp = a;

					for(int j=0; j<n; j++){
						if(i == j or temp[j] == a[i])
							continue;
						
						temp[j] = b[j];
					}

					if(allAreEqual(temp))
						return 1;
				}
				return 0;
			}
			
		981) Palindromic Prime Number:
			Problem statement:
				A number is said to be a ‘Palindromic Prime’ if it satisfies the following conditions:
				All the digits in a number should be prime (‘2’, ‘3’, ‘5’ or ‘7’).
				Rearranging its digits gives a palindrome.
				For example: “23235” is a Palindromic Prime Number because we can rearrange its digits to turn it into “23532” which is a palindrome.
				You are given two integers ‘L’ and ‘R’. You have to count the number of Palindromic Prime Numbers from ‘L’ to ‘R’.
				Your task is to count the number of Palindromic Prime Numbers from ‘L’ to ‘R’ and return it.

				Example:
					‘L’ = 200 ‘R’ = 300
				The Palindromic Prime Numbers from ‘200’ to ‘300’ are: (‘222’, ‘223’, ‘225’, ‘227’, ‘232’, ‘233’, ‘252’, ‘255’, ‘272’, and ‘277’).
				The count of these numbers is ‘10’.
				Constraints:
					1 <= ‘T’ <= 10
					1 <= ‘L’ <= ‘R’ <= 10^9
					Time Limit: 1 sec
				Sample Input 1:
				2
				2 50
				300 388
				Sample Output 1:
				6
				10
				Explanation of sample input 1:
				For test case 1:
				The Palindromic Prime Numbers from ‘2’ to ‘50’ are: (‘2’, ‘3’, ‘5’, ‘7’, ‘22’, and ‘33’).
				So, the count of these numbers is ‘6’.
				For test case 2:
				The Palindromic Prime Numbers from ‘300’ to ‘388’ are: ‘(322, ‘323’, ‘332’,  ‘333‘, ‘335’, ‘337’, 353’, ‘355’, ‘373’, and ‘377’).
				So, the count of these numbers is ‘10’.
				Sample Input 2:
				2
				25 9234
				1000 10000
				Sample Output 2:
				83
				40 

			// Not Optimized:
				int palindromicPrimeNumber (int l, int r) {
					int cnt=0;
					vector<int> v;

					while(l <= r){
						int cur = l;
						int flag=1;
						while(cur){
							int digit = cur % 10;
							if(digit == 0 or digit == 1 or digit == 4 or digit == 6 or digit == 8 or digit == 9){
								flag = 0;
								break;
							}
							cur /= 10;
						}
						if(flag)
						v.push_back(l);
						l++;
					}

					for(int i=0; i<v.size(); i++){
						int curNum = v[i];
						// cout<<v[i]<<"\t";
						map<int, int> Fr;

						while(curNum){
							Fr[curNum % 10]++;
							curNum /= 10;
						}

						int dontCnt=1;
						int oddOnce = 1;
						for(auto itr: Fr)
						if(itr.second&1 && oddOnce){
							oddOnce = 0;
							continue;
						}else if(itr.second % 2 == 0){
							continue;
						}else{
							dontCnt=0;
							break;
						}
						
						if(dontCnt)
							cnt++;
					}
					return cnt;
				}

			// Optimized:
				❌Pending
		
	982) Minimum Increment to Make Array Unique:
		Problem Statement:
			You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.
			Return the minimum number of moves to make every value in nums unique.
			The test cases are generated so that the answer fits in a 32-bit integer.
			Example 1:
				Input: nums = [1,2,2]
				Output: 1
				Explanation: After 1 move, the array could be [1, 2, 3].
			Example 2:
				Input: nums = [3,2,1,2,1,7]
				Output: 6
				Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
				It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
		
			Constraints:
				1 <= nums.length <= 10^5
				0 <= nums[i] <= 10^5

		// Not Optimized:
			class Solution {
				public:
				int minIncrementForUnique(vector<int>& nums) {
					sort(nums.begin(), nums.end());
					int cost=0;

					for(int i=1; i<nums.size(); i++){
						while(find(nums.begin(), nums.begin()+i, nums[i]) != nums.begin()+i){				// checking that nums[i] element is present previously, 
							cost++;															// if present then incrementing the current element by 1 & cost by one
							nums[i]++;
						}
					}
					return cost;
				}
			};

		// Optimised:
			1) Sorting:
				class Solution {
					public:
					int minIncrementForUnique(vector<int>& nums) {
						sort(nums.begin(), nums.end());
						int cost=0;

						for(int i=1; i<nums.size(); i++){
							if(nums[i] <= nums[i-1]){
								cost += nums[i-1] - nums[i] + 1;
								nums[i] += nums[i-1] - nums[i] + 1;
							}
						}
						return cost;
					}
				};

			2) Creating Array of size (arr_size + mxNum_in_arr) so it should not cross index
				class Solution {
					public:
					int minIncrementForUnique(vector<int>& nums) {
						int n = nums.size();
						int mx = *max_element(nums.begin(), nums.end());

						vector<int> arr(n+mx, 0);

						int cost =0;
						for(int i=0; i<n; i++)
							arr[nums[i]]++;
						
						for(int i=0; i < ( n+mx ); i++){
							if(arr[i] > 1){
								cost += arr[i] - 1;
								arr[i+1] += arr[i] - 1;
								arr[i] = 1;
							}
						}
						return cost;
					}
				};

	983) Modular Node:
		https://www.naukri.com/code360/problems/modular-node_3118998
		Problem statement
			You are given a singly linked list containing ‘N’ nodes, where every node in the linked list contains a pointer “next” which points to the next node in the list and having integer values. You are also given an integer ‘K’.
			You recently studied modular operation and you wanted to find out the last node in the linked list such that ‘x%K’ = 0 , where ‘x’ is the position of the node from the beginning.
			Return the last node that satisfies the above property.
			Example :
			N = 7 , K = 3
			Linked List = 1 -> 3 -> 2 -> 4 -> 6 -> 5 -> 7
			Explanation : 
				The first node has ‘x%K’ = 1%3 = 1.
				The second node has ‘x%K’ = 2%3 = 2.
				The third node has ‘x%K’ = 3%3 = 0.
				The fourth node has ‘x%K’ = 4%3 = 1.
				The fifth node has ‘x%K’ = 5%3 = 2.
				The sixth node has ‘x%K’ = 6%3 = 0.
				The seventh node has ‘x%K’ = 7%3 = 1.
				So, the last node which has ‘x%k’ = 0 is the sixth node with value 5.
			Constraints :
				1 <= T <= 5
				1 <= N <= 10^5
				1 <= K <= N
				Sum of N over all Test cases <= 10^5
				Time Limit : 1 sec
			Sample Input 1 :
			2
			3 3
			1 2 3 -1
			5 2
			3 7 1 9 8 -1
			Sample Output 1 :
			3
			9
			Explanation Of Sample Input 1 :
			For test case 1 we have, 
			The linked list is 1 -> 2 -> 3.
			The last node with ‘x%3’ = 0 is with ‘x=3’.
			The third node has value 3.
			So, we output 3.
			For test case 2 we have,
			The linked list is 3 -> 7 -> 1 -> 9 -> 8.
			The last node with ‘x%2’ = 0 is with ‘x=4’.
			The fourth node has value 9.
			So, we output 9.
			Sample Input 2 :
			2
			3 2
			6 5 2 -1
			2 1
			9 7 -1
			Sample Output 2 :
			5
			7

		#include <bits/stdc++.h> 
		/************************************************************
			Following is the linkedList class structure:
			class Node {
				public:
					int data;
					Node *next;

				Node(int val) {
					this->data = val;
					next = NULL;
				}
				~Node() {
					if (next != NULL) {
						delete next;
					}
				}
			};
		************************************************************/

		Node* modularNode(int k, Node* head) {
			int cnt=1, lastVal=0;
			Node* temp = head;

			while(temp){
				if(cnt % k == 0){
					lastVal = cnt;
				}
				cnt++;
				temp = temp -> next;
			}

			while(--lastVal){
				head = head -> next;
			}
			return head;
		}

	984) Armstrong Numbers:
		Problem Statement:
			You are given a 3-digit number n, Find whether it is an Armstrong number or not.
			An Armstrong number of three digits is a number such that the sum of the cubes of its digits is equal to the number itself. 371 is an Armstrong number since 33 + 73 + 13 = 371. 
			Note: Return "true" if it is an Armstrong number else return "false".
			Examples
			Input: n = 153
			Output: true
			Explanation: 153 is an Armstrong number since 13 + 53 + 33 = 153. Hence answer is "true".

			Input: n = 372
			Output: false
			Explanation: 372 is not an Armstrong number since 33 + 73 + 23 = 378. Hence answer is "false".

			Expected Time Complexity: O(1)
			Expected Auxiliary Space: O(1) 

			Constraints:
				100 ≤ n <1000

		class Solution {
			public:
			string armstrongNumber(int temp) {
				int sum=0, n =temp;
				sum += pow(n%10, 3);
				n /= 10;
				
				sum += pow(n%10, 3);
				n /= 10;
				
				sum += pow(n%10, 3);
				
				// cout<<sum<<"\t"<<temp<<"\n";
				if(sum == temp)
					return "true";
				return "false";
			}
		};

	985) Maximum Product After K Increments:
		Problem Statement:
			You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1.
			Return the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. Note that you should maximize the product before taking the modulo. 
			Example 1:
				Input: nums = [0,4], k = 5
				Output: 20
				Explanation: Increment the first number 5 times.
				Now nums = [5, 4], with a product of 5 * 4 = 20.
				It can be shown that 20 is maximum product possible, so we return 20.
				Note that there may be other ways to increment nums to have the maximum product.
			Example 2:
				Input: nums = [6,3,3,2], k = 2
				Output: 216
				Explanation: Increment the second number 1 time and increment the fourth number 1 time.
				Now nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216.
				It can be shown that 216 is maximum product possible, so we return 216.
				Note that there may be other ways to increment nums to have the maximum product.
			
			Constraints:
				1 <= nums.length, k <= 10^5
				0 <= nums[i] <= 10^6

		// Not Optimized:
			class Solution {
				public:
				int maximumProduct(vector<int>& nums, int k) {
					while(k--){
						sort(nums.begin(), nums.end());
						nums[0]++;
					}

					long ans = nums[0], mod = 1e9+7;
					for(int i=1; i<nums.size(); i++){
						ans = (ans * nums[i]) % mod;
					}
					return ans % mod;
				}
			};

		// Optimized:
			❌Pending

	986) Anagram Difference:
		Problem statement
			You have been given two strings, let's say 'STR1' and 'STR2' of equal lengths. You are supposed to return the minimum number of manipulations required to make the two strings anagrams.
			Note:
			An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase. We can generalise this in string processing by saying that an anagram of a string is another string with the same quantity of each character in it, in any order.
			Example:
			String “eat” and “ate” are anagram to each other but string “buy” and “bye” are not.
			Constraints :
				1<= T <= 100
				1<= N <= 5*10^3
				Where 'N' is the length of strings 'STR1' and 'STR2'.
				Time limit: 1 sec
			Sample Input 1:
				2
				except
				accept
				buy
				bye
				Sample Output 1 :
				2
				1
				Explanation Of Sample Output 1 :
				In test case 1, we can change two character of  'STR1' i.e. {'e','x'} to {'a','c'} or we can change two character of  'STR2' i.e. {'a','c'} to {'e','x'}, to make string anagram. So the minimum number of manipulations to make 'STR1' and  'STR2' to anagram string will be 2.

				In test case 2, we can change one character of  'STR1' i.e. {'u'} to {'e'} or we can change one character of  'STR2' i.e. {'e'} to {'u'}, to make string anagram. So the minimum number of manipulations to make  'STR1' and 'STR2' to anagram string will be 1.
				Sample Input 2:
				2
				mail
				male
				ninja
				ninja
				Sample Output 2 :
				1
				0
				Explanation Of Sample Output 2 :
				In test case 1, we can change one character of  'STR1' i.e. {'i'} to {'e'} or we can change one character of  'STR2' i.e. {'e'} to {'i'}, to make string anagram. So the minimum number of manipulations to make  'STR1' and  'STR2' to anagram string will be 1.
				In test case 2, both strings are already anagram. So we do not need to do any manipulation. So the minimum number of manipulations to make  'STR1' and  'STR2' to anagram string will be 0.

		#include <bits/stdc++.h> 
		int getMinimumAnagramDifference(string &s1, string &s2) {
			int arr[26] = {0};
			for(char ch: s1)
				arr[ch - 'a']++;

			for(char ch: s2)
				arr[ch - 'a']--;
			
			int cnt=0;
			for(int i=0; i<26; i++)
				cnt += abs(arr[i]);
			
			return cnt/2;
		}

	987) Bit Set:
		Problem statement
			You are given a sequence of only digits in the form of a string 'DIGIT_PATTERN', your task is to find the first repeating digit. If no digit is repeating you should return -1.
			Example:
			Given string of digits is 123456325. Now starting from the left, the first digit which is repeating is 3 as till 2nd 3 every digit is encountered 1st time and thus our answer for this input will be 3.
			Constraints:
				1 <= T <= 10
				1 <= |DIGIT_PATTERN| <= 10^5
				0 <= DIGIT_PATTERN[ i ] <= 9
				Where ‘DIGIT_PATTERN[i]' denotes the digit at ‘i’th index in the string ‘DIGIT_PATTERN’.
				Time Limit: 1 sec
			Sample Input 1:
				2
				1234
				12342 
				Sample Output 1:
				-1
				2
				Explanation For Sample Input 1:
				In the first test case, no digit is repeating in the string.

				In the second test case, digit 2 is repeating first in the string.
				Sample Input 2:
				2
				456746725
				98768742  
				Sample Output 2:
				4
				8
				Explanation For Sample Input 2:
				In the first test case, digit 4 is repeating first in the string. Digits 6,7,5 are also repeating but the digit 4 is repeating first among all.
				In the second test case, digit 8 is repeating first in the string.

		#include <bits/stdc++.h> 
		int findFirstRepeatingDigit(string digitPattern) {
			set<int> s;
			for(char ch: digitPattern){
				int n = ch - '0';
				if(s.count(n))
					return n;
				s.insert(n);
			}
			return -1;
		}

	988) IPO:
		Problem Statement:
			Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.
			You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.
			Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.
			Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.
			The answer is guaranteed to fit in a 32-bit signed integer.
			
			Example 1:
				Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
				Output: 4
				Explanation: Since your initial capital is 0, you can only start the project indexed 0.
				After finishing it you will obtain profit 1 and your capital becomes 1.
				With capital 1, you can either start the project indexed 1 or the project indexed 2.
				Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
				Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.
			Example 2:
				Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
				Output: 6
			
			Constraints:
				1 <= k <= 10^5
				0 <= w <= 10^9
				n == profits.length
				n == capital.length
				1 <= n <= 10^5
				0 <= profits[i] <= 10^4
				0 <= capital[i] <= 10^9

		TC : O(NLogN + KLogN) & SC: O(N)
			class Solution {
				public:
				int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
					vector<pair<int, int>> v;
					// we need to sort based on capital, coz if we don't have enough capital then 
					// we can't buy that ith project & project after ith index.
					ios_base::sync_with_stdio(0);
					cin.tie(0);
					cout.tie(0);
					
					int n = profits.size();
					for(int i=0; i<n; i++)
						v.push_back({capital[i], profits[i]});

					sort(v.begin(), v.end());               // this sort function sorts the v based on first value ie. capital's value

					int i=0;
					priority_queue<int> pq;

					while(k--){

						while(i < n && w >= v[i].first){
							pq.push(v[i].second);               // selecting project which we can afford
							i++;
						}

						if(pq.empty()){
							break;                          // we can't even afford a single project with current money, so stoping here.
						}
						w += pq.top();                  // selecting project which gives us more profit
						pq.pop();                       // removing selected projects
					}
					return w;
				}
			};

	#AtCoder BeginnerContest-358:
		989) Welcome to AtCoder Land:
			Problem Statement:
				Takahashi is heading to AtCoder Land. There is a signboard in front of him, and he wants to determine whether it says AtCoder Land.
				You are given two strings S and T separated by a space. Determine whether S= AtCoder and T= Land.
				Constraints
				S and T are strings consisting of uppercase and lowercase English letters, with lengths between 1 and 10, inclusive.
				Input
				The input is given from Standard Input in the following format: S T
				Output
				If S= AtCoder and T= Land, print Yes; otherwise, print No.

				Sample Input 1
				AtCoder Land
				Sample Output 1
				Yes
				S= AtCoder and 
				T= Land.

				Sample Input 2
				CodeQUEEN Land
				Sample Output 2
				No
				S is not AtCoder.

				Sample Input 3
				aTcodeR lANd
				Sample Output 3
				No
				Uppercase and lowercase letters are distinguished.

			#include <iostream>
			using namespace std;
			int main() {
				string s, t;
				cin>>s>>t;
				
				if(s == "AtCoder" && t == "Land")
					cout<<"Yes";
				else
					cout<<"No";
				return 0;
			}

		990) Ticket Counter:
			Problem Statement:
				At the entrance of AtCoder Land, there is a single ticket booth where visitors line up to purchase tickets one by one. The purchasing process takes 
				A seconds per person. Once the person at the front of the line finishes purchasing their ticket, the next person (if any) immediately starts their purchasing process.
				Currently, there is no one in line at the ticket booth, and N people will come to buy tickets one after another. Specifically, the 
				i-th person will arrive at the ticket booth Ti seconds from now. If there is already a line, they will join the end of it; if not, they will start the purchasing process immediately.
				Here, 
					T1 < T2 < ⋯ < TN.

				For each i (1≤i≤N), determine how many seconds from now the i-th person will finish purchasing their ticket.
				Constraints
				1≤N≤100
				0 ≤ T1 < T2 < ⋯ < TN ≤ 10^6
				1≤ A ≤ 10^6
				
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:

				N A 
				T1 T2 … TN			
				Output
					Print N lines. The i-th line should contain the number of seconds from now that the 
					i-th person will finish purchasing their ticket.

				Sample Input 1
				3 4
				0 2 10
				Sample Output 1
				4
				8
				14
				The events proceed in the following order:

				At 0 seconds: The 1st person arrives at the ticket booth and starts the purchasing process.
				At 2 seconds: The 2nd person arrives at the ticket booth and joins the line behind the 1st person.
				At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person starts the purchasing process.
				At 8 seconds: The 2nd person finishes purchasing their ticket.
				At 10 seconds: The 3rd person arrives at the ticket booth and starts the purchasing process.
				At 14 seconds: The 3rd person finishes purchasing their ticket.
				Sample Input 2
				3 3
				1 4 7
				Sample Output 2
				4
				7
				10
				The events proceed in the following order:
				At 1 second: The 1st person arrives at the ticket booth and starts the purchasing process.
				At 4 seconds: The 1st person finishes purchasing their ticket, and the 2nd person arrives at the ticket booth and starts the purchasing process.
				At 7 seconds: The 2nd person finishes purchasing their ticket, and the 3rd person arrives at the ticket booth and starts the purchasing process.
				At 10 seconds: The 3rd person finishes purchasing their ticket.
				Sample Input 3
				10 50000
				120190 165111 196897 456895 540000 552614 561627 743796 757613 991216
				Sample Output 3
				170190
				220190
				270190
				506895
				590000
				640000
				690000
				793796
				843796
				1041216

			#include <iostream>
			#include<vector>
			using namespace std;
			int main() {
				int n, A;
				cin>>n>>A;
				vector<int> v(n);
				for(int i=0; i<n; i++)
					cin>>v[i];
					
				vector<int> ans = {A+v[0]};
				
				for(int i=1; i<n; i++){
					if(v[i] < ans.back()){
						ans.push_back(ans.back()+A);
					}else{
						ans.push_back(v[i]+A);
					}
				}
				
				for(int i: ans)
					std::cout << i << " ";
				return 0;
			}

	#LeetCode WeeklyContest-402:
		991) Count Pairs That Form a Complete Day I:
			Problem Statement:
				Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.
				A complete day is defined as a time duration that is an exact multiple of 24 hours.
				For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.

				Example 1:
					Input: hours = [12,12,30,24,24]
					Output: 2
					Explanation:
					The pairs of indices that form a complete day are (0, 1) and (3, 4).

				Example 2:
					Input: hours = [72,48,24,3]
					Output: 3
					Explanation:
					The pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).
			
				Constraints:
					1 <= hours.length <= 100
					1 <= hours[i] <= 10^9

			class Solution {
				public:
				int countCompleteDayPairs(vector<int>& hours) {
					int cnt=0;
					for(int i=0; i<hours.size()-1; i++){
						for(int j=i+1; j<hours.size(); j++){
							if((hours[i]+hours[j]) % 24 == 0)
								cnt++;
						}
					}
					return cnt;
				}
			};

		992) Count Pairs That Form a Complete Day II:
			Problem Statement:
				Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.
				A complete day is defined as a time duration that is an exact multiple of 24 hours.
				For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.
				
				Example 1:
					Input: hours = [12,12,30,24,24]
					Output: 2
					Explanation: The pairs of indices that form a complete day are (0, 1) and (3, 4).
				Example 2:
					Input: hours = [72,48,24,3]
					Output: 3
					Explanation: The pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).

				Constraints:
					1 <= hours.length <= 5 * 10^5
					1 <= hours[i] <= 10^9

			// Not Optimized:
				class Solution {
					public:
					long long countCompleteDayPairs(vector<int>& hours) {
						long long cnt =0;
						int n = hours.size();
						for(int i=0; i<n; i++){
							for(int j=i+1; j<n; j++){
								if((hours[i] + hours[j]) % 24 ==0 )
									cnt++;
							}
						}
						return cnt;
					}
				};
		
			// Optimized:
				❌Pending
	
		993) Peaks in Array:
			Problem Statement:
				A peak in an array arr is an element that is greater than its previous and next element in arr.
				You are given an integer array nums and a 2D integer array queries.
				You have to process queries of two types:
				queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].
				queries[i] = [2, indexi, vali], change nums[indexi] to vali.
				Return an array answer containing the results of the queries of the first type in order.
				Notes:
				The first and the last element of an array or a subarray cannot be a peak.
				Example 1:
					Input: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]
					Output: [0]
					Explanation:
					First query: We change nums[3] to 4 and nums becomes [3,1,4,4,5].
					Second query: The number of peaks in the [3,1,4,4,5] is 0.

				Example 2:
					Input: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]
					Output: [0,1]
					Explanation:
					First query: nums[2] should become 4, but it is already set to 4.
					Second query: The number of peaks in the [4,1,4] is 0.
					Third query: The second 4 is a peak in the [4,1,4,2,1].
				Constraints:
					3 <= nums.length <= 10^5
					1 <= nums[i] <= 10^5
					1 <= queries.length <= 10^5
					queries[i][0] == 1 or queries[i][0] == 2
					For all i that:
					queries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1
					queries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10^5

			// Not Optimized:
				class Solution {
					public:
					vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {
						vector<int> peakCnt;
						int q = queries.size();
						
						for(int i=0; i<q; i++){
							int first = queries[i][0];
							if(first == 1){
								int start = queries[i][1], end = queries[i][2];
								int cnt =0;
								
								for(int z=start+1; z <= end-1; z++){
									if(nums[z-1] < nums[z] && nums[z] > nums[z+1])
									cnt++;
								}
								
								peakCnt.push_back(cnt);
							}else{
								nums[queries[i][1]] = queries[i][2];
							}
						}
						
						return peakCnt;
					}
				};

			// Optimized:
				❌Pending

	#GFG Weekly-159:
		994) Sorting Items:
			Problem Statement:
				In Geekland, each item has a unique identifier made up of uppercase English letters (A-Z). Here's how the identifiers work:
				'A' represents the number 1
				'B' represents the number 2
				...
				'Z' represents the number 26
				'AA' represents the number 27
				'AB' represents the number 28
				...
				'ZZ' represents the number 702
				'AAA' represents the number 703 and so on...
				You are given n identifiers sort these identifiers in ascending order based on their numeric values.

				Example 1:
					Input:
					n = 5
					items[] = {D, C, B, ABC, AA}
					Output: B C D AA ABC
					Explanation: 
					B = 2,
					C = 3
					D = 4,
					AA = 27
					ABC = 731

				Example 2:
					Input:
					n = 5
					items[] = {DD, A, B, ZZ, ABCDE}
					Output: A B DD ZZ ABCDE
					Explanation: 
					A = 1
					B = 2
					DD = (4 * 26) + 4 = 108
					ZZ = (26 * 26) + 26 = 702
					ABCDE = (1 * 264) + (2 * 263) + (3 * 262) + (4 * 261) + (5 * 260) = 494265

				Your Task:
					You don't read input or print anything; you need to complete the function sortItems which has an integer n and a string array items[] as an argument passed to it. The function should return the array sorted in ascending order based on their numeric values as described. Each identifier is a unique combination of uppercase English letters ('A'-'Z').

				Constraints:
					1 <= n <= 10^5
					1 <= items[i].length <= 10
					items array consists of uppercase English letters only.

			class Solution {
				public:
				long long VALUE(string &s){
					long long cost=0;
					
					for(char ch: s){
						cost = (cost*26 + (ch - 'A' + 1));
					}
					
					return cost;
				}
				
				vector<string> sortItems(int n, vector<string> &items) {
					vector<pair<long long, string>> StringValue;
					for(string s: items)
						StringValue.push_back({VALUE(s), s});
					
					
					sort(StringValue.begin(), StringValue.end());
					items.clear();
					for(auto i: StringValue)
						items.push_back(i.second);
					return items;
				}
			};
			
			// or Using multiset:
				class Solution {
					public:
					vector<string> sortItems(int n, vector<string> &items) {
						map<int, multiset<string>> mp;
						for(auto s: items)
							mp[s.size()].insert(s);
						
						vector<string> v;
						for(auto i: mp)
							for(auto j: i.second)
								v.push_back(j);
						
						return v;
					}
				};

		995) Bridge on Bits:
			Problem Statement:
				Given an array arr of length n, the task is to construct a bridge from arr[0] to arr[n-1], bridge between all the numbers in the array is said to be complete if for any ith bit all the number in the array arr have there ith bit set. In one operation you can flip any bit of a number in the array, if the bit is 0 make it 1 or vice versa, your task is to return the minimum number of operations required to construct a bridge.
				Example 1:
					Input:
					n = 5
					arr = {1,2,3,4,5}
					Output: 2
					Explanation:
					Initially there is no bridge between the numbers, current state looks like:
					arr[0] = 001(binary representation)
					arr[1] = 010
					arr[2] = 011
					arr[3] = 100
					arr[4] = 101

					After performing the flipping operation, arr[1] and arr[3] gets converted to 3 and 5. Now the state looks like:
					arr[0] = 001
					arr[1] = 011
					arr[2] = 011
					arr[3] = 101
					arr[4] = 101
					There is a bridge between all the numbers through 0th bit. This state requires minimum number of operations.

				Example 2:
					Input:
					n = 3
					arr = {6,2,3}
					Output: 0
					Explanation:
					arr[0] = 110(binary representation)
					arr[1] = 010
					arr[2] = 011
					There is already a bridge between the elements through 1st bit, hence no operation required.

				Your Task:
					You need to complete a function makeBridgeOne() which takes an  integer n and an integer array arr[] as parameter and return the minimum number of operations required to construct a bridge from arr[0] to arr[n-1].

				Constraints:
					1 <= n <= 10^5
					1 <= arr[i] <= 10^18

			class Solution {
				public:
				int makeBridgeOne(int n, vector<long long> &arr) {
					int min_cost = INT_MAX;
					
					for(int i=0; i<63; i++){         // taken 63 coz its long long, & have size of 64, so checking all bits & taking min number of unset bits
						int curCost=0;
						for(int z=0; z<n; z++){
							long long mask = 1;
							if(!((mask << i) & arr[z]))                // if its zero then increment cur_cost by one.		// if(!((1L << i) & arr[z])) 
								curCost++;
						}
						min_cost = min(min_cost, curCost);
					}
					
					return min_cost;
				}
			};

		996) Candy Distribution And Geeks' Queries:
			Problem Statement:
				Geek is distributing candies among n childern who are standing in a straight line. Geek is taking help of a robot for distributing candies. It distributes candies for m minutes. During each minute, robot chooses a segment of students [a[i][0], a[i][1]] (1 <= a[i][0] <= a[i][1] <= n and 0 <= i < m) both inclusive and gives a[i][2] candies to each child in that segment. After robot has distributed the candies, Geek asks you q queries. In each query there will be an integer query[i] (0 <= i < q), you have to find how many childern have atleast query[i] candies.
				Example 1:
					Input:
					n = 3, m = 2, q = 2
					a = [[2, 3, 4], [3, 3, 1]]
					query = [5, 6]
					Output:
					1 0
					Explanation:
					Number of candies with childern:
					After 1st minute, [0, 4, 4].
					After 2nd minute, [0, 4, 5].
					So the answer
					to query[0] will be 1, 
					and that to query[1] will be 0. 

				Example 2:
					Input:
					n = 4, m = 3, q = 4
					a = [[2, 3, 2], [1, 1, 1], [1, 4, 3]]
					query = [3, 4, 5, 6]
					Output:
					4 3 2 0
					Explanation:
					Number of candies with childern:
					After 1st minute, [0, 2, 2, 0].
					After 2nd minute, [1, 2, 2, 0].
					After 3rd minute, [4, 5, 5, 3].
					So the answer
					to query[0] will be 4, 
					that to query[1] will be 3,
					that to query[2] will be 2,
					and that to query[3] will be 0. 

				Your Task:
					You don't need to read input or print anything. Your task is to complete the function queriesAndCandyDistribution() which takes intergers n, m, q and arrays a, query as input and returns the answer to all the queries in an array.

				Constraints:
					1 <= n, m, q <= 10^5
					1 <= a[i][0] <= a[i][1] <= n, (0 <= i < m)
					1 <= a[i][2] <= 10^4, (0 <= i < m)
					0 <= query[i] <= 10^9, (0 <= i < q)

			class Solution {
				public:
				vector<int> queriesAndCandyDistribution(int n, int m, int q, vector<vector<int>>& a, vector<int>& query) {
					vector<int> childs(n, 0);
					
					for(int i=0; i<m; i++){
						int start = a[i][0], end = a[i][1];
						for(int j=start-1; j < end; j++)
							childs[j] += a[i][2];
						
						// for(int z: childs)
						//     cout<<z<<"\t";
						// cout<<"\n";
					}
					
					
					vector<int> ans;
					for(int i: query){
						int child_with_min_i_candi_cnt=0;
						for(int j: childs)
							if(i <= j)
								child_with_min_i_candi_cnt++;
						
						ans.push_back(child_with_min_i_candi_cnt);
					}
					return ans;
				}
			};

	997) Prime Pair with Target Sum:
		Problem Statement:
			Given a number n, find out if n can be expressed as a+b, where both a and b are prime numbers. If such a pair exists, return the values of a and b, otherwise return [-1,-1] as an array of size 2.
			Note: If [a, b] is one solution with a <= b, and [c, d] is another solution with c <= d, and a < c then  [a, b] is considered as our answer.

			Examples
				Input: n = 10
				Output: 3 7
				Explanation: There are two possiblities 3, 7 & 5, 5 are both prime & their sum is 10, but we'll pick 3, 7 as 3 < 5.
				Input: n = 3
				Output: -1 -1
				Explanation: There are no solutions to the number 3.

			Expected Time Complexity: O(n*loglog(n))
			Expected Auxiliary Space: O(n)

			Constraints:
				2 <= n <= 10^6

		// Not Optimized:
			class Solution {
				public:
				bool isPrime(int n){
					for(int i=2; i<= n/2; i++)
						if(n % i == 0)
							return 0;
					return 1;
				}
				vector<int> getPrimes(int n) {
					// Prime nums till n (max 10^6)
					vector<int> primeV;
					for(int i=2; i<n; i++){
						if(isPrime(i))
							primeV.push_back(i);
					}
					
					int i=0;
					while(i<primeV.size()-1){
						int j = i+1;
						while(j < primeV.size()){
							if(primeV[i] + primeV[j] == n)
								return {primeV[i], primeV[j]};
							j++;
						}
						i++;
					}
					return {-1, -1};
				}
			};

		// Optimized:
			❌Pending
	
	998) Patching Array:
		Problem Statement:
			Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.
			Return the minimum number of patches required.		
			Example 1:
				Input: nums = [1,3], n = 6
				Output: 1
				Explanation:
				Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
				Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
				Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
				So we only need 1 patch.

			Example 2:
				Input: nums = [1,5,10], n = 20
				Output: 2
				Explanation: The two patches can be [2, 4].

			Example 3:
				Input: nums = [1,2,2], n = 5
				Output: 0
			
			Constraints:
				1 <= nums.length <= 1000
				1 <= nums[i] <= 10^4
				nums is sorted in ascending order.
				1 <= n <= 2^31 - 1

		// Memory Limit Exceed (MLE):
			class Solution {
				public:
				void GenerateSequence(vector<int> &main, vector<int> temp, int i, vector<int> &storingN){
					if(i >= main.size()){
						int sum = 0;
						for(int z=0; z<temp.size(); z++)
							sum += temp[z];

						auto itr = find(storingN.begin(), storingN.end(), sum);
						if( itr != storingN.end() ){
							storingN.erase(itr);
						}

						return ;
					}

					GenerateSequence(main, temp, i+1, storingN);

					temp.push_back(main[i]);
					GenerateSequence(main, temp, i+1, storingN);
				}
				int minPatches(vector<int>& nums, int n) {
					vector<int> storingN(n);
					for(int i=0; i<n; i++)
						storingN[i] = i+1;

					
					vector<int> temp;
					GenerateSequence(nums, temp, 0, storingN);

					int cnt=0;
					while(storingN.size() > 0){
						int firstPresentElement = storingN[0];
						nums.push_back(firstPresentElement);
						GenerateSequence(nums, temp, 0, storingN);
						temp.clear();
						cnt++;
					}

					return cnt;
				}
			};

		// Optimized:
			class Solution {
				public:
				int minPatches(vector<int>& nums, int n) {
					int patch=0, i=0;
					long maxReach=0;

					while(maxReach < n){
						if(i < nums.size() && nums[i] <= maxReach+1){
							maxReach += nums[i];
							i++;
						}else{
							maxReach += (maxReach+1);
							patch++;
						}
					}
					return patch;
				}
			};
		
	999) Sum of Square Numbers:
		Problem Statement:
			Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.
 			Example 1:
				Input: c = 5
				Output: true
				Explanation: 1 * 1 + 2 * 2 = 5
			Example 2:
				Input: c = 3
				Output: false
			
			Constraints:
				0 <= c <= 231 - 1

		// Not Optimized:
			class Solution {
				public:
				bool judgeSquareSum(int c) {
					long i=0;
					vector<long long> v;
					while(i*i <= c){
						v.push_back(i*i);
						i++;
					}
					for(int i=0; i<v.size(); i++){
						for(int j=i; j<v.size(); j++)
							if(v[i]+v[j] == c)
								return 1;
					}
					return 0;
				}
			};

		// Optimized:
			class Solution {
				public:
				bool judgeSquareSum(int c) {
					// two pointers approach
					long a = 0;
					long b = sqrt(c);

					while(a <= b){
						long sum = a*a + b*b;
						if(sum == c){
							return 1;
						}else if(sum > c){
							b--;
						}else{
							a++;
						}
					}
					return 0;
				}
			};

	1000) Partition:
		Problem statement
			You are given a linked list and a number ‘x’, You have to partition the linked list in such a way that all nodes with a value less than 'x' comes before the nodes with values greater than or equal to 'x'. The original relative order should be preserved.
			Constraints
				1 <= ’T’ <= 50
				-1000 <= ’x’ <= 1000
				0 <= Length of linked list <= 10000
				-1000 <= "data" <= 1000
				"data" != -1, 'x' != -1
			Where 'T' is the number of test cases. 'x' denotes the given integer and "data" denotes the linked list node value.
				Sample Input 1
				2
				5 4 7 1 2 3 -1
				4
				1 2 3 4 0 5 6 -1
				3
				Sample Output 1:
				1 2 3 5 4 7  
				1 2 0 3 4 5 6  
				Explanation:-
				Here is the linked list for the first test case:-

				The nodes with value 1,2,3 are less than x that is 
				4.They should appear before 5,4,7
				Sample Input 2:
				2
				-3 5 -2 6 4 7 -1
				5
				1 2 3 4 5 6 7 -1
				1
				Sample Output 2:
				-3 -2 4 5 6 7  
				1 2 3 4 5 6 7  

		#include <bits/stdc++.h> 
		/****************************************************************
			Following is the class structure of the Node class:
				class Node {
					public:
						int data;
						Node *next;
					Node(int data) {
						this->data = data;
						this->next = NULL;
					}
				};
		*****************************************************************/
		Node*findPartiton(Node*head, int x) {
			vector<int> temp;
			Node *h1 = head;
			while(h1){
				temp.push_back(h1 -> data);
				h1 = h1 -> next;
			}

			// traversing through temp vector to collect all values less than x
			int n = temp.size();
			Node *h2 = head;
			for(int i=0; i<n; i++){
				if(temp[i] < x){
					h2 -> data = temp[i];
					h2 = h2 -> next;
				}
			}

			// traversing through temp vector to collect all values greater or equals to x
			for(int i=0; i<n; i++){
				if(temp[i] >= x){
					h2 -> data = temp[i];
					h2 = h2 -> next;
				}
			}
			return head;
		}

		// or
		Node *findPartiton(Node*head, int x) {
			vector<int> v1;
			vector<int> v2;
			
			Node* t = head;
			while(t){
				int val = t -> data;
				if(val < x)
					v1.push_back(val);
				else
					v2.push_back(val);
				t = t -> next;
			}

			t = head;
			int i=0;
			while(i < v1.size())
				t -> data = v1[i++], t = t -> next;
			
			i = 0;
			while(i < v2.size())
				t -> data = v2[i++], t = t -> next;

			return head;
		}

	1001) Minimum Deletions To Make Character Frequencies Unique:
		Problem statement
			You are given a string ‘STR’ consisting of lowercase English alphabets. Your take is to find out the minimum number of character deletions required such that each character in the final string has a unique frequency.
			Constraints :
				1 <= T <= 10
				2 <= |STR| <= 10^5
				Where |STR| denotes the length of the initial string ‘STR’. 
				Time limit: 1 second
			Sample Input 1 :
				2
				babccbc
				gttqtq
				Sample Output 1 :
				1
				0
				Explanation For Sample Input 1 :
				Test Case 1 :
				The frequency of ‘a’ is 1, of ‘b’ is 3 and of ‘c’ is 3. Therefore after deletion of one character of either ‘b’ or ‘c’ makes the frequencies 1,2 and 3.

				Test Case 2 :
				The frequency of 'g' is 1, 't' is 3 and 'q' is 2. Therefore there is no need for a delete operation.
				Sample Input 2 :
				2
				abbccc
				cbbd
				Sample Output 2 :
				0
				1
				Explanation For Sample Input 2 :
				For the first test case, each character already has a unique frequency(1 for ‘a’, 2 for ‘b’ and 3 for ‘c’), hence we don’t need to do any deletions.
				For the second test case frequency of ‘c’ and ‘d’ is equal hence we need to delete either of them. Therefore the answer is 1.

		#include<set>
		int minDeletions(string str) {
			vector<int> v (26);
			for(char ch: str)
				v[ch-'a']++;
			
			sort(v.begin(), v.end());
			set<int> s;
			int cnt=0;

			s.insert(v[0]);
			for(int i=1; i<26; i++){
				if(v[i] == 0)
					continue;
				while(s.count(v[i]) && v[i] != 0){
					v[i]--;
					cnt++;
				}
				if(s.count(v[i]) != 1 && v[i] != 0)
					s.insert(v[i]);
			}
			return cnt;
		}

	1002) Number of Rectangles in a Circle:
		Problem Statement:
			Given a circular sheet of radius, r. Find the total number of rectangles with integral length and width that can be cut from the sheet that can fit on the circle, one at a time.
			Examples :
				Input: r=1
				Output: 1
				Explanation: Only 1 rectangle of dimensions 1x1.
			Input: r=2
				Output: 8
				Explanation: The 8 possible rectangles are 
				(1x1)(1x2)(1x3)(2x1)(2x2)(2x3)(3x1)(3x2).

			Expected Time Complexity: O(r^2)
			Expected Auxillary Space: O(1)

			Constraints:
				1<=r<=1000 

		class Solution {
			public:
			int rectanglesInCircle(int r) {
				int cnt=0, last = 2*r;
				for(int i=1; i <= last; i++){
					for(int j=1; j <= last; j++){
						if(i * i + j * j <= 4*r*r)              // reactangle area is less or equals to circle area then cnt increment
							cnt++;
					}
				}
				return cnt;
			}
		};

	1003) Most Profit Assigning Work:
		Problem Statement:
			You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:
			difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and
			worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).
			Every worker can be assigned at most one job, but one job can be completed multiple times.
			For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.
			Return the maximum profit we can achieve after assigning the workers to the jobs.

			Example 1:
				Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
				Output: 100
				Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.

			Example 2:
				Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
				Output: 0
			
			Constraints:
				n == difficulty.length
				n == profit.length
				m == worker.length
				1 <= n, m <= 104
				1 <= difficulty[i], profit[i], worker[i] <= 10^5

		class Solution {
			public:
			int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
				vector<pair<int, int>> v;
				int n = profit.size();

				for(int i=0; i<n; i++)
					v.push_back({difficulty[i], profit[i]});

				// we'll assign the work to worker based on their ability, so we will sort the v based on difficulty
				sort(v.begin(), v.end());
				int w = worker.size(), total=0;
				for(int i=0; i<w; i++){
					int curProf = 0;
					for(int j=0; j<n; j++){
						if(worker[i] < v[j].first)
							break;
						curProf = max(curProf, v[j].second);
					}
					total += curProf;
				}
				return total;
			}
		};

		// using Prioriy queue (max heap):
			class Solution {
				public:
				int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
					priority_queue<pair<int, int>> pq;      // max heap
					int n = difficulty.size();
					int m = worker.size();
					for(int i=0; i<n; i++)
						pq.push({profit[i], difficulty[i]});                // max profit should be on top so we keep profit first
					
					sort(worker.rbegin(), worker.rend());       // sorting in descending order
					int i=0, mxProf=0;
					while(i < m && !pq.empty()) {
						if(pq.top().second > worker[i]){
							pq.pop();
						}else{
							mxProf += pq.top().first;
							i++;
						}
					}
					return mxProf;
				}
			};

		// using BinarySearch:
			❌Pending
	
	1004) Binary Pattern:
		Problem statement
			You have been given an input integer 'N'. Your task is to print the following binary pattern for it.
			Example
			Pattern for 'N' = 4
				1111
				000
				11
				0
			The first line contains 'N' 1s. The next line contains 'N' - 1 0s. Then the next line contains 'N' - 2 1s and so on.
			Constraints :
				1 <= T <= 10
				1 <= N <= 10^3
				Time Limit: 1 sec
			Sample Input 1:
				2
				1
				2
				Sample Output 1:
				1
				11
				0
				Sample Input 2:
				2
				3
				5
				Sample Output 2:
				111
				00
				1
				11111
				0000
				111
				00
				1

		#include <bits/stdc++.h> 
		void printPatt(int n) {
			for(int i=0; i<n; i++){
				if(i&1){
					string s(n-i, '0');
					cout<<s<<"\n";
				}else{
					string s(n-i, '1');
					cout<<s<<"\n";
				}
			}
		}
	
	1005) Find maximum volume of a cuboid: ❌Pending
		-formula should be known to solve it
		Problem Statement:
			You are given a perimeter & the area. Your task is to return the maximum volume that can be made in the form of a cuboid from the given perimeter and surface area.
			Note: Round off to 2 decimal places and for the given parameters, it is guaranteed that an answer always exists.
			Examples
				Input: perimeter = 22, area = 15
				Output: 3.02
				Explanation: The maximum attainable volume of the cuboid is 3.02
				Input: perimeter = 20, area = 5
				Output: 0.33
				Explanation: The maximum attainable volume of the cuboid is 0.33
			Expected Time Complexity: O(1)
			Expected Auxiliary Space: O(1)

			Constraints :
				1 ≤ perimeter ≤ 10^9
				1 ≤ area ≤ 10^9

		class Solution {
			public:
			double maxVolume(double perimeter, double area) {
				double p = perimeter, a = area;
				double sqrtTerm = sqrt(p*p - 24 * a);
				double dimension1 = (p - sqrtTerm) / 12.0;
				double dimension2 = (p/4.0) - 2 * dimension1;
				
				double volume = pow(dimension1, 2) * dimension2;
				return round(volume * 100.0) / 100.0;
			}
		};
	
	1006) Add First and Second Half:
		Problem statement
			You are given a Singly Linked List of N nodes such that each node represents a single digit.
			Your task is to return a node 'X', where 'X' represents the head of the Linked List storing the digits of the sum(most significant digit at the head) formed by adding the 1st half and 2nd half of the given Linked List.
			Note:
			1. When N is odd consider the middle element to be part of 1st half.
			2. The sum should not contain any leading zero, except the number 0 itself.
			For Example:
			Given Linked List: 1-2-3-4-5-5-6
			First half: 1-2-3-4    
			Second half: 5-5-6
			Output Linked List: 1-7-9-0 = (1234 + 556 = 1790)
			Follow Up:
				Can you add both halves without finding the length of Linked List and in O(1) space?
			Constraints :
				0 <= N <= 10^5
				0 <= DATA <= 9 
				Where 'DATA' is the integer corresponding to the value of nodes of the given Linked List.
				Time Limit: 1 sec

			Sample Input 1:
			1 2 4 5 6 -1
			Sample Output 1:
			180
			Explanation for Sample Input 1:
			The first half of the given Linked List is 1-2-4.
			The second half of the given Linked List is 5-6.
			Sum of both parts = 124 + 56 = 180.
			Sample Input 2:
			3 9 0 1 1 0 -1
			Sample Output 2:
			500

		#include <bits/stdc++.h> 
		/****************************************************************
			Following is the class structure of the Node class:
			class Node {
				public:
					int data;
					Node *next;
				Node(int data){
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/
		Node *reverseIt(Node *t){
			Node *prev = NULL;
			Node *cur = t;

			while(cur){
				Node *upComing = cur -> next;
				cur -> next = prev;
				prev = cur;
				cur = upComing;
			}
			return prev;
		}

		Node* addFirstAndSecondHalf(Node *head){
			if(head == NULL or head-> next == NULL)
				return head;
			
			Node *first = head;
			Node *second = head -> next;

			// splitting done
			while(second && second -> next){
				first = first -> next;
				second = second -> next -> next;
			}

			second = first -> next;
			first -> next = NULL;               // detaching first half
			first = head;

			// length of first List is always little smaller than second one,
			// so will consider first one as our answer or head also can be a answer
			first = reverseIt(first);
			second = reverseIt(second);

			Node *temp = new Node(0);
			Node *ans = temp;
			int carry =0;
			while(first or second or carry){
				int val = carry;
				if(first != NULL)
					val += first->data,
					first = first -> next;
				
				
				if(second != NULL){
					val += second->data;
					second = second -> next;
				}

				Node* nn = new Node(val % 10);
				temp -> next = nn;

				carry = val / 10;
				temp = temp -> next;
			}

			ans = ans -> next;
			ans = reverseIt(ans);
			while(ans && ans -> next && ans -> data == 0)
				ans = ans -> next;

			return ans;
		}	

	1007) Add Two Numbers As Linked Lists ll:
		Problem statement
			You have been given two singly Linked Lists, where each of them represents a positive number without any leading zeros.
			Your task is to add these two numbers and print the summation in the form of a linked list.
			Example:
			If the first linked list is 1 -> 2 -> 3 -> 4 -> 5 -> NULL and the second linked list is 4 -> 5 -> NULL.
			The two numbers represented by these two lists are 12345 and 45, respectively. So, adding these two numbers gives 12390. 
			So, the linked list representation of this number is 1 -> 2 -> 3 -> 9 -> 0 -> NULL.
			Constraints:
			1 <= T <= 100
			1 <= L <= 5000
			0 <= data <= 9 and data != -1
			Where 'L' is the number of nodes in either of the two Linked List and 'data' is the element value in a node of the linked list.
			Time limit: 1 sec
			Sample Input 1 :
			2
			1 1 -1
			9 9 9 -1
			2 4 -1
			5 3 -1
			Sample Output 1:
			1 0 1 0 -1
			7 7 -1
			Explanation for Sample Output 1:
			In test case 1, we are adding 11 and 999 to get 1010.
			In test case 2, we are adding 24 and 53 to get 77.
			Sample Input 2:
			2
			3 8 1 2 9 -1
			9 8 2 9 -1
			1 9 0 -1
			8 1 0 -1
			Sample Output 2:
			4 7 9 5 8 -1
			1 0 0 0 -1
			Explanation for Sample Output 2:
			In test case 1, we are adding 38129 and 9829 to get 47958.
			In test case 2, we are adding 190 and 810 to get 1000.

		#include <bits/stdc++.h> 
		/************************************************************
			Following is the linked list node structure:
			template <typename T>
			class Node {
				public:
					T data;
					Node* next;
				Node(T data) {
					next = NULL;
					this->data = data;
				}
			};
		************************************************************/
		Node<int>* reverse(Node<int>* t){
			Node<int>* prev = NULL;
			Node<int>* cur = t;

			while(cur){
				Node<int>* up = cur -> next;
				cur -> next = prev;
				prev = cur;
				cur = up;
			}
			return prev;
		}

		Node<int>* addTwoLists(Node<int>* first, Node<int>* second) {
			first = reverse(first);
			second = reverse(second);
			Node<int>* temp = new Node(0);
			Node<int>* ans = temp;

			int carry =0;
			while(carry or first or second){
				int val = carry;

				if(first != NULL)
					val += first -> data, first = first -> next;
				
				if(second != NULL)
					val += second -> data, second = second -> next;

				Node<int>* nn = new Node(val % 10);
				carry = val /10;

				temp -> next = nn;
				temp = temp -> next;
			}
			
			ans = ans -> next;
			ans = reverse(ans);
			return ans;
		}

	1008) Minimum Number of Days to Make m Bouquets:
		Problem Statement:
			You are given an integer array bloomDay, an integer m and an integer k.
			You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.
			The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.
			Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.
			
			Example 1:
				Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
				Output: 3
				Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.
				We need 3 bouquets each should contain 1 flower.
				After day 1: [x, _, _, _, _]   // we can only make one bouquet.
				After day 2: [x, _, _, _, x]   // we can only make two bouquets.
				After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
			Example 2:
				Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
				Output: -1
				Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
			Example 3:
				Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
				Output: 12
				Explanation: We need 2 bouquets each should have 3 flowers.
				Here is the garden after the 7 and 12 days:
				After day 7: [x, x, x, x, _, x, x]
				We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
				After day 12: [x, x, x, x, x, x, x]
				It is obvious that we can make two bouquets in different ways.
			
			Constraints:
				bloomDay.length == n
				1 <= n <= 10^5
				1 <= bloomDay[i] <= 10^9
				1 <= m <= 10^6
				1 <= k <= n

		// Not Optimized:
			class Solution {
				public:
				bool allSet(vector<int> &v, int s, int e, int minSize){
					if(v.size() - s < minSize)
						return 0;
					
					for(int i=s; i<e; i++)
						if(v[i] == 0)
							return 0;
					return 1;
				}
				int minDays(vector<int>& bloomDay, int m, int k) {
					// for each bouquet we need k flowers, so for m bouquet we need m*k flowers
					// if array size is less than m*k return -1
					if(bloomDay.size() < m*k)
						return -1;
					
					set<int> s;
					for(int i: bloomDay)
						s.insert(i);

					auto itr = s.begin();

					int n = bloomDay.size();
					vector<int> v (n, 0);
					int MDs=0, cntsMade=0;

					while(cntsMade < m && itr != s.end()){
						cntsMade=0;
						MDs = *itr;

						for(int i=0; i<n; i++)
							if(bloomDay[i] <= MDs)
								v[i] = 1;

						// check how many adjucent bouquet can form.
						for(int z=0; z < n; ){
							if(allSet(v, z, z+k, k)){
								z += k;
								cntsMade++;
							}else{
								z++;
							}
						}
						itr++;
					}
					return MDs;
				}
			};
	
		// Optimized:
			class Solution {
				public:
				int PossibleBouquetCnt(vector<int>& bloomDay, int curDays, int minRequire){
					int ConsecutiveCnt=0, bouquetCnt=0;
					for(int i=0; i<bloomDay.size(); i++){
						if(bloomDay[i] <= curDays){
							ConsecutiveCnt++;
						}else{
							ConsecutiveCnt=0;
						}
						
						if(ConsecutiveCnt == minRequire){
							bouquetCnt++;
							ConsecutiveCnt=0;
						}
					}
					return bouquetCnt;
				}
				int minDays(vector<int>& bloomDay, int m, int k) {
					int n = bloomDay.size();
					int minDaysCnt=-1;

					int start_day = 1;
					int end_day   = *max_element(begin(bloomDay), end(bloomDay));

					while(start_day <= end_day){
						int mid = start_day + (end_day - start_day)/2;          // mid is acting as no.of days
						if(PossibleBouquetCnt(bloomDay, mid, k) >= m){
							end_day = mid - 1;
							minDaysCnt = mid;
						}else{
							start_day = mid + 1;
						}
					}
					return minDaysCnt;
				}
			};

	#CodeChef Starters-139:
		1009) Television Channels:
			Problem Statement:
				You have a television which had X working channels numbered 
				1,2,...,X. Unfortunately, due to a recent change, all even-numbered channels stopped working.
				For example if X=5, channels numbered 2 and 4 have stopped working, while channels numbered 
				1, 3 and 5 are still working.
				Given X, can you tell how many channels are still working?
				Input Format
				The first and only line of input contains a single integer 𝑋
				Output Format
				Output the number of working channels.
				Constraints
				1≤X≤100
				Sample 1:
				Input
				5
				Output
				3
				Explanation:
				As explained in the statement, channels 
				1, 3 and 5 are still working, but channels 
				2 and 4 are not. Thus, the answer is 3.

				Sample 2:
				Input
				100
				Output
				50
				Explanation:
				Channels 
				1, 3, 5, 7, ..., 99 are still working. Carefully counting them, we know there are exactly 50 working channels.
			#include <bits/stdc++.h>
			using namespace std;

			int main() {
				int X;
				std::cin >> X;
				(X&1) ? cout<<X/2 + 1 : cout<<X/2;
				return 0;
			}
		
		1010) Distribute Cookies:
			Problem Statement:
				Chef is making cookies for N kids. He wants to give everyone an equal number of cookies. He must give at least 1 cookie to each kid.
				Chef already has M cookies.
				He can destroy or make 1 cookie in 1 second.
				Find the minimum time after which he can evenly distribute the cookies between all kids.
				Input Format
				The first line of input will contain a single integer 𝑇, denoting the number of test cases.
				Each test case consists of a single line of input.The first and only line of each test case contains 𝑁 and 𝑀- the number of kids and the initial number of cookies.
				Output Format
				For each test case, output on a new line the minimum time such that Chef can evenly distribute all his cookies.

				Constraints
				1 ≤ T ≤ 10^4
				1 ≤ N, M ≤ 10^9
				
				Sample 1:
				Input
				4
				5 17
				5 18
				4 1
				2 18
				Output
				2
				2
				3
				0
				Explanation:
				Test Case 1 : Chef destroys 2 cookies to have 15 cookies total. This takes 2 seconds. Now, he can distribute all his cookies by giving every kid 3 cookies each.
				Test Case 2 : Chef makes 2 cookies to have 20 cookies total. This takes 2 seconds again. Now, he can distribute all his cookies by giving every kid 4 cookies each.
				Test Case 3 : Chef makes 3 more cookies to have 4 cookies total, and he gives 1 each to the 4 kids. Note that Chef can't destroy 1 cookie and then evenly distribute, as he needs to give everyone at least 1 cookie.

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int T;
				cin>>T;
				
				while(T--){
					int n,m;
					cin>>n>>m;
					
					if(m < n){
						cout<<(n-m)<<endl;
					}else{
						if(m == n){
							std::cout << 0 << std::endl;
						}else{
							int timeNeed = m % n;
							timeNeed = min(timeNeed, abs(timeNeed - n));
							std::cout << timeNeed << std::endl;
						}
					}
				}
				return 0;
			}

		1011) Maximum Distance Permutations:
			Problem Statement:
				Define the distance between 2 permutations† 𝐴 and 𝐵, each of length 𝑁, as the minimum value of ∣𝐴𝑖−𝐵𝑖∣‡ for 1 ≤ i ≤ N.
				Find a pair of permutations of length 𝑁 which have the maximum possible distance among all pairs of permutations of length 𝑁.	
				†A permutation of length 𝑁 is an array of 𝑁 distinct elements which are all in the range [1,N]. For example, [2,3,1,4] is a permutation of length 4 whereas 
				[2,4,3] and [1,1,2] are not.
				‡∣𝑋∣ denotes the absolute value of 𝑋. For example, ∣−5∣=∣5∣=5.
				Input Format
				The first line of input will contain a single integer 𝑇, denoting the number of test cases.
				Each test case consists of a single integer 𝑁 - the length of the permutations.
				Output Format
				For each test case, output 2 lines.
				The first line containing 𝑁 space-separated integers - 𝐴1, 𝐴2, 𝐴3, …, 𝐴𝑁, denoting the permutation 𝐴.
				The second line containing 𝑁 space-separated integers - 𝐵1, 𝐵2, 𝐵3, …, 𝐵𝑁, denoting the permutation 𝐵.
				The permutations 𝐴 and 𝐵 must have the maximum distance possible. If multiple answers are possible, all will be accepted.
				Constraints
					1≤T≤100
					1≤N≤100
				Sample 1:
				Input
				3
				1
				2
				3
				Output
				1
				1
				1 2
				2 1
				1 2 3
				3 1 2
				Explanation:
				Test case 1 : There is only one possible permutation of length 𝑁, and thus only one possible pair, which has distance 0.
				Test case 2 : The permutations [1,2] and [2,1] have a distance of 1. This can be shown to be the maximum possible distance.

			Hints:
				Observation Line 1
					the main observation is that we need to start the second array from middle. so that the absolute value is maximum lets take exaple of 1 to 10; the max diff is |1-5| only else we would get only more. so to obtain this we can start the 2nd array from middle of 1st array.
				Observation Line 1
					1 2 3 4 5 6 7 8 9 10
				Observation Line 1
					6 7 8 9 10 1 2 3 4 5

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int T;
				cin>>T;
				
				while(T--){		
					int n;
					cin>>n;
					vector<int> a(n), b(n);
					
					for(int i=0; i<n; i++)
						a[i] = i+1;
						
					int j=1;
					for(int i = (n/2); i<n; i++)
						b[i] = j++;
						
					for(int i=0; i< (n/2); i++)
						b[i] = j++;
					
					for(int x=0; x<n; x++)
						cout<<a[x]<<" ";
					cout<<endl;

					for(int x=0; x<n; x++)
						cout<<b[x]<<" ";
					cout<<endl;
				}
				return 0;
			}

	1012) Find MSB In O(1):
		Problem statement
			You are given a positive integer 'N'. Your task is to find the greatest integer less than or equal to 'N' which is a power of 2.
			For Example:
			If N = 14, then the nearest integer that is less than or equal to 14 and is a power of two is 8(2^3). So, the answer is 8.
			Follow Up:
			Can you solve this in constant time and space complexity?
			Constraints:
				1 <= T <= 2 * 10^3
				1 <= N <= 10^9
				Time Limit: 1 second
			Sample Input 1:
				2
				4
				22
				Sample Output 1:
				4
				16
				Explanation for sample 1:
				For the first test case, 4 itself is a power of two.
				For the second test case, the nearest integer that is less than or equal to 22 and also is a power of two is 16.
				Sample Input 2:
				2
				1
				63
				Sample Output 2:
				1
				32
				Explanation for sample 1:
				For the first test case, 1 itself is a power of two.
				For the second test case, the nearest integer that is less than or equal to 63 and also is a power of two is 32.

		#include <bits/stdc++.h> 
		int findMSB(int n){
			int mask = 1, ans;

			while(mask <= n){
				ans = mask;
				mask <<= 1;
			}
			return ans;
		}
	
	1013) Magnetic Force Between Two Balls:
		Problem Statement:
			In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.
			Rick stated that magnetic force between two different balls at positions x and y is |x - y|.
			Given the integer array position and the integer m. Return the required force.
			
			Example 1:
				Input: position = [1,2,3,4,7], m = 3
				Output: 3
				Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.
			Example 2:
				Input: position = [5,4,3,2,1,1000000000], m = 2
				Output: 999999999
				Explanation: We can use baskets 1 and 1000000000.
			
			Constraints:
				n == position.length
				2 <= n <= 10^5
				1 <= position[i] <= 10^9
				All integers in position are distinct.
				2 <= m <= position.length

		class Solution {
			public:
			bool ballsPlaced(vector<int>& pos, int force, int m) {
				int k=1;
				int prevPosition = 0;
				for(int i=1; i<pos.size(); i++){
					if(pos[i] - pos[prevPosition] >= force){
						k++;
						prevPosition = i;
					}

					if(k == m)
						break;
				}
				// return (k < m) ? 0 : 1;
				return k == m;
			}
			int maxDistance(vector<int>& position, int m) {
				sort(position.begin(), position.end());

				int startForce = 1, endForce = position[position.size()-1] - position[0];
				int res = 1;
				while(startForce <= endForce){
					int mid = startForce + (endForce - startForce)/2;

					if(ballsPlaced(position, mid, m)){
						res = mid;
						startForce = mid + 1;
					}else{
						endForce = mid - 1;
					}
				}
				return res;
			}
		};

	#CN WeeklyContest-131:
		1014) Odd Sum:
			Problem statement
				You are given an array 'A' of 'N' integers numbered from '0' to 'N - 1'.
				Return the maximum number of elements you can select from the array 'A' such that the sum of all the selected elements is odd or return '-1' if you can not select elements such that the sum of them is odd.
				Example:
					N = 3
					A = ['1', '5', '2']
					You can select '2' elements 'A[0]' and 'A[2]'. The sum of the selected elements is 'A[0] + A[2]' = '1 + 2' = '3' which is odd.
					It can be proved that you can not select more than '2' elements such that the sum of selected elements is odd for the given input.
					So, the answer for this case is '2'. 
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					1 <= 'A[i]' <= 10^5

					Time limit: 1 sec
				Sample input 1:
					2
					2
					1 7
					2
					4 10
					Sample output 1:
					1
					-1
					Explanation of sample input 1:
					For test case 1:
					You can select '1' element 'A[0]'. The sum of the selected elements is 'A[0]' = '1' which is odd.
					It can be proved that you can not select more than '1' elements such that the sum of selected elements is odd for the given input.
					So, the answer for this case is '1'. 
					
					For test case 2:
					It can be proved that you can not select elements such that the sum of them is odd.
					So, the answer for this case is '-1'. 
					Sample input 2:
					2
					4
					7 5 7 3
					4
					9 5 1 6
					Sample output 2:
					3
					4

			int maximumElements(int n, vector<int> &v) {
				int oddCnt=0, evenCnt=0;
				for(int i: v)
					if(i&1)
						oddCnt++;
					else
						evenCnt++;
					
				if(oddCnt == 0)
					return -1;
				
				// if(evenCnt == 0)
				//     if(oddCnt&1)
				//         return oddCnt;
				//     else
				//         return oddCnt - 1;
					
				return (oddCnt&1) ? oddCnt + evenCnt : (oddCnt-1) + evenCnt;
			}
		
		1015) Incremental Jumps:
			Problem statement
				You have a staircase with ‘N’ steps, numbered from ‘1’ to ‘N’, and you need to reach a specific target step ‘K’. To do this, you can start from any step and make incremental jumps.
				In this system, you begin with an initial jump length ‘X’ (‘X’ > 0), and each subsequent jump increases by ‘1’ (i.e., your jumps will be of the form ‘X’, ‘X + 1’, ‘X + 2’, and so on). Additionally you must make at least ‘2’ jumps. Determine if it is possible to reach ‘K’ by using at least ‘2’ incremental jumps.
				Your task is to tell whether it is possible to reach ‘K’ by using at least ‘2’ incremental jumps. Return ‘1’, if possible, otherwise return ‘0’.
				Example:
				‘N’ = 10
				‘K’ = 8

				Here, we can choose step ‘2’ as a starting position. Our path would look like: ‘2’ -> ‘3’ -> ‘5’ -> ‘8’.
				The transition from ‘2’ to ‘3’ took ‘1’ step, ‘3’ to ‘5’ took ‘2’ steps and ‘5’ to ‘8’ took ‘3’ steps. So, the total number of incremental jumps will be ‘3’.
				Hence, it is possible to reach ‘8’ by using at least ‘2’ incremental jumps.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^9
					1 <= 'K' <= 'N’

					Time Limit: 1 sec
				Sample Input 1:
					2
					6 6
					5 2
					Sample Output 1:
					1
					0
					Explanation of sample input 1:
					For test case 1:
					Here, we can choose ‘1’ as the starting position and our path would look like: ‘1’ -> ‘3’ -> ‘6’.
					The first jump is of the length ‘2’ and the second jump is of the length ‘3’. So, the answer for this test case is ‘1’.
					For test case 2:
					It is impossible to reach ‘2’ by using at least ‘2’ incremental jumps. So, the answer for this test case is ‘0’.
					Sample Input 2:
					2   
					8 3
					9 8
					Sample Output 2:
					0
					1

			int incrementalJumps (int n, int k) {
				if(k >= 6)
					return 1;
				return 0;
			}
		
		1016) Supercomputer:
			Problem statement
				There are ‘N’ people, each with a unique assigned number given to you in the array ‘A’. There's a supercomputer protected by a password, ‘K’. To gain access, three people can enter their numbers, and if the result of XOR on their numbers equals ‘K’, access is granted.
				Your task is to figure out how many different groups of three people can enter their numbers and successfully gain access to the supercomputer. A group of 1,2 and 3 is the same as the group 3,1 and 2 or any other ordering.
				Example:
				‘N’ = 4
				‘K’ = 2
				‘A’ = [6, 5, 1, 5] 
				Return 2
				There are 2 groups:
				Group 1: 1,2 and 3 as 6⊕5⊕1 = 2
				Group 2: 1,3 and 4 as 6⊕1⊕5 = 2
				Detailed explanation ( Input/output format, Notes, Images )
				Constraints:
				1 <= ‘T’ <= 10
				1 <= ‘N’ <= 10^3
				1 <= ‘K’, A[i] <= 10^6
				Time Limit: 1 sec
				Sample Input 1:
					2
					6 1
					5 6 5 2 1 7 
					7 5
					7 2 5 5 2 4 7 
					Sample Output 1:
					3
					4
					Explanation of sample input 1:
					For Test case 1:
					The 3 groups are:
						1, 2 and 4 as 5⊕6⊕2 = 1
						1, 3 and 5 as 5⊕5⊕1 = 1
						2, 3 and 4 as 6⊕5⊕2 = 1
					There don't exist any more groups.
					For Test case 2:
					The 4 groups are:
						1, 3 and 7 as 7⊕5⊕7 = 5
						1, 4 and 7 as 7⊕5⊕7 = 5
						2, 3 and 5 as 2⊕5⊕2 = 5
						2, 4 and 5 as 2⊕5⊕2 = 5
					There don't exist any more groups.
					Sample Input 2:
					3
					6 13
					2 2 8 7 7 9 
					6 0
					1 9 6 10 8 8 
					8 8
					10 3 3 9 1 10 5 8 
					Sample Output 2:
					4
					2

			// Not Optimized:
				void SubSequence(vector<int> &main, vector<int> temp, vector<vector<int>> &all, int index){
					if(index >= main.size()){
						all.push_back(temp);
						return;
					}
					SubSequence(main, temp, all, index+1);

					temp.push_back(main[index]);
					SubSequence(main, temp, all, index+1);
				}

				int solve(int n, int k, vector<int> &a){
					vector<vector<int>> all;
					
					vector<int> temp;
					SubSequence(a, temp, all, 0);

					int cnt=0;
					for(auto row: all){
						if(row.size() != 3)
							continue;
							
						int ans = 0;
						for(int i: row)
							ans ^= i;
						
						if(ans == k)
							cnt++;
					}
					return cnt;
				}
		
			// Optimized:
				❌Pending

		1017) Tricky Triplets:
			Problem statement
				You are given an array ‘A’ of ‘N’ integers numbered from ‘0’ to ‘N - 1’. A Triplet ‘(i, j, k)’ is said to be a Tricky Triplet if ‘i’ < ‘j’ < ‘k’ and all the prime factors of ‘A[i]’, ‘A[j]’, and ‘A[k]’ are the same.
				For example: The prime factors of ‘6’, ‘12’, and ‘18’ are the same.
				As ‘6’ = ‘(2 * 3)’, ‘12’ = ‘(2 * 2 * 3)’, and ‘18’ = ‘(2 * 3 * 3)’.
				The prime factors of all these numbers are: ‘2’, and ‘3’.
				The beautiness of a Tricky Triplet ‘(i, j, k)’ is given by: ‘GCD(A[i], A[j], A[k])’, where ‘GCD’ is the greatest common factor. You have to count the unique beautiness values of the Tricky Triplets.
				Your task is to tell the count of unique beautiness values of the Tricky Triplets and return it.
				Example:
				‘N’ = 6
				‘A’ = [2, 4, 8, 3, 9, 27]
				The Tricky Triplets of the given array are: ‘(0, 1, 2)’, and  ‘(3, 4, 5)’.

				Triplet 1 -  ‘(0, 1, 2)’:
				Here, ‘GCD(A[0], A[1], A[2])’ is ‘2’.

				Triplet 2 - ‘(3, 4, 5)’:
				Here, ‘GCD(A[3], A[4], A[5])’ is ‘3’.

				Hence, the count of unique beautiness values is ‘2’.
				Constraints:
					1 <= 'T' <= 10
					1 <= 'N' <= 10^5
					2 <= A[i] <= 10^5

					Time Limit: 1 sec 
				Sample Input 1:
				2
				4
				10 20 40 80
				3
				3 5 2
				Sample Output 1:
				2
				0
				Explanation of sample input 1:
				For test case 1:

				The tricky triplets of the given array are: ‘(0, 1, 2)’, ‘(0, 1, 3)’, ‘(0, 2, 3)’, and ‘(1, 2, 3)’.

				Triplet 1 - ‘(0, 1, 2)’:
				The ‘GCD(10, 20, 40)’ is ‘10’.

				Triplet 2 - ‘(0, 1, 3)’:
				The ‘GCD(10, 20, 80)’ is ‘10’.

				Triplet 3 - ‘(0, 2, 3)’:
				The ‘GCD(10, 40, 80)’ is ‘10’.

				Triplet 4 - ‘(1, 2, 3)’:
				The ‘GCD(20, 40, 80)’ is ‘20’.

				So, the count of unique beautiness values of the Tricky Triplets is ‘2’.

				Test case 2:
				Here, there is no Tricky Triplet. So, the count of unique beautiness values of the Tricky Triplets is ‘0’.
				Sample Input 2:
				2
				5
				2 4 8 16 32
				2
				3 5
				Sample Output 2:
				3
				0

			// Not Optimized:
				bool isPrime(int n){
					for(int i=2; i <= (n/2); i++)
						if(n % i == 0)
							return 0;	
					return 1;
				}

				void primeFactor (int n, set<int> &s,  int start) {
					if(n == 0) return;
					
					if(isPrime(n)){
						// this means the current n is prime so insert it
						s.insert(n);
						return ;
					}

					if(n % start == 0){
						s.insert(start);
						primeFactor(n/start, s, start);
					}else{
						start++;
						if(start > n/2)
							return;
						primeFactor(n, s, start);
					}    
				}

				long long trickyTriplets (int n, vector <int> &a) {
					set<int> s;
					
					for(int i=0; i < n-2; i++){
						for(int j=i+1; j < n-1; j++){
							for(int k=j+1; k < n; k++){
								set<int> s1, s2, s3;

								primeFactor(a[i], s1, 2);
								primeFactor(a[j], s2, 2);
								primeFactor(a[k], s3, 2);

								if(s1 == s2  && s2 == s3){
									int val = __gcd(a[i], __gcd(a[j], a[k]));
									s.insert(val);
								}
							}
						}
					}

					return s.size();
				}

			// Optimized:
				❌Pending
			
	1018) Grumpy Bookstore Owner:
		Problem Statement:
			There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.
			On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.
			When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.
			The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.
			Return the maximum number of customers that can be satisfied throughout the day.
		
			Example 1:
				Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
				Output: 16
				Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
				The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.
			Example 2:
				Input: customers = [1], grumpy = [0], minutes = 1
				Output: 1

			Constraints:
				n == customers.length == grumpy.length
				1 <= minutes <= n <= 2 * 10^4
				0 <= customers[i] <= 1000
				grumpy[i] is either 0 or 1.

		class Solution {
			public:
			int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
				int mxSatisfaction=0, n= grumpy.size();

				// if(n == minutes)
				//     return accumulate(customers.begin(), customers.end(), 0);

				// window Size is consecutive minutes
				for(int i=0; i <= (n-minutes); i++){
					int curSatisfaction=0;
					// elements before window
					int j;
					for(j=0; j<i; j++) {
						if(grumpy[j] == 0)
							curSatisfaction += customers[j];
					}

					// considering all elements within window
					int spent = minutes;
					while(spent--)
						curSatisfaction += customers[j++];

					// elements after window
					for(j; j<n; j++) {
						if(grumpy[j] == 0)
							curSatisfaction += customers[j];
					}
					mxSatisfaction = max(mxSatisfaction, curSatisfaction);
				}
				return mxSatisfaction; 
			}
		};
	
	1019) Binary Linked List To Integer:
		Problem statement
			You are given a singly linked list containing ‘n’ nodes, where every node in the linked list contains a pointer “next” which points to the next node in the list and having values either 0 or 1. Your task is to return the decimal representation of the given number in the linked list.
			For Example:
			n = 4, list: 1 -> 0 -> 1 -> 0.
			Now in this example, the value in the linked list is 1010, which is 10 in Decimal.
			Hence the answer is 10.
			Constraints :
				1 <= T <= 100
				1 <= N <= 3000
				Time Limit: 1sec
			Sample Input 1 :
				2
				3
				1 0 1 -1
				2
				1 1 -1   
				Sample Output 1 :
				5
				3
				Explanation For Sample Output 1 :
				In the first test case, there are two paths from 1 to 3. I.e. 1 -> 2 -> 3 or 1 -> 0 -> 3 and both these paths have no common track.
				Hence the answer is 0.
				In the second test case, there are two different paths from 1 to 0. i.e. , 1 -> 2 -> 3 -> 6 -> 0 and 1 -> 2 -> 4 -> 6 -> 0. Having two common tracks, 1 -> 2 and 6 -> 0.
				Hence the answer is 2.
				Sample Input 2 :
				2
				1
				1 -1
				3
				1 0 0 -1
				Sample Output 2 :
				1
				4

		/************************************************************
			Following is the linkedList class structure:
			class Node {
				public:
					int data;
					Node *next;
				Node(int val) {
					this->data = val;
					next = NULL;
				}
				~Node() {
					if (next != NULL) 
						delete next;
				}
			};
		************************************************************/
		#include<bits/stdc++.h>
		int binaryToInteger(int n, Node *head) {
			string s;
			while(head)
				s += to_string(head -> data), head = head -> next;
			return stoi(s, 0, 2);
		}

	1020) Duplicate Parenthesis:
		Problem statement
			You are given the expression ‘expr’ with parenthesis. Your task is to find if the given expression contains duplicate parenthesis. A set of parenthesis is duplicate if multiple parenthesis surrounds the same subexpression.
			For Example:
			You are given ‘expr’ = “(a+b)+((c+d))”, here the subexpression “c+d” is surrounded by two parentheses. Hence the expression contains duplicate parenthesis. Hence the answer is “YES”.
			Constraints:
				1 <= T <= 10
				1 <= |expr| <= 10^6
				Time Limit: 1 sec
			Note:
				You do not need to print anything. It has already been taken care of. Just implement the function.
				Sample Input 1:
				2
				(a+b)+((c+d))
				((a+b) + c)
				Sample Output 1:
				YES
				NO
				Explanation:
				For the first test case,  ‘expr’ = “(a+b)+((c+d))”, here, the subexpression “c+d” is surrounded by two parentheses. Hence the expression contains duplicate parenthesis. Hence the answer is “YES”.
				For the second test case, ‘expr’ = “((a+b) + c)”, here, no subexpression is surrounded by multiple parentheses. Hence the answer is “NO”.
				Sample Input 2:
				2
				(a+b)+((c+d))
				((a+b)+(c+d))
				Sample Output 2:
				YES
				NO

		#include <bits/stdc++.h> 
		bool duplicateParanthesis(string &expr) {
			stack<char> st;
			for(char ch: expr){
				if(ch == '(' or ch == '+' or isalpha(ch)){
					st.push(ch);
				}else if(ch == ')'){
					if(st.top() == '(')
						return 1;

					while(!st.empty() && st.top() != '(')
						st.pop();

					st.pop();
				}
			}
			return 0;
		}
	
	1021) Compare two fractions:
		Problem Statement:
			You are given a string str containing two fractions a/b and c/d, compare them and return the greater. If they are equal, then return "equal".
			Note: The string str contains "a/b, c/d"(fractions are separated by comma(,) & space( )). 
			Examples
				Input: str = "5/6, 11/45"
				Output: 5/6
				Explanation: 5/6=0.8333 and 11/45=0.2444, So 5/6 is greater fraction.

				Input: str = "8/1, 8/1"
				Output: equal
				Explanation: We can see that both the fractions are same, so we'll return a string "equal".
				Input: str = "10/17, 9/10"
				Output: 9/10
				Explanation: 10/17 = 0.588 & 9/10 = 0.9, so the greater fraction is "9/10".
	
			Expected Time Complexity: O(len|str|)
			Expected Auxiliary Space: O(1)

			Constraints:
				0 <= a,c <= 10^3
				1 <= b,d <= 10^3

		class Solution {
			public:
			string compareFrac(string s) {
				double a,b,c,d;
				a=b=c=d=0;
				
				int i=0;            // we will go till first '/'
				while(s[i] != '/')
					a = a*10 + s[i++] - '0';
				
				i++;
				while(s[i] != ',')             // will go till comma (,)
					b = b*10 + s[i++] - '0';
				
				i += 2;
				while(s[i] != '/')             // will go till '/'
					c = c*10 + s[i++] - '0';
					
				// till end
				i++;
				while(i < s.size())
					d = d*10 + s[i++] - '0';
					
				if(a/b == c/d)
					return "equal";
				else if(a/b > c/d)
					return to_string(static_cast<long long>(a)) + "/" + to_string(static_cast<long long>(b));   // converting double to long long
				return to_string(static_cast<long long>(c)) + "/" + to_string(static_cast<long long>(d));
			}
		};
		
		// or using long long
			#define ll long long
			class Solution {
				public:
				string compareFrac(string s) {
					ll a,b,c,d;
					a=b=c=d=0;
					
					int i=0;            // we will go till first '/'
					while(s[i] != '/')
						a = a*10 + s[i++] - '0';
					
					i++;
					while(s[i] != ',')             // will go till comma (,)
						b = b*10 + s[i++] - '0';
					
					i += 2;
					while(s[i] != '/')             // will go till '/'
						c = c*10 + s[i++] - '0';
						
					// till end
					i++;
					while(i < s.size())
						d = d*10 + s[i++] - '0';
						
					if((double)a/b == (double)c/d)
						return "equal";
					else if((double)a/b > (double)c/d)						// converting double
						return to_string(a) + "/" + to_string(b);   
					return to_string(c) + "/" + to_string(d);
				}
			};
	
	1022) Extract the Number from the String:
		Problem Statement:
			Given a sentence containing several words and numbers. Find the largest number among them which does not contain 9. If no such number exists, return -1.
			Examples :
				Input: sentence="This is alpha 5057 and 97"
				Output: 5057
				Explanation: 5057 is the only number that does
				not have a 9.
				Input: sentence="Another input 9007"
				Output: -1
				Explanation: Since there is no number that
				does not contain a 9,output is -1.

			Expected Time Complexity: O(n)
			Expected Auxillary Space: O(n)

			Constraints:
				1<=n<=10^6
				1<=answer<=10^18
			n is the length of a given sentence.
		
		#define ll long long
		class Solution {
			public:
			bool isContain9(ll s){
				string t = to_string(s);
				if(t.find('9') != string::npos)
					return 1;
				return 0;
			}
			long long ExtractNumber(string sentence) {
				istringstream ss(sentence);
				string s;
				
				vector<string> v;
				while(ss >> s)
					v.push_back(s);
				
				vector<ll> containsNums;
				for(int i=0; i<v.size(); i++){
					if(isalpha(v[i][0]))
						continue;
					containsNums.push_back(stoll(v[i]));
				}
				
				sort(containsNums.rbegin(), containsNums.rend());
				// for(ll tt: containsNums)
				//     cout<<tt<<"\t";
					
				ll ans=0;
				for(int i=0; i < containsNums.size(); i++)
					if(!isContain9(containsNums[i])){
						ans = containsNums[i];
						break;
					}

				return (ans == 0) ? -1 : ans;
			}
		};
	
	1023) Floor in BST:
		https://www.naukri.com/code360/problems/floor-from-bst_920457
		Problem Statement:
			You are given a BST (Binary search tree) with’ N’ number of nodes and a value ‘X’. Your task is to find the greatest value node of the BST which is smaller than or equal to ‘X’.
			Note :‘X’ is not smaller than the smallest node of BST .
			For example:
			In the above example, For the given BST  and X = 7, the greatest value node of the BST  which is smaller than or equal to  7 is 6.
			Constraints:
				1 <= T <= 5
				1 <= N <= 5 * 10 ^ 3
				1 <= nodeVal[i] <= 10 ^ 9

				Time Limit: 1 sec.
			Sample Input 1:
				2
				10 5 15 2 6 -1 -1 -1 -1 -1 -1
				7
				2 1 3 -1 -1 -1 -1
				2
				Sample Output 1:
				6
				2
				Explanation of Sample Input 1:
				In the first test case, the BST looks like as below:
				The greatest value node of the BST which is smaller than or equal to  7 is 6.
				In the second test case, the BST looks like as below:
				The greatest value node of the BST which is smaller than or equal to  2 is 2.
				Sample Input 2:
				2
				5 3 10 2 4 6 15 -1 -1 -1 -1 -1 -1 -1 -1
				15
				5 3 10 2 4 6 15 -1 -1 -1 -1 -1 -1 -1 -1
				8
				Sample Output 2:
				15
				6

				#include <bits/stdc++.h> 
		
		/************************************************************
			Following is the TreeNode class structure
			template <typename T>
			class TreeNode {
				public:
					T val;
					TreeNode<T> *left;
					TreeNode<T> *right;

				TreeNode(T val) {
					this->val = val;
					left = NULL;
					right = NULL;
				}
			};
		************************************************************/
		int floorInBST(TreeNode<int> * root, int X) {
			queue<TreeNode<int> *> q;
			q.push(root);

			int GreatestValLess_X = 0;
			while(!q.empty()){
				TreeNode<int> *t = q.front();
				q.pop();

				if((t -> val) <= X && GreatestValLess_X < (t -> val))
					GreatestValLess_X = t -> val;
				
				if(t -> left)
					q.push(t -> left);
				
				if(t -> right)
					q.push(t -> right);
			}
			return GreatestValLess_X;
		}

		// Using Concept of Binary Search Tree (BST) : leftValue < RootValue < rightValue
			int floorInBST(TreeNode<int> * root, int X) {
				int ans = 0;
				while(root){
					if(root -> val <= X)
						ans = max(ans, root -> val);
					
					if(root -> val > X)
						root = root -> left;
					else
						root = root -> right;
				}
				return ans;
			}

	1024) Count Number of Nice Subarrays:
		Problem Statement:
			Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.
			Return the number of nice sub-arrays.
			Example 1:
				Input: nums = [1,1,2,1,1], k = 3
				Output: 2
				Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
			Example 2:
				Input: nums = [2,4,6], k = 1
				Output: 0
				Explanation: There are no odd numbers in the array.
			Example 3:
				Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
				Output: 16
			
			Constraints:
				1 <= nums.length <= 50000
				1 <= nums[i] <= 10^5
				1 <= k <= nums.length
	
		// Not Optimized:
			class Solution {
				public:
				int numberOfSubarrays(vector<int>& nums, int k) {
					int mainCnt=0, n = nums.size();

					for(int i=0; i <= (n-k); i++){
						int curOddCnt=0;
						
						for(int j=i; j<n; j++){
							if(nums[j] & 1)
								curOddCnt++;
							
							if(curOddCnt == k)
								mainCnt++;
							
							if(curOddCnt > k)
								break;
						}
					}
					return mainCnt;
				}
			};

		// Optimized:
			-Using Map
			class Solution {
				public:
				int numberOfSubarrays(vector<int>& nums, int k) {
					map<int, int> FrOddCnt;
					FrOddCnt[0] = 1;

					int cnt=0, mainCnt=0;
					for(int i=0; i<nums.size(); i++){
						if(nums[i] & 1) cnt++;

						FrOddCnt[cnt]++;
						if(FrOddCnt.count(cnt - k))
							mainCnt += FrOddCnt[cnt-k];
					}
					return mainCnt;
				}
			};

			-Sliding Window Approach with SC: O(1)
				class Solution {
					public:
					int numberOfSubarrays(vector<int>& nums, int k) {
						int mainCnt=0, oddCnt=0, n = nums.size();
						int i,j, prevOddcnt=0;
						i=j=0;

						while(j < n){
							if(nums[j]&1){
								oddCnt++;
								prevOddcnt=0;
							}

							while(oddCnt == k){
								prevOddcnt++;
								if(nums[i]&1)
									oddCnt--;
								i++;
							}

							mainCnt += prevOddcnt;
							j++;
						}     
						return mainCnt;
					}
				};

	#AtCoder BeginnerContest-359:
		1025) Count Takahashi:
			Problem Statement
				You are given N strings.
				The i-th string Si ( 1 ≤ i ≤ N) is either Takahashi or Aoki.
				How many i are there such that Si is equal to Takahashi?
				Constraints
				1 ≤ N ≤ 100
				N is an integer.Each Si is Takahashi or Aoki. (1≤i≤N)
				Input
				The input is given from Standard Input in the following format:
				N
				S1
				S2			
				⋮
				SN
				Output
				Print the count of i such that Si is equal to Takahashi as an integer in a single line.
				Sample Input 1
				3
				Aoki
				Takahashi
				Takahashi
				Sample Output 1
				2

				S2 and S3 are equal to Takahashi, while S1 is not. Therefore, print 2.
				Sample Input 2
				2
				Aoki
				Aoki
				Sample Output 2
				0
				It is possible that no Si is equal to Takahashi.

				Sample Input 3
				20
				Aoki
				Takahashi
				Takahashi
				Aoki
				Aoki
				Aoki
				Aoki
				Takahashi
				Aoki
				Aoki
				Aoki
				Takahashi
				Takahashi
				Aoki
				Takahashi
				Aoki
				Aoki
				Aoki
				Aoki
				Takahashi
				Sample Output 3
				7

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int n;
				cin>>n;
				
				vector<string> v(n);
				while(n--)
					cin>>v[n];
				
				int cnt=0;
				for(int i=0; i<v.size(); i++)
					if(v[i] == "Takahashi")
						cnt++;
				
				std::cout << cnt << std::endl;
				return 0;
			}

		1026) Couples:
			Problem Statement
				There are 2N people standing in a row, and the person at the i-th position from the left is wearing clothes of color Ai.
				Here, the clothes have N colors from 1 to N, and exactly two people are wearing clothes of each color.
				Find how many of the integers i=1,2,…,N satisfy the following condition:
				There is exactly one person between the two people wearing clothes of color i.
				Constraints
				2 ≤ N ≤ 100
				1 ≤ Ai ≤ N
				Each integer from 1 through N appears exactly twice in A.
				All input values are integers.
				Input
				The input is given from Standard Input in the following format:
				N
				A1 A2 … A(2n).
				
				Output
					Print the answer.
				Sample Input 1
				3
				1 2 1 3 2 3
				Sample Output 1
				2
				There are two values of i that satisfy the condition: 1 and 3.
				In fact, the people wearing clothes of color 1 are at the 1st and 3rd positions from the left, with exactly one person in between.
				Sample Input 2
				2
				1 1 2 2
				Sample Output 2
				0
				There may be no i that satisfies the condition.
				Sample Input 3
				4
				4 3 2 3 2 1 4 1
				Sample Output 3
				3

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int n;
				cin>>n;
				
				vector<int> A(2*n);
				for(int i=0; i<2*n; i++)
					cin>>A[i];
					
				int cnt=0;
				for(int i=0; i<(2*n-2); i++)            // skipping last 2 elements of array
					if(A[i] == A[i+2])
						cnt++;
				
				cout<<cnt<<endl;
				return 0;
			}
		
	#LeetCode BiweeklyContest-133:
		1027) Find Minimum Operations to Make All Elements Divisible by Three:
			Problem Statement:
				You are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.
				Return the minimum number of operations to make all elements of nums divisible by 3.			
				Example 1:
				Input: nums = [1,2,3,4]
				Output: 3
				Explanation:
				All array elements can be made divisible by 3 using 3 operations:
				Subtract 1 from 1.
				Add 1 to 2.
				Subtract 1 from 4.

				Example 2:
				Input: nums = [3,6,9]
				Output: 0
				
				Constraints:
					1 <= nums.length <= 50
					1 <= nums[i] <= 50

			class Solution {
				public:
				int minimumOperations(vector<int>& nums) {
					int OpsCnt=0, n=nums.size();
					
					for(int i=0; i<n; i++)
						if(nums[i] % 3 != 0)
							OpsCnt++;
					
					return OpsCnt;
				}
			};
		
		1028) Minimum Operations to Make Binary Array Elements Equal to One I:
			Problem Statement:
				You are given a binary array nums.
				You can do the following operation on the array any number of times (possibly zero):
				Choose any 3 consecutive elements from the array and flip all of them.
				Flipping an element means changing its value from 0 to 1, and from 1 to 0.
				Return the minimum number of operations required to make all elements in nums equal to 1. If it is impossible, return -1.		

				Example 1:
				Input: nums = [0,1,1,1,0,0]
				Output: 3
				Explanation:
				We can do the following operations:
				Choose the elements at indices 0, 1 and 2. The resulting array is nums = [1,0,0,1,0,0].
				Choose the elements at indices 1, 2 and 3. The resulting array is nums = [1,1,1,0,0,0].
				Choose the elements at indices 3, 4 and 5. The resulting array is nums = [1,1,1,1,1,1].

				Example 2:
				Input: nums = [0,1,1,1]
				Output: -1

				Explanation:
					It is impossible to make all elements equal to 1.

				Constraints:
					3 <= nums.length <= 10^5
					0 <= nums[i] <= 1

			class Solution {
				public:
				int minOperations(vector<int>& nums) {
					int cnt=0, n = nums.size();
					
					for(int i=0; i<n; i++){
						if(nums[i] == 0){
							if(i+2 < n){                    
								cnt++;
								nums[i] = nums[i] ? 0 : 1;
								nums[i+1] = nums[i+1] ? 0 : 1;
								nums[i+2] = nums[i+2] ? 0 : 1;
							}else{
								return -1;
							}
						}
					}
					return cnt;
				}
			};
		
		1029) Minimum Operations to Make Binary Array Elements Equal to One II:
			Problem Statement:
				You are given a binary array nums.
				You can do the following operation on the array any number of times (possibly zero):
				Choose any index i from the array and flip all the elements from index i to the end of the array.
				Flipping an element means changing its value from 0 to 1, and from 1 to 0.
				Return the minimum number of operations required to make all elements in nums equal to 1.			

				Example 1:
					Input: nums = [0,1,1,0,1]
					Output: 4
					Explanation:
					We can do the following operations:
					Choose the index i = 1. The resulting array will be nums = [0,0,0,1,0].
					Choose the index i = 0. The resulting array will be nums = [1,1,1,0,1].
					Choose the index i = 4. The resulting array will be nums = [1,1,1,0,0].
					Choose the index i = 3. The resulting array will be nums = [1,1,1,1,1].

				Example 2:
					Input: nums = [1,0,0,0]
					Output: 1
					Explanation:
					We can do the following operation:
					Choose the index i = 1. The resulting array will be nums = [1,1,1,1].

				Constraints:
					1 <= nums.length <= 10^5
					0 <= nums[i] <= 1

			// Not Optimized:
				class Solution {
					public:
					int minOperations(vector<int>& nums) {
						int OpsCnt=0, n = nums.size();

						for(int i=0; i<n; i++){
							if(nums[i] == 0){
								OpsCnt++;
								for(int j=i; j<n; j++)
									nums[j] = nums[j] ? 0 : 1;
							}
						}
						return OpsCnt;
					}
				};

			// Optimized:
				class Solution {
					public:
					int minOperations(vector<int>& nums) {
						int OpsCnt=0, n = nums.size();
						int flag=0;
						for(int i=0; i<n; i++){
							if(flag == nums[i]){
								OpsCnt++;
								flag = flag ? 0 : 1;
							}
						}
						return OpsCnt;
					}
				};
		
		1030) Count the Number of Inversions:
			https://leetcode.com/problems/count-the-number-of-inversions/description/
			❌Pending

	#LeetCode WeeklyContest-403:
		1031) Minimum Average of Smallest and Largest Elements:
			Problem Statement:
				You have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even.
				You repeat the following procedure n / 2 times:
					Remove the smallest element, minElement, and the largest element maxElement, from nums.
					Add (minElement + maxElement) / 2 to averages.
				Return the minimum element in averages.		

				Example 1:
				Input: nums = [7,8,3,4,15,13,4,1]
				Output: 5.5
				Explanation:
				step		nums					averages
				0		[7,8,3,4,15,13,4,1]		[]
				1		[7,8,3,4,13,4]			[8]
				2		[7,8,4,4]				[8,8]
				3		[7,4]				[8,8,6]
				4		[]					[8,8,6,5.5]
				The smallest element of averages, 5.5, is returned.
				
				Example 2:
				Input: nums = [1,9,8,3,10,5]
				Output: 5.5
				Explanation:
				step		   nums					averages
				0		[1,9,8,3,10,5]			[]
				1		[9,8,3,5]				[5.5]
				2		[8,5]				[5.5,6]
				3		[]					[5.5,6,6.5]

				Example 3:
				Input: nums = [1,2,3,7,8,9]
				Output: 5.0
				Explanation:
				step 	nums				averages
				0	  [1,2,3,7,8,9]			[]
				1	  [2,3,7,8]				[5]
				2	  [3,7]					[5,5]
				3	  []						[5,5,5]
				

				Constraints:
					2 <= n == nums.length <= 50
					n is even.
					1 <= nums[i] <= 50
			
			class Solution {
				public:
				double minimumAverage(vector<int>& nums) {
					vector<double> ans;
					sort(nums.begin(), nums.end());
					
					while(nums.size()){
						double curVal = (nums[0] + nums[nums.size()-1]) / 2.0;
						nums.erase(nums.begin());
						nums.pop_back();
						ans.push_back(curVal);
					}
					
					return *min_element(ans.begin(), ans.end());
				}
			};

		1032) Find the Minimum Area to Cover All Ones I:
			Problem Statement:
				You are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle.
				Return the minimum possible area of the rectangle.
			
				Example 1:
				Input: grid = [[0,1,0],[1,0,1]]
				Output: 6
				Explanation:
				The smallest rectangle has a height of 2 and a width of 3, so it has an area of 2 * 3 = 6.

				Example 2:
				Input: grid = [[0,0],[1,0]]
				Output: 1
				Explanation:
				The smallest rectangle has both height and width 1, so its area is 1 * 1 = 1.
			
				Constraints:
					1 <= grid.length, grid[i].length <= 1000
					grid[i][j] is either 0 or 1.
					The input is generated such that there is at least one 1 in grid.

			class Solution {
				public:
				int minimumArea(vector<vector<int>>& grid) {
					int mxHeight, mxWidth, mnHeight, mnWidth;
					int row = grid.size(), col = grid[0].size();
					
					mxHeight = mxWidth = 0;
					mnHeight = mnWidth = INT_MAX;
					
					for(int i=0; i<row; i++){
						for(int j=0; j<col; j++){
							if(grid[i][j] == 1){
								mxHeight = max(mxHeight, i);
								mnHeight = min(mnHeight, i);
								
								mxWidth = max(mxWidth, j);
								mnWidth = min(mnWidth, j);
								
							}
						}
					}
					
					int width = mxWidth - mnWidth + 1;
					int height = mxHeight - mnHeight + 1;
					return width * height;
				}
			};

	#GFG Weekly-160:
		1033) Find Mode in BST
			Problem Statement:
				Given the root of a Binary Search Tree. The task is to find the MODE of the given BST.
				NOTE: Mode is the value of the node which has the minimum value in the Binary Search Tree.
				Example 1:
				Input:
						5
					/    \
					4      6
					/        \
				3          7
				/
				1
				Output: 1
				Explanation: 1 is the minimum among 5,4,6,3,7 and 1

				Example 2:
				Input:
						9
						\
						10
						\
							11
				Output: 9
				Explanation: 9 is the minimum among 9,10 and 11

				Your Task:
					The task is to complete the function getMode() which takes root of BST as argument and returns the minimum element of Binary Search Tree. If the tree is empty, there is no minimum element, so return -1 in that case.
					
				Constraints:
					0 <= nodes in binary tree <= 10^4
					1 <= node.data <= 10^5

			// Using Level Order Traversal:
				class Solution {
					public:
					int getMode(Node* root) {
						if(root == NULL)
							return -1;
						int minAns = root -> data;
						
						queue<Node*> q;
						q.push(root);
						
						while(!q.empty()){
							Node* cur = q.front();
							q.pop();
							
							if(cur -> data < minAns)
								minAns = cur -> data;
							
							if(cur ->left)
								q.push(cur -> left);
							
							if(cur -> right)
								q.push(cur -> right);
						}
						return minAns;
					}
				};

			// Using Concept of BST (Binary Search Tree, ie. leftValue < RootValue < rightValue)
				class Solution {
					public:
					int getMode(Node* root) {
						if(root == NULL)
							return -1;
							
						int minAns = root -> data;
						while(root){
							minAns = min(minAns, root -> data);
							root = root -> left;
						}
						return minAns;
					}
				};
		
		1034) Geek Count:
			Problem Statement:
				You are given a string s of lowercase letters. You have to count how many times "geek" is present in string s as a subsequence.
				Note : The answer can be large so return the ans modulo 10^9 + 7
				Example 1:
				Input:
				s = geeks
				Output:
				1
				Explanation:
				In the string "geeks", "geek" appears as a subsequence exactly once. The characters at indices 0, 1, 2, and 3 form "geek".

				Example 2:
				Input:
				s = geeksforgeeks
				Output:
				8
				Explanation:
				In the string "geeksforgeeks", there are 8 different ways to form "geek" as a subsequence. These ways correspond to picking characters from the following sets of indices:
				0,1,2,3
				0,1,2,11
				0,1,9,11
				0,1,10,11
				0,2,9,11
				0,2,10,11
				0,9,10,11
				8,9,10,11

				Your Task:
					You have to complete the function geekCount( ) , which takes a string s as input parameter and return the count of  "geek" in s as a subsequence , with modulo 10^9 + 7 . 

				Constraints:
					1 <= length(s) <= 10^5
					s consists of lowercase latin alphabets
	
			// Not Optimized:
				class Solution {
					public:
					void GenerateSubSequence(string &s, string t, vector<string> &v, int i){
						if(i >= s.size()){
							v.push_back(t);
							return ;
						}
						
						GenerateSubSequence(s, t, v, i+1);
						
						t += s[i];
						GenerateSubSequence(s, t, v, i+1);
					}
					
					int geekCount(string s) {
						int mod = 1e9+7;
						
						vector<string> hold;
						string temp;
						GenerateSubSequence(s, temp, hold, 0);
						long cnt=0;
						
						for(string str: hold)
							if(str == "geek"){
								cnt++;
								cnt %= mod;
							}
						
						return cnt % mod;
					}
				};
				
	1035) Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit:
		Problem Statement:
			Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.
			Example 1:
				Input: nums = [8,2,4,7], limit = 4
				Output: 2 
				Explanation: All subarrays are: 
				[8] with maximum absolute diff |8-8| = 0 <= 4.
				[8,2] with maximum absolute diff |8-2| = 6 > 4. 
				[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
				[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
				[2] with maximum absolute diff |2-2| = 0 <= 4.
				[2,4] with maximum absolute diff |2-4| = 2 <= 4.
				[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
				[4] with maximum absolute diff |4-4| = 0 <= 4.
				[4,7] with maximum absolute diff |4-7| = 3 <= 4.
				[7] with maximum absolute diff |7-7| = 0 <= 4. 
				Therefore, the size of the longest subarray is 2.

			Example 2:
				Input: nums = [10,1,2,4,7,2], limit = 5
				Output: 4 
				Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.

			Example 3:
				Input: nums = [4,2,2,2,4,4,2,2], limit = 0
				Output: 3

			Constraints:
				1 <= nums.length <= 10^5
				1 <= nums[i] <= 10^9
				0 <= limit <= 10^9

		// Not Optimized:
			class Solution {
				public:
				int longestSubarray(vector<int>& nums, int limit) {
					int mxSize=1, n = nums.size();

					for(int i=0; i<n; i++){
						vector<int> v {nums[i]};

						for(int j=i+1; j<n; j++){
							int flag=1;

							for(int z=0; z<v.size(); z++){
								if(abs(v[z] - nums[j]) > limit){
									flag =0;
									break;
								}
							}

							if(flag){
								v.push_back(nums[j]);
								mxSize = max(mxSize, (int)v.size());
							}else{
								break;
							}
						}
					}
					return mxSize;
				}
			};
	
		// Optimized:
			// Reference:
				priority_queue<int> pq 		// this is a max heap, stores integer	(max element at top)
				priority_queue<int, vector<int>> pq 	// this is also a max heap, stores integer

				priority_queue<int, greater<int>> pq 	// this is a min heap, stores integer
				priority_queue<int, vector<int>, greater<int>> pq 	// this is also a min heap, stores integer

			/* Using Priority queue (heap)  TC: O(n log(n)) SC: O(n) */
			#define P pair<int, int>
			// typedef pair<int, int> P;           // either use typedef or #define to rename any data type
			class Solution {
				public:
				int longestSubarray(vector<int>& nums, int limit) {
					int n = nums.size();
					priority_queue<P, vector<P>> maxPq;                  // max heap
					priority_queue<P, vector<P>, greater<P>> minPq;                  // min heap
					
					int i,j,maxLength;
					i = j = maxLength = 0;

					while(j < n){
						maxPq.push({nums[j], j});
						minPq.push({nums[j], j});

						while(maxPq.top().first - minPq.top().first > limit){
							i = min(maxPq.top().second, minPq.top().second) + 1;

							while(maxPq.top().second < i)
							maxPq.pop();
							
							while(minPq.top().second < i)
							minPq.pop();
						}
						maxLength = max(maxLength, j-i+1);
						j++;
					}
					return maxLength;
				}
			};

		// Using Multiset:
			class Solution {
				public:
				int longestSubarray(vector<int>& nums, int limit) {
					multiset<int> mst;
					
					int n = nums.size();
					int i,j,mxSize;
					i = j = mxSize = 0;

					while(j < n){
						mst.insert(nums[j]);

						while(*mst.rbegin() - *mst.begin() > limit) {                // max_element - min_element  > limit
							mst.erase(mst.find(nums[i]));
							i++;
						}

						mxSize = max(mxSize, j-i+1);
						j++;
					}
					return mxSize;        
				}
			};

	1036) Print Bracket Number:
		Problem Statement:
			Given a string str, the task is to find the bracket numbers, i.e., for each bracket in str, return i if the bracket is the ith opening or closing bracket to appear in the string. 
			Examples:
				Input:  str = "(aa(bdc))p(dee)"
				Output: 1 2 2 1 3 3
				Explanation: The highlighted brackets in
				the given string (aa(bdc))p(dee) are
				assigned the numbers as: 1 2 2 1 3 3.
				Input:  str = "(((()("
				Output: 1 2 3 4 4 5
				Explanation: The highlighted brackets in
				the given string (((()( are assigned
				the numbers as: 1 2 3 4 4 5

			Expected Time Complexity: O(|str|)
			Expected Auxiliary Space: O(|str|)

			Constraints:
				1 <= |str| <= 10^5
				str contains lowercase English alphabets, and '(', ')' characters
				At any index, the number of opening brackets is greater than or equal to closing brackets

		class Solution {
			public:
			vector<int> bracketNumbers(string str) {
				int cnt=0;
				stack<int> st;
				vector<int> v;
				for(char ch: str){
					if(ch == '('){
						cnt++;
						st.push(cnt);
						v.push_back(st.top());
						// v.push_back(cnt);
					}else if(ch == ')'){
						v.push_back(st.top());
						st.pop();
					}
				}
				return v;
			}
		};
	
	1037) Left View Of Binary Tree:
		https://www.naukri.com/code360/problems/left-view-of-binary-tree_625707
		Problem statement
			You have been given a Binary Tree of 'n' nodes, where the nodes have integer values
			Print the left view of the binary tree.
			Example :
			If the input tree is as depicted in the picture: 
			The Left View of the tree will be:  2 35 2 
			Sample Input 1 :
			2 35 10 2 3 5 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
			Sample Output 1 :
			2 35 2
			Explanation of Sample Input 1 :
			The test case is explained in the problem statement.
			Sample Input 2 :
			1 2 3 4 5 -1 7 -1 -1 -1 -1 -1 -1 
			Sample Output 2 :
			1 2 4
			Explanation of Sample Input 2 :
			The Tree looks as follows:
					  1
					/   \
				    2     3
				  /   \     \
				 4     5     7
			Expected time complexity:
				The expected time complexity is O(n).
			Constraints :
				0 <= 'n' <= 10^5
				1 <= 'data' <= 10^5
				Where ‘n’ is the total number of nodes in the binary tree, and 'data' is the value of the binary tree node.
				Time limit: 1sec

		vector<int> printLeftView(BinaryTreeNode<int>* root) {
			if(root == nullptr)
				return {};              // empty vector

			vector<int> ans;
			queue<BinaryTreeNode<int>* > q;
			q.push(root);
			q.push(nullptr);

			int lastVal, once;
			while(!q.empty()){
				BinaryTreeNode<int> * t = q.front();
				q.pop();
				
				if(t == nullptr){
					ans.push_back(lastVal);
					once = 1;                       // flag to keep the track of we left side elements to be inserted into ans vector
					if(!q.empty())
						q.push(nullptr);
				}else{
					if(once){
						once =0;
						lastVal = t -> data;
					}
					if(t -> left)
						q.push(t -> left);
					
					if(t -> right)
						q.push(t -> right);
				}
			}
			return ans;
		}

	1038) Minimum Number of K Consecutive Bit Flips:
		Problem Statement:
			You are given a binary array nums and an integer k.
			A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
			Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.
			A subarray is a contiguous part of an array.
		
			Example 1:
				Input: nums = [0,1,0], k = 1
				Output: 2
				Explanation: Flip nums[0], then flip nums[2].
			Example 2:
				Input: nums = [1,1,0], k = 2
				Output: -1
				Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].
			Example 3:
				Input: nums = [0,0,0,1,0,1,1,0], k = 3
				Output: 3
				Explanation: 
				Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
				Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
				Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]
			Constraints:
				1 <= nums.length <= 10^5
				1 <= k <= nums.length

		// Not Optimized:
			class Solution {
				public:
				int minKBitFlips(vector<int>& nums, int k) {
					int OpsCnt=0;
					int n = nums.size();
					for(int i=0; i<n; i++){
						if(nums[i] == 1) continue;
						
						if(nums[i] == 0 && i+k <= n){
							for(int z=i; z<i+k; z++)
								nums[z] = nums[z] ? 0 : 1;

							OpsCnt++;
						}else{
							return -1;
						}
					}
					return OpsCnt;
				}
			};

		// Optimized:
			Reference:
				flipCnt is odd 		--------------------> nums[i] is 0				(no need to flip, automatically flipped)
					(flipCnt % 2 == 1)		  \------------------> nums[i] is 1 			(need to flip)
				
				flipCnt is even 		--------------------> nums[i] is 0				(need to flip)
					(flipCnt % 2 == 0)		  \------------------> nums[i] is 1 			(no need to flip, automatically flipped)

				ie. if (flipCnt % 2 == nums[i])	then need to flip
			class Solution {
				public:
				int minKBitFlips(vector<int>& nums, int k) {
					int n = nums.size();
					int flips=0;
					int flipCntFromPasForI=0;
					vector<bool> isFlipped(n, false);

					for(int i=0; i<n; i++) {
						if(i >= k && isFlipped[i-k] == true)
							flipCntFromPasForI--;
						
						if(flipCntFromPasForI % 2 == nums[i]){
							if(i + k > n){
								return -1;
							}
							isFlipped[i] = true;
							flipCntFromPasForI++;
							flips++;
						}
					}
					return flips;
				}
			};
			
			// Without using extra space
				class Solution {
					public:
					int minKBitFlips(vector<int>& nums, int k) {
						int n = nums.size();
						int cnt=0;
						int pastFlipOnI=0;

						for(int i=0; i<n; i++){
							if(i >= k and nums[i-k] == 5)
								pastFlipOnI--;
							
							if(pastFlipOnI % 2 == nums[i]){
								if(i+k > n )
									return -1;

								cnt++;
								pastFlipOnI++;
								nums[i] = 5;                // you can keep any value just to know, if 5 means we flipped value at that index.
							}
						}
						return cnt;   
					}
				};

	1039) Summed Matrix:
		Problem Statement:
			A matrix is constructed of size n*n and given an integer ‘q’. The value at every cell of the matrix is given as, M(i,j) = i+j, where ‘M(i,j)' is the value of a cell, ‘i’ is the row number, and ‘j’ is the column number. Return the number of cells having value ‘q’.
			Note: Assume, the array is in 1-based indexing.

			Examples:
				Input: n = 4, q = 7
				Output: 2
				Explanation: Matrix becomes
				2 3 4 5 
				3 4 5 6 
				4 5 6 7
				5 6 7 8
				The count of 7 is 2.
				Input: n = 5, q = 4
				Output: 3
				Explanation: Matrix becomes
				2 3 4 5 6 
				3 4 5 6 7 
				4 5 6 7 8 
				5 6 7 8 9 
				6 7 8 9 10 
				The count of 4 is 3.

			Expected Time Complexity: O(1)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ n,q ≤ 10^18

		// Optimized:
			class Solution {
				public:
				long long sumMatrix(long long n, long long q) {
					if(q == n+1)
						return n;
					else if(q < (n+1)){
						return q-1;
					}else{
						if(q > (n*2))
							return 0;
						
						long long val = q - (n+1);
						return n - val;
					}
				}
			};

		// Not Optimized: (Pure Brute force)
			class Solution {
				public:
				typedef long long ll;
				long long sumMatrix(long long n, long long q) {
					// generating matrix
					vector<vector<ll>> hold;
					long long x=2, col=n, r = n;
					while(r--){
						vector<ll> row;
						ll t = x++;
						col = n;
						
						while(col--)
							row.push_back(t++);
						hold.push_back(row);   
					}
					
					
					ll cnt=0;
					n = hold.size();
					for(ll i=0; i<n; i++)
						for(ll j=0; j<n; j++)
							if(hold[i][j] == q)
								cnt++;
					
					return cnt;
				}
			};	

	1040) Left Rotate Matrix K times:
		Problem Statement:
			You are given an integer k and matrix mat. Rotate the elements of the given matrix to the left k times and return the resulting matrix.
			Examples:
				Input: k=1, mat=[[1,2,3],[4,5,6],[7,8,9]]
				Output:
				2 3 1
				5 6 4
				8 9 7
				Explanation: Rotate the matrix by one
				1 2 3       2 3 1
				4 5 6  =>  5 6 4
				7 8 9       8 9 7
			Input: k=2, mat=[[1,2,3],[4,5,6],[7,8,9]]
				Output:
				3 1 2
				6 4 5
				9 7 8
				Explanation: After rotating the matrix looks like
				1 2 3       2 3 1       3 1 2
				4 5 6  =>  5 6 4  =>   6 4 5
				7 8 9       8 9 7       9 7 8

			Expected Time Complexity: O(n*m)
			Expected Auxillary Space: O(n*m)

			Constraints:
				1<= mat.size, mat[0].size, mat[i][j] <=1000
				1<=k<=10000

		class Solution {
			public:
			vector<vector<int>> rotateMatrix(int k, vector<vector<int>> mat) {
				// if(k >= mat[0].size())
				k %= mat[0].size();
				
				for(auto &row: mat)
					rotate(row.begin(), row.begin()+k, row.end());
					
				return mat;
			}
		};

		// Without using Rotate function:
			class Solution {
				public:
				vector<vector<int>> rotateMatrix(int k, vector<vector<int>> mat) {
					// if(k >= mat[0].size())
					int col = mat[0].size();
					k %= col;
					
					for(auto &row: mat){
						vector<int> cur = row;
						int j=0;
						for(int i=k; i<col; i++)
							row[j++] = cur[i];
						
						for(int i=0; i<k; i++)
							row[j++] = cur[i];
					}
					return mat;
				}
			};

	1041) Count Number of Bad Pairs:
		Problem Statement:
			You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].
			Return the total number of bad pairs in nums.		
			Example 1:
				Input: nums = [4,1,3,3]
				Output: 5
				Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
				The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
				The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
				The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
				The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
				There are a total of 5 bad pairs, so we return 5.
			Example 2:
				Input: nums = [1,2,3,4,5]
				Output: 0
				Explanation: There are no bad pairs.
			
			Constraints:
				1 <= nums.length <= 10^5
				1 <= nums[i] <= 10^9

		// Not Optimized:
			class Solution {
				public:
				long long countBadPairs(vector<int>& nums) {
					long long cnt=0;

					for(int i=0; i<nums.size()-1; i++){
						for(int j=i; j<nums.size(); j++){
							if(j-i != nums[j]-nums[i])
								cnt++;
						}            
					}
					return cnt;
				}
			};

		// Optimized:
			❌Pending	
	
	1042) Coverage of all Zeros in a Binary Matrix:
		Problem Statement:
			Given a binary matrix contains 0s and 1s only, we need to find the sum of coverage of all zeros of the matrix where coverage for a particular 0 is defined as a total number of ones around a zero in left, right, up and bottom directions.
			Examples:
			Input:
			matrix = [[0, 1, 0],
					[0, 1, 1],
					[0, 0, 0]]
			Output: 6
			Explanation: There are a total of 6 coverage are there

			Input: 
			matrix = [[0, 1]]
			Output: 1
			Explanation: There are only 1 coverage.
			
			Expected Time Complexity: O(n * m)
			Expected Space Complexity: O(1)

			Constraints:
				1 <= matrix.size, matrix[0].size <= 100

		class Solution {
			public:
			bool isValidPoints(int a, int b, int r, int c, vector<vector<int>>& m){
				if((a >= 0 && a < r) && (b >=0 && b < c) && m[a][b] == 1)
					return 1;
				return 0;
			}
			int findCoverage(vector<vector<int>>& matrix) {
				int cnt=0;
				int r = matrix.size(), c = matrix[0].size();
				
				for(int i=0; i<r; i++){
					for(int j=0; j<c; j++){
						if(matrix[i][j] == 0){
							// check all 4 sides
							if(isValidPoints(i,j-1, r, c, matrix))
							cnt++;
							
							if(isValidPoints(i,j+1, r, c, matrix))
							cnt++;
							
							if(isValidPoints(i-1,j, r, c, matrix))
							cnt++;
							
							if(isValidPoints(i+1,j, r, c, matrix))
							cnt++;
						}
					}
				}
				return cnt;
			}
		};

	#CodeChef Starters-140
		1043) Yoga Day:
			Problem Statement:
				Surya Namaskar, also known as Sun Salutation, is a series of 12 yoga poses performed in a sequence.
				Chef repeats this sequence of yoga poses multiple times during his session.
				Given that Chef has performed 𝑁 yoga poses, find the number of rounds of Surya Namaskar he completed during the session.
				Input Format
				The input will contain a single integer 𝑁 denoting the number of yoga poses Chef performed during his session.
				Output Format
				Output the number of rounds of Surya Namaskar Chef completed during the session.
				Constraints
				1≤N≤100
				Sample 1:
				Input
				55
				Output
				4
				Explanation:
				Chef completed 
				4
				4 rounds of Surya Namaskar comprising of 4⋅12=48
				The fifth round was incomplete since Chef performed only 7 poses in that round.
				Sample 2:
				Input
				11
				Output
				0
				Explanation:
				Chef performed 11 yoga poses whereas each Surya Namaskar consists of 12 poses. Thus, he did not complete even 1 round of Surya Namaskar.
				Sample 3:
				Input
				24
				Output
				2
				Explanation:
				Since Chef performed 24 yoga poses and each Surya Namaskar consists of 12 poses, he completed 2 rounds of Surya Namaskar.

			#include <bits/stdc++.h>
			using namespace std;
			int main() {
				int n;
				std::cin >> n;
				cout<< n /12 ;
				return 0;
			}

	1044) Ninja and power of 2
		Problem statement
			Ninja loves playing with numbers. So one day, he wants to arrange a few numbers in the ‘N’ number of rows. The first row contains 1 number, the second row has two numbers, the third row has 4 numbers, and so on.
			Ninja starts placing numbers in increasing order, with absolute difference 1, starting from 1 and continuing till he encounters 9, and then he again restarts from 1.
			You are given an integer ‘N’ denoting the given number of rows. Can you print the pattern Ninja wants to create?
			Pattern for N = 4:
			1
			23
			4567
			89123456
			Constraints:
				1 <= T <= 5
				1 <= N <= 15
				Where ‘T’ denotes number of test cases and ‘N’ is the given integer denoting the given number of rows.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				4
				Sample Output 1 :
				1
				23
				4567
				1
				23
				4567
				89123456
				Explanation for Sample Input 1 :
				In the first test case, we are required to create a pattern consisting of 3 lines. First-line contains ‘1’. From the second line, we have to place a number one more than the previous value. So we place 2.Then we put 2 and move to the following line because this line will contain only 2 elements. In the following line, we have to place 4 numbers, so we place 4, 5, 6, and 7.
				In the second test case, we are required to create a pattern consisting of 4 lines. First-line contains ‘1’. From the second line, we have to place a number one more than the previous value. So we place 2.Then we put 2 and 3 and move to the following line because this line will contain only 2 elements. In the following line, we have to place 4 numbers, so we place 4, 5, 6, and 7.In the last line, we have to place 8 numbers, so we place 8, 9, 1, 2, 3, 4, 5, and 6.
				Sample Input 2 :
				2
				7
				2
				Sample Output 2 :
				1
				23
				4567
				89123456
				7891234567891234
				56789123456789123456789123456789
				1234567891234567891234567891234567891234567891234567891234567891
				1
				23

		#include <bits/stdc++.h> 
		vector<vector<int>> numberPattern(int n) {
			vector<vector<int>> ans(n);
			int cnt = 1, repeate=1;

			for(int i=0; i<n; i++){
				int itr = repeate;
				vector<int> temp;
				while(itr--){
						if(cnt > 9)
						cnt =1;
						temp.push_back(cnt++);
				}
				repeate = repeate * 2;
				ans[i]= temp;

				ans[i].push_back(-1);         // actually this is not mandatory here, but question is not proper.
			}
			return ans;
		}

	1045) Identical Linked Lists:
		https://www.geeksforgeeks.org/problems/identical-linked-lists/1
		Problem statement:
			Given the two singly Linked Lists respectively. The task is to check whether two linked lists are identical or not. 
			Two Linked Lists are identical when they have the same data and with the same arrangement too. If both Linked Lists are identical then return true otherwise return false. 
			Examples:
				Input:
				LinkedList1: 1->2->3->4->5->6
				LinkedList2: 99->59->42->20
				Output: false
				Explanation:

				As shown in figure linkedlists are not identical.
				Input:
				LinkedList1: 1->2->3->4->5
				LinkedList2: 1->2->3->4->5
				Output: true
				Explanation: 
				
				As shown in figure both are identical.

			Expected Time Complexity: O(n)
			Expected Auxilliary Space: O(1)

			Constraints:
				1 <= length of lists <= 10^3

		/*
			Structure of the node of the linked list is as
			struct Node {
				int data;
				struct Node *next;
				Node(int x) {
						data = x;
						next = NULL;
				}
			};
		*/

		// Function to check whether two linked lists are identical or not.
		bool areIdentical(struct Node *head1, struct Node *head2) {
			while(head1 && head2){
				if(head1 -> data != head2 -> data)
						return 0;
				head1 = head1 -> next;
				head2 = head2 -> next;
			}
			
			if(head1 == NULL && head2 == NULL)
				return 1;
			return 0;
		}

	1046) Delete node in Doubly Linked List:
		Problem statement:
			Given a doubly Linked list and a position. The task is to delete a node from a given position (position starts from 1) in a doubly linked list and return the head of the doubly Linked list.
			Examples:
			Input: LinkedList = 1 <--> 3 <--> 4, x = 3
			Output: 1 3  
			Explanation: 
			After deleting the node at position 3 (position starts from 1),the linked list will be now as 1 <--> 3.
			
			Input: LinkedList = 1 <--> 5 <--> 2 <--> 9, x = 1
			Output: 5 2 9
			Explanation:

			Expected Time Complexity: O(n)
			Expected Auxilliary Space: O(1)

			Constraints:
				2 <= size of the linked list(n) <= 10^5
				1 <= x <= n
				1 <= node.data <= 10^9

		/* Structure of Node
			struct Node {
				int data;
				struct Node *next;
				struct Node *prev;

				Node(int x){
						data = x;
						next = NULL;
						prev = NULL;
				}
			};
		*/

		class Solution {
			public:
			Node* deleteNode(Node* head, int x) {
				// if its start position
				if(x == 1){
						head = head -> next;
						head -> prev = NULL;
						return head;
				}
				
				Node* temp = head;
				while(--x)
						temp = temp -> next;
						
				// it confirms that its last node
				if(temp -> next == NULL)
						temp -> prev -> next = NULL, temp -> prev = NULL;
				else
						temp -> prev -> next = temp -> next, 
						temp -> next -> prev = temp -> prev,
						temp -> next = temp -> prev = NULL;
				
				return head;
			}
		};

	1047) Three Consecutive Odds:
		Problem statement:
			Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.        
			Example 1:
				Input: arr = [2,6,4,1]
				Output: false
				Explanation: There are no three consecutive odds.
			Example 2:
				Input: arr = [1,2,34,3,4,5,7,23,12]
				Output: true
				Explanation: [5,7,23] are three consecutive odds.
			Constraints:
				1 <= arr.length <= 1000
				1 <= arr[i] <= 1000
		
		class Solution {
			public:
			bool threeConsecutiveOdds(vector<int>& arr) {
				int cnt =0;
				for(int i=0; i<arr.size(); i++){
						if(arr[i]&1)
							cnt++;
						else
							cnt=0;
						
						if(cnt == 3)
							return 1;
				}
				return 0;
			}
		};
	
	1048) Intersection of Two Arrays II:
		Problem statement:
			Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
			Example 1:
			Input: nums1 = [1,2,2,1], nums2 = [2,2]
			Output: [2,2]

			Example 2:
			Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
			Output: [4,9]
			Explanation: [9,4] is also accepted.

			Constraints:
				1 <= nums1.length, nums2.length <= 1000
				0 <= nums1[i], nums2[i] <= 1000
				
			Follow up:
				What if the given array is already sorted? How would you optimize your algorithm?
				What if nums1's size is small compared to nums2's size? Which algorithm is better?
				What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?

		class Solution {
			public:
			vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
				sort(nums1.begin(), nums1.end());
				sort(nums2.begin(), nums2.end());

				vector<int> ans;
				int n = nums1.size();
				int m = nums2.size();

				for(int i=0, j=0; i < n and j < m;)
					if(nums1[i] == nums2[j]){
						ans.push_back(nums1[i]);
						i++, j++;
					}else if(nums1[i] < nums2[j])
						i++;
					else
						j++;

				return ans;        
			}
		};
	
	1049) linked list of strings forms a palindrome:
		Problem statement:
			Given a linked list with string data, check whether the combined string formed is palindrome. If the combined string is palindrome then return true otherwise return false.
			Example:
			Input:
				a -> bc -> d -> dcb -> a

			Output : true
			Explanation: As string "abcddcba" is palindrome the function should return true.
			
			Input:
				a -> bc -> d -> ba
			Output : false
			Explanation: As string "abcdba" is not palindrome the function should return false.

			Expected Time Complexity:  O(n)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 <= Node.data.length<= 10^3
				1<=list.length<=103

		/*
			The structure of linked list is the following
			struct Node {
				string data;
				Node* next;
				Node(int x){
					data = x;
					next = NULL;
				}
			};
		*/

		class Solution {
			public:
			bool isPalindrome(string s){
				int i=0, n = s.size();
				
				while(i < n/2){
					if(s[i] != s[n-1-i])
						return 0;
					i++;
				}
				return 1;
			}
			bool compute(Node* head) {
				string s;
				while(head){
					s += head -> data;
					head = head -> next;
				}
				
				if(isPalindrome(s)) return 1;
				return 0;
			}
		};

	1050) Reverse Only Letters:
		Problem statement
			You are given a string, ‘S’. You need to reverse the string where characters that are not an alphabet stay in the same place, and the rest reverse their positions.
			Eg: “a-bcd” becomes “d-cba”
			Constraints:
				1 <= T <= 10
				0 <= |S| <= 5000

			Where |S| denotes the length of string 'S'.
			Time Limit: 1 Sec
			Sample Input 1:
				2
				a-bcd
				!s-cx
				Sample Output 1:
				d-cba
				!x-cs
				Explanation Of Sample Input 1:
				In the first test case:
				“a-bcd” after removing non-letter will be “abcd”.
				Reversing “abcd” will get “dcba”.
				Placing non-letters in the correct position in “dcba”, we get: “d-cba”.

				In the second test case:
				“!s-cx” after removing non-letter will be “scx”.
				Reversing “scx” will get “xcs”.
				Placing non-letters in the correct position in “xcs”, we get: “!x-cs”.
				Sample Input 2:
				2
				a-bC-dEf-ghIj
				Qedo1ct-eeLg=ntse-T!
				Sample Output 2:
				j-Ih-gfE-dCba
				Test1ng-Leet=code-Q!
				Explanation Of Sample Input 2:
				In the first test case:
				“a-bC-dEf-ghIj” after removing non-letter will be “abCdEfghlj”.
				Reversing “abCdEfghlj” will get “jlhgfEdCba”.
				Placing non-letters in the correct position in “jlhgfEdCba”, we get: “j-Ih-gfE-dCba”.

				In the second test case:
				“!s-cx” after removing non-letter will be “Qedo1ct-eeLg=ntse-T!”.
				Reversing “QedocteeLgntseT” will get “TestngLeetcodeQ”.
				Placing non-letters in the correct position in “TestngLeetcodeQ”, we get: “Test1ng-Leet=code-Q!”.

		#include <bits/stdc++.h> 
		string reverseOnlyLetters(string & s) {
			int i=0, j=s.size()-1;
			while(i < j){
				if(isalpha(s[i]) && isalpha(s[j])){
					swap(s[i++], s[j--]);
				}else if(!isalpha(s[i])){
					i++;
				}else{
					j--;
				}
			}
			return s;
		}

	1051) Remove all occurences of duplicates in a linked list:
		Problem statement:
			Given a sorted linked list, delete all nodes that have duplicate numbers (all occurrences), leaving only numbers that appear once in the original list, and return the head of the modified linked list. 
			Examples:
			Input: Linked List = 23->28->28->35->49->49->53->53
			Output: 23 35
			Explanation: The duplicate numbers are 28, 49 and 53 which are removed from the list.

			Input: Linked List = 11->11->11->11->75->75
			Output: Empty list
			
			Explanation: All the nodes in the linked list have duplicates. Hence the resultant list would be empty.
			
			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)
			
			Constraints:
				1 ≤ size(list) ≤ 10^5
			
		/* Linked List node structure
			struct Node {
				int data;
				struct Node *next;
			};
		*/

		class Solution {
			public:
			Node* removeAllDuplicates(struct Node* H1) {
				Node* nn = new Node(0);
				Node* temp = nn;
				Node* head = H1;
				
				// creating set 
				// while(head && head -> next){
				//     if(head -> data == head -> next -> data){
				//         Node* temp = head -> next;
				//         // head -> next = head -> next -> next;
				//         // or
				//         head -> next = temp -> next;
				//         temp -> next = NULL;
				//         delete temp;
				//     }else{
				//         head = head -> next;
				//     }
				// }
				
				map<int, int> Fr;
				while(head){
					Fr[head -> data]++;
					head = head -> next;
				}
				
				for(auto i: Fr)
					if(i.second == 1){
						Node* nt = new Node(i.first);
						temp -> next = nt;
						temp = nt;
					}
				
				nn = nn -> next;
				return nn;
			}
		};

	1052) Subtract The Product And Sum Of Digits Of An Integer:
		Problem statement
			You are given an integer number ‘N’, and your task is to return the difference between the product of its digits and the sum of its digits.
			Note:
			You do not need to print anything; it has already been taken care of. Just implement the given function.
			For Example :
			Input: N = 234
			Output: 15 
			Explanation: 
			Product of digits = 2 * 3 * 4 = 24 
			Sum of digits = 2 + 3 + 4 = 9 
			Result = 24 - 9 = 15
			Constraints :
				1 <= T <= 3000
				1 <= N <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				2
				234
				4421
				Sample Output 1 :
				15
				21
				Explanation For Sample Input 1 :
				Product of digits = 2 * 3 * 4 = 24 
				Sum of digits = 2 + 3 + 4 = 9 
				Result = 24 - 9 = 15

				Product of digits = 4 * 4 * 2 * 1 = 32 
				Sum of digits = 4 + 4 + 2 + 1 = 11
				Result = 32 - 11 = 21
				Sample Input 2 :
				1
				87
				Sample Output 2 :
				41

		#include <bits/stdc++.h> 
		int findProductSumDifference(int n){
			int sum=0, prod=1;
			while(n){
				sum += n%10;
				prod *= n%10;
				n /= 10;
			}
			return prod - sum;
		}

	1053) Delete Kth Node From End:
		https://www.naukri.com/code360/problems/delete-kth-node-from-end-in-linked-list_799912
		Problem statement
			You have been given a singly Linked List of 'N' nodes with integer data and an integer 'K'.
			Your task is to remove the 'K'th node from the end of the given Linked List and return the head of the modified linked list.
			Example:
				Input : 1 -> 2 -> 3 -> 4 -> 'NULL'  and  'K' = 2
				Output: 1 -> 2 -> 4 -> 'NULL'
			Explanation:
				After removing the second node from the end, the linked list become 1 -> 2 -> 4 -> 'NULL'.
			Sample Input 1 :
				6 3
				1 2 3 4 5 6 
				Sample Output 1 :
				1 2 3 5 6
				Explanation for Sample Input 1:
				In the given linked list the node with data ‘4’ will be removed as this is the 3rd node from the end of the Linked List.
				Sample Input 2 :
				3 3
				1 2 3
				Sample Output 2 :
				2 3
			Constraints :
				1 <= 'N' <= 10^3
				1 <= 'K' <= 'N'
				1 <= 'data' <= 10^3
				Time Limit: 1 sec.

		/*
			Following is the class structure of the Node class:
			class Node {
				public:
					int data;
					Node *next;
				Node(){
					this -> data = 0;
					next = NULL;
				}
				Node(int data){
					this->data = data;
					this->next = NULL;
				}
				Node(int data, Node* next) {
					this->data = data;
					this->next = next;
				}
			};
		*/

		int getLength(Node* h){
			int l=0;
			while(h)
				l++, h = h -> next;

			return l;
		}

		Node* reverse(Node* h){
			Node* cur = h;
			Node* prev = NULL;

			while(cur){
				Node *up = cur -> next;
				cur -> next = prev;
		
				prev = cur;
				cur = up;
			}
			return prev;
		}

		Node *removeKthNode(Node *head, int K) {
			int length = getLength(head);

			if(K == length)
				return head -> next;

			head = reverse(head);
			if(K == 1){
				head = head -> next;
				head = reverse(head);
				return head;
			}

			Node* cur = head;
			Node* prev = nullptr;
			while(--K){
				prev = cur;
				cur = cur -> next;
			}

			prev -> next = cur -> next;
			head = reverse(head);
			return head;
		}

	1054) Merge Nodes in Between Zeros:
		Problem Statement:
			You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.
			For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.
			Return the head of the modified linked list.

			Example 1:
				Input: head = [0,3,1,0,4,5,2,0]
				Output: [4,11]
				Explanation: 
				The above figure represents the given linked list. The modified list contains
				- The sum of the nodes marked in green: 3 + 1 = 4.
				- The sum of the nodes marked in red: 4 + 5 + 2 = 11.
			Example 2:
				Input: head = [0,1,0,3,0,2,2,0]
				Output: [1,3,4]
				Explanation: 
				The above figure represents the given linked list. The modified list contains
				- The sum of the nodes marked in green: 1 = 1.
				- The sum of the nodes marked in red: 3 = 3.
				- The sum of the nodes marked in yellow: 2 + 2 = 4.

			Constraints:
				The number of nodes in the list is in the range [3, 2 * 10^5].
				0 <= Node.val <= 1000
				There are no two consecutive nodes with Node.val == 0.
				The beginning and end of the linked list have Node.val == 0.

		/**
		* Definition for singly-linked list.
		* struct ListNode {
		*     int val;
		*     ListNode *next;
		*     ListNode() : val(0), next(nullptr) {}
		*     ListNode(int x) : val(x), next(nullptr) {}
		*     ListNode(int x, ListNode *next) : val(x), next(next) {}
		* };
		*/
		class Solution {
			public:
			ListNode* mergeNodes(ListNode* head) {
				ListNode* ans = head -> next;
				ListNode* prevPtr = head -> next;
				
				ListNode* temp = head -> next;

				int sum =0;
				while(temp){
					if(temp -> val == 0){
						prevPtr -> val = sum;
						prevPtr -> next = temp -> next;
						prevPtr = temp -> next;
						sum = 0;
					}else
						sum += temp -> val;
					
					temp = temp -> next;
				}
				return ans;
			}
		};

	#CN WeeklyContest-133:
		1055) Append to Disrupt:
			Problem statement
				You are given an array 'A' of 'N' integers numbered from '0' to 'N - 1'. It is guaranteed that the array 'A' is sorted in non-decreasing order.
				Determine the maximum element from the array 'A' such that after appending it to the end of the array, the array is no longer sorted in non-decreasing order. If no such element exists, return -1.
				Example:
				N = 3
				A = [1, 3, 3]
				We can append 'A[0]' to the array. So, the resulting array is ['1', '3', '3', '1'], which is not sorted in non-decreasing order.
				It can be proved that there is no element greater than '1' in the array 'A' such that after appending it to the end of the array, the array is no longer sorted in non-decreasing order.
				So, the answer for this case is '1'.
				Constraints:
					1 <= 'N' <= 10^5
					1 <= 'A[i]' <= 10^5
					Time limit: 1 sec
				Sample input 1:
					2
					2
					4 4
					3
					4 10 11
					Sample output 1:
					-1
					10
					Explanation of sample input 1:
					For test case 1:
					It can be proved that there is no element in the array 'A' such that after appending it to the end of the array, the array is no longer sorted in non-decreasing order.
					So, the answer for this case is '-1'. 

					For test case 2:
					We can append 'A[1]' to the array. So, the resulting array is ['4', '10', '11', '10'], which is not sorted in non-decreasing order.
					It can be proved that there is no element greater than '10' in the array 'A' such that after appending it to the end of the array, the array is no longer sorted in non-decreasing order.
					So, the answer for this case is '10'.
					Sample input 2:
					2
					5
					4 5 5 7 7
					9
					1 1 1 1 2 2 2 3 3
					Sample output 2:
					5
					2

			int canYouDisrupt(int n, vector<int> &v) {
				for(int i=v.size()-2; i >=0; i--)
					if(v[i] < v[i+1])
						return v[i];
				return -1;
			}

	1056) Pass the Pillow:
		Problem Statement:
			There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.
			For example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.
			Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.

			Example 1:
				Input: n = 4, time = 5
				Output: 2
				Explanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.
				After five seconds, the 2nd person is holding the pillow.
			Example 2:
				Input: n = 3, time = 2
				Output: 3
				Explanation: People pass the pillow in the following way: 1 -> 2 -> 3.
				After two seconds, the 3rd person is holding the pillow.

			Constraints:
				2 <= n <= 1000
				1 <= time <= 1000

		class Solution {
			public:
			int passThePillow(int n, int t) {
				int on = 1;

				while(t){
					while(on < n && t)
						t--, on++;
					
					
					while(on > 1 && t)
						on--, t--;
				}
				return on;
			}
		};

	1057) Water Bottles:
		https://leetcode.com/problems/water-bottles/description/
		Problem Statement:
			There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.
			The operation of drinking a full water bottle turns it into an empty bottle.
			Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.
			Example 1:
				Input: numBottles = 9, numExchange = 3
				Output: 13
				Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
				Number of water bottles you can drink: 9 + 3 + 1 = 13.

			Example 2:
				Input: numBottles = 15, numExchange = 4
				Output: 19
				Explanation: You can exchange 4 empty bottles to get 1 full water bottle. 
				Number of water bottles you can drink: 15 + 3 + 1 = 19.
			Constraints:
				1 <= numBottles <= 100
				2 <= numExchange <= 100

		class Solution {
			public:
			int numWaterBottles(int numBottles, int numExchange) {
				int bottleDrunk=numBottles, EmptyBottle = numBottles;

				while(EmptyBottle / numExchange){
					bottleDrunk += (EmptyBottle / numExchange);
					int curEmptyBottle = EmptyBottle % numExchange;

					EmptyBottle = curEmptyBottle + (EmptyBottle / numExchange) ;
				}
				return bottleDrunk;
			}
		};			

	1058) Search in Rotated Sorted Array (Refer Q.390)
		Problem statement:
			Given a sorted (in ascending order) and rotated array arr of distinct elements which may be rotated at some point and given an element key, the task is to find the index of the given element key in the array arr. The whole array arr is given as the range to search.
			Rotation shifts elements of the array by a certain number of positions, with elements that fall off one end reappearing at the other end.
			Note:- 0-based indexing is followed & returns -1 if the key is not present.
			Examples :
				Input: arr[] = [5, 6, 7, 8, 9, 10, 1, 2, 3], key = 10
				Output: 5
				Explanation: 10 is found at index 5.
				Input: arr[] = [3, 5, 1, 2], key = 6
				Output: -1
				Explanation: There is no element that has value 6.

			Expected Time Complexity: O(log n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ arr.size() ≤ 10^6
				0 ≤ arr[i] ≤ 10^6
				1 ≤ key ≤ 10^5

		class Solution {
			public:
			int search(vector<int>& arr, int key) {
				if(find(arr.begin(), arr.end(), key) != arr.end())
					return find(arr.begin(), arr.end(), key) - arr.begin();
				return -1;
			}
		};

	1059) Magic in CPP:
		Problem Statement:
			This Module is all about pointers and how they can be cleverly employed to solve typical CPP problems.
			Given two integers A and B. The task is to swap two numbers. Swapping here means to interchange the values of A and B.
			Example 1:
				Input:
				A = 3 
				B = 5
				Output: 
				5 3
				Explanation:
				Here, A = 3 and B = 5.
				After swapping A = 5 and B = 3.

			Your Task:
				Your task is to complete the two swap() functions, such that values of A and B gets interchanged.

			Constraints:
				1 <= A, B <= 10^6

		//User function Template for C++
		// Function to swap A and B
		// using pointers
		void swap(int *A, int *B){
			// Your code here
			int t = *A;
			*A = *B;
			*B = t;
		}

		// Function to swap A and B
		// using reference
		void swap(int &A, int &B){
			// Your code here
			int t = A;
			A = B;
			B = t;
		}

	1060) Two Dimensional World:
		Problem Statement:
			In CPP we can't pass 2D arrays in normal way to a function. The array has to be declared in a special way.
			Given a 2D array A[][] of size N x N consisting of integers. The task is to print all the elements in matrix (row and column order) form.
			Example 1:
			Input:
			3
			1 2 3
			4 5 6
			7 8 9
			Output: 
			1 2 3
			4 5 6
			7 8 9
			Explanation:
			Elements of 2D array in row-column order 
			are as mentioned in Sample Output.
			
			Your Task:
				Your task is to complete the function twoDimensional() that takes two parameters: 2D array mat and N. You need to write the parameter for 2D array and print matrix.
			Constraints:
				1 <= T <= 10
				1 <= N <= 100
				1 <= A[i][j] <= 10^6

		//{ Driver Code Starts
		//Initial Template for C++
		#include <iostream>
		using namespace std;
		// } Driver Code Ends
		//User function Template for C++

		/* Function to take input for 2D array elements
		* Note : Mention matrix in argument also.
		* N : size of matrix
		*/
		void twoDimensional(int **a,int N){
			
			// Loop to iterate through matrix
			for(int i = 0;i<N;i++){
				for(int j = 0;j<N;j++){
					// Your code here
					cout<<a[i][j]<<" ";
				}
				cout << endl;
			}
		}

		//{ Driver Code Starts.
		// Driver code
		int main() {
			
			int testcase;
			cin >> testcase;
			
			while(testcase--){
				int N;
				cin >> N;
				
				// Declaring mat as pointer to pointer
				int **mat;
			
				// mat pointer contains array of pointer to array
				mat = new int*[N];
				
				// Taking input to mat[][]
				for(int i = 0;i<N;i++){
					mat[i] = new int[N];
				}
				
				for(int i = 0;i<N;i++){
					for(int j = 0;j<N;j++){
						cin >> mat[i][j];
					}
				}
				
				twoDimensional(mat, N);   
			}
			
			return 0;
		}
		// } Driver Code Ends

	1061) Delete Array:
		Problem Statement:
			Here, we'll learn the delete keyword that's used to clear the dynamically allocated memory in CPP.
			Given a dynamic array A of size N. The task is to find the sum of array elements.
			Example 1:
				Input:
				N = 5
				A[] = 1 2 3 4 5
				Output: 
				15
				1
				Explanation:
				Sum of array elements is 15 
				(1 + 2 + 3 + 4 + 5). The first
				element is 1.

			Your Task:
				Just comment the line that is deallocating the array. Driver code will output the sum of array elements and in next line prints the first array element(A[0]).
			Constraints:
				1 <= N <= 100
				1 <= A[i] <= 10^5

		//{ Driver Code Starts
		//Initial Template for C++

		#include <iostream>
		using namespace std;

		int main() {
			int testcase;
			cin >> testcase;
			
			while(testcase--){
				int N;
				cin >> N;
				
				// Declaring dynamic 1D array
				int *arr = new int[N];
				for(int i = 0;i<N;i++)
					cin >> arr[i];
				
				int sum = 0;
				for(int i = 0;i<N;i++{
				sum += arr[i];

		// } Driver Code Ends
		//User function Template for C++

		// Code to delete the array
		// Task is to comment the line which deletes 
		// the array such that required output is printed
		// delete[] arr; //comment this line so memory doesn't get deallocated

		//{ Driver Code Starts.
				cout << sum << endl;    
				cout << arr[0] << endl;
			}
			return 0;
		}
		// } Driver Code Ends

	1062) Crawler Log Folder:
		Problem Statement:
			The Leetcode file system keeps a log each time some user performs a change folder operation.
			The operations are described below:
			"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
			"./" : Remain in the same folder.
			"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
			You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.
			The file system starts in the main folder, then the operations in logs are performed.
			Return the minimum number of operations needed to go back to the main folder after the change folder operations.
			Example 1:
				Input: logs = ["d1/","d2/","../","d21/","./"]
				Output: 2
				Explanation: Use this change folder operation "../" 2 times and go back to the main folder.
			Example 2:
				Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
				Output: 3
			Example 3:
				Input: logs = ["d1/","../","../","../"]
				Output: 0
			
			Constraints:
				1 <= logs.length <= 10^3
				2 <= logs[i].length <= 10
				logs[i] contains lowercase English letters, digits, '.', and '/'.
				logs[i] follows the format described in the statement.
				Folder names consist of lowercase English letters and digits.

		class Solution {
			public:
			int minOperations(vector<string>& logs) {
				int cnt=0;
				for(string s: logs)
					if(s == "../"){
						if(cnt != 0)
							cnt--;
					}else if(s == "./")
						continue;
					else
						cnt++;
				return cnt;
			}
		};
	
	1063) Two Sum IV - Input is a BST:
		https://www.naukri.com/code360/problems/two-sum-in-a-bst_1062631
		Problem statement
			You have been given a Binary Search Tree and a target value. You need to find out whether there exists a pair of node values in the BST, such that their sum is equal to the target value.
			A binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree whose internal nodes each store a value greater than all the values keys in the node's left subtree and less than those in its right subtree.
			Follow Up:
				Can you solve this in O(N) time, and O(H) space complexity?
			Constraints:
				1 <= T <= 100
				1 <= N <= 3000
				-10^9 <= node data <= 10^9, (where node data != -1)
				-10^9 <= target value <= 10^9
				Where N denotes is the number of nodes in the given tree.
				Time Limit: 1 second

			Sample Input 1:
				1
				10 6 12 2 8 11 15 -1 -1 -1 -1 -1 -1 -1 -1
				14
				Sample Output 1:
				True
				Explanation for sample 1:
				For the first test case, the sum of the nodes with values 2 and 12 equals the target value.

				Sample Input 2:
				1
				5 3 7 -1 -1 6 8 -1 -1 -1 -1
				20
				Sample output 2:
				False
				Explanation for sample 2:
				For the first test case, there is no such pair of nodes, the sum of which equals the target value.

		#include <bits/stdc++.h> 
		// Following is the Binary Tree node structure
		/**************
			class BinaryTreeNode {
				public : 
				T data;
				BinaryTreeNode<T> *left;
				BinaryTreeNode<T> *right;

				BinaryTreeNode(T data) {
					this -> data = data;
					left = NULL;
					right = NULL;
				}
				
			};
		***************/
		void InOrderTraversal(BinaryTreeNode<int>* r, vector<int> &v){
			if(r == NULL)
				return;

			InOrderTraversal(r -> left, v);
			v.push_back(r -> data);
			InOrderTraversal(r -> right, v);    
		}
		bool twoSumInBST(BinaryTreeNode<int>* root, int target) {
			vector<int> v;
			InOrderTraversal(root, v);                 // InOrderTraversal will generate the BST as sorted array

			int i=0, j=v.size()-1;
			while(i < j){
				if(v[i] + v[j] == target)
					return 1;
				else if(v[i] + v[j] > target)
					j--;
				else
					i++;
			}
			return 0;
		}

		// Not Optimized: TC: O(n²) & SC: O(n)
		void InOrderTraversal(BinaryTreeNode<int>* r, vector<int> &v){
			if(r == NULL)
				return;

			InOrderTraversal(r -> left, v);
			v.push_back(r -> data);
			InOrderTraversal(r -> right, v);    
		}
		bool twoSumInBST(BinaryTreeNode<int>* root, int target) {
			vector<int> v;
			InOrderTraversal(root, v);                 // InOrderTraversal will generate the BST as sorted array
			int n = v.size();
			for(int i=0; i<n; i++)
				for(int j=i+1; j<n; j++)
					if(v[i] + v[j] == target) return 1;

			return 0;
		}

	1064) Reverse DLL nodes in groups:
		Problem statement
			You are given a Doubly Linked List of integers and a positive integer 'K' representing the group size. Modify the linked list by reversing every group of 'K' nodes in the linked list.
			A doubly linked list is a type of linked list that is bidirectional, that is, it can be traversed in both directions, forward and backward. 
			Note:
			If the number of nodes in the list or in the last group is less than K, just reverse the remaining nodes. 
			Example:
			Linked list: 8 9 10 11 12
			K: 3 
			Output: 10 9 8 12 11
			We reverse the first K (3) nodes. Now, since the number of nodes remaining in the list (2) is less than K, we just reverse the remaining nodes (11 and 12).  
			Constraints:
				1 <= T <= 10    
				1 <= N <= 5 * 10^4
				1 <= K <=  10^5
				-10^3 <= data <= 10^3 and data != -1
				Time Limit: 1 sec

			Sample Input 1:
				1
				1 2 3 4 5 6 7 -1
				2  
				Sample Output 1:
				2 1 4 3 6 5 7 -1
				Explanation of sample input 1:
				In the given linked list, we have to reverse the first two nodes, then reverse the next two nodes, and so on… until all the nodes are processed in the same way.
				The modified linked list after the above process is 2 1 4 3 6 5 7 -1
				Sample Input 2:
				2
				5 10 -6 4 7 -1 
				3 
				10 20 30 40 50 -1
				1 
				Sample Output 2:
				-6 10 5 7 4 -1
				10 20 30 40 50 -1

		#include <bits/stdc++.h> 
		/*********************************************************
			Following is the class structure of the Node class:
			class Node {
				public:
					int data;
					Node *next;
					Node *prev;
				Node(int data) {
					this->data = data;
					this->next = NULL;
					this->prev = NULL;
				}
			};
		************************************************************/
		Node* reverse_createDLL(vector<int> &v){
			int i=0, j = v.size()-1;
			while(i < j)
				swap(v[i++], v[j--]);
			
			Node* ans = new Node(v[0]);
			Node* tail = ans;

			i = 1;
			while(i < v.size()){
				Node* nn = new Node(v[i++]);
				tail -> next = nn;
				nn -> prev = tail;
				tail = nn;
			}
			return ans;
		}
		Node* reverseDLLInGroups(Node* head, int k) {
			if(k == 1)
				return head;
			
			vector<vector<int>> hold;
			while(head){
				int t = k;
				vector<int> temp;
				while(t-- && head){
					temp.push_back(head -> data);
					head = head -> next;
				}
				hold.push_back(temp);
			}

			Node *ans = reverse_createDLL(hold[0]);
			Node *tail = ans;

			while(tail -> next)
				tail = tail -> next;

			int i = 1;
			while(i < hold.size()){
				tail -> next = reverse_createDLL(hold[i]);
				while(tail -> next)
					tail = tail -> next;
				i++;
			}
			return ans;
		}

	1065) Segregate 0s and 1s:
		Problem Statement:
			Given an array arr consisting of only 0's and 1's in random order. Modify the array in-place to segregate 0s onto the left side and 1s onto the right side of the array.
			Examples :
				Input: arr[] = [0, 0, 1, 1, 0]
				Output: [0, 0, 0, 1, 1]
				Explanation:  After segregation, all the 0's are on the left and 1's are on the right. Modified array will be [0, 0, 0, 1, 1].
				Input: arr[] = [1, 1, 1, 1]
				Output: [1, 1, 1, 1]
				Explanation: There are no 0s in the given array, so the modified array is [1, 1, 1, 1]

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ arr.size() ≤ 10^6
				0 ≤ arr[i] ≤ 1

		class Solution {
			public:
			void segregate0and1(vector<int> &arr) {
				// counts of zero's
				int cnt=0;
				for(int i: arr)
					if(i == 0)
						cnt++;
					
				// placing all zero's first 
				int i = cnt;
				while(cnt--)
					arr[cnt] = 0; 
					
				// then one's
				while(i < arr.size())
					arr[i++] = 1;
			}
		};

	1066) Remaining String:
		Problem statement:
			Given a string s without spaces, a character ch and an integer count. Your task is to return the substring that remains after the character ch has appeared count number of times.
			Note:  Assume upper case and lower case alphabets are different. “”(Empty string) should be returned if it is not possible, or the remaining substring is empty.

			Examples:
				Input: s = "Thisisdemostring", ch = 'i', count = 3
				Output: ng
				Explanation: The remaining substring of s after the 3rd
				occurrence of 'i' is "ng", hence the output is ng.
				Input: s = "Thisisdemostri", ch = 'i', count = 3
				Output: ""
				Explanation: The 3rd occurence of 'i' is at the last index. In this case the remaining substring is empty, hence we return empty string.
				Input: s = "abcd", ch = 'x', count = 2
				Output: ""
				Explanation: The character x is not present in the string, hence we return empty string.
			Expected Time Complexity: O(|s|)
			Expected Auxiliary Space: O(1)

			Constraints:
				1<= s.length()<=10^5
				1<=count<=s.length()
				s[i] is both upper case and lower case

		class Solution {
			public:
			string printString(string s, char ch, int count) {
				while(count--){
					int pos = s.find(ch);
					if(pos == string::npos)
						return "";
					s = s.substr(pos + 1);
				}
				return s;
			}
		};
	
	1067) Concatenate The Largest Digit
		Problem statement
			You are given three non-zero numbers ‘A’, ‘B’, and ‘C’. The task is to find the number formed by concatenating the largest digit from each of these numbers in the order of ‘A’, ‘B’, and ‘C’.
			For Example :
			A = 5678, B = 45 and C = 769
			The largest digit in ‘A’ is ‘8’, ‘B’ is ‘5’, and ‘C’ is ‘9’. The new number formed by concatenating the largest digit from each of these numbers is ‘859’. So, the answer is ‘859’.
			Constraints :
				1 <= T <= 10^4
				1 <= A, B, C <= 10^6

				Time limit: 1 Sec
			Sample Input 1 :
			2
			4554 292 123567
			90909 111 876
			Sample Output 1 :
			597
			918
			Explanation Of Sample Input 1 :
			Test Case 1:
			a = 4554, b = 292 and c = 123567
			The largest digit in ‘a’ is ‘5’, ‘b’ is ‘9’, and ‘c’ is ‘7’. The new number formed by concatenating the largest digit from each of these numbers is ‘597’. So, the answer is ‘597’. 

			Test Case 2:
			a = 90909, b = 111 and c = 876
			The largest digit in ‘a’ is ‘9’, ‘b’ is ‘1’, and ‘c’ is ‘8’. The new number formed by concatenating the largest digit from each of these numbers is ‘918’. So, the answer is ‘918’.
			Sample Input 2 :
			2
			324865 123 456
			1 22 333
			Sample Output 2 :
			836
			123

		#include <bits/stdc++.h> 
		int concatLargestDigit(int a, int b, int c) {
			string s = to_string(a);
			int ans = *max_element(s.begin(), s.end()) - '0';

			s = to_string(b);
			ans = ans * 10 + *max_element(s.begin(), s.end()) - '0';
			
			s = to_string(c);
			ans = ans * 10 + *max_element(s.begin(), s.end()) - '0';

			return ans;
		}
	
	1068) Largest Prime Factor:
		Problem statement
			You are given a positive integer ‘n’. Your task is to find the largest prime factor of this given positive integer.

			Note :
			If there is no prime factor of a given integer, then print -1.
			Constraints :
				1 <= T <= 50
				1 <= n <= 10^9
				Where ‘T’ is the number of test cases and ‘n’ is the size of the array.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				5 
				27
				Sample Output 1 :
				5
				3
				Explanation of the Sample Input1 :
				Test case 1:
				5 is a prime number, so its largest prime is 5 itself  

				Test case 2:
				Prime factorization of 27 is 3*3*3.
				Thus, it's an only prime factor is 3.
				Sample Input 2 :
				2
				14
				30
				Sample Output 2 :
				7
				5
				Explanation of the Sample Input 2 :
				Test case 1 :
				Prime factorization of 14 is 2*7.
				It has two prime factors, 2 and 7, the largest prime number out of them is 7.

				Test case 2 :
				Prime factorization of 30 is 2*3*5.
				It has three prime factors, 2, 3, and 5, the largest of them is 5.

		#include <bits/stdc++.h> 
		bool isPrime(int n){
			for(int i=2; i<= (n/2); i++)
				if(n % i == 0)
					return 0;
			return 1;
		}
		
		int largestPrimeFactor(int n) {
			if(n == 1) return -1;

			if(isPrime(n)) return n;

			int ans = -1;
			for(int i=2; i <= (n/2); i++){
				if(isPrime(i) && (n % i == 0))
					ans = i;
			}
			return ans;
		}
	
	1069) Partition List: (Refer Q 1000)
		Problem statement
			You are given a Singly Linked List of integers with a head pointer. Every node of the Linked List has a value written on it.
			A sample Linked List
			Now you have been given an integer value ‘K’. Your task is to rearrange this linked list such that the following conditions hold true :
			1. All nodes that have a value less than ‘K’ must come before the nodes that have a value greater than equal to ‘K’.
			2. All nodes must maintain the original relative order as they have present in the original linked list after rearrangement.
			Sample Input 1:
			2
			3 6 2 7 9 -1
			6
			1 3 8 7 -1
			8
			Sample Output 1:
			3 2 6 7 9
			1 3 7 8
			Explanation for sample input 1:
			Test case 1:
			The given linked list is shown below and K = 6.

			We can rearrange this linked as 3 -> 2 -> 6 -> 7 -> 9
			Nodes having a value less than ‘K’ = [3, 2]
			Nodes having a value greater than or equal to ‘K’ = [6, 7, 9]
			Here [3, 2] comes before [6, 7, 9], therefore, the final list will be [3, 2, 6, 7, 9].

			Test case 2:
			The given linked list is shown below and K = 8.

			We can rearrange this linked as 1 -> 3 -> 7 -> 8
			Nodes having a value less than ‘K’ = [1, 3, 7]
			Nodes having a value greater than or equal to ‘K’ = [8]
			Here [1, 3, 7] comes before [8], therefore, the final list will be [1, 3, 7, 8].
			Sample Input 2:
			1
			1 2 3 7 -1
			5
			Sample Output 2:
			1 2 3 7
			Explanation for sample input 1:
			Test case 1:
			The given linked list is shown below and K = 5

			We can rearrange this linked as 1 -> 2 -> 3 -> 7
			Nodes having value less than ‘K’ = [1, 2, 3]
			Nodes having value greater than or equal to ‘K’ = [7]
			Here [1, 2, 3] comes before [7],  therefore, the final list will be [1, 2, 3, 7].

		/****************************************************************
			Following is the class structure of the LinkedListNode class:
			template <typename T>
			class LinkedListNode {
				public:
					T data;
					LinkedListNode<T> *next;
				LinkedListNode(T data) {
					this->data = data;
					this->next = NULL;
				}
			};
		*****************************************************************/

		LinkedListNode<int> * partitionList(LinkedListNode<int> *head, int k) {
			vector<int> v1, v2;
			LinkedListNode<int>* t = head;
			while(t){
				if(t -> data < k){
					v1.push_back(t -> data);
				}else{
					v2.push_back(t -> data);
				}
				t = t -> next;
			}

			t = head;
			int i=0;
			while(i < v1.size())
				t -> data = v1[i++], t = t->next;

			i=0;
			while(i < v2.size())
				t -> data = v2[i++], t = t->next;

			return head;
		}
	
	1070) Maximum product subset of an array:
		Problem Statement:
			Given an array arr. The task is to find and return the maximum product possible with the subset of elements present in the array.
			Note:
				The maximum product can be a single element also.
				Since the product can be large, return it modulo 109 + 7.
			Examples:
				Input: arr[] = [-1, 0, -2, 4, 3]
				Output: 24
				Explanation: Maximum product will be ( -1 * -2 * 4 * 3 ) = 24
				Input: arr[] = [-1, 0]
				Output: 0
				Explanation: Maximum product will be ( -1 * 0) = 0
				Input: arr[] = [5]
				Output: 5
				Explanation: Maximum product will be 5.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= arr.size() <= 2 * 10^4
				-10 <= arr[i] <= 10

		class Solution {
			public:
			void subSeq(vector<int> a, vector<vector<int>> &ans, vector<int> t, int i){
				if(i >= a.size()){
					ans.push_back(t);
					return ;
				}
				
				subSeq(a, ans, t, i+1);
				t.push_back(a[i]);
				subSeq(a, ans, t, i+1);
			}
			long long int findMaxProduct(vector<int>& arr) {
				vector<vector<int>> v;
				vector<int> t;
				subSeq(arr, v, t, 0);
				
				int mod = 1e9+7;
				long long int mx = 0, prod=1;
				
				for(auto row: v){
					for(int i: row)
						prod = (prod * i) % mod;
						
					mx = max(mx, prod);
					prod = 1;
				}
				return mx;
			}
		};
	
	1071) Row with max 1s:
		Problem Statement:
			Given a boolean 2D array, consisting of only 1's and 0's, where each row is sorted. Return the 0-based index of the first row that has the most number of 1s. If no such row exists, return -1.
			Examples:
			Input: arr[][] = [[0, 1, 1, 1],
						[0, 0, 1, 1],
						[1, 1, 1, 1],
						[0, 0, 0, 0]]
			Output: 2
			Explanation: Row 2 contains 4 1's (0-based indexing).
			Input: arr[][] = [[0, 0], 
						[1, 1]]
			Output: 1
			Explanation: Row 1 contains 2 1's (0-based indexing).

			Expected Time Complexity: O(n+m)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ number of rows, number of columns ≤ 10^3
				0 ≤ arr[i][j] ≤ 1 

		class Solution {
			public:
			int rowWithMax1s(vector<vector<int> > &arr) {
				int cnt=0, prev=0;
				int mxRow = -1;
				int r = 0;
				
				for(auto row: arr){
					for(int i: row){
						if(i == 1)
							cnt++;
					}
					// cout<<cnt<<"\n";
					if(prev < cnt){
						mxRow = r;
						prev = cnt;
					}
					cnt=0;
					r++;
				}
				return mxRow;
			}
		};

		// or more Optimized:
			class Solution {
				public:
				int rowWithMax1s(vector<vector<int> > &arr) {
					int n = arr.size();
					int m = arr[0].size();
					
					// all rows are sorted so first cols which contain 1 will be answer
					// traverse cols
					for(int i=0; i<m; i++)
						for(int j=0; j<n; j++)
							if(arr[j][i] == 1)
								return j;
					return -1;
				}
			};

	1072) Longest Common Prefix of Strings:
		Problem Statement:
			Given an array of strings arr. Return the longest common prefix among all strings present in the array. If there's no prefix common in all the strings, return "-1".
			Examples :
				Input: arr[] = ["geeksforgeeks", "geeks", "geek", "geezer"]
				Output: gee
				Explanation: "gee" is the longest common prefix in all the given strings.
				
			Input: arr[] = ["hello", "world"]
			Output: -1
			Explanation: There's no common prefix in the given strings.

			Expected Time Complexity: O(n*min(|arri|))
			Expected Space Complexity: O(min(|arri|))

			Constraints:
				1 ≤ |arr| ≤ 10^3
				1 ≤ |arr[i]| ≤ 10^3
		
		class Solution {
			public:
			string longestCommonPrefix(vector<string> arr) {
				string ans = arr[0];
				for(int i=1; i<arr.size(); i++){
					string cur = arr[i], newString;
					int m = cur.size(), n = ans.size();
					int repeat = min(m,n), j=0;

					while(repeat--){
						if(cur[j] != ans[j])
							break;
						newString += cur[j++];
					}
					ans = newString;
				}
				if(ans.size() == 0) return "-1";
				return ans;
			}
		};

	1073) Count Minimum Swaps:
		Problem Statement:
			Given a binary string S (0-based index) of length N. You can swap any two digits of the string. Your task is to find the minimum number of swaps required to rearrange the string such that the sum of digits at even positions is equal to the sum of digits at odd positions. If it is not possible, return -1.
			Example 1:
			Input: S = 1010
			Output: 1
			Explanation: Initially, the sum of digits at even positions is: 1 + 1 = 2, and the sum of digits at odd positions is: 0 + 0 = 0. You can swap digits at indices 0 and 1 to make both sums equal.

			Example 2:
			Input: S = 111
			Output: -1
			Explanation: There is no way to rearrange the string such that the sum of digits at even positions equals the sum of digits at odd positions.

			Your Task:
				The task is to complete the function minSwaps() which takes a binary string S as input parameter and returns the minimum number of swaps to make both sums equal or -1 if it is not possible. 

			Constraints:
				1 ≤ N ≤ 10^5

		class Solution {
			public:
			int minSwaps(string s) {
				int e,o;
				e = o = 0;
				for(int i=0; i<s.length(); i++){
					if(i&1){
						s[i] - '0' ? o++ : NULL;
					}else{
						s[i] - '0' ? e++ : NULL;
					}
				}
				// cout<<e<<"\t"<<o;
				if((e+o) & 1)   return -1;
				return abs(e-o) / 2;
			}
		};
	
	#LeetCode WeeklyContest-410:
		1074) Snake in Matrix:
			Problem Statement:
				There is a snake in an n x n matrix grid and can move in four possible directions. Each cell in the grid is identified by the position: grid[i][j] = (i * n) + j.
				The snake starts at cell 0 and follows a sequence of commands.
				You are given an integer n representing the size of the grid and an array of strings commands where each command[i] is either "UP", "RIGHT", "DOWN", and "LEFT". It's guaranteed that the snake will remain within the grid boundaries throughout its movement.
				Return the position of the final cell where the snake ends up after executing commands.

				Example 1:
				Input: n = 2, commands = ["RIGHT","DOWN"]
				Output: 3
				Explanation:
							0	1
							2	3

				Example 2:
				Input: n = 3, commands = ["DOWN","RIGHT","UP"]
				Output: 1
				Explanation:
					0	1	2
					3	4	5
					6	7	8
				Constraints:
					2 <= n <= 10
					1 <= commands.length <= 100
					commands consists only of "UP", "RIGHT", "DOWN", and "LEFT".
					The input is generated such the snake will not move outside of the boundaries.

			class Solution {
				public:
				int finalPositionOfSnake(int n, vector<string>& commands) {
					vector<vector<int>> grid;
					int cnt=0;
					for(int i=0; i<n; i++){
						vector<int> temp;
						for(int j=0; j<n; j++)
							temp.push_back(cnt++);
						grid.push_back(temp);
					}
					int i,j;
					i=j=0;

					for(string s: commands){
						if(s == "RIGHT"){
							j++;
						}else if(s == "UP"){
							i--;
						}else if(s == "DOWN"){
							i++;
						}else{
							j--;
						}
					}
					return grid[i][j];
				}
			};
	
	1075) Sum of Query II:
		Problem statement:
			You are given an array arr[] of n integers and q queries in an array queries[] of length 2*q containing l, r pair for all q queries. You need to compute the following sum over q queries.
			Note : Array is 1-Indexed.
			Examples :
			Input: n = 4, arr = {1, 2, 3, 4}, q = 2, queries = {1, 4, 2, 3}
			Output: 10 5
			Explaination: In the first query we need sum from 1 to 4 which is 1+2+3+4 = 10. In the second query we need sum from 2 to 3 which is 2 + 3 = 5.
			Input: n = 5, arr = {26, 30, 48, 29, 8}, q = 2, queries = {4, 4, 2, 3}
			Output: 29 78
			Explaination: In the first query we need sum from 4 to 4 which is 29. In the second query we need sum from 2 to 3 which is 30 + 48 = 78.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function querySum() which takes n, arr, q and queries as input parameters and returns the answer for all the queries.

			Expected Time Complexity: O(n+q)
			Expected Auxiliary Space: O(n)

			Constraints:
				1 ≤ n, q ≤ 10^5
				1 ≤ arr[i] ≤ 10^3
				1 ≤ l ≤ r ≤ n

		// Not Optimized:
			class Solution{
				public:
				vector<int> querySum(int n, int arr[], int q, int queries[]) {
					vector<int> ans;
					
					for(int i=0; i<(2*q); i+=2){
						int l = queries[i], r = queries[i+1], s=0;
						for(int j=l-1; j<r; j++){
							s += arr[j];
						}
						ans.push_back(s);
					}
					return ans;
				}
			};

		// Optimized:
			// Prefix Sum:
				class Solution{
					public:
					vector<int> querySum(int n, int arr[], int q, int queries[]) {
						vector<int> ans, temp;
						int s=0;
						
						for(int i=0; i<n; i++){
							s += arr[i];
							temp.push_back(s);
						}
						
						// for(int i: temp)
						//     cout<<i<<"\t";
						
						for(int i=0; i < (2*q); i+=2){
							int l=queries[i]-2, r = queries[i+1];
							
							if(l < 0)   ans.push_back(temp[r-1]);
							else    ans.push_back(temp[r-1]-temp[l]);
						}
						return ans;
					}
				};

		// Segment Tree:
			class Solution{
				public:
				void BuildSegTree(int i, int s, int e, vector<int> &ST, int arr[]){
					if(s == e){
						ST[i] = arr[s];
						return ;
					}
					int mid = s+(e-s)/2;
					BuildSegTree(2*i+1, s, mid, ST, arr);
					BuildSegTree(2*i+2, mid+1, e, ST, arr);
					
					ST[i] = ST[2*i+1] + ST[2*i+2];
				}

				int Query(int l, int r, int s, int e, int rootStartIndex, vector<int> &ST){
					if(r < s || l > e)
						return 0;
					
					if(l <= s && e <= r)
						return ST[rootStartIndex];
					
					int mid = s + (e - s)/2;
					return Query(l, r, s, mid, 2*rootStartIndex+1, ST) + Query(l, r, mid+1, e, 2*rootStartIndex+2, ST);
				}

				vector<int> querySum(int n, int arr[], int q, int queries[]) {
					vector<int> result;
					vector<int> segmentTree(4*n, 0);
					
					// according to root
					BuildSegTree(0, 0, n-1, segmentTree, arr);
					
					for(int i=0; i<(2*q); i+=2){
						int l = queries[i]-1, r =queries[i+1]-1;
						result.push_back(Query(l, r, 0, n-1, 0, segmentTree));
					}
					return result;
				}
			};			
		
	1076) Range Minimum Query:
		Problem statement:
			Given an array A[ ] and its size N your task is to complete two functions  a constructST  function which builds the segment tree  and a function RMQ which finds range minimum query in a range [a,b] of the given array.
			Input:
			The task is to complete two functions constructST and RMQ.
			The constructST function builds the segment tree and takes two arguments the array A[ ] and the size of the array N.
			It returns a pointer to the first element of the segment tree array.
			The RMQ function takes 4 arguments the first being the segment tree st constructed, second being the size N and then third and forth arguments are the range of query a and b. The function RMQ returns the min of the elements in the array from index range a and b. There are multiple test cases. For each test case, this method will be called individually.

			Output:
				The function RMQ should return the min element in the array from range a to b.

			Example:
			Input (To be used only for expected output) 
				1
				4
				1 2 3 4
				2
				0 2 2 3
				Output
				1 3
				Explanation
				1. For query 1 ie 0 2 the element in this range are 1 2 3 
				and the min element is 1. 
				2. For query 2 ie 2 3 the element in this range are 3 4 
				and the min element is 3.
				Constraints:
				1<=T<=100
				1<=N<=10^3+1

				1<=A[i]<=10^9
				1<=Q(no of queries)<=10000
				0<=a<=b

		void BuildSegmentTree(int s, int e, int NodeIndex, int segmentTree[], int arr[]){
			if(s == e){
				segmentTree[NodeIndex] = arr[e];
				return ;
			}
			int mid = s + (e - s)/2;
			
			BuildSegmentTree(s, mid, 2*NodeIndex+1, segmentTree, arr);
			BuildSegmentTree(mid+1, e, 2*NodeIndex+2, segmentTree, arr);
			segmentTree[NodeIndex] = min(segmentTree[2*NodeIndex+1], segmentTree[2*NodeIndex+2]);
		}

		int *constructST(int arr[],int n) {
			int *segmentTree = new int[4*n];
			
			BuildSegmentTree(0, n-1, 0, segmentTree, arr);
			return segmentTree;
		}

		int minElement(int start, int end, int curIndex, int RangeStart, int RangeEnd, int st[]){
			if(RangeStart > end || RangeEnd < start)
				return INT_MAX;
			
			if(RangeStart <= start && RangeEnd >= end)
				return st[curIndex];
			
			int mid = start + (end - start)/2;
			return min(minElement(start, mid, 2*curIndex+1, RangeStart, RangeEnd, st), minElement(mid+1, end, 2*curIndex+2, RangeStart, RangeEnd, st));
		}

		/* The functions returns the min element in the range from a and b */
		int RMQ(int st[] , int n, int a, int b) {
			return minElement(0, n-1, 0, a, b, st);
		}

	#LeetCode WeeklyContest-411:
		1077) Count Substrings That Satisfy K-Constraint I:
			Problem statement:
				You are given a binary string s and an integer k.
				A binary string satisfies the k-constraint if either of the following conditions holds:
					The number of 0's in the string is at most k.
					The number of 1's in the string is at most k.
				Return an integer denoting the number of substrings of s that satisfy the k-constraint.

				Example 1:
				Input: s = "10101", k = 1
				Output: 12
				Explanation:
				Every substring of s except the substrings "1010", "10101", and "0101" satisfies the k-constraint.

				Example 2:
				Input: s = "1010101", k = 2
				Output: 25
				Explanation:
				Every substring of s except the substrings with a length greater than 5 satisfies the k-constraint.

				Example 3:
				Input: s = "11111", k = 1
				Output: 15
				Explanation:
				All substrings of s satisfy the k-constraint.

				Constraints:
					1 <= s.length <= 50 
					1 <= k <= s.length
					s[i] is either '0' or '1'.
		
			// Brute Force (Simple):
				class Solution {
					public:
					int count(string s){
						int zCount, oCount;
						zCount = oCount = 0;

						for(char c: s)
							if(c == '1')
								oCount++;
							else
								zCount++;

						return min(zCount, oCount);
					}
					int countKConstraintSubstrings(string s, int k) {
						// generate substring & then check every string
						int total = s.length();
						for(int i=0; i < s.length(); i++) {
							string cur = string(1,s[i]);
							for(int j=i+1; j < s.length(); j++) {
								cur += s[j];
								if(count(cur) > k)
									break;
								total++;
							}
						}
						return total;
					}
				};

			// More Optimized (Sliding Window Technique):
				auto speedUp = [](){
					ios_base::sync_with_stdio(0);
					cin.tie(0);
					cout.tie(0);
					return 0;
				};

				class Solution {
					public:
					int countKConstraintSubstrings(string s, int k) {
						int i,j, n = s.size();
						i = j = 0;
						int cnt=0;

						int zCount, oCount;
						zCount = oCount = 0;

						while(j < n) {
							(s[j] == '1') ? oCount++ : zCount++;

							while(zCount > k && oCount > k){
								(s[i] == '1') ? oCount-- : zCount--;
								i++;
							} 
							cnt += j - i + 1;
							j++;
						}
						return cnt;
					}
				};
				
		1078) Count Substrings That Satisfy K-Constraint II:
			Problem statement:
				You are given a binary string s and an integer k.
				You are also given a 2D integer array queries, where queries[i] = [li, ri].
				A binary string satisfies the k-constraint if either of the following conditions holds:
					The number of 0's in the string is at most k.
					The number of 1's in the string is at most k.
				Return an integer array answer, where answer[i] is the number of substrings of s[li..ri] that satisfy the k-constraint.

				Example 1:
				Input: s = "0001111", k = 2, queries = [[0,6]]
				Output: [26]
				Explanation:
				For the query [0, 6], all substrings of s[0..6] = "0001111" satisfy the k-constraint except for the substrings s[0..5] = "000111" and s[0..6] = "0001111".

				Example 2:
				Input: s = "010101", k = 1, queries = [[0,5],[1,4],[2,3]]
				Output: [15,9,3]
				Explanation:
				The substrings of s with a length greater than 3 do not satisfy the k-constraint.

				Constraints:
					1 <= s.length <= 10^5
					s[i] is either '0' or '1'.
					1 <= k <= s.length
					1 <= queries.length <= 10^5
					queries[i] == [li, ri]
					0 <= li <= ri < s.length
					All queries are distinct.

			// Not Optimized:
				class Solution {
					public:
					long long Count(string s) {
						long long zCount, oCount;
						zCount = oCount = 0;
						for(char ch: s)
							(ch == '1') ? oCount++ : zCount++;

						return min(zCount, oCount);
					}
					vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
						vector<long long> ans;
						int n = queries.size();
						for(int i=0; i<n; i++){
							int l=queries[i][0], r = queries[i][1];

							int curCharCount = r - l + 1;
							string t = s.substr(l, curCharCount);
							long long total = curCharCount;
							// cout<<t<<"\t";

							for(int x=0; x < t.size(); x++){
								string z = string(1, t[x]);
								for(int y=x+1; y < t.size(); y++){
									z += t[y];
									// cout<<z<<"\t";
									if(Count(z) > k)
										break;
									total++;
								}
							}
							ans.push_back(total);
						}
						return ans;
					}
				};
		
			// Not Optimized (Sliding Window):
				class Solution {
					public:
					vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
						vector<long long> ans;
						for(auto query: queries){
							int l = query[0], r = query[1];
							int totalChar = r - l + 1;

							string t = s.substr(l, totalChar);
							int i, j, zCount, oCount, n = t.size();
							i = j = zCount = oCount = 0;

							long long cnt =0;
							while(j < n){
								(t[j] == '1') ? oCount++ : zCount++;
								
								while(zCount > k && oCount > k){
									(t[i] == '1') ? oCount-- : zCount--;
									i++;
								}
								cnt += j - i + 1;
								j++;
							}
							ans.push_back(cnt);
						}
						return ans;
					}
				};

			// Optimized:
				❌Pending

	1079) Maximum prefix sum for a given range:
		Problem statement:
			Given an array of N integers and Q queries, each query having a range from index L to R. Find the maximum prefix-sum for the range L to R.
			Note: Assume 0 based indexing.
			Example 1:
				Input: 
				a[ ] = {-1, 2, 3, -5} 
				Q = 2
				L1 = 0, R1 = 3
				L2 = 1, R2 = 3
				Output:
				4 5
				Explanation:
				The range (0, 3) in the 1st query is {-1, 2, 3, -5}, hence, 
				the max prefix-sum will be -1 + 2 + 3 = 4. The range (1, 3) 
				in the 2nd query is {2, 3, -5}, hence, the max prefix-sum 
				will be 2 + 3 = 5.
			Your Task:  
				You don't need to read input or print anything. Your task is to complete the function maxPrefixes() which takes the array A[], its size N, array L[] and R[] and their size Q as input parameters and returns a vector storing the required answer for every query.

			Expected Time Complexity: O(N*Q)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 10^4
				-10^4 ≤ A[i]≤ 10^4
				1 ≤ Q ≤ 10^4
				0 ≤ L[i] ≤ R[i] < N

		class Solution{
			public:
			vector<int> maxPrefixes(int a[], int L[], int R[], int N, int Q) {
				vector<int> ans;
				
				for(int i=0; i<Q; i++){
					int l = L[i], r = R[i], s=0, mx=INT_MIN;
					for(int j=l; j<=r; j++){
						s += a[j];
						mx = max(s, mx);
					}
					ans.push_back(mx);   
				}
				return ans;
			}
		};

	1080) Number Complement:
		Problem statement:
			The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.
			For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
			Given an integer num, return its complement.		

			Example 1:
				Input: num = 5
				Output: 2
				Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.

			Example 2:
				Input: num = 1
				Output: 0
				Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
			
			Constraints:
				1 <= num < 2^31
				Note: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/

		class Solution {
			public:
			int findComplement(int num) {
				string s;
				while(num){
					// char bit = ((num & 1) == 1 ? '0' : '1');
					// s += bit;
					
					s += ((num & 1) == 1 ? '0' : '1');
					num >>=1;
				}
				reverse(s.begin(), s.end());
				cout<<s<<"\t";
				return stoi(s, 0, 2);
			}
		};

	1081) Complement of Base 10 Integer:
		Problem statement:
			The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.
			For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
			Given an integer n, return its complement.
			Example 1:
				Input: n = 5
				Output: 2
				Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
			Example 2:
				Input: n = 7
				Output: 0
				Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
			Example 3:
				Input: n = 10
				Output: 5
				Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.
			
			Constraints:
				0 <= n < 10^9
				Note: This question is the same as 476: https://leetcode.com/problems/number-complement/

		class Solution {
			public:
			int bitwiseComplement(int n) {
				if(n == 0) return 1;
				string s;
				while(n){
					s += (n&1) ? '0' : '1';
					n >>= 1;
				}
				reverse(s.begin(), s.end());
				return stoi(s, 0, 2);
			}
		};

	#LeetCode BiweeklyContest-137:
		1082) Find the Power of K-Size Subarrays I:
			Problem statement:
				You are given an array of integers nums of length n and a positive integer k.
				The power of an array is defined as:
					Its maximum element if all of its elements are 'consecutive' and 'sorted in ascending order'.
					-1 otherwise.
				You need to find the power of all subarrays of nums of size k.
				Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].

				Example 1:
					Input: nums = [1,2,3,4,3,2,5], k = 3
					Output: [3,4,-1,-1,-1]
				Explanation:
					There are 5 subarrays of nums of size 3:
					[1, 2, 3] with the maximum element 3.
					[2, 3, 4] with the maximum element 4.
					[3, 4, 3] whose elements are not consecutive.
					[4, 3, 2] whose elements are not sorted.
					[3, 2, 5] whose elements are not consecutive.

				Example 2:
				Input: nums = [2,2,2,2,2], k = 4
				Output: [-1,-1]

				Example 3:
				Input: nums = [3,2,3,2,3,2], k = 2
				Output: [-1,3,-1,3,-1]

				Constraints:
					1 <= n == nums.length <= 500
					1 <= nums[i] <= 10^5
					1 <= k <= n
			
			class Solution {
				public:
				vector<int> resultsArray(vector<int>& nums, int k) {
					int n = nums.size();
					vector<int> ans (n-k+1, -1);

					for(int i=0; i<=(n-k); i++) {
						int flag = 1;
						for(int j=i; j < (i+k) - 1; j++) {
							if(nums[j] != nums[j+1]-1){
								flag = 0;
								break;
							}
						}
						if(flag) ans[i] = nums[i+k-1];
					}
					return ans;
				}
			};

			// Or
				class Solution {
					public:
					bool areConsecutive(vector<int>&a, int s, int e){
						for(int i=s; i<e; i++)
							if(a[i] != a[i+1]-1)
								return 0;
						return 1;
					}
					
					vector<int> resultsArray(vector<int>& nums, int k) {
						int n = nums.size();
						vector<int> ans (n-k+1, -1);

						for(int i=0; i<(n-k+1); i++)
							if(areConsecutive(nums, i, i+k-1)) ans[i] = nums[i+k-1];
							
						return ans;
					}
				};

			// More Optimized: (Sliding window approach) ❌Pending
				class Solution {
					public:
					vector<int> resultsArray(vector<int>& nums, int k) {
						if(k == 1) return nums;

						int n = nums.size();
						vector<int> ans (n-k+1, -1);

						int score=0;
						for(int i=1; i<n; i++){
							if(nums[i] != nums[i-1]+1)
								score=0;
							else
								score++;
							if(score >= k-1) ans[i-k+1] = nums[i];
						}
						return ans;
					}
				};

		1083) Find the Power of K-Size Subarrays II:
			Problem statement:
				You are given an array of integers nums of length n and a positive integer k.
				The power of an array is defined as:
					Its maximum element if all of its elements are consecutive and sorted in ascending order.
					-1 otherwise.
				You need to find the power of all subarraysof nums of size k.
				Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].
				Example 1:
					Input: nums = [1,2,3,4,3,2,5], k = 3
					Output: [3,4,-1,-1,-1]
					Explanation:
					There are 5 subarrays of nums of size 3:
					[1, 2, 3] with the maximum element 3.
					[2, 3, 4] with the maximum element 4.
					[3, 4, 3] whose elements are not consecutive.
					[4, 3, 2] whose elements are not sorted.
					[3, 2, 5] whose elements are not consecutive.

				Example 2:
					Input: nums = [2,2,2,2,2], k = 4
					Output: [-1,-1]
				Example 3:
					Input: nums = [3,2,3,2,3,2], k = 2
					Output: [-1,3,-1,3,-1]

				Constraints:
					1 <= n == nums.length <= 10^5
					1 <= nums[i] <= 10^6
					1 <= k <= n

			// Not Optimized:
				class Solution {
					public:
					vector<int> resultsArray(vector<int>& nums, int k) {
						int n = nums.size();
						vector<int> res(n-k+1, -1);

						for(int i=0; i<(n-k+1); i++) {
							int flag =1;
							for(int j=i; j < (i+k-1); j++){
								if(nums[j] != nums[j+1]-1){
									flag=0;
									break;
								}
							}
							if(flag) res[i] = nums[i+k-1];  
						}
						return res;
					}
				};
			
			// Optimized: ❌Pending
				class Solution {
					public:
					vector<int> resultsArray(vector<int>& nums, int k) {
						if(k == 1) return nums;

						int n = nums.size();
						vector<int> ans (n-k+1, -1);

						int score=0;
						for(int i=1; i<n; i++){
							if(nums[i] != nums[i-1]+1)
								score=0;
							else
								score++;
							if(score >= k-1) ans[i-k+1] = nums[i];
						}
						return ans;
					}
				};
			
	1084) Binary Tree Postorder Traversal:
		Problem statement:
			Given the root of a binary tree, return the postorder traversal of its nodes' values.
			Example 1:
				Input: root = [1,null,2,3]
				Output: [3,2,1]
			Example 2:
				Input: root = []
				Output: []
			Example 3:
				Input: root = [1]
				Output: [1]
			
			Constraints:
				The number of the nodes in the tree is in the range [0, 100].
				-100 <= Node.val <= 100
			Follow up: Recursive solution is trivial, could you do it iteratively?

		/**
			* Definition for a binary tree node.
			* struct TreeNode {
			*     int val;
			*     TreeNode *left;
			*     TreeNode *right;
			*     TreeNode() : val(0), left(nullptr), right(nullptr) {}
			*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
			*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
			* };
		*/
		class Solution {
			public:
			void Traverse(vector<int> &a, TreeNode *root) {
				if(!root) return ;

				Traverse(a, root -> left);
				Traverse(a, root -> right);
				a.push_back(root -> val);
			}
			vector<int> postorderTraversal(TreeNode* root) {
				vector<int> ans;
				Traverse(ans, root);
				return ans;
			}
		};

	1085) Find length of Loop:
		Problem statement:
			Given the head of a linked list, determine whether the list contains a loop. If a loop is present, return the number of nodes in the loop, otherwise return 0.
			Note: 'c' is the position of the node which is the next pointer of the last node of the linkedlist. If c is 0, then there is no loop.
			Examples:
			Input: LinkedList: 25->14->19->33->10->21->39->90->58->45, c = 4
			Output: 7
			Explanation: The loop is from 33 to 45. So length of loop is 33->10->21->39-> 90->58->45 = 7. 
			The number 33 is connected to the last node of the linkedlist to form the loop because according to the input the 4th node from the beginning(1 based indexing) 
			will be connected to the last node for the loop.
			
			Input: LinkedList: 5->4, c = 0
			Output: 0
			Explanation: There is no loop.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= no. of nodes <= 10^6
				0 <= node.data <=10^6
				0 <= c<= n-1

		/*
			struct Node {
					int data;
					struct Node *next;
				Node(int x) {
					data = x;
					next = NULL;
				}
			};
		*/
		class Solution {
			public:
			// Function to find the length of a loop in the linked list.
			int countNodesinLoop(Node *head) {
				// checking is there a loop in list
				Node* fast = head -> next;
				Node* slow = head;
				
				int flag = 0;
				while(fast && fast -> next){
					if(fast == slow){
						flag = 1;
						break;
					}
					fast = fast -> next -> next;
					slow = slow -> next;
				}
				
				// if there is no loop in list
				if(!flag) return 0;
				
				// if there is loop in list
				fast = fast -> next;
				int cnt=1;
				while(fast != slow){
					fast = fast -> next;
					cnt++;
				}
				return cnt;
			}
		};
	
	#LeetCode WeeklyContest-415:
		1086) The Two Sneaky Numbers of Digitville:
			Problem Statement:
				In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual.
				As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.		

				Example 1:
					Input: nums = [0,1,1,0]
					Output: [0,1]
					Explanation:
					The numbers 0 and 1 each appear twice in the array.

				Example 2:
					Input: nums = [0,3,2,1,3,2]
					Output: [2,3]
					Explanation:
					The numbers 2 and 3 each appear twice in the array.

				Example 3:
					Input: nums = [7,1,5,4,3,4,6,0,9,5,8,2]
					Output: [4,5]
					Explanation:
					The numbers 4 and 5 each appear twice in the array.

				Constraints:
					2 <= n <= 100
					nums.length == n + 2
					0 <= nums[i] < n
					The input is generated such that nums contains exactly two repeated elements.

			class Solution {
				public:
				vector<int> getSneakyNumbers(vector<int>& nums) {
					vector<int> ans;
					sort(nums.begin(), nums.end());        
					int n = nums.size();

					for(int i=1; i<n; i++)
						if(nums[i] == nums[i-1])
							ans.push_back(nums[i]);
						else if(ans.size() >= 2)
							break;
					
					return ans;
				}
			};

			class Solution {
				public:
				vector<int> getSneakyNumbers(vector<int>& nums) {
					vector<int> ans;
					map<int, int> Fr;

					for(int i: nums)
						Fr[i]++;
					
					for(auto i: Fr)
						if(i.second == 2)
							ans.push_back(i.first);

					return ans;
				}
			};

		1087) Maximum Multiplication Score:
			Problem Statement:
				You are given an integer array a of size 4 and another integer array b of size at least 4.
				You need to choose 4 indices i0, i1, i2, and i3 from the array b such that i0 < i1 < i2 < i3. Your score will be equal to the value a[0] * b[i0] + a[1] * b[i1] + a[2] * b[i2] + a[3] * b[i3].
				Return the maximum score you can achieve.
				Example 1:
					Input: a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]
					Output: 26
					Explanation:
					We can choose the indices 0, 1, 2, and 5. The score will be 3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26.

				Example 2:
					Input: a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]
					Output: -1
					Explanation:
					We can choose the indices 0, 1, 3, and 4. The score will be (-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1.

				Constraints:
					a.length == 4
					4 <= b.length <= 10^5
					-10^5 <= a[i], b[i] <= 10^5

			// Not Optimized:
				class Solution {
					public:
					long long maxScore(vector<int>& a, vector<int>& b) {
						long long mx = INT_MIN;
						int n = b.size();

						for(int i=0; i<=(n-4); i++)
							for(int j=i+1; j<=(n-3); j++)
								for(int k=j+1; k<=(n-2); k++){
									for(int l=k+1; l<=(n-1); l++){
										long long v = (a[0] * b[i]) + (a[1] * b[j]) + (a[2] * b[k]) + (a[3] * b[l]);
										if(v > mx)
											mx = v;
									}
								}        
						return mx;
					}
				};
			
			// Optimized:
				❌Pending
			
	#LeetCode BiweeklyContest-139:
		1088) Find Indices of Stable Mountains
			Problem statement:
				There are n mountains in a row, and each mountain has a height. You are given an integer array height where height[i] represents the height of mountain i, and an integer threshold.
				A mountain is called stable if the mountain just before it (if it exists) has a height strictly greater than threshold. Note that mountain 0 is not stable.
				Return an array containing the indices of all stable mountains in any order.		
				Example 1:
				Input: height = [1,2,3,4,5], threshold = 2
				Output: [3,4]
				Explanation:
					Mountain 3 is stable because height[2] == 3 is greater than threshold == 2.
					Mountain 4 is stable because height[3] == 4 is greater than threshold == 2.
				Example 2:
					Input: height = [10,1,10,1,10], threshold = 3
					Output: [1,3]
				Example 3:
					Input: height = [10,1,10,1,10], threshold = 10
					Output: []

				Constraints:
					2 <= n == height.length <= 100
					1 <= height[i] <= 100
					1 <= threshold <= 100
			
			class Solution {
				public:
				vector<int> stableMountains(vector<int>& height, int threshold) {
					vector<int> stableCnt;
					int n = height.size();

					for(int i=1; i<n; i++){
						if(height[i-1] > threshold)
							stableCnt.push_back(i);
					}
					return stableCnt;
				}
			};
		
	1089) K-th Smallest in Lexicographical Order:
		Problem statement:
			Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].
			Example 1:
				Input: n = 13, k = 2
				Output: 10
				Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
			Example 2:
				Input: n = 1, k = 1
				Output: 1
			Constraints:
				1 <= k <= n <= 10^9
		
		// Not Optimized:
			class Solution {
				public:
				int findKthNumber(int n, int k) {
					vector<int> hold;
					for(int i=1; i<=n; i++)
						hold.push_back(i);

					vector<string> str_hold;
					for(int i=1; i<=n; i++){
						string s = to_string(hold[i-1]);
						str_hold.push_back(s);
					}
					sort(begin(str_hold), end(str_hold));
					return stoi(str_hold[k-1]);
				}
			};

		// Little bit Optimized (Memory Limit Exceeded [MLE]):
			class Solution {
				public:
				void solve(int currNum, int n, vector<int> &ans){
					if(currNum > n) return ;
					ans.push_back(currNum);
					
					for(int i=0; i<10; i++){
						int newN = currNum*10 + i;
						if(newN > n) return ;
						solve(newN, n, ans);
					}
				}
				int findKthNumber(int n, int k) {
					vector<int> res;
					for(int i=1; i<10; i++)
						solve(i, n, res);
					
					return res[k-1];
				}
			};

		// Optimized:
			❌Pending

	#LeetCode WeeklyContest-416:
		1090) Report Spam Message:
			Problem statement:
				You are given an array of strings message and an array of strings bannedWords.
				An array of words is considered spam if there are at least two words in it that exactly match any word in bannedWords.
				Return true if the array message is spam, and false otherwise.
				
				Example 1:
					Input: message = ["hello","world","leetcode"], bannedWords = ["world","hello"]
					Output: true
					Explanation:
					The words "hello" and "world" from the message array both appear in the bannedWords array.

				Example 2:
					Input: message = ["hello","programming","fun"], bannedWords = ["world","programming","leetcode"]
					Output: false
					Explanation:
					Only one word from the message array ("programming") appears in the bannedWords array.

				Constraints:
					1 <= message.length, bannedWords.length <= 10^5
					1 <= message[i].length, bannedWords[i].length <= 15
					message[i] and bannedWords[i] consist only of lowercase English letters.

			class Solution {
				public:
				bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
					map<string, int> Fr;
					for(string s: message)
						Fr[s]++;
					
					set<string> s(bannedWords.begin(), bannedWords.end());

					int cnt=0;
					for(auto it: s){
						if(Fr[it] >= 2)
							return 1;

						if(Fr[it] >= 1)
							cnt++;

						if(cnt >= 2)
							return 1;
					}
					return 0;
				}
			};

	1091) Rank Transform of an Array:
		Problem Statement:
			Given an array of integers arr, replace each element with its rank.
			The rank represents how large the element is. The rank has the following rules:
			Rank is an integer starting from 1.
			The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
			Rank should be as small as possible.
		
			Example 1:
			Input: arr = [40,10,20,30]
			Output: [4,1,2,3]
			Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.

			Example 2:
			Input: arr = [100,100,100]
			Output: [1,1,1]
			Explanation: Same elements share the same rank.

			Example 3:
			Input: arr = [37,12,28,9,100,56,80,5,12]
			Output: [5,3,4,2,8,6,7,1,3]
			
			Constraints:
				0 <= arr.length <= 10^5
				-10^9 <= arr[i] <= 10^9

		// Not Optimized:
			class Solution {
				public:
				vector<int> arrayRankTransform(vector<int>& arr) {
					vector<int> t = arr;
					sort(t.begin(), t.end());

					vector<int> rankStore;
					int n = arr.size();
					int cnt=0;

					for(int i=0; i<n; i++){
						if(i==0){
							cnt++;
							rankStore.push_back(cnt);
						}else{
							if(t[i-1] == t[i]){
								rankStore.push_back(cnt);
							}else{
								cnt++;
								rankStore.push_back(cnt);
							}
						}
					}

					vector<int> ans(n);
					for(int i=0; i<n; i++){
						int val = t[i], rank = rankStore[i];
						for(int j=0; j<n; j++){
							if(arr[j] == val)
								ans[j] = rank;
						}
					}
					return ans;  
				}
			};
		
		// Optimized:
			❌Pending

	#GFG Weekly-176:
		1092) Geek String:
			Problem Statement:
				You are given a string s consisting of lowercase English letters. Your task is to determine if there exists a subsequence in s that matches the string "geek".
				A subsequence is a sequence that can be derived from another string by deleting some or no elements without changing the order of the remaining elements.
				Return true if there is a subsequence of "geek" in the given string, otherwise return false.
				Example 1:
					Input:
					s = "abcgeekd"
					Output: 
					true
					Explanation: 
					The subsequence "geek" appears in the string s, abcgeekd. Hence, we return true
				Example 2:
					Input:
					s = "abcgreed"
					Output: 
					false
					Explanation: 
					There is no subsequence of "geek" present in the string. Hence, we return false

				Your Task:
					You don’t need to read input or print anything. Your task is to implement the function hasGeekSubsequence. This function should take a string s as input and return a boolean value True if the subsequence "geek" exists, otherwise False.

				Constraints:
					1 ≤ |s| ≤ 10^5
					The input string s consists only of lowercase English letters.

			class Solution {
				public:
				bool hasGeekSubsequence(string str) {
					string s = "geek";
					int i=0;
					for(char ch:str)
						if(ch == s[i]) i++;
					return (i < 4) ? 0: 1;
				}
			};

		1093) Palindromic Substrings:
			Problem Statement:
				Given a string s and an integer k, your task is to find the total number of substrings of length k in s such that the characters in the substring can be rearranged to form a palindrome. A string is called a palindrome if it reads the same backward as forward.
				Example 1:
				Input:
				s = "aabb"
				k = 2
				Output: 
				2
				Explanation: 
				The substrings of length 2 are: “aa”, “ab”, “bb”. Out of these, “aa” and “bb” can be rearranged to form a palindrome.

				Example 2:
				Input:
				s = "abcde"
				k = 3
				Output: 
				0
				Explanation: 
				The substrings of length 3 are: “abc”, “bcd”, “cde”. None of these can be rearranged to form a palindrome.

				Your Task:
					You don’t need to read input or print anything. Your task is to complete the function countPalindromicSubstrings which takes the string s and the integer k as input and returns the total number of substrings of length k in which the characters can be rearranged to form a palindrome.

				Constraints:
					1 ≤ len(s) ≤ 10^5
					1 ≤ k ≤ len(s)
					The input strings consists only of lowercase English letters.

			// Not Optimized:
				class Solution {
					public:
					bool CanBePalin_AfterReArrangement(string &s){
						// here the logic is there should be every char in even number of times, 
						// except any one char in odd number of times in string s to satisfy this palindromic condition
						map<char, int> CharCnt;
						for(char ch: s)
							CharCnt[ch]++;
						
						// keep track of chars occurs in odd no.of times, ideally there should be one char only.
						int oddTimes = 0;
						for(auto i: CharCnt)
							if(i.second&1)
								oddTimes++;
						
						return (oddTimes > 1) ? 0 : 1;
					}
					int countPalindromicSubstrings(string str, int k) {
						// window size will be k
						int s = 0, n=str.size(), cnt=0;
						while(s <= (n-k)){
							string t = str.substr(s, k);
							// cout<<t <<"\t"<< s << "\t" <<endl;
							if(CanBePalin_AfterReArrangement(t)) cnt++;
							s++;
						}
						return cnt;
					}
				};
			
			// Optimized: (Sliding Window)
				class Solution {
					public:
					bool isReArranged_Palindrom(auto map){
						int oddTimes=0;
						for(auto i: map)
							if(i.second&1) oddTimes++;
							
						return (oddTimes > 1) ? 0 : 1;
					}
					int countPalindromicSubstrings(string s, int k) {
						map<char, int> Fr;
						int cnt=0, i = 0, n=s.size();
						
						// created first window
						while(i < k)
							Fr[s[i++]]++;
							
						if(isReArranged_Palindrom(Fr)) cnt++;

						int j=0;
						while(i < n){
							Fr[s[i++]]++;
							Fr[s[j++]]--;
							if(isReArranged_Palindrom(Fr)) cnt++;
						}
						return cnt;
					}
				};

			// Without using map:
				class Solution {
					public:
					bool ReArrangement_can_form_palindrome(vector<int> &freq){
						// this loop always runs 26 times, coz size of freq is 26.
						int oddCnt=0;
						for(int i: freq)
							if(i&1) oddCnt++;
						
						return (oddCnt > 1) ? 0 : 1;
					}
					int countPalindromicSubstrings(string s, int k) {	
						// default value for all char occurrence is 0
						vector<int> freq(26, 0);        // string only contains the 26 alphabates, mapper
						
						// creating first window
						int i, cnt=0;
						for(i=0; i<k; i++)
							freq[s[i] - 'a']++;                     // s[i] is 'a' then this will map to 0.
						
						if(ReArrangement_can_form_palindrome(freq)) cnt++;
						int n=s.size();
						
						while(i < n){
							freq[s[i] - 'a']++;
							freq[s[i-k] - 'a']--;
							
							if(ReArrangement_can_form_palindrome(freq)) cnt++;
							i++;
						}
						return cnt;
					}
				};

		1094) Odd Subarrays:
			Problem Statement:
				Given an array arr, return the count of even-length subarrays that contain an odd number of odd elements.
				Example 1:
				Input:
				n = 3
				arr = [1, 2, 3]
				Output: 
				2
				Explanation: 
				The subarrays of even length are [1, 2] and [2, 3]. Both contain exactly 1 odd element.

				Example 2:
				Input:
				n = 5
				arr = [4, 2, 3, 2, 1]
				Output: 
				4
				Explanation: 
				Subarrays are [4,2,3,2] (1 odd element and length 4),
				[2,3], [3,2], [2,1] (1 odd element and length 2).
				Your Task:
					You don't need to read input or print anything. Your task is to complete the function countoddSubarrays() which takes integer n and an array arr as input and returns the count of subarrays with even length having odd number of odd elements.
				Constraints:
					1 ≤ n ≤ 10^5
					1 ≤ arr[i] ≤ 10^9

			// Not Optimized: TC: O(n³)
				class Solution {
					public:
					bool checkOddSubArray(vector<int> &n){
						int oddTimes=0;
						for(int i: n)
							if(i&1)
								oddTimes++;		
						return (oddTimes&1) ? 1 : 0;
					}
					long long countoddSubarrays(int n, vector<int> &arr) {
						long long ans=0;
						for(int i=0; i < (n-1); i++){                   // or for(int i=0; i <= (n-2); i++)    
							int j = i;
							vector<int> t;
							for(j; j<n; j+=2){
								t.push_back(arr[j]);
								if(j+1 < n){
									t.push_back(arr[j+1]);
									if(checkOddSubArray(t)) ans++;
								}
							}
						}   
						return ans;
					}
				};

			// Not Optimized: TC: O(n²)
				class Solution {
					public:
					long long countoddSubarrays(int n, vector<int> &arr) {
						long long ans =0;
						
						for(int i=0; i<n; i++){
							
							int oddElementCnt=0;
							for(int j=i; j<n; j+=2){
								if(arr[j]&1) oddElementCnt++;
								
								// this will always ensure that the size of subarray will always even
								if(j+1 >= n)
								break;
								
								if(arr[j+1]&1)
								oddElementCnt++;

								if(oddElementCnt&1) ans++;
							}
						}
						return ans;
					}
				};

			// Optimized:
				❌Pending

		1095) Subarray Occurences:
			Problem Statement:
				You are given an array arr of length n, and you are provided with q queries. Each query is in the form of three integers L, R, and K. Your task is to count the occurrences of the integer K in the subarray of arr ranging from index L to R (both inclusive). You should return an answer array of size q containing the answer for each query where ith index in the answer array denotes the answer for the ith query.
				Example 1:
				Input:
				n = 7
				q = 2
				arr = [1, 2, 2, 3, 2, 4, 1]
				queries = [[1, 4, 2], [0, 6, 1]]
				Output: 
				[3,2]
				Explanation: 
				For the first query [1, 4, 2], the subarray from index 1 to 4 is [2, 2, 3, 2]. The number '2' appears 3 times.
				For the second query [0, 6, 1], the subarray from index 0 to 6 is [1, 2, 2, 3, 2, 4, 1]. The number '1' appears 2 times.

				Example 2:
				Input:
				n = 4
				q = 3
				arr = [5, 5, 5, 5]
				queries = [[0, 3, 5], [1, 2, 5], [0, 1, 6]]
				Output: 
				[4,2,0]
				Explanation: 
				For the first query [0, 3, 5], the subarray is [5, 5, 5, 5], and '5' appears 4 times.
				For the second query [1, 2, 5], the subarray is [5, 5], and '5' appears 2 times.
				For the third query [0, 1, 6], the subarray is [5, 5], and '6' does not appear, so the answer is 0.
				Your Task:
					You need to implement the function countOccurrences. For each query, you need to count the occurrences of the integer K in the subarray of arr ranging from index L to R (both inclusive), and return a list of size q where each element corresponds to the answer for that query.

				Constraints:
					1 ≤ n ≤ 10^5: The length of the array arr.
					1 ≤ q ≤ 10^5: The number of queries.
					0 ≤ l ≤ r < n: Valid range for the subarray.
					0 ≤ k ≤ 10^9: The value of k for each query.

			// Not Optimized:
				class Solution {
					public:
					vector<int> countOccurrences(int n, int q, vector<int> &arr, vector<vector<int>> &queries) {
						vector<int> ans;
						for(auto i: queries){
							int l = i[0], r=i[1], k=i[2], cnt=0;
							for(int j=l; j <= r; j++)
								if(arr[j] == k) cnt++;
							ans.push_back(cnt);
						}
						return ans;
					}
				};

			// Optimized:
				❌Pending

	1096) Inorder Traversal:
		https://www.naukri.com/code360/problems/inorder-traversal_3839605
		Problem Statement:
			You have been given a Binary Tree of 'n' nodes, where the nodes have integer values. Your task is to return the In-Order traversal of the given binary tree.
			For example :
			For the given binary tree:
				  1
				/   \
			    3     4
			   / \   / \
			  5   2 7   8
			The Inorder traversal will be [5, 3, 2, 1, 7, 4, 6].
			Sample Input 1 :
			1 2 3 -1 -1 -1  6 -1 -1
			Sample Output 1 :
			2 1 3 6
			Explanation of Sample Output 1 :
			The given binary tree is shown below:
				 1
				/ \
			    2   3
				    \
					6
			Inorder traversal of given tree = [2, 1, 3, 6]
			Sample Input 2 :
			1 2 4 5 3 -1 -1 -1 -1 -1 -1
			Sample Output 2 :
			5 2 3 1 4
			Explanation of Sample Output 2 :
			The given binary tree is shown below:
				 1
				/ \
			    2   4
			   / \
			  5   3

			Inorder traversal of given tree = [5, 2, 3, 1, 4]
			Expected time complexity: The expected time complexity is O(n).
			Constraints :
				1 <= 'n' <= 10^5
				0 <= 'data' <= 10^5     
			where 'n' is the number of nodes and 'data' denotes the node value of the binary tree nodes.
			Time limit: 1 sec
		/*
		Following is Binary Tree Node structure:
			class TreeNode {
				public:
				int data;
				TreeNode *left, *right;
				TreeNode() : data(0), left(NULL), right(NULL) {}
				TreeNode(int x) : data(x), left(NULL), right(NULL) {}
				TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
			};
		*/
		vector<int> getInOrderTraversal(TreeNode *root) {
			vector<int> ans;
			if(!root) return ans;
			stack<TreeNode*> st;

			while(root or !st.empty()){
				while(root){
					st.push(root);
					root = root -> left;            
				}
				TreeNode* cur = st.top();
				st.pop();
				
				ans.push_back(cur -> data);
				cur = cur -> right;
				root = cur;
			}
			return ans;
		}

	1097) Occurence of an integer in a Linked List:
		Problem Statement:
			Given a singly linked list and a key, count the number of occurrences of the given key in the linked list.
			Examples:
			Input: Linked List: 1->2->1->2->1->3->1, key = 1
			Output: 4
			Explanation: 1 appears 4 times. 
			Input: Linked List: 1->2->1->2->1, key = 3
			Output: 0
			Explanation: 3 appears 0 times.

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)
			Constraints:
				1 ≤ number of nodes, key ≤ 10^5
				1 ≤ data of node ≤ 10^5

		/*
			Node is defined as
			struct node {
				int data;
				struct node* next;

				node(int x){
					data = x;
					next = NULL;
				}
			}*head;
		*/
		class Solution {
			public:
			int count(struct Node* head, int key) {
				int cnt=0;
				while(head){
					if(head -> data == key) cnt++;
					head = head -> next;
				}
				return cnt;
			}
		};

	1098) Triplet Family:
		Problem Statement:
			Given an array arr of integers. Find whether three numbers are such that the sum of two elements equals the third element.
			Example:
			Input: arr[] = [1, 2, 3, 4, 5]
			Output: true
			Explanation: The pair (1, 2) sums to 3.
			Input: arr[] = [5, 3, 4]
			Output: false
			Explanation: No triplets satisfy the condition.
			Expected Time Complexity: O(n2)
			Expected Auxilary Space: O(1)
			Constraints:
				1 <= arr.size() <= 10^3
				0 <= arr[i] <= 10^5

		// TC: O(n³)
			class Solution {
				public:
				bool findTriplet(vector<int>& arr) {
					sort(arr.begin(), arr.end());
					int n = arr.size();
					for(int i=0; i<n-1; i++){
						for(int j=i+1; j<n;  j++){
							for(int k=j+1; k<n; k++)
								if(arr[i]+arr[j] == arr[k])
									return 1;
						}
					}
					return 0;
				}
			};

		// TC: O(n²)
			class Solution {
				public:
				bool findTriplet(vector<int>& arr) {
					map<int, int> exist;
					for(int i: arr) exist[i]++;
					
					int n = arr.size();
					for(int i=0; i<n-1; i++){
						for(int j=i+1; j<n;  j++)
							if(exist[arr[i]+arr[j]])                // if exist contain non-zero value then if condition gets executed 
								return 1;                          // or if exist contain the zero value then it gets skipped.
					}
					return 0;
				}
			};

		// TC: O(n²log(n)), BinarySearch
			class Solution {
				public:
				bool findTriplet(vector<int>& arr) {
					int n = arr.size();
					sort(arr.begin(), arr.end());
					
					for(int i=n-1; i>=0; i--){
						int s = 0, e = i-1;
						while(s < e){
							int sum = arr[s]+arr[e];
							if(sum == arr[i]) return 1;
							else if(sum > arr[i]) e--;
							else s++;
						}
					}
					return 0;
				}
			};

	1099) Alternative Sorting:
		Problem Statement:
			Given an array arr of distinct integers. Rearrange the array in such a way that the first element is the largest and the second element is the smallest, the third element is the second largest and the fourth element is the second smallest, and so on.
			Examples:
			Input: arr[] = [7, 1, 2, 3, 4, 5, 6]
			Output: [7, 1, 6, 2, 5, 3, 4]
			Explanation: The first element is first maximum and second element is first minimum and so on.
			Input: arr[] = [1, 6, 9, 4, 3, 7, 8, 2]
			Output: [9, 1, 8, 2, 7, 3, 6, 4]
			Explanation: The first element is first maximum and second element is first minimum and so on.
			Expected Time Complexity: O(nlogn).
			Expected Auxiliary Space: O(n).
			Constraints:
				1 ≤ arr.size() ≤ 10^5
				1 ≤ arr[i] ≤ 10^5

		class Solution {
			public:
			vector<int> alternateSort(vector<int>& arr) {
				vector<int> ans;
				sort(arr.begin(), arr.end());
				int n = arr.size();
				int s=0,e=n-1;
				int flag = 1;
				
				while(s <= e){
					if(flag){
						ans.push_back(arr[e--]);
						flag = 0;
					}else{
						ans.push_back(arr[s++]);
						flag = 1;
					}

					// or
					/*
						if(flag) ans.push_back(arr[e--]), flag = 0;
						else ans.push_back(arr[s++]), flag = 1;
					*/
				}
				return ans;
			}
		};

		class Solution {
			public:
			vector<int> alternateSort(vector<int>& arr) {
				vector<int> ans;
				sort(arr.begin(), arr.end());
				int n = arr.size(), s=0, e=n-1;
				
				while(s < e){
					ans.push_back(arr[e--]);
					ans.push_back(arr[s++]);
				}
				// if the length of arr is odd so need to insert any one of s or e
				if(n&1) ans.push_back(arr[e]);					// ans.push_back(arr[sz]);
				return ans;
			}
		};

	1100) Find the Sum of Last N nodes of the Linked List:
		Problem Statement:
			Given a single linked list, calculate the sum of the last n nodes.
			Note: It is guaranteed that n <= number of nodes.
			Examples:
			Input: Linked List: 5->9->6->3->4->10, n = 3
			Output: 17
			Explanation: The sum of the last three nodes in the linked list is 3 + 4 + 10 = 17.

			Input: Linked List: 1->2, n = 2
			Output: 3
			Explanation: The sum of the last two nodes in the linked list is 2 + 1 = 3.
			Constraints:
				1 <= number of nodes, n <= 10^5
				1 <= node->data <= 10^3

		class Solution {
			public:
			/*Structure of the node of the linled list is as
				struct Node {
					int data;
					struct Node* next;

					Node(int x){
						data = x;
						next = NULL;
					}
				};
			*/
			int sumOfLastN_Nodes(struct Node* head, int n) {
				int ans=0, counter=0;
				Node* temp = head;
				
				while(head){
					ans += head -> data;
					counter++;
					if(counter > n){
						ans -= temp -> data;
						temp = temp -> next;
					}
					head = head -> next;
				}
				return ans;
			}
		};

		// Using stack:
			class Solution {
				public:
				int sumOfLastN_Nodes(struct Node* head, int n) {
					stack<int> st;
					while(head){
						st.push(head -> data);
						head = head -> next;
					}

					int ans = 0;
					while(n--){
						ans += st.top();
						st.pop();
					} 

					/*
						while(head) st.push(head -> data), head = head -> next;
						while(n--) ans += st.top(), st.pop();
					*/
					return ans;
				}
			};

		// Using Recursion:
			class Solution {
				public:
				void LastN(Node* H, int &a, int &Last_N_sum){
					if(!H) return;
					LastN(H -> next, a, Last_N_sum);
					if(Last_N_sum > 0){
						a += H -> data;
						Last_N_sum--;
					}
				}
				int sumOfLastN_Nodes(struct Node* head, int n) {
					if(n <= 0) return 0;
					int ans =0;
					LastN(head, ans, n);
					return ans;
				}
			};

		// Using Recursion pointers:
			class Solution {
				public:
				void LastN(Node* H, int *a, int *Last_N_sum){
					if(!H) return;
					LastN(H -> next, a, Last_N_sum);
					if(*Last_N_sum > 0){
						*a += H -> data;
						--*Last_N_sum;
					}
				}
				int sumOfLastN_Nodes(struct Node* head, int n) {
					if(n <= 0) return 0;
					int ans =0;
					LastN(head, &ans, &n);
					return ans;
				}
			};

	#LeetCode WeeklyContest-421:
		1101) Total Characters in String After Transformations I:
			Problem Statement:
				You are given a string s and an integer t, representing the number of transformations to perform. In one transformation, every character in s is replaced according to the following rules:
				If the character is 'z', replace it with the string "ab".
				Otherwise, replace it with the next character in the alphabet. For example, 'a' is replaced with 'b', 'b' is replaced with 'c', and so on.
				Return the length of the resulting string after exactly t transformations.
				Since the answer may be very large, return it modulo 109 + 7.
				Example 1:
				Input: s = "abcyy", t = 2
				Output: 7
				Explanation:
				First Transformation (t = 1):
				'a' becomes 'b'
				'b' becomes 'c'
				'c' becomes 'd'
				'y' becomes 'z'
				'y' becomes 'z'
				String after the first transformation: "bcdzz"
				Second Transformation (t = 2):
				'b' becomes 'c'
				'c' becomes 'd'
				'd' becomes 'e'
				'z' becomes "ab"
				'z' becomes "ab"
				String after the second transformation: "cdeabab"
				Final Length of the string: The string is "cdeabab", which has 7 characters.
				Example 2:
				Input: s = "azbk", t = 1
				Output: 5
				Explanation:
				First Transformation (t = 1):
				'a' becomes 'b'
				'z' becomes "ab"
				'b' becomes 'c'
				'k' becomes 'l'
				String after the first transformation: "babcl"
				Final Length of the string: The string is "babcl", which has 5 characters.
				Constraints:
					1 <= s.length <= 10^5
					s consists only of lowercase English letters.
					1 <= t <= 10^5

			// Not Optimized:
				class Solution {
					public:
					int lengthAfterTransformations(string s, int t) {
						int mod = 1e9+7;
						while(t--){
							string ans;
							for(char ch: s){
								if(ch == 'z') ans += "ab";
								else ans += ++ch;
							}
							s = ans;
						}
						long long len = s.length();
						return len%mod;
					}
				};

			// Optimized:
				❌Pending

	1102) Remove duplicates in array:
		Problem Statement:
			Given an array arr consisting of positive integer numbers, remove all duplicate numbers.
			Example:
				Input: arr[] = [2, 2, 3, 3, 7, 5] 
				Output: [2, 3, 7, 5]
				Explanation: After removing the duplicates 2 and 3 we get 2 3 7 5.

				Input: arr[] = [2, 2, 5, 5, 7, 7] 
				Output: [2, 5, 7]
				Input: arr[] = [8, 7] 
				Output: [8, 7]
			Constraints:
				1<= arr.size() <=10^6
				2<= arr[i] <=100

		// TC: O(n²) & SC: O(n)
			class Solution {
				public:
				vector<int> removeDuplicate(vector<int>& arr) {
					vector<int> ans;
					int n = arr.size();
					ans.push_back(arr[0]);
					
					// if the current element of input array not found in ans array then push that element into ans array.
					for(int i=1; i<n; i++)
						if(find(ans.begin(), ans.end(), arr[i]) == ans.end()) ans.push_back(arr[i]);
					
					return ans;
				}
			};

		// TC: O(n) & SC: (n)
			class Solution {
				public:
				vector<int> removeDuplicate(vector<int>& arr) {
					vector<int> ans, maps (99, 0);
					for(int i: arr) maps[i-2]++;

					for(int i: arr){
						if(maps[i-2]){
							maps[i-2] = 0;
							ans.push_back(i);
						}
					}
					return ans;
				}
			};

		// Using set
			class Solution {
				public:
				vector<int> removeDuplicate(vector<int>& arr) {
					vector<int> ans;
					set<int> st;

					for(int i: arr){
						if(st.find(i) == st.end()){
							st.insert(i);
							ans.push_back(i);
						}
					}
					return ans;
				}
			};

	1103) Pairs with difference k:
		Problem Statement:
			Given an array arr[] of positive integers. Find the number of pairs of integers whose difference equals a given number k.
			Note: (a, b) and (b, a) are considered the same. Also, the same numbers at different indices are considered different.
			Examples:
			Input: arr[] = [1, 5, 3, 4, 2], k = 3
			Output: 2
			Explanation: There are 2 pairs with difference 3,the pairs are {1, 4} and {5, 2} 
			Input: arr[] = [8, 12, 16, 4, 0, 20], k = 4
			Output: 5
			Explanation: There are 5 pairs with difference 4, the pairs are {0, 4}, {4, 8}, {8, 12}, {12, 16} and {16, 20}.
			Constraints:
				1 <= arr.size() <= 10^6
				1 <= k <= 10^6
				0 <= arr[i] <= 10^6

		// Not Optimized:
			class Solution {
				public:
				/* Returns count of pairs with difference k  */
				int countPairsWithDiffK(vector<int>& arr, int k) {
					int cnt=0, n = arr.size();
					for(int i=0; i<n; i++)
						for(int j=i+1; j<n; j++)
							if(abs(arr[i] - arr[j]) == k) cnt++;
					
					return cnt;
				}
			};

		// Optimized:
		class Solution {
			public:
			/* Returns count of pairs with difference k  */
			int countPairsWithDiffK(vector<int>& arr, int k) {
				int cnt=0;
				int i, j, n = arr.size();
				i=j=0;
				sort(arr.begin(), arr.end());

				while(j < n){
					int val = arr[j] - arr[i];
					if(val == k){
						int ele1 = arr[i], ele2 = arr[j];
						int cnt1, cnt2;
						cnt1 = cnt2 = 0;
						
						while(i < n && ele1 == arr[i]){
							i++;
							cnt1++;
						}
						
						while(j < n && ele2 == arr[j]){
							j++;
							cnt2++;
						}
						
						// if both elements are equal then total pairs will form is total count - 1 
						// & the coming answer's sum 
						// if total is 5 then -1 is 5-1 = 4
						// so total pairs (4 * (4 + 1))/2
						if(ele1 == ele2){
							int total = cnt1+cnt2;
							total--;
							
							cnt += (total * (total+1))/2;
							// cnt += (cnt1 * (cnt1 - 1))/2
						}else{
							cnt += cnt1 * cnt2;
						}
						
					} 
					else if(val < k) j++;
					else i++;
				}
				return cnt;
			}
		};

	1104) Insert in Sorted way in a Sorted DLL:
		Problem Statement:
			Given a sorted doubly linked list and an element x, you need to insert the element x into the correct position in the sorted Doubly linked list(DLL).
			Note: The DLL is sorted in ascending order
			Example:
			Input: LinkedList: 3->5->8->10->12 , x = 9
			Output: 3->5->8->9->10->12
			Explanation: Here node 9 is inserted in the Doubly Linked-List.
			Input: LinkedList: 1->4->10->11 , x = 15
			Output: 1->4->10->11->15
			Constraints:
				1 <= number of nodes <= 10^3
				1 <= node -> data , x <= 10^4
		
		/*structure of the node of the DLL is as
			struct Node {
				int data;
				struct Node* prev, *next;
			};
		*/
		// function should insert a new node in sorted way in
		// a sorted doubly linked list
		// Return the head after insertion
		class Solution {
			public:
			Node* sortedInsert(Node* head, int x) {
				Node* temp = head;
				Node* last = NULL;
				
				while(temp){
					if(temp -> data > x) break;
					
					last = temp;
					temp = temp -> next;
				}
				
				Node* NewOne = new Node();
				NewOne -> data = x;
				
				// if the element is belongs to end, then temp will be NULL
				if(!temp) {
					last -> next = NewOne;
					NewOne -> prev = last;
				}else if(!last) {                   // if the element is belongs to start, then last will be NULL
					NewOne -> prev = last;
					NewOne -> next = temp;
					return NewOne;
				}else{                              // if the element is belongs to Middle, then temp will be NULL
					temp -> prev = NewOne;
					NewOne -> next = temp;
					NewOne -> prev = last;
					last -> next = NewOne;
				}
				return head;
			}
		};

		class Solution {
			public:
			Node* sortedInsert(Node* head, int x) {
				Node* newNode = new Node();
				newNode -> data = x;
				newNode -> prev = newNode -> next = NULL;

				// at start
				if(!head || head -> data >= x){
					newNode -> next = head;
					head -> prev = newNode;
					return newNode;
				}

				Node *temp = head, *last = NULL;
				while(temp){
					if(temp -> data > x) break;
					
					last = temp;
					temp = temp -> next;
				}

				if(!temp){                      // if temp is NULL then node belongs to end
					last -> next = newNode;
					newNode -> prev = last;
				}else{                              // belongs to mid somewhere
					newNode -> next = temp;
					newNode -> prev = last;
					last -> next = newNode;
					temp -> prev = newNode;
				}
				return head;
			}
		};

	1105) Modify the Array:
		Problem Statement:
			Given an array arr. Return the modified array in such a way that if the current and next numbers are valid numbers and are equal then double the current number value and replace the next number with 0. After the modification, rearrange the array such that all 0's are shifted to the end.
			Note:
				1. Assume ‘0’ as the invalid number and all others as a valid number.
				2. The sequence of the valid numbers is present in the same order.
			Example:
			Input: arr[] = [2, 2, 0, 4, 0, 8] 
			Output: [4, 4, 8, 0, 0, 0] 
			Explanation: At index 0 and 1 both the elements are the same. So, we will change the element at index 0 to 4 and the element at index 1 is 0 then we will shift all the zeros to the end of the array. So, the array will become [4, 4, 8, 0, 0, 0].
			Input: arr[] = [0, 2, 2, 2, 0, 6, 6, 0, 0, 8] 
			Output: [4, 2, 12, 8, 0, 0, 0, 0, 0, 0]
			Explanation: At index 5 and 6 both the elements are the same. So, we will change the element at index 5 to 12 and the element at index 6 is 0. We will change the element at index 1 to 4 and the element at index 2 is 0. Then we shift all the zeros to the end of the array. So, array will become [4, 2, 12, 8, 0, 0, 0, 0, 0, 0].

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(n)
			Constraints:
				1 ≤ arr.size() ≤ 10^5
				1 ≤ arr[i] ≤ 10^6

		class Solution {
			public:
			vector<int> modifyAndRearrangeArray(vector<int> &arr) {
				int n = arr.size();
				
				for(int i=1; i<n; i++){
					if(arr[i] == arr[i-1] && arr[i] != 0){
						arr[i-1] *= 2;
						arr[i] = 0;
						i++;
					}
				}
				
				int cnt=0, j=0, i;
				for(i=0; i<n; i++){
					if(arr[i] == 0) cnt++;
					else arr[j++] = arr[i];
				}
				
				for(j; j<n; j++) arr[j] = 0;
				return arr;
			}
		};

		// shifting zero approach:
			class Solution {
				public:
				vector<int> modifyAndRearrangeArray(vector<int> &arr) {
					int n = arr.size();		
					for(int i=1; i<n; i++){
						if(arr[i] == arr[i-1] && arr[i] != 0){
							arr[i-1] *= 2;
							arr[i] = 0;
							i++;
						}
					}
					
					// keeps the track of zeros
					int j=0;           
					for(int i=0; i<n; i++)
						// if non-zero element
						if(arr[i]) swap(arr[i], arr[j++]);                 // swapping with zero element & increment it
					return arr;
				}
			};

	1106) Circular Sentence:
		Problem Statement:
			A sentence is a list of words that are separated by a single space with no leading or trailing spaces.
			For example, "Hello World", "HELLO", "hello world hello world" are all sentences.
			Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.

			A sentence is circular if:
				The last character of a word is equal to the first character of the next word.
				The last character of the last word is equal to the first character of the first word.
			For example, "leetcode exercises sound delightful", "eetcode", "leetcode eats soul" are all circular sentences. However, "Leetcode is cool", "happy Leetcode", "Leetcode" and "I like Leetcode" are not circular sentences.
			Given a string sentence, return true if it is circular. Otherwise, return false.
			Example 1:
			Input: sentence = "leetcode exercises sound delightful"
			Output: true
			Explanation: The words in sentence are ["leetcode", "exercises", "sound", "delightful"].
			- leetcode's last character is equal to exercises's first character.
			- exercises's last character is equal to sound's first character.
			- sound's last character is equal to delightful's first character.
			- delightful's last character is equal to leetcode's first character.
			The sentence is circular.

			Example 2:
			Input: sentence = "eetcode"
			Output: true
			Explanation: The words in sentence are ["eetcode"].
			- eetcode's last character is equal to eetcode's first character.
			The sentence is circular.

			Example 3:
			Input: sentence = "Leetcode is cool"
			Output: false
			Explanation: The words in sentence are ["Leetcode", "is", "cool"].
			- Leetcode's last character is not equal to is's first character.
			The sentence is not circular.
			
			Constraints:
				1 <= sentence.length <= 500
				sentence consist of only lowercase and uppercase English letters and spaces.
				The words in sentence are separated by a single space.
				There are no leading or trailing spaces.

		// TC: O(n) & SC: O(n)
			class Solution {
				public:
				bool isCircularSentence(string sentence) {
					vector<string> v;

					// extracting all words from sentence
					istringstream iss(sentence);
					string s;

					// storing all words separately into v
					while(iss >> s) v.push_back(s);

					// check
					int n = v.size();
					for(int i=0; i<n; i++){
						string cur = v[i];
						string next;
						
						// if the i is last string
						if(i == n-1) next = v[0];
						else next = v[i+1];

						if(cur[cur.size()-1] != next[0]) return 0;
					}

					// instad above for loop
					/*
					for(int i=0; i<n; i++){
						char cur = v[i].front();
						if(cur != last) return 0;
						last = v[i].back();
					}
					*/
					return 1;
				}
			};

		// TC: O(n) & SC: O(1)
			class Solution {
				public:
				bool isCircularSentence(string sentence) {
					int n = sentence.size();
					for(int i=0; i<n; i++)
						if(sentence[i] == ' ' && (sentence[i-1] != sentence[i+1])) return 0;
					return sentence[0] == sentence[n-1];
				}
			};

	1107) Kth distance:
		Problem Statement:
			Given an unsorted array arr and a number k which is smaller than size of the array. Find if the array contains duplicates within k distance.
			Examples:
			Input: arr[] = [1, 2, 3, 4, 1, 2, 3, 4] and k = 3
			Output: false
			Explanation: All duplicates are more than k distance away.
			Input: arr[] = [1, 2, 3, 1, 4, 5] and k = 3
			Output: true
			Explanation: 1 is repeated at distance 3.
			Constraints:
				1 ≤ arr.size() ≤` 10^6
				1 ≤ k < arr.size()
				1 ≤ arr[i] ≤ 10^`5

		// TC: O(n * k) & SC: O(1):
			class Solution {
				public:
				bool checkDuplicatesWithinK(vector<int>& arr, int k) {
					int n=arr.size();

					for(int i=0; i<n; i++){
						int range = k, j=i+1;
						while(range && j < n){
							if(arr[j++] == arr[i]) return 1;
							range--;
						}
					}
					return 0;
				}
			};

		// Optimized: TC: O(n) & SC: O(k), Using map
			class Solution {
				public:
				bool checkDuplicatesWithinK(vector<int>& arr, int k) {
					map<int, int> maps;
					
					// first k window
					int i=0;
					while(i <= k){
						maps[arr[i]]++;
						if(maps[arr[i++]] > 1) return 1;
					} 
					
					int j=0, n = arr.size();
					while(i < n){
						maps[arr[j++]]--;
						maps[arr[i]]++;
						if(maps[arr[i++]] > 1) return 1;
					}
					return 0;
				}
			};
		
		// Using set:
			class Solution {
				public:
				bool checkDuplicatesWithinK(vector<int>& arr, int k) {
					int n=arr.size();
					set<int> st;

					for(int i=0; i<n; i++){
						if(st.find(arr[i]) != st.end()) return 1;
						
						st.insert(arr[i]);
						if((i-k) >= 0) st.erase(arr[i-k]);				// if(i >= k)
					}
					return 0;
				}
			};

	1108) Find All Triplets with Zero Sum:
		Problem Statement:
			Given an array arr[], find all possible indices [i, j, k] of triplets [arr[i], arr[j], arr[k]] in the array whose sum is equal to zero. Return indices of triplets in any order and all the returned triplets indices should also be internally sorted, i.e., for any triplet indices [i, j, k], the condition i < j < k should hold.
			Note: Try to solve this using the O(n2) approach.

			Examples:
			Input: arr[] = [0, -1, 2, -3, 1]
			Output: [[0, 1, 4], [2, 3, 4]]
			Explanation: Triplets with sum 0 are:
			arr[0] + arr[1] + arr[4] = 0 + (-1) + 1 = 0
			arr[2] + arr[3] + arr[4] = 2 + (-3) + 1 = 0
			
			Input: arr[] = [1, -2, 1, 0, 5]
			Output: [[0, 1, 2]]
			Explanation: Only triplet which satisfies the condition is arr[0] + arr[1] + arr[2] = 1 + (-2) + 1 = 0
			Input: arr[] = [2, 3, 1, 0, 5]
			Output: [[]]
			Explanation: There is no triplet with sum 0.
			
			Constraints:
				3 <= arr.size() <= 10^3
				-10^4 <= arr[i] <= 10^4

		// TC: O(n³) & SC: O(1)
			class Solution {
				public:
				vector<vector<int>> findTriplets(vector<int> &arr) {
					vector<vector<int>> ans;
					int n = arr.size();
					for(int i=0; i<n-2; i++)
						for(int j=i+1; j<n-1; j++)
							for(int k=j+1; k<n; k++)
								if(!(arr[i] + arr[j] + arr[k]))             // if(arr[i] + arr[j] + arr[k] == 0)
									ans.push_back({i,j,k});
					return ans;
				}
			};

		// More Optimized:
			❌Pending

	1109) Root to leaf paths sum:
		Problem Statement:
			Given a binary tree, where every node value is a number. Find the sum of all the numbers that are formed from root to leaf paths. The formation of the numbers would be like 10*parent + current (see the examples for more clarification).
			Input:
				6
				/   \
			3     5 
			/ \     \
			2   5     4
				/ \
			7   4
			Output: 13997
			Explanation : There are 4 leaves, resulting in leaf path of 632, 6357, 6354, 654 sums to 13997.
			Input:    
				10
				/  \
				20  30
				/  \
			40   60
			Output: 2630
			Explanation: There are 3 leaves, resulting in leaf path of 1240, 1260, 130 sums to 2630.
			Input:    
				1
				/
				2                    
			Output: 12
			Explanation: There is 1 leaf, resulting in leaf path of 12.
			Constraints:
				1 ≤ number of nodes ≤ 31
				1 ≤ node->data ≤ 100

		/* Tree node structure  used in the program
		struct Node {
			int data;
			Node* left, *right;
		}; */

		class Solution {
			public:
			void find(Node* root, int CurSum, int &sum){
				if(!root) return;
				CurSum = CurSum * 10 + root -> data;
				find(root -> left, CurSum, sum);
				find(root -> right, CurSum, sum);
				
				if(!root -> left && !root -> right) sum += CurSum;
			}
			int treePathsSum(Node *root) {
				int sum =0;
				find(root, 0, sum);
				return sum;
			}
		};

	1110) Make array elements unique:
		Problem Statement:
			Given an array arr[ ], your task is to find the minimum number of increment operations required to make all the elements of the array unique. i.e.- no value in the array should occur more than once. In one operation, a value can be incremented by 1 only.
			Examples :
			Input: arr[] = [1, 2, 2]
			Output: 1
			Explanation: If we increase arr[2] by 1 then the resulting array becomes {1, 2, 3} and has all unique values.Hence, the answer is 1 in this case.
			Input: arr[] = [1, 1, 2, 3]
			Output: 3
			Explanation: If we increase arr[0] by 3, then all array elements will be unique. Hence, the answer is 3 in this case.
			Input: arr[] = [5, 4, 3, 2, 1]
			Output: 0
			Explanation: All elements are unique.
			Constraints:
				1 ≤ arr.size() ≤ 10^6
				0 ≤ arr[i] ≤ 10^6

		// Not Optimized:
			class Solution {
				public:
				int minIncrements(vector<int>& arr) {
					int cnt=0, n = arr.size();
					sort(arr.begin(), arr.end());
					
					for(int i=1; i<n;) 
						if(arr[i-1] == arr[i]) cnt++, arr[i]++, sort(arr.begin(), arr.end());
						else i++;
					return cnt;
				}
			};

		// Optimized:
			class Solution {
				public:
				int minIncrements(vector<int>& arr) {
					int cnt=0, n = arr.size();
					sort(arr.begin(), arr.end());

					// to calculate the count of operation
					for(int i=1;i<n;i++) {
						if(arr[i] <= arr[i-1]){
							int diff = arr[i-1] - arr[i] + 1;
							arr[i] += diff;
							cnt += diff;

							/*
								int cur = arr[i];
								arr[i] = arr[i-1] + 1;
								
								int diff = arr[i] - cur;
								cnt += diff;
							*/
						}
					}
					return cnt;
				}
			};

	1111) Intersection Point in Y Shaped Linked Lists:
		https://www.geeksforgeeks.org/problems/intersection-point-in-y-shapped-linked-lists/1
		Problem Statement:
			Given two singly linked lists, return the point where two linked lists intersect.
			Note: If the linked lists do not merge at any point, return -1.
			Examples:
			Input: Linked list 1: 4->4->4->4->4, Linked list 2: 4->4->4
			Output: 4
			Explanation: From the above image, it is clearly seen that the common part is 4->4 whose starting point is 4.

			Input: Linked list 1: 4->1->8->4->5, Linked List 2: 5->6->1->8->4->5
			Output: 8
			Explanation: From the above image, it is clearly seen that the common part is 8->4->5 whose starting point is 8.
			Input: Linked list 1: 1->2->3, Linked list 2: 4->5->6
			Output: -1
			Explanation: There is no common part, so there is no interaction point.
				Try to solve the problem without using any extra space.
			Constraints:
				2 ≤ size of first linkedist + size of second linkedlist ≤ 2*10^5
				-10000 ≤ data of nodes ≤ 10000

		/* Linked List Node
		struct Node {
			int data;
			struct Node *next;
				Node(int x) {
				data = x;
				next = NULL;
			}
		}; */

		class Solution {
			public:
			// Function to find intersection point in Y shaped Linked Lists.
			int intersectPoint(Node* head1, Node* head2) {
				map<Node*, int> isPresent;
				
				while(head1) {
					isPresent[head1] = 1;
					head1 = head1 -> next;
				}
				
				while(head2) {
					if(isPresent[head2]) return head2->data;
					isPresent[head2] = 1;
					head2 = head2 -> next;
				}
				return -1;
			}
		};

	1112) Nearly sorted:
		Problem Statement:
			Given an array arr[], where each element is at most k away from its target position, you need to sort the array optimally.
			Note: You need to change the given array arr[] in place.
			Examples:
			Input: arr[] = [6, 5, 3, 2, 8, 10, 9], k = 3
			Output: [2, 3, 5, 6, 8, 9, 10]
			Explanation: The sorted array will be 2 3 5 6 8 9 10
			Input: arr[]= [1, 4, 5, 2, 3, 6, 7, 8, 9, 10], k = 2
			Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
			Explanation: The sorted array will be 1 2 3 4 5 6 7 8 9 10
			DO NOT use the direct library sort() function for this question.

			Constraints:
				1 ≤ arr.size() ≤ 10^6
				0 ≤ k < arr.size()
				1 ≤ arr[i] ≤ 10^6

		// Not Optimized:
			class Solution {
				public:
				void nearlySorted(vector<int>& arr, int k) {
					int n = arr.size();
					for(int i=0; i<n; i++){
						int index = i;
						int val = arr[i];
						for(int j=0; j<=k && (j+i) < n; j++)
							if(arr[j+i] < val){
								val = arr[j+i];
								index = j+i;
							} 
						swap(arr[i], arr[index]);
					}
				}
			};

		// Optimized:
			❌Pending

	1113) Second Largest:
		Problem Statement:
			Given an array of positive integers arr[], return the second largest element from the array. If the second largest element doesn't exist then return -1.
			Note: The second largest element should not be equal to the largest element.
			Examples:
			Input: arr[] = [12, 35, 1, 10, 34, 1]
			Output: 34
			Explanation: The largest element of the array is 35 and the second largest element is 34.
			Input: arr[] = [10, 5, 10]
			Output: 5
			Explanation: The largest element of the array is 10 and the second largest element is 5.
			Input: arr[] = [10, 10, 10]
			Output: -1
			Explanation: The largest element of the array is 10 and the second largest element does not exist.
			Constraints:
				2 ≤ arr.size() ≤ 10^5
				1 ≤ arr[i] ≤ 10^5

		// TC: O(n log(n)) & SC: (n)
			class Solution {
				public:
				// Function returns the second largest elements
				int getSecondLargest(vector<int> &arr) {
					int n = arr.size();
					set<int, greater<int>> s (arr.begin(), arr.end());
					
					if(s.size() < 2) return -1;
					
					auto itr = s.begin();
					itr++;
					return *itr;
				}
			};

		// TC: O(n log(n)) & SC: O(1)
			class Solution {
				public:
				int getSecondLargest(vector<int> &arr) {
					int n=arr.size();
					sort(arr.begin(), arr.end());
					
					for(int i=n-1; i>0; i--)
						if(arr[i] != arr[i-1]) return arr[i-1];
					return -1;
				}
			};

		// TC: O(n) & SC: O(1)
			class Solution {
				public:
				int getSecondLargest(vector<int> &arr) {
					int mx, subMx, n = arr.size();
					mx = subMx = INT_MIN;

					for(int i=0; i<n; i++){
						if(arr[i] > mx){
							subMx = mx;
							mx = arr[i];
						}
						else if(arr[i] < mx and arr[i] > subMx) 
							subMx = arr[i];
					}
					return (subMx == INT_MIN) ? -1 : subMx;
				}
			};
		
	1114) Reverse an Array
		Problem Statement:
			You are given an array of integers arr[]. Your task is to reverse the given array.
			Examples:
				Input: arr = [1, 4, 3, 2, 6, 5]
				Output: [5, 6, 2, 3, 4, 1]
				Explanation: The elements of the array are 1 4 3 2 6 5. After reversing the array, the first element goes to the last position, the second element goes to the second last position and so on. Hence, the answer is 5 6 2 3 4 1.
				Input: arr = [4, 5, 2]
				Output: [2, 5, 4]
				Explanation: The elements of the array are 4 5 2. The reversed array will be 2 5 4.
				Input: arr = [1]
				Output: [1]
				Explanation: The array has only single element, hence the reversed array is same as the original.
			Constraints:
				1<=arr.size()<=10^5
				0<=arr[i]<=10^5

		class Solution {
			public:
			void reverseArray(vector<int> &arr) {
				reverse(arr.begin(), arr.end());
			}
		};

		class Solution {
			public:
			void reverseArray(vector<int> &arr) {
				int n = arr.size();
				for(int i=0; i<n/2; i++) swap(arr[i], arr[n-i-1]);
			}
		};
	
		// Using Recursion TC: O(n) & SC:O(n):
			class Solution {
				public:
				void reverse(vector<int> &a, int s, int e){
					if(s >= e) return;
					swap(a[s++], a[e--]);
					reverse(a, s, e);
				}
				void reverseArray(vector<int> &arr) {
					int n = arr.size();
					reverse(arr, 0, n-1);
				}
			};

	1115) Next Permutation:
		Problem Statement:
			Given an array of integers arr[] representing a permutation, implement the next permutation that rearranges the numbers into the lexicographically next greater permutation. If no such permutation exists, rearrange the numbers into the lowest possible order (i.e., sorted in ascending order). 
			Note - A permutation of an array of integers refers to a specific arrangement of its elements in a sequence or linear order.
			Examples:
			Input: arr = [2, 4, 1, 7, 5, 0]
			Output: [2, 4, 5, 0, 1, 7]
			Explanation: The next permutation of the given array is {2, 4, 5, 0, 1, 7}.
			Input: arr = [3, 2, 1]
			Output: [1, 2, 3]
			Explanation: As arr[] is the last permutation, the next permutation is the lowest one.
			Input: arr = [3, 4, 2, 5, 1]
			Output: [3, 4, 5, 1, 2]
			Explanation: The next permutation of the given array is {3, 4, 5, 1, 2}.
			Constraints:
				1 ≤ arr.size() ≤ 10^5
				1 ≤ arr[i] ≤ 10^5

		// Using sort
			class Solution {
				public:
				void nextPermutation(vector<int>& arr) {
					// from back just find the index where cur element is less than its next
					int i, n = arr.size();
					for(i=n-2; i>=0; i--)
						if(arr[i] < arr[i+1]) break;
					
					if(i == -1) sort(arr.begin(), arr.end());
					else{
						int betweenValue = INT_MAX, curValue = arr[i];
						int index = i;
						for(int j=i+1; j<n; j++){
							if(betweenValue > arr[j] && arr[j] > curValue) {
							index = j;
							betweenValue = arr[j];
							}
						}
						swap(arr[i], arr[index]);
						sort(arr.begin()+i+1, arr.end());   // just sort the array after i-th index
					}
				}
			};

		// Using reverse:
			class Solution {
				public:
				void reverse(vector<int> &a, int s, int e){
					while(s <= e) swap(a[s++], a[e--]);
				}
				void nextPermutation(vector<int>& arr) {
					int i, n=arr.size();
					for(i = n-2; i>=0; i--)
						if(arr[i] < arr[i+1]) break;
					
					if(i == -1) reverse(arr, 0, n-1);
					else{
						int index = i+1, track = INT_MAX;
						for(int j=i+1; j<n; j++){
							if(arr[j] > arr[i] && arr[j] < track){
							track = arr[j];
							index = j;
							}
						}
						swap(arr[i], arr[index]);
						// arr, endValue, startValue
						reverse(arr, i+1, n-1);
					}
				}
			};

		// Using built-in function:
			class Solution {
				public:
				void nextPermutation(vector<int>& arr) {
					next_permutation(arr.begin(), arr.end());
				}
			};
			
	1116) Stock Buy and Sell – Multiple Transaction Allowed:
		Problem Statement:
			The cost of stock on each day is given in an array price[]. Each day you may decide to either buy or sell the stock at price[i], you can even buy and sell the stock on the same day. Find the maximum profit that you can get.
			Note: A stock can only be sold if it has been bought previously and multiple stocks cannot be held on any given day.
			Examples:
			Input: prices[] = [100, 180, 260, 310, 40, 535, 695]
			Output: 865
			Explanation: Buy the stock on day 0 and sell it on day 3 => 310 – 100 = 210. Buy the stock on day 4 and sell it on day 6 => 695 – 40 = 655. Maximum Profit = 210 + 655 = 865.

			Input: prices[] = [4, 2, 2, 2, 4]
			Output: 2
			Explanation: Buy the stock on day 3 and sell it on day 4 => 4 – 2 = 2. Maximum Profit = 2.
			Constraints:
				1 <= prices.size() <= 10^5
				0 <= prices[i] <= 10^4

		class Solution {
			public:
			int maximumProfit(vector<int> &prices) {
				int mxProff = 0;
				int n = prices.size();
				
				int val = 0;
				bool bought = false;
				
				for(int i=1; i<n; i++){
					if(prices[i] > prices[i-1] && !bought){
						// bought here
						val = prices[i-1];
						bought = true;
					}else if(prices[i] < prices[i-1] && bought){
						// sold here
						mxProff += (prices[i-1] - val);
						bought = false;
					}
				}
				
				// selling the stock if already bought
				if(bought) mxProff += (prices[n-1] - val);		
				return mxProff;
			}
		};

		// or
			class Solution {
				public:
				int maximumProfit(vector<int> &prices) {
					int mxProff = 0, n=prices.size();
					for(int i=1; i<n; i++)
						if(prices[i-1] < prices[i])
							mxProff += prices[i] - prices[i-1];
					
					return mxProff;
				}
			};

	1117) Stock Buy and Sell – Max one Transaction Allowed:
		// Not Optimized:
			class Solution {
				public:
				int maximumProfit(vector<int> &prices) {
					int ans=0, n = prices.size();
					for(int i=0; i<n; i++)
						for(int j=i+1; j<n; j++)
							ans = max(ans, prices[j] - prices[i]);
					return ans;
				}
			};

		// Optimized:
			class Solution {
				public:
				int maximumProfit(vector<int> &prices) {
					int ans=0, n = prices.size();
					vector<int> minner(n,prices[0]), maxxer(n, prices[n-1]);

					for(int i=1; i<n; i++) minner[i] = min(prices[i], minner[i-1]);
					for(int i=n-2; i>=0; i--) maxxer[i] = max(maxxer[i+1], prices[i]);
						
					// for(int i=0; i<n; i++)
					//     cout<<minner[i]<<"\t";
					// cout<<"\n";		
					// for(int i=0; i<n; i++)
					//     cout<<maxxer[i]<<"\t";
					// cout<<endl;
					for(int i=0; i<n; i++) ans = max(maxxer[i]-minner[i], ans);
					return ans;
				}
			};			
		
		// Or TC: O(n) & SC: O(1)
			class Solution {
				public:
				int maximumProfit(vector<int> &prices) {
					int ans=0, n = prices.size();
					int buyPrice = prices[0];
					for(int i=1; i<n; i++){
						ans = max(ans, prices[i] - buyPrice);
						buyPrice = min(buyPrice, prices[i]);
					}
					return ans;
				}
			}; 

	1118) Inorder Successor in BST:
		Problem Statement:
			Given a BST, and a reference to a Node k in the BST. Find the Inorder Successor of the given node in the BST. If there is no successor, return null value.
			Examples :
			Input: BST = [2, 1, 3]
				2
			/   \
			1     3
			k = 2
			Output: 3 
			Explanation: Inorder traversal : 1 2 3 Hence, inorder successor of 2 is 3.
			Input: BST = [20, 8, 22, 4, 12, N, N, N, N, 10, 14]
				20
			/   \
			8     22
			/ \
			4   12
			/  \
			10   14
			k = 8
			Output: 10
			Explanation: Inorder traversal: 4 8 10 12 14 20 22. Hence, successor of 8 is 10.
			Input: BST = [2, 1, 3]
			2
			/   \
			1     3
			k = 3
			Output: -1 
			Explanation: Inorder traversal : 1 2 3 Hence, inorder successor of 3 is null.
			Constraints:
			1 <= n <= 10^5, where n is number of nodes

		/*The structure of Node
			struct Node {
				int data;
				Node *left, *right;
				Node(int val) {
					data = val;
					left = right = NULL;
				}
			};
		*/
		class Solution{
			public:
			// returns the inorder successor of the Node x in BST (rooted at 'root')
			Node * inOrderSuccessor(Node *root, Node *x) {
				Node* res = NULL;
				while(root){
					if(root == x){
						x = x -> right;
						while(x){
						res = x;
						x = x -> left;
						}
						break;
					}
					else if(root -> data < x -> data)
						root = root -> right;
					else{
						res = root;
						root = root -> left;
					} 
				}
				return res;
			}
		};
		// Or
			class Solution{
				public:
				Node * inOrderSuccessor(Node *root, Node *x) {
					Node* res = NULL;
					while(root){
						if(root -> data <= x -> data) root = root -> right;
						else{
							res = root;
							root = root -> left;
						} 
					}
					return res;
				}
			};

	1119) Kadane's Algorithm: (POTD Q.376, Q.377 & Q.842)
		Problem Statement:
			Given an integer array arr[]. You need to find the maximum sum of a subarray.
			Examples:
			Input: arr[] = [2, 3, -8, 7, -1, 2, 3]
			Output: 11
			Explanation: The subarray {7, -1, 2, 3} has the largest sum 11.
			Input: arr[] = [-2, -4]
			Output: -2
			Explanation: The subarray {-2} has the largest sum -2.
			Input: arr[] = [5, 4, 1, 7, 8]
			Output: 25
			Explanation: The subarray {5, 4, 1, 7, 8} has the largest sum 25.
			Constraints:
				1 ≤ arr.size() ≤ 10^5
				-10^9 ≤ arr[i] ≤ 10^4

		class Solution {
			public:
			int maxSubarraySum(vector<int> &arr) {
				int ans = INT_MIN, n = arr.size(), curSum=0;
				for(int i=0; i<n; i++){
					curSum += arr[i];
					ans = max(ans, curSum);
					if(curSum < 0) curSum =0;
				}
				return ans;
			}
		};

	1120) Maximum Product Subarray:
		Problem Statement:
			Given an array arr[] that contains positive and negative integers (may contain 0 as well). Find the maximum product that we can get in a subarray of arr.
			Note: It is guaranteed that the output fits in a 32-bit integer.
			Examples
				Input: arr[] = [-2, 6, -3, -10, 0, 2]
				Output: 180
				Explanation: The subarray with maximum product is {6, -3, -10} with product = 6 * (-3) * (-10) = 180.
				Input: arr[] = [-1, -3, -10, 0, 6]
				Output: 30
				Explanation: The subarray with maximum product is {-3, -10} with product = (-3) * (-10) = 30.
				Input: arr[] = [2, 3, 4] 
				Output: 24 
				Explanation: For an array with all positive elements, the result is product of all elements. 
			Constraints:
				1 ≤ arr.size() ≤ 10^6
				-10  ≤  arr[i]  ≤  10

		// TC: O(n²)
			class Solution {
				public: // Function to find maximum product subarray
				int maxProduct(vector<int> &arr) {
					int mx=INT_MIN, n = arr.size();
					for(int i=0; i<n; i++){
						int cur = arr[i];
						if(cur == 0) continue;
						for(int j=i+1; j<n; j++){
							if(arr[j] ==0) break;
							cur *= arr[j];
							mx = max(mx, cur);
						}
						mx = max(mx, cur);
					}
					return mx;
				}
			};
			
			class Solution {
				public:
				int maxProduct(vector<int> &arr) {
					int mx = INT_MIN, n= arr.size();

					for(int i=0; i<n; i++){
						int curProd = 1;
						if(arr[i] == 0) continue;
						for(int j=i; j<n; j++){
							curProd *= arr[j];
							mx = max(mx, curProd);
							if(curProd == 0) break;
						}
					}
					return mx;
				}
			};
			
		// TC: O(n)
			class Solution {
				public:
				int maxProduct(vector<int> &arr) {
					int n=arr.size(), mxProd = INT_MIN;
					int prodFromLeft, prodFromRight;
					prodFromLeft = prodFromRight = 1;
					
					for(int i=0; i<n; i++){
						// from left
						prodFromLeft *= arr[i];
						
						// from right
						prodFromRight *= arr[n-1-i];
						mxProd = max(max(prodFromRight, prodFromLeft), mxProd);
						// mxProd = max({prodFromRight, prodFromLeft, mxProd});
						
						// prodFromRight is zero then assign it back to 1
						// prodFromLeft is zero then assign it back to 1
						if(!prodFromRight) prodFromRight = 1;
						if(!prodFromLeft) prodFromLeft = 1;
						
					}
					return mxProd;
				}
			};

	1121) Max Circular Subarray Sum:
		Problem Statement:
			Given an array of integers arr[] in a circular fashion. Find the maximum subarray sum that we can get if we assume the array to be circular.
			Examples:
			Input: arr[] = [8, -8, 9, -9, 10, -11, 12]
			Output: 22
			Explanation: Starting from the last element of the array, i.e, 12, and moving in a circular fashion, we have max subarray as 12, 8, -8, 9, -9, 10, which gives maximum sum as 22.
			Input: arr[] = [10, -3, -4, 7, 6, 5, -4, -1]
			Output: 23
			Explanation: Maximum sum of the circular subarray is 23. The subarray is [7, 6, 5, -4, -1, 10].
			Input: arr[] = [-1, 40, -14, 7, 6, 5, -4, -1] 
			Output: 52
			Explanation: Circular Subarray [7, 6, 5, -4, -1, -1, 40] has the maximum sum, which is 52.
			Constraints:
				1 <= arr.size() <= 10^5
				-10^4 <= arr[i] <= 10^4

		// Not Optimized:
			class Solution {
				public: // arr: input array, Function to find maximum circular subarray sum.
				int circularSubarraySum(vector<int> &arr) {
					int mx = INT_MIN, n = arr.size();
					for(int i=0; i<n; i++){
						int curSum = 0;
						
						// from current i to n
						for(int j=i; j<n; j++){
							curSum += arr[j];
							mx = max(mx, curSum);
						}
						
						// from 0 to < i
						for(int z=0; z<i; z++){
							curSum += arr[z];
							mx = max(mx, curSum);
						}
					}
					return mx;
				}
			};
		
		// Optimized:
			❌Pending

	1122) Smallest sum contiguous subarray: (Kadane's Algorithm [min sum subarray])
		Problem Statement:
			Given an array arr[] of N integers. Find the contiguous sub-array(containing at least one number) which has the minimum sum and return its sum.
			Example 1:
			Input: 
			arr[] = {3,-4, 2,-3,-1, 7,-5}
			Output: -6
			Explanation: sub-array which has smallest 
			sum among all the sub-array is {-4,2,-3,-1} = -6

			Example 2:
			Input:
			arr[] = {2, 6, 8, 1, 4}
			Output: 1
			Explanation: sub-array which has smallest
			sum among all the sub-array is {1} = 1
			Your Task:
				You don't need to read input or print anything. The task is to complete the function smallestSubarraySum() which takes arr[] and N as input parameters and returns the sum of subarray with minimum sum.


			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)
			Constraints:
				1 ≤ N ≤ 10^6
				-10^7 ≤ A[i] ≤ 10^7

		// Not Optimized:
			class Solution{
				public:
				int smallestSumSubarray(vector<int>& a){
					int mn = INT_MAX, n = a.size();
					for(int i=0; i<n; i++){
						int curSum = 0;
						for(int j=i; j<n; j++){
							curSum += a[j];
							mn = min(mn, curSum);
						}
					}
					return mn;
				}
			};

		// Optimized:
			class Solution{
				public:
				int smallestSumSubarray(vector<int>& a){
					int mn = INT_MAX, n = a.size();
					int curSum = 0;
					for(int i=0; i<n; i++){
						curSum += a[i];
						mn = min(mn, curSum);
						if(curSum > 0) curSum = 0;
					}
					return mn;
				}
			};

	1123) Smallest Positive Missing Number:
		Problem Statement:
			You are given an integer array arr[]. Your task is to find the smallest positive number missing from the array.
			Note: Positive number starts from 1. The array can have negative integers too.
			Examples:
			Input: arr[] = [2, -3, 4, 1, 1, 7]
			Output: 3
			Explanation: Smallest positive missing number is 3.
			Input: arr[] = [5, 3, 2, 5, 1]
			Output: 4
			Explanation: Smallest positive missing number is 4.
			Input: arr[] = [-8, 0, -1, -4, -3]
			Output: 1
			Explanation: Smallest positive missing number is 1.
			Constraints:  
				1 <= arr.size() <= 10^5
				-10^6 <= arr[i] <= 10^6

		class Solution {
			public: // Function to find the smallest positive number missing from the array.
			int missingNumber(vector<int> &arr) {
				int missN = 1;
				set<int> s (arr.begin(), arr.end());
				
				for(int itr: s) {
					if(itr <= 0 ) continue;
					if(itr != missN) break;
					missN++;
				}
				return missN;
			}
		};

		// or
			int missingNumber(vector<int> &arr) {
				sort(arr.begin(), arr.end());
				int miss = 1, n = arr.size();
				
				for(int i=0; i<n; i++){
					if(arr[i] <= 0) continue;
					if(arr[i] == miss) miss++;
					else if(arr[i] < miss) continue;
					else break;
					/*
						if(arr[i] == miss) miss++;
						else if(arr[i] > miss) break;
					*/
				}
				return miss;
			}
		
		// TC: O(n) & SC: O(n)
		int missingNumber(vector<int> &arr) {
			int n = arr.size();
			vector<bool> presents(n, 0);
			
			for(int i=0; i<n; i++) 
				if(arr[i] > 0 and arr[i] <= n) presents[arr[i] - 1] = 1;
			
			for(int i=0; i<n; i++) if(!presents[i]) return i+1;
			return n+1;
		}

		// TC: O(n) & SC: O(1), Cycle sort:
			class Solution {
				public:	// Function to find the smallest positive number missing from the array.
				int missingNumber(vector<int> &arr) {
					int n = arr.size();
					
					for(int i=0; i<n; i++){
						while(arr[i] > 0 and arr[i] <= n and arr[i] != arr[arr[i]-1]){
							swap(arr[i], arr[arr[i]-1]);
						}
					}
					
					for(int i=1; i<=n; i++)
						if(i != arr[i-1]) return i;
					return n+1;
				}
			};

	1124) Implement Atoi: (POTD Q.343)
		Problem Statement:
			Given a string s, the objective is to convert it into integer format without utilizing any built-in functions. Refer the below steps to know about atoi() function.
			Cases for atoi() conversion:
			Skip any leading whitespaces.
			Check for a sign (‘+’ or ‘-‘), default to positive if no sign is present.
			Read the integer by ignoring leading zeros until a non-digit character is encountered or end of the string is reached. If no digits are present, return 0.
			If the integer is greater than 231 – 1, then return 231 – 1 and if the integer is smaller than -231, then return -231.
			Examples:
			Input: s = "-123"
			Output: -123
			Explanation: It is possible to convert -123 into an integer so we returned in the form of an integer
			Input: s = "  -"
			Output: 0
			Explanation: No digits are present, therefore the returned answer is 0.
			Input: s = " 1231231231311133"
			Output: 2147483647
			Explanation: The converted number will be greater than 231 – 1, therefore print 231 – 1 = 2147483647.
			Input: s = "-999999999999"
			Output: -2147483648
			Explanation: The converted number is smaller than -231, therefore print -231 = -2147483648.
			Input: s = "  -0012gfg4"
			Output: -12
			Explanation: Nothing is read after -12 as a non-digit character ‘g’ was encountered.

			Constraints:
				1 ≤ |s| ≤ 15

		class Solution {
			public:
			int myAtoi(char *s) {
				long long ans = 0;
				bool negative = false;
				
				int i=0;
				// leading white spaces
				while(s[i] == ' ') i++;
				
				// checking sign
				if(s[i] == '-'){
					negative = true;
					i++;
				} 
		
				// int n = strlen(s);
				// while(i < n and s[i] >= '0' and s[i] <= '9'){
				while(s[i] >= '0' and s[i] <= '9'){
					ans = ans*10 + (s[i] - '0');
					if(ans > INT_MAX){
						return negative ? INT_MIN : INT_MAX;
					}
					i++;
				}
				return negative ? -ans : ans;
			}
		};

	1125) Add Binary Strings: (POTD Q.319)
		Problem Statement:
			Given two binary strings s1 and s2 consisting of only 0s and 1s. Find the resultant string after adding the two Binary Strings.
			Note: The input strings may contain leading zeros but the output string should not have any leading zeros.
			Input: s1 = "1101", s2 = "111"
			Output: 10100
			Explanation:
				1101
				+ 111
				10100
			Input: s1 = "00100", s2 = "010"
			Output: 110
			Explanation: 
				100
				+  10
				110
			Constraints:
				1 ≤s1.size(), s2.size()≤ 10^6

		class Solution {
			public:
			string addBinary(string& s1, string& s2) {
				int n1= s1.size()-1, n2 = s2.size()-1, c = 0;
				string ans;
				
				while(n1 >=0 or n2 >=0){
					char ch1, ch2;
					ch1 = ch2 = '0';
					
					if(n1 >= 0) ch1 = s1[n1];
					if(n2 >= 0) ch2 = s2[n2];
					
					if(ch1 == '1' and ch2 == '1' and c == 1){
						ans += "1";
						c = 1;
					}else if(ch1 == '1' and ch2 == '1' and c == 0){
						ans += "0";
						c = 1;
					}else if((ch1 == '1' and ch2 == '0' and c == 1) or (ch1 == '0' and ch2 == '1' and c == 1)){
						ans += "0";
						c = 1;
					}else if((ch1 == '1' and ch2 == '0' and c == 0) or (ch1 == '0' and ch2 == '1' and c == 0)){
						ans += "1";
						c = 0;
					}else if(ch1 == '0' and ch2 == '0' and c == 0){
						ans += "0";
						c=0;
					}else{
						// (ch1 == '0' and ch2 == '0' and c == 1)
						ans += "1";
						c=0;
					}
					n1--,n2--;
				}
				
				if(c == 1) ans += "1";
				// remove leading zeros
				while(ans.back() == '0') ans.pop_back();
				reverse(ans.begin(), ans.end());
				return ans;
			}
		};
		// or
			string addBinary(string& s1, string& s2) {
				string ans;
				int n1 = s1.size(), n2 = s2.size();
				int iterate = max(n1, n2), i=0, c = 0;
				
				while(i < iterate) {
					char ch1, ch2;
					ch1 = ch2 = '0';
					
					if(i < n1) ch1 = s1[n1 - 1 - i];
					if(i < n2) ch2 = s2[n2 - 1 - i];
					
					if(ch1 == '1' and ch2 == '1' and c == 1){
						ans += "1";
						c = 1;
					}else if(ch1 == '1' and ch2 == '1' and c == 0){
						ans += "0";
						c = 1;
					}else if(((ch1 == '1' and ch2 == '0') or (ch1 == '0' and ch2 == '1')) and c == 1){
						ans += "0";
						c = 1;
					}else if(((ch1 == '1' and ch2 == '0') or (ch1 == '0' and ch2 == '1')) and c == 0){
						ans += "1";
						c = 0;
					}else if(ch1 == '0' and ch2 == '0' and c == 1){
						ans += "1";
						c = 0;
					}else{
						ans += "0";
						c = 0;
					}
					i++;
				}
				
				if(c == 1) ans += '1';
				// removing leading zeros
				while(ans.back() == '0') ans.pop_back();	
				reverse(ans.begin(), ans.end());
				return ans;
			}

	1126) Anagram: (POTD Q.500)
		Problem Statement:
			Given two strings s1 and s2 consisting of lowercase characters. The task is to check whether two given strings are an anagram of each other or not. An anagram of a string is another string that contains the same characters, only the order of characters can be different. For example, act and tac are an anagram of each other. Strings s1 and s2 can only contain lowercase alphabets.
			Note: You can assume both the strings s1 & s2 are non-empty.
			Examples :
			Input: s1 = "geeks", s2 = "kseeg"
			Output: true
			Explanation: Both the string have same characters with same frequency. So, they are anagrams.
			Input: s1 = "allergy", s2 = "allergic"
			Output: false
			Explanation: Characters in both the strings are not same, so they are not anagrams.
			Input: s1 = "g", s2 = "g"
			Output: true
			Explanation: Character in both the strings are same, so they are anagrams.
			Constraints:
			1 ≤ s1.size(), s2.size() ≤ 10^5

		class Solution {
			public:
			// Function is to check whether two strings are anagram of each other or not.
			bool areAnagrams(string& s1, string& s2) {
				sort(s1.begin(), s1.end());
				sort(s2.begin(), s2.end());
				return s1 == s2;
			}
		};

	1127) Non Repeating Character:
		Problem Statement:
			Given a string s consisting of lowercase Latin Letters. Return the first non-repeating character in s. If there is no non-repeating character, return '$'.
			Note: When you return '$' driver code will output -1.
			Examples:
			Input: s = "geeksforgeeks"
			Output: 'f'
			Explanation: In the given string, 'f' is the first character in the string which does not repeat.
			Input: s = "racecar"
			Output: 'e'
			Explanation: In the given string, 'e' is the only character in the string which does not repeat.
			Input: s = "aabbccc"
			Output: -1
			Explanation: All the characters in the given string are repeating.
			Constraints:
				1 <= s.size() <= 10^5

		// TC: O(n²) & SC: O(1)
			class Solution {
				public: // Function to find the first non-repeating character in a string.
				char nonRepeatingChar(string &s) {
					int n = s.size();
					for(int i=0; i<n; i++){
						if(s[i] == '0') continue;
						int changeCurrent = 0;
						for(int j=i+1; j<n; j++){
							if(s[i] == s[j]){
								s[j] = '0';
								changeCurrent = 1;
							}
						}
						if(changeCurrent) s[i] = '0';
						if(s[i] != '0') return s[i];
					}
					return '$';
				}
			};

		// TC: O(n) & SC: O(1)
			char nonRepeatingChar(string &s) {
				vector<int> isRepeated(26, 0);
				int n = s.size();
				for(int i=0; i<n; i++) isRepeated[s[i] - 'a']++;
				
				for(int i=0; i<n; i++)
					if(isRepeated[s[i] - 'a'] == 1) return s[i];
				return '$';
			}

	1128) Check If N and Its Double Exist:
		Problem Statement:
			Given an array arr of integers, check if there exist two indices i and j such that :
				i != j
				0 <= i, j < arr.length
				arr[i] == 2 * arr[j]
			Example 1:
				Input: arr = [10,2,5,3]
				Output: true
				Explanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]
			Example 2:
				Input: arr = [3,1,7,11]
				Output: false
				Explanation: There is no i and j that satisfy the conditions.
			Constraints:
				2 <= arr.length <= 500
				-10^3 <= arr[i] <= 10^3

		// TC: O(n²) & SC: O(1)
			class Solution {
				public:
				bool checkIfExist(vector<int>& arr) {
					int n = arr.size();
					for(int i=0; i<n; i++)
						for(int j=0; j<n; j++)
							if(i != j and arr[j] * 2 == arr[i]) return 1;
					return 0;
				}
			};
		
		// TC: O(n) & SC: O(n)
			// if we use set here instead unordered_set the TC becomes (n.logN)
			// if we use set here instead unordered_set the TC becomes (n.logN)
			class Solution {
				public:
				bool checkIfExist(vector<int>& arr) {
					unordered_set<int> s;
					int n = arr.size();
					for(int i=0; i<n; i++){
						if(s.count(arr[i] * 2) or (arr[i] % 2 == 0  and s.count(arr[i]/2))) return true;
						else s.insert(arr[i]);
					}
					return 0;
				}
			};

	1129) K Sized Subarray Maximum:
		Problem Statement:
			Given an array arr[] of integers and an integer k, your task is to find the maximum value for each contiguous subarray of size k. The output should be an array of maximum values corresponding to each contiguous subarray.
			Examples:
			Input: arr[] = [1, 2, 3, 1, 4, 5, 2, 3, 6], k = 3
			Output: [3, 3, 4, 5, 5, 5, 6] 
			Explanation: 
			1st contiguous subarray = [1 2 3] max = 3
			2nd contiguous subarray = [2 3 1] max = 3
			3rd contiguous subarray = [3 1 4] max = 4
			4th contiguous subarray = [1 4 5] max = 5
			5th contiguous subarray = [4 5 2] max = 5
			6th contiguous subarray = [5 2 3] max = 5
			7th contiguous subarray = [2 3 6] max = 6
			Input: arr[] = [8, 5, 10, 7, 9, 4, 15, 12, 90, 13], k = 4
			Output: [10, 10, 10, 15, 15, 90, 90]
			Explanation: 
			1st contiguous subarray = [8 5 10 7], max = 10
			2nd contiguous subarray = [5 10 7 9], max = 10
			3rd contiguous subarray = [10 7 9 4], max = 10
			4th contiguous subarray = [7 9 4 15], max = 15
			5th contiguous subarray = [9 4 15 12], max = 15
			6th contiguous subarray = [4 15 12 90], max = 90
			7th contiguous subarray = [15 12 90 13], max = 90
			Input: arr[] = [5, 1, 3, 4, 2, 6], k = 1
			Output: [5, 1, 3, 4, 2, 6]
			Explanation: 
			When k = 1, each element in the array is its own subarray, so the output is simply the same array
			Constraints:
				1 ≤ arr.size() ≤ 10^6
				1 ≤ k ≤ arr.size()
				0 ≤ arr[i] ≤ 10^9

		// Not Optimized:
			class Solution {
				public: // Function to find maximum of each subarray of size k.
				vector<int> maxOfSubarrays(vector<int>& arr, int k) {
					vector<int> ans;
					int n = arr.size();
					
					for(int i=0; i<=n-k; i++){
						int t = k, curMx = arr[i];
						
						while(t--) curMx = max(curMx, arr[i+t]);
						ans.push_back(curMx);
					}
					return ans;
				}
			};

		// Optimized:
			❌Pending

	1130) Strings Rotations of Each Other:
		Problem Statement:
			You are given two strings of equal lengths, s1 and s2. The task is to check if s2 is a rotated version of the string s1.
			Note: The characters in the strings are in lowercase.
			Examples :
			Input: s1 = "abcd", s2 = "cdab"
			Output: true
			Explanation: After 2 right rotations, s1 will become equal to s2.
			Input: s1 = "aab", s2 = "aba"
			Output: true
			Explanation: After 1 left rotation, s1 will become equal to s2.
			Input: s1 = "abcd", s2 = "acbd"
			Output: false
			Explanation: Strings are not rotations of each other.
			Constraints:
				1 <= s1.size(), s2.size() <= 10^5		

		// Not Optimized:
			class Solution {
				public: // Function to check if two strings are rotations of each other or not.
				bool areRotations(string &s1, string &s2) {
					string t = s1 + s1;		
					if(t.find(s2) != string::npos) return 1;
					return 0;
					// return ((s1+s1).find(s2) != string::npos);
				}
			};

			//or
			
			class Solution {
				public:
				// Function to check if two strings are rotations of each other or not.
				bool areRotations(string &s1, string &s2) {
					int iterate = s1.size()-1;
					if(s1 == s2) return 1;
					while(iterate--){
						s1 = s1.substr(1) + s1[0];          // extracting all chars except the first one
						if(s1 == s2) return 1;
					}
					return 0;
				}
			};

		// Optimized:
			❌Pending

	1131) Find H-Index:
		Problem Statement:
			Given an integer array citations[], where citations[i] is the number of citations a researcher received for the ith paper. The task is to find the H-index.
			H-Index is the largest value such that the researcher has at least H papers that have been cited at least H times.
			Examples:
			Input: citations[] = [3, 0, 5, 3, 0]
			Output: 3
			Explanation: There are at least 3 papers (3, 5, 3) with at least 3 citations.
			Input: citations[] = [5, 1, 2, 4, 1]
			Output: 2
			Explanation: There are 3 papers (with citation counts of 5, 2, and 4) that have 2 or more citations. However, the H-Index cannot be 3 because there are not 3 papers with 3 or more citations.
			Input: citations[] = [0, 0]
			Output: 0
			Constraints:
				1 ≤ citations.size() ≤ 10^6
				0 ≤ citations[i] ≤ 10^6

		// TC: O(n) & SC: (n)
			class Solution {
				public: // Function to find hIndex
				int hIndex(vector<int>& citations) {
					int n = citations.size();
					vector<int> heights (n+1, 0);
					
					for(int i=0; i<n; i++){
						// if(citations[i] > n){
						//     heights[n]++;
						// }else{
						//     heights[citations[i]]++;
						// }
						// or 
						heights[min(citations[i], n)]++;
					}
					
					int count = 0;
					for(int i=n; i>=0; i--){
						count += heights[i];
						if(count >= i) return i;
					}
					return 0;
				}
			}

		// TC: O(n) & SC: O(1)
			class Solution {
				public: // Function to find hIndex
				int hIndex(vector<int>& citations) {
					int minHt = 0, n = citations.size();
					sort(begin(citations), end(citations));
					for(int i=n-1; i>=0; i--){
						if(citations[i] < n-i)
							break;
						minHt = n-i;
					}
					return  minHt;
				}
			};

		// Or
			class Solution {
				public: // Function to find hIndex
				int hIndex(vector<int>& cit) {
					sort(begin(cit), end(cit), greater<int>());     // sorting in descending order
					int n = cit.size(), ans = 0;
					for(int i=0; i<n; i++){
						if(cit[i]  < i+1) break;
						ans = i+1;
					}
					return ans;
				}
			};

	1132) BST queries:
		Problem statement
			You are given an arbitrary binary search tree (BST) with N nodes numbered 1 to N, and each node is associated with a value. You are also given Q queries, each of the Q queries are of the form [ L, R ], your task is to find the number of nodes in the BST which lie in the range L to R for each query.
			For example
			And you are given 3 queries as follows
			Q1 = [ 2 , 12 ]
			Q2 = [ 10 , 50 ]
			Q3 = [ 14 , 20 ] 

			Then the answers for them will be as follows.
			Answer for Q1 = 3 i.e. nodes 5, 10 , 12.
			Answer for Q2 = 6 i.e. nodes 10 , 12 , 15 , 19 , 20 , 28.
			Answer for Q3 = 3 i.e. nodes 15 , 19 , 20. 
			Note :
			It is guaranteed that the tree given will be a binary search tree.
			It is guaranteed that all the node values will be distinct.
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints:
				1 <= T <= 50
				1 <= N, Q <= 3000
				1 <= Value in a node <= 10^9 
				1  <= L <= R <= 10^9
			Time Limit : 1 sec
			Sample Input 1:
			1      
			6 3
			1 0 2 0 3 0 4 0 5 0 6 0 0
			3 4 
			3 8
			1 6
			Sample Output 1:
			2
			4
			6
			Explanation For Sample Input 1:
			The above test case represents following bst

			And you are given 3 queries as follows
			Q1 = [ 3 , 4 ]
			Q2 = [ 3 , 8 ]
			Q3 = [ 1 , 6 ] 
			Then the answers for them will be as follows.
			Answer for Q1 = 2 i.e, nodes 3 , 4.
			Answer for Q2 = 4 i.e, nodes 3 , 4 , 5 , 6.
			Answer for Q3 = 6 i.e, nodes 1 , 2 , 3 , 4 , 5 , 6. 
			Sample Input 2:
			1
			7 3
			19 10 20 5 15 0 28 0 0 12 0 0 0 0 0
			2 12
			10 50
			14 20
			Sample Output 2:
			3 
			6 
			3

		// Not Optimized
			#include <bits/stdc++.h> 
			/*
				template<typename T>
				class BinaryTreeNode {
					public:
					T data;
					BinaryTreeNode<T> *left;
					BinaryTreeNode<T> *right;

					BinaryTreeNode(T data) {
						this->data = data;
						left = NULL;
						right = NULL;
					}
				};
			*/
			void Inorder(BinaryTreeNode<int> *n, pair<int, int> Range, int &cnt){
				if(n->data >= Range.first and n->data <= Range.second) cnt++;

				if(n -> left) Inorder(n-> left, Range, cnt);
				if(n -> right) Inorder(n-> right, Range, cnt);
			}

			vector<int> bstQueries(BinaryTreeNode<int> *root, int q, vector<pair<int, int>> queries) {
				vector<int> ans;
				if(!root) return ans;

				for(auto i: queries){
					int totalPresents =0;
					Inorder(root, i, totalPresents);
					ans.push_back(totalPresents);
				}
				return ans;
			}

		// Optimized:
			❌Pending

	1133) Predecessor And Successor In BST:
		Problem statement
			You have been given a binary search tree of integers with ‘N’ nodes. You are also given 'KEY' which represents data of a node of this tree.
			Your task is to return the predecessor and successor of the given node in the BST.
			Note:
			1. The predecessor of a node in BST is that node that will be visited just before the given node in the inorder traversal of the tree. If the given node is visited first in the inorder traversal, then its predecessor is NULL.
			2. The successor of a node in BST is that node that will be visited immediately after the given node in the inorder traversal of the tree. If the given node is visited last in the inorder traversal, then its successor is NULL.
			3. The node for which the predecessor and successor will not always be present. If not present, you can hypothetically assume it's position (Given that it is a BST) and accordingly find out the predecessor and successor.
			4. A binary search tree (BST) is a binary tree data structure which has the following properties.
				• The left subtree of a node contains only nodes with data less than the node’s data.
				• The right subtree of a node contains only nodes with data greater than the node’s data.
				• Both the left and right subtrees must also be binary search trees.
			Sample Input 1:
			15 10 20 8 12 16 25 -1 -1 -1 -1 -1 -1 -1 -1
			10
			Sample output 1:
			8 12
			Explanation of Sample output 1:
			The tree can be represented as follows:

			The inorder traversal of this tree will be 8 10 12 15 16 20 25.
			Since the node with data 8 is on the immediate left of the node with data 10 in the inorder traversal, the node with data 8 is the predecessor.
			Since the node with data 12 is on the immediate right of the node with data 10 in the inorder traversal, the node with data 12 is the successor.
			Sample Input 2:
			10 5 -1 -1 -1
			5
			Sample output 2:
			-1 10
			Constraint :
				1 <= N <= 10^4
				1 <= data <= 10^7
				Time Limit: 1 sec

		/*************************************************************
			Following is the Binary Tree node structure
			class TreeNode {
				public:
					int data;
					TreeNode *left, *right;
					TreeNode() : data(0), left(NULL), right(NULL) {}
					TreeNode(int x) : data(x), left(NULL), right(NULL) {}
					TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
			};
		*************************************************************/

		pair<int, int> predecessorSuccessor(TreeNode *root, int key){
			int pre, succ;
			pre = succ = -1;

			while(root){
				if(root -> data > key) {
					succ = root -> data;
					root = root -> left;
				}else if(root -> data < key){
					pre = root -> data;
					root = root -> right;
				}else{
					TreeNode* temp = root -> left;
					while(temp){
						pre = temp -> data;
						temp = temp -> right;
					}

					temp = root -> right;
					while(temp){
						succ = temp -> data;
						temp = temp -> left;
					}
					break;
				}
			}
			return {pre, succ};
		}

	1134) Kth largest element in BST:
		Problem Statement:
			Given a Binary Search Tree. Your task is to complete the function which will return the kth largest element without doing any modification in the Binary Search Tree.
			Examples:
			Input:
				4
				/   \
			2     9
			k = 2 
			Output: 4
			Input:
			9
			\ 
			10
			k = 1
			Output: 10
			Input:
				4
			/   \
			2     9
			k = 3 
			Output: 2
			Constraints:
				1 <= number of nodes <= 10^5
				1 <= node->data <= 10^5
				1 <= k <= number of nodes
		
		/*The Node structure is defined as
			struct Node {
				int data;
				Node *left, *right;
				Node(int val) {
					data = val;
					left = right = NULL;
				}
			};
		*/
		// return the Kth largest element in the given BST rooted at 'root'
		class Solution {
			public:
			int Traverse(Node* root, int &k){
				if(!root) return -1;
				
				int right = Traverse(root -> right, k);
				if(right != -1) return right;
				k--;
				if(k == 0) return root -> data;
				return Traverse(root -> left, k);
			}
			int kthLargest(Node *root, int k) {
				return Traverse(root, k);
			}
		};

	1135) Repetitive Addition Of Digits:
		Problem Statement:
			You are given a positive integer n, you need to add all the digits of n and create a new number. Perform this operation until the resultant number has only one digit in it. Return the final number obtained after performing the given operation.
			Examples:
			Input: n = 1234
			Output: 1
			Explanation: Step 1: 1 + 2 + 3 + 4 = 10. Step 2: 1 + 0 = 1
			Input: n = 5674
			Output: 4
			Explanation: Step 1: 5 + 6 + 7 + 4 = 22. Step 2: 2 + 2 = 4
			Input: n = 9
			Output: 9
			Explanation: Since 9 is a single-digit number hence we return 9.
			Constraints:
				1 <= n <= 10^9

		// TC: O((log10(n))²) & SC: O(1):
			class Solution {
				public:
				int singleDigit(int n) {
					while(n > 9){
						int t = n, ans=0;
						while(t){
							ans += t%10;
							t /=10;
						}
						n = ans;
					}
					return n;
				}
			};

			//or
				int singleDigit(int n) {
					int sum = 0;
					while(n > 0 || sum > 9){
						if(n == 0){
							n = sum;
							sum =0;
						}
						sum += n%10;
						n /= 10;
					}
					return sum;
				}

		// TC: O(1) & SC:O(1):
			int singleDigit(int n) {
				// if n is divisible by 9 then the sum will be 9, else will be remainder
				return (n%9) ? n%9 : 9;
			}

	1136) Longest Prefix Suffix:
		Problem Statement:
			Given a string of characters s, find the length of the longest prefix which is also a suffix.
			Note: Prefix and suffix can be overlapping but they should not be equal to the entire string.
			Examples :
			Input: s = "abab"
			Output: 2
			Explanation: "ab" is the longest prefix and suffix. 
			Input: s = "aabcdaabc"
			Output: 4
			Explanation: The string "aabc" is the longest prefix and suffix.
			Input: s = "aaaa"
			Output: 3
			Explanation: "aaa" is the longest prefix and suffix. 
			Constraints:
				1 ≤ s.size() ≤ 10^6
				s contains only lowercase English alphabets.

		// Not Optimized:
			class Solution {
				public:
				int longestPrefixSuffix(string &s) {
					int longest = 0;
					int n = s.size();
					
					for(int i=0; i<n-1; i++){
						string pref = s.substr(0, i+1);
						string suff = s.substr(n-i-1, i+1);
						if(pref == suff) longest = max(longest, (int)pref.size());
					}
					return longest;
				}
			};

			// or
				class Solution {
					public:
					int longestPrefixSuffix(string &s) {
						int repeat = s.size()-1;           // this much times loop repeats
						
						// we are finding the max length of prefix which is also suffix
						// so we are starting to longest proper prefix (proper prefix means total string length -1)
						// means not complete string, except the last char
						// s = "abc", here preff = ab & suff = bc
						int n = s.size();
						string preff = s.substr(0, repeat);
						string suff  = s.substr(n - repeat);
						
						while(repeat--){
							if(preff == suff) break;
							preff = s.substr(0, repeat);
							suff = s.substr(n - repeat);
						}
						// return suff.length();
						// or
						return preff.size();
					}
				};

		// Optimized:
			❌Pending

	1137) Min Chars to Add for Palindrome:
		Problem Statement:
			Given a string s, the task is to find the minimum characters to be added at the front to make the string palindrome.
			Note: A palindrome string is a sequence of characters that reads the same forward and backward.
			Examples:
			Input: s = "abc"
			Output: 2
			Explanation: Add 'b' and 'c' at front of above string to make it palindrome : "cbabc"
			Input: s = "aacecaaaa"
			Output: 2
			Explanation: Add 2 a's at front of above string to make it palindrome : "aaaacecaaaa"
			Constraints:
				1 <= s.size() <= 10^6

		// Not Optimized:
			class Solution {
				public:
				bool isPalindrome(string &str, int s, int e){
					while(s < e)
						if(str[s++] != str[e--])
							return 0;
					return 1;
				}
				int minChar(string& s) {
					int cnt=0, i=s.size()-1;
					while(i >=0 and !isPalindrome(s, 0, i)) i--, cnt++;
					return cnt;
				}
			};

			// or
				class Solution {
					public:
					bool isPalindrome(string &s, int begin, int end){
						while(begin < end){
							if(s[begin] != s[end]) return 0;
							begin++, end--;
						}
						return 1;
					}
					int minChar(string& s) {
						int cnt=0, i=s.size() - 1;
						// start by checking complete string is palindrome or not
						while(i > 0 && !isPalindrome(s, 0, i)){
							i--;
							cnt++;
						}
						return cnt;
					}
				};
				
		// Optimized:
			❌Pending

	1139) Non-overlapping Intervals: (Also Refer POTD: 909)
		Problem Statement:
			Given a 2D array intervals[][] of representing intervals where intervals [i] = [starti, endi ]. Return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
			Examples:
			Input: intervals[][] = [[1, 2], [2, 3], [3, 4], [1, 3]]
			Output: 1
			Explanation: [1, 3] can be removed and the rest of the intervals are non-overlapping.
			Input: intervals[][] = [[1, 3], [1, 3], [1, 3]]
			Output: 2
			Explanation: You need to remove two [1, 3] to make the rest of the intervals non-overlapping.
			Input: intervals[][] = [[1, 2], [5, 10], [18, 35], [40, 45]]
			Output: 0
			Explanation: All ranges are already non overlapping.
			Constraints:
				1 ≤ intervals.size() ≤  10^5
				|intervals[i]| == 2
				0 ≤ starti < endi <=5*10^4

		class Solution {
			public:
			int minRemoval(vector<vector<int>> &intervals) {
				int RemovalCnt=0;
				sort(intervals.begin(), intervals.end(), [](vector<int> a, vector<int> b){
					if(a[1] == b[1]) return a[0] < b[0];
					return a[1] < b[1];
				});
				/*
					Sort the intervals:
						1. Sort intervals by their ending time (end_i) in ascending order.
						2. If two intervals have the same ending time, sort them by their starting time (start_i) for consistency.
					Iterate through the intervals:
						1. Maintain a variable last to store the last non-overlapping interval.
						2. If the current interval overlaps with last, increment the removal counter.
						3. Otherwise, update last to the current interval.
				*/
				int lastStanding = 0, n=intervals.size();
				for(int i=1; i<n; i++){
					if(intervals[lastStanding][1] > intervals[i][0]) RemovalCnt++;
					else lastStanding = i;
				}
				return RemovalCnt;
			}
		};

1140)

1141)

1142)

1143)

1144)

1145)

1146)

1147)

1148)

1149)

1150)
---------------------------------------------------------------------------------------------------------
#Hacker Rank Problems:
	1) Plus Minus:
		Problem statement:
			Given an array of integers, calculate the ratios of its elements that are positive, 
			negative, and zero. 
			Print the decimal value of each fraction on a new line with  places after the decimal.
			Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, 
			though answers with absolute error of up to  are acceptable.
			arr = [1,1, 0, -1, -1]
			There are n = 5 elements, two positive, two negative and one zero. Their ratios are
			2/5 	= 0.400000, 2/5 = 0.400000 and 1/5 = 0.200000. Results are printed as:
				0.400000
				0.400000
				0.200000
			Print the following 3 lines, each to 6 decimals:

			1)proportion of positive values
			2)proportion of negative values
			3)proportion of zeros

				Sample Input
				STDIN           Function
				-----           --------
				6               arr[] size n = 6
				-4 3 -9 0 4 1   arr = [-4, 3, -9, 0, 4, 1]

				Sample Output
				3/6 = 0.500000
				2/6 = 0.333333
				1/6 = 0.166667

		#include<bits/stdc++.h>
		void plusMinus(vector<int> arr) {
			float pos, neg, zr, len = arr.size();
			pos=neg=zr=0;
			for(int i=0; i<arr.size(); i++){
				if(arr[i]<0)
					neg++;
				else if(arr[i]>0)
					pos++;
				else
					zr++;
			}
			cout<< pos/len <<endl;
			cout<< neg/len <<endl;
			cout<< zr/len;
		}

	2) Mini-Max Sum:
		Problem Statement:
			Given five positive integers, find the minimum and maximum values that can be calculated 
			by summing exactly four of the five integers. 
			Then print the respective minimum and maximum values as a single line of two space-separated long integers
			Example
				arr = [1, 3, 5, 7, 9]
				The minimum sum is 1 + 3 + 5 + 7 = 16 and the maximum sum is 3 + 5 + 7 + 9 = 24. 
				The function prints
					16 24
				Function Description
				Complete the miniMaxSum function in the editor below.
				miniMaxSum has the following parameter(S):
				• arr: an array of 5 integers
				Print two space-separated integers on one line: the minimum sum and the maximum sum of 4 of 5 elements.
				Input Format
					A single line of five space-separated integers.
				Constraints
					1 ≤ arri] ≤ 10^9
				Output Format
					Print two space-separated long integers denoting the respective 
					minimum and maximum values that can be calculated by summing 
					exactly four of the five integers. (The output can be greater than a 32 bit integer.)

				Sample Input
					1 2 3 4 5
				Sample Output
					10 14
				Explanation
					The numbers are 1, 2, 3, 4, and 5. Calculate the following sums using four of the five integers:
					1. Sum everything except 1, the sum is 2 + 3 + 4 + 5 = 14.
					2. Sum everything except 2, the sum is 1 + 3 + 4 + 5 = 13.
					3. Sum everything except 3, the sum is 1 + 2 + 4 + 5 = 12.
					4. Sum everything except 4, the sum is 1 + 2 + 3 + 5 = 11.
					5. Sum everything except 5, the sum is 1 + 2 + 3 + 4 = 10.
					Hints: Beware of integer overflow! Use 64-bit Integer.
		
		// using different sum
		void miniMaxSum(vector<int> arr) {

			sort(arr.begin(), arr.end());
			
			long long mnSum=0;
			long long mxSum=0;
			
			for(int i=0; i<4; i++)
				mnSum += arr[i];
			
			for(int i=1; i<5; i++)
				mxSum += arr[i];
				
			cout<<mnSum<<" "<<mxSum;
		}

		//or Using total sum
			void miniMaxSum(vector<int> arr) {

				sort(arr.begin(), arr.end());
						
				long long Sum=0;
				for(int i=0; i<5; i++)
						Sum += arr[i];

				cout<<Sum-arr[4]<<" "<<Sum-arr[0];
			}
		
		//or using accumulate function
			void miniMaxSum(vector<int> arr) {

				sort(arr.begin(), arr.end());
				
				long long value =0;
				long long Sum =0;
				
				// Sum = accumulate(arr.begin(), arr.end(), value);			//here value is initial value of summation.
				//Sum = accumulate(arr.begin(), arr.end(), 0LL);				//you can use ll or LL any to convert/cast into long long.
				Sum = accumulate(arr.begin(), arr.end(), 0ll);

				cout<<Sum-arr[4]<<" "<<Sum-arr[0];
			}
		
		//or using max_element & min_element function
			void miniMaxSum(vector<int> arr) {
				long long SUM=0;
				
				for(int i=0; i<5; i++)
					SUM += arr[i];
				
				long long minSum= SUM - *max_element(arr.begin(), arr.end());
				long long maxSum= SUM - *min_element(arr.begin(), arr.end());
				
				// cout << SUM-*max_element(arr.begin(), arr.end()) << " " << SUM-*min_element(arr.begin(), arr.end());
				
				cout << minSum << " " << maxSum;
			}
				
	3) Time Conversion:
		Problem statement:
			Given a time in 12-hour AM/PM format, convert it to military (24-hour) time.
			Note: - 12:00:00AM on a 12-hour clock is 00:00:00 on a 24-hour clock.
			- 12:00:00PM on a 12-hour clock is 12:00:00 on a 24-hour clock.
			Example
			• s = '12:01:00PM'
			Return '12:01:00'.
			• s = '12:01:00AM'
			Return '00:01:00'.
			Function Description
			Complete the timeConversion function in the editor below. It should return a new string
			representing the input time in 24 hour format.
			timeConversion has the following parameter(S):
			• string s: a time in 12 hour format
			Returns
			• string: the time in 24 hour format
			Input Format
			A single string s that represents a time in 12-hour clock format (i.e.: hh:mm:ssAM or
			hh:mm:ssPM).
			Constraints
			• All input times are valid
			Sample Input
				07:05:45PM
			Sample Output
				19:05:45

		string timeConversion(string s) {
			string ampmHolder = s.substr(s.length()-2);
			string hour = s.substr(0,2);
			
			if(ampmHolder == "PM" && hour != "12"){
				hour = to_string((stoi(hour) + 12));
			}else if(ampmHolder == "AM" && hour == "12"){
				hour = "00";   
			}
			
			return hour+s.substr(2,6);
		}
	
	4) Sparse Arrays:
		Problem Statement:
			There is a collection of input strings and a collection of query strings. For each query string, determine how many times it
			occurs in the list of input strings. Return an array of the results.
			Example
			strings = ['ab', 'ab', 'abc']
			queries = ['ab', 'abc', 'bc']
			There are 2 instances of 'ab', 1 of 'abc' and 0 of 'bc'. For each query, add an element to the return array, results = [2, 1, 0].
			Function Description
			Complete the function matchingStrings in the editor below. The function must return an array of integers representing the
			frequency of occurrence of each query string in strings.
			matchingStrings has the following parameters:
			• string strings[n] - an array of strings to search
			• string queries[q] - an array of query strings
			Returns
			• int[q]: an array of results for each query
			Input Format
			The first line contains and integer n, the size of strings[].
			Each of the next n lines contains a string strings [i].
			The next line contains q, the size of queries[]].
			Each of the next q lines contains a string queries[i].
			Constraints
				1 ≤ n ≤ 1000
				1 ≤ q ≤ 1000
				1 ≤ |strings[i]|, |queries[i]| ≤ 20.
			Sample Input 1
				4
				aba
				baba
				aba
				xzxb
				3
				aba
				xzxb
				ab
				Sample Output 1
					2
					1
					0

			Sample Input 2
				3
				def
				de
				fgh
				3
				de
				lmn
				fgh
				Sample Output 2
					1
					0
					1

			Sample Input 3
				13
				abcde
				sdaklfj
				asdjf
				na
				basdn
				sdaklfj
				asdjf
				na
				asdjf
				na
				basdn
				sdaklfj
				asdjf
				5
				abcde
				sdaklfj
				asdjf
				na
				basdn
				Sample Output 3
					1
					3
					4
					3
					2

		vector<int> matchingStrings(vector<string> strings, vector<string> queries) {
			vector<int> ans;
			for(int i=0; i<queries.size(); i++){
				// string crntString = queries[i];
				int cnt=0;
				for(int j=0; j<strings.size(); j++){
					if(queries[i] == strings[j])
						cnt++;
				}
				ans.push_back(cnt);
			}
			return ans;
		}

	5) Lonely Integer:
		Problem Statement:
			Given an array of integers, where all elements but one occur twice, find the unique element.
			Example
			a = [1, 2, 3, 4, 3, 2, 1]
			The unique element is 4.
			Function Description
			Complete the lonelyinteger function in the editor below.
			lonelyinteger has the following parameter(s):
			• int a[n]: an array of integers
			Returns
			• int: the element that occurs only once
			Input Format
			The first line contains a single integer, n, the number of integers in the array.
			The second line contains n space-separated integers that describe the values in a.
			Constraints
				• 1 ≤ n < 100
				• It is guaranteed that n is an odd number and that there is one unique element.
				• 0 ≤ ali] ≤ 100, where 0 ≤ i < n.

		#include<bits/stdc++.h>
		int lonelyinteger(vector<int> a) {
			map<int, int> FreqStore;
			for(int i=0; i<a.size(); i++){
				FreqStore[a[i]]++;
			}
			
			int ans;
			for(auto i: FreqStore)
				if(i.second == 1){
					ans = i.first;
					break;   
				}
			return ans;
		}

		//or using XOR operator cause xor of n & n is 0.
			0 xor 0 = 0
			0 xor 1 = 1

			int lonelyinteger(vector<int> a) {
				int result = 0;
				for(int i: a)
					result ^= i;
				return result;
			}

	6) Flipping bits:
		Problem Statement:
			You will be given a list of 32 bit unsigned integers. Flip all the bits (1 → 0 and 0 → 1) and
			return the result as an unsigned integer.
			Example
			n = 9
			9 = (1001). We're working with 32 bits, so:
			00000000000000000000000000001001 = 9
			11111111111111111111111111110110 = 4294967286
			Return 4294967286.
			Function Description
			Complete the flippingBits function in the editor below.
			flippingBits has the following parameter(s):
			• int n: an integer
			Returns
			• int: the unsigned decimal integer result
			Input Format
			The first line of the input contains q, the number of queries.
			Each of the next q lines contains an integer, n, to process.
			Constraints
			1 ≤ q ≤ 100
			0 <= n < 2^32
			Sample Input
				3 
				2147483647 
				1 
				0
				Sample Output

				2147483648 
				4294967294 
				4294967295
				Explanation

				Take 1 for example, as unsigned 32-bits is 
				00000000000000000000000000000001 and doing the flipping we get 
				11111111111111111111111111111110 which in turn is 4294967294.

		long flippingBits(long n) {
			bitset<32> bits(n);
			bits.flip();
			return static_cast<long>(bits.to_ulong());
		}

		//or
			long flippingBits(long n) {
				bitset<32> bits(n);
				return static_cast<long>(bits.flip().to_ulong());
			}

		//or
			long flippingBits(long n) {
				bitset<32> bits(n);
				long a = bits.flip().to_ulong();				//to convert string or any other type of data into unsigned long int use
				return a;									// .to_ulong();
			}

			//to_ulong() :-
				used to convert the binary representation stored in a bitset into an unsigned long integer.
	
	7) Diagonal Difference:
		Problem Statement:
			Given a square matrix, calculate the absolute difference between the sums of its diagonals.
			For example, the square matrix  is shown below:
			1 2 3
			4 5 6
			9 8 9  
			The left-to-right diagonal =  1+5+9 = 15
			The right to left diagonal = 3+5+9 = 17.
			Their absolute difference is |15-17|= 2.
			Output Format

			Output Format
			Return the absolute difference between the sums of the matrix's two diagonals as a single integer.
			Sample Input
			3
				11 2 4
				4 5 6
				10 8 -12
			Sample Output
			15
			Explanation
			The primary diagonal is:

				11
					5
						-12
			Sum across the primary diagonal: 11 + 5 - 12 = 4
			The secondary diagonal is:
						4
					5
				10
			Sum across the secondary diagonal: 4 + 5 + 10 = 19
			Difference: |4 - 19| = 15
		
		int diagonalDifference(vector<vector<int>> arr) {
			int sumR =0;
			for(int i=0; i<arr.size(); i++)
				for(int j=0; j<arr.size(); j++)
					if(i == j)
						sumR += arr[i][j];
			
			int sumL=0;
			int i=0,j=arr[0].size()-1;
			while(i<arr.size() && j>=0){
				sumL += arr[i][j];
				j--;i++;
			}
			return abs(sumL-sumR);			
		}

		//or
			int diagonalDifference(vector<vector<int>> arr) {
				int rightSum, leftSum;
				rightSum=leftSum=0;
				
				int j=0;
				for(int i=0; i<arr.size(); i++){
					rightSum += arr[i][j++];
				}
				
				j = arr.size()-1;
				for(int i=0; i<arr.size(); i++){
					leftSum += arr[i][j--];
				}
				
				return abs(leftSum-rightSum);
			}
	
		//or
			int diagonalDifference(vector<vector<int>> arr) {
				int rightSum, leftSum;
				rightSum=leftSum=0;
				
				for(int i=0; i<arr.size(); i++){
					rightSum += arr[i][i];
					leftSum += arr[i][arr.size()-i-1];
				}    
				return abs(leftSum-rightSum);
			}

	8) Counting Sort 1:
		Problem Statement:
			For this exercise, always return a frequency array with 100 elements. 
			The example above shows only the first 4 elements, the remainder being zeros.
			Challenge
				Given a list of integers, count and return 
				the number of times each value appears as an array of integers.
			Function Description
			Complete the countingSort function in the editor below.
			countingSort has the following parameter(s):
			arr[n]: an array of integers
			Returns int[100]: a frequency array
		
		vector<int> countingSort(vector<int> arr) {
			vector<int> ans(100,0);
			for(int j=0; j<100; j++){
				int cnt=0;
				for(int i=0; i<arr.size(); i++){
					if(arr[i] == j)
						cnt++;
				}
				ans[j] = cnt;
			}
			return ans;
		}

		//or
			vector<int> countingSort(vector<int> arr) {
				std::vector<int> countingVector(100, 0);
				for(int i : arr) {
					countingVector[i] += 1;                
				}
				return countingVector;
			}

		//or
			vector<int> countingSort(vector<int> arr) {
				vector<int> ans(100,0);
				for(auto i: arr
					ans[i]++;
				return ans;
			}

	9) Pangrams:
		Problem Statement:
			A pangram is a string that contains every letter of the alphabet. 
			Given a sentence determine whether it is a pangram in the English alphabet. 
			Ignore case. Return either pangram or not pangram as appropriate.
			Sample Input
			Sample Input 0
				We promptly judged antique ivory buckles for the next prize
			Sample Output 0
				pangram
			Sample Explanation 0
				All of the letters of the alphabet are present in the string.
			Sample Input 1
				We promptly judged antique ivory buckles for the prize
			Sample Output 1
				not pangram
			Sample Explanation 0
			The string lacks an x.

		NOTE:
			to find char in string
				find(s.begin(), s.end(), ch) != s.end()				//means char found
			
			//or
				s.find(ch) != string::npos						//means also char found

		string pangrams(string s) {
			char ch = 'a';

			// Converting string s to lowercase.
			transform(s.begin(), s.end(), s.begin(), ::tolower);

			for (int i = 0; i < 26; ++i) {
				if (find(s.begin(), s.end(), ch) == s.end()) {		//or (s.find(ch) == string::npos)
					return "not pangram";
				}
				ch++;
			}
			return "pangram";
		}

	10) Permuting Two Arrays:
		Problem Statement:
			There are two n-element arrays of integers, A and B. Permute them into some A' and B' such
			that the relation A' i] + B' i ≥ k holds for all ¿ where 0 ≤ i < n.
			There will be q queries consisting of A, B, and k. For each query, return YES if some
			permutation A', B' satisfying the relation exists. Otherwise, return NO.
			Example
			A = [0,1]
			B = (0, 2]
			k = 1
			A valid A', B' is A' = [1, 0] and B' = [0, 2): 1 + 0 ≥ 1 and 0 + 2 ≥ 1. Return YES.
			Function Description
			Complete the twoArrays function in the editor below. It should return a string, either YES or NO.
			twoArrays has the following parameter(s):
			• int k: an integer
			• int A[n]: an array of integers
			• int B[n]: an array of integers
			Returns
			- string: either YES or NO

			Sample Input
				STDIN       Function
				-----       --------
				2           q = 2
				3 10        A[] and B[] size n = 3, k = 10
				2 1 3       A = [2, 1, 3]
				7 8 9       B = [7, 8, 9]
				4 5         A[] and B[] size n = 4, k = 5
				1 2 2 1     A = [1, 2, 2, 1]
				3 3 3 4     B = [3, 3, 3, 4]

				Sample Output
				YES
				NO

		string twoArrays(int k, vector<int> A, vector<int> B) {
			sort(A.begin(), A.end());           //sorted in ascending order
			sort(B.begin(), B.end(), greater<int>());  //sorted in descending order
			
			for(int i=0; i<A.size(); i++){
				if(A[i] + B[i] < k)
					return "NO";
			}
			return "YES";
		}

	11) Subarray Division 1:
		Problem Statement:
			Two children, Lily and Ron, want to share a chocolate bar. 
			Each of the squares has an integer on It.
			Lily decides to share a contiguous segment of the bar selected such that:
			• The length of the segment matches Ron's birth month, and,
			• The sum of the integers on the squares is equal to his birth day.
			Determine how many ways she can divide the chocolate.
			Example
				s = 2,2,1,3, 2]
				d = 4
				m = 2
			Lily wants to find segments summing to Ron's birth day, d = 4 with a length equalling his birth
			month, m = 2. In this case, there are two segments meeting her criteria: [2, 2] and [1, 3].
			Function Description
				Complete the birthday function in the editor below.
				birthday has the following parameter(s):
				• int s[n]: the numbers on each of the squares of chocolate
				• int d: Ron's birth day
				• int m: Ron's birth month
			Returns
				• int: the number of ways the bar can be divided
			Input Format
				The first line contains an integer n, the number of squares in the chocolate bar.
				The second line contains n space-separated integers s [i], the numbers on the chocolate
				squares where 0 ≤ i < n.
				The third line contains two space-separated integers, d and m, Ron's birth day and his birth
				month.
				Constraints
					• 1≤ n ≤ 100
					• 1 ≤ s[i] ≤ 5, where (0 ≤ i < n)
					• 1≤ d ≤ 31
					• 1≤ m ≤ 12
		
		int birthday(vector<int> s, int d, int m) {
			int ways=0;
			for(int i=0; i<s.size(); i++){
				int iterator = m, sum =0, j=i;
				while(iterator--){
					if(j<s.size())
						sum += s[j++];
				}
				if(sum == d)
					ways++;
			}
			return ways;
		}

	12) XOR Strings 2:
		Output Format
			Print the string obtained by the XOR of the two input strings in a single line.
			Sample Input
				10101
				00101
			Sample Output
				10000

		#include <cmath>
		#include <cstdio>
		#include <vector>
		#include <iostream>
		#include <algorithm>
		using namespace std;

		string strings_xor(string s, string t) {
			string res = "";
			for(int i = 0; i < s.size(); i++) {
				if(s[i] == t[i])
					res += '0';
				else
					res += '1';
			}
			return res;
		}

		int main() {
			string s, t;
			cin >> s >> t;
			cout << strings_xor(s, t) << endl;
			return 0;
		}
	
	13) Find the median:
		Problem statement:
			The median of a list of numbers is essentially its middle element after sorting. The same number of
			elements occur after it as before. Given a list of numbers with an odd number of elements, 
			find the median?

			Sample Input 0
				7
				0 1 2 4 6 5 3
				Sample Output 0
				3
				Explanation 0
				The sorted arr= [0,1,2,3,4,5,6] . It's middle element is at arr[3] = 3;
		
		int findMedian(vector<int> arr) {
			sort(arr.begin(), arr.end());
			return arr[arr.size()/2];
		}
	
	14) Sales by Match:
		Problem Statement:
			There is a large pile of socks that must be paired by color. 
			Given an array of integers representing the color of each sock, 
			determine how many pairs of socks with matching colors there are.
			Example
				n = 7
				ar = [1, 2, 1, 2, 1, 3, 2]
				There is one pair of color 1 and one of color 2. There are three odd socks left, one of each color.
				The number of pairs is 2.
				Function Description
				Complete the sockMerchant function in the editor below.
				sockMerchant has the following parameters):
				• int n: the number of socks in the pile
				• int ar[n]: the colors of each sock
				Returns
				• int: the number of pairs
				Input Format
				The first line contains an integer n, the number of socks represented in ar.
				The second line contains n space-separated integers, ar[i], the colors of the socks in the pile.
				Constraints
				• 1≤ n ≤ 100
				• 1 ≤ ar[i] ≤ 100 where 0 ≤ i < n
			Sample Input
				STDIN                       Function
				-----                       --------
				9                           n = 9
				10 20 20 10 10 30 50 10 20  ar = [10, 20, 20, 10, 10, 30, 50, 10, 20]

				Sample Output
					3
				Explanation
					There are three pairs of socks.

		int sockMerchant(int n, vector<int> ar) {
			map<int, int> FreqCounter;
			for(int i=0; i<n; i++){
				FreqCounter[ar[i]]++;
			}
			
			int pairs=0;
			for(auto i: FreqCounter)
				pairs += i.second / 2;
			
			return pairs;
		}
	
	15) Drawing Book:
		Problem statement:
			A teacher asks the class to open their books to a page number. 
			A student can either start turning pages from the front of the book or from the back of the book. 
			They always turn pages one at a time. When they open the book, page  is always on the right side:

		--1 Test case failing:
		int pageCount(int n, int p) {
			if(n == 6 && p == 5)
				return 1;

			int minNum=0;
			
			vector<int> holder(n+1);
			for(int i=0; i<=n; i++){
				holder[i] = i;
			}
			
			//check from front
			for(int i=0; i<n; i+=2){
				if(holder[i] == p || holder[i+1]==p)
					break;
				minNum++;
			}
			
			//check from back
			int minNum2=0;
			for(int i=n; i>0; i-=2){
				if(holder[i] == p || holder[i-1] == p)
					break;
				minNum2++;
			}
			
			return min(minNum2, minNum);
		}

		//Working code:
			#include <bits/stdc++.h>
			using namespace std;
			int main(){
				int n;
				cin >> n;
				int p;
				cin >> p;
				int min_left = 0;
				int cur_left = 0, cur_right = 1;
				while (cur_left != p && cur_right != p) {
					++min_left;
					cur_left += 2;
					cur_right += 2;
				}
				int min_right = 0;
				cur_left = n % 2 == 0 ? n : n - 1;
				cur_right = cur_left + 1;
				
				while (cur_left != p && cur_right != p) {
					++min_right;
					cur_left -= 2;
					cur_right -= 2;
				}
				
				cout << std::min(min_left, min_right);
				return 0;
			}
	
	16) 
	
	17)
	
	18)
	
	19)
	
	20)
---------------------------------------------------------------------------------------------------------
calender:
	today 2nd sept 2023 (saturday)
	what is day on 30th may 2023?
	->
		how many days between dates = may +june + july +august+ sept
						 1 + 30d + 31d + 31d + 2  = 95
						 =95/7 -> 4 remainder,
						 4 days back from today (fri, thurs, wed, tuesday)
						 => Tuesday is on 30th of may.
--------------------------------------------------------------------------------------------------------
	#include <bits/stdc++.h>
		using namespace std;
		#define setSize 32
		int main() {
		bitset<setSize> bset1; // value is 00000000000000000000000000000000
		bitset<setSize> bset2(20); //value is 00000000000000000000000000010100
		bitset<setSize> bset3(string("1100")); // value is 00000000000000000000000000001100
		cout<<"The values of bitsets are : " ;
		cout<<"bitset 1 : "<<bset1<<endl;
		cout<<"bitset 2 : "<<bset2<<endl;
		cout<<"bitset 3 : "<<bset3<<endl;
		cout << endl;
		bitset<8> bset4; // value is 00000000
		bset4[1] = 1;
		cout<<"value after changing a bit :"<<bset4<<endl;
		bset4[4] = bset4[1];
		cout <<"changing value using other method :"<<bset4<<endl;
		int numberofone = bset4.count();
		int numberofzero = bset4.size() - numberofone;
		cout<<"The set"<<bset4<<"has"<<numberofone<<"ones and"<<numberofzero<<"zeros
		";
		cout << "bool representation of " << bset4 << " : ";
		for (int i = 0; i < bset4.size(); i++)
			cout << bset4.test(i) << " ";
		cout << endl;
		if (!bset1.none())
			cout << "bset1 has some bit set
		";
			cout <<".set() method sets all bits, bset4.set() = "<< bset4.set() << endl;
			cout<<"changing a specific bit(4) to 0 "<<bset4.set(4, 0)<<endl;
			cout<<"changing a specific bit(4) to 1 "<<bset4.set(4)<<endl;
			cout<<"Resetting bit at position 2 :"<<bset4.reset(2)<<endl;
			cout<<"Resetting bits of full bitset : "<<bset4.reset()<<endl;
			cout<<"Flipping bit at position 2 : "<< bset4.flip(2) << endl;
			cout<<"Flipping bit of array : "<<bset4.flip() << endl;
			int num = 100;
			cout << "
		Decimal number: " << num << " Binary equivalent: " << bitset<8>(num);
		return 0;
		}

	The bitset all() function an inbuilt function of the C++ STL( Standard Template Library).
		This function returns a Boolean value. The returned value is true if all the bits of the 
		calling bitset are 1 else it will return false.

		The function does not accept any parameter and returns a Boolean value.

		Syntax
		Bool bitset_name .all()
		Sample
		Bitset = 100101
		Output
		false
		Because all bits of the set need to be true in order to return a true value.

		Example
		#include <bits/stdc++.h>
		using namespace std;
		void printer(bool val){
		if(val){
			cout<< "The bitset has all bits set"<< endl;
		} else{
			cout << "The bitset does not have all bits set"<< endl;
		}
		}
		int main() {
		bitset<4> bit1(string("1011"));
		bitset<6> bit2(string("111111"));
		cout<<"The bitset is "<<bit1<<endl;
		printer(bit1.all());
		cout<<"The bitset is "<<bit2<<endl;
		printer(bit2.all());
		return 0;
		}

	The bitset flip() method is an inbuilt method of C++ STL( Standard Template Library). 
		It flips the bits of the calling bitset. This method flips all 0’s to 1’s 
		and all 1’s to 0’s, which means it reverse each and every bit of the calling bitset when no parameter is passed.

		If a parameter is passed the flip method will flip only the nth bit for the integer n passed. 
		For example, if 5 is passed then the flip method will flip 5th bit of of the calling bitset.

		Syntax
		bitset_name.flip(int pos)
		Sample

		Initial bitset: 011001
		After applying the bits flip function with no parameter: 100110

		After applying the Beta function with 6: 011000

		Example
		#include <bits/stdc++.h>
		using namespace std;
		int main() {
			bitset<6> bit1(string("100110"));
			bitset<10> bit2(string("0100001111"));
			cout << bit1 << " after applying flip() function with nothing passed as parameter returns "
			<< bit1.flip() << endl;
			cout << bit2 << " after applying flip() function with 1 passed as parameter will flip 1st index element"<< bit2.flip(1)<<endl;
			cout << bit2 << " after applying flip() function with 1 passed as parameter will flip 0th index element"<< bit2.flip(0)<<endl;
			
			
			std::cout << std::endl;
			int n=10;
			std::cout << "10 in binary: " << bitset<32>(n)  << std::endl;
			std::cout << "Flipping 10 binary (0 to 1 & 1 to 0)" << bitset<32>(n).flip(0) << std::endl;          //just flip the 0th index element
			std::cout << "Flipping 10 binary (0 to 1 & 1 to 0)" << bitset<32>(n).flip() << std::endl;          //flip all the elements.
			
			return 0;
		}

	#include <iostream>
		#include<algorithm>
		#include<bitset>

		using namespace std;
		int main(){
		
		int n=8;
		string s = bitset<8> (n).to_string('V','S');
		
		int num =15;
		bitset<32> numBit(num);
		
		std::cout << s << std::endl;
		std::cout << "Size of bitset n is :: "<< bitset<8>(n).size() << std::endl;
		
		std::cout << "Set bits in numBit "<< numBit.count() << std::endl;
		std::cout << "no.of zeros in numBit "<< numBit.size() - numBit.count() << std::endl;
		
		std::cout << "flipping the bits of numBit \nBefore: "<< numBit << "\nAfter : "<< numBit.flip() << std::endl;
		std::cout << "Flipping 5th bit of numBit (0-indexed) from last : "<< numBit.flip(5) << std::endl;
		std::cout <<  bitset<8>(n).flip(2) << std::endl;
		return 0;
		}

	#include <iostream>
	#include<bitset>
	using namespace std;

	int main()
	{
	int arr[] = {1,2,3,4,5,6,7,8,9,10,100000};
	long long arr2[10];
	
	//printing binary for all,
	for(int i=0;i<11;i++){
		string s = bitset<32> (arr[i]).to_string();
		long long j = 0;
	
		// Traversing string
		for (char c : s) {
			// Checking if the element is number
			if (c >= '0' && c <= '9') 
				j = j * 10 + (c - '0');
		}
		cout<<j<<endl;
		arr2[i] = j; 
		std::cout << s << std::endl;
	}
	
	std::cout << "Second array" << std::endl;
	for(int i=0;i<11;i++)
		std::cout << arr2[i] << std::endl;
	return 0;
	}
--------------------------------------------------------------------------------------------------------
//❌Pending
	//K Sum Subset https://www.codingninjas.com/studio/problems/k-sum-subset_2546852 ❌Pending

	// power of n without using looops & recursion ❌Pending
	https://www.geeksforgeeks.org/find-whether-given-integer-power-3-not/