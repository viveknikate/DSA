-When you start reading/ revising notes, read problem statement properly & think logical,
 if you don't understand the program, prefer try to resolve the problem by yourself.
-Google it if you don't understand the question.
	01/08/2023
Lecture-1
     -Understand the problem
     -check given data
     -search approach (make flowchart)
     -start programming

     -Flowchart:
          Diagrammatic representation of an approach
          Components:
               1.Terminator: start/end
               2.Parallelogram block   : represent IO/OP 
               3.Rectangular block: represent process
               4.Diamond: decision making (condition)
          e.g., Sum of 2 num:
	-Pseudocode:	Generic way of representing look of code.
	-Flowchart for Simple Interest
		SI = (P*R*T)/100
		eg.
			Calculate Simple Interest
				#include <bits/stdc++.h> 
				#include <iostream>
				using namespace std;

				int main(){
					float pr,time, RI;
					cin>>pr>>RI>>time;
					float ans;
					ans =(int) (pr*time*RI)/100;
					cout<<ans;
					return 0;
				}

	-Two colons (::) are used in C++ as a scope resolution operator

	-Flowchart for average of 3 num
		avg = (a+b+c)/3;

	-Greater between 2 num:
		a>b? print(a greater) : print(b greater);

		//Largest of 3 numbers
			#include <bits/stdc++.h> 
			#include <iostream>
			using namespace std;

			int main() {
				int a,b,c;
				cin>>a>>b>>c;
				cout<<max(a,max(b,c));
				return 0;
			}

	-Odd or even num:
		(num %2 ==0) ? print(even):print(odd)

	-num is +ve or -ve or zero?
		If(num >0) print(+ve)
		else if (num<0) print(-ve)
		else print(zero)
		
	-Valid triangle or not?
		Angles A, B & C
		A+B > C
		B+C > A
		C+A > B

	-Loops:
		-Print 1 to 5 nums.

		-print even nums from given range (copy paste program directly on compiler to check)

			#include <iostream>
			using namespace std;
			int main() {
				// Write C++ code here
				cout << "Range..!"<<"\n";
				int s=1,e=10,i;
				for(i=s; i<=e; i++){	
					cout<<i<<"\t";
				}
				cout<<"\neven nums.."<<"\n";
				for(i=s;i<e;i++){
					if(i%2==0){
						cout<<i<<endl;
					}else{
						continue;
					}
				}
				cout<<"\nend";
				return 0;
			}

		-Sum of 1 to N nums:
			#include <iostream>
			using namespace std;

			int main() {
				// Write C++ code here
				cout<<"Enter n::";
				int n;
				cin>>n;
				int sum = 0;
				
				// sum = n*(n+1)/2;
				//or
				for(int i=1;i<=n;i++){
					sum = sum +i;
				}
				cout<<"The sum of first "<<n<<" numbers ::"<<sum;
				cout<<"\nend";

				return 0;
			}

		-Factorial:
			#include <iostream>			//using namespace std not used here.
			int main() {
				std::cout<<"Enter n::";
				int n,fact=1;
				std::cin>>n;
				
				for(int i=1;i<=n;i++){
					fact = fact * i;
				}
				std::cout<<"The factorial of "<<n<<" is ::"<<fact;
				std::cout<<"\nend";

				return 0;
			}

				//or
					#include <iostream>
					using namespace std;

					int main() {
						int n;
						cin>>n;
						int fact=1;
						if (n == 0) {
							cout << 1;
							return 0;
						}else if (n<0){
							cout<<"Error";
							return 0;
						}else{
							while(n>0){
								fact = fact * n;
								n--;
							}
						}

						cout<<fact;
						return 0;
					}

		-Prime num:
			#include <iostream>
			int main() {
				// Write C++ code here
				std::cout<<"Enter n to check prime or not::";
				int n;
				std::cin>>n;
				bool flag = true;
				
				if(n == 1){
					std::cout<<"1 is neither prime nor composite";
					return 0;
				}
				
				for(int i=2;i<n;i++){
					if(n % i ==0){
						flag = false;
						break;
					}else{
						flag = true;
					}
				}
				
				if(flag){
					std::cout<<n<<" is Prime num.";
				}else{
					std::cout<<n<<" is not Prime num.";
				}
				
				std::cout<<"\nend";
				return 0;
			}
		
	-Compiler: convert High Level Language to Binary Language (machine understandable)
---------------------------------------------------------------------------------------------------------
	02/08/2023
Lecture-2:
	Compiler:
		-convert program to machine understandable Language ( Binary ).
		-checks the error & let you know.
	
	IDE: Integrated Development Environment
	
	-Program always start from main function.
	eg.
		#include <iostream>
		int main() {
			std::cout << "Hello world!"<<endl;
			return 0;
		}

		//if you used this statement no need to mention std in program
		using namespace std;
		#include <iostream>
		int main() {
			cout << "Hello world!";
			return 0;
		}

		where,
			std 			- is a namespace.
			cout 		- is function for printing
			<< 			- is outputing a output.
			endl  or '\n' 	- end line/ new line.
			; 			- represent end line.
		
	
	-Datatype & Variables:
		1 Byte is 8 bit.
		4bit is 1 nibble.
		int-
			size is 4 byte(32bit) generally (sometimes 2 bytes also, depends on compiler).
			Stores whole numbers, without decimals
			eg.
				int a = 20;

			min size -2³¹
			max size 2³¹-1
		
		char-
			size is 1 byte
			Stores a single character/letter/number, or ASCII values
			eg.
				char ch = 'a';		//valid

				char ch = 'ab';	//invalid
			
			Alternatively, you can use ASCII values to display certain characters:
			eg.
				char a = 65, b = 66, c = 67;
				cout << a;		//A
				cout << b;		//B
				cout << c;		//C

			-ASCII values:	ASCII - 'American Standard Code for Information Interchange'
				32 		is value of space.
				48 to 57 	is for 	0 to 9.
				65 to 90 	is for 	A to Z.
				97 to 122 is for 	a to z.

		boolean-
			1 byte	
			Stores true or false values
			you can keep any value for this boolean if it is non-zero(+ve) or -ve  then its considered as true (1).
				if it is zero then its considered as false(0).
			eg.
				bool a = true;

				bool b = 1,c =true, d = false;
				cout <<b<<endl;         //1
				cout <<c<<endl;         //1
				cout <<d<<endl;         //0
	
		float-
			4 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 6-7 decimal digits.
			eg.
				float f1 = 35e3;
				double d1 = 12E4;
				float ff = 35.453f;				//f to represent its is a floating point num.
				double dd = 12.78909d;			//d to represent its is a double
				cout << f1 << "\n";				// 35000
				cout << d1;					// 120000
		
		double-
			8 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits.
		
		NOTE:
			float vs. double
			The precision of a floating point value indicates how many digits the value can have after the decimal point. 
			The precision of float is only six or seven decimal digits, while double variables have a precision of about 15 digits. 
			Therefore it is safer to use double for most calculations.
		
		string-
			32 byte.
			string type is used to store a sequence of characters (text).
			This is not a built-in type, but it behaves like one in its most basic usage. 
			String values must be surrounded by double quotes:
			eg.
				#include <string>				//including this header file is not mandatory.
				string str  = "Vivek";
				cout << str;
			
		Variable Naming Convention:
			int abc1 = 1;			//valid
			int _abc = 21;			//valid
			int 1abc = -10; 		//invalid because the first character letter/underscore not number

		sizeof:
			eg.
				#include <iostream>

				int main() {
					bool c  = -12;
					int i   = 10;
					char ch = 'A';
					float f =  11.12; 
					double d   = 12.1245d;
					std::string str = "Vivek ";
					
					std::cout<<"The size of "<<c<<" Boolean :: "<<sizeof(c)<<" Byte\n";
					std::cout<<"The size of "<<i<<" integer :: "<<sizeof(i)<<" Byte\n";
					std::cout<<"The size of "<<ch<<" char :: "<<sizeof(ch)<<" Byte\n";
					std::cout<<"The size of "<<f<<" float :: "<<sizeof(f)<<" Byte\n";
					std::cout<<"The size of "<<d<<" double :: "<<sizeof(d)<<" Byte\n";
					std::cout<<"The size of "<<str<<" string :: "<<sizeof(str)<<" Byte\n";
					
					return 0;
				}

				//output
					The size of 1 Boolean :: 1 Byte
					The size of 10 integer :: 4 Byte
					The size of A char :: 1 Byte
					The size of 11.12 float :: 4 Byte
					The size of 12.1245 double :: 8 Byte
					The size of Vivek  string :: 32 Byte

		storing process:
			int is 4 bytes ie. 32 bits.
				4 blocks of bits are made
				eg.
					[-------- -------- -------- --------] this how integer converted to binary & store data in bits format.

		TypeCasting:
			when you assign a value of one primitive data type to another type.
			eg.
				int a = 'a';
				cout<<a;

				char ch = 98;
				cout<<ch;

				-int is 4 byte & char is 1 byte, if we try to store big integer to char
				 warning will be thrown & last 1 byte of data will be store in char.
				 eg.
				 	char ch = 123456		//binary of 123456 = 11110001001000000
					cout<< ch;			//@

					but char is of size 1 byte ie. 8 bits, so last 8 bit of binary 123456 will extracted ie.01000000 
						& rest all bits will be lost
					& if we print the ch then output will be @.
					coz this binary 01000000 is 64 in decimal.
					& 64 is mapped with @ char.
			
			eg.
				include <iostream>

				int main() {
					float f = 45.99f;
					int b = f;
					
					float f1 = b;
					
					std::string str = "1234";
					// int a = int(str);       // this won't work
					int a = stoi(str);       //to convert string to int
					
					std::cout<<a<<std::endl;		//1234
					std::cout<<a+6<<std::endl;	//1240
					
					std::cout<<f<<"\n";		//45.99
					std::cout<<b+2<<"\n";	//47
					std::cout<<f1<<"\n";	//45
					
					return 0;
				}

				#include <iostream>
				int main() {
					std::string str = "450";
					int a;
					std::cout<<str<<std::endl;
					std::cout<<a<<std::endl;
					std::cout<<stoi(str)+10;			string to integer stoi().
					return 0;
				}

		How -ve num stored:
			if first bit is 1, then num is -ve.
			if first bit is 0, then num is +ve.
			eg.
				want to store -8.
				step 1:	
					ignore negative sing(-ve)
					8
				step 2:
					convert 8 to binary format
					1000
					stored as
						[-------- -------- -------- ----1000] rest all are zero only like below,
						[00000000 00000000 00000000 00001000]

				step 3:
					-Take 2's (two's) complement & store.
					 for taking 2's complement first take 1's complement
					 
					 step 1: 
					 	1's complement change 0 to 1 & viceversa.
						[11111111 11111111 11111111 11110111]

					 step 2:
					 	add 1 in 1's complement.
						[11111111 11111111 11111111 11110111]
						+							1
						______________________________________
						[11111111 11111111 11111111 11111000]		
							--here in the answer first bit is 1, so it denotes its -ve num.
							--this is 2s complement of 8
				
				step 4:
					-To print that -ve num then take 2's complement of above output:
						[11111111 11111111 11111111 11111000]		
					
					-1's complement
						[00000000 00000000 00000000 00000111]
						+							1
						_____________________________________
						[00000000 00000000 00000000 00001000]
					
					now print above as its 8, but -ve.

		For +ve num only:
			unsigned int a = 122;
			range:
				0 to 2³²-1;

			if you try to store -ve num then it will generate huge num becoz 
			of most significant bit (first bit) is 1 to represent it is a -ve but,
			you said its +ve by mentioning usigned so compiler treat it as positive & generates huge num.
		
		Operator:
			Unary:
				increment (++)
				decrement (--)
				eg.
					postIncrement/postDecrement means the value will get incremented or decremented after using.
					old value gets used then value gets updated
						a++;		//postIncrement
						a--;		//postDecrement
					
					
					preIncrement/ preDecrement means the value will get incremented or decremented before using.
					value gets incresed or decresed first then it will gets used.
						++a;		//pretIncrement
						--a;		//pretDecrement
					
			Arithmetic:-
				+,-,*,/,%

				int/ int  = int		//if we divide int by int the answer will be integer
				float / int = float		//if we divide float by int the answer will be floating point num.
				double / int = double		//if we divide double by int the answer will be double.

			Relational:- 
				To Check
				== is equal to equal to (double equals to)
				< is less than
				> is greater than
				<= is less than equal to
				>= is greater than equal to
				!= is not equal to
			
			Assignment operator:
				=, +=, *=, -=, /=, %= etc
				eg.
					a = 10;
					a = a + 10;		-->		a += 10;
					a = a * 10;		-->		a *= 10;
					a = a - 10;		-->		a -= 10;
					a = a / 10;		-->		a /= 10;
					a = a % 10;		-->		a %= 10;

			Logical:-
				&& AND operation takes two boolean values and returns True if both are True else False.
				|| OR any one conditions should true for that statement to execute.
				! NOT reverse value.
				eg.
					ignores the sign.
					int a = 0;
						std::cout << !a;		//1
					int b = 1;
						std::cout << !b;		//0
					int c = 10;
						std::cout << !c;		//0
					int d = -10;
						std::cout << !d;		//0
					int e = -0;
						std::cout << !e;		//1

			Ternary Operator:
				syntax:
					(condition) ? ([if true execute this]) : ([if false execute this])
				eg.
					#include <iostream>
					using namespace std;

					int main() {
						int a = 100;
						
						//ternary operator
						(a>20) ? cout<< a << " Greater Than 20" : cout<< a << "Less than 20";

						return 0;
					}
				
				-for single statement don't use ( ) in ternary operator direct mention your statement.
				-for multiple statement to print or do operation use ( ).
				eg.
					printing twice,
						#include <iostream>
						using namespace std;

						int main()
						{
							int n =91;
							(n % 2 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or above there is just one condition so no need to use braces near condition also, like
							n % 2 == 0 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//if more than one condition is there in ternary operator, use braces ( ), for best practices
							//if you don't use still it works

							//first even condition is true but 2nd 400 is not less than 50, its false 
							//but && requires both condition must be true so complete equation is false,
							//ouput odd world.
							n =400;
							(n % 2==0 && n< 50 == 1) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							

							//ouput for below is even n<50 which is false means 0, & 0 == 0 so n= 400 is even & 0 == 0 both condition are true so even world will printed.
							(n % 2==0 && n< 50 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or even world will run
							//first condition is true, 2nd is false
							n=400;
							(n % 2==0 || n< 50) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
  
							//without braces
							//works fine and (,) comma is behaves like && operator,
							n % 2==0 && n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							n % 2==0 , n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							return 0;
						}

					initializing int inside ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							//syntax to initialize,
							(condition)? ([] {//initialization,//statement, //code})(): ([] {//initialization,//statement, //code})()

							//integer initialized
							n % 2 == 0 && n < 50 ? ([]{ int v = 80; cout << "Hello Even World " << v << " Hello 2nd World "; })() : ([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							//string initialized
							n%2 ? ([]{ string v = "Vivek"; cout << "Hello Even World " << v << " Hello 2nd World ";})() :([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							return 0;
						}

					ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							n % 2 == 0 && n < 50 ? ([]{
								int v = 80;
								string evenMessage = "Hello Even World " + to_string(v);
								string secondMessage = "Hello 2nd World";
								cout << evenMessage << " " << secondMessage;
							})() : ([]{
								string oddMessage = "Hello Odd World";
								string thirdMessage = "Hello 3rd World";
								cout << oddMessage << " " << thirdMessage;
							})();

							return 0;
						}

					string ternary:
						#include <iostream>
						using namespace std;

						int main()
						{
							string finalgrade = []() {
								int grade = 100;
								return (grade < 60) ? "fail" : "pass";
							}();

							std::cout << finalgrade << std::endl;

							return 0;
						}

			Bitwise:-
				& and
				| or
				^ xor
				~ complement of bits in binary representation
				<< left shift
				>> right shift
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-3:
	Conditionals, Loops, Patterns
	1) if Statement
		if(condition){
			//code block executed when condition evaluates as TRUE
		}

	2) if-else Statement
		if(condition){ 
			//This code block will be executed only if 'condition' is evaluated as TRUE
		}
		else{   
			//this block gets executed when if block evaluates to FALSE
		}
		
	3) else-if Statement
		if (cond_A) { 
			//first conditional expression
			/* statements */
		}
		else if (cond_B) {
			//second condtional expression
			/* other statements*/
		}
		else if (cond_C) {
			//third condtional expression
			/* other statements*/
		}
		else {
			/* last statement for default case */
		}
		//else is last default block not mandatory to write.
	
	4) Nested If statements / Nested If-else:
		if-statement inside another if statement

		if(cond){
			//if true
		}else{
			if(nestedCond){ 
				// nested condition code here
			} else{

			}
		}
	
	5) Switch Case Statement
			Why we use switch case instead of if-else?
				Editing in switch statement is easier as compared to the 'if-else' statement. 
				If we remove any of the cases from the switch, then it will not interrupt the execution of other cases. 
				Therefore, we can say that the switch statement is easy to modify and maintain.

				-If we have multiple choices then the
				switch statement is the best option as
				the speed of the execution will be much
				higher than 'if-else'

				-Break keyword:
					The break in C++ is a loop control statement that is used to terminate the loop. 
					As soon as the break statement is encountered from within a loop, 
					the loop iterations stop there and control returns from the loop immediately to the first statement after the loop.
				
				-Continue:
					C++ continue statement is a loop control statement that forces the 
					program control to execute the next iteration of the loop. As a result, 
					the code inside the loop following the continue statement will be 
					skipped and the next iteration of the loop will begin.

			eg.
				#include <iostream>
				using namespace std;

				int main() {
					char oper;
					float num1, num2;
					cout << "Enter an operator (+, -, *, /): ";
					cin >> oper;
					cout << "Enter two numbers: " << endl;
					cin >> num1 >> num2;

					switch (oper) {
						case '+':
							cout << num1 << " + " << num2 << " = " << num1 + num2;
							break;
						case '-':
							cout << num1 << " - " << num2 << " = " << num1 - num2;
							break;
						case '*':
							cout << num1 << " * " << num2 << " = " << num1 * num2;
							break;
						case '/':
							cout << num1 << " / " << num2 << " = " << num1 / num2;
							break;
						default:
							// operator is doesn't match any case constant (+, -, *, /)
							cout << "Error! The operator is not correct";
							break;
					}
					return 0;
				}
			


	6) While Loop:
		while loop require just a num inside as condition it may be -ve or +ve, it will work, 
		except the 0, if zero cames then loop breaks.
		eg.
			while(1)		//works
			while(100)	//works
			while(-23)	//works
			while(5)		//works

			while(0)		//stops this will breaks the loop.
			eg.
				#include <iostream>
				using namespace std;

				int main()
				{
					int i=1, b=-5;
					while(b++){
						std::cout << "say hii" << i++ << std::endl;
						//b++;
					}
					return 0;
				}

	 eg
	 	//WAP TO PRINT THE N NUMS:
			#include <iostream>
			using namespace std;

			int main() {
				int i=1;
				// while(i<11)
				//     cout << i++ <<"\t";
				//or
				
				while(i<11){
					cout << i << end;
					i++;                //i = i + 1
				}
				return 0;
			}

			#include <iostream>
			using namespace std;

			int main() {
				int i=1,n;
				cout << "enter n :: ";
				cin>>n;
				while(i<=n)
					cout << i++ <<"\t";
				//or
				
				//while(i<=n){
				//	cout << i << "\t";
				//	i++;                //i = i + 1
				//}
				return 0;
			}

		//WAP sum of first n num
			#include <iostream>
			using namespace std;

			int main() {
				int n,i=1,sum=0;
				cout << "enter n:: ";
				cin>>n;

				//shorthand
				while(i<=n)
					sum += i++;
				
				// or
				// while(i<=n){
				//     sum = sum + i;       //sum = sum + i
				//     i++;            //i = i +1;
				// }

				cout<< "The sum of "<<n<<" is "<<sum;
				
				return 0;
			}

		//WAP sum of even num
			#include <iostream>
			using namespace std;

			int main() {
				// sum of even num
				int n,i=2;
				cout << "Enter n:: ";
				cin>>n;
				
				int sum =0;
				while(i<=n){
					if(i % 2 == 0)
						sum = sum + i;
					i++;
				}
				
				// or shorhand
				// while(i <= n){
				//     if(i % 2 == 0)
				//         sum += i;
				//     i++;
				// }
					
				cout << "Sum of even till "<< n << " is :: "<< sum;
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					int sum=0;
					int n;
					cin>>n;

					for(int i=2;i<=n;i+=2)
						sum +=i;
					cout<<sum;
					return 0;
				}							
			
		//WAP to check entered num is prime or not?
			#include <iostream>
			using namespace std;

			int main() {
				//WAP num is prime or not.
				int n,i=2,flag=0;
				cout << "enter num :: ";
				cin>>n;
				
				while(i <= n/2){
					if(n % i == 0){
						flag = 1;
						break;
					}
					i++;
				}
				
				if(flag)
					cout << n << " is not prime";
				else
					cout << n << " is Prime Num";
				
				return 0;
			}
		
		//WAP to print:
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			->
				#include <iostream>
				int main() {
					int i=1,j=1;
					while(i++ <6){              //shorthands
						while(j++ < 8){         //shorthands for increment
							std::cout << "* ";
							// j++              
						}
						j=1;
						// i++;     
						std::cout<<"\n";
					}
					return 0;
				}
		
		//WAP to take rows & column from user.
			#include <iostream>
			int main() {
				int i=1,j=1,n;
				
				std::cout<<"Enter rows column :: ";
				std::cin>>n;
				
				while(i++ <n){              //shorthands
					while(j++ < n){         //shorthands for increment
						std::cout << "* ";
						// j++              
					}
					j=1;
					// i++;     
					std::cout<<"\n";
				}

				return 0;
			}
		
		//WAP to print this Patterns with custom rows:
		 if rows are 5,
			1 1 1 1 1 
			2 2 2 2 2 
			3 3 3 3 3 
			4 4 4 4 4 
			5 5 5 5 5
		     ->
			#include <iostream>
			int main() {
			
				int z,p,rows;
				std::cout << "Enter num of rows you want :: ";
				std::cin >> rows;
				for(z=1; z<=rows; z++){
					for(p=1; p<=rows; p++)
						std::cout << z << " ";
					std::cout<<std::endl;
				}
				return 0;
			}
			//output:
				Enter num of rows you want :: 8
					1 1 1 1 1 1 1 1 
					2 2 2 2 2 2 2 2 
					3 3 3 3 3 3 3 3 
					4 4 4 4 4 4 4 4 
					5 5 5 5 5 5 5 5 
					6 6 6 6 6 6 6 6 
					7 7 7 7 7 7 7 7 
					8 8 8 8 8 8 8 8

	eg.
		1).WAP to check num is +ve, -ve or zero?
			#include <iostream>
			using namespace std;

			int main() {
				cout<<"Enter value for A::";
				int a;
				cin>>a;
				if(a>0){
					cout<<"A is +ve "<<a;
				}else if(a<0){
					cout<<"A is -ve "<<a;
				}else{
					cout<<"A is Zero "<<a;
				}
				return 0;
			}
			--here cin function takes the input, cin function don't read tabs, space & new line char.

		2).WAP for Greater num
			#include <iostream>
			using namespace std;

			int main() {
				cout << "Enter values of A & B::";
				int a,b;
				cin >> a >> b;						//taking input at same time.
				
				cout << "A :: " << a << " B :: " << b << endl;
				if(a>b)
					cout << "A is Greater than B";
				else if(b > a)
					cout << "B is Greater than A";
				else
					cout << "A is equals to B";
				return 0;
			}

			--if there is one statement in if block then no need to put the { } curly braces

		3). WAP to check char is lowercase or uppercase or digit?
			#include <iostream>
			using namespace std;

			int main() {
				char ch;
				cout<< "Enter char :: ";
				cin>>ch;
				
				if(ch >= 'a' && ch<='z')
					cout << "Char is Lowercase "<<ch;
				else if(ch >= 'A' && ch <= 'Z')
					cout << "Char is Uppercase "<<ch;
				else if(ch >= '0' && ch <= '9')
					cout << "Char is Digit "<<ch;
				else
					cout << "Char is something Strange "<<ch;
				return 0;
			}

		-to take space, new line as input use cin.get() function.
			int a= cin.get();
			cout<<"A :: "<<a;
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-4:
	if 'return 0' is not there at the end still program works.
	Patterns solving
	1)	1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){            			//shorthand checking as well as incrementing king as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementing
					while(b <= n){          			//for be also you can increment while checking
						cout << b++ << " ";         	//shorthand (printing as well as incrementing)
						// b++;
					}
					b=1;
					// a++; 
					cout<<"\n";
				}

				return 0;
			}

	2)
		n = 5
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
		->
			#include <iostream>
			using namespace std;		

			int main() {
			
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n) {          //shorthand
					while(b <= n){    
						cout << n - b +1<< " ";
						b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}

	3)
		1	2	3 	4	 5
		6	7 	8 	9	 10
		11	12 	13 	14	 15
		16 	17 	18	19	 20
		21 	22 	23	24	 25
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1,counter=1;

				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){          //shorthand
					while(b++ <= n){    //shorthand
						cout<<counter++<<"\t";
						// b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}
	
	4) Start pattern for custom rows:
		Enter rows:: 5
			* 
			* * 
			* * * 
			* * * * 
			* * * * * 
		->
			#include <iostream>
			using namespace std;

			int main() {
			
				int n,a=1,b=1;
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){      //shorthand 
						cout<< "* ";
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			}
	
	5)
		take rows from user:
		 Enter rows:: 5
			1 
			1 2 
			1 2 3 
			1 2 3 4 
			1 2 3 4 5 
		->
			#include <iostream>
			using namespace std;

			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b <= a){      
						cout<< b++ <<" ";     //shorthand 
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}
			return 0;
			}
	
	6)
		take rows from user:
		 Enter rows:: 5
			1 
			2 2 
			3 3 3
			4 4 4 4
			5 5 5 5 5
		 ->
		 	#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){            //shorthand
						cout<< a <<" ";     
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			} 

	7)
		Take rows input from user..
			Enter rows:5
				1	
				2	3	
				4	5	6	
				7	8	9	10	
				11	12	13	14	15	
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,counter=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){        //shorthand
						while(b++ <= a){                    //shorthand
							cout << counter++ << "\t";      //shorthand
							// counter++;
							// b++;
						}
						b=1;
						a++;
						cout << "\n";
					}
					
					
					return 0;
				}

	8)
		Take user input for rows
			Enter rows:5
			1	
			2	3	
			3	4	5	
			4	5	6	7	
			5	6	7	8	9
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,temp;
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					temp = a;						//need to try without using extra var.
					while(b <= a){
						cout << temp++ << "\t";
						b++;
					}
					cout << "\n";
					a++;
					b=1;      //important step
				}
				return 0;
			}

			//or without using temp.
			#include <iostream>
			using namespace std;
			int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << a + b - 1 << "\t";
							b++;
						}
						cout << "\n";
						a++;
						b=1;      //important step
					}
					return 0;
			}
	
	9)
		Take user input for rows
			Enter rows:5
			1
			2 1
			3 2 1
			4 3 2 1
			5 4 3 2 1
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,temp;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						temp = a;
						while(b <= a){
							cout << temp-- << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
			
			//or without using that extra temp variable

				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						// temp = a;
						while(b <= a){
							cout << a - b + 1 << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}

	10)
		Take user input for rows
			enter rows:3
				A A A
				B B B
				C C C
			->	
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a++ <= n){						//shorhand
						while(b++ <= n){					//shorhand
							cout << ch <<" ";
							//b++;
						}
						ch++;
						//a++;
						b=1;
						cout<< "\n";
					}

					//for above while loop short code.
					// 	while(a++ <= n){
					// 	    while(b++ <= n)1
					// 	        cout << ch <<" ";
					// 	    ch++;b=1;
					// 	    cout<< "\n";
					// 	}


					return 0;
				}
			
			//without using that extra char ch variable.
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:";
				cin>>n;
				
				//using char function to convert the int to char.
				
				while(a <= n){
					while(b++ <= n)
						cout << char('A' + a - 1) <<" ";

					b=1;
					a++;
					cout<< "\n";
				}
				return 0;
			}
	
	11)
		Take user input for rows
			enter rows: 3
				A B C
				A B C
				A B C
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
						cout << ch << " ";
						b++;
					}
					ch++;
					a++;
					b=1;
					cout << "\n";
				}
				
				return 0;
			}

			//or without using that extra ch
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							
							cout << char(64 + a) << " ";					//ASCII value of A is 65 so we purposefully added 64 before it.
							
							//or
							//cout << char('A' + a - 1) << " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
		
	12)
		Take user input for rows
			Enter rows:5
			A B C D E 
			F G H I J 
			K L M N O 
			P Q R S T 
			U V W X Y 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
						cout << ch++ << " ";			//shorhand for ch.
							b++;
							//ch++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	14)
		Take user input for rows
		Enter rows:5
			A B C D E 
			B C D E F 
			C D E F G 
			D E F G H 
			E F G H I 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';

				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
					cout << ch++  << " ";
						b++;
						// ch++;
					}
					ch = 'A' + a;
					a++;
					b=1;
					cout << endl;
				}
				return 0;
			}

			//or without using that extra char ch.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							cout << char('A' + b - 1 + a - 1) << " ";			//to match the above pattern so we did adjustment.

							//or using ASCII value to print A , for first iteration (63 + 1 + 1 = 65) which is A.
							//cout << char(63 + b + a) << " ";
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	15)
		Take user input for rows
		  enter rows: 3
		  	A
			B B
			C C C
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
						cout << ch << " ";
						b++;
						}
						ch++;
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

			//without using ch char.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + a - 1) << " ";

							//or
							//cout << char(64 + a) << " ";

							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	16)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				D E F 
				G H I J 
				K L M N O 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b++ <= a)				//shorhand for b first checking then incrementing.
							cout << ch++ << " ";
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	17)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				C D E 
				D E F G 
				E F G H I
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							// cout << char('A' - 1 + b + a -1) << " ";
							// or
							cout << char(63 + b + a ) << " ";
							
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	18)
		Take user input for rows
			Enter rows:5
				E 
				D D 
				C C C 
				B B B B 
				A A A A A 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					
					while(a <= n){
						while(b <= a){
							cout << char(ch + n - a)<< " ";

							//or without using that char ch.
							//cout << char('A' + n - a)<< " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}	
					return 0;
				}

	19)
		Take user input for rows
			Enter rows:5
				E 
				D E 
				C D E 
				B C D E 
				A B C D E 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + n - a + b -1) << " ";
							b++;
						}
						a++;
						b=1;
						
						cout << "\n";
					}
					
					return 0;
				}

				//or short
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows:";
						cin>>n;
						
						while(a <= n){
							while(b <= a)
								cout << char(64 + n - a + b++) << " ";
							a++;b=1;
							cout << "\n";
						}
						return 0;
					}

	20)
		Take user input for rows
			Enter rows: 5
			     *
			    **
			   ***
			  ****
			 *****
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,c,temp;
			
				cout << "Enter rows: ";
				cin >>n;
				c=n;
				
				while(a <= n){  
					temp = c--;                 //shorthand for c
					while(temp >= 1){
						cout << " ";
						temp--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;
			}

			//or
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,space;
			
				cout << "Enter rows: ";
				cin >>n;
			
				while(a <= n){
					space = n - a;
					while(space){
						cout << " ";
						space--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;			
			}

	21)
			Take user input for rows
				Enter rows: 5
					XXXXX
					XXXX
					XXX
					XX
					X
				->
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows: ";
						cin >>n;
						b=n;
						
						while(a <= n){
							while(b--){         //b shorthand
								cout << "X";
								// b--;
							}
							b=n-a++;        //a shorthand
							// a++;
							cout << endl;
						}
						return 0;
					}

	22)Take user input for rows
		Enter rows: 5
			* * * * * 
			  * * * * 
			    * * * 
			      * * 
			        * 
		->
		#include <iostream>
		using namespace std;
		int main() {
			int n,a=1,b, space;
			
			cout << "Enter rows: ";
			cin >>n;

			b = n;
			
			while(a <= n){
				space = a - 1;
				while(space--){         //space shorthand
					cout << "  ";
					// space--;
				}
				while(b--){             //b shorthand
					cout << "* ";
					// b--;
				}
				
				b= n - a;
				a++;
				cout << "\n";
			}
			return 0;
		}

	23)Take user input for rows
		Enter rows: 5
			1 1 1 1 1 
			  2 2 2 2 
			    3 3 3 
			      4 4 
			        5 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b, space;
				cout << "Enter rows: ";
				cin >>n;
				b = n;
				
				while(a <= n){
					space = a - 1;
					while(space--){         //space shorthand
						cout << "  ";
						// space--;
					}
					while(b--){             //b shorthand
						cout << a <<" ";
						// b--;
					}
					
					b= n - a;
					a++;
					cout << "\n";
				}	
				return 0;
			}

	24)Take user input for rows
		Enter rows:5
						1
					2	2
				3	3	3
			4   	4	4	4
		5  	5	5	5	5
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			space = n-1;
			
			while(i <= n){
				while(space--){                 //shorthand for space 
					cout << "  ";
					// space--;
				}
				
				while(j++ <= i){                //shorthand for j
					cout << i << " ";
					// j++;
				}
				i++;
				j = 1;
				
				space = n - i;          //important step.
				
				cout << "\n";
			}

			return 0;
		}

	25)Take user input for rows
	 Enter rows:4
		1 2 3 4
		  2 3 4
		    3 4
		      4
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){
				
				//spacing
				space = 1;
				while(space < i){
					cout << "  ";
					space++;
				}
				
				//printing num
				while(j <= n){
					cout << j << " " ;
					j++;
				}
				cout << "\n";
				i++;
				j=i;            //important step
			}
			return 0;
		}

	26)Take user input for rows
	    Enter rows:4
					1
				2	3
			4	5	6
		7	8	9	10
	   ->
	   	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,counter=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){	
				//spacing
				space = n - i;
				while(space--){		//shorhand for space
					cout << "\t";
				}
				
				while(j <= i){
					cout << counter++ << "\t";
					j++;
				}
				i++;
				cout << "\n";
				j=1;
			}	
			return 0;
		}

	27)Take user input for rows
		Enter rows:4

						1
					1	2	1
				1	2	3	2	1
			1	2	3	4	3	2	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, k=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--) {
						cout << "  ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << j << " ";
						j++;
					}
					
					while(k < i){
						cout << i - k << " ";
						k++;
					}
					
					cout<<endl;
					k=1;
					j=1;
					i++;
				}				
				return 0;
			}

	28)Take user input for rows
		Enter rows:5
		1	2	3	4	5	5	4	3	2	1
		1	2	3	4	*	*	4	3	2	1
		1	2	3	*	*	*	*	3	2	1
		1	2	*	*	*	*	*	*	2	1
		1	*	*	*	*	*	*	*	*	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space=1;
				
				cout << "Enter rows: ";
				cin >> n;
				
				while(i <= n){
					
					//start looping
					while(j <= n-i+1){              //important step
						cout << j  << " "; 
						j++;
					}
					
					//spacing
					while(space < i){
						cout << "* * ";
						space++;
					}
					
					//reverse loop
					while(--j){
						cout << j << " ";
					}
					
					//resetting the values
					j=1;
					space=1;
					
					cout << endl;
					i++;
				}
				return 0;
			}
			//output
				Enter rows: 5
					1 2 3 4 5 5 4 3 2 1 
					1 2 3 4 * * 4 3 2 1 
					1 2 3 * * * * 3 2 1 
					1 2 * * * * * * 2 1 
					1 * * * * * * * * 1 

	29) pyramid start pattern:
		Enter rows: 5
 			    * 
 			   * * 
 			  * * * 
 			 * * * * 
 			* * * * *
		->

			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--){
						cout << " ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << "* ";
						j++;
					}
					cout<<endl;
					j=1;
					i++;
				}
				return 0;
			}
---------------------------------------------------------------------------------------------------------
	04/08/2023
Lecture-5:
	Bitwise Operators, For Loops, Operator Precedence & Variable Scoping
	-Bitwise Operator
		This operator will work on BIT level.
			1). AND (&)
			2). OR (|)
			3). NOT (~)
			4). XOR (^)
		
		Let’s look at the truth table of the bitwise operators
			  Operator	Description				Example
				&		Bitwise AND	 			a & b
				|		Bitwise OR	 			a | b
				^		Bitwise XOR	 			a ^ b
				~		Bitwise NOT (Complement)		  ~a
				<<		Bitwise Left Shift			a << n
				>>		Bitwise Right Shift			a >> n


		Table:
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   a   |   b   | a & b | (a | b)| a ^ b |   ~a  | a << 1 | a >> 1 |
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   0   |   0   |   0   |   0    |   0   |   1   |   0    |   0    |
			|   0   |   1   |   0   |   1    |   1   |   1   |   0    |   0    |
			|   1   |   0   |   0   |   1    |   1   |   0   |   2    |   0    |
			|   1   |   1   |   1   |   1    |   0   |   0   |   2    |   0    |
			+-------+-------+-------+--------+-------+-------+--------+--------+


		eg.
			#include <iostream>
			#include <bitset>
			using namespace std;

			int main() {
				// Bitwise AND (&)
				int a = 12;  // 1100 in binary
				int b = 25;  // 11001 in binary
				int result_and = a & b;
				cout << "Bitwise AND: " << result_and << " (" << bitset<8>(result_and) << ")" << endl;  // Output: 8 (00001000)

				// Bitwise OR (|)
				int result_or = a | b;
				cout << "Bitwise OR: " << result_or << " (" << bitset<8>(result_or) << ")" << endl;  // Output: 29 (00011101)

				// Bitwise XOR (^)
				int result_xor = a ^ b;
				cout << "Bitwise XOR: " << result_xor << " (" << bitset<8>(result_xor) << ")" << endl;  // Output: 21 (00010101)

				// Bitwise NOT (~)
				int result_not = ~a;
				cout << "Bitwise NOT: " << result_not << " (" << bitset<8>(result_not) << ")" << endl;  // Output: -13 (11110011)

				// Bitwise Left Shift (<<)
				int n_left = 2;
				int result_left = a << n_left;
				cout << "Bitwise Left Shift: " << result_left << " (" << bitset<8>(result_left) << ")" << endl;  // Output: 48 (00110000)

				// Bitwise Right Shift (>>)
				int n_right = 2;
				int result_right = a >> n_right;
				cout << "Bitwise Right Shift: " << result_right << " (" << bitset<8>(result_right) << ")" << endl;  // Output: 3 (00000011)

				return 0;
			}
		
			Practice:
				#include <iostream>
				using namespace std;

				int main()
				{
					int a=4,b=6;
					
					cout<<"A&B "<< (a&b) << endl;           //4
					cout << "A|B "<< (a|b) << endl;         //6
					cout << "A^B "<< (a^b) << endl;         //2
					cout << "~A "<< (~a) << endl;           //-5
					
					//~a --> 32 bit
						// 4 ==> [-------- -------- -------- -----100] all bits are zero 
						// ~a ==> [11111111 11111111 11111111 11111011]    reverse of above 
						
						// from first bit you can say that it's -ve num.
						//     so before to print take its 2's complement
						//     1's complement [-------- -------- -------- -----100] adding + 1 in it.
						//     ==> [-------- -------- -------- -----101]
							//this above binary in decimal is 5 so ans is -5.
					return 0;
				}
		
		-Left shift:
			syntax.
				var << num;
			eg.
				5 << 1		ie.		101 after shifting 1 bit to left 1010, so 1010 is 10.
				3 << 2         ie. 		011 after shifting 2 bit to left 1100 so its 12.

		-NOTE: here you can see when we use left shift it will get multiplied by 2 in most cases.
				but BE CAREFULL SOMETIME IT WILL GENERATE AN -VE NUM ALSO, WHEN NUM IS TOO LARGE,
				SO, ITS NOT LIKE THAT WHEN WE DO LEFT SHIFT THEN IT'LL GET MULTIPLIED BY 2.
			
		-Right Shift:
			syntax.
				var >> num;
			eg.
				15 >> 1;			ie. right shift by 1 bit.
				
				5 >> 2;			ie. right shift by 2 bit,
								101 >> 2 -->	001 its 1.

				5/2 = 2 ------- pass 1
				2/2 = 1 ------- pass 2	
				so 5 >> 2 => 1
		
		NOTE: 
			either it is a left shift(<<) or right shift(>>) to any +VE NUM, 
			then num of bits padded with zero(0). (means zero will get added after shifting).

			else if the num is -ve then padding will depends on compiler
		
		eg.
			int a=1,b=2;

			if(a-- >0 && ++b > 2)				//it will check for b also cause && require all condition must be true
				cout<<"if";
			else
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 3 
		
			//OR
			int a=1,b=2;
			if(a-- >0 || ++b > 2)				//it will check for a only, cause one condition needs to be true,
				cout<<"if";					//so if first condition is true then control don't go for next condition & 
			else								//b won't get incremented also. check output
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 2
		
	-For Loop:
		flow:
			once we visit initialization part, 
			then for next all iteration we just check the condition & updation value.

		for(initialize; condition; increment/ decrement){
			//statement
		}
		//or
		for(;;){
				
		}
		eg.
			for(int i=1; i<=5; i++){
				cout << i;
			}
			//or

			int i = 1;
			for(;;){
				if(i<=n){
					cout << i++ ;
				}else{
					break;
				}
			}

			//multiple
			for(int a=0, b=1; a>=0, b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;

			for(int a=0, b=1; a>=0 && b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;
		
		1). WAP Sum of n
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, sum=0;
				cout << "enter n ";
				cin>>n;
				for(int i =1; i<=n; i++)
					sum += i;
					
				std::cout <<"The sum of "<<n<<" num is "<<sum << std::endl;
				
				return 0;
			}
		
		2). WAP for Fibonacci series
			#include <iostream>
			using namespace std;

			int main()
			{
				int n,prev=0, cur=1,temp;
				cout << "enter n ";
				cin>>n;
				
				for(int i =1; i<=n; i++){
					
					cout << prev << " ";
					
					temp = cur + prev;
					prev = cur;
					cur = temp;
					
				}
					
				return 0;
			}
		
		3). check entered num is Prime num or not?
			#include <iostream>
			using namespace std;

			int main()
			{
				int n;
				cout << "Enter num : ";
				cin >> n;
				
				bool PRM = true;
				
				for(int i=2; i < n/2; i++)
					if(n % i == 0){
						PRM = false;
						break;
					}
				
				if(PRM)
					cout << n << " is prime num.";
				else
					cout << n << " is not prime num.";
				
				cout << endl << "END";
				return 0;
			}
		
		4). Print all prime nums between given range
			#include <iostream>
			using namespace std;

			int main()
			{
				int startNum, endNum;
				
				std::cout << "Enter Range to print all Prime nums in-between : " << std::endl;
				
				std::cout << "Enter Starting num :: ";
				std::cin >> startNum;
				
				std::cout << "Enter Ending num :: ";
				std::cin >> endNum;
				
				std::cout << "Prime nums in-between given range :: " << std::endl;
					
				for(int i = startNum; i <= endNum; i++){
					
					bool PRM = true;
					
					if( i == 1){
						std::cout << "1 neither prime nor composite" << std::endl;
						continue;
					}
					
					for(int j=2; j <= i/2; j++)
						if(i % j == 0){
							PRM = false;
							break;
						}
					
					if(PRM)
						std::cout << i << " is Prime num." << std::endl;
					else{
						// std::cout << i << " is not Prime num." << std::endl;
						continue;
					}
				}
				
				cout << endl << "END";
				return 0;
			}

		5). 

	-Variable & Scope:
		-You can't create same variable within single block.
		eg.
			#include <iostream>
			int main()
			{    
				int a =10;
				std::cout << a << std::endl;                //10
				
				if(true){
					std::cout <<"inside if before creating "<< a << std::endl;          //10
					int a = 89, b = 77;
					std::cout <<"inside if after creating "<< a << std::endl;           //89
					std::cout << "b = "<< b << std::endl;
				}
				
				// std::cout << "b" <<b<< std::endl;                       //you cant access b outside if block
				std::cout << "Outside if : "<< a << std::endl;          //10
				
				int i=1;
				for(int i= 5;i<=5;i++)
					std::cout << "HII" << std::endl;
					
				//below code works fine.
				if(1){
					int b;
					
					if(1){
						int b;
						
						if(1){
							int b;
							
							if(1){
								int b;
							}
						}
					}
				}
				std::cout << std::endl << "END";
				return 0;
			}

	-Operator Precedence:
		BODMAS
			-Brackets
			-Orders (Exponents and Roots): 
				Evaluate exponents and roots next. This includes calculations involving powers (^) and square roots (√).
			D - Division
			M - Multiplication
			A - Addition
			S - Subtraction
		
	-Practice:
		1].WAP print the difference of product & sum of given num.
		
			#include <iostream>
			using namespace std;

			int main()
			{
				int num;
				cout << "Enter num ";
				cin >> num;
				
				int sum =0 , prod=1;
				
				while(num > 0){
					int temp = num % 10;
					
					sum = sum + temp;
					prod = prod * temp;
					
					num = num / 10;
				}
				
				std::cout << "SUM "<< sum << std::endl;
				std::cout << "Product "<< prod << std::endl;
				std::cout << "Product - SUM "<< prod-sum << std::endl;
				
				cout << "END";
				return 0;
			}

		2]. WAP to count  Number of 1 Bits in given num:
			#include <iostream>
			using namespace std;

			int main()
			{
				int count =0,n=123;
				while(n > 0){
					if(n & 1){
						c++;
					}
					n >>= 1;
				}
				cout << "no.of 1 bit " <<count;
			}
		
		3]. Reverse integer

			int reverse(int n) {
				int rev = 0;
				while(n){
					if( rev > INT_MAX/10 || rev < INT_MIN/10)   return 0;		//if crossing the limit then return 0.
					rev = (rev * 10) +  n % 10;
					n /= 10;
				}
				return rev;
			}

			#include <iostream>
				using namespace std;
				int main()
				{
					int rev = 0, n;
					
					cin>>n; //123

						while(n > 0){
							int lastDigit = (n % 10);
							rev = rev * 10 + lastDigit;
							n /= 10;
						}
						cout << rev;
					return 0;
				}

			int reverse(int x) {
				int rev = 0, n = abs(x);				//abs() it convert num -ve to +ve, & +ve is +ve only. 

				while(n > 0){
					rev += (n % 10);
					
					if(n > 10){
						rev *= 10;
					}
					
					n /= 10;
				}
				if(x <0 )
					return -rev;
	
				return rev;
			}

			//using do-while loop.
			#include <iostream>
				using namespace std;

				int main()
				{
					int n;
					std::cout << "enter n:" << std::endl;
					cin>> n;
					int rev =0;
					
					do{
						rev = (n % 10) + rev * 10;
					}while(n /=10);
					
					cout<<"The Reverse "<< rev;
					return 0;
				}
	
		4]. WAP to find entered num is even or odd.
			#include <iostream>
			using namespace std;
				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					if( num % 2 == 0)
						cout << num << " is Even." <<endl;
					else
						cout << num << " is Odd." <<endl;

					//or
					//(num % 2 == 0)? std::cout << num << " is Even" : cout << num << " is odd";


					return 0;
				}

			//or without using modulo operator,
				cout << (num & 1 == 1); 
				-This part is attempting to check whether the least significant bit (LSB) of num is 1. 
				However, the code is not written correctly for this purpose.
				The issue lies in operator precedence. 
				The equality operator (==) has higher precedence than the bitwise AND operator (&). 
				So, the expression is evaluated like this:
					(num & (1 == 1))
				
				To fix this issue add parentheses,
					cout << ((num & 1) == 1);
				#include <iostream>
				using namespace std;

				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					((num & 1) == 1) ? printf("%d is Odd num",num) : printf("%d is Even num.",num);

					//or
					//((num & 1) == 0) ? printf("%d is Even num.",num) : printf("%d is Odd num",num) ;
	
					return 0;
				}

			//or
				first division then multiply, it because of rounding in integer,
				#include <iostream>
				using namespace std;
				int main() {
					int num;
					std::cout << "Enter num: ";
					std::cin >> num;

					if((num / 2) * 2 == num)
						cout << "even"<<std::endl;
					else
						cout << "Odd"<<std::endl;
						
					std::cout << "End" ;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	05/08/23
Lecture-6:
	Binary & Decimal Num System
		1) Decimal to Binary
			-divide by 2.
			-Store remainder
			-repeat above 2 step until n != 0.
			-at last reverse the answer
			eg.
				5 -> 101
				7 -> 111
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int num, i=0;
					std::cout << "Enter num :" << std::endl;
					cin>>num;
					
					int binaryForm = 0;
					cout << "Binary of " << num << " is ";
					
					while(num){
						int bit = num & 1;
						
						binaryForm = (bit * pow(10,i++)) + binaryForm;
						
						num >>= 1;          //num = num >> 1;
					}
					std::cout << binaryForm <<std::endl;	
					return 0;
				}
			
			eg. to keep same sequence of num.
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int a = 203,b=0,last,i=0;
					
					std::cout << a << std::endl;
					
					while(a){
						last = a % 10;
						b = b + last* pow(10,i++);
						a /=10;
					}

					cout<<b;
					return 0;
				}

			//Homework -ve num to binary
				->

		2) Binary to Decimal
			-multiply by 2's power to that numbers binary bit
			-if that bit is 1, then consider 2's power else ignore
			-last add all 2's power

				1 -> 1011

				=(2⁰ * 1) + (2¹ * 1) + (2² * 0) + (2³ * 1)
				=1+2+0+8
				=11.
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int num,i=0;
					std::cout << "Enter num in binary : " << std::endl;
					cin>>num;            //1010
					
					int deci=0;

					//using while loop
					while(num){
						
						if(num % 10 == 1)					//if(num%10)
							deci = pow(2,i) + deci;
						i++; 
						num /= 10;
					}
					
					//or using do-while loop
					//do{
					//	if(num % 10 == 1)				//if(num%10)
					//		deci = pow(2,i) + deci;
					//	i++;
					//}while(num /=10);

					cout << "The Decimal num is :: "<<deci;
					return 0;
				}
		
		#Bitset:
			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<5> bits; // Creates a bitset with 5 bits, initialized to all zeros
				
				bits[2] = 1; // Set the third bit to 1
				std::cout << "Bitset value: " << bits << std::endl; // Output: 00100
				
				return 0;
			}

		eg.
			#include <bitset>
			std::bitset<8> bits; // Creates a bitset with 8 bits, initialized to all zeros
			std::bitset<8> anotherBits("10101010"); // Initializes the bitset with the given binary string

			std::bitset<32> thirtyTwoBits;   // Creates a bitset with 32 bits
			std::bitset<64> sixtyFourBits;   // Creates a bitset with 64 bits
			std::bitset<128> oneTwentyEightBits; // Creates a bitset with 128 bits
		eg.
			it's okay to define a std::bitset<8> and initialize it with a binary string that has fewer than 8 characters. 
			The missing bits will be implicitly set to 0. In your example, std::bitset<8> anotherBits("101"), 
			since the binary string "101" has only 3 characters, the remaining 5 bits will be set to 0, 
			resulting in a bitset equivalent to "00000101".

			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<8> anotherBits("101"); // Initializes the bitset with "101"

				std::cout << "Bitset value: " << anotherBits << std::endl; // Output: 00000101

				//printing any binary num
					int n;
					cin>>n;
					std::cout << "n "<< bitset<8>(n) << std::endl;
   				
				return 0;
			}
				In this example, the std::bitset<8> is initialized with the binary string "101", 
				which fills the lower three bits. The remaining bits are automatically set to 0, 
				resulting in the bitset value "00000101".
---------------------------------------------------------------------------------------------------------
	06/08/23
Lecture-7:
	LeetCode Problem Solving Session
	eg.
		max/min int printing:
			#include<climits>				
				cout<<INT_MIN;				//minimum value of int stored in INT_MIN
				cout<<INT_MAX;				//maximum value of int stored in INT_MAX

	Practice:
		1]. Complement of base 10 integer
			5 -> 101
			complement -> 010
			which is 2 in decimal

			7 -> 111
			complement -> 000
			which is 0 in decimal

			#include <iostream>
				#include<bitset>
				using namespace std;

				int main()
				{
					
					int n;
					cin>>n;
					
					if(!n){                                 //if(n == 0)
						cout << "new num "<< !n;            //cout << "new num "<< 1;
						return 0;
					}
					
					int temp = n, mask=0;
					
					while(temp){
						mask <<= 1;              //mask = mask << 1;
						mask |= 1;               //mask = mask | 1;
						temp >>=1;               //temp =  temp >> 1;
					}
					
					n = (~n) & mask;
					
					cout << "new num "<<n;
					
					return 0;
				}

			LeetCode:
				int bitwiseComplement(int n) {

					if(!n){
						return !n;
					}

					int temp = n,mask=0;

					while(temp){
						mask <<=1;
						mask |= 1;
						temp >>= 1;
					}

					n = (~n) & mask;
					return n;
				}

		2]. Given num is representation of power of 2.	(hint if no.of setbits = 1 then that num is power of 2)
			#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int n,i=0;
					cin>>n;
					
					while(n >=1){
						int temp = pow(2,i++);
						if(n == temp){
							std::cout << "TRUE" << std::endl;
							return 0;
						}
						
						if(temp > n)
						{
							cout <<"FALSE";
							return 0;
						}
					}
					cout << "FALSE";
					return 0;
				}
				//or
					int main()
					{
						int a;
						
						std::cout << "Enter num " << std::endl;
						cin>>a;
						
						for(int i=0; ;i++){
							int temp = pow(2,i);
							if(temp == a){
								std::cout << "Yes power of 2" << std::endl;
								break;
							}
							
							if(temp > a){
								std::cout << "No it's not power of 2" << std::endl;
								break;
							}
						}
						
						std::cout << "END" << std::endl;
						return 0;
					}

			LeetCode:
				bool isPowerOfTwo(int n) {
					int temp=1;					
					while(n>=1){
						if(n == temp)
							return true;
						
						if(temp > n)
							return false;

						temp = temp * 2;
					}
					return false;
				}	

				//or
				if(n==0) return false;
				while(n%2==0) n/=2;
				return n==1;	
---------------------------------------------------------------------------------------------------------
	07/08/23
Lecture-8:
	Switch case & functions:
		syntax.
			switch(condition){
				case value_1 :
					//statement block ;
					break;
					
				case value_2:
					//statement block ;
					break;

				case value_3:
					//statement block;
					break;

				default:
					//statement block ;
			}
			--here for above case no need to use break after default, coz default is at the last of switch case,
				so it will automatically go out of switch case and continue with next line.

			--in place of condition in switch case [switch(condition)], you can keep integer or character value,
				but not float / string value.
				you can keep expression also, like	
				switch(a+b*10)		which generates an constant value.
				
			
			--default case is not mandatory, if its there in code then GOOD, if its not then NO WORRIES.
			--default case is better to keep at last,
		->		
			Include break after default: 
				If you want the switch statement to exit immediately after the default case is executed, 
				you should include a break statement. This prevents the program from continuing to execute 
				code in other case blocks that come after the default case.
				switch(condition){
					case value_1 :
						//statement block ;
						break;
						
					case value_2:
						//statement block ;
						break;

					default:
						//statement block ;
						break;
					
					case value_3:
						//statement block;
						break;
				}

				--if the code is like this above then better to keep the break after default, if you don't 
					write break; after default, then it'll continues to executes the next cases which are after default.

				Nested switch:
					switch(condition){
						case value_1 :
							//statement block ;
							break;
							
						case value_2:
							switch(condition){
									case value_1 :
										//statement block ;
										break;
										
									case value_2:
										//statement block ;
										break;

									default:
										//statement block ;
										break;
									
									case value_3:
										//statement block;
										break;
								}
							break;

						default:
							//statement block ;
							break;
						
						case value_3:
							//statement block;
							break;
					}
		
		eg.
			#include <iostream>
			using namespace std;

			int main()
			{
				int num = 1;
				char ch = '1';
				switch(ch){
					case '2':
						std::cout << "2nd Character" << std::endl;
						break;
						
					case '3':
						std::cout << "3rd Character" << std::endl;
						break;
						
					case '1':
						switch(num){
							case 1:
								std::cout << "1st Character Nested switch" << std::endl;
								break;
						}
						break;
						
					default:
						std::cout << "Default case" << std::endl;
				}
				return 0;
			}
			//output : 1st Character Nested switch

		-Function exit(0)
			--used to come out from infinite loop if we got stuck, without using break. 
			--The most common convention is to use exit(0) to indicate successful execution.
			--and exit(1) (or any non-zero value) to indicate an error or abnormal termination.

			#include <iostream>
			#include <stdlib.h>
			using namespace std;

			int main()
			{
				int num = 1;
				
				while(1){
					std::cout << num << std::endl;
					if(num > 10)
						exit(0);
					num++;
				}
			return 0;
			}
		
		Practice:
			#include <iostream>
				using namespace std;

				int main()
				{
					int a,b;
					char Op;
					
					std::cout << "Enter A :: ";
					std::cin >> a;
					std::cout << "Enter B :: ";
					cin>>b;
					
					cout<<"Enter Operation want to perform: ";
					cin>>Op;
					
					switch(Op){
						case '+':
							{
								std::cout << "Addition: " <<a+b << std::endl;				//you can use Brackets for cases also.
								break;
							}
							
						case '*':
							{
								std::cout <<  "Multiplication: " << a*b << std::endl;
							}
							break;
						
						case '-':
							std::cout <<  "Subtraction: " <<  a-b << std::endl;
							break;
						
						case '/':
							std::cout <<   "Division: " << a/b << std::endl;
							break;
						
						case '%':
							std::cout <<  "Remainder: " <<  a%b << std::endl;
							break;
						default:
							cout << "Not Matching Operation.\n";
					}
					
					std::cout << "END" << std::endl;
					return 0;
				}

			#include <iostream>
				using namespace std;

				int main()
				{
					int num;
					std::cout << "Enter Num : " << std::endl;
					cin >>num;
					
					switch(1){
						
					}
					int temp = num;
					//1234      =12
					
					std::cout << "you need "<< num/ 100 << " 100 notes" << std::endl;        //12
					num -= (num/100) * 100;                     //1234-1200 = 34
					
					std::cout << "you need "<< num / 50 << " 50 notes" << std::endl;         //0
					num -= (num/50) * 50;                                               //34
					
					std::cout << "you need "<<num/20 << " 20 notes" << std::endl;        //1
					num -= (num/20) * 20;                                           //34-20 =14
					
					std::cout << "you need "<< num/10 << " 10 notes" << std::endl;       //1
					num -= (num/10) * 10;                                       //14-10=4
					
					std::cout << "you need "<< num/1 << " 1 coins" << std::endl;       //4
					num = num;

					std::cout << "For "<<temp<<" Amout." << std::endl;
					
					std::cout << "END" << std::endl;
					return 0;
				}	

		Functions:
			A function is a block of code that performs a specific task.
			Suppose we need to create a program to create a circle and color it. We can create two functions to solve this problem:

				a function to draw the circle
				a function to color the circle
			Dividing a complex problem into smaller chunks makes our program easy to understand and reusable.

			There are two types of function:
				Standard Library Functions: Predefined in C++
				User-defined Function: Created by users 
			
			syntax to declare a function is:

				returnType functionName (parameter1, parameter2,...) {
					// function body   
				}

				Here's an example of a function declaration.
				
				// function declaration
				void greet() {
					cout << "Hello World";
				}

				Here,
					the name of the function is greet()
					the return type of the function is void
					the empty parentheses mean it doesn't have any parameters
					the function body is written inside {}
				
				Calling a Function
					In the above program, we have declared a function named greet(). 
					To use the greet() function, we need to call it.
					Here's how we can call the above greet() function.
						greet();
			eg.
				Power of n, pow(a,b);
					#include <iostream>
					using namespace std;

					int power(int, int);            //function declaration,because after main function
											//we are giving the function definition
					int main()
					{
						int a,b;
						std::cout << "Enter a, b :: " << std::endl;
						std::cin >> a>>b;
						
						int ans = power(a,b);
						
						cout<<"Power "<<ans;
						
						return 0;
					}

						int power(int a, int b){

							if(a == 0)                  //if(!a)
								return 0;       
							
							int t=a;
							while(--b){
								a = a * t;
							}
							return a;
						}
					
					//or
						Find power of a number
						#include <bits/stdc++.h> 
						#include <iostream>
						using namespace std;

						int main() {
							int n,x;
							cin>>x>>n;
							int ans = pow(x,n);
							int mod = 1e9+7;
							cout<< ans % mod;
							return 0;
						}

				Even Odd function:
					#include <iostream>
					using namespace std;

					bool isEven(int);        //function declaration

					int main()
					{
						int a;
						std::cout << "Enter a ";
						cin >> a;
						
						// (a&1)?cout<<"Odd":cout<<"Even";      
						//or
						
						isEven(a)?cout<<" Even": cout<< " Odd";         //using function
						
						return 0;
					}

						bool isEven(int num){
							if(num % 2 ==0)
								return 1;
							return 0;
						}

				nCr= n!/(r!* (n-r)!)
					#include <iostream>
					using namespace std;

					int fact(int);
					int nCr(int, int); 	          //function declaration  its not required if 
											//we defined function before main function
											//but here we are giving the function definition after main function.
					int main()
					{
						int n,r;
						cout<<"Enter n & r :: ";
						cin>>n>>r;
						
						cout<<n<<"C"<<r<<" = "<< nCr(n,r);
						return 0;
					}

						int nCr(int a, int b){
						
						int NMR = fact(a);                  //numerator
						
						int DNMR = fact(b) * fact(a-b);                     //denominator
						
						return NMR/DNMR;
					}

					int fact(int num){
					
						if(num == 0)
							return 1;
						int t = num;
						
						for(int i=1; i<t; i++)
							num *= i;                               //num = num * i;

						return num;
					}

				Printcouting:
					//void function returns nothing, 

					#include <iostream>
					using namespace std;

					// void printCouting(int);             //function declaration no need here coz 
												//we defined the function with its definition here.

					void printCouting(int c){
					for(int i=1;i<=c;i++)
						std::cout << i << std::endl;
					}

					int main()
					{
						int n;
						cin>>n;
						
						printCouting(n);
						
						std::cout << "END" << std::endl;
						return 0;
					}

				isPrime:
					#include <iostream>
					using namespace std;

					bool isPrime(int num){
						for(int i=2; i<= num/2; i++)
							if(num % i == 0)
								return 1;
						
						return 0;
					}

					int main()
					{
						
						int n;
						cin>>n;
						
						isPrime(n)? cout<<"NO "<<n<<" is NOT Prime num" :cout<<"Yes "<<n<<" is Prime num"; 

						return 0;
					}

				NOTE:
					You can use return in void returnType function without specifying any number;
					eg.
						This is OK.
						void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;							
								return ;
							}
						
						This is not OK.
							void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;
								
								return 0;						//here return 0, void doesn't return anything will generate error.
							}

			function calling stack:
				FILO	: First in Last out
			
			-Parameter/ argument:
				Formal Parameter:
					-A variable and its type as they appear in the prototype of the function or method.
					-Formal parameters are declared in the function signature and 
					 act as placeholders for values that the function will receive.
					 eg.
					 	void displayNumber(int num); // Formal parameter: "int num"

				Actual Parameter: 
					-The variable or expression corresponding to a formal parameter that appears in 
					 the function or method call in the calling environment.
					-Actual parameters (arguments) are the specific values that are 
					 provided to the function when it is called, corresponding to the formal parameters
					eg.
						displayNumber(42); // Actual parameter: "42"

			-Pass by Value/ call by value:
				#include <iostream>
				using namespace std;
				void func(int n){						//formal parameter
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90
					func(n);											//91			//Actual parameter
					std::cout << "After func: "<< n << std::endl;			//90
					return 0;
				}

			-Pass by reference/ call by reference:
				#include <iostream>
				using namespace std;

				void func(int &n){
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90

					//pass by reference- sending memory 
					func(n);											//91
					
					std::cout << "After func: "<< n << std::endl;			//91
					return 0;
				}

			Homework:
				1)ArithmeticProgression  = 3 * n +  7 make function of it.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int n;
							std::cout << "enter n: " << std::endl;
							cin>>n;
							
							std::cout << "The Arithmetic Progression for "<< n << " is "<< (3*n)+7;
							return 0;
						}

				2)Total no.of set bits (1) from given 2 numbers.
					eg.
						2 -> 10 			->1
						3 -> 11			->2
						Total set bits : 1+2 = 3
					->
						#include <iostream>
						#include <bitset>
						using namespace std;

						int setBitCouter(int z){
							int counter=0;
							
							while(z != 0){
								if(z&1)
									counter++;
								z >>=1;
							}
							return counter;
						}

						int main()
						{
							int a,b;
							std::cout << "enter a: ";
							cin>>a;
							
							std::cout << "enter b: ";
							cin>>b;
							
							std::cout << "Binary if a :: "<< bitset<32>(a) << std::endl;
							std::cout << "Binary if b :: "<< bitset<32>(b) << std::endl;
							
							//couting the no.of setbits, for a
							int sbA = setBitCouter(a);
							
							//for b
							int sbB = setBitCouter(b);
							
							std::cout << "The no.of setbits in "<<a<< " & "<<b<<" is "<< sbA+sbB << std::endl;
							
							return 0;
						}

					#include <iostream>
					using namespace std;
					int main(){
						int n=3;
						int ans = __builtin_popcount(n);
						std::cout << ans << std::endl;
						return 0;   
					}


				3)Fibonacci series nth term function:
					input: n = 5;			// 0 1 1 2 3 5 8 13
					output: 3			//5th num of that series.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int prev= 0, curr= 1;
							
							int n;
							cout<<"Enter n:";
							cin>>n;
							
							int i=0;
							
							for(;i<n-1; i++){
								// cout<<prev<<" ";            
								
								int next = prev + curr;
								prev = curr;          
								curr = next;          
							}
							
							std::cout << "The "<< i+1 <<" number term is "<< prev << std::endl;
							return 0;
						}

			Local variable: 
				A variable declared within a function or a block of code is called a local variable. 
				Local variables are frequently used to temporarily store data in a defined 
				scope where they can be accessed and manipulated. They are stored in the memory stack, 
				Once the function or block of code in which the local variable is declared finishes executing. 
				The variable is automatically removed from the memory.

		2]. Number complement

			#include <iostream>
			#include <bitset>
			using namespace std;
			int main()
			{
				int n;
				std::cout << "Enter num : " << std::endl;
				cin>>n;
				
				cout<<"Binary of "<<n<<" "<<bitset<32>(n)<<endl;
				std::cout << "Complement of above binary "<< bitset<32>(~n) << std::endl;
				
				return 0;
			}
			
		3]. Square root of n ❌
---------------------------------------------------------------------------------------------------------
	08/08/23
Lecture-9:
	Introduction to Arrays
		-Array is a collection of variables of the same type.
		-Arrays are used to store multiple values of same Datatype in a single variable, 
		 instead of declaring separate variables for each value.
		-To declare an array, define the variable type, specify the name of the array 
		 followed by square brackets and specify the number of elements it should store

		-All arrays consist of contiguous memory locations. 
		 The lowest address corresponds to the first element and the highest address to the last element.

		-Array elements/ value we can access by INDEX.
		-Array start from 0.
		-defaultly they contain garbage value inside it.
		-use index num to access value of array on that location.
		
		-size of array = n, then till (n-1) index we can access.

		-Array declaration:
			 int a[10] ={1,2,3};         //ok
    
			int b[3] = {1,2,3};         //ok
			
			int c[] = {1,2,3,4,5,6,7};      //ok
			
			// int d[2] = {1,2,3,4,5,6,7};     //not ok
			
			// int e[];            //not ok

			// int f[10];              //not ok
			// f[10] = {1,2,2};
			// f[] = {1,2,4,3};

			int g[15];				//ok
	
		-declararing array with random/ Garbage value:
			int a[10];
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

		-Initializing all array element with 0.
			int a[10] ={0};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			-When you try to initialize some elements of array, they will get your specified value, 
				& rest all element of array elements become zero.

			--here in above case first element is initialized with 0, & rest all become will initialized with zero. 
		
		-Initializing all array element with 1 WON'T WORK ❌, only with 0 it will work.
			int a[10] ={5};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			In the above example, only the first element will be initialized to 5. All others are initialized to 0.

		--Here in below
			example you can see that if you try to initialize any position's value in array,
			then that position will get specified mentioned value, rest all by default initialized with zero.

			#include <iostream>
			using namespace std;

			int main()
			{
				int a[10] = {2,8};
				a[9]=90;
				a[5]=60;
				
				for(int i=0;i<10;i++)
					std::cout << i <<" "<<a[i]<< "\t";					
					
				return 0;
			}
				//2       8       0       0       0       60      0       0       0       90
			
		-To initialize array element with some default value,
			int a[10];
			for(int i=0;i<10;i++)
				a[i] = 4;
			
			for(int i=0; i<10;i++)
				std::cout << i << " " << a[i] << std::endl;
			
			//or using fill_n method
			std::fill_n(arrayName, arraySize, defaultValue);

			std::fill_n(a,10,90);

		string cars[4];
		eg.
		 int a[] = {1,2,3};
		 std::cout << sizeof(a) << std::endl;			//each int size is 4 so here, 12.

		 int b[] = {1,2,3,4};
		 std::cout << sizeof(b) << std::endl;			//each int size is 4 so here, 16.

		 //to print memory address of variable stored use &.
		 	int b=90;
			cout<< "memory location of B :: "<<b<<" "<<&b;

		for array just print the variable name it will give the memory address
			int a[] = {1,2,3};
			cout<< "memory location of Array a :: "<<a<<" "<<&a<<endl;			//this both a & (&a) will print the same thing.
		
		-Index accessing:
			int a[5] ={1,2,3,4,5};
				//100 , 104, 108, 112, 116			--memory address.
			
			-variable a will store the base address.
			-Suppose 100, first element's address, the next will be 104, next 108 coz size of int is 4 byte.

			a[0];			//base address	100, output value will be 1
			a[3];			//(base address + indexNum * sizeOfDatatype) =100 + 3*4 = 112, value will be 4.
        
	   	----External Link---------
			https://www.tutorialspoint.com/cplusplus/cpp_arrays.htm	
		-------------

		-If we try to access the index which is greater than size of array,
			then you will get an GARBAGE value.
		
		-Finding array length
			we can find the length using sizeof operator,
			-first find the sizeof whole array
			-then divide it by sizeof Datatype of that array.
			eg.
				int a[10];
				sizeof (a); //output : 40
				sizeof(int);	//output:4
				sizeof (a)/sizeof(int); //output : 10

			BUT,here in below case we initialized just 2 element then it should show the 
				length is 2 but according to that above method it will print length as whole 
				array size. drawback.
				eg.
					int b[10]={1,5};			//length:2
					int len = sizeof(b)/sizeof(int);		//len: 10 		(not expected this.)

		-Advance for loop in c++:
			int b[10] = {90};

			for(int j: b){
				cout<<j<<"\t";
			}

			for(int i: b)
				cout<<i<<"\t";
		
		-BAD Practice:
			int size;
			cin>>size;

			int arr[size];				//never do this.
				//instead of doing like this directly mention constant as size of array thats better,
			int arr[10000];			//this is ok than above

		-Practice:
			1.Array:
				#include <iostream>
				using namespace std;
				void printArray(int[], int);        //function declaration says that takes input parameter first as array, 2nd is integer

				int main()
				{
					//creating array & initializing
					int arr[10]= {1,2,3,4,5,6,7,8,9,10};
					
					//printing it,
					for(int i=0;i<10;i++)
						std::cout << arr[i] << "\t";
						
					std::cout << std::endl;     //or
					
					//printing using function
					printArray(arr, 10);
					
					std::cout << std::endl;
					
					//using advance loop,
					for(int j: arr)
						cout << j << "\t";
					
					return 0;
				}

				void printArray(int v[],int size){
					for(int i=0;i<size;i++)
						std::cout << v[i] << "\t";
				}

			2.Min/Max Array:
				#include <iostream>
				#include <climits>
				using namespace std;

				void getMax(int n[], int len){
					int maxi = INT_MIN;
					
					for(int a=0; a<len; a++){
						
						// if(maxi < n[a]){
						//     maxi = n[a];
						// }
						
						maxi = max(maxi, n[a]);     //it will compare these 2 values we passed then 
												// decides which one is maximum & stores maximum value.
					}
					cout<<"MAX : "<<maxi;
				}

				void getMin(int k[], int L){
					int mini = INT_MAX;
					
					for(int a=0; a<L; a++){
						
						// if(mini > k[a]){
						//     mini = k[a];
						// }
						
						//or using built in fuction
						mini = min(mini,k[a]);       //it will compare these 2 values we passed then 
												// decides which is min & stores minimum value
					}
					
					cout<<"Min : "<<mini;
				}

				int main(){
					int array[100];
					
					int size;
					std::cout << "Enter size of array : (should be <100)" << std::endl;
					cin>>size;
					
					std::cout << "Enter "<<size<<" elements in array :" << std::endl;
					
					//taking array elements
					for(int i=0; i<size; i++)
						cin>>array[i];
						
					//printing array
					for(int o=0; o<size; o++)
						cout<<array[o]<<" ";
					
					std::cout << std::endl;
					getMax(array,size);
					
					std::cout << std::endl;
					getMin(array,size);
					
					return 0;
				}

		-Passing array to function:
			--here passing array to function means passing memory address of that array to function,
			  so as we learnt name of array holds the base/ starting memory address of array.
			  eg.
			  	int ar[10];		//here ar holds the memory address, so if we pass ar to fuction
								//then we passing memory address of array, not copy of array.
			
			--so if you update the array inside any other function also, this will affect 
			  the original array.
			eg.
				#include <iostream>
				using namespace std;

				void UpdateArr(int z[], int len){
				
					z[5] = 500;			//updating value at 6th location.
					
					std::cout << "Inside Update function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<z[i]<<"\t";
						
					cout<<"\n";
				}

				int main(){
					int arr[100] = {1,2,3,4,5,6,7,8,9,10};
					
					std::cout << "Inside main function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					std::cout  << std::endl;
					UpdateArr(arr, 10);
					
					std::cout << "Back to main function again Now Array : " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					return 0;
				}
				//output:
					Inside main function array: 
					1       2       3       4       5       6       7       8       9       10
					Inside Update function array: 
					1       2       3       4       5       500     7       8       9       10
					Back to main function again Now Array : 
					1       2       3       4       5       500     7       8       9       10

				Sum of array elements:
					#include <iostream>
					using namespace std;

					int SUM(int z[], int len){	
						int sum =0; 
						
						for(int i=0;i<10;i++)
							sum += z[i];
							
						return sum;
					}

					int main()
					{
						int arr[100] = {1,2,3,4,5,6,7,8,9,-10};
						
						int sum = SUM(arr,10);
						std::cout << "Sum of Array elements :: "<< sum << std::endl;	//Sum of Array elements :: 35
						
						return 0;
					}

					//in reverse order
						int sumElement(int arr[],int n){
							int s=0;
							//Your code here
							while(n)
								s += arr[--n];
							return s;
						}


				Reverse Array:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						
						//Array
						for(int q: arr)
							std::cout << q << "\t";                 //use this advance loop if your are using whole size of array.
							
						std::cout << std::endl;
						
						//printing array in reverse way. means not reversing actual array.
						for(int i=9; i>=0; i--)
							cout<< arr[i]<<"\t";
						
						//for this you should know the length of array
						//array reversed.
						int len = 10;
						for(int i=0; i<len/2; i++){
							
							int temp = arr[i];
							arr[i] = arr[(len-1)-i];
							arr[(len-1)-i] = temp;
						}
						
						//printing original array
						std::cout << std::endl;
						for(int i: arr){
							cout<<i<<"\t";
						}
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;

						void reverse(int arr[], int n) {

							int start = 0;
							int end = n-1;

							while(start<=end) {
								swap(arr[start], arr[end]);
								start++;
								end--;
							}
						}

						void printArray(int arr[], int n) {
							
							for(int i=0; i<n; i++) {
								cout << arr[i] << " ";
							}
							cout << endl;
						}

						int main() {

							int arr[6] = {1,4,0,5,-2,15};
							int brr[5] = {2,6,3,9,4};

							reverse(arr, 6);
							reverse(brr, 5);

							printArray(arr, 6);
							printArray(brr, 5);

							return 0;
						}

				Linear search:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						int key;
						
						std::cout << "enter key: " << std::endl;
						cin>>key;
						
						for(int i=0;i<10;i++){
							if(arr[i] == key){
								std::cout << "Key Found, at "<< i << std::endl;
								break;
							}
							
							if(i==9)
								std::cout << "Key Not Found." << std::endl;             //array traversed till last but didn't found key
						}
							
						return 0;
					}
---------------------------------------------------------------------------------------------------------
	09/08/23
Lecture-10:
	Alternate swap
		i/p-> {1,2,3,4,5,6};
		o/p-> {2,1,4,3,6,5};
		->
			#include <iostream>
			using namespace std;

			void swapAlternate(int ar[], int size){
    
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = ar[i];
					//     ar[i] = ar[i+1];
					//     ar[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(ar[i],ar[i+1]);
				}
			}


			int main()
			{
				int a[100];
				
				int size;
				std::cout << "Enter size of array:" << std::endl;
				cin>>size;
				
				cout<<"Enter "<< size << "elements in array: ";
				
				//inputing array elements
				for(int i=0;i<size;i++)
					cin>>a[i];
				
				//printing array.
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";
					
				
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = a[i];
					//     a[i] = a[i+1];
					//     a[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(a[i],a[i+1]);
				}

				//or using function
				//swapAlternate(a, size);
				
				cout<<"\n";
				
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";

				return 0;
			}

	-find unique element in array
		(hint: XOR with same num will give output 0) a ^ a =0
		eg.
			5 ^ 5 = 0
		(XOR with zero & any other num will ouput the same num ) 0 ^ a = a
		eg.
			0 ^ 5 = 5
			0 ^ 23 = 23.
		->
			int findUnique(int arr, int size){
				int ans = 0;
				for(int i=0;i<size;i++)
					ans = ans ^ arr[i];

				return ans;
			}
	
	-check the occurence of elements are unique or not?
		bool uniqueOccurrences(vector<int>& arr) {
			vector<int> ans;

			int counter=1;
			
			for(int i=0;i<arr.size(); i++){
				int temp = arr[i];
				if(arr[i] == -2000)
					continue;
				for(int j=i+1; j<arr.size();j++){
					if(temp == arr[j]){
						arr[j] = -2000;
						counter++;
					}
				}
				ans.push_back(counter);
				counter=1;
			}

			for(int i=0; i<ans.size(); i++){
				int temp = ans[i];
				for(int j=i+1; j<ans.size(); j++){
					if(temp == ans[j])
						return false;
				}
			}
			return true;
		}

	-find duplicate element in array
		Vector- It's dyanamic kind of thing.

		//not optimized
			int n = arr.size();
			for(int o=0;o<n;o++){
				int t = arr[o];

				if(o<n-1)
					for(int i=o+1; i<n; i++)
						if(t == arr[i])
							return t;
			}
		
		//optimized
			int findDuplicate(vector<int> &arr) 
			{
				// Write your code here
				int ans =0;

				//first we initialized the ans to 0 coz xor 0 with any other num will
				//give ans as that num only.

				//then we run for loop 0 to till length of array some answer will come,
				//again we will run loop from 1 to length-1 of array means to skip any one value.
				//then the answer will be duplicate value.

				for(int a=0; a<arr.size(); a++)
					ans = ans ^ arr[a];
				
				//we are doing xor with a directly coz there is only one duplicate element
				//& array contain the element from 1 & n-1 at least once
				for(int a=1; a< arr.size(); a++)
					ans = ans ^ a;

				return ans;
			}

	-find all duplicates num in array.
		//dyamica array in c++
			#include <iostream>
			#include <vector>
			int main() {
				// Write C++ code here
				//dynamic array
				
				std::vector<int> arr = {1,2,3};
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
					
				arr.push_back(100);
				
				std::cout<<"\n";
				
				arr.push_back(200);			//inserting num in array.
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
				
				return 0;
			}

		//brute force-> TIME LIMIT EXCEEDED
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				for(int a=0; a< nums.size(); a++)
				{
					int temp = nums[a];
					for(int b =a+1; b< nums.size(); b++){
						if(temp == nums[b]){
							dual.push_back(nums[b]);
							break;
						}
					}
				}
				return dual;
			}

		//optimized
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				sort(nums.begin(), nums.end());			//built in function to sort array.

				for(int a=1; a< nums.size(); a++)
				{
					if(nums[a-1] == nums[a]){
						dual.push_back(nums[a]);
					}
				}
				return dual;
			}

			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;			//dynamic array.
				set<int> st;				//set which contains any element once only.

				for(int a=0; a< nums.size(); a++)
				{
					if(st.count(nums[a])){				//count method return 1 if that element present in set, else 0.
						dual.push_back(nums[a]);
					}else{	
						st.insert(nums[a]);				//insert method will insert that element/value into set.
					}
				}
				return dual;
			}

	-Sorting array:
		#include <iostream>
		#include <set>
		#include<algorithm> //mandatory for sort functionality
		using namespace std;

		int main() {
			// Write C++ code here
			int nums[] = {5,4,3,2,1};
			
			int len = sizeof(nums)/sizeof(nums[0]);     //calculating the length of array. 
												//this works if complete array which length is specified is filled completely, like a[100], then all 100 elements should be present.
												//or they if left length of array empty, like int arr[] = {1,2,3};
			
			for(int i=0;i<len; i++)
					cout<<" "<<nums[i];
					
			cout<<"\n";
			
			sort(nums, nums+len);			//from base(starting) address to till last
			
			//sort(starting array_memory_address, end array_memory_address);
			
			for(int i=0;i<len; i++)
				cout<<" "<<nums[i];
			return 0;
		}
	
	-Set:
		-set by default store element in ascending order,
		-set store unique elements. not duplicate.
		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.
		eg.
			std::set <data_type> set_name;

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values

			//to check element present in set or not use count method with parameter in it.
			val.count(5);			//if that value present in set it returns 1
			val.count(12);			//if that value absent in set it returns 0
		Pratical:
			#include <iostream>
			#include <set>
			using namespace std;
			int main() {
				std::set<int> a;
				a.insert(10);
				a.insert(9);
				a.insert(7);
				
				a.insert(9);        //these 2 values won't get added.
				a.insert(7);
				
				a.insert(90);
				a.insert(70);
				
				
				a.insert(23);
				a.insert(34);            //inserting into set.


				cout<<*a.begin()<<"\t";     //return first element of set.
				
				cout<<*a.end()<<"\t";       //return the last element index, Length of set

				//length of set:
				cout<<"\n the length of set A is :: "<<a.size();

				//printing set
				for (int str : a) {
					cout << str << ' ';
				}
				
				cout<<"\n";
				cout<<"is 12 present in set A :: "<<a.count(12);			//0 means not present
				cout<<"is 10 present in set A :: "<<a.count(10);			//1 means present
				
				std::cout << '\n';

				return 0;
			}
		
			//printing char set,
			--need to define the iterator on it which is character (char) type.
				set<char> set1;
				set<char> :: iterator MY;
				for(MY = set1.begin(); MY != set1.end(); MY++){
					cout<< *MY;
				}

	-Array intersection (common element from 2 array).
		Intersection Of Two Sorted Arrays
		Constraints:
			1 <= T <= 100
			1 <= N, M <= 10^4
			0 <= A[i] <= 10^5
			0 <= B[i] <= 10^5
			Time Limit: 1 sec
		
		Sample Input 1 :
			2				T		test cases
			6 4				N M
			1 2 2 2 3 4		A	array 
			2 2 3 3			B	array

			3 2				N M  lengths
			1 2 3			array A
			3 4  			array B
		Sample Output 1 :
			2 2 3		
			3   
		Explanation For Sample Input 1 :
			For the first test case, the common elements are 2 2 3 in both the arrays, so we print it.
			For the second test case, only 3 is common so we print 3.
		->
			//Time Limit EXCEEDED (TLE)
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;

					for(int i=0; i<n; i++){
						int temp = arr1[i];

						for(int j=0; j<m; j++){
							if(temp == arr2[j]){
								common.push_back(temp);
								arr2[j] = -1;
								break;
							}
						}
					}
					return common;
				}
			
			//optimized:
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;
					int i=0,j=0;
					
					while(i<n && j<m){
						if(arr1[i] == arr2[j]){
							common.push_back(arr1[i]);
							i++;j++;
						}else if(arr1[i]< arr2[j]){
							i++;
						}else{
							j++;
						}
					}
					return common;
				}

	-Pair sum
		-https://www.codingninjas.com/studio/problems/pair-sum_697295
		Sample Input 1:
		5
		1 2 3 4 5
		Sample Output 1:
		1 4
		2 3

		Explaination For Sample Output 1:
		Here, 1 + 4 = 5
			2 + 3 = 5
		Hence the output will be, (1,4) , (2,3).
		
		Sample Input 2:
		0
		2 -3 3 3 -2
		Sample Output 2:
		-3 3
		-3 3
		-2 2

		#include <bits/stdc++.h>
		vector<vector<int>> pairSum(vector<int> &arr, int s){
			vector< vector<int> > ans;

			for(int i=0; i<arr.size(); i++){
				for(int j=i+1; j<arr.size(); j++){
					if(arr[i]+arr[j] == s){
						vector<int> temp;
						temp.push_back(min(arr[i], arr[j]));            
						temp.push_back(max(arr[i], arr[j]));
						ans.push_back(temp);
					}
				}
			}
			sort(ans.begin(), ans.end());
			return ans;
		}
		
	-Triplet sum:
		#include <bits/stdc++.h> 
		vector<vector<int>> findTriplets(vector<int>arr, int n, int K) {  
			sort(arr.begin(),arr.end());
				vector<vector<int>>ans;
			set<vector<int>> s;
			for(int i=0;i<n;i++){
				int sum = K - arr[i];
				int j = i+1;
				int k = n-1;
				while(j<k){
						if(arr[j]+arr[k] == sum){
							vector<int> temp;
							temp.push_back(arr[i]);
							temp.push_back(arr[j]);
							temp.push_back(arr[k]);
							sort(temp.begin(),temp.end());
							s.insert(temp);
							j++;
						}
					else if(arr[j]+arr[k]<sum){
						j++;
					}
					else{
						k--;
					}
				}
			}
			for(auto val: s){
				ans.push_back(val);
			}
			return ans;
		}

	-sort 0's & 1's:
		#include <iostream>
		using namespace std;

		void printArr(int a[], int n){
			for(int i=0;i<n; i++){
				cout<<a[i] << "\t";
			}
			cout<<"\n";
		}

		int main() {
			int arr[] = {1,1,1,1,1,0,0,0,0,0};
			int len = 10;
			printArr(arr, len);
						
			int i=0, j = len-1;
			while(i <= j ){
				if(arr[i] > arr[j]){
					swap(arr[i],arr[j]);
					i++;j--;
				}else if(arr[i] < arr[j]){
					i++;
				}else if(arr[i] ==  arr[j]){
					j--;
				}
			}
			
			printArr(arr, len);
			return 0;
		}

	-sort 0's, 1's & 2's:
		remain.. ❌
---------------------------------------------------------------------------------------------------------
	10/08/23
Lecture-11:
	Time & Space Complexity, How to avoid Time Limit Exceeded [TLE]
		Time Complexity:
			-It is the amount of time taken by an algorithm to run, as function of length of input.
			-the computational complexity that describes the amount of computer time it takes to run an algorithm. or
			-The Time Complexity of an algorithm/code is not equal to the actual time required to execute a particular code, 
			 but the number of times a statement executes.

			-we use time/space complexity for making better programs.
			-using these terms, we can decide algorithm is fast or slow.
			-It represented in 3 forms,
				1). Big O - Upper bound, (at max this much time program will take). worst case scenario
				2). Theta θ - Average, average case scenario.
				3). Omega Ω - Lower bound (at minimum, this much amount of time program will take) best case scenario.
			
			-Time:
				1) Constant time O(1).
				2) Linear time O(n).
				3) Logarithmic time O(log n).
				4) Quadratic time O(n²).		(nested loops)
				5) Cubic time O(n³).		(nested nested loops)

				chart: 
						O(N!)			--maximum time takes.
						O(2ⁿ)
					↑	O(n³)
					↑	O(n²)
					↑	O(n log(n))
					↑	O(n)
					↑	O(log(n))
					↑	O(1)			--minimum time takes.
			eg.
				-ignore constant, choose highest degree in equation.
					f(n) = 2n² + 3n 
					->
						O(n²)
					f(n) = 4n⁴ + 3n³
					->
						O(n⁴)
					
					f(n) = n² + log(n)
					-> O(n²).

					f(n) = 120043
					->
						O(1).
					
					f(n) = 5n³ + 3n² + 5
					->
						O(n³)
					
					f(n) = n³ / 300
					->
						O(n³)
					
					f(n) = 5n² + log(n)
					->
						O(n²)
					
					f(n) = n/4
					->
						O(n)				(Linear Time complexity)
					
					f(n) = (n+4)/4
					->
						O(n)				(Linear Time complexity)

				-Take this function to find its time complexity:
					void printArr(int a[], int n){
						for(int i=0;i<n; i++){
							cout<<a[i] << "\t";
						}
						cout<<"\n";
					}
					->
						here the length of array is n, so time depends length of array,
						so 
						Time Complexity will be O(n).
				
				-for calculating time complexity, if 2 for loops are there which are nested then their last
				value will be multiplied with eachother,
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements
					->
						time complexity: n*n  = O(n²);
					
				-if 2 for loops are there which are next to each other then we add their last value;
					for(int i=0;i<n; i++) ->	O(n)
						//statements
					
					for(j=0;j<m;j++)		-> O(m)
						//statements
					
					Time Complexity = O(n+m)

				-for this?
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements		// O(n²)
					
					for(j=0;j<n;j++)			// O(n)
						//statements
					
					= O(n²) + O(n)
					Time Complexity = O(n²)
				
				-for this?
					for(i=0;i<n;i++)			//this loop will run till (n-1)	ie.	O(n)
						for(j=n;j>i;j--)		//suppose i=0 then, this loop will run n to 0, ie. O(n)
							//statements		
					
					Time Complexity = O(n²)

		Space Complexity:
			-The total amount of memory space used by an algorithm/program, including the space of input values for execution.
			-The space complexity of an algorithm or a computer program is the amount of memory space required to solve an instance 
			 of the computational problem as a function of characteristics of the input. 
			 It is the memory required by an algorithm until it executes completely.
			-This includes the memory space used by its inputs, called input space, and any other (auxiliary) memory it uses during execution, 
			 which is called auxiliary space.

			-Similar to time complexity, space complexity is often expressed asymptotically in big O notation, such as O(n), O(n long(n)), 
			eg.
				-if we mention the array size then its fixed space complexity O(1).
				-if we declare any variable, it will take fixed space, so space Complexity O(1).
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-12:
	Binary Search:
		Binary search is applied only in list/ array where the data is sorted, 
		 either in increasing or in decreasing order, called monotonic function.
		Steps for Binary Search :
		1. Find middle element of the given array.
			If the value found at mid index is equal to key, return true else,
		2. if key >  mid,
			then go left side of the array by start = mid+1 to end is same.
		3. if Key <  mid,
			then go right side of the array from start is same & end = mid -1
		3. If key not found after searching whole array, return false.

		--here in case of binary search the Time Complexity is O(log(n)), where n is length of array.
		--because for every next iteration the array size is getting half,
		  for first len/2
		  for 2nd len/4
		  for 3rd len/8, like len/2¹, len/2², len/2³,... len/2ⁿ
		  len/2ⁿ = 1
		  len = 2ⁿ
		  n = log₂(len) 

		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[],int size){
				for(int i=0;i<size;i++){
					cout<<a[i]<<" ";
				}
				
				std::cout << std::endl;
			}

			int BinarySearch(int b[], int len, int key){
			
				int start = 0, end = len-1;
				
				//int mid = (start+end)/2;
				
				int mid = start + (end - start)/2;
    
				//sometimes array length is too large that start & end index is of (2³¹ - 1) & (2³¹ - 1) 
				//then their addition will be out of range of integer
				
				// so to avoid this issue we can use this formula,			

				while(start <= end){
					
					if(b[mid] == key)
						return mid;
					else if(key > b[mid])
						start = mid+1;
					else
						end = mid-1;
						
					mid = start + (end - start)/2;
				}
				return -1;
			}

			int main()
			{
				int Even[] = {2,4,6,8,12,14,16,22,28,30};
				int Odd[] = {1,3,5,9,13,17,41,43,59,55,69};
				
				cout<<"Even array: ";
				printArr(Even,10);
				
				
				cout<<"Odd array: ";
				printArr(Odd,11);
				
				int element;
				std::cout << "Enter element you want to find in Even array: " << std::endl;
				cin>>element;
				
				std::cout << element << " is at " << BinarySearch(Even, 10, element) << " Index." << std::endl;
				
				std::cout << "Enter element you want to find in Odd array: " << std::endl;
				cin>>element;
				std::cout << element << " is at " << BinarySearch(Odd, 11, element) << " Index." << std::endl;
				
				std::cout << "--END--" << std::endl;
			}
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-13:
	Questions on BinarySearch
	#Pair in C++ Standard Template Library (STL)
		-Pair is used to combine together two values that may be of different data types. 
		-Pair provides a way to store two heterogeneous objects as a single unit. 
		-It is basically used if we want to store tuples. 
		-The pair container is a simple container defined in <utility> header consisting of two data elements or objects. 

		-The first element is referenced as ‘first’ and the second element as ‘second’ and the order is fixed (first, second).
		-Pair can be assigned, copied, and compared. 
		-The array of objects allocated in a map or hash_map is of type ‘pair’ by default in which all the ‘first’ elements are unique keys associated with their ‘second’ value objects.
		-To access the elements, we use variable name followed by dot operator followed by the keyword first or second.
		Syntax: 
			pair <data_type1, data_type2> Pair_name
			eg.
				#include <iostream>
				#include <utility>
				using namespace std;
				int main()
				{
					// defining a pair
					pair<int, char> PAIR1;

					// first part of the pair
					PAIR1.first = 100;

					// second part of the pair
					PAIR1.second = 'G';

					cout << PAIR1.first << " ";
					cout << PAIR1.second << endl;

					// defining a pair
					pair<string, double> PAIR2("GeeksForGeeks", 1.23);
					
					cout << PAIR2.first << " ";
					cout << PAIR2.second << endl;

					return 0;
				}
				ouput:	100 G

				Initializing a Pair: We can also initialize a pair. 
					Syntax:
						pair <data_type1, data_type2> Pair_name (value1, value2) ;
					
					Different ways to initialize pair:  

						pair  g1;         //default
						pair  g2(1, 'a');  //initialized,  different data type
						pair  g3(1, 10);   //initialized,  same data type
						pair  g4(g3);    //copy of g3
						
						Another way to initialize a pair is by using the make_pair() function. 
							g2 = make_pair(1, 'a');

						Another valid syntax to declare pair is:
							g2 = {1, 'a'};
							pair<int, int> p1 {a,b};		
							pair<int, int> p1 = {a,b};
							eg.
								#include <iostream>
								using namespace std;

								int main(){
									int a = 10,b =20;

									pair<int, int> p1 {a,b};
									pair<char, string> p2('A',"First Alphabet");
									
									std::cout << p1.first<<" ";                     //10 20
									std::cout << p1.second << std::endl;
									
									std::cout << p2.first <<" ";                    //A First Alphabet
									std::cout << p2.second << std::endl;
									
									
									return 0;
								}

				Note: If not initialized, the first value of the pair gets automatically initialized. 
				
					#include <iostream>
					#include <utility>
					using namespace std;
					int main()
					{
						pair<int, double> PAIR1;
						pair<string, char> PAIR2;
						
						// it is initialised to 0
						cout << PAIR1.first;
						
						// it is initialised to 0
						cout << PAIR1.second;
						
						cout << " ";
						
						// it prints nothing i.e NULL
						cout << PAIR2.first;
							
						// it prints nothing i.e NULL
						cout << PAIR2.second;
						
						return 0;
					}
				-for more example Visit GFG pair
					1)swap
					2)make_pair
					3)tie

	1)Find the First & Last occurence of element in array:
		//Linear search method
			#include <bits/stdc++.h> 
			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				int i;
				int len = arr.size();

				for(i=0; i< len;i++){
					if(k == arr[i]){
						ans.first = i;
						break;
					}
				}
				
				if(i == len)
					ans.first = -1;
				

				for(i=len-1; i>-1; i--)
				{
					if(k == arr[i]){
						ans.second = i;
						break;
					}
				}

				if(i == -1)
					ans.second = -1;

				return ans;
			}

		//Binary search method
			#include <bits/stdc++.h> 
			int firstOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						e = mid -1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			int lastOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						s = mid + 1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				ans.first = firstOcc(arr, n, k);
				ans.second = lastOcc(arr, n, k);
				return ans;
			}

	example:To find the total no.of occurence of key in sorted array
		find the first/start index & last/end index, then 
		no.of occurence = (last - first)+1;
		eg.
			1 2 3 4 4 4 4 4 5 6 7
			--here 4's first index is 3 & last index is 7
			 so 7-3+1 = 5
			-no.of occurence of 4 is 5 times.
		
	2)Peak Index in Mountain Array:
		https://leetcode.com/problems/peak-index-in-a-mountain-array/
		//Linear or Brute force  algorithm			//TC- O(n)
			int peakIndexInMountainArray(vector<int>& arr) {
				int temp = arr[0], ans=0;
				for(int i=1; i< arr.size(); i++){
					if(temp < arr[i]){
						ans = i;
						temp = arr[i];
					}   
				}
				return ans;
			}
		
		//using Binary Search algorithm
			int peakIndexInMountainArray(vector<int>& arr) {
				int s=0, e= arr.size()-1;
				int mid = (s+e)/2;
				
				while(s < e){
					if(arr[mid] < arr[mid+1]){
						s = mid +1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}
				return e;
			}

	3)Find Pivot Index: HW
		-Left side summation & right side summation must be same then return the index of that element.
		//Linear search method:
			https://leetcode.com/problems/find-pivot-index/description/
			int pivotIndex(vector<int>& nums) {
				int left=0,right=0;
				int i=0;
				for(;i<nums.size(); i++){

					//for rightSide
					for(int j=i+1; j<nums.size(); j++){
						right += nums[j]; 
					}

					//for leftSide
					for(int k=0; k<i; k++){
						left += nums[k];
					}

					if(left == right)
					{
						break;
					}
					right=0; left=0;
				}

				if(i == nums.size())
						return -1;
				return i;
			}
---------------------------------------------------------------------------------------------------------
	13/08/23
Lecture-14:
	Binary Search Interview Questions | Problem set-2
		Find the pivot in sorted & rotated array,
		eg.
			sorted array : [1,2,3,4,5,6,7,8,9];	
			rotated array by 3 in right direction : [7,8,9,1,2,3,4,5,6];
		-finding pivot in it,
			-> The minimum value in array is a pivot element.
		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[], int L){
				for(int i=0;i<L;i++){
					cout<<a[i]<<" ";
				}
				std::cout << std::endl;
			}

			int main()
			{
				int arr[] = {4,5,6,7,8,9,10,1,2,3};
				int len = 10;

				std::cout << "The array is : " << std::endl;
				printArr(arr, len);

				int s=0, e=len-1;
				int mid = (s+e)/2;

				while(s < e){
					if(arr[mid] >= arr[0]){
						s = mid + 1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}

				cout<<"The pivot Element is at location/index :"<<s<<" or at "<<e;
				return 0;
			}

		1). Search K In Rotated Sorted Array

			//Linear way O(n) time complexity,
				int search(vector<int>& arr, int n, int k)
				{
					// Write your code here.
					// Return the position of K in ARR else return -1.
					int i=0;
					for(;i<arr.size();i++){
						if(k == arr[i]){
							return i;
						}
					}

					if(i == arr.size())
						return -1;
				}

			//Using Binary search O(log(n)) Time complexity,
				int BinarySearch(vector<int>& arr, int start, int n, int key){
					int s = start, e= n-1;
					int mid= (s+e)/2;
					
					while(s <= e){
						if(arr[mid] == key){
							return mid;
						}else if(key > arr[mid]){
							s = mid + 1;
						}else{
							e = mid -1;
						}
						mid = (s+e)/2;
					}
					return -1;
				}

				int pivotFind(vector<int>& arr, int len){
					
					int s=0, e = len-1;
					int mid = (s+e)/2;

					while(s < e){
						if(arr[mid] > arr[0] ){
							s = mid +1;
						}else{
							e =mid;
						}
						mid = (s+e)/2;
					}
					return s;
				}

				int search(vector<int>& arr, int n, int k){
					// Return the position of K in ARR else return -1
					int pivot = pivotFind(arr, n);
					
					if(arr[0] <= k && k <= arr[pivot-1]){
						//first line from start to till pivot
						return BinarySearch(arr, 0, pivot, k);        
					}else{
						// second line from pivot to till end.
						return  BinarySearch(arr, pivot, n, k);
					}				
				}

		2). Square Root of a number
			//Linear Search, not optimized
				int floorSqrt(int n){
					for(int i=1;i<=n/2;i++){
						if(n == pow(i,2)){
							return i;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
				}

			//using BinarySearch optimized
				int floorSqrt(int n){
					int s=0, e = n;
					long long int mid = (s+e)/2;
					long long int sqr;
					long long int ans;

					while(s <= e){
						sqr = mid * mid;
						if(sqr == n){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid -1;
						}else{
							ans = mid;
							s = mid +1;
						}
						mid = (s+e)/2;
					}
					return ans;
				}

		3). Sqrt(x):
			//Linear search not optimized
				int mySqrt(int n) {
					int i=0;
					for(;i<=n;i++){

						if(n == pow(i,2)){
							break;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
					return i;
				}
			
			//using BinarySearch 
				int mySqrt(int n) {
					int s=0, e =n;
					long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
					long long int ans;
					long long int sqr;

					while(s <= e){
						sqr = mid * mid;
						if(n == sqr){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid-1;
						}else{
							ans = mid;
							s=mid+1;
						}
						mid = (s+e)/2;
					}
					return ans;  
				}

		4). Square Root with decimal precision:
			#include <iostream>
			using namespace std;
			long long int SQRTn(int n){
				int s=0, e =n;
				long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
				long long int ans;
				long long int sqr;

				while(s <= e){
					sqr = mid * mid;
					if(n == sqr){
						ans = mid;
						break;
					}else if(sqr > n){
						e = mid-1;
					}else{
						ans = mid;
						s=mid+1;
					}
					mid = (s+e)/2;			//or mid = s + (e-s)/2;
				}
				return ans;
			}

			double morePrecision(int n, int uptoDecimal, int sqrtNum){

				double factor=1;
				double ans= sqrtNum;

				for(int i=0; i< uptoDecimal; i++){
					factor = factor/10;

					for(double j=sqrtNum; j*j < n; j = j + factor){
						ans = j;
					}
				}
				return ans;
			}

			int main(){
				int n;
				cout<<"Enter n";
				cin>>n;

				int sqrt1 = SQRTn(n);
				cout<<"answer is upto 4 decimal precision ::"<< morePrecision(n, 4, sqrt1);
				return 0;	
			}
---------------------------------------------------------------------------------------------------------
	14/08/23
Lecture-15:
	Book Allocation Problem || Aggressive Cows Problem || Binary Search Advanced Problems
		1). Book Allocation:
			HW- https://www.codingninjas.com/studio/problems/allocate-books_1090540
		2). Painter partition
			HW.
		3). Aggressive cows

	COME BACK TO THIS LECTURE AGAIN. ❌
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-16: Selection Sort
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1;i++){
			int minIndex = i;
			for(int j=i+1; j<n;j++){
				if(arr[j] < arr[minIndex])
					minIndex = j;
			}
			swap(arr[minIndex],arr[i]);
		}
	}

	//or
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1; i++){
			for(int j=i+1;j<n;j++){
				if(arr[i] > arr[j])
					swap(arr[i],arr[j]);
			}
		}
	}

	//or
	#include <bits/stdc++.h> 
	void selectionSort(vector<int>& arr, int n){
		int i,j;
		for(i=0;i<n-1;i++)
			for(j=i+1; j<n; j++)
				if(arr[i]> arr[j])
					swap(arr[i], arr[j]);
	}

		-for Selection Sort program,
			Space complexity:	O(1).
			Time complexity: O(n²);		
		
		-Use case:
			if given array/vector size is small then we can go for Selection sort.
		
		HW
			-Flowchart : 
			-Stable & unstable algorithm

	Practice:
		#include <iostream>
		using namespace std;
		void printArray(int [], int);		//or void printArray(int anyName[], int)	or if you don't give name to array still its fine, its just function declaration.

		int main()
		{
			int arr[] = {55,44,33,32,11,22,57,90,87,76,65,1};
			//1,11,22,32,33,44,55,57,65,76,87,90
			
			int len = 12;
			
			printf("Before Sorting :: \n");
			printArray(arr, len);
			
			int minValueIndex = arr[0];
			
			//sorting array,
			for(int i=0; i<len-1; i++){
				for(int j=i+1; j < len; j++)
					if(arr[minValueIndex] > arr[j])
						minValueIndex = j;
				
				//after getting the minimum value's index swap it, 
				swap(arr[i],arr[minValueIndex]);
			}
			printf("\nAfter Sorting :: \n");
			printArray(arr, len);

			return 0;
		}

		void printArray(int brr[], int len){
			for(int i=0;i<len;i++)
				printf("%d ",brr[i]);
		}
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-17: BUBBLE SORT
	-Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. 
	-This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.
	Bubble Sort Algorithm
		In this algorithm,
		-traverse from left and compare adjacent elements and the higher one is placed at right side. 
		-In this way, the LARGEST element is moved to the rightmost end at first, at the end of array. 
		-This process is then continued to find the second largest and place it and so on until the data is sorted.
		
		Advantages of Bubble Sort:
			-Bubble sort is easy to understand and implement.
			-It does not require any additional memory space.
			-It is a stable sorting algorithm, 
			 meaning that elements with the same key value maintain their relative order in the sorted output.

		Disadvantages of Bubble Sort:
			-Bubble sort has a time complexity of O(n²) which makes it very slow for large data sets.
			-Bubble sort is a comparison-based sorting algorithm, 
			 which means that it requires a comparison operator to determine the relative order of elements in the input data set. 
			 It can limit the efficiency of the algorithm in certain cases.

	QnA:
		-In Bubble Sort, after each pass, the largest element among the unsorted elements "bubbles up" to which position?
		-> Last

		-main drawback of the Bubble Sort algorithm?
		->It has a high time complexity. ie. O(n²).

		-space complexity:
			O(1), haven't created a dynamic variable so no space complexity.

		-true regarding Bubble Sort?
		->It is an in-place sorting algorithm.
		Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. 
		Hence Bubble sort algorithm is an in-place algorithm.

		-Bubble Sort is an example of a sorting algorithm that:
		->Swaps adjacent elements directly

		-Bubble Sort is an example of a ______ sorting algorithm.
		->Comparison - based

		-worst-case time complexity of the Bubble sort Algorithm?
		->O(n²)

		-What is the maximum number of comparisons that can take place when a bubble sort algorithm is implemented?, 
		suppose there are n elements in the array.
		->	(n*(n-1))/2

		-The number of swappings needed to sort the numbers 8, 22, 7, 9, 31, 5, 13 in ascending order, using bubble sort is,
		->10

		-Assume that we use Bubble Sort to sort n distinct elements in ascending order. When does the best case of Bubble Sort occur?
		->When elements are sorted in ascending order
		the time complexity of bubble sort in the BEST-CASE scenario is O(n).

	eg.
		#include <bits/stdc++.h> 
		void bubbleSort(vector<int>& arr, int n){
			for(int i=0;i<n-1; i++)
				for(int j=0; j<n-1;j++)				//here covering the last element looping from start to till end.
					if(arr[j]> arr[j+1])
						swap(arr[j],arr[j+1]);
		}

		//or neglecting the last element as it is already sorted,
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++)					
					for(int j=0; j<n-i;j++)				//here ignoring the last element from start to till n-1.
						if(arr[j]> arr[j+1])
							swap(arr [j],arr[j+1]);
			}
		
		//optimizing more.., 
		 in a random round there is no any swapping done, then we can consider that it's sorted.
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++){
					bool isSwappingOn = false;

					for(int j=0; j<n-i;j++)
						if(arr[j] > arr[j+1]){
							swap(arr [j],arr[j+1]);
							//swapping on..
							isSwappingOn = true;
						}
					if(isSwappingOn == false)
						break;        
				}
			}
		
	HW:
		stable or unstable bubble sort?
		in-place sort
---------------------------------------------------------------------------------------------------------
	16/08/23	
Lecture-18: INSERTION SORT
	Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. 
	The array is virtually split into a sorted and an unsorted part. 
	Values from the unsorted part are picked and placed at their correct position in the sorted part.

	-shifting of element done here.
	-https://www.geeksforgeeks.org/insertion-sort/

	-code:
		#include <bits/stdc++.h> 
		void insertionSort(int n, vector<int> &arr){
			for(int i=1; i<n; i++){
				int temp = arr[i],j;
				for(j=i-1; j>=0; j--){
					if(temp< arr[j]){
						//shifting
						arr[j+1] = arr[j]; 
					}else{
						break;
					}
				}
				arr[j+1] = temp;
			}
		}

	Characteristics of Insertion Sort
		-This algorithm is one of the simplest algorithms with a simple implementation
		-Basically, Insertion sort is efficient for small data values
		-Insertion sort is adaptive in nature, i.e. it is appropriate for data sets that are already partially sorted.

	-insertion sort is a STABLE sorting algorithm.
	-insertion sort is a ADAPTABLE sorting algorithm.
	-Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, 
	 and only a few elements are misplaced in a complete big array.
	
	Time complexity:
		O(n²)
		-Best-Case : O(n);
		-Worst-case: O(n²)
	space complexity:
		O(1)
---------------------------------------------------------------------------------------------------------
	17/08/23
Lecture-19: C++ STL (Standard Template Library)
	-Algorithm
	-Containers

	1) STD::array in C++:
		The array is a collection of homogeneous objects and this array container is defined for constant size arrays or (static size). 
		This container wraps around fixed-size arrays and the information of its size are not lost when declared to a pointer. 
		In order to utilize arrays, we need to include the array header:
			#include <array>

			Syntax:
				array<object_type, arr_size> arr_name;

			a)[] Operator : This is similar to the normal array, we use it to access the element store at index ‘i’ .
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <char , 3> arr={'G','f','G'};
						cout<<arr[0] <<" "<<arr[2];			//G G
						return 0;
					}
			
			b) front( ) and back( ) function: 
				-These methods are used to access the first and the last element of the array directly.
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				
			c) swap( ) function: 
				-This swap function is used to swap the content of the two arrays.
					Ex: 
					#include <iostream>
					#include <array>
					using namespace std;
				
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						arr.swap(arr1);  // now arr = {M,M,P}
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				eg.
					#include <iostream>
					#include<array>
					using namespace std;

					int main()
					{
						//double or single braces works fine.
						array<int, 5> a {1,2,3,4};
						array<int, 5> b {{10,20,30,40,150}};
						array<int, 5> c {1,2,3,4,5};
						
						cout<<"A:\n";
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nB : " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
							
						a.swap(b);
						std::cout << "\nAfter swapping: Array A:  " << std::endl;
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nAfter swapping: Array B:  " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
					}

			d)empty(): to check array is empty or not
				first need to cout boolalpha then after print the boolean value, if you print boolean values 
				before cout boolalpha then it will printed like 0,1.
				eg.
					bool x = arr.empty(); // false ( not empty)
					cout<<boolalpha;		//or cout<<boolalpha<<(x);				
					bool y = 1;
					cout<<y;
					cout<<"\n"<<x;

				-boolalpha is a manipulator used in C++ for the std::cout stream (the standard output stream) 
				to display boolean values as their corresponding textual representations "true" or "false," 
				rather than as integer values 1 or 0.
			
			e) at() function: 
				This function is used to access the element stored at a specific location, 
				if we try to access the element which is out of bounds of the array size then it throws an exception. 
				Ex: 
					#include <iostream>
					#include <array>
					using namespace std;

					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						cout<< arr.at(2) <<" " << arr1.at(2);
						//cout<< arr.at(3); // exception{Abort signal from abort(3) (SIGABRT)}
						return 0;
					}
					Output
						71 80

			f) fill( ) function: 
				This is specially used to initialize or fill all the indexes of the array with a similar value.
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 5> arr;
						arr.fill(1);
						for(int i: arr)
							cout<<arr[i]<<" ";
						return 0;
					}
						Output
						1 1 1 1 1 

			g) size( ) or max_size( ) and sizeof( ) function: 
				Both size( ) or max_size( ) are used to get the maximum number of indexes in the array 
				while sizeof( ) is used to get the total size of array in bytes.

				#include <iostream>
				#include <array>
				using namespace std;				
				int main() {
					array <int , 10> arr;   
					cout<<arr.size()<<'\n'; // total num of indexes
					cout<<arr.max_size()<<'\n'; // total num of indexes
					cout<<sizeof(arr); // total size of array
					return 0;
				}
				Output
					10
					10
					40

		eg.
			#include <iostream>
			#include <array>
			using namespace std;

			int main()
			{
				int arr[] = {1,2,3};            //static array
							
				array<int, 4> a = {1,2,3,4};        //this is also static array
				
				std::cout << "Size : "<< a.size() << std::endl;     //to get the length of array    //Size : 4
				
				//printing the array element
				for(int i: a){
					cout<<i<<"\t";              //1       2       3       4
				}
				std::cout << std::endl;
				
				for(int it=0; it<a.size(); it++)
					cout<<a[it]<<" ";               //1       2       3       4
					
				//First last element of array
				std::cout << "\n\n First element of array A :: "<< a.front() << endl;           //  First element of array A :: 1
				std::cout << " Last element of array A :: "<< a.back()<<endl;                   //   Last element of array A :: 4
				
				//random index of array
				std::cout << "\n3rd index : "<< a[3] << std::endl;                  // 3rd index : 4
				std::cout << "2nd index : "<< a.at(2) << std::endl;                 // 2nd index : 3
				
				//checking the array is empty or not?
				cout<<"Array A is empty : "<<a.empty();                         // array is not empty so, Array A is empty : 0
				
				return 0;
			}

		eg.
			#include <iostream>
			#include<array>

			//for sorting algorithm need to include,
			#include <algorithm>
			using namespace std;

			int main()
			{
				//double or single braces works fine.
				array<int, 5> a {1,2,3,4};
				array<int, 5> b {{1,2,3,4,15}};
				array<int, 5> c {1,2,3,4,5};
				
				//printing array
				for(auto i: a){
					std::cout << i <<" ";
				}
				std::cout << std::endl;
				
				for(auto i: b){
					printf("%d ",i);
				}
				
				
				//sort
				std::cout << std::endl;
				array<int, 5> d = {5,4,3,2,1};          //equal sign with single braces.
						
				for(auto i: d)
					cout<<i<<" ";
					
				std::cout  << std::endl;
				
				//after sorting
				sort(d.begin(), d.end());
				
				
				//if you just try to print the begin() function on array it will print the memory location of that array
				//so to print the element at that address Use asterisk.
				
				cout<<"Beging memory address: "<<d.begin()<<"\n";
				cout<<"starting element: "<<*d.begin()<<"\n";
				
				cout<<"End: "<<*d.end()<<"\n";
				
				for(auto i: d)
					cout<<i<<" ";
					
				array<int, 3> e = {{}};         //equal sign with double braces.
				
				
				//by default array e gets initialized with 0.
				cout<<"\n";
				for(int o: e){
					cout<<o<<" ";
				}
				
				
				//initializing array e with default specific element with 97,
				cout<<"\n";
				e.fill(97);
				for(auto i: e)
					cout<<i<<" ";
					
				//initializing string array
				cout<<"\n";
				array<string, 5> strings {"Vivek","Nikate","a","b"};
				
				for(string s: strings)
					cout<<s<<"\t";
					
				//printing string array
				cout<<"\n";
				for(auto s: strings)
					cout<<s<<"\t";

				return 0;
			}

	2) Vector:
		-It's a dynamic array.
		-Vectors are the same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, 
		 with their storage being handled automatically by the container. Vector elements are placed in contiguous storage 
		 so that they can be accessed and traversed using iterators. 
		 In vectors, data is inserted at the end. Inserting at the end takes differential time, 
		 as sometimes the array may need to be extended. Removing the last element takes only constant 
		 time because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.
		 
					vector::push_back() 								|	vector::pop_back()
				It is used to add a new element at the end of the vector. 		|	It is used to remove a new element at the end of the vector.
				Its parameter is the value we want to add in the end of vector. 	|	It does not take any parameters.
				It does not have any return type.							|	It does not have any return value.
				Its complexity is constant.								|	Its complexity is constant.
				`container.push_back(element);							| 	container.pop_back();
			Container-    Vector, Deque, List, etc. 						| 	Vector, Deque, List, etc..
			Effects  -    Increases container size by 1 						|	 Decreases container size by 1.


		-std::vector in C++, It is defined inside the <vector> header file.

		Reverse Vector:
			#include <iostream>
			#include<vector>
			// this algorithm header file is for reverse method,
			#include <algorithm>
			using namespace std;

			int main()
			{
				vector<int> v {10,9,8,7,6,5,4,3,2,1};
				std::cout << "Size "<< v.size() << std::endl;       //Size 10
				
				for(auto i: v)
					cout<<i<<" ";                               // 10 9 8 7 6 5 4 3 2 1 
					
				reverse(v.begin(), v.end());
				
				cout<<"\n After reversing: ";
				for(auto i: v)
					cout<<i<<" ";                               // After reversing: 1 2 3 4 5 6 7 8 9 10 

				return 0;
			}

			//Initialize an array with consecutive numbers using std::iota

				#include <iostream>
				#include <vector>
				#include<numeric>               //for iota 
				#include<algorithm>             //for reversing
				using namespace std;
				int main(){
					vector<int> v(10);
					
					iota(v.begin(), v.end(), 9);        // from 9 to 18
					
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 14 15 16 17 18
						
					reverse(v.begin()+5,v.end());       //reverse after 5th index
					
					cout<<"\n";
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 18 17 16 15 14
					
					return 0;
				}

		Practice:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main()
			{
				vector<int> v;
				
				//Capacity- means how many elements it can contain.
				//Size- means how many elements it is containing/ contained now.
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;
				std::cout << "Size- "<<v.size() << std::endl;
				
				v.push_back(1);
				v.push_back(2);
				v.push_back(3);
				v.push_back(4);
				v.push_back(5);
				v.push_back(48);
				v.push_back(45);
				
				v.push_back(18);
				v.push_back(345);
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //capacity gets double everytime if size is greater than capacity value.
					std::cout << "Size- "<<v.size() << std::endl;                   //9
				
				for(auto i: v)
					cout<<i<<" ";
					
				std::cout << "\nAfter Popping last element : " << std::endl;
				v.pop_back();
				
				for(auto i: v)
					cout<<i<<" ";
					
				v.clear();
				
				std::cout  << std::endl;
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //after clearing also capacity is same.
				std::cout << "Size- "<<v.size() << std::endl;                   //size reduce back to 0.
				return 0;
			}

		-vector initialization:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> a;      //size=0
				std::cout << a.size() << std::endl;
				
				vector<int> b(5);   //size=5, but all element are by default initialized to 0.
				std::cout << b.size() << std::endl;
				
				for(auto i:b)
					cout<<i<<" ";
					
				//vector with initializing default value,
				//vector<DataType> VectorName(size, defaultValue);
				vector<int> c(10, 580);     //10 element having all value 580.
				
				cout<<"\n";
				for(int i: c)
					cout<<i<<" ";
					
				//copying vector from another
				vector<int> d(c);        //copying vector c to d.
				
				cout<<"\n vector D: ";
				for(int i: d)
					cout<<i<<" ";
				
				//inserting value to specific index,
				cout<<"\n";
				
				d.insert(d.begin(),34);     //at start
				d.insert(d.begin()+4,23);     //at 4th index
				
				cout<<"\n vector D After insertion: ";
				for(int i: d)
					cout<<i<<" ";
					
					//inserting specific no.of same element to vector  
					cout<<"\n vector e :";
				vector<int> e(5,4);
				for(int i: e)
					cout<<i<<" ";
				
				std::cout<<"\nAfter insertion 99 in vector e: " << std::endl;
				//vector_name.insert(position, size (no.of times to be inserted), val (defaultValue) )
				e.insert(e.begin()+2, 5, 99);              //inserting 780, 5 times after 2nd index.
				
				for(int i: e)
					cout<<i<<" ";

				return 0;
			}

		eg.
			#include <iostream>
			#include <vector>

			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 5; i++)
					g1.push_back(i);						//inserting element into the vector.

				cout << "Output of begin and end: ";
				for (auto i = g1.begin(); i != g1.end(); ++i)
					cout << *i << " ";						//Output of begin and end: 1 2 3 4 5 

				cout << "\nOutput of cbegin and cend: ";
				for (auto i = g1.cbegin(); i != g1.cend(); ++i)
					cout << *i << " ";						//Output of cbegin and cend: 1 2 3 4 5 

				cout << "\nOutput of rbegin and rend: ";
				for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir)
					cout << *ir << " ";						//Output of rbegin and rend: 5 4 3 2 1 

				cout << "\nOutput of crbegin and crend : ";
				for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir)
					cout << *ir << " ";						//Output of crbegin and crend : 5 4 3 2 1

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 10; i++)
					g1.push_back(i * 10);

				cout << "\nReference operator [g] : g1[2] = " << g1[2];			//Reference operator [g] : g1[2] = 30

				cout << "\nat : g1.at(4) = " << g1.at(4);                   //element at 4th index (means 0-based indexing so 5th)
				//at : g1.at(4) = 50

				cout << "\nfront() : g1.front() = " << g1.front();          //first element
				//front() : g1.front() = 10

				cout << "\nback() : g1.back() = " << g1.back();             //last element
				//back() : g1.back() = 100

				// pointer to the first element
				int* pos = g1.data();           //storing the base address of vector g1 here.

				cout << "\nThe first element is " << *pos;          //accessing first/base element
				//The first element is 10
				
				cout << "\nThe 9th element is " << *(pos+8);
				//The 9th element is 90

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			#include <vector>
			using namespace std;

			int main()
			{
				// Assign vector
				vector<int> v;

				// fill the vector with 10 five times
				v.assign(5, 10);

				cout << "The vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 15 to the last position
				v.push_back(15);
				int n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// removes last element
				v.pop_back();

				// prints the vector
				cout << "\nThe vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 5 at the beginning
				v.insert(v.begin(), 5);

				cout << "\nThe first element is: " << v[0];

				// removes the first element
				v.erase(v.begin());

				cout << "\nThe first element is: " << v[0];

				// inserts at the beginning
				v.emplace(v.begin(), 5);
				cout << "\nThe first element is: " << v[0];

				// Inserts 20 at the end
				v.emplace_back(20);
				n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// erases the vector
				v.clear();
				cout << "\nVector size after clear(): " << v.size();

				// two vector to perform swap
				vector<int> v1, v2;
				v1.push_back(1);
				v1.push_back(2);
				v2.push_back(3);
				v2.push_back(4);

				cout << "\n\nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";

				// Swaps v1 and v2
				v1.swap(v2);

				cout << "\nAfter Swap \nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";
			}
			Output:
				The vector elements are: 10 10 10 10 10 
				The last element is: 15
				The vector elements are: 10 10 10 10 10 
				The first element is: 5
				The first element is: 10
				The first element is: 5
				The last element is: 20
				Vector size after erase(): 0

				Vector 1: 1 2 
				Vector 2: 3 4 
				After Swap 
				Vector 1: 3 4 
				Vector 2: 1 2
		
		-Erase method:
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
					// Assign vector
				vector<int> v;
				
				// fill the vector with 10 five times
				v.push_back(10);
				v.push_back(20);
				v.push_back(30);
				v.push_back(40);
				v.push_back(50);
				
				for(auto i: v)
					std::cout << i << " ";
				
				v.erase(v.begin()+3);       //removing 4th element 40.
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
					
					v.erase(v.begin());     //removing first element
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
				
				return 0;
			}

		Time Complexity of Vector:
			-The time complexity for doing various operations on vectors is-
				Random access – constant O(1)
				Insertion or removal of elements at the end – constant O(1)
				Insertion or removal of elements – linear in the distance to the end of the vector O(N)
				Knowing the size – constant O(1)
				Resizing the vector- Linear O(N)

	3) Deque:
		-Doubly ended queue
		-Means you can perform insertion/Deletion (push/ pop) operation from both ends, front & back.
		-Its implementation is bit complex, it uses static array not on contiguous location
		-It is DYNAMIC.
		-Random Access of element is possible
		-The deque::max_size() is a built-in function in C++ STL,
		 which returns the maximum number of elements that a deque container can hold.
			Syntax:
				deque_name.max_size()

			Parameters: The function does not accept any parameters.
			Return Value: The function returns the maximum number of elements that a deque container can hold.
			eg.
				int main(){
					deque<int> dq;
					
					cout << "The max-size of deque: " << dq.max_size();			//The max-size of deque: 4611686018427387903	
					return 0;
				}
			
		eg.
			#include <iostream>
			#include<deque>
			using namespace std;

			int main()
			{
				deque<int> d;
				
				//inserting at ending,
				d.push_back(1);
				d.push_back(2);
				d.push_back(3);
				d.push_back(4);
				d.push_back(5);
				
				d.push_front(100);
				d.push_front(200);
				d.push_front(300);
				d.push_front(400);
				d.push_front(500);
				
				for(auto i: d)
					std::cout << i << " ";          //500 400 300 200 100 1 2 3 4 5 

				//Removing element from start       //500
				d.pop_front();
				
				//Removing element from back        //5
				d.pop_back();
				
				cout<<"\nAfter removal : \n ";
				for(auto i: d)
					std::cout << i << " ";                  // 400 300 200 100 1 2 3 4 
					
				//accessing first index element
				cout<<"\nFirst index element : "<<d[1];     //First index element : 300
				
				//using at()
				cout<<"\n4th index element : "<<d.at(4);    //4th index element : 1
					
				//start element
				std::cout << "\n Start element : "<< d.front() << std::endl;            //Start element : 400
				
				//end element
				
				std::cout << "End element : "<< d.back() << std::endl;                  //End element : 4
				
				std::cout << "deque empty? : "<<boolalpha<< d.empty() << std::endl;     //0 or false, its not empty.
				
				std::cout << "Deque Size : "<< d.size() << std::endl;                   //Deque Size : 8
				
				std::cout << "Capacity : "<< d.max_size() << std::endl;                 //Capacity : 2305843009213693951
				
				//Deleting range of elements from 3 to 5, 3rd & 4th only not 5th.
				d.erase(d.begin()+3, d.begin()+5);              //100 1
				
				cout<<"\nDeleted few elements: ";
				for(auto i: d)
					std::cout << i << " ";                  // Deleted few elements: 400 300 200 2 3 4 
				
				//Deleting all elements
				d.clear();
				std::cout << "\nDeque Size : "<< d.size() << std::endl;                   //Deque Size : 0

				return 0;
			}

	4) List:
		-Lists are sequence containers that allow non-contiguous memory allocation. 
		-As compared to the vector, the list has slow traversal, but once a position has been found, 
		 insertion and deletion are quick (constant time). 
		-Normally, when we say a List, we talk about a doubly linked list. For implementing a singly linked list, 
		 we use a forward_list.

		-std::list is the class of the List container. 
		-It is the part of C++ Standard Template Library (STL) and is defined inside <list> header file.
		-Random access is not possible.
		Points to Remember about List Container:-
			-It is generally implemented using a dynamic doubly linked list with traversal in both directions.
			-Faster insert and delete operation as compared to arrays and vectors.
			-It provides only sequential access. Random Access to any middle element is not possible
			-It is defined as a template so it is able to hold any data type.
			-It operates as an unsorted list would, which implies that by default, the list’s order is not preserved. However, there are techniques for sorting.

		Syntax:
			std::list <data-type> name_of_list;
			eg.
				list<int> L;
		
		eg.
			#include <iostream>
			#include <list>
			using namespace std;

			int main()
			{
				list<int> L;
				
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;          //The size of List :: 0

				
				L.push_back(90);            //insertion at back
				L.push_back(100);
				
				L.push_front(910);          //insertion at front side
				L.push_front(800);
				
				for(auto i:L)
					cout<<i<<" ";           //800 910 90 100 
					
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;      //The size of List :: 4
				
				std::cout << "\nThe max size of List :: "<< L.max_size();           //The max size of List :: 384307168202282325
				
				//deleting start element      //800
				//you can't delete random element coz list doesn't provide random access to element.
				
				L.erase(L.begin());
				cout<<"\n start element removed : ";            // start element removed : 910 90 100 
				for(auto i:L)
					cout<<i<<" ";
					
				//copy
				list<int> n(L);
				cout<<"\n copied list : ";
				for(auto i:L)
					cout<<i<<" ";                       //copied list : 910 90 100 
					
				//list with default value 0
				
				//list<DataType> list_name(size)
				list<int> a(5);         
				
				cout<<"\n List A: ";
				for(int i:a)
					cout<<i<<" ";           // List A: 0 0 0 0 0 
					
				//list<DataType> list_name(size, DefaultValue);
				
				list<int> b(7, 31);         
				
				cout<<"\n List B: ";
				for(int i:b)
					cout<<i<<" ";           //  List B: 31 31 31 31 31 31 31 
				
				L.clear();      //deleting all list element,
				cout << "\n The size of List AFTER CLEARING :: "<< L.size();            // The size of List AFTER CLEARING :: 0

				return 0;
			}

	5) Stack:
		-LIFO (Last In First Out).
		-new element is added at one end (top) and an element is removed from that end only.
		-Operations:
			push(), pop(), top(), size(), empty() all are having Time complexity of O(1)
		
		eg.
			#include <iostream>
			#include <stack>
			using namespace std;

			int main(){
				stack<string> stsr;
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        //Size of Stack :: 0
				
				stsr.push("Vivek");
				stsr.push("Mahesh");
				stsr.push("Saraswait");
				stsr.push("Rohini");
				stsr.push("Computer");
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;					//TOP element of stack : Computer
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        					//Size of Stack :: 5

				stsr.pop();
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;								//TOP element of stack : Rohini
				
				std::cout << "Stack empty? :: "<< stsr.empty() << " " << boolalpha <<stsr.empty() << std::endl;		//Stack empty? :: 0 false
				return 0;
			}

	6) Queue:
		-operate in a first in first out (FIFO) type of arrangement. 
		-Elements are inserted at the back (end) and are deleted from the front.
		-operations:
			push(), pop(), front(), back(), emplace(), size(), empty() all are have Time complexity of O(1).

		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				queue<string> sq;
				
				std::cout << "Size of Queue before insertion : "<< sq.size() << std::endl;
				
				sq.push("First");
				sq.push("Second");
				sq.push("Third");
				sq.push("Forth");
				
				std::cout << "Size of Queue After insertion : "<< sq.size() << std::endl;
				
				std::cout << "start element of Queue : "<< sq.front() << std::endl;
				
				std::cout << "Last element of Queue : "<< sq.back() << std::endl;
				
				sq.pop();
				
				std::cout << "start element After poping : "<< sq.front() << std::endl;
				
				std::cout << "Queue empty? : "<< boolalpha <<sq.empty() << std::endl;
				return 0;
			}

			//ouput:
				Size of Queue before insertion : 0
				Size of Queue After insertion : 4
				start element of Queue : First
				Last element of Queue : Forth
				start element After poping : Second
				Queue empty? : false

		emplace operation used to insert element in queue:{
			queue<char> myqueue;
			myqueue.emplace('k');
			myqueue.emplace('j');
			myqueue.emplace('y');
			myqueue.emplace('r');
			myqueue.emplace('y');
			myqueue.emplace('u');
			
			// queue becomes k, j, y, r, y, u
			
			while (!myqueue.empty())
			{
				cout << ' ' << myqueue.front();
				myqueue.pop();
			}
			return 0;
		}

	7) Priority Queue:
		https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/
		Time complexity:
			push(), pop() on priority queue is of O(logN).
			top(), size() & empty() are constant time operations O(1).
		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				priority_queue<int> pq;     //by default it creates max-heap(decreasing order).
				
				std::cout << "Size : "<< pq.size() << std::endl;        //Size : 0

				pq.push(1);
				pq.push(3);
				pq.push(5);
				pq.push(2);
				pq.push(4);
				
				std::cout << "First element : "<< pq.top() << std::endl;        //First element : 5
				int pqSize = pq.size();
				
				std::cout << "Size : "<< pqSize << std::endl;           //Size : 5

				for(int i=0;i<pqSize;i++){
					cout<<pq.top()<<" ";            //5 4 3 2 1 
					pq.pop();
				}
				
				//min heap increasing order
				priority_queue<int, vector<int>, greater<int>> min;
				
				min.push(100);
				min.push(200);
				min.push(400);
				min.push(300);
				min.push(500);
				
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty(); //Min priority_queue is empty ? 0
				int minSize= min.size();
				
				cout<<"\n Min elements : ";
				
				for(int i=0;i<minSize;i++){
					cout<<min.top()<<" ";                   //Min elements : 100 200 300 400 500 
					min.pop();
				}
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty();     //Min priority_queue is empty ? 1
				return 0;
			}

	8) Set:
		-Stores unique elements
		-The values are stored in a specific sorted order i.e. either ascending or descending.
		-By default, the std::set is sorted in ascending order.
		-The std::set class is the part of C++ Standard Template Library (STL) and it is defined inside the <set> header file.
		-Syntax:
			std::set <data_type> set_name;

		-we have the option to change the sorting order by using the following syntax.
		-Syntax:
			std::set <data_type, greater<data_type>> set_name;

		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values
		
		Properties-
			Storing order – The set stores the elements in sorted order.
			Values Characteristics – All the elements in a set have unique values.
			Values Nature – The value of the element cannot be modified once it is added to the set, 
						though it is possible to remove and then add the modified value of that element. Thus, the values are immutable.
			Search Technique – Sets follow the Binary search tree implementation.
			Arranging order – The values in a set are unindexed.
		Note: To store the elements in an unsorted(random) order,  unordered_set() can be used.
		-set is little slower than unordered_set.

		•The time complexities for doing various operations on sets are:
			-Insertion of Elements – O(log N)
			-Deletion of Elements – O(log N)
			-insert(), find(), erase(), count() -> O(long N)
			-size(), begin(), empty(), end() -> O(1).
		eg.
			#include <iostream>
			#include <set>
			using namespace std;
			int main(){
				std::set<char> a;
				a.insert('A');
				a.insert('B');
				a.insert('E');
				a.insert('D');
				a.insert('C');
				
				//repeated element will not be inserted again in set.
				a.insert('B');
				a.insert('A');
				
				
				//sorted increasing order,
				for (auto& str : a) {           //& sign used
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (auto str : a) {                //& not used still fine
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (char str : a) {                //dataType char used.
					std::cout << str << ' ';
				}
				
				set<int> inSt;
				inSt.insert(100);
				
				inSt.insert(1);
				inSt.insert(1);
				
				inSt.insert(2);
				
				inSt.insert(5);
				inSt.insert(5);
				
				inSt.insert(4);
				inSt.insert(200);
				
				cout<<"\n";
				for(int i: inSt)
				cout<<i<<" ";
				
				//Decreasing order set
				set<int, greater<int>> descSet;
				
				descSet.insert(0);
				descSet.insert(1);
				
				descSet.insert(3);
				descSet.insert(3);
				
				descSet.insert(4);
				
				
				descSet.insert(200);
				descSet.insert(200);
				descSet.insert(300);
				
				descSet.insert(400);
				
				descSet.insert(2);
				descSet.insert(2);
				
				//descSet 
				cout<<"\n";
				for(int i: descSet)
				cout<<i<<" ";
				
				//erasing
				set<int>::iterator IT = descSet.begin();
				IT++;
				IT++;
				
				descSet.erase(IT);
				cout<<"\n Erased 2nd element:";
				for(int i: descSet)
				cout<<i<<" ";
				
				//deleting 300 from set, directly passing element which want to delete.
				descSet.erase(300);
				cout<<"\n 300 erased: ";
				for(int i: descSet)
				cout<<i<<" ";
				
				cout<<"\n400 is present in descSet ? "<<descSet.count(400);
				cout<<"\n300 is present in descSet ? "<<descSet.count(300);
				
				cout<<"\ndescSet empty? "<<descSet.empty();

				cout<<"\ndescSet max_size? "<<descSet.max_size();
				cout<<"\ndescSet size? "<<descSet.size();
				
				descSet.clear();
				cout<<"\ndescSet empty? "<<descSet.empty();
				
				return 0;
			}
			//ouput:
				A B C D E 
				A B C D E 
				A B C D E 
				1 2 4 5 100 200 
				400 300 200 4 3 2 1 0 
				Erased 2nd element:400 300 4 3 2 1 0 
				300 erased: 400 4 3 2 1 0 
				400 is present in descSet ? 1
				300 is present in descSet ? 0
				descSet empty? 0
				descSet max_size? 230584300921369395
				descSet size? 6
				descSet empty? 1

	9) Map:
		-Stores data in form of key-value pair
		-all keys are unique, one key points to one value only.
		-same keys will not points to different value,
		-value of keys might be same.
		-keys stored in sorted order.
		-Time Complexity:
			insert(), erase(), find(), count() is O(log N).
		eg.

			#include <iostream>
			#include <map>
			using namespace std;

			int main(){
				map<int, string> m;
				std::cout << " Before, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;
				
				m[4] = "Vivek";
				m[70] = "Seven";
				m[80] = "EIGHT";
				m[3] = "Rohini";
				m[2] = "Nikate";
				m[1] = "Aai";
				m[50] = "papa";
				
				m.insert({-10,"Minus num"});
				m.insert({-11, "minus 11"});

				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";

				std::cout << "After, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;

				//key present
				std::cout << "4 key present? "<< m.count(4) << std::endl;
				std::cout << "40 key present? "<< m.count(40) << std::endl;

				//erase
				m.erase(2); //key 2 removed
				m.erase(-11); //key 2 removed
				
				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";
				
				cout<<"\n";
				//print all element after key 4.
				auto it = m.find(4);
				for(auto i=it; i != m.end(); i++)
					cout<<(*i).first<<" "<<(*i).second<<"\n";
				
				return 0;
			}

	10) STL Algorithm:
		sort() works on introsort, its combination of quick sort, heap sort & insertion sort.
		eg.
			#include <algorithm>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> v={11,55,44,33,22,23,78,90,45,67,879,675};
				
				std::cout << "Vector size : "<< v.size() << std::endl;
				
				//find 22 (not working properly)
				std::cout << "22 present? "<< binary_search(v.begin(), v.end(), 55) << std::endl;
				std::cout << "upper_bound : "<< upper_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				std::cout << "lower_bound : "<< lower_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				

				int a=90, b=40;
				std::cout << "MAX of A & B : "<< max(a,b) << std::endl;
				std::cout << "min of A B"<< min(a,b) << std::endl;

				printf("A: %d, B: %d", a,b);
				swap(a,b);
				printf("\nA: %d, B: %d", a,b);
				
				string str = "asdfghjkl";
				std::cout << "String : "<< str << std::endl;
				
				reverse(str.begin(),str.end());
				std::cout << "Reverse String : "<< str << std::endl;

				std::cout  << std::endl;
				//rotate
				for(auto i:v)
					cout<<i<<" ";
				
				rotate(v.begin(), v.begin()+3, v.end());
				
				std::cout  << std::endl;
				for(auto i:v)
					cout<<i<<" ";
					
				//sorted
				sort(v.begin(), v.end());
				std::cout << std::endl << "Sorted: ";
				for(auto i:v)
					cout<<i<<" ";
				return 0;
			}
			//ouput:
				Vector size : 12
				22 present? 0
				upper_bound : 10
				lower_bound : 10
				MAX of A & B : 90
				min of A B40
				A: 90, B: 40
				A: 40, B: 90String : asdfghjkl
				Reverse String : lkjhgfdsa

				11 55 44 33 22 23 78 90 45 67 879 675 
				33 22 23 78 90 45 67 879 675 11 55 44 
				Sorted: 11 22 23 33 44 45 55 67 78 90 675 879
---------------------------------------------------------------------------------------------------------
	27/08/23
Lecture-20:
	LeetCode Practice:
		1) Reverse Vector:
			-reverse(startIndex, endIndex);
			-reverse function defined in the algorithm header file.
			using built in function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					std::cout  << std::endl;
					reverse(v.begin(), v.end());
					
					cout<<"After: ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";

					return 0;
				}

			Without using builtint function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				vector<int> REVERSE(vector<int> a){
					int start=0, end = a.size()-1;
					
					while(start <= end){
						swap(a[start], a[end]);
						start++;
						end--;
					}
					
					return a;
				}

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					
					vector<int> ans= REVERSE(v);
					
					cout<<"\nAfter: ";
					for(int i=0;i<ans.size();i++)
						cout<<ans[i]<<" ";

					return 0;
				}
			
		2) Reverse The Array:
			-Reversing array from given position
			eg.
				Sample Input 1:
				2
				6 3
				1 2 3 4 5 6
				5 2
				10 9 8 7 6
				Sample Output 1:
				1 2 3 4 6 5
				10 9 8 6 7
				Explanation 1:
				For the first test case, 
				Considering 0-based indexing we have M = 3 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {1, 2, 3, 4, 6, 5}.

				For the second test case, 
				Considering 0-based indexing we have M = 2 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {10, 9, 8, 6, 7}.
				Sample Input 2:
				2
				7 3
				1 4 5 6 6 7 7 
				9 3
				10 4 5 2 3 6 1 3 6
				Sample Output 2:
				1 4 5 6 7 7 6
				10 4 5 2 6 3 1 6 3 

			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				return reverse(arr.begin()+m+1,arr.end());
			}

			//or
			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				int start = m+1, end = arr.size()-1;
				while (start <= end) {
					swap(arr[start], arr[end]);
					start++;
					end--;
				}
			}
		
		3) Merge Sorted Array:
			void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
				vector<int> nm;
				int i=0,j=0;
				while(i<m && j<n){
					if(nums1[i] < nums2[j]){
						nm.push_back(nums1[i++]);
					}else{
						nm.push_back(nums2[j++]);
					}
				}

				while(i < m)
					nm.push_back(nums1[i++]);

				while(j < n)
					nm.push_back(nums2[j++]);
				
				//nums1.clear();
				nums1 = nm;
			}
		
			#Program:
				#include<iostream>
				#include<vector>
				using namespace std;

				void merge(int arr1[], int n, int arr2[], int m, int arr3[]) {
					int i = 0, j = 0;
					int k = 0;
					while( i<n && j<m) {
						if(arr1[i] < arr2[j]){
							arr3[k++] = arr1[i++];
						}
						else{
							arr3[k++] = arr2[j++];
						}
					}

					//copy first array k element ko
					while(i<n) {
						arr3[k++] = arr1[i++];
					}

					//copy kardo second array k remaining element ko
					while(j<m) {
						arr2[k++] = arr2[j++];
					}
				}

				void print(int ans[], int n) {
					for(int i=0; i<n; i++) {
						cout<< ans[i] <<" ";
					}
					cout << endl;
				}

				int main(){
					int arr1[5] = {1,3,5,7,9};
					int arr2[3] = {2,4,6};

					int arr3[8] = {0};

					merge(arr1, 5, arr2, 3, arr3);
					print(arr3, 8);
					return 0;
				}

		4) Move Zeroes:
			Given an integer array nums, move all 0's 
			to the end of it while maintaining the relative order of the non-zero elements.
			Note that you must do this in-place without making a copy of the array.
				Example 1:

				Input: nums = [0,1,0,3,12]
				Output: [1,3,12,0,0]
				Example 2:

				Input: nums = [0]
				Output: [0]
			->
				void moveZeroes(vector<int>& nums) {
					int len = nums.size();
					int cnt =0;
					vector<int> temp;
					for(int i=0;i<len;i++){
						if(nums[i] == 0)
							cnt++;
						else
							temp.push_back(nums[i]);
					}
					for(int i=0; i<cnt; i++)
						temp.push_back(0);
					
					nums = temp;
				}

				//or
					int i=0;
					for(int j=0;j<nums.size(); j++)
						if(nums[j] != 0)
							swap(nums[i++], nums[j]);
		
		5) Subarray or not?
			#include <iostream>
			#include <vector>
			using namespace std;

			int main (){
				vector<int> array = {1,2,3,4,5,6,7,8,9};
				vector<int> sequence = {2,3,4};
				
				int temp = 0;
				for (int i = 0; i < sequence.size ();){
					int h = temp;
					for (h; h < array.size (); h++)
						if (sequence[i] == array[h]){
							i++;
							temp = h;
							break;
						}
					if (h == array.size ()){
						std::cout << "not a subarray" << std::endl;
						return 0;
					}
				}
				cout<<"Its a subarray";
				return 0;
			}
---------------------------------------------------------------------------------------------------------
	3/09/23
Lecture-21
	Solving LeetCode/CodeStudio Questions [Arrays]
		1) Rotate Array
			Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
				Example 1:

				Input: nums = [1,2,3,4,5,6,7], k = 3
				Output: [5,6,7,1,2,3,4]
				Explanation:
				rotate 1 steps to the right: [7,1,2,3,4,5,6]
				rotate 2 steps to the right: [6,7,1,2,3,4,5]
				rotate 3 steps to the right: [5,6,7,1,2,3,4]
				Example 2:

				Input: nums = [-1,-100,3,99], k = 2
				Output: [3,99,-1,-100]
				Explanation: 
				rotate 1 steps to the right: [99,-1,-100,3]
				rotate 2 steps to the right: [3,99,-1,-100]

			class Solution {
				public:
				void rotate(vector<int>& nums, int k) {
					int n = nums.size();
					vector<int> temp(n);

					for(int i=0;i<n;i++)
						temp[(i+k)%n] = nums[i];

					nums = temp;
				}
			};
		
		2) Check if Array Is Sorted and Rotated:
			https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/
			class Solution {
			public:
				bool check(vector<int>& nums) {
					int cnt=0;
					for(int i=1;i<nums.size();i++)
						if(nums[i-1] > nums[i])
							cnt++; 
					if(nums[nums.size()-1] > nums[0])
						cnt++;
					return cnt<=1;
				}	
			};

		3) Sum Of Two Arrays:
			Sample Input 1:
				2
				4 1 
				1 2 3 4
				6
				3 2
				1 2 3
				9 9    
				Sample Output 1:
				1 2 4 0
				2 2 2
				Explanation For Sample Input 1:
				For the first test case, the integer represented by the first array is 1234 and the second array is 6, so the sum is 1234 + 6 =  1240.

				For the second test case, the integer represented by the first array is 123 and the second array is 99, so the sum is 123 + 99 = 222.
				Sample Input 2:
				2
				3 3 
				4 5 1
				3 4 5
				2 2
				1 1
				1 2
				Sample Output 2:
				7 9 6
				2 3

			#include <bits/stdc++.h> 
			int convertor(vector<int> , int);
			vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {

				int n1 = convertor(a, n);
				int n2 = convertor(b, m);

				int sum = n1 + n2;

				vector<int> sample;

				while(sum){
					int temp = sum % 10;
					sample.push_back(temp);
					sum /=10;
				}

				reverse(sample.begin(), sample.end());
				return sample;	
			}

			int convertor(vector<int> a, int len){
				int num =0;
				//array to num
				for(int i=0;i<len;i++)
					num = num * 10 + a[i];

				return num;
			}

			#include <bits/stdc++.h> 
			vector<int> findArraySum(vector<int>& a, int n, std::vector<int>& b, int m) {
				vector<int> v;
				int i = n - 1;
				int j = m - 1;
				int carry = 0;

				while (i >= 0 && j >= 0) {
						
					int sum = a[i--] + b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//first array len is greater than second
				while (i >= 0) {
					int sum = a[i--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//second array len is greater than first
				while (j >= 0) {
					int sum = b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//carry is remain to add
				while (carry != 0) {
					int sum = carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}
				return v;
			}
---------------------------------------------------------------------------------------------------------
	14/09/23
Lecture-22
	All about Char Arrays, Strings & solving LeetCode Questions

---------------------------------------------------------------------------------------------------------
#miscellaneous
	//Curly braces related..

		#include <iostream>
		using namespace std;

		int main()
		{
			if(0)
				if(0)
					std::cout << "nested if" << std::endl;
			else
				cout<<"nested else";					//if this else block is not present then outside else block got attached to inner if block
			else										//works like putting curly braces around if-else block.
				cout<<"outside if main IF got FALSE";
					
			return 0;
		}
	
	//Label
		if() can accept any non-zero or -ve value considered as true 
		if 0 then false.
		#include <iostream>
		using namespace std;

		int main()
		{
		
			if(2)					//if(-2)			this is also true.
				goto L2;

			L1: 
			
			std::cout << "Lable 1st" << std::endl;
			
			
			std::cout << "Lable 1st" << std::endl;
			
			
			std::cout << "Lable 1st" << std::endl;
			
			
			std::cout << "Lable 1st" << std::endl;
			
			L2:
				
			std::cout << "Lable 2nd" << std::endl;
			
			
			std::cout << "Lable 2nd" << std::endl;
			
			
			std::cout << "Lable 2nd" << std::endl;
			
			
			std::cout << "Lable 2nd" << std::endl;
			
			
			std::cout << "Lable 2nd" << std::endl;
			
			L3:
			return 0;
		}

	//Factorial:
		//fact program
		//position of increment decrement operator matters a LOTTTTTTTTT.
		#include <iostream>

		using namespace std;

		int main()
		{
			int n,t;
			cin>>n;
			t=n-1;
			
			while(t)
				n *= t--;
			
			std::cout <<endl<< n << std::endl;
			return 0;
		}

	//SWAP function:
		#include <iostream>
		using namespace std;

		int main()
		{
			int a = 10;
			int b = 20;
			cout << "Value of a before: " << a << endl;
			cout << "Value of b before: " << b << endl;

			// swap values of the variables
			swap(a, b);			//takes 2 values.

			//or
			a = a + b;	//a^b		//10+20=30
			b = a - b;	//a^b		//30-20=10
			a = a - b;	//a^b		//30-10=20

			cout << "Value of a now: " << a << endl;
			cout << "Value of b now: " << b << endl;
			return 0;
		}

	//while loop:
		#include <iostream>
		using namespace std;

		int main()
		{
			int i=0,j=0;
			
			while(i<5 && j<10){
				
				std::cout << i<<" "<<j << std::endl;			// and Operator is there so both condition must be true.
				i++;j++;									//output will be 0 to 4,
			}
			return 0;
		}

		//or if we used || or (,) then 0 - 9 will be printed.
		#include <iostream>
		using namespace std;

		int main()
		{
			int i=0,j=0;
			while(i<5 , j<10){          //while(i<5 || j<10)
				std::cout << i<<" "<<j << std::endl;
				i++;j++;
			}

			return 0;
		}

	//Remain 
		//Line 4237 Triplet sum didn't understand❌ (come back here later.).
		-Check TLE again (Time Limit Exceeded). https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/

	//Self Solved:
		1. Two Sum
			vector<int> twoSum(vector<int>& nums, int target) {
				vector<int> ans;
				
				for(int i=0;i<nums.size(); i++){
					for(int j=i+1; j<nums.size(); j++){
						if(nums[i]+nums[j] == target){
							ans.push_back(i);
							ans.push_back(j);
						}
					}
				}
				return ans;
			}

		2. Coding Ninja Content:
			Container with Maximum Water:
				#include <bits/stdc++.h> 
				int maxAreaContainer(vector<int> &arr) {
					int n = arr.size();
					int area, mainMax=0;

					for(int i=0; i<n-1;i++){
						for(int j=i+1; j<n; j++){
							area = min(arr[i], arr[j]) * (j-i);

							if(mainMax < area)
								mainMax = area;
						}    
					}
						return mainMax;
				}

				//optimized:
					#include <bits/stdc++.h> 
					int maxAreaContainer(vector<int> &arr) {
						int n = arr.size();
						int left = 0;
						int right = n - 1;
						int mainMax = 0;

						while (left < right) {
							int width = right - left;
							int height = min(arr[left], arr[right]);
							int area = width * height;

							mainMax = max(mainMax, area);

							if (arr[left] < arr[right]) {
								left++;
							} else {
								right--;
							}
						}
						return mainMax;
					}

		3. Subarray with given sum
			vector<int> subarraySum(vector<int>arr, int n, long long s)
			{
				
				int start = 0;
				long long sum = 0;
				vector<int> v;
			
				if (s == 0) // Handle the case where target sum is 0
				{
					v.push_back(-1);
					return v;
				}
				
				for (int i = 0; i < n; i++)
				{
					sum += arr[i];
			
					while (sum > s && start <= i)
					{
						sum -= arr[start];
						start++;
					}
			
					if (sum == s)
					{
						v.push_back(start + 1);
						v.push_back(i + 1);
						return v;
					}
				}
				v.push_back(-1); // If no subarray found
				return v;
			}

			//or
				vector<int> subarraySum(vector<int>arr, int n, long long s)
				{
					// Your code here
					vector<int> res;
					bool bl = false;
					for (int i = 0; i < n; i++) {
						int currentSum = arr[i];
					
						if (currentSum == s) {
							res.push_back(i+1);
							res.push_back(i+1);
							bl=true;
							break;
						}
						else {
							// Try all subarrays starting with 'i'
							for (int j = i + 1; j < n; j++) {
								currentSum += arr[j];
					
								if (currentSum == s) {
									res.push_back(i+1);
									res.push_back(j+1);
									bl=true;
									break;
								}
							}
							if(bl) break;
						}
					}
					if(bl) return res;
						return {-1};
				}

		4. Smaller and Larger:
			vector<int> getMoreAndLess(int arr[], int n, int x) {
				int GreaterCount=0, LessCount=0;
				
				for(int i=0;i<n; i++){
					if(arr[i]>= x)
						GreaterCount++;
					
					if(arr[i]<=x)
						LessCount++;
				}
				
				vector<int> v;
				v.push_back(LessCount);
				v.push_back(GreaterCount);
				return v;
			}
		
		-Refere few programs from here also...
			https://auth.geeksforgeeks.org/user/viveknikate/practice

	//Char extraction & string addition:
		int main () {
			string firstName = "John ";
			char lastName =firstName[0];
			char n = 'f';
			string s;
			s+= n;
			s+= lastName;
			cout << s;
			return 0;
		}

	//CHAR_BIT:
		-This C++ program will output the value of the `CHAR_BIT` constant, 
		 which represents the number of bits in a `char` data type on the particular platform and compiler being used.
		-In most systems, a `char` data type is 8 bits (1 byte), but it's not guaranteed to be the same on all platforms. 
		 The `CHAR_BIT` constant is defined in the `<climits>` header in C++ and specifies 
		 the number of bits in the smallest addressable unit of the machine's memory.
		-So, when you run this program, it will likely output `8`, indicating that a `char` consists of 8 bits on your platform.
		eg.
			#include <iostream>
			#include <climits>
			using namespace std;
			int main(){
				cout<<CHAR_BIT<<"\n";
				cout<<CHAR_BIT * sizeof(int)<<"\n";
				return 0;
			}
			//ouput:
				8
				32

	//String initialization:
		#include <iostream>
		using namespace std;

		int main(){
			string s(10, 'V');
			std::cout << s << std::endl;
			return 0;
		}

	//String length calculate:
		-use size() or length function.
		#include <iostream>
		using namespace std;

		int main(){
			string s ="Vivek";
			std::cout << s.size() << std::endl;         //11
			std::cout << s.length() << std::endl;       //11

			return 0;
		}

	//Max of integer:
		int max_of_four(int a, int b, int c, int d){
			return max(max(a,b),max(c,d));
		}

	//String assinging value at specific index:
		#include <iostream>
		using namespace std;
		int main(){
			string a,b;
			cin>>a;
			cin>>b;
			
			cout<<a.length()<<" "<<b.length()<<endl;
			cout<<(a+b)<<endl;

			swap(a[0],b[0]);
			cout<<a<<" "<<b<<endl;
			
			a[0]='Z';
			b[2]='Q';
			
			cout<<a<<" "<<b;
			return 0;
		}
		//ouput:
			Vivek 
			Rohini
			5 6
			VivekRohini
			Rivek Vohini
			Zivek VoQini

	//Local variables are stored in an area called a stack. Global variables, static variables, and program instructions 
	 are stored in the permanent storage area. The memory space between these two regions is known as a heap.

	#modulus operator:
		-when you take mod operation on any num with x, then output
		 will be inbetween 0 to (x-1);
		 eg.
		 	with 5: output will be 0 to 4.	|	with 10: output will be 0 to 9.
			1 % 5 = 1						|		1 % 10 = 1
			2 % 5 = 2						|		2 % 10 = 2
			3 % 5 = 3						|		3 % 10 = 3
			4 % 5 = 4						|		4 % 10 = 4
			5 % 5 = 0						|		5 % 10 = 5
			6 % 5 = 1						|		6 % 10 = 6
			7 % 5 = 2						|		7 % 10 = 7
			8 % 5 = 3						|		8 % 10 = 8
			9 % 5 = 4						|		9 % 10 = 9
			10 % 5 = 0					|		10 % 10 = 0
---------------------------------------------------------------------------------------------------------
POTD:-[Problem of the Day]
	1) Minimum Difference in an Array	
		#include <bits/stdc++.h> 
		int minDiff(int n, vector < int > arr) {
			sort(arr.begin(), arr.end());
			// int minDiffHold = abs(arr[0] - arr[1]);      //or you can assign INT_MAX here also

			int minDiffHold =INT_MAX; 
			for (int i = 0; i < n - 1; i++) {
				if (arr[i] == arr[i + 1])
				return 0;

				int value = abs(arr[i] - arr[i + 1]);

				// assigning minimum value to mindiffhold variable.
				minDiffHold = min(value, minDiffHold);
			}
			return minDiffHold;
		}

	2) Reverse Coding:
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int row = mat.size();
			int column = mat[0].size();
			
			vector<vector<int>> v;

			for (int i = 0; i < row; i++) {

				vector<int> second;
				for (int j = column - 1; j >= 0; j--){
					int value = mat[i][j];
					second.push_back(value);
				}
				v.push_back(second);
			}

			return v;
		}

		//or
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int i=0,n = mat.size();

			while(i<n){
				reverse(mat[i].begin(), mat[i].end());
				i++;
			}
			return mat;
		}

	3) Planet Division:
		vector<int> planetDivision(int n) {
			vector<int> v;
			(n % 2 == 0)?(v.push_back(n/2), v.push_back(n/2)):(v.push_back((n/2)+1), v.push_back(n/2));
			return v;
		}

	4) Missing number in array:
		class Solution{
			public:
			int missingNumber(vector<int>& array, int n) {
				//(TLE)
				// for(int i=1;i<=n;i++){
				//     int j;
				//     for(j=0;j<n;j++){
				//         if(array[j] == i)
				//             break;
				//     }
				//         if(j == n)
				//             return i;
				// }
				
				/or (TLE)
				// int counter = 1, i=0;
				// while(i<n){
				//     if(array[i++] == counter){
				//         i=0;
				//         counter++;
				//     }
				// }
				// return counter; 
				
				//or (optimized)
				sort(array.begin(), array.end());
				for(int i=0;i<n;i++){
					if(array[i] != i+1)
						return i+1;
				}
			}
		};

	5) Count Odd Even
		void countOddEven(int arr[], int sizeof_array)
		{
			int odd=0, even=0;
			for(int i=0; i<sizeof_array;i++){
				(arr[i] % 2)? odd++ : even++;
			}
			cout<<odd<<" "<<even<<"\n";
		}

	6) Pattern 11
		void printTriangle(int n) {
			int bit = 0;
			for(int i=0;i<n; i++){
				int tempBit = bit;
				for(int j=0; j<=i; j++){
					(tempBit)?(tempBit =0):(tempBit = 1);
					cout<<tempBit<<" ";
				}
				if(bit == 0)
					bit =1;
				else
					bit = 0;
				printf("\n");
			}
		}
		//output
			Input: 5
			Output:
				1 
				0 1 
				1 0 1
				0 1 0 1 
				1 0 1 0 1

	7) Boring Factorial:
		Input:
			3
			2 5			(2!) % 5 =2
			5 11			(5!) % 11 =10
			21 71		(21!) % 71 =6

		Output:
			2
			10
			6
		#include <iostream>
		using namespace std;

		int main(){	
			int fact=1;
			int n=23,p=29;
			
				if(n >= p)
					return 0;

				for(int i=1;i<=n; i++){
					fact = (fact * i) % p; 
				cout<< fact<<"\t";
				}
			return 0;
		}

	8) Class Test:
		Sample Input 1 :
			2
			3
			1
			3 4 4
			4
			3
			1 1 2 2 
		Sample Output 1 :
		4
		1
		Explanation Of Sample Input 1 :
		For test case 1 we have, 

		To get a Rank 1, Ninja must have scored maximum marks in the class.
		Hence, Ninja scored 4 marks.
		For test case 2 we have,
		Students with marks = 2 will achieve ranks 1 and 2 respectively.
		Students with marks = 1 will achieve ranks 3 and 4 respectively.
		So, Ninja scored 1 mark.
		Sample Input 2 :
			test cases : 3
			i.	2
				1
				20 9 

			ii.	2
				1
				9 17 

			iii.	7
				2
				9 6 0 2 20 10 5 
		Sample Output 2 :
			20
			17
			10

		#include <bits/stdc++.h> 
		int classTest(int n, vector<int> &a, int k) {
			sort(a.begin(), a.end());
			reverse(a.begin(), a.end());

			int mark=a[0], temp =1;
			for(int i=0;i<n;i++){
				if(temp == k){
						mark = a[i];
					}
				temp++;
			}
			return mark;
		}

	9) Find the lone set bit & return its index.
		#include <iostream>
		#include <bitset>
		using namespace std;

		int main(){
			int N = 136;
			cout<<"binary form 136 "<<bitset<32>(N);
			std::cout << std::endl;
			if(N == 0){
				cout<<-1;
				return 0;
			}

			int count=0;
			if(N&1){
				cout<<-1;
				return 0;
			}else{
				int setBit =0;
				while(N>0){
					if(setBit == 1 && N >0){
						cout<<-1;
						return 0;
					}
					
					if(N & 1)
						setBit++;       //111010
					
					count++;
					N>>=1;
				}
			}
			cout<<count;
			return 0;
		}
	
	10) String Count:
		Sample Input 1:-
			2
			4 
			##**    
			3
			***
			Sample Output 1:-
			1
			0
			Explanation Of Sample Input 1:-
			First test case:- 
			We have three substrings of size 2 for the string 'S', which are "##", "#*" and "**".
			Only one of them is good(#* or *#) . So, the total number of good substrings of 'S' is 1.

			Second test case:-
			There is no good substring in 'S', so the answer is 0.
			Sample Input 2:-
			2
			4
			#*#*
			2
			*#
			Sample Output 2:-
				3
				1

			int stringCount(int n, string &s) {
				int ttl=0;
				int len = s.length();
				
				for(int i=0; i<len; i++){
					
					char first = s[i];
					char sec = s[i+1];
					string str = "";
					str += first;
					str += sec;
					
					if(str == "#*" || str == "*#")
						ttl++;
				}

				return ttl;
			}

	11) Sequence Query:
		Sample Input 1:
			start value, diff, target
			1 2 7
		Sample Output 1 :
			1
		Explanation For Sample Input 1:
		The sequence here is 1, 3, 5, 7, .... As 7 is present in the sequence, the output is 1.

		Sample Input 2:
		5 0 3
		Sample Output 2 :
		0
		Explanation For Sample Input 2:
		The sequence here is 5, 5, 5, .... As 3 is not present in the sequence, the output is 0.

		int checkSequence(int a, int d, int x) {
			// Write your code here.
			if(a == x || (d==1 && a<x))
				return 1;
			
			if((a > x && d>0) || (a < x && d<0))
				return 0;

			int counter=0;

			for(int start=a; ;start+=d)
			{

				a += d;
				if(a == x)
					return 1;

				counter++;
				if(counter>30)
					return 0;
			}
		}

	12) min & max:
		without using conditional operator, ternary operator
		eg.
			pair<int,int> ans= {a,b};
			for(int i=b;i<a;i++) {
				ans = {b,a};
				break;
			}
			return ans;		//returning minimum, maximum.

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				pair<int,int>pr;

				int max = (a>=b)*a+(b>a)*b;
				int min = (a<=b)*a+(b<a)*b;

				pr.first = min;
				pr.second = max;

				return pr;
			}

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				int mini = min(a,b);
				int maxi = max(a,b);
				
				pair<int,int> pr;
				// pr.first = mini;
				// pr.second = maxi;
				//or

				pr = {mini, maxi};
				return pr;
			}

		eg.
			#include <bits/stdc++.h>
			pair < int , int > findMinMax(int a , int b){
				return {min(a,b),max(a,b)};
			}
	
	13) Fibonacci series nums addition within given range:❌
		#include <bits/stdc++.h> 
		int fiboSum(int n , int m){
			int sum = 0;
			if(n<2) sum = 1;

			int a = 0, b = 1, mod = 1e9+7;

			for(int i=2;i<=m;i++){
				int c = (a+b)%mod;
				a = b;
				b = c;
				if(i>=n && i<=m)sum = (sum+c)%mod;
			}

			return sum;
		}

		#include <bits/stdc++.h> 
		long long int fiboSum(int n , int m){
			long long int prev =0, cur =1, fib=0;
			long long int sum=0;
			
			for(int i=0; i<=m; i++){
				
				// if(i>=n)
				// 	sum += prev;


				sum += prev;

				if(i<n)
					sum -= prev;
					
				fib = cur + prev;		 
				prev = cur;
				cur = fib;				 
			}
			return sum;	
		}

	14) Water Glass
		Sample Input 1:
		2
		2 2 2 3
		1 1 1 3
		Sample Output 1:
		normal
		cold
		##### Explanation Of Sample Input 1:

		For test case 1:
		The arrangement of glasses looks like,
		W W N N C C W W N N C C …………..
		Here the 3rd glass is N means it contains normal water.

		Hence, the answer for this case is "normal".


		For test case 2:
		The arrangement of glasses looks like,
		W N C W N C …………..
		Here the 3rd glass is C means it contains cold water.

		Hence, the answer for this case is "cold".
		Sample Input 2:
		2
		5 6 8 15
		9 3 3 12
		Sample Output 2:
		cold
		normal

		string waterGlass(long long x, long long y, long long z, long long n){
			// Write your code here.
			long long i,wrm, nrm, cld;
			vector<int> v;

			back:
			for(wrm=0; wrm<x; wrm++)
				v.push_back(1);

			for(nrm=0;nrm<y;nrm++)
				v.push_back(2);
			
			for(cld=0; cld<z;cld++)
				v.push_back(3);
			
			if(v.size() < n)
				goto back;


			// for(i=0;i<n;i++){
			// 	if(v[i] == )
			// }
			if(v[n-1] == 1){
				return "warm";
			}else if (v[n-1] == 2){
				return "normal";
			}else{
				return "cold";
			}
		}

	15) Toggle K bits:
		Sample Input 1:
			2
			21 3
			40 4
			Sample Output 1:
			18
			39
			Explanation For Sample Input 1:
			In example 1, the binary representation of 21 is '10101'. After toggling rightmost 3 bits, it becomes ‘10010’ which is equal to 18.
			In example 2, the binary representation of 40 is ‘101000’. After toggling rightmost 4 bits, it becomes ‘100111’ which is equal to 39.
			Sample Input 2:
			2 
			20 2
			85 5
			Sample Output 2:
			23
			74
			Explanation For Sample Input 2:
			In example 1, the binary representation of 20 is '10100'. After toggling rightmost 2 bits, it becomes ‘10111’ which is equal to 23.
			In example 2, the binary representation of 85 is ‘1010101’. After toggling rightmost 5 bits, it becomes ‘1001010’ which is equal to 74.

		#include <bits/stdc++.h> 
		using namespace std;
		int toggleKBits(int n, int k) {

			vector<int> v;
			for(int i=0;i<k;i++){
				int bit = n&1;
				n >>= 1;
				v.push_back(bit);
			}

			for(int i=0;i<v.size();i++)
				if(v[i] == 1){
					v[i] = 0;
				}else{
					v[i] = 1;
				}

			for(int i=0; i<k; i++){
				n <<= 1;
				n = n | v[v.size()-i-1];
			}
			return n;
		}

		//or
			#include <bits/stdc++.h>
				int toggleKBits(int n, int k) {
					return n^((1<<k)-1);
				}

	16) Unlucky Number:
		Num consist of 1 or 3 or 1 & 3 only. not other number;
			Sample Input 1
				1
				Sample Output 1
				1
				Sample Input 2
				2
				Sample Output 2
				3
				Sample Input 3
				5
				Sample Output 3
				31
			eg.
				1, 3, 11, 13, 31, 33, 111, 113, 131, 133, 311, 313, 331, 333.
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
			//Write your code here
			int n;
			cin>>n;

			vector<int> v;
			int IStore=0, checker;

				for(int j=1;j<2000000;j++){
					IStore = j;
					checker = j;
					while(checker>0){
						int temp = checker % 10;

						if(temp == 1 || temp ==3){
							checker /= 10;
							continue;
						}else{
							break;
						}
					}

					if(checker == 0)
						v.push_back(IStore);
				}
				cout<<v[n-1];
				return 0;
			} 

	17) Digit Count In Range:
		Sample Input 1:
			2
			3
			1 15
			2
			2 12
			Sample Output 1:
			2
			2
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [1, 13] = 2 (3, 13). Return 2


			In the second test case, 
			Number of occurrences of 2 in range [2, 12] = 2 (2, 12). Return 2
			Sample Input 2:
			2
			1 
			1 15
			3
			3 33
		
		Sample Output 2:
			8
			8
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 1 in range [1, 15] = 8 (1, 10, 11, 12, 13, 14, 15). Return 8

			In the second test case, 
			Number of occurrences of 3 in range [3, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int digitCount(int K, long long int A, long long int B){
			long long int counter = 0,i,JStorer;
			while(A<=B){
				JStorer = A;
				while(JStorer>0){
					int temp = JStorer % 10;
					if(temp == K)
						counter++;
					JStorer/=10;
				}
				A++;
			}
			return counter;	
		}

	18) Minimum Difference Of Subarrays:
		int minimumDifference(int n, vector<int> arr){
			//Declaring totalSum to store the sum of all elements of arr.
			int totalSum = 0;
			for (int idx = 0; idx < n; idx++)
				totalSum += arr[idx];

			// currentSum stores the sum of first subarray.
			int currentSum = 0, minDiff = INT_MAX;

			for (int idx = 0; idx < n - 1; idx++){

				// updating the sum of the current subarray.
				currentSum += arr[idx];

				// Updating the mininmum difference.
				minDiff = min(minDiff, abs(currentSum - (totalSum - currentSum)));
			}
			return minDiff;
		}

	19) Ninja And The Triangle:
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
			int Istorer, sum=0, i;
			for(i=1; i<n; i++)
				if((sum+i) <= n){
					sum += i;
					Istorer = i;
				}
				else
					break;
			
			return Istorer;
		}
		//or
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
		    int k = (int)(sqrt(2*n));
			while(k*(k+1)/2 > n)
				k--;
			return k;
		}

		//or
			#include <bits/stdc++.h> 
			int ninjaAndTriangle(int n) {
				int d = 1 + 8 * n;
				int x = (1 + sqrt(d))/2;
				return x-1;
			}

	20) Amazing Strings
		Sample Input 1:
			2
			HI HEY EIHYH
			ALL GOOD ADOLLG
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined has 1 A, 2 L, 1 G, 2 O and 1 D. While the string ‘THIRD’ has 1 A, 2 L, 1 G, 1 O and 1 D and So, it has one character less than the combined ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.
			Sample Input 1:
			2
			CODING NINJA NINCODINGJA
			YES NO NEEOOYS
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined have 1 N, 1 Y, 1 E, 1 S and 1 O. While the string ‘THIRD’ has 1 N, 1 Y, 2 E, 1 S and 2 O and So, it has one character more than ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.

		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size(),i=0;

			if((firLen + secLen) != len)
				return "NO";

			while(i<firLen){
				char tempCh = first[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}
			i=0;
			while(i<secLen){
				char tempCh = second[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}

			return "YES";
		}

		//or
		#include <algorithm>
		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size();
			int i=0;

			if((firLen + secLen) != len)
				return "NO";
			
			string full = first + second;
			sort(full.begin(), full.end());

			sort(third.begin(), third.end());
			
			if(full == third)
				return "YES";
			else
				return "NO";
		}

		//optimized:
			string amazingStrings(string first, string second,string third) {
				// Write your code here.
				if((first.length() + second.length()) == third.length())
					return "YES";
				else
					return "NO";
			}

	#Weekend Problem:
		21) Chocolate Removal Challenge:
			Explaination:
				You are given an array 'A' of size 'N'. Each element 'A[i]' represents the number of chocolates in the 'i-th' pile. 
				In a single move, you are allowed to perform the following operation: 
				If a pile contains more than 23 chocolates, you can take out all the chocolates leaving only 23 in the pile.

				Input: A = [25, 24, 29, 15]
				Output: 9

				First pile: Contains 25 chocolates, remove 2 to leave 23. Chocolates removed = 2.
				Second pile: Contains 24 chocolates, remove 1 to leave 23. Chocolates removed = 1.
				Third pile: Contains 29 chocolates, remove 6 to leave 23. Choclates removed = 6
				Fourth pile: Contains 15 chocolates, no chocolates removed as the pile already has less than or equal to 23 chocolates.
				Total chocolates removed = 2 + 1 + 6 = 9.

			Sample Input 1:
				2
				4
				25 24 10 15
				3
				30 20 40
				Sample Output 1 :
				3
				24
				Explanation For Sample Input 1:
				For test case 1:
				We remove 2 chocolates from the first pile and 1 from the second pile. Hence the total chocolates removed = 2 + 1 = 3.

				For test case 2:
				We remove 7 chocolates from the first pile, none from the second pile and 17 from the third pile. Hence the total chocolates removed = 7 + 17 = 24.
				Sample Input 2:
				2
				5
				100 200 300 400 500
				1
				23
				Sample Output 2 :
				1385
				0

			long long totalChocolates(int n, vector<int> a) {
				long long sum =0;
				for(int i=0;i<n;i++){
					if(a[i]> 23)
						sum += (a[i]-23);
				}
				return sum;
			}

		22) Odd Product:
			Ninja loves the odd numbers. He gives you an array 'A' of size 'N'. Help Ninja to find numbers of pairs '(L, R)' 
			such that products of array elements in the range 'L' to 'R' have an odd number of divisors.
			eg.
				'N' = 2
				'A' = [1, 4]

				There are total three possible pairs of '(L, R)':
				L = 1, R = 1, 'product = 1', divisors = [1]
				L = 1, R = 2, 'product = 1*4 = 4', divisors = [1, 2, 4]
				L = 2, R = 2 , 'product = 4', divisors = [1, 2 , 4]

				All three pairs have an odd number of divisors, so the answer is '3'.

			eg.
				Sample Input 1:
					2
					4
					1 2 4 2
					2
					1 2
					Sample Output 1:
					4
					1
					Explanation Of Sample Input 1:
					For test case 1:
					There are total '10' possible pairs of '(L, R)':

					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2', divisors = [1, 2]
					L = 1, R = 3, 'product = 1*2*4 = 8', divisors = [1, 2, 4, 8]
					L = 1, R = 4, 'product = 1*2*4*2 = 16', divisors = [1, 2, 4, 8, 16]
					L = 2, R = 2, 'product = 2', divisors = [1, 2]
					L = 2, R = 3, 'product = 2*4 = 8', divisors = [1, 2, 4, 8]
					L = 2, R = 4, 'product = 2*4*2 = 16', divisors = [1, 2, 4, 8]
					L = 3, R = 3, 'product = 4', divisors = [1, 2, 4]
					L = 3, R = 4, 'product = 4*2 = 8', divisors = [1, 2, 4, 8]
					L = 4, R = 4, 'product = 2', divisors = [1, 2]

					We can see that only '4' pairs have an odd number of divisors, so the answer is '4'.

					For test case 2:
					There are total three possible pairs of '(L, R)':
					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2 = 2', divisors = [1, 2]
					L = 2, R = 2 , 'product = 2', divisors = [1, 2]

					Only one pair has an odd number of divisors, so the answer is '1'.
					Sample Input 2:
					2
					4
					4 4 4 4
					5
					4 2 8 10 16
					Sample Output 2:
					10
					4
			
			long long oddProducts(int n, vector<int> &a){
				int counter=0;
				long long MainCounter=0;
				for(int b=0; b<n; b++){

					int prod=1,j;
					for(int c=b; c<n; c++){
						prod *= a[c];

						j=1;
						while(j<=prod){
							if(prod % j == 0)
								counter++;
							j++;
						}

						if(counter&1)
							MainCounter++;
						
						counter=0;
					}
				}
				return  MainCounter;
			}

	23) Strobogrammatic Number ll:
		-Given a length ‘N’, you need to find all the strobogrammatic numbers of length ‘N’.
		-A strobogrammatic number is a number that looks the same when rotated by 180.
		-In other words, a number that on rotating right side up and upside down appears the same is a strobogrammatic number.
		-‘986’ is a strobogrammatic number because on rotating ‘986’ by 180 degrees, ‘986’ will be obtained.
		-If N = 2, all the strobogrammatic numbers of length = 2 are “11”, “88”, “69”, “96”.
		-Sample Input 1:
			2
			3
			1
			Sample Output 1:
			101 111 181 609 619 689 808 818 888 906 916 986 
			0 1 8 
			Explanation For Sample Input 1:
			Test Case 1: All the possible Strobogrammatic numbers of length = 3 are “101”, “111”, “181”, “609”, “619”, “689”, “808”, “818”, “906”, “916”, “986”.

			Test Case 2: Strobogrammatic numbers of length = 1 are “0”, “1”, and “8”.
			Sample Input 2:
			2
			4
			2
			Sample Output 2:
			1001 1111 1691 1881 1961 6009 6119 6699 6889 6969 8008 8118 8698 8888 8968 9006 9116 9696 9886 9966 
			11 69 88 96 
			Explanation For Sample Input 2:
			Test Case 1: All the possible Strobogrammatic numbers of length = 4 are printed.

			Test Case 2: All the possible Strobogrammatic numbers of length = 2 are printed.

		#include <bits/stdc++.h> 
		bool checker(string st){

			int temp = stoi(st);
			int rev = 0;
			while(temp>0){
				rev = (temp % 10) + rev * 10; 
				temp /=10;
			}

			string tempStr = to_string(rev);
			int index=0;
			while(tempStr[index] != '\0'){
				if(tempStr[index] == '6')
					tempStr[index] = '9';
				else if(tempStr[index] == '9')
					tempStr[index] = '6';
				index++;
			}

			if(st == tempStr)
				return true;
			return false;
		}

		vector<string> findStrobogrammatic(int n){
			vector<string> s;
			if(n == 1)
				return {"0","1","8"};
			
			if(n == 2)
				return {"11","69","88","96"};

			int Digit = 1;
			Digit = pow(10,n-1);

			for(int i = Digit; i<(Digit*10); i++){
				int temp = i;
				while(temp > 0){
					int singleBit = temp % 10;
					if(singleBit == 0 || singleBit == 1 || singleBit == 6 || singleBit == 8 || singleBit == 9)
						temp /=10;
					else
						break;
				}
				if(temp == 0)
					s.push_back(to_string(i));
			}

			vector<string> Upgraded;

			for(int i=0; i<s.size(); i++){
				string tempStr = s[i];
				
				if(checker(tempStr))
					Upgraded.push_back(tempStr);
			}
			return Upgraded;
		}

		//optimized:
			vector < string > findStrobogrammaticHelper(int n, int len) {
				// If len = 0, return empty string.
				if (len == 0) {
					return vector < string > ({ "" });
				}

				if(len == 1){
					return vector < string > ({"0", "1", "8" });
				}

				// Recursively call for len = len - 2.
				vector < string > prev = findStrobogrammaticHelper(n, len - 2);

				// Initialize vector of strings to store resulting strings.
				vector < string > res;

				// Iterate through all strings in "prev".
				for (int i = 0; i < prev.size(); i++) {

					// Add digits around string prev[i].
					if (len != n) {
						res.push_back("0" + prev[i] + "0");
					}

					res.push_back("1" + prev[i] + "1");
					res.push_back("6" + prev[i] + "9");
					res.push_back("8" + prev[i] + "8");
					res.push_back("9" + prev[i] + "6");
				}
				return res;
			}

			vector < string > findStrobogrammatic(int n) {
				// Recursive function to find all strobogrammatic numbers.
				vector < string > ans = findStrobogrammaticHelper(n, n);
				return ans;
			}

	24) Set Matrix Ones
		#include <bits/stdc++.h> 
		void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
			vector<vector<int>> ans(n, vector<int>(m,0));
			for(int i=0;i<n; i++){
				for(int j=0;j<m;j++){
					if(MAT[i][j] == 1){
						for(int b=0;b<m;b++)
							ans[i][b] =1;                
						for(int a =0;a<n;a++)
							ans[a][j] = 1;
					}
				}
			}
			MAT = ans;
		}

		//optimized:
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<pair<int, int>> ones;
				vector<bool> rowHasOne(n, false);
				vector<bool> colHasOne(m, false);

				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (MAT[i][j] == 1) {
							rowHasOne[i] = true;
							colHasOne[j] = true;
						}
				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (rowHasOne[i] || colHasOne[j]) 
							MAT[i][j] = 1;
			}

	25) Count Distinct Element in Every K Size Window
		you are given an array ‘ARR’ of size ‘N’ and an integer ‘K’. Your task is to find the total
		number of distinct elements present in every ‘K’ sized window of the array. A ‘K’ sized
		window can also be viewed as a series of continuous ‘K’ elements present in the
		sequence.
		Note:
			1. The size of ‘ARR’ will always be greater than or equal to the ‘K’.
			2. Here window refers to a subarray of ‘ARR’. Hence ‘K’ sized window means a subarray of size ‘K’.
			3. You are not required to print the output explicitly. It has already been taken care of. Just
			 implement the function and return an array of the count of all distinct elements in the ‘K’ size window.
		eg.
			consider ARR = [ 1, 2, 1, 3, 4, 2,3 ] and K = 3.

			As per the given input, we have a sequence of numbers of length 7, and we need to find the number of
			distinct elements present in all the windows of size 3.
			Window-1 has three elements { 1,2, 1 } and only two elements { 1,2 } are distinct because 1 is repeating two times.
			Window-2 has three elements { 2,1, 3 } and all three elements are distinct { 2, 1, 3 }.
			Window-3 has three elements { 1,3, 4 } and all three elements are distinct { 1, 3, 4 }.
			Window-4 has three elements { 3,4, 2 } and all three elements are distinct { 3, 4, 2 }.
			Window-5 has three elements { 4,2, 3 } and all three elements are

			Hence, the count of distinct elements in all K sized windows is { 2, 3, 3, 3, 3 }.
		eg.
			Sample Input 1:
				2
				7 4
				1 2 1 3 4 2 3
				5 3
				1 1 2 1 3
				Sample Output 1:
				3 4 4 3
				2 2 3
				Explanation Of Sample Input 1:
				Test Case 1:

				Window-1 has four elements { 1, 2, 1, 3 } and only three elements { 1, 2, 3 } are distinct because 1 is repeating two times.
				Window-2 has four elements { 2, 1, 3, 4 } and all four elements { 2, 1, 3, 4 } are distinct.
				Window-3 has four element { 1, 3, 4, 2 } and all four elements { 1, 3, 4, 2 } are distinct. 
				Window-4 has four element { 3, 4, 2, 3 } and only three elements { 3, 4, 2 } are distinct because 3 is repeating two times.

				Hence, the count of distinct elements in all windows is { 3, 4, 4, 3}.

				Test case 2: 

				Window-1 has three elements { 1, 1, 2 } and only two elements { 1, 2 } are distinct because 1 is repeating two times.
				Window-2 has three elements { 1, 2, 1 } and only two elements { 2, 1 } are distinct.
				Window-3 has three elements { 2, 1, 3 } and all three elements { 2, 1, 3 } are distinct.

				Hence, the count of distinct elements in all windows is { 2, 2, 3 }.
				Sample Input 2:
				2
				4 1
				2 3 1 2
				5 2
				2 2 3 2 1
				Sample Output 2:
				1 1 1 1
				1 2 2 2

		#include <bits/stdc++.h> 
		vector<int> countDistinctElements(vector<int> &arr, int k) {
			vector<int> DistinctCount;
			int len = arr.size();
			int Lind =k-1;
			int i=0,j;
			int windowHolder = k;
			while(Lind < len){
				set<int> temp;
				j = i;
				while(windowHolder){
					temp.insert(arr[j++]);
					windowHolder--;
				}
				i++;
				windowHolder = k;
				DistinctCount.push_back(temp.size());
				temp.clear();
				Lind += 1;
			}
			return DistinctCount;
		}

		//optimized:
			#include <bits/stdc++.h> 
			vector<int> countDistinctElements(vector<int> &arr, int k) {
				std::vector<int> distinctCount;
				int len = arr.size();
				
				if (k <= 0 || k > len) {
					return distinctCount;  // Handle invalid input.
				}
				
				std::unordered_map<int, int> elementCount;
				int distinct = 0;
				
				// Calculate distinct elements in the first window.
				for (int i = 0; i < k; ++i) {
					if (elementCount[arr[i]] == 0) {
						distinct++;
					}
					elementCount[arr[i]]++;
				}
				
				distinctCount.push_back(distinct);
				
				// Slide the window and update distinct count.
				for (int i = k; i < len; ++i) {
					int leftElement = arr[i - k];
					int rightElement = arr[i];
					
					// Remove the leftmost element from the window.
					if (elementCount[leftElement] == 1) {
						distinct--;
					}
					elementCount[leftElement]--;
					
					// Add the rightmost element to the window.
					if (elementCount[rightElement] == 0) {
						distinct++;
					}
					elementCount[rightElement]++;
					
					distinctCount.push_back(distinct);
				}
				return distinctCount;	
			}

	26) Tweaked Array:
		Sample Input 1 :
			2
			3
			1 4 1
			3
			5 2 -5
			Sample Output 1 :
			5 2 5
			-3 0 7
			Explanation Of Sample Input 1 :
			For test 1:
			TotalSum = 1 + 4 + 1 = 6
			Tweaked array = {6 - 1,  6 - 4,  6 - 1} = {5, 2, 5}

			For test 2:
			TotalSum = 5 + 2 + (-5) = 2
			Tweaked array = {2 - 5,  2 - 2,  2 - (-5)} = {-3, 0, 7}
			Sample Input 2 :
			2
			2
			1 2
			3
			-1 -2 -4
			Sample Output 2 :
			2 1
			-6 -5 - 3

		#include <bits/stdc++.h> 
		vector<int> tweakTheArray(vector<int> arr, int n){
			int sum=0;
			for(int i=0; i<arr.size(); i++){
				sum += arr[i];
			}

			for(int i=0;i<arr.size();i++)
				arr[i] = sum - arr[i];

			return arr;
		}

	27) Lucky String:
		You are given a string 'S' of length 'N' consisting of lowercase latin letters. If
		there is a letter occurring consecutively three times (at least three times), the
		string becomes unlucky for you. Your task is to erase some characters
		from the string such that it becomes lucky for you. A string which is not unlucky, is considered as lucky.
		Output the minimum number of removals (of characters) required to make the given
		string lucky.
		Sample Input 1 :
			2
			7
			abcccca
			5
			cbazz
			Sample Output 1 :
			2
			0
			Explanation For Sample Input 1 :
			For test case 1:
			If a substring "cc" is deleted from any position, the remaining string becomes lucky. Hence a minimum removal of 2 characters is required. 

			For test case 2:
			Given string is already lucky. No removal is required.
			Sample Input 2 :
			3
			5
			bbbbb
			2
			xy
			9
			abcccbaaa
			Sample Output 2 :
			3
			0
			2

		#include <bits/stdc++.h> 
		int makeLucky(string s, int n){
			int i=0,cnt=0;
			while(i<s.length()-1){
				if(s[i] == s[i+1])
					if(s[i+1] == s[i+2])
						cnt++;
				i++;
			}
			return cnt;
		}

	28) Minimize Bill:
		Sample Input 1 :
			2
			5
			-2 0 5 2 -1
			4
			5 8 7 9
			Sample Output 1 :
			-6
			11
			Explanation For Sample Input 1 :
			For test case 1:
			The optimal way is to make change at A[2]. Minimum sum of array (after change) becomes -2+0+(-5)+2-1 = -6.

			For test case 2:
			Make change at A[3]. Minimum sum becomes 5+8+7+(-9) = 11.
			Sample Input 2 :
			3
			4
			3 -1 0 2
			2
			0 -1
			5
			5 5 5 5 5
			Sample Output 2 :
			-2
			-1
			15

		#include <bits/stdc++.h> 
		long long totalBill(int n, vector<int>& a){
			int mxValInd=0;

			for(int i=0;i<a.size();i++)
				if(a[mxValInd] < a[i])
					mxValInd = i;
			
			a[mxValInd] = -1 * (a[mxValInd]);

			int sum=0;
			for(int i=0;i<a.size(); i++)
				sum += a[i];
			return sum;
		}

	29) Encode The String:
		Sample Input 1 :
			2
			3
			dog
			4
			cazz
			Sample Output 1 :
			cpf
			bbyy
			Explanation Of Sample Input 1 :
			For the first test case :

			Character ‘d’ gets changed to ‘c’.
			Character ‘o’ gets changed to ‘p’.
			Character ‘g’ gets changed to ‘f’.

			Encoded string = “cpf”.


			For the second test case :

			Character ‘c’ gets changed to ‘b’.
			Character ‘a’ gets changed to ‘b’.
			Character ‘z’ gets changed to ‘y’.
			Sample Input 2 :
			2
			4
			gjmf
			3
			abc
			Sample Output 2 :
			file
			bab

		#include <bits/stdc++.h> 
		string encodeString(string &s, int n) {
			for(int i=0;i<s.length();i++){
				if(s[i] == 'a'){
					s[i] = 'b';
				}else if(s[i] == 'e'){
					s[i] = 'f';
				}else if(s[i] == 'i'){
					s[i] = 'j';
				}else if(s[i] == 'o'){
					s[i] = 'p';
				}else if(s[i] == 'u'){
					s[i] = 'v';
				}else{
					s[i] = s[i] - 1;
				}     
			}
			return s;
		}

	30) Next Greater Element
		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			for(int i=0;i<n;i++){
				if(i == (n-1)){
					arr[i] = -1;
					return arr;
				}
				int j=i+1;
				for(j; j<n;j++){
					if(arr[i] < arr[j]){
						arr[i] = arr[j];
						break;
					}
				}
				if(j==n)
					arr[i] = -1;
			}
		}
		
		//optimized
		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			vector<int> res(n, -1);
			stack<int> st;

			for(int i=0;i<n;i++){
				while(!st.empty() && arr[i] > arr[st.top()]){
					res[st.top()] = arr[i];
					st.pop();
				}
				st.push(i);
			}
			return res;
		}

	31) Implement Deque:
		-https://www.codingninjas.com/studio/problems/deque_1170059
		#include <bits/stdc++.h>
		#include<queue>
		using namespace std;
		class Deque
		{
			public:
				// Initialize your data structure.
				int size;
				deque<int> d;
				Deque(int n){
					// Write your code here.
					size = n;
				}

				// Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushFront(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_front(x);
						return true;
					}
					return false;
				}

				// Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushRear(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_back(x);
						return true;
					}
					return false;
				}

				// Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popFront(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.front();
						d.pop_front();
						return temp;
					}
					return -1;
				}

				// Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popRear(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.back();
						d.pop_back();
						return temp;
					}
					return -1;
				}

				// Returns the first element of the deque. If the deque is empty, it returns -1.
				int getFront(){
					// Write your code here.
					if(!d.empty()){
						return d.front();
					}
					return -1;
				}

				// Returns the last element of the deque. If the deque is empty, it returns -1.
				int getRear(){
					// Write your code here.
					if(!d.empty()){
						return d.back();
					}
					return -1;
				}

				// Returns true if the deque is empty. Otherwise returns false.
				bool isEmpty(){
					// Write your code here.
					if(d.empty())
						return true;
					
					return false;
				}

				// Returns true if the deque is full. Otherwise returns false.
				bool isFull(){
					// Write your code here.
					if(d.size() == size)
						return true;
					return false;
				}
		};
	
	32) Direction Game:
		Ninja is currently facing North. An instructor gives him 'N' instructions in the
		form of a binary string 'S'. If 'S[ i ]' is '0', then Ninja will turn clockwise by ‘90’
		degrees. Otherwise, Ninja will turn counterclockwise by ‘90’ degrees.
		Ninja is lazy and doesn't feel like doing all 'N' instructions. So, he decides to just face
		the final direction. Find the final direction of Ninja, which will be one of the
		following: 'NORTH', 'SOUTH', 'EAST', or 'WEST
		Sample Input 1:
			2
			4
			1111
			4
			1101
			Sample Output 1:
			NORTH
			SOUTH
			Explanation Of Sample Input 1:
			For test case 1:
			Ninja’s direction will change in the following order:
			North → West → South  → East → Noth
			So, the answer is 'NORTH'.

			For test case 2:
			Ninja’s direction will change in the following order:
			North → West → South → West → South
			So, the answer is 'SOUTH'.
			Sample Input 2:
			2
			8
			10011101
			7
			0101011
			Sample Output 2:
			SOUTH
			WEST

		string directionGame(int n, string &s){
			vector<string> dire = {"NORTH","WEST","SOUTH","EAST"};
			int index=0;
			for(int i=0;i<n;i++){
				if(s[i] == '1')
					index = (index+1)%4;
				else
					index = (index+3)%4;
			}
			return dire[index];
		}

	33) Apple Harvest:
		Sample Input 1:
			2
			20 15 5
			7 4 6
			Sample Output 1 :
			25
			18
			Explanation For Sample Input 1:
			For test case 1:
			The tree produces 20 apples daily. The basket can hold up to 15 apples. So, every day 5 apples are wasted. Over 5 days, 25 apples are wasted.

			For test case 2:
			The tree produces 7 apples daily. The basket can hold up to 4 apples. So, every day 3 apples are wasted. Over 6 days, 18 apples are wasted.
			Sample Input 2:
			2
			50 25 10
			12 5 7
			Sample Output 2 :
			250
			49

		long long wastedApples(int n, int m, int x) {
			return static_cast<long long>(max(0,(n-m)))*x;
		}

	34) Ninja wants Holiday:
		Ninja is a corporate employee, and like
			other corporate employees, he also wants
			to visit his home on long holidays. He
			wants to spend at least 'K' consecutive
			days at his home.
			You are given an array 'A' of length 'N'
			denoting the list of holidays. Ninja can
			only take leave on holidays.
			You have to find if it's possible for Ninja to
			spend at least 'K' consecutive days at his
			home.
			Example:
			'N' = 4
			'K' = 3
			'A' = [1, 3, 4, 5]
			Ninja can take leave on '1',
			'3', '4', and '5'. Therefore,
			he can take leave consecutively
			for at most 3 days, which are
			from '3' to '5'.
			Thus, minimum requirement of 'K= 3' is satisfied in this case. Hence, the final output will be 'YES'.

		Sample Input 1:
			2
			5 3
			1 3 7 5 8
			4 2
			2 4 8 3
			Sample Output 1:
			NO
			YES
			Explanation Of Sample Input 1:
			For test case 1:
			Holidays cannot be taken for three days in a row.
			Hence, the answer for this case is "NO".

			For test case 2:
			Ninja can take holidays on days '2' and '3', thus satisfying requirement of holiday on two consecutive days.
			Hence, the answer for this case is "YES".
			Sample Input 2:
			2
			5 3
			2 3 5 8 7
			4 2
			4 5 2 3
			Sample Output 2:
			NO
			YES


		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;

		string ninjaWantsHoliday(int n, int k, vector<int> &a) {
			sort(a.begin(), a.end());
			int cnt=1;
			for(int i=0;i<n; i++){      //1 4 5 8 10
				if(a[i]+1 == a[i+1]){
					cnt++;
					if(cnt == k)
						return "YES";
				}else{
					cnt=1;
					continue;
				}
			}
			return "NO";
		}
		int main(){
			int n=5, k=2;

			vector<int>a {5, 10, 1 ,8, 4};
			string s = ninjaWantsHoliday(n,k,a);
			std::cout << s << std::endl;
			return 0;
		}

	35) Vaccination Drive:
			The Indian government recently launched the world's largest vaccination drive for
			COVID-19. Dr Ritesh has been appointed as a nodal officer for vaccinating a
			locality. There are ‘N’ houses numbers from 1 to ‘N’ in that locality. Dr Ritesh will
			visit each house one by one and vaccinate all the people in the house. He
			has already covered ‘K’ number of houses. Since ‘N’ is a very large number,
			‘L’ bits are required to represent the number. You are supposed to help Dr
			Ritesh and find the maximum possible number of houses that are yet to be
			covered under the vaccination drive
			(Hint 2's power)
		Sample Input 1 :
			2
			3 5
			5 3
			Sample output 1 :
			29
			3
			Explanation of Sample output 1 :
			For the first test case, since the number of bits required is 5, the maximum possible value for ‘N’ is 32. So the maximum possible number of remaining houses are 32 - 3 = 29.

			For the second test case, since the number of bits required is 3, the maximum possible value for ‘N’ is 8. So the maximum possible number of remaining houses are 8 - 3 = 5.
			Sample Input 2 :
			2
			1 1
			2 3
			Sample output 2 :
			1
			6
		#include <bits/stdc++.h> 
		int getMaximumHouses(int k, int l){
			return (pow(2,l))-k;
		}

	36) Factorial of Larger nums:
		void multiply(vector<int> &result, int x) {
			int carry = 0;
			for (int i = 0; i < result.size(); i++) {
				int product = result[i] * x + carry;
				result[i] = product % 10;
				carry = product / 10;
			}
			
			while (carry) {
				result.push_back(carry % 10);
				carry /= 10;
			}
		}

		void factorial(int n){
			vector<int> result;
			result.push_back(1); // Initialize the result as 1
			
			for (int i = 2; i <= n; i++) {
				multiply(result, i);
			}
			
			// Print the result in reverse order
			for (int i = result.size() - 1; i >= 0; i--) {
				cout << result[i];
			}
			cout << endl;   
		}

	37) Print all Divisors of a number
		Given an integer 'N', return all the divisors of 'N' in ascending order.
		For Example:
		'N' = 5.
		The divisors of 5 are 1, 5.
		Sample Input 1 :
			10
			Sample Output 1 :
			1 2 5 10
			Explanation Of Sample Input 1:
			The divisors of 10 are 1,2,5,10.
			Sample Input 1 :
			6
			Sample Output 1 :
			1 2 3 6

		vector<int> printDivisors(int n) {
			vector<int> ans;
			for(int i=1;i<=n/2;i++)
				if(n % i == 0)
					ans.push_back(i);

			ans.push_back(n);
			return ans;
		}
	
	38) Rotate array
		Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative
		'arr '= [1,2,3,4,5]
			'k' = 1 rotated array = [2,3,4,5,1] 
			'k' = 2 rotated array = [3,4,5,1,2]
			'k' = 3 rotated array = [4,5,1,2,3] and so on.

		Sample Input 1:
			8
			7 5 2 11 2 43 1 1
			2
			Sample Output 1:
			2 11 2 43 1 1 7 5
			Explanation Of Sample Input 1:
			Rotate 1 steps to the left: 5 2 11 2 43 1 1 7
			Rotate 2 steps to the left: 2 11 2 43 1 1 7 5
			Sample Input 2:
			4
			5 6 7 8
			3
			Sample Output 2:
			8 5 6 7
			Explanation Of Sample Input 2:
			Rotate 1 steps to the left: 6 7 8 5
			Rotate 2 steps to the left: 7 8 5 6
			Rotate 2 steps to the left: 8 5 6 7

		vector<int> rotateArray(vector<int>arr, int k) {
			vector<int> ans;
			for(int i=k;i<arr.size();i++)
				ans.push_back(arr[i]);
			
			for(int i=0;i<k;i++)
				ans.push_back(arr[i]);
			
			return ans;
		}

	39) Generate Binary Numbers:
		Sample Input 1:
			2
			2
			6
			Sample Output 1:
			1 10
			1 10 11 100 101 110
			Explanation 1:
			For the first test case when N = 2. 
			We need all the binary numbers from 1 to 2:
			1 -> 1
			2 -> 10
			Thus, the output is 1, 10.

			For the second test case when N = 6
			We need all the binary numbers from 1 to 6:
			1 -> 1
			2 -> 10
			3 -> 11
			4 -> 100
			5 -> 101
			6 -> 110
			Thus, the output is 1, 10, 11, 100, 101, 110.
			Sample Input 2:
			2
			8
			4
			Sample Output 2:
			1 10 11 100 101 110 111 1000
			1 10 11 100

		#include <bits/stdc++.h>
		string binConvert(int); 
		vector<string> generateBinaryNumbers(int n){
			vector<string> ans;
			for(int i=1;i<=n;i++){
				string s = binConvert(i);
				ans.push_back(s);
			}
			return ans;
		}

		string binConvert(int n){
			string temp;
			while(n>0){
				int t = n % 2;
				temp += to_string(t);
				n/=2;
			}
			reverse(temp.begin(), temp.end());
			return temp;
		}

	40) Sum Of Zeroes
		#include <bits/stdc++.h> 
		int coverageOfMatrix(vector<vector<int>> &matrix) {
		int rows = matrix.size();
		int cols = matrix[0].size();
		int coverage = 0;

		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				if (matrix[i][j] == 0) {
					int adjacent = 0;

					// Check top neighbor
					if (i > 0 && matrix[i - 1][j] == 1) {
						adjacent += 1;
					}

					// Check bottom neighbor
					if (i < rows - 1 && matrix[i + 1][j] == 1) {
						adjacent += 1;
					}

					// Check left neighbor
					if (j > 0 && matrix[i][j - 1] == 1) {
						adjacent += 1;
					}

					// Check right neighbor
					if (j < cols - 1 && matrix[i][j + 1] == 1) {
						adjacent += 1;
					}

					coverage += adjacent;
				}
			}
		}
		return coverage;
		}

	41) Add One To Number
		Sample Input 1
			3
			3
			1 2 3
			2
			9 9
			1
			4
			Sample Output 1
			1 2 4
			1 0 0
			5
			Explanation For Sample Input 1
			In the 1st test case, the number is 123 after adding 1 number becomes 124, hence the output will be {1,2,4}.

			In the 2nd test case, the number is 99 after adding 1 number becomes 100, hence the output will be {1,0,0}.

			In the 3rd test case, the number is 4 after adding 1 number becomes 5, hence the output will be {5}.
			Sample Input 2
			3
			4
			2 4 6 8 
			1
			0
			2
			0 2
			Sample Output 2
			2 4 6 9
			1
			3

		#include <bits/stdc++.h> 
		vector<int> addOneToNumber(vector<int> arr){
			int n = arr.size();
			
			// Add 1 to the least significant digit (rightmost)
			arr[n - 1] += 1;
			
			// Handle carry
			int carry = 0;
			for (int i = n - 1; i >= 0; i--) {
				int sum = arr[i] + carry;
				arr[i] = sum % 10;  // Update the current digit
				carry = sum / 10;   // Calculate the carry for the next digit
			}
			
			// If there is still a carry after processing all digits, insert it at the beginning
			if (carry > 0) {
				arr.insert(arr.begin(), carry);
			}
			//removing leadig zeros
			while(!arr.empty() && arr[0]==0){
				arr.erase(arr.begin());
			}
			return arr;
		}

	42) 
	
---------------------------------------------------------------------------------------------------------
	#include <iostream>
	#include <algorithm>
	using namespace std;
	int main(){
		string s = "Hello World";
		
		std::cout << s << std::endl;

		std::cout << char(tolower('A')) << std::endl;
		
		//string upper to lower case
		transform(s.begin(), s.end(), s.begin(), ::tolower);
		// transform(s2.begin(), s2.end(), s2.begin(), ::tolower);

		std::cout << s << std::endl;
		
		transform(s.begin(), s.end(), s.begin(), ::toupper);
		
		std::cout << s << std::endl;
		
		return 0;
	}

	#include <iostream>
	#include <algorithm>
	using namespace std;

	int main(){
		string s1 = "VIVEK", s2="nikate", s3 = "third", s4 = "this is first letter capital sentence.";
		
		transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
		std::cout << s1 << std::endl;
		
		transform(s2.begin(), s2.end(), s2.begin(), ::toupper);
		std::cout << s2 << std::endl;
		
		s3[0] = toupper(s3[0]);
		std::cout << s3 << std::endl;
		
		int i=0;
		while(s4[i] != '\0'){
			if(i==0) s4[i] = toupper(s4[i]);
			if(isblank(s4[i])) s4[i+1] = toupper(s4[i+1]);
			i++;
		}
		
		std::cout << s4 << std::endl;	
		return 0;
	}


	Char Array:

		#include <iostream>

		int main(){
			char str[] = "sadf";
			std::cout << str[0] << std::endl;
			std::cout << str << std::endl;
			return 0;
		}
---------------------------------------------------------------------------------------------------------
calender:
	today 2nd sept 2023 (saturday)
	what is day on 30th may 2023?
	->
		how many days between dates = may +june + july +august+ sept
						 1 + 30d + 31d + 31d + 2  = 95
						 =95/7 -> 4 remainder,
						 4 days back from today (fri, thurs, wed, tuesday)
						 => Tuesday is on 30th of may.
---------------------------------------------------------------------------------------------------------	