-When you start reading/ revising notes, read problem statement properly & think logical,
 if you don't understand the program, prefer try to resolve the problem by yourself.
-Google it if you don't understand the question.
	01/08/2023
Lecture-1
     -Understand the problem
     -check given data
     -search approach (make flowchart)
     -start programming

     -Flowchart:
          Diagrammatic representation of an approach
          Components:
               1.Terminator: start/end
               2.Parallelogram block   : represent IO/OP 
               3.Rectangular block: represent process
               4.Diamond: decision making (condition)
          e.g., Sum of 2 num:
	-Pseudocode:	Generic way of representing look of code.
	-Flowchart for Simple Interest
		SI = (P*R*T)/100
		eg.
			Calculate Simple Interest
				#include <bits/stdc++.h> 
				#include <iostream>
				using namespace std;

				int main(){
					float pr,time, RI;
					cin>>pr>>RI>>time;
					float ans;
					ans =(int) (pr*time*RI)/100;
					cout<<ans;
					return 0;
				}

	-Two colons (::) are used in C++ as a scope resolution operator

	-Flowchart for average of 3 num
		avg = (a+b+c)/3;

	-Greater between 2 num:
		a>b? print(a greater) : print(b greater);

		//Largest of 3 numbers
			#include <bits/stdc++.h> 
			#include <iostream>
			using namespace std;

			int main() {
				int a,b,c;
				cin>>a>>b>>c;
				cout<<max(a,max(b,c));
				return 0;
			}

	-Odd or even num:
		(num %2 ==0) ? print(even):print(odd)

	-num is +ve or -ve or zero?
		If(num >0) print(+ve)
		else if (num<0) print(-ve)
		else print(zero)
		
	-Valid triangle or not?
		Angles A, B & C
		A+B > C
		B+C > A
		C+A > B

	-Loops:
		-Print 1 to 5 nums.

		-print even nums from given range (copy paste program directly on compiler to check)

			#include <iostream>
			using namespace std;
			int main() {
				// Write C++ code here
				cout << "Range..!"<<"\n";
				int s=1,e=10,i;
				for(i=s; i<=e; i++){	
					cout<<i<<"\t";
				}
				cout<<"\neven nums.."<<"\n";
				for(i=s;i<e;i++){
					if(i%2==0){
						cout<<i<<endl;
					}else{
						continue;
					}
				}
				cout<<"\nend";
				return 0;
			}

		-Sum of 1 to N nums:
			#include <iostream>
			using namespace std;

			int main() {
				// Write C++ code here
				cout<<"Enter n::";
				int n;
				cin>>n;
				int sum = 0;
				
				// sum = n*(n+1)/2;
				//or
				for(int i=1;i<=n;i++){
					sum = sum +i;
				}
				cout<<"The sum of first "<<n<<" numbers ::"<<sum;
				cout<<"\nend";

				return 0;
			}

		-Factorial:
			#include <iostream>			//using namespace std not used here.
			int main() {
				std::cout<<"Enter n::";
				int n,fact=1;
				std::cin>>n;
				
				for(int i=1;i<=n;i++){
					fact = fact * i;
				}
				std::cout<<"The factorial of "<<n<<" is ::"<<fact;
				std::cout<<"\nend";

				return 0;
			}

				//or
					#include <iostream>
					using namespace std;

					int main() {
						int n;
						cin>>n;
						int fact=1;
						if (n == 0) {
							cout << 1;
							return 0;
						}else if (n<0){
							cout<<"Error";
							return 0;
						}else{
							while(n>0){
								fact = fact * n;
								n--;
							}
						}

						cout<<fact;
						return 0;
					}

		-Prime num:
			#include <iostream>
			int main() {
				// Write C++ code here
				std::cout<<"Enter n to check prime or not::";
				int n;
				std::cin>>n;
				bool flag = true;
				
				if(n == 1){
					std::cout<<"1 is neither prime nor composite";
					return 0;
				}
				
				for(int i=2;i<n;i++){
					if(n % i ==0){
						flag = false;
						break;
					}else{
						flag = true;
					}
				}
				
				if(flag){
					std::cout<<n<<" is Prime num.";
				}else{
					std::cout<<n<<" is not Prime num.";
				}
				
				std::cout<<"\nend";
				return 0;
			}
		
	-Compiler: convert High Level Language to Binary Language (machine understandable)
---------------------------------------------------------------------------------------------------------
	02/08/2023
Lecture-2:
	Compiler:
		-convert program to machine understandable Language ( Binary ).
		-checks the error & let you know.
	
	IDE: Integrated Development Environment
	
	-Program always start from main function.
	eg.
		#include <iostream>
		int main() {
			std::cout << "Hello world!"<<endl;
			return 0;
		}

		//if you used this statement no need to mention std in program
		using namespace std;
		#include <iostream>
		int main() {
			cout << "Hello world!";
			return 0;
		}

		where,
			std 			- is a namespace.
			cout 		- is function for printing
			<< 			- is outputing a output.
			endl  or '\n' 	- end line/ new line.
			; 			- represent end line.
		
	
	-Datatype & Variables:
		1 Byte is 8 bit.
		4bit is 1 nibble.
		int-
			size is 4 byte(32bit) generally (sometimes 2 bytes also, depends on compiler).
			Stores whole numbers, without decimals
			eg.
				int a = 20;

			min size -2³¹
			max size 2³¹-1
		
		char-
			size is 1 byte
			Stores a single character/letter/number, or ASCII values
			eg.
				char ch = 'a';		//valid

				char ch = 'ab';	//invalid
			
			Alternatively, you can use ASCII values to display certain characters:
			eg.
				char a = 65, b = 66, c = 67;
				cout << a;		//A
				cout << b;		//B
				cout << c;		//C

			-ASCII values:	ASCII - 'American Standard Code for Information Interchange'
				32 		is value of space.
				48 to 57 	is for 	0 to 9.
				65 to 90 	is for 	A to Z.
				97 to 122 is for 	a to z.

		boolean-
			1 byte	
			Stores true or false values
			you can keep any value for this boolean if it is non-zero(+ve) or -ve  then its considered as true (1).
				if it is zero then its considered as false(0).
			eg.
				bool a = true;

				bool b = 1,c =true, d = false;
				cout <<b<<endl;         //1
				cout <<c<<endl;         //1
				cout <<d<<endl;         //0
	
		float-
			4 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 6-7 decimal digits.
			eg.
				float f1 = 35e3;
				double d1 = 12E4;
				float ff = 35.453f;				//f to represent its is a floating point num.
				double dd = 12.78909d;			//d to represent its is a double
				cout << f1 << "\n";				// 35000
				cout << d1;					// 120000
		
		double-
			8 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits.
		
		NOTE:
			float vs. double
			The precision of a floating point value indicates how many digits the value can have after the decimal point. 
			The precision of float is only six or seven decimal digits, while double variables have a precision of about 15 digits. 
			Therefore it is safer to use double for most calculations.
		
		string-
			32 byte.
			string type is used to store a sequence of characters (text).
			This is not a built-in type, but it behaves like one in its most basic usage. 
			String values must be surrounded by double quotes:
			eg.
				#include <string>				//including this header file is not mandatory.
				string str  = "Vivek";
				cout << str;
			
		Variable Naming Convention:
			int abc1 = 1;			//valid
			int _abc = 21;			//valid
			int 1abc = -10; 		//invalid because the first character letter/underscore not number

		sizeof:
			eg.
				#include <iostream>

				int main() {
					bool c  = -12;
					int i   = 10;
					char ch = 'A';
					float f =  11.12; 
					double d   = 12.1245d;
					std::string str = "Vivek ";
					
					std::cout<<"The size of "<<c<<" Boolean :: "<<sizeof(c)<<" Byte\n";
					std::cout<<"The size of "<<i<<" integer :: "<<sizeof(i)<<" Byte\n";
					std::cout<<"The size of "<<ch<<" char :: "<<sizeof(ch)<<" Byte\n";
					std::cout<<"The size of "<<f<<" float :: "<<sizeof(f)<<" Byte\n";
					std::cout<<"The size of "<<d<<" double :: "<<sizeof(d)<<" Byte\n";
					std::cout<<"The size of "<<str<<" string :: "<<sizeof(str)<<" Byte\n";
					
					return 0;
				}

				//output
					The size of 1 Boolean :: 1 Byte
					The size of 10 integer :: 4 Byte
					The size of A char :: 1 Byte
					The size of 11.12 float :: 4 Byte
					The size of 12.1245 double :: 8 Byte
					The size of Vivek  string :: 32 Byte

		storing process:
			int is 4 bytes ie. 32 bits.
				4 blocks of bits are made
				eg.
					[-------- -------- -------- --------] this how integer converted to binary & store data in bits format.

		TypeCasting:
			when you assign a value of one primitive data type to another type.
			eg.
				int a = 'a';
				cout<<a;

				char ch = 98;
				cout<<ch;

				-int is 4 byte & char is 1 byte, if we try to store big integer to char
				 warning will be thrown & last 1 byte of data will be store in char.
				 eg.
				 	char ch = 123456		//binary of 123456 = 11110001001000000
					cout<< ch;			//@

					but char is of size 1 byte ie. 8 bits, so last 8 bit of binary 123456 will extracted ie.01000000 
						& rest all bits will be lost
					& if we print the ch then output will be @.
					coz this binary 01000000 is 64 in decimal.
					& 64 is mapped with @ char.
			
			eg.
				include <iostream>

				int main() {
					float f = 45.99f;
					int b = f;
					
					float f1 = b;
					
					std::string str = "1234";
					// int a = int(str);       // this won't work
					int a = stoi(str);       //to convert string to int
					
					std::cout<<a<<std::endl;		//1234
					std::cout<<a+6<<std::endl;	//1240
					
					std::cout<<f<<"\n";		//45.99
					std::cout<<b+2<<"\n";	//47
					std::cout<<f1<<"\n";	//45
					
					return 0;
				}

				#include <iostream>
				int main() {
					std::string str = "450";
					int a;
					std::cout<<str<<std::endl;
					std::cout<<a<<std::endl;
					std::cout<<stoi(str)+10;			string to integer stoi().
					return 0;
				}

		How -ve num stored:
			if first bit is 1, then num is -ve.
			if first bit is 0, then num is +ve.
			eg.
				want to store -8.
				step 1:	
					ignore negative sing(-ve)
					8
				step 2:
					convert 8 to binary format
					1000
					stored as
						[-------- -------- -------- ----1000] rest all are zero only like below,
						[00000000 00000000 00000000 00001000]

				step 3:
					-Take 2's (two's) complement & store.
					 for taking 2's complement first take 1's complement
					 
					 step 1: 
					 	1's complement change 0 to 1 & viceversa.
						[11111111 11111111 11111111 11110111]

					 step 2:
					 	add 1 in 1's complement.
						[11111111 11111111 11111111 11110111]
						+							1
						______________________________________
						[11111111 11111111 11111111 11111000]		
							--here in the answer first bit is 1, so it denotes its -ve num.
							--this is 2s complement of 8
				
				step 4:
					-To print that -ve num then take 2's complement of above output:
						[11111111 11111111 11111111 11111000]		
					
					-1's complement
						[00000000 00000000 00000000 00000111]
						+							1
						_____________________________________
						[00000000 00000000 00000000 00001000]
					
					now print above as its 8, but -ve.

		For +ve num only:
			unsigned int a = 122;
			range:
				0 to 2³²-1;

			if you try to store -ve num then it will generate huge num becoz 
			of most significant bit (first bit) is 1 to represent it is a -ve but,
			you said its +ve by mentioning usigned so compiler treat it as positive & generates huge num.
		
		Operator:
			Unary:
				increment (++)
				decrement (--)
				eg.
					postIncrement/postDecrement means the value will get incremented or decremented after using.
					old value gets used then value gets updated
						a++;		//postIncrement
						a--;		//postDecrement
					
					
					preIncrement/ preDecrement means the value will get incremented or decremented before using.
					value gets incresed or decresed first then it will gets used.
						++a;		//pretIncrement
						--a;		//pretDecrement
					
			Arithmetic:-
				+,-,*,/,%

				int/ int  = int		//if we divide int by int the answer will be integer
				float / int = float		//if we divide float by int the answer will be floating point num.
				double / int = double		//if we divide double by int the answer will be double.

				eg.
					#include <iostream>
					#include<cmath>
					using namespace std;
					int main(){
						int n=60, sum =101;
						
						double d = sum/(double)n;			//getting value in double.		
						std::cout << d << std::endl;					//1.68333
						std::cout << round(d) << std::endl;			//2
						
						return 0;
					}


			Relational:- 
				To Check
				== is equal to equal to (double equals to)
				< is less than
				> is greater than
				<= is less than equal to
				>= is greater than equal to
				!= is not equal to
			
			Assignment operator:
				=, +=, *=, -=, /=, %= etc
				eg.
					a = 10;
					a = a + 10;		-->		a += 10;
					a = a * 10;		-->		a *= 10;
					a = a - 10;		-->		a -= 10;
					a = a / 10;		-->		a /= 10;
					a = a % 10;		-->		a %= 10;

			Logical:-
				&& AND operation takes two boolean values and returns True if both are True else False.
				|| OR any one conditions should true for that statement to execute.
				! NOT reverse value.
				eg.
					ignores the sign.
					int a = 0;
						std::cout << !a;		//1
					int b = 1;
						std::cout << !b;		//0
					int c = 10;
						std::cout << !c;		//0
					int d = -10;
						std::cout << !d;		//0
					int e = -0;
						std::cout << !e;		//1

			Ternary Operator:
				syntax:
					(condition) ? ([if true execute this]) : ([if false execute this])
				eg.
					#include <iostream>
					using namespace std;

					int main() {
						int a = 100;
						
						//ternary operator
						(a>20) ? cout<< a << " Greater Than 20" : cout<< a << "Less than 20";

						return 0;
					}
				
				-for single statement don't use ( ) in ternary operator direct mention your statement.
				-for multiple statement to print or do operation use ( ).
				eg.
					printing twice,
						#include <iostream>
						using namespace std;

						int main()
						{
							int n =91;
							(n % 2 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or above there is just one condition so no need to use braces near condition also, like
							n % 2 == 0 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//if more than one condition is there in ternary operator, use braces ( ), for best practices
							//if you don't use still it works

							//first even condition is true but 2nd 400 is not less than 50, its false 
							//but && requires both condition must be true so complete equation is false,
							//ouput odd world.
							n =400;
							(n % 2==0 && n< 50 == 1) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							

							//ouput for below is even n<50 which is false means 0, & 0 == 0 so n= 400 is even & 0 == 0 both condition are true so even world will printed.
							(n % 2==0 && n< 50 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or even world will run
							//first condition is true, 2nd is false
							n=400;
							(n % 2==0 || n< 50) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
  
							//without braces
							//works fine and (,) comma is behaves like && operator,
							n % 2==0 && n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							n % 2==0 , n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							return 0;
						}

					initializing int inside ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							//syntax to initialize,
							(condition)? ([] {//initialization,//statement, //code})(): ([] {//initialization,//statement, //code})()

							//integer initialized
							n % 2 == 0 && n < 50 ? ([]{ int v = 80; cout << "Hello Even World " << v << " Hello 2nd World "; })() : ([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							//string initialized
							n%2 ? ([]{ string v = "Vivek"; cout << "Hello Even World " << v << " Hello 2nd World ";})() :([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							return 0;
						}

					ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							n % 2 == 0 && n < 50 ? ([]{
								int v = 80;
								string evenMessage = "Hello Even World " + to_string(v);
								string secondMessage = "Hello 2nd World";
								cout << evenMessage << " " << secondMessage;
							})() : ([]{
								string oddMessage = "Hello Odd World";
								string thirdMessage = "Hello 3rd World";
								cout << oddMessage << " " << thirdMessage;
							})();

							return 0;
						}

					string ternary:
						#include <iostream>
						using namespace std;

						int main()
						{
							string finalgrade = []() {
								int grade = 100;
								return (grade < 60) ? "fail" : "pass";
							}();

							std::cout << finalgrade << std::endl;

							return 0;
						}

			Bitwise:-
				& and
				| or
				^ xor
				~ complement of bits in binary representation
				<< left shift
				>> right shift
			
			//Converting num to string & counting digit in it.
				#include <iostream>
				using namespace std;
				int main(){
					int i=1234,j=12,k=9686854;
					cout<<"no.of digit in i: "<<(to_string(i).length())<<endl;            //4
					cout<<"no.of digit in j: "<<to_string(j).size()<<endl;                //2
					cout<<"no.of digit in k: "<<to_string(k).size()<<endl;                //7
					
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-3:
	Conditionals, Loops, Patterns
	1) if Statement
		if(condition){
			//code block executed when condition evaluates as TRUE
		}

	2) if-else Statement
		if(condition){ 
			//This code block will be executed only if 'condition' is evaluated as TRUE
		}
		else{   
			//this block gets executed when if block evaluates to FALSE
		}
		
	3) else-if Statement
		if (cond_A) { 
			//first conditional expression
			/* statements */
		}
		else if (cond_B) {
			//second condtional expression
			/* other statements*/
		}
		else if (cond_C) {
			//third condtional expression
			/* other statements*/
		}
		else {
			/* last statement for default case */
		}
		//else is last default block not mandatory to write.
	
	4) Nested If statements / Nested If-else:
		if-statement inside another if statement

		if(cond){
			//if true
		}else{
			if(nestedCond){ 
				// nested condition code here
			} else{

			}
		}
	
	5) Switch Case Statement
			Why we use switch case instead of if-else?
				Editing in switch statement is easier as compared to the 'if-else' statement. 
				If we remove any of the cases from the switch, then it will not interrupt the execution of other cases. 
				Therefore, we can say that the switch statement is easy to modify and maintain.

				-If we have multiple choices then the
				switch statement is the best option as
				the speed of the execution will be much
				higher than 'if-else'

				-Break keyword:
					The break in C++ is a loop control statement that is used to terminate the loop. 
					As soon as the break statement is encountered from within a loop, 
					the loop iterations stop there and control returns from the loop immediately to the first statement after the loop.
				
				-Continue:
					C++ continue statement is a loop control statement that forces the 
					program control to execute the next iteration of the loop. As a result, 
					the code inside the loop following the continue statement will be 
					skipped and the next iteration of the loop will begin.

			eg.
				#include <iostream>
				using namespace std;

				int main() {
					char oper;
					float num1, num2;
					cout << "Enter an operator (+, -, *, /): ";
					cin >> oper;
					cout << "Enter two numbers: " << endl;
					cin >> num1 >> num2;

					switch (oper) {
						case '+':
							cout << num1 << " + " << num2 << " = " << num1 + num2;
							break;
						case '-':
							cout << num1 << " - " << num2 << " = " << num1 - num2;
							break;
						case '*':
							cout << num1 << " * " << num2 << " = " << num1 * num2;
							break;
						case '/':
							cout << num1 << " / " << num2 << " = " << num1 / num2;
							break;
						default:
							// operator is doesn't match any case constant (+, -, *, /)
							cout << "Error! The operator is not correct";
							break;
					}
					return 0;
				}
			


	6) While Loop:
		while loop require just a num inside as condition it may be -ve or +ve, it will work, 
		except the 0, if zero cames then loop breaks.
		eg.
			while(1)		//works
			while(100)	//works
			while(-23)	//works
			while(5)		//works

			while(0)		//stops this will breaks the loop.
			eg.
				#include <iostream>
				using namespace std;

				int main()
				{
					int i=1, b=-5;
					while(b++){
						std::cout << "say hii" << i++ << std::endl;
						//b++;
					}
					return 0;
				}

	 eg
	 	//WAP TO PRINT THE N NUMS:
			#include <iostream>
			using namespace std;

			int main() {
				int i=1;
				// while(i<11)
				//     cout << i++ <<"\t";
				//or
				
				while(i<11){
					cout << i << end;
					i++;                //i = i + 1
				}
				return 0;
			}

			#include <iostream>
			using namespace std;

			int main() {
				int i=1,n;
				cout << "enter n :: ";
				cin>>n;
				while(i<=n)
					cout << i++ <<"\t";
				//or
				
				//while(i<=n){
				//	cout << i << "\t";
				//	i++;                //i = i + 1
				//}
				return 0;
			}

		//WAP sum of first n num
			#include <iostream>
			using namespace std;

			int main() {
				int n,i=1,sum=0;
				cout << "enter n:: ";
				cin>>n;

				//shorthand
				while(i<=n)
					sum += i++;
				
				// or
				// while(i<=n){
				//     sum = sum + i;       //sum = sum + i
				//     i++;            //i = i +1;
				// }

				cout<< "The sum of "<<n<<" is "<<sum;
				
				return 0;
			}

		//WAP sum of even num
			#include <iostream>
			using namespace std;

			int main() {
				// sum of even num
				int n,i=2;
				cout << "Enter n:: ";
				cin>>n;
				
				int sum =0;
				while(i<=n){
					if(i % 2 == 0)
						sum = sum + i;
					i++;
				}
				
				// or shorhand
				// while(i <= n){
				//     if(i % 2 == 0)
				//         sum += i;
				//     i++;
				// }
					
				cout << "Sum of even till "<< n << " is :: "<< sum;
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					int sum=0;
					int n;
					cin>>n;

					for(int i=2;i<=n;i+=2)
						sum +=i;
					cout<<sum;
					return 0;
				}							
			
		//WAP to check entered num is prime or not?
			#include <iostream>
			using namespace std;

			int main() {
				//WAP num is prime or not.
				int n,i=2,flag=0;
				cout << "enter num :: ";
				cin>>n;
				
				while(i <= n/2){
					if(n % i == 0){
						flag = 1;
						break;
					}
					i++;
				}
				
				if(flag)
					cout << n << " is not prime";
				else
					cout << n << " is Prime Num";
				
				return 0;
			}
		
		//WAP to print:
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			->
				#include <iostream>
				int main() {
					int i=1,j=1;
					while(i++ <6){              //shorthands
						while(j++ < 8){         //shorthands for increment
							std::cout << "* ";
							// j++              
						}
						j=1;
						// i++;     
						std::cout<<"\n";
					}
					return 0;
				}
		
		//WAP to take rows & column from user.
			#include <iostream>
			int main() {
				int i=1,j=1,n;
				
				std::cout<<"Enter rows column :: ";
				std::cin>>n;
				
				while(i++ <n){              //shorthands
					while(j++ < n){         //shorthands for increment
						std::cout << "* ";
						// j++              
					}
					j=1;
					// i++;     
					std::cout<<"\n";
				}

				return 0;
			}
		
		//WAP to print this Patterns with custom rows:
		 if rows are 5,
			1 1 1 1 1 
			2 2 2 2 2 
			3 3 3 3 3 
			4 4 4 4 4 
			5 5 5 5 5
		     ->
			#include <iostream>
			int main() {
			
				int z,p,rows;
				std::cout << "Enter num of rows you want :: ";
				std::cin >> rows;
				for(z=1; z<=rows; z++){
					for(p=1; p<=rows; p++)
						std::cout << z << " ";
					std::cout<<std::endl;
				}
				return 0;
			}
			//output:
				Enter num of rows you want :: 8
					1 1 1 1 1 1 1 1 
					2 2 2 2 2 2 2 2 
					3 3 3 3 3 3 3 3 
					4 4 4 4 4 4 4 4 
					5 5 5 5 5 5 5 5 
					6 6 6 6 6 6 6 6 
					7 7 7 7 7 7 7 7 
					8 8 8 8 8 8 8 8

	eg.
		1).WAP to check num is +ve, -ve or zero?
			#include <iostream>
			using namespace std;

			int main() {
				cout<<"Enter value for A::";
				int a;
				cin>>a;
				if(a>0){
					cout<<"A is +ve "<<a;
				}else if(a<0){
					cout<<"A is -ve "<<a;
				}else{
					cout<<"A is Zero "<<a;
				}
				return 0;
			}
			--here cin function takes the input, cin function don't read tabs, space & new line char.

		2).WAP for Greater num
			#include <iostream>
			using namespace std;

			int main() {
				cout << "Enter values of A & B::";
				int a,b;
				cin >> a >> b;						//taking input at same time.
				
				cout << "A :: " << a << " B :: " << b << endl;
				if(a>b)
					cout << "A is Greater than B";
				else if(b > a)
					cout << "B is Greater than A";
				else
					cout << "A is equals to B";
				return 0;
			}

			--if there is one statement in if block then no need to put the { } curly braces

		3). WAP to check char is lowercase or uppercase or digit?
			#include <iostream>
			using namespace std;

			int main() {
				char ch;
				cout<< "Enter char :: ";
				cin>>ch;
				
				if(ch >= 'a' && ch<='z')
					cout << "Char is Lowercase "<<ch;
				else if(ch >= 'A' && ch <= 'Z')
					cout << "Char is Uppercase "<<ch;
				else if(ch >= '0' && ch <= '9')
					cout << "Char is Digit "<<ch;
				else
					cout << "Char is something Strange "<<ch;
				return 0;
			}

		-to take space, new line as input use cin.get() function.
			int a= cin.get();
			cout<<"A :: "<<a;
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-4:
	if 'return 0' is not there at the end still program works.
	Patterns solving
	1)	1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){            			//shorthand checking as well as incrementing king as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementing
					while(b <= n){          			//for be also you can increment while checking
						cout << b++ << " ";         	//shorthand (printing as well as incrementing)
						// b++;
					}
					b=1;
					// a++; 
					cout<<"\n";
				}

				return 0;
			}

	2)
		n = 5
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
		->
			#include <iostream>
			using namespace std;		

			int main() {
			
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n) {          //shorthand
					while(b <= n){    
						cout << n - b +1<< " ";
						b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}

	3)
		1	2	3 	4	 5
		6	7 	8 	9	 10
		11	12 	13 	14	 15
		16 	17 	18	19	 20
		21 	22 	23	24	 25
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1,counter=1;

				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){          //shorthand
					while(b++ <= n){    //shorthand
						cout<<counter++<<"\t";
						// b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}
	
	4) Start pattern for custom rows:
		Enter rows:: 5
			* 
			* * 
			* * * 
			* * * * 
			* * * * * 
		->
			#include <iostream>
			using namespace std;

			int main() {
			
				int n,a=1,b=1;
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){      //shorthand 
						cout<< "* ";
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			}
	
	5)
		take rows from user:
		 Enter rows:: 5
			1 
			1 2 
			1 2 3 
			1 2 3 4 
			1 2 3 4 5 
		->
			#include <iostream>
			using namespace std;

			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b <= a){      
						cout<< b++ <<" ";     //shorthand 
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}
			return 0;
			}
	
	6)
		take rows from user:
		 Enter rows:: 5
			1 
			2 2 
			3 3 3
			4 4 4 4
			5 5 5 5 5
		 ->
		 	#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){            //shorthand
						cout<< a <<" ";     
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			} 

	7)
		Take rows input from user..
			Enter rows:5
				1	
				2	3	
				4	5	6	
				7	8	9	10	
				11	12	13	14	15	
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,counter=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){        //shorthand
						while(b++ <= a){                    //shorthand
							cout << counter++ << "\t";      //shorthand
							// counter++;
							// b++;
						}
						b=1;
						a++;
						cout << "\n";
					}
					
					
					return 0;
				}

	8)
		Take user input for rows
			Enter rows:5
			1	
			2	3	
			3	4	5	
			4	5	6	7	
			5	6	7	8	9
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,temp;
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					temp = a;						//need to try without using extra var.
					while(b <= a){
						cout << temp++ << "\t";
						b++;
					}
					cout << "\n";
					a++;
					b=1;      //important step
				}
				return 0;
			}

			//or without using temp.
			#include <iostream>
			using namespace std;
			int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << a + b - 1 << "\t";
							b++;
						}
						cout << "\n";
						a++;
						b=1;      //important step
					}
					return 0;
			}
	
	9)
		Take user input for rows
			Enter rows:5
			1
			2 1
			3 2 1
			4 3 2 1
			5 4 3 2 1
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,temp;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						temp = a;
						while(b <= a){
							cout << temp-- << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
			
			//or without using that extra temp variable

				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						// temp = a;
						while(b <= a){
							cout << a - b + 1 << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}

	10)
		Take user input for rows
			enter rows:3
				A A A
				B B B
				C C C
			->	
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a++ <= n){						//shorhand
						while(b++ <= n){					//shorhand
							cout << ch <<" ";
							//b++;
						}
						ch++;
						//a++;
						b=1;
						cout<< "\n";
					}

					//for above while loop short code.
					// 	while(a++ <= n){
					// 	    while(b++ <= n)1
					// 	        cout << ch <<" ";
					// 	    ch++;b=1;
					// 	    cout<< "\n";
					// 	}


					return 0;
				}
			
			//without using that extra char ch variable.
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:";
				cin>>n;
				
				//using char function to convert the int to char.
				
				while(a <= n){
					while(b++ <= n)
						cout << char('A' + a - 1) <<" ";

					b=1;
					a++;
					cout<< "\n";
				}
				return 0;
			}
	
	11)
		Take user input for rows
			enter rows: 3
				A B C
				A B C
				A B C
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
						cout << ch << " ";
						b++;
					}
					ch++;
					a++;
					b=1;
					cout << "\n";
				}
				
				return 0;
			}

			//or without using that extra ch
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							
							cout << char(64 + a) << " ";					//ASCII value of A is 65 so we purposefully added 64 before it.
							
							//or
							//cout << char('A' + a - 1) << " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
		
	12)
		Take user input for rows
			Enter rows:5
			A B C D E 
			F G H I J 
			K L M N O 
			P Q R S T 
			U V W X Y 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
						cout << ch++ << " ";			//shorhand for ch.
							b++;
							//ch++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	14)
		Take user input for rows
		Enter rows:5
			A B C D E 
			B C D E F 
			C D E F G 
			D E F G H 
			E F G H I 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';

				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
					cout << ch++  << " ";
						b++;
						// ch++;
					}
					ch = 'A' + a;
					a++;
					b=1;
					cout << endl;
				}
				return 0;
			}

			//or without using that extra char ch.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							cout << char('A' + b - 1 + a - 1) << " ";			//to match the above pattern so we did adjustment.

							//or using ASCII value to print A , for first iteration (63 + 1 + 1 = 65) which is A.
							//cout << char(63 + b + a) << " ";
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	15)
		Take user input for rows
		  enter rows: 3
		  	A
			B B
			C C C
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
						cout << ch << " ";
						b++;
						}
						ch++;
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

			//without using ch char.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + a - 1) << " ";

							//or
							//cout << char(64 + a) << " ";

							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	16)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				D E F 
				G H I J 
				K L M N O 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b++ <= a)				//shorhand for b first checking then incrementing.
							cout << ch++ << " ";
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	17)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				C D E 
				D E F G 
				E F G H I
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							// cout << char('A' - 1 + b + a -1) << " ";
							// or
							cout << char(63 + b + a ) << " ";
							
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	18)
		Take user input for rows
			Enter rows:5
				E 
				D D 
				C C C 
				B B B B 
				A A A A A 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					
					while(a <= n){
						while(b <= a){
							cout << char(ch + n - a)<< " ";

							//or without using that char ch.
							//cout << char('A' + n - a)<< " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}	
					return 0;
				}

	19)
		Take user input for rows
			Enter rows:5
				E 
				D E 
				C D E 
				B C D E 
				A B C D E 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + n - a + b -1) << " ";
							b++;
						}
						a++;
						b=1;
						
						cout << "\n";
					}
					
					return 0;
				}

				//or short
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows:";
						cin>>n;
						
						while(a <= n){
							while(b <= a)
								cout << char(64 + n - a + b++) << " ";
							a++;b=1;
							cout << "\n";
						}
						return 0;
					}

	20)
		Take user input for rows
			Enter rows: 5
			     *
			    **
			   ***
			  ****
			 *****
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,c,temp;
			
				cout << "Enter rows: ";
				cin >>n;
				c=n;
				
				while(a <= n){  
					temp = c--;                 //shorthand for c
					while(temp >= 1){
						cout << " ";
						temp--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;
			}

			//or
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,space;
			
				cout << "Enter rows: ";
				cin >>n;
			
				while(a <= n){
					space = n - a;
					while(space){
						cout << " ";
						space--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;			
			}

	21)
			Take user input for rows
				Enter rows: 5
					XXXXX
					XXXX
					XXX
					XX
					X
				->
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows: ";
						cin >>n;
						b=n;
						
						while(a <= n){
							while(b--){         //b shorthand
								cout << "X";
								// b--;
							}
							b=n-a++;        //a shorthand
							// a++;
							cout << endl;
						}
						return 0;
					}

	22)Take user input for rows
		Enter rows: 5
			* * * * * 
			  * * * * 
			    * * * 
			      * * 
			        * 
		->
		#include <iostream>
		using namespace std;
		int main() {
			int n,a=1,b, space;
			
			cout << "Enter rows: ";
			cin >>n;

			b = n;
			
			while(a <= n){
				space = a - 1;
				while(space--){         //space shorthand
					cout << "  ";
					// space--;
				}
				while(b--){             //b shorthand
					cout << "* ";
					// b--;
				}
				
				b= n - a;
				a++;
				cout << "\n";
			}
			return 0;
		}

	23)Take user input for rows
		Enter rows: 5
			1 1 1 1 1 
			  2 2 2 2 
			    3 3 3 
			      4 4 
			        5 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b, space;
				cout << "Enter rows: ";
				cin >>n;
				b = n;
				
				while(a <= n){
					space = a - 1;
					while(space--){         //space shorthand
						cout << "  ";
						// space--;
					}
					while(b--){             //b shorthand
						cout << a <<" ";
						// b--;
					}
					
					b= n - a;
					a++;
					cout << "\n";
				}	
				return 0;
			}

	24)Take user input for rows
		Enter rows:5
						1
					2	2
				3	3	3
			4   	4	4	4
		5  	5	5	5	5
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			space = n-1;
			
			while(i <= n){
				while(space--){                 //shorthand for space 
					cout << "  ";
					// space--;
				}
				
				while(j++ <= i){                //shorthand for j
					cout << i << " ";
					// j++;
				}
				i++;
				j = 1;
				
				space = n - i;          //important step.
				
				cout << "\n";
			}

			return 0;
		}

	25)Take user input for rows
	 Enter rows:4
		1 2 3 4
		  2 3 4
		    3 4
		      4
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){
				
				//spacing
				space = 1;
				while(space < i){
					cout << "  ";
					space++;
				}
				
				//printing num
				while(j <= n){
					cout << j << " " ;
					j++;
				}
				cout << "\n";
				i++;
				j=i;            //important step
			}
			return 0;
		}

	26)Take user input for rows
	    Enter rows:4
					1
				2	3
			4	5	6
		7	8	9	10
	   ->
	   	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,counter=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){	
				//spacing
				space = n - i;
				while(space--){		//shorhand for space
					cout << "\t";
				}
				
				while(j <= i){
					cout << counter++ << "\t";
					j++;
				}
				i++;
				cout << "\n";
				j=1;
			}	
			return 0;
		}

	27)Take user input for rows
		Enter rows:4

						1
					1	2	1
				1	2	3	2	1
			1	2	3	4	3	2	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, k=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--) {
						cout << "  ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << j << " ";
						j++;
					}
					
					while(k < i){
						cout << i - k << " ";
						k++;
					}
					
					cout<<endl;
					k=1;
					j=1;
					i++;
				}				
				return 0;
			}

	28)Take user input for rows
		Enter rows:5
		1	2	3	4	5	5	4	3	2	1
		1	2	3	4	*	*	4	3	2	1
		1	2	3	*	*	*	*	3	2	1
		1	2	*	*	*	*	*	*	2	1
		1	*	*	*	*	*	*	*	*	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space=1;
				
				cout << "Enter rows: ";
				cin >> n;
				
				while(i <= n){
					
					//start looping
					while(j <= n-i+1){              //important step
						cout << j  << " "; 
						j++;
					}
					
					//spacing
					while(space < i){
						cout << "* * ";
						space++;
					}
					
					//reverse loop
					while(--j){
						cout << j << " ";
					}
					
					//resetting the values
					j=1;
					space=1;
					
					cout << endl;
					i++;
				}
				return 0;
			}
			//output
				Enter rows: 5
					1 2 3 4 5 5 4 3 2 1 
					1 2 3 4 * * 4 3 2 1 
					1 2 3 * * * * 3 2 1 
					1 2 * * * * * * 2 1 
					1 * * * * * * * * 1 

	29) pyramid start pattern:
		Enter rows: 5
 			    * 
 			   * * 
 			  * * * 
 			 * * * * 
 			* * * * *
		->

			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--){
						cout << " ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << "* ";
						j++;
					}
					cout<<endl;
					j=1;
					i++;
				}
				return 0;
			}
---------------------------------------------------------------------------------------------------------
	04/08/2023
Lecture-5:
	Bitwise Operators, For Loops, Operator Precedence & Variable Scoping
	-Bitwise Operator
		This operator will work on BIT level.
			1). AND (&)
			2). OR (|)
			3). NOT (~)
			4). XOR (^)
		
		Let’s look at the truth table of the bitwise operators
			  Operator	Description				Example
				&		Bitwise AND	 			a & b
				|		Bitwise OR	 			a | b
				^		Bitwise XOR	 			a ^ b
				~		Bitwise NOT (Complement)		  ~a
				<<		Bitwise Left Shift			a << n
				>>		Bitwise Right Shift			a >> n


		Table:
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   a   |   b   | a & b | (a | b)| a ^ b |   ~a  | a << 1 | a >> 1 |
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   0   |   0   |   0   |   0    |   0   |   1   |   0    |   0    |
			|   0   |   1   |   0   |   1    |   1   |   1   |   0    |   0    |
			|   1   |   0   |   0   |   1    |   1   |   0   |   2    |   0    |
			|   1   |   1   |   1   |   1    |   0   |   0   |   2    |   0    |
			+-------+-------+-------+--------+-------+-------+--------+--------+


		eg.
			#include <iostream>
			#include <bitset>
			using namespace std;

			int main() {
				// Bitwise AND (&)
				int a = 12;  // 1100 in binary
				int b = 25;  // 11001 in binary
				int result_and = a & b;
				cout << "Bitwise AND: " << result_and << " (" << bitset<8>(result_and) << ")" << endl;  // Output: 8 (00001000)

				// Bitwise OR (|)
				int result_or = a | b;
				cout << "Bitwise OR: " << result_or << " (" << bitset<8>(result_or) << ")" << endl;  // Output: 29 (00011101)

				// Bitwise XOR (^)
				int result_xor = a ^ b;
				cout << "Bitwise XOR: " << result_xor << " (" << bitset<8>(result_xor) << ")" << endl;  // Output: 21 (00010101)

				// Bitwise NOT (~)
				int result_not = ~a;
				cout << "Bitwise NOT: " << result_not << " (" << bitset<8>(result_not) << ")" << endl;  // Output: -13 (11110011)

				// Bitwise Left Shift (<<)
				int n_left = 2;
				int result_left = a << n_left;
				cout << "Bitwise Left Shift: " << result_left << " (" << bitset<8>(result_left) << ")" << endl;  // Output: 48 (00110000)

				// Bitwise Right Shift (>>)
				int n_right = 2;
				int result_right = a >> n_right;
				cout << "Bitwise Right Shift: " << result_right << " (" << bitset<8>(result_right) << ")" << endl;  // Output: 3 (00000011)

				return 0;
			}
		
			Practice:
				#include <iostream>
				using namespace std;

				int main()
				{
					int a=4,b=6;
					
					cout<<"A&B "<< (a&b) << endl;           //4
					cout << "A|B "<< (a|b) << endl;         //6
					cout << "A^B "<< (a^b) << endl;         //2
					cout << "~A "<< (~a) << endl;           //-5
					
					//~a --> 32 bit
						// 4 ==> [-------- -------- -------- -----100] all bits are zero 
						// ~a ==> [11111111 11111111 11111111 11111011]    reverse of above 
						
						// from first bit you can say that it's -ve num.
						//     so before to print take its 2's complement
						//     1's complement [-------- -------- -------- -----100] adding + 1 in it.
						//     ==> [-------- -------- -------- -----101]
							//this above binary in decimal is 5 so ans is -5.
					return 0;
				}
		
		-Left shift:
			syntax.
				var << num;
			eg.
				5 << 1		ie.		101 after shifting 1 bit to left 1010, so 1010 is 10.
				3 << 2         ie. 		011 after shifting 2 bit to left 1100 so its 12.

		-NOTE: here you can see when we use left shift it will get multiplied by 2 in most cases.
				but BE CAREFULL SOMETIME IT WILL GENERATE AN -VE NUM ALSO, WHEN NUM IS TOO LARGE,
				SO, ITS NOT LIKE THAT WHEN WE DO LEFT SHIFT THEN IT'LL GET MULTIPLIED BY 2.
			
		-Right Shift:
			syntax.
				var >> num;
			eg.
				15 >> 1;			ie. right shift by 1 bit.
				
				5 >> 2;			ie. right shift by 2 bit,
								101 >> 2 -->	001 its 1.

				5/2 = 2 ------- pass 1
				2/2 = 1 ------- pass 2	
				so 5 >> 2 => 1
		
		NOTE: 
			either it is a left shift(<<) or right shift(>>) to any +VE NUM, 
			then num of bits padded with zero(0). (means zero will get added after shifting).

			else if the num is -ve then padding will depends on compiler
		
		eg.
			int a=1,b=2;

			if(a-- >0 && ++b > 2)				//it will check for b also cause && require all condition must be true
				cout<<"if";
			else
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 3 
		
			//OR
			int a=1,b=2;
			if(a-- >0 || ++b > 2)				//it will check for a only, cause one condition needs to be true,
				cout<<"if";					//so if first condition is true then control don't go for next condition & 
			else								//b won't get incremented also. check output
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 2
		
	-For Loop:
		flow:
			once we visit initialization part, 
			then for next all iteration we just check the condition & updation value.

		for(initialize; condition; increment/ decrement){
			//statement
		}
		//or
		for(;;){
				
		}
		eg.
			for(int i=1; i<=5; i++){
				cout << i;
			}
			//or

			int i = 1;
			for(;;){
				if(i<=n){
					cout << i++ ;
				}else{
					break;
				}
			}

			//multiple
			for(int a=0, b=1; a>=0, b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;

			for(int a=0, b=1; a>=0 && b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;
		
		1). WAP Sum of n
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, sum=0;
				cout << "enter n ";
				cin>>n;
				for(int i =1; i<=n; i++)
					sum += i;
					
				std::cout <<"The sum of "<<n<<" num is "<<sum << std::endl;
				
				return 0;
			}
		
		2). WAP for Fibonacci series
			#include <iostream>
			using namespace std;

			int main()
			{
				int n,prev=0, cur=1,temp;
				cout << "enter n ";
				cin>>n;
				
				for(int i =1; i<=n; i++){
					
					cout << prev << " ";
					
					temp = cur + prev;
					prev = cur;
					cur = temp;
					
				}
					
				return 0;
			}
		
		3). check entered num is Prime num or not?
			#include <iostream>
			using namespace std;

			int main()
			{
				int n;
				cout << "Enter num : ";
				cin >> n;
				
				bool PRM = true;
				
				for(int i=2; i < n/2; i++)
					if(n % i == 0){
						PRM = false;
						break;
					}
				
				if(PRM)
					cout << n << " is prime num.";
				else
					cout << n << " is not prime num.";
				
				cout << endl << "END";
				return 0;
			}
		
		4). Print all prime nums between given range
			#include <iostream>
			using namespace std;

			int main()
			{
				int startNum, endNum;
				
				std::cout << "Enter Range to print all Prime nums in-between : " << std::endl;
				
				std::cout << "Enter Starting num :: ";
				std::cin >> startNum;
				
				std::cout << "Enter Ending num :: ";
				std::cin >> endNum;
				
				std::cout << "Prime nums in-between given range :: " << std::endl;
					
				for(int i = startNum; i <= endNum; i++){
					
					bool PRM = true;
					
					if( i == 1){
						std::cout << "1 neither prime nor composite" << std::endl;
						continue;
					}
					
					for(int j=2; j <= i/2; j++)
						if(i % j == 0){
							PRM = false;
							break;
						}
					
					if(PRM)
						std::cout << i << " is Prime num." << std::endl;
					else{
						// std::cout << i << " is not Prime num." << std::endl;
						continue;
					}
				}
				
				cout << endl << "END";
				return 0;
			}

		5). 

	-Variable & Scope:
		-You can't create same variable within single block.
		eg.
			#include <iostream>
			int main()
			{    
				int a =10;
				std::cout << a << std::endl;                //10
				
				if(true){
					std::cout <<"inside if before creating "<< a << std::endl;          //10
					int a = 89, b = 77;
					std::cout <<"inside if after creating "<< a << std::endl;           //89
					std::cout << "b = "<< b << std::endl;
				}
				
				// std::cout << "b" <<b<< std::endl;                       //you cant access b outside if block
				std::cout << "Outside if : "<< a << std::endl;          //10
				
				int i=1;
				for(int i= 5;i<=5;i++)
					std::cout << "HII" << std::endl;
					
				//below code works fine.
				if(1){
					int b;
					
					if(1){
						int b;
						
						if(1){
							int b;
							
							if(1){
								int b;
							}
						}
					}
				}
				std::cout << std::endl << "END";
				return 0;
			}

	-Operator Precedence:
		BODMAS
			-Brackets
			-Orders (Exponents and Roots): 
				Evaluate exponents and roots next. This includes calculations involving powers (^) and square roots (√).
			D - Division
			M - Multiplication
			A - Addition
			S - Subtraction
		
	-Practice:
		1].WAP print the difference of product & sum of given num.
		
			#include <iostream>
			using namespace std;

			int main()
			{
				int num;
				cout << "Enter num ";
				cin >> num;
				
				int sum =0 , prod=1;
				
				while(num > 0){
					int temp = num % 10;
					
					sum = sum + temp;
					prod = prod * temp;
					
					num = num / 10;
				}
				
				std::cout << "SUM "<< sum << std::endl;
				std::cout << "Product "<< prod << std::endl;
				std::cout << "Product - SUM "<< prod-sum << std::endl;
				
				cout << "END";
				return 0;
			}

		2]. WAP to count  Number of 1 Bits in given num:
			#include <iostream>
			using namespace std;

			int main()
			{
				int count =0,n=123;
				while(n > 0){
					if(n & 1){
						c++;
					}
					n >>= 1;
				}
				cout << "no.of 1 bit " <<count;
			}
		
		3]. Reverse integer

			int reverse(int n) {
				int rev = 0;
				while(n){
					if( rev > INT_MAX/10 || rev < INT_MIN/10)   return 0;		//if crossing the limit then return 0.
					rev = (rev * 10) +  n % 10;
					n /= 10;
				}
				return rev;
			}

			#include <iostream>
				using namespace std;
				int main()
				{
					int rev = 0, n;
					
					cin>>n; //123

						while(n > 0){
							int lastDigit = (n % 10);
							rev = rev * 10 + lastDigit;
							n /= 10;
						}
						cout << rev;
					return 0;
				}

			int reverse(int x) {
				int rev = 0, n = abs(x);				//abs() it convert num -ve to +ve, & +ve is +ve only. 

				while(n > 0){
					rev += (n % 10);
					
					if(n > 10){
						rev *= 10;
					}
					
					n /= 10;
				}
				if(x <0 )
					return -rev;
	
				return rev;
			}

			//using do-while loop.
			#include <iostream>
				using namespace std;

				int main()
				{
					int n;
					std::cout << "enter n:" << std::endl;
					cin>> n;
					int rev =0;
					
					do{
						rev = (n % 10) + rev * 10;
					}while(n /=10);
					
					cout<<"The Reverse "<< rev;
					return 0;
				}
	
		4]. WAP to find entered num is even or odd.
			#include <iostream>
			using namespace std;
				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					if( num % 2 == 0)
						cout << num << " is Even." <<endl;
					else
						cout << num << " is Odd." <<endl;

					//or
					//(num % 2 == 0)? std::cout << num << " is Even" : cout << num << " is odd";


					return 0;
				}

			//or without using modulo operator,
				cout << (num & 1 == 1); 
				-This part is attempting to check whether the least significant bit (LSB) of num is 1. 
				However, the code is not written correctly for this purpose.
				The issue lies in operator precedence. 
				The equality operator (==) has higher precedence than the bitwise AND operator (&). 
				So, the expression is evaluated like this:
					(num & (1 == 1))
				
				To fix this issue add parentheses,
					cout << ((num & 1) == 1);
				#include <iostream>
				using namespace std;

				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					((num & 1) == 1) ? printf("%d is Odd num",num) : printf("%d is Even num.",num);

					//or
					//((num & 1) == 0) ? printf("%d is Even num.",num) : printf("%d is Odd num",num) ;
	
					return 0;
				}

			//or
				first division then multiply, it because of rounding in integer,
				#include <iostream>
				using namespace std;
				int main() {
					int num;
					std::cout << "Enter num: ";
					std::cin >> num;

					if((num / 2) * 2 == num)
						cout << "even"<<std::endl;
					else
						cout << "Odd"<<std::endl;
						
					std::cout << "End" ;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	05/08/23
Lecture-6:
	Binary & Decimal Num System
		1) Decimal to Binary
			-divide by 2.
			-Store remainder
			-repeat above 2 step until n != 0.
			-at last reverse the answer
			eg.
				5 -> 101
				7 -> 111
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main(){
					int num, i=0;
					std::cout << "Enter num :" << std::endl;
					cin>>num;
					
					int binaryForm = 0;
					cout << "Binary of " << num << " is ";
					
					while(num){
						int bit = num & 1;
						
						binaryForm = (bit * pow(10,i++)) + binaryForm;
						
						num >>= 1;          //num = num >> 1;
					}
					std::cout << binaryForm <<std::endl;	
					return 0;
				}

				//or
					#include <iostream>
					#include<algorithm>
					using namespace std;
					int main(){
						string s;
						int n = 8;
						while(n){
							s += to_string(n%2);
							n /= 2;
						}
						
						reverse(s.begin(), s.end());
						std::cout << s << std::endl;
						return 0;
					}
			
			eg. to keep same sequence of num.
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int a = 203,b=0,last,i=0;
					
					std::cout << a << std::endl;
					
					while(a){
						last = a % 10;
						b = b + last* pow(10,i++);
						a /=10;
					}

					cout<<b;
					return 0;
				}

			//Homework -ve num to binary
				->

		2) Binary to Decimal
			-multiply by 2's power to that numbers binary bit
			-if that bit is 1, then consider 2's power else ignore
			-last add all 2's power

				1 -> 1011

				=(2⁰ * 1) + (2¹ * 1) + (2² * 0) + (2³ * 1)
				=1+2+0+8
				=11.
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int num,i=0;
					std::cout << "Enter num in binary : " << std::endl;
					cin>>num;            //1010
					
					int deci=0;

					//using while loop
					while(num){
						
						if(num % 10 == 1)					//if(num%10)
							deci = pow(2,i) + deci;
						i++; 
						num /= 10;
					}
					
					//or using do-while loop
					//do{
					//	if(num % 10 == 1)				//if(num%10)
					//		deci = pow(2,i) + deci;
					//	i++;
					//}while(num /=10);

					cout << "The Decimal num is :: "<<deci;
					return 0;
				}
		
		#Bitset:
			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<5> bits; // Creates a bitset with 5 bits, initialized to all zeros
				
				bits[2] = 1; // Set the third bit to 1
				std::cout << "Bitset value: " << bits << std::endl; // Output: 00100
				
				return 0;
			}

		eg.
			#include <bitset>
			std::bitset<8> bits; // Creates a bitset with 8 bits, initialized to all zeros
			std::bitset<8> anotherBits("10101010"); // Initializes the bitset with the given binary string

			std::bitset<32> thirtyTwoBits;   // Creates a bitset with 32 bits
			std::bitset<64> sixtyFourBits;   // Creates a bitset with 64 bits
			std::bitset<128> oneTwentyEightBits; // Creates a bitset with 128 bits
		eg.
			it's okay to define a std::bitset<8> and initialize it with a binary string that has fewer than 8 characters. 
			The missing bits will be implicitly set to 0. In your example, std::bitset<8> anotherBits("101"), 
			since the binary string "101" has only 3 characters, the remaining 5 bits will be set to 0, 
			resulting in a bitset equivalent to "00000101".

			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<8> anotherBits("101"); // Initializes the bitset with "101"

				std::cout << "Bitset value: " << anotherBits << std::endl; // Output: 00000101

				//printing any binary num
					int n;
					cin>>n;
					std::cout << "n "<< bitset<8>(n) << std::endl;
   				
				return 0;
			}
				In this example, the std::bitset<8> is initialized with the binary string "101", 
				which fills the lower three bits. The remaining bits are automatically set to 0, 
				resulting in the bitset value "00000101".
---------------------------------------------------------------------------------------------------------
	06/08/23
Lecture-7:
	LeetCode Problem Solving Session
	eg.
		max/min int printing:
			#include<climits>				
				cout<<INT_MIN;				//minimum value of int stored in INT_MIN
				cout<<INT_MAX;				//maximum value of int stored in INT_MAX

	Practice:
		1]. Complement of base 10 integer
			5 -> 101
			complement -> 010
			which is 2 in decimal

			7 -> 111
			complement -> 000
			which is 0 in decimal

			#include <iostream>
				#include<bitset>
				using namespace std;

				int main()
				{
					
					int n;
					cin>>n;
					
					if(!n){                                 //if(n == 0)
						cout << "new num "<< !n;            //cout << "new num "<< 1;
						return 0;
					}
					
					int temp = n, mask=0;
					
					while(temp){
						mask <<= 1;              //mask = mask << 1;
						mask |= 1;               //mask = mask | 1;
						temp >>=1;               //temp =  temp >> 1;
					}
					
					n = (~n) & mask;
					
					cout << "new num "<<n;
					
					return 0;
				}

			LeetCode:
				int bitwiseComplement(int n) {

					if(!n){
						return !n;
					}

					int temp = n,mask=0;

					while(temp){
						mask <<=1;
						mask |= 1;
						temp >>= 1;
					}

					n = (~n) & mask;
					return n;
				}

		2]. Given num is representation of power of 2.	(hint if no.of setbits = 1 then that num is power of 2)
			#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int n,i=0;
					cin>>n;
					
					while(n >=1){
						int temp = pow(2,i++);
						if(n == temp){
							std::cout << "TRUE" << std::endl;
							return 0;
						}
						
						if(temp > n)
						{
							cout <<"FALSE";
							return 0;
						}
					}
					cout << "FALSE";
					return 0;
				}
				//or
					int main()
					{
						int a;
						
						std::cout << "Enter num " << std::endl;
						cin>>a;
						
						for(int i=0; ;i++){
							int temp = pow(2,i);
							if(temp == a){
								std::cout << "Yes power of 2" << std::endl;
								break;
							}
							
							if(temp > a){
								std::cout << "No it's not power of 2" << std::endl;
								break;
							}
						}
						
						std::cout << "END" << std::endl;
						return 0;
					}

			LeetCode:
				bool isPowerOfTwo(int n) {
					int temp=1;					
					while(n>=1){
						if(n == temp)
							return true;
						
						if(temp > n)
							return false;

						temp = temp * 2;
					}
					return false;
				}	

				//or
				if(n==0) return false;
				while(n%2==0) n/=2;
				return n==1;

			// power finding without using * & pow().
				#include <iostream>
				#include<cmath>
				using namespace std;
				int main(){
					
					int n=-9;
					int sqr =0;
					
					//without using *,/ or pow()
					if(n<0)
						n = -n;
					for(int i=1; i<=n; i++)
						sqr +=n;
					std::cout << sqr << std::endl;
					
					//using pow()
					std::cout << pow(n,2) << std::endl;
					
					//using *
					std::cout << n*n << std::endl;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	07/08/23
Lecture-8:
	Switch case & functions:
		syntax.
			switch(condition){
				case value_1 :
					//statement block ;
					break;
					
				case value_2:
					//statement block ;
					break;

				case value_3:
					//statement block;
					break;

				default:
					//statement block ;
			}
			--here for above case no need to use break after default, coz default is at the last of switch case,
				so it will automatically go out of switch case and continue with next line.

			--in place of condition in switch case [switch(condition)], you can keep integer or character value,
				but not float / string value.
				you can keep expression also, like	
				switch(a+b*10)		which generates an constant value.
				
			
			--default case is not mandatory, if its there in code then GOOD, if its not then NO WORRIES.
			--default case is better to keep at last,
		->		
			Include break after default: 
				If you want the switch statement to exit immediately after the default case is executed, 
				you should include a break statement. This prevents the program from continuing to execute 
				code in other case blocks that come after the default case.
				switch(condition){
					case value_1 :
						//statement block ;
						break;
						
					case value_2:
						//statement block ;
						break;

					default:
						//statement block ;
						break;
					
					case value_3:
						//statement block;
						break;
				}

				--if the code is like this above then better to keep the break after default, if you don't 
					write break; after default, then it'll continues to executes the next cases which are after default.

				Nested switch:
					switch(condition){
						case value_1 :
							//statement block ;
							break;
							
						case value_2:
							switch(condition){
									case value_1 :
										//statement block ;
										break;
										
									case value_2:
										//statement block ;
										break;

									default:
										//statement block ;
										break;
									
									case value_3:
										//statement block;
										break;
								}
							break;

						default:
							//statement block ;
							break;
						
						case value_3:
							//statement block;
							break;
					}
		
		eg.
			#include <iostream>
			using namespace std;

			int main()
			{
				int num = 1;
				char ch = '1';
				switch(ch){
					case '2':
						std::cout << "2nd Character" << std::endl;
						break;
						
					case '3':
						std::cout << "3rd Character" << std::endl;
						break;
						
					case '1':
						switch(num){
							case 1:
								std::cout << "1st Character Nested switch" << std::endl;
								break;
						}
						break;
						
					default:
						std::cout << "Default case" << std::endl;
				}
				return 0;
			}
			//output : 1st Character Nested switch

		-Function exit(0)
			--used to come out from infinite loop if we got stuck, without using break. 
			--The most common convention is to use exit(0) to indicate successful execution.
			--and exit(1) (or any non-zero value) to indicate an error or abnormal termination.

			#include <iostream>
			#include <stdlib.h>
			using namespace std;

			int main()
			{
				int num = 1;
				
				while(1){
					std::cout << num << std::endl;
					if(num > 10)
						exit(0);
					num++;
				}
			return 0;
			}
		
		Practice:
			#include <iostream>
				using namespace std;

				int main()
				{
					int a,b;
					char Op;
					
					std::cout << "Enter A :: ";
					std::cin >> a;
					std::cout << "Enter B :: ";
					cin>>b;
					
					cout<<"Enter Operation want to perform: ";
					cin>>Op;
					
					switch(Op){
						case '+':
							{
								std::cout << "Addition: " <<a+b << std::endl;				//you can use Brackets for cases also.
								break;
							}
							
						case '*':
							{
								std::cout <<  "Multiplication: " << a*b << std::endl;
							}
							break;
						
						case '-':
							std::cout <<  "Subtraction: " <<  a-b << std::endl;
							break;
						
						case '/':
							std::cout <<   "Division: " << a/b << std::endl;
							break;
						
						case '%':
							std::cout <<  "Remainder: " <<  a%b << std::endl;
							break;
						default:
							cout << "Not Matching Operation.\n";
					}
					
					std::cout << "END" << std::endl;
					return 0;
				}

			#include <iostream>
				using namespace std;

				int main()
				{
					int num;
					std::cout << "Enter Num : " << std::endl;
					cin >>num;
					
					switch(1){
						
					}
					int temp = num;
					//1234      =12
					
					std::cout << "you need "<< num/ 100 << " 100 notes" << std::endl;        //12
					num -= (num/100) * 100;                     //1234-1200 = 34
					
					std::cout << "you need "<< num / 50 << " 50 notes" << std::endl;         //0
					num -= (num/50) * 50;                                               //34
					
					std::cout << "you need "<<num/20 << " 20 notes" << std::endl;        //1
					num -= (num/20) * 20;                                           //34-20 =14
					
					std::cout << "you need "<< num/10 << " 10 notes" << std::endl;       //1
					num -= (num/10) * 10;                                       //14-10=4
					
					std::cout << "you need "<< num/1 << " 1 coins" << std::endl;       //4
					num = num;

					std::cout << "For "<<temp<<" Amout." << std::endl;
					
					std::cout << "END" << std::endl;
					return 0;
				}	

		Functions:
			A function is a block of code that performs a specific task.
			Suppose we need to create a program to create a circle and color it. We can create two functions to solve this problem:

				a function to draw the circle
				a function to color the circle
			Dividing a complex problem into smaller chunks makes our program easy to understand and reusable.

			There are two types of function:
				Standard Library Functions: Predefined in C++
				User-defined Function: Created by users 
			
			syntax to declare a function is:

				returnType functionName (parameter1, parameter2,...) {
					// function body   
				}

				Here's an example of a function declaration.
				
				// function declaration
				void greet() {
					cout << "Hello World";
				}

				Here,
					the name of the function is greet()
					the return type of the function is void
					the empty parentheses mean it doesn't have any parameters
					the function body is written inside {}
				
				Calling a Function
					In the above program, we have declared a function named greet(). 
					To use the greet() function, we need to call it.
					Here's how we can call the above greet() function.
						greet();
			eg.
				Power of n, pow(a,b);
					#include <iostream>
					using namespace std;

					int power(int, int);            //function declaration,because after main function
											//we are giving the function definition
					int main()
					{
						int a,b;
						std::cout << "Enter a, b :: " << std::endl;
						std::cin >> a>>b;
						
						int ans = power(a,b);
						
						cout<<"Power "<<ans;
						
						return 0;
					}

						int power(int a, int b){

							if(a == 0)                  //if(!a)
								return 0;       
							
							int t=a;
							while(--b){
								a = a * t;
							}
							return a;
						}
					
					//or
						Find power of a number
						#include <bits/stdc++.h> 
						#include <iostream>
						using namespace std;

						int main() {
							int n,x;
							cin>>x>>n;
							int ans = pow(x,n);
							int mod = 1e9+7;
							cout<< ans % mod;
							return 0;
						}

				Even Odd function:
					#include <iostream>
					using namespace std;

					bool isEven(int);        //function declaration

					int main()
					{
						int a;
						std::cout << "Enter a ";
						cin >> a;
						
						// (a&1)?cout<<"Odd":cout<<"Even";      
						//or
						
						isEven(a)?cout<<" Even": cout<< " Odd";         //using function
						
						return 0;
					}

						bool isEven(int num){
							if(num % 2 ==0)
								return 1;
							return 0;
						}

				nCr= n!/(r!* (n-r)!)
					#include <iostream>
					using namespace std;

					int fact(int);
					int nCr(int, int); 	          //function declaration  its not required if 
											//we defined function before main function
											//but here we are giving the function definition after main function.
					int main()
					{
						int n,r;
						cout<<"Enter n & r :: ";
						cin>>n>>r;
						
						cout<<n<<"C"<<r<<" = "<< nCr(n,r);
						return 0;
					}

						int nCr(int a, int b){
						
						int NMR = fact(a);                  //numerator
						
						int DNMR = fact(b) * fact(a-b);                     //denominator
						
						return NMR/DNMR;
					}

					int fact(int num){
					
						if(num == 0)
							return 1;
						int t = num;
						
						for(int i=1; i<t; i++)
							num *= i;                               //num = num * i;

						return num;
					}

				Printcouting:
					//void function returns nothing, 

					#include <iostream>
					using namespace std;

					// void printCouting(int);             //function declaration no need here coz 
												//we defined the function with its definition here.

					void printCouting(int c){
					for(int i=1;i<=c;i++)
						std::cout << i << std::endl;
					}

					int main()
					{
						int n;
						cin>>n;
						
						printCouting(n);
						
						std::cout << "END" << std::endl;
						return 0;
					}

				isPrime:
					#include <iostream>
					using namespace std;

					bool isPrime(int num){
						for(int i=2; i<= num/2; i++)
							if(num % i == 0)
								return 1;
						
						return 0;
					}

					int main()
					{
						
						int n;
						cin>>n;
						
						isPrime(n)? cout<<"NO "<<n<<" is NOT Prime num" :cout<<"Yes "<<n<<" is Prime num"; 

						return 0;
					}

				NOTE:
					You can use return in void returnType function without specifying any number;
					eg.
						This is OK.
						void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;							
								return ;
							}
						
						This is not OK.
							void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;
								
								return 0;						//here return 0, void doesn't return anything will generate error.
							}

			function calling stack:
				FILO	: First in Last out
			
			-Parameter/ argument:
				Formal Parameter:
					-A variable and its type as they appear in the prototype of the function or method.
					-Formal parameters are declared in the function signature and 
					 act as placeholders for values that the function will receive.
					 eg.
					 	void displayNumber(int num); // Formal parameter: "int num"

				Actual Parameter: 
					-The variable or expression corresponding to a formal parameter that appears in 
					 the function or method call in the calling environment.
					-Actual parameters (arguments) are the specific values that are 
					 provided to the function when it is called, corresponding to the formal parameters
					eg.
						displayNumber(42); // Actual parameter: "42"

			-Pass by Value/ call by value:
				#include <iostream>
				using namespace std;
				void func(int n){						//formal parameter
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90
					func(n);											//91			//Actual parameter
					std::cout << "After func: "<< n << std::endl;			//90
					return 0;
				}

			-Pass by reference/ call by reference:
				#include <iostream>
				using namespace std;

				void func(int &n){
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90

					//pass by reference- sending memory 
					func(n);											//91
					
					std::cout << "After func: "<< n << std::endl;			//91
					return 0;
				}

			Homework:
				1)ArithmeticProgression  = 3 * n +  7 make function of it.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int n;
							std::cout << "enter n: " << std::endl;
							cin>>n;
							
							std::cout << "The Arithmetic Progression for "<< n << " is "<< (3*n)+7;
							return 0;
						}

				2)Total no.of set bits (1) from given 2 numbers.
					eg.
						2 -> 10 			->1
						3 -> 11			->2
						Total set bits : 1+2 = 3
					->
						#include <iostream>
						#include <bitset>
						using namespace std;

						int setBitCouter(int z){
							int counter=0;
							
							while(z != 0){
								if(z&1)
									counter++;
								z >>=1;
							}
							return counter;
						}

						int main()
						{
							int a,b;
							std::cout << "enter a: ";
							cin>>a;
							
							std::cout << "enter b: ";
							cin>>b;
							
							std::cout << "Binary if a :: "<< bitset<32>(a) << std::endl;
							std::cout << "Binary if b :: "<< bitset<32>(b) << std::endl;
							
							//couting the no.of setbits, for a
							int sbA = setBitCouter(a);
							
							//for b
							int sbB = setBitCouter(b);
							
							std::cout << "The no.of setbits in "<<a<< " & "<<b<<" is "<< sbA+sbB << std::endl;
							
							return 0;
						}

					#include <iostream>
					using namespace std;
					int main(){
						int n=3;
						int ans = __builtin_popcount(n);
						std::cout << ans << std::endl;
						return 0;   
					}


				3)Fibonacci series nth term function:
					input: n = 5;			// 0 1 1 2 3 5 8 13
					output: 3			//5th num of that series.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int prev= 0, curr= 1;
							
							int n;
							cout<<"Enter n:";
							cin>>n;
							
							int i=0;
							
							for(;i<n-1; i++){
								// cout<<prev<<" ";            
								
								int next = prev + curr;
								prev = curr;          
								curr = next;          
							}
							
							std::cout << "The "<< i+1 <<" number term is "<< prev << std::endl;
							return 0;
						}

			Local variable: 
				A variable declared within a function or a block of code is called a local variable. 
				Local variables are frequently used to temporarily store data in a defined 
				scope where they can be accessed and manipulated. They are stored in the memory stack, 
				Once the function or block of code in which the local variable is declared finishes executing. 
				The variable is automatically removed from the memory.

		2]. Number complement

			#include <iostream>
			#include <bitset>
			using namespace std;
			int main()
			{
				int n;
				std::cout << "Enter num : " << std::endl;
				cin>>n;
				
				cout<<"Binary of "<<n<<" "<<bitset<32>(n)<<endl;
				std::cout << "Complement of above binary "<< bitset<32>(~n) << std::endl;
				
				return 0;
			}
			
		3]. Square root of n ❌
---------------------------------------------------------------------------------------------------------
	08/08/23
Lecture-9:
	Introduction to Arrays
		-Array is a collection of variables of the same type.
		-Arrays are used to store multiple values of same Datatype in a single variable, 
		 instead of declaring separate variables for each value.
		-To declare an array, define the variable type, specify the name of the array 
		 followed by square brackets and specify the number of elements it should store

		-All arrays consist of contiguous memory locations. 
		 The lowest address corresponds to the first element and the highest address to the last element.

		-Array elements/ value we can access by INDEX.
		-Array start from 0.
		-defaultly they contain garbage value inside it.
		-use index num to access value of array on that location.
		
		-size of array = n, then till (n-1) index we can access.

		-Array declaration:
			 int a[10] ={1,2,3};         //ok
    
			int b[3] = {1,2,3};         //ok
			
			int c[] = {1,2,3,4,5,6,7};      //ok
			
			// int d[2] = {1,2,3,4,5,6,7};     //not ok
			
			// int e[];            //not ok

			// int f[10];              //not ok
			// f[10] = {1,2,2};
			// f[] = {1,2,4,3};

			int g[15];				//ok
	
		-declararing array with random/ Garbage value:
			int a[10];
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

		-Initializing all array element with 0.
			int a[10] ={0};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			-When you try to initialize some elements of array, they will get your specified value, 
				& rest all element of array elements become zero.

			--here in above case first element is initialized with 0, & rest all become will initialized with zero. 
		
		-Initializing all array element with 1 WON'T WORK ❌, only with 0 it will work.
			int a[10] ={5};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			In the above example, only the first element will be initialized to 5. All others are initialized to 0.

		--Here in below
			example you can see that if you try to initialize any position's value in array,
			then that position will get specified mentioned value, rest all by default initialized with zero.

			#include <iostream>
			using namespace std;

			int main()
			{
				int a[10] = {2,8};
				a[9]=90;
				a[5]=60;
				
				for(int i=0;i<10;i++)
					std::cout << i <<" "<<a[i]<< "\t";					
					
				return 0;
			}
				//2       8       0       0       0       60      0       0       0       90
			
		-To initialize array element with some default value,
			int a[10];
			for(int i=0;i<10;i++)
				a[i] = 4;
			
			for(int i=0; i<10;i++)
				std::cout << i << " " << a[i] << std::endl;
			
			//or using fill_n method
			std::fill_n(arrayName, arraySize, defaultValue);

			std::fill_n(a,10,90);

		string cars[4];
		eg.
		 int a[] = {1,2,3};
		 std::cout << sizeof(a) << std::endl;			//each int size is 4 so here, 12.

		 int b[] = {1,2,3,4};
		 std::cout << sizeof(b) << std::endl;			//each int size is 4 so here, 16.

		 //to print memory address of variable stored use &.
		 	int b=90;
			cout<< "memory location of B :: "<<b<<" "<<&b;

		for array just print the variable name it will give the memory address
			int a[] = {1,2,3};
			cout<< "memory location of Array a :: "<<a<<" "<<&a<<endl;			//this both a & (&a) will print the same thing.
		
		-Index accessing:
			int a[5] ={1,2,3,4,5};
				//100 , 104, 108, 112, 116			--memory address.
			
			-variable a will store the base address.
			-Suppose 100, first element's address, the next will be 104, next 108 coz size of int is 4 byte.

			a[0];			//base address	100, output value will be 1
			a[3];			//(base address + indexNum * sizeOfDatatype) =100 + 3*4 = 112, value will be 4.
        
	   	----External Link---------
			https://www.tutorialspoint.com/cplusplus/cpp_arrays.htm	
		-------------

		-If we try to access the index which is greater than size of array,
			then you will get an GARBAGE value.
		
		-Finding array length
			we can find the length using sizeof operator,
			-first find the sizeof whole array
			-then divide it by sizeof Datatype of that array.
			eg.
				int a[10];
				sizeof (a); //output : 40
				sizeof(int);	//output:4
				sizeof (a)/sizeof(int); //output : 10

			BUT,here in below case we initialized just 2 element then it should show the 
				length is 2 but according to that above method it will print length as whole 
				array size. drawback.
				eg.
					int b[10]={1,5};			//length:2
					int len = sizeof(b)/sizeof(int);		//len: 10 		(not expected this.)

		-Advance for loop in c++:
			int b[10] = {90};

			for(int j: b){
				cout<<j<<"\t";
			}

			for(int i: b)
				cout<<i<<"\t";
		
		-BAD Practice:
			int size;
			cin>>size;

			int arr[size];				//never do this.
				//instead of doing like this directly mention constant as size of array thats better,
			int arr[10000];			//this is ok than above

		-Practice:
			1.Array:
				#include <iostream>
				using namespace std;
				void printArray(int[], int);        //function declaration says that takes input parameter first as array, 2nd is integer

				int main()
				{
					//creating array & initializing
					int arr[10]= {1,2,3,4,5,6,7,8,9,10};
					
					//printing it,
					for(int i=0;i<10;i++)
						std::cout << arr[i] << "\t";
						
					std::cout << std::endl;     //or
					
					//printing using function
					printArray(arr, 10);
					
					std::cout << std::endl;
					
					//using advance loop,
					for(int j: arr)
						cout << j << "\t";
					
					return 0;
				}

				void printArray(int v[],int size){
					for(int i=0;i<size;i++)
						std::cout << v[i] << "\t";
				}

			2.Min/Max Array:
				#include <iostream>
				#include <climits>
				using namespace std;

				void getMax(int n[], int len){
					int maxi = INT_MIN;
					
					for(int a=0; a<len; a++){
						
						// if(maxi < n[a]){
						//     maxi = n[a];
						// }
						
						maxi = max(maxi, n[a]);     //it will compare these 2 values we passed then 
												// decides which one is maximum & stores maximum value.
					}
					cout<<"MAX : "<<maxi;
				}

				void getMin(int k[], int L){
					int mini = INT_MAX;
					
					for(int a=0; a<L; a++){
						
						// if(mini > k[a]){
						//     mini = k[a];
						// }
						
						//or using built in function
						mini = min(mini,k[a]);       //it will compare these 2 values we passed then 
												// decides which is min & stores minimum value
					}
					
					cout<<"Min : "<<mini;
				}

				int main(){
					int array[100];
					
					int size;
					std::cout << "Enter size of array : (should be <100)" << std::endl;
					cin>>size;
					
					std::cout << "Enter "<<size<<" elements in array :" << std::endl;
					
					//taking array elements
					for(int i=0; i<size; i++)
						cin>>array[i];
						
					//printing array
					for(int o=0; o<size; o++)
						cout<<array[o]<<" ";
					
					std::cout << std::endl;
					getMax(array,size);
					
					std::cout << std::endl;
					getMin(array,size);
					
					return 0;
				}

		-Passing array to function:
			--here passing array to function means passing memory address of that array to function,
			  so as we learnt name of array holds the base/ starting memory address of array.
			  eg.
			  	int ar[10];		//here ar holds the memory address, so if we pass ar to function
								//then we passing memory address of array, not copy of array.
			
			--so if you update the array inside any other function also, this will affect 
			  the original array.
			eg.
				#include <iostream>
				using namespace std;

				void UpdateArr(int z[], int len){
				
					z[5] = 500;			//updating value at 6th location.
					
					std::cout << "Inside Update function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<z[i]<<"\t";
						
					cout<<"\n";
				}

				int main(){
					int arr[100] = {1,2,3,4,5,6,7,8,9,10};
					
					std::cout << "Inside main function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					std::cout  << std::endl;
					UpdateArr(arr, 10);
					
					std::cout << "Back to main function again Now Array : " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					return 0;
				}
				//output:
					Inside main function array: 
					1       2       3       4       5       6       7       8       9       10
					Inside Update function array: 
					1       2       3       4       5       500     7       8       9       10
					Back to main function again Now Array : 
					1       2       3       4       5       500     7       8       9       10

				Sum of array elements:
					#include <iostream>
					using namespace std;

					int SUM(int z[], int len){	
						int sum =0; 
						
						for(int i=0;i<10;i++)
							sum += z[i];
							
						return sum;
					}

					int main()
					{
						int arr[100] = {1,2,3,4,5,6,7,8,9,-10};
						
						int sum = SUM(arr,10);
						std::cout << "Sum of Array elements :: "<< sum << std::endl;	//Sum of Array elements :: 35
						
						return 0;
					}

					//in reverse order
						int sumElement(int arr[],int n){
							int s=0;
							//Your code here
							while(n)
								s += arr[--n];
							return s;
						}


				Reverse Array:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						
						//Array
						for(int q: arr)
							std::cout << q << "\t";                 //use this advance loop if your are using whole size of array.
							
						std::cout << std::endl;
						
						//printing array in reverse way. means not reversing actual array.
						for(int i=9; i>=0; i--)
							cout<< arr[i]<<"\t";
						
						//for this you should know the length of array
						//array reversed.
						int len = 10;
						for(int i=0; i<len/2; i++){
							
							int temp = arr[i];
							arr[i] = arr[(len-1)-i];
							arr[(len-1)-i] = temp;
						}
						
						//printing original array
						std::cout << std::endl;
						for(int i: arr){
							cout<<i<<"\t";
						}
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;

						void reverse(int arr[], int n) {

							int start = 0;
							int end = n-1;

							while(start<=end) {
								swap(arr[start], arr[end]);
								start++;
								end--;
							}
						}

						void printArray(int arr[], int n) {
							
							for(int i=0; i<n; i++) {
								cout << arr[i] << " ";
							}
							cout << endl;
						}

						int main() {

							int arr[6] = {1,4,0,5,-2,15};
							int brr[5] = {2,6,3,9,4};

							reverse(arr, 6);
							reverse(brr, 5);

							printArray(arr, 6);
							printArray(brr, 5);

							return 0;
						}

				Linear search:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						int key;
						
						std::cout << "enter key: " << std::endl;
						cin>>key;
						
						for(int i=0;i<10;i++){
							if(arr[i] == key){
								std::cout << "Key Found, at "<< i << std::endl;
								break;
							}
							
							if(i==9)
								std::cout << "Key Not Found." << std::endl;             //array traversed till last but didn't found key
						}
							
						return 0;
					}
---------------------------------------------------------------------------------------------------------
	09/08/23
Lecture-10:
	Alternate swap
		i/p-> {1,2,3,4,5,6};
		o/p-> {2,1,4,3,6,5};
		->
			#include <iostream>
			using namespace std;

			void swapAlternate(int ar[], int size){
    
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = ar[i];
					//     ar[i] = ar[i+1];
					//     ar[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(ar[i],ar[i+1]);
				}
			}


			int main()
			{
				int a[100];
				
				int size;
				std::cout << "Enter size of array:" << std::endl;
				cin>>size;
				
				cout<<"Enter "<< size << "elements in array: ";
				
				//inputing array elements
				for(int i=0;i<size;i++)
					cin>>a[i];
				
				//printing array.
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";
					
				
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = a[i];
					//     a[i] = a[i+1];
					//     a[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(a[i],a[i+1]);
				}

				//or using function
				//swapAlternate(a, size);
				
				cout<<"\n";
				
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";

				return 0;
			}

	-find unique element in array
		(hint: XOR with same num will give output 0) a ^ a =0
		eg.
			5 ^ 5 = 0
		(XOR with zero & any other num will ouput the same num ) 0 ^ a = a
		eg.
			0 ^ 5 = 5
			0 ^ 23 = 23.
		->
			int findUnique(int arr, int size){
				int ans = 0;
				for(int i=0;i<size;i++)
					ans = ans ^ arr[i];

				return ans;
			}
	
	-check the occurence of elements are unique or not?
		bool uniqueOccurrences(vector<int>& arr) {
			vector<int> ans;

			int counter=1;
			
			for(int i=0;i<arr.size(); i++){
				int temp = arr[i];
				if(arr[i] == -2000)
					continue;
				for(int j=i+1; j<arr.size();j++){
					if(temp == arr[j]){
						arr[j] = -2000;
						counter++;
					}
				}
				ans.push_back(counter);
				counter=1;
			}

			for(int i=0; i<ans.size(); i++){
				int temp = ans[i];
				for(int j=i+1; j<ans.size(); j++){
					if(temp == ans[j])
						return false;
				}
			}
			return true;
		}

	-find duplicate element in array
		Vector- It's dyanamic kind of thing.

		//not optimized
			int n = arr.size();
			for(int o=0;o<n;o++){
				int t = arr[o];

				if(o<n-1)
					for(int i=o+1; i<n; i++)
						if(t == arr[i])
							return t;
			}
		
		//optimized
			int findDuplicate(vector<int> &arr) 
			{
				// Write your code here
				int ans =0;

				//first we initialized the ans to 0 coz xor 0 with any other num will
				//give ans as that num only.

				//then we run for loop 0 to till length of array some answer will come,
				//again we will run loop from 1 to length-1 of array means to skip any one value.
				//then the answer will be duplicate value.

				for(int a=0; a<arr.size(); a++)
					ans = ans ^ arr[a];
				
				//we are doing xor with a directly coz there is only one duplicate element
				//& array contain the element from 1 & n-1 at least once
				for(int a=1; a< arr.size(); a++)
					ans = ans ^ a;

				return ans;
			}

	-find all duplicates num in array.
		//dyamica array in c++
			#include <iostream>
			#include <vector>
			int main() {
				// Write C++ code here
				//dynamic array
				
				std::vector<int> arr = {1,2,3};
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
					
				arr.push_back(100);
				
				std::cout<<"\n";
				
				arr.push_back(200);			//inserting num in array.
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
				
				return 0;
			}

		//brute force-> TIME LIMIT EXCEEDED
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				for(int a=0; a< nums.size(); a++)
				{
					int temp = nums[a];
					for(int b =a+1; b< nums.size(); b++){
						if(temp == nums[b]){
							dual.push_back(nums[b]);
							break;
						}
					}
				}
				return dual;
			}

		//optimized
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				sort(nums.begin(), nums.end());			//built in function to sort array.

				for(int a=1; a< nums.size(); a++)
				{
					if(nums[a-1] == nums[a]){
						dual.push_back(nums[a]);
					}
				}
				return dual;
			}

			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;			//dynamic array.
				set<int> st;				//set which contains any element once only.

				for(int a=0; a< nums.size(); a++)
				{
					if(st.count(nums[a])){				//count method return 1 if that element present in set, else 0.
						dual.push_back(nums[a]);
					}else{	
						st.insert(nums[a]);				//insert method will insert that element/value into set.
					}
				}
				return dual;
			}

	-Sorting array:
		#include <iostream>
		#include <set>
		#include<algorithm> //mandatory for sort functionality
		using namespace std;

		int main() {
			// Write C++ code here
			int nums[] = {5,4,3,2,1};
			
			int len = sizeof(nums)/sizeof(nums[0]);     //calculating the length of array. 
												//this works if complete array which length is specified is filled completely, like a[100], then all 100 elements should be present.
												//or they if left length of array empty, like int arr[] = {1,2,3};
			
			for(int i=0;i<len; i++)
					cout<<" "<<nums[i];
					
			cout<<"\n";
			
			sort(nums, nums+len);			//from base(starting) address to till last
			
			//sort(starting array_memory_address, end array_memory_address);
			
			for(int i=0;i<len; i++)
				cout<<" "<<nums[i];
			return 0;
		}
	
	-Set:
		-set by default store element in ascending order,
		-set store unique elements. not duplicate.
		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.
		eg.
			std::set <data_type> set_name;

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values

			//to check element present in set or not use count method with parameter in it.
			val.count(5);			//if that value present in set it returns 1
			val.count(12);			//if that value absent in set it returns 0
		Pratical:
			#include <iostream>
			#include <set>
			using namespace std;
			int main() {
				std::set<int> a;
				a.insert(10);
				a.insert(9);
				a.insert(7);
				
				a.insert(9);        //these 2 values won't get added.
				a.insert(7);
				
				a.insert(90);
				a.insert(70);
				
				
				a.insert(23);
				a.insert(34);            //inserting into set.


				cout<<*a.begin()<<"\t";     //return first element of set.
				
				cout<<*a.end()<<"\t";       //return the last element index, Length of set

				//length of set:
				cout<<"\n the length of set A is :: "<<a.size();

				//printing set
				for (int str : a) {
					cout << str << ' ';
				}
				
				cout<<"\n";
				cout<<"is 12 present in set A :: "<<a.count(12);			//0 means not present
				cout<<"is 10 present in set A :: "<<a.count(10);			//1 means present
				
				std::cout << '\n';

				return 0;
			}
		
			//printing char set,
			--need to define the iterator on it which is character (char) type.
				set<char> set1;
				set<char> :: iterator MY;
				for(MY = set1.begin(); MY != set1.end(); MY++){
					cout<< *MY;
				}

	-Array intersection (common element from 2 array).
		Intersection Of Two Sorted Arrays
		Constraints:
			1 <= T <= 100
			1 <= N, M <= 10^4
			0 <= A[i] <= 10^5
			0 <= B[i] <= 10^5
			Time Limit: 1 sec
		
		Sample Input 1 :
			2				T		test cases
			6 4				N M
			1 2 2 2 3 4		A	array 
			2 2 3 3			B	array

			3 2				N M  lengths
			1 2 3			array A
			3 4  			array B
		Sample Output 1 :
			2 2 3		
			3   
		Explanation For Sample Input 1 :
			For the first test case, the common elements are 2 2 3 in both the arrays, so we print it.
			For the second test case, only 3 is common so we print 3.
		->
			//Time Limit EXCEEDED (TLE)
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;

					for(int i=0; i<n; i++){
						int temp = arr1[i];

						for(int j=0; j<m; j++){
							if(temp == arr2[j]){
								common.push_back(temp);
								arr2[j] = -1;
								break;
							}
						}
					}
					return common;
				}
			
			//optimized:
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;
					int i=0,j=0;
					
					while(i<n && j<m){
						if(arr1[i] == arr2[j]){
							common.push_back(arr1[i]);
							i++;j++;
						}else if(arr1[i]< arr2[j]){
							i++;
						}else{
							j++;
						}
					}
					return common;
				}

	-Pair sum
		-https://www.codingninjas.com/studio/problems/pair-sum_697295
		Sample Input 1:
		5
		1 2 3 4 5
		Sample Output 1:
		1 4
		2 3

		Explaination For Sample Output 1:
		Here, 1 + 4 = 5
			2 + 3 = 5
		Hence the output will be, (1,4) , (2,3).
		
		Sample Input 2:
		0
		2 -3 3 3 -2
		Sample Output 2:
		-3 3
		-3 3
		-2 2

		#include <bits/stdc++.h>
		vector<vector<int>> pairSum(vector<int> &arr, int s){
			vector< vector<int> > ans;

			for(int i=0; i<arr.size(); i++){
				for(int j=i+1; j<arr.size(); j++){
					if(arr[i]+arr[j] == s){
						vector<int> temp;
						temp.push_back(min(arr[i], arr[j]));            
						temp.push_back(max(arr[i], arr[j]));
						ans.push_back(temp);
					}
				}
			}
			sort(ans.begin(), ans.end());
			return ans;
		}
		
	-Triplet sum:
		#include <bits/stdc++.h> 
		vector<vector<int>> findTriplets(vector<int>arr, int n, int K) {  
			sort(arr.begin(),arr.end());
				vector<vector<int>>ans;
			set<vector<int>> s;
			for(int i=0;i<n;i++){
				int sum = K - arr[i];
				int j = i+1;
				int k = n-1;
				while(j<k){
						if(arr[j]+arr[k] == sum){
							vector<int> temp;
							temp.push_back(arr[i]);
							temp.push_back(arr[j]);
							temp.push_back(arr[k]);
							sort(temp.begin(),temp.end());
							s.insert(temp);
							j++;
						}
					else if(arr[j]+arr[k]<sum){
						j++;
					}
					else{
						k--;
					}
				}
			}
			for(auto val: s){
				ans.push_back(val);
			}
			return ans;
		}

	-sort 0's & 1's:
		#include <iostream>
		using namespace std;

		void printArr(int a[], int n){
			for(int i=0;i<n; i++){
				cout<<a[i] << "\t";
			}
			cout<<"\n";
		}

		int main() {
			int arr[] = {1,1,1,1,1,0,0,0,0,0};
			int len = 10;
			printArr(arr, len);
						
			int i=0, j = len-1;
			while(i <= j ){
				if(arr[i] > arr[j]){
					swap(arr[i],arr[j]);
					i++;j--;
				}else if(arr[i] < arr[j]){
					i++;
				}else if(arr[i] ==  arr[j]){
					j--;
				}
			}
			
			printArr(arr, len);
			return 0;
		}

	-sort 0's, 1's & 2's:
		remain.. ❌
---------------------------------------------------------------------------------------------------------
	10/08/23
Lecture-11:
	Time & Space Complexity, How to avoid Time Limit Exceeded [TLE]
		Time Complexity:
			-It is the amount of time taken by an algorithm to run, as function of length of input.
			-the computational complexity that describes the amount of computer time it takes to run an algorithm. or
			-The Time Complexity of an algorithm/code is not equal to the actual time required to execute a particular code, 
			 but the number of times a statement executes.

			-we use time/space complexity for making better programs.
			-using these terms, we can decide algorithm is fast or slow.
			-It represented in 3 forms,
				1). Big O - Upper bound, (at max this much time program will take). worst case scenario
				2). Theta θ - Average, average case scenario.
				3). Omega Ω - Lower bound (at minimum, this much amount of time program will take) best case scenario.
			
			-Time:
				1) Constant time O(1).
				2) Linear time O(n).
				3) Logarithmic time O(log n).
				4) Quadratic time O(n²).		(nested loops)
				5) Cubic time O(n³).		(nested nested loops)

				chart: 
						O(N!)			--maximum time takes.
						O(2ⁿ)
					↑	O(n³)
					↑	O(n²)
					↑	O(n log(n))
					↑	O(n)
					↑	O(log(n))
					↑	O(1)			--minimum time takes.
			eg.
				-ignore constant, choose highest degree in equation.
					f(n) = 2n² + 3n 
					->
						O(n²)
					f(n) = 4n⁴ + 3n³
					->
						O(n⁴)
					
					f(n) = n² + log(n)
					-> O(n²).

					f(n) = 120043
					->
						O(1).
					
					f(n) = 5n³ + 3n² + 5
					->
						O(n³)
					
					f(n) = n³ / 300
					->
						O(n³)
					
					f(n) = 5n² + log(n)
					->
						O(n²)
					
					f(n) = n/4
					->
						O(n)				(Linear Time complexity)
					
					f(n) = (n+4)/4
					->
						O(n)				(Linear Time complexity)

				-Take this function to find its time complexity:
					void printArr(int a[], int n){
						for(int i=0;i<n; i++){
							cout<<a[i] << "\t";
						}
						cout<<"\n";
					}
					->
						here the length of array is n, so time depends length of array,
						so 
						Time Complexity will be O(n).
				
				-for calculating time complexity, if 2 for loops are there which are nested then their last
				value will be multiplied with eachother,
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements
					->
						time complexity: n*n  = O(n²);
					
				-if 2 for loops are there which are next to each other then we add their last value;
					for(int i=0;i<n; i++) ->	O(n)
						//statements
					
					for(j=0;j<m;j++)		-> O(m)
						//statements
					
					Time Complexity = O(n+m)

				-for this?
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements		// O(n²)
					
					for(j=0;j<n;j++)			// O(n)
						//statements
					
					= O(n²) + O(n)
					Time Complexity = O(n²)
				
				-for this?
					for(i=0;i<n;i++)			//this loop will run till (n-1)	ie.	O(n)
						for(j=n;j>i;j--)		//suppose i=0 then, this loop will run n to 0, ie. O(n)
							//statements		
					
					Time Complexity = O(n²)

		Space Complexity:
			-The total amount of memory space used by an algorithm/program, including the space of input values for execution.
			-The space complexity of an algorithm or a computer program is the amount of memory space required to solve an instance 
			 of the computational problem as a function of characteristics of the input. 
			 It is the memory required by an algorithm until it executes completely.
			-This includes the memory space used by its inputs, called input space, and any other (auxiliary) memory it uses during execution, 
			 which is called auxiliary space.

			-Similar to time complexity, space complexity is often expressed asymptotically in big O notation, such as O(n), O(n long(n)), 
			eg.
				-if we mention the array size then its fixed space complexity O(1).
				-if we declare any variable, it will take fixed space, so space Complexity O(1).
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-12:
	Binary Search:
		Binary search is applied only in list/ array where the data is sorted, 
		 either in increasing or in decreasing order, called monotonic function.
		Steps for Binary Search :
		1. Find middle element of the given array.
			If the value found at mid index is equal to key, return true else,
		2. if key >  mid,
			then go left side of the array by start = mid+1 to end is same.
		3. if Key <  mid,
			then go right side of the array from start is same & end = mid -1
		3. If key not found after searching whole array, return false.

		--here in case of binary search the Time Complexity is O(log(n)), where n is length of array.
		--because for every next iteration the array size is getting half,
		  for first len/2
		  for 2nd len/4
		  for 3rd len/8, like len/2¹, len/2², len/2³,... len/2ⁿ
		  len/2ⁿ = 1
		  len = 2ⁿ
		  n = log₂(len) 

		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[],int size){
				for(int i=0;i<size;i++){
					cout<<a[i]<<" ";
				}
				
				std::cout << std::endl;
			}

			int BinarySearch(int b[], int len, int key){
			
				int start = 0, end = len-1;
				
				//int mid = (start+end)/2;
				
				int mid = start + (end - start)/2;
    
				//sometimes array length is too large that start & end index is of (2³¹ - 1) & (2³¹ - 1) 
				//then their addition will be out of range of integer
				
				// so to avoid this issue we can use this formula,			

				while(start <= end){
					
					if(b[mid] == key)
						return mid;
					else if(key > b[mid])
						start = mid+1;
					else
						end = mid-1;
						
					mid = start + (end - start)/2;
				}
				return -1;
			}

			int main()
			{
				int Even[] = {2,4,6,8,12,14,16,22,28,30};
				int Odd[] = {1,3,5,9,13,17,41,43,59,55,69};
				
				cout<<"Even array: ";
				printArr(Even,10);
				
				
				cout<<"Odd array: ";
				printArr(Odd,11);
				
				int element;
				std::cout << "Enter element you want to find in Even array: " << std::endl;
				cin>>element;
				
				std::cout << element << " is at " << BinarySearch(Even, 10, element) << " Index." << std::endl;
				
				std::cout << "Enter element you want to find in Odd array: " << std::endl;
				cin>>element;
				std::cout << element << " is at " << BinarySearch(Odd, 11, element) << " Index." << std::endl;
				
				std::cout << "--END--" << std::endl;
			}
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-13:
	Questions on BinarySearch
	#Pair in C++ Standard Template Library (STL)
		-Pair is used to combine together two values that may be of different data types. 
		-Pair provides a way to store two heterogeneous objects as a single unit. 
		-It is basically used if we want to store tuples. 
		-The pair container is a simple container defined in <utility> header consisting of two data elements or objects. 

		-The first element is referenced as ‘first’ and the second element as ‘second’ and the order is fixed (first, second).
		-Pair can be assigned, copied, and compared. 
		-The array of objects allocated in a map or hash_map is of type ‘pair’ by default in which all the ‘first’ elements are unique keys associated with their ‘second’ value objects.
		-To access the elements, we use variable name followed by dot operator followed by the keyword first or second.
		Syntax: 
			pair <data_type1, data_type2> Pair_name
			eg.
				#include <iostream>
				#include <utility>
				using namespace std;
				int main()
				{
					// defining a pair
					pair<int, char> PAIR1;

					// first part of the pair
					PAIR1.first = 100;

					// second part of the pair
					PAIR1.second = 'G';

					cout << PAIR1.first << " ";
					cout << PAIR1.second << endl;

					// defining a pair
					pair<string, double> PAIR2("GeeksForGeeks", 1.23);
					
					cout << PAIR2.first << " ";
					cout << PAIR2.second << endl;

					return 0;
				}
				ouput:	100 G

				Initializing a Pair: We can also initialize a pair. 
					Syntax:
						pair <data_type1, data_type2> Pair_name (value1, value2) ;
					
					Different ways to initialize pair:  

						pair  g1;         //default
						pair  g2(1, 'a');  //initialized,  different data type
						pair  g3(1, 10);   //initialized,  same data type
						pair  g4(g3);    //copy of g3
						
						Another way to initialize a pair is by using the make_pair() function. 
							g2 = make_pair(1, 'a');

						Another valid syntax to declare pair is:
							g2 = {1, 'a'};
							pair<int, int> p1 {a,b};		
							pair<int, int> p1 = {a,b};
							eg.
								#include <iostream>
								using namespace std;

								int main(){
									int a = 10,b =20;

									pair<int, int> p1 {a,b};
									pair<char, string> p2('A',"First Alphabet");
									
									std::cout << p1.first<<" ";                     //10 20
									std::cout << p1.second << std::endl;
									
									std::cout << p2.first <<" ";                    //A First Alphabet
									std::cout << p2.second << std::endl;
									
									
									return 0;
								}

				Note: If not initialized, the first value of the pair gets automatically initialized. 
				
					#include <iostream>
					#include <utility>
					using namespace std;
					int main()
					{
						pair<int, double> PAIR1;
						pair<string, char> PAIR2;
						
						// it is initialised to 0
						cout << PAIR1.first;
						
						// it is initialised to 0
						cout << PAIR1.second;
						
						cout << " ";
						
						// it prints nothing i.e NULL
						cout << PAIR2.first;
							
						// it prints nothing i.e NULL
						cout << PAIR2.second;
						
						return 0;
					}
				-for more example Visit GFG pair
					1)swap
					2)make_pair
					3)tie

	1)Find the First & Last occurence of element in array:
		//Linear search method
			#include <bits/stdc++.h> 
			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				int i;
				int len = arr.size();

				for(i=0; i< len;i++){
					if(k == arr[i]){
						ans.first = i;
						break;
					}
				}
				
				if(i == len)
					ans.first = -1;
				

				for(i=len-1; i>-1; i--)
				{
					if(k == arr[i]){
						ans.second = i;
						break;
					}
				}

				if(i == -1)
					ans.second = -1;

				return ans;
			}

		//Binary search method
			#include <bits/stdc++.h> 
			int firstOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						e = mid -1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			int lastOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						s = mid + 1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				ans.first = firstOcc(arr, n, k);
				ans.second = lastOcc(arr, n, k);
				return ans;
			}

	example:To find the total no.of occurence of key in sorted array
		find the first/start index & last/end index, then 
		no.of occurence = (last - first)+1;
		eg.
			1 2 3 4 4 4 4 4 5 6 7
			--here 4's first index is 3 & last index is 7
			 so 7-3+1 = 5
			-no.of occurence of 4 is 5 times.
		
	2)Peak Index in Mountain Array:
		https://leetcode.com/problems/peak-index-in-a-mountain-array/
		//Linear or Brute force  algorithm			//TC- O(n)
			int peakIndexInMountainArray(vector<int>& arr) {
				int temp = arr[0], ans=0;
				for(int i=1; i< arr.size(); i++){
					if(temp < arr[i]){
						ans = i;
						temp = arr[i];
					}   
				}
				return ans;
			}
		
		//using Binary Search algorithm
			int peakIndexInMountainArray(vector<int>& arr) {
				int s=0, e= arr.size()-1;
				int mid = (s+e)/2;
				
				while(s < e){
					if(arr[mid] < arr[mid+1]){
						s = mid +1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}
				return e;
			}

	3)Find Pivot Index: HW
		-Left side summation & right side summation must be same then return the index of that element.
		//Linear search method:
			https://leetcode.com/problems/find-pivot-index/description/
			int pivotIndex(vector<int>& nums) {
				int left=0,right=0;
				int i=0;
				for(;i<nums.size(); i++){

					//for rightSide
					for(int j=i+1; j<nums.size(); j++){
						right += nums[j]; 
					}

					//for leftSide
					for(int k=0; k<i; k++){
						left += nums[k];
					}

					if(left == right)
					{
						break;
					}
					right=0; left=0;
				}

				if(i == nums.size())
						return -1;
				return i;
			}
---------------------------------------------------------------------------------------------------------
	13/08/23
Lecture-14:
	Binary Search Interview Questions | Problem set-2
		Find the pivot in sorted & rotated array,
		eg.
			sorted array : [1,2,3,4,5,6,7,8,9];	
			rotated array by 3 in right direction : [7,8,9,1,2,3,4,5,6];
		-finding pivot in it,
			-> The minimum value in array is a pivot element.
		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[], int L){
				for(int i=0;i<L;i++){
					cout<<a[i]<<" ";
				}
				std::cout << std::endl;
			}

			int main()
			{
				int arr[] = {4,5,6,7,8,9,10,1,2,3};
				int len = 10;

				std::cout << "The array is : " << std::endl;
				printArr(arr, len);

				int s=0, e=len-1;
				int mid = (s+e)/2;

				while(s < e){
					if(arr[mid] >= arr[0]){
						s = mid + 1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}

				cout<<"The pivot Element is at location/index :"<<s<<" or at "<<e;
				return 0;
			}

		1). Search K In Rotated Sorted Array

			//Linear way O(n) time complexity,
				int search(vector<int>& arr, int n, int k)
				{
					// Write your code here.
					// Return the position of K in ARR else return -1.
					int i=0;
					for(;i<arr.size();i++){
						if(k == arr[i]){
							return i;
						}
					}

					if(i == arr.size())
						return -1;
				}

			//Using Binary search O(log(n)) Time complexity,
				int BinarySearch(vector<int>& arr, int start, int n, int key){
					int s = start, e= n-1;
					int mid= (s+e)/2;
					
					while(s <= e){
						if(arr[mid] == key){
							return mid;
						}else if(key > arr[mid]){
							s = mid + 1;
						}else{
							e = mid -1;
						}
						mid = (s+e)/2;
					}
					return -1;
				}

				int pivotFind(vector<int>& arr, int len){
					
					int s=0, e = len-1;
					int mid = (s+e)/2;

					while(s < e){
						if(arr[mid] > arr[0] ){
							s = mid +1;
						}else{
							e =mid;
						}
						mid = (s+e)/2;
					}
					return s;
				}

				int search(vector<int>& arr, int n, int k){
					// Return the position of K in ARR else return -1
					int pivot = pivotFind(arr, n);
					
					if(arr[0] <= k && k <= arr[pivot-1]){
						//first line from start to till pivot
						return BinarySearch(arr, 0, pivot, k);        
					}else{
						// second line from pivot to till end.
						return  BinarySearch(arr, pivot, n, k);
					}				
				}

		2). Square Root of a number
			//Linear Search, not optimized
				int floorSqrt(int n){
					for(int i=1;i<=n/2;i++){
						if(n == pow(i,2)){
							return i;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
				}

			//using BinarySearch optimized
				int floorSqrt(int n){
					int s=0, e = n;
					long long int mid = (s+e)/2;
					long long int sqr;
					long long int ans;

					while(s <= e){
						sqr = mid * mid;
						if(sqr == n){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid -1;
						}else{
							ans = mid;
							s = mid +1;
						}
						mid = (s+e)/2;
					}
					return ans;
				}

		3). Sqrt(x):
			//Linear search not optimized
				int mySqrt(int n) {
					int i=0;
					for(;i<=n;i++){

						if(n == pow(i,2)){
							break;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
					return i;
				}
			
			//using BinarySearch 
				int mySqrt(int n) {
					int s=0, e =n;
					long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
					long long int ans;
					long long int sqr;

					while(s <= e){
						sqr = mid * mid;
						if(n == sqr){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid-1;
						}else{
							ans = mid;
							s=mid+1;
						}
						mid = (s+e)/2;
					}
					return ans;  
				}

		4). Square Root with decimal precision:
			#include <iostream>
			using namespace std;
			long long int SQRTn(int n){
				int s=0, e =n;
				long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
				long long int ans;
				long long int sqr;

				while(s <= e){
					sqr = mid * mid;
					if(n == sqr){
						ans = mid;
						break;
					}else if(sqr > n){
						e = mid-1;
					}else{
						ans = mid;
						s=mid+1;
					}
					mid = (s+e)/2;			//or mid = s + (e-s)/2;
				}
				return ans;
			}

			double morePrecision(int n, int uptoDecimal, int sqrtNum){

				double factor=1;
				double ans= sqrtNum;

				for(int i=0; i< uptoDecimal; i++){
					factor = factor/10;

					for(double j=sqrtNum; j*j < n; j = j + factor){
						ans = j;
					}
				}
				return ans;
			}

			int main(){
				int n;
				cout<<"Enter n";
				cin>>n;

				int sqrt1 = SQRTn(n);
				cout<<"answer is upto 4 decimal precision ::"<< morePrecision(n, 4, sqrt1);
				return 0;	
			}
---------------------------------------------------------------------------------------------------------
	14/08/23
Lecture-15:
	Book Allocation Problem || Aggressive Cows Problem || Binary Search Advanced Problems
		1). Book Allocation:
			HW- https://www.codingninjas.com/studio/problems/allocate-books_1090540
		2). Painter partition
			HW.
		3). Aggressive cows

	COME BACK TO THIS LECTURE AGAIN. ❌
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-16: Selection Sort
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1;i++){
			int minIndex = i;
			for(int j=i+1; j<n;j++){
				if(arr[j] < arr[minIndex])
					minIndex = j;
			}
			swap(arr[minIndex],arr[i]);
		}
	}

	//or
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1; i++){
			for(int j=i+1;j<n;j++){
				if(arr[i] > arr[j])
					swap(arr[i],arr[j]);
			}
		}
	}

	//or
	#include <bits/stdc++.h> 
	void selectionSort(vector<int>& arr, int n){
		int i,j;
		for(i=0;i<n-1;i++)
			for(j=i+1; j<n; j++)
				if(arr[i]> arr[j])
					swap(arr[i], arr[j]);
	}

		-for Selection Sort program,
			Space complexity:	O(1).
			Time complexity: O(n²);		
		
		-Use case:
			if given array/vector size is small then we can go for Selection sort.
		
		HW
			-Flowchart : 
			-Stable & unstable algorithm

	Practice:
		#include <iostream>
		using namespace std;
		void printArray(int [], int);		//or void printArray(int anyName[], int)	or if you don't give name to array still its fine, its just function declaration.

		int main()
		{
			int arr[] = {55,44,33,32,11,22,57,90,87,76,65,1};
			//1,11,22,32,33,44,55,57,65,76,87,90
			
			int len = 12;
			
			printf("Before Sorting :: \n");
			printArray(arr, len);
			
			int minValueIndex = arr[0];
			
			//sorting array,
			for(int i=0; i<len-1; i++){
				for(int j=i+1; j < len; j++)
					if(arr[minValueIndex] > arr[j])
						minValueIndex = j;
				
				//after getting the minimum value's index swap it, 
				swap(arr[i],arr[minValueIndex]);
			}
			printf("\nAfter Sorting :: \n");
			printArray(arr, len);

			return 0;
		}

		void printArray(int brr[], int len){
			for(int i=0;i<len;i++)
				printf("%d ",brr[i]);
		}
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-17: BUBBLE SORT
	-Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. 
	-This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.
	Bubble Sort Algorithm
		In this algorithm,
		-traverse from left and compare adjacent elements and the higher one is placed at right side. 
		-In this way, the LARGEST element is moved to the rightmost end at first, at the end of array. 
		-This process is then continued to find the second largest and place it and so on until the data is sorted.
		
		Advantages of Bubble Sort:
			-Bubble sort is easy to understand and implement.
			-It does not require any additional memory space.
			-It is a stable sorting algorithm, 
			 meaning that elements with the same key value maintain their relative order in the sorted output.

		Disadvantages of Bubble Sort:
			-Bubble sort has a time complexity of O(n²) which makes it very slow for large data sets.
			-Bubble sort is a comparison-based sorting algorithm, 
			 which means that it requires a comparison operator to determine the relative order of elements in the input data set. 
			 It can limit the efficiency of the algorithm in certain cases.

	QnA:
		-In Bubble Sort, after each pass, the largest element among the unsorted elements "bubbles up" to which position?
		-> Last

		-main drawback of the Bubble Sort algorithm?
		->It has a high time complexity. ie. O(n²).

		-space complexity:
			O(1), haven't created a dynamic variable so no space complexity.

		-true regarding Bubble Sort?
		->It is an in-place sorting algorithm.
		Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. 
		Hence Bubble sort algorithm is an in-place algorithm.

		-Bubble Sort is an example of a sorting algorithm that:
		->Swaps adjacent elements directly

		-Bubble Sort is an example of a ______ sorting algorithm.
		->Comparison - based

		-worst-case time complexity of the Bubble sort Algorithm?
		->O(n²)

		-What is the maximum number of comparisons that can take place when a bubble sort algorithm is implemented?, 
		suppose there are n elements in the array.
		->	(n*(n-1))/2

		-The number of swappings needed to sort the numbers 8, 22, 7, 9, 31, 5, 13 in ascending order, using bubble sort is,
		->10

		-Assume that we use Bubble Sort to sort n distinct elements in ascending order. When does the best case of Bubble Sort occur?
		->When elements are sorted in ascending order
		the time complexity of bubble sort in the BEST-CASE scenario is O(n).

	eg.
		#include <bits/stdc++.h> 
		void bubbleSort(vector<int>& arr, int n){
			for(int i=0;i<n-1; i++)
				for(int j=0; j<n-1;j++)				//here covering the last element looping from start to till end.
					if(arr[j]> arr[j+1])
						swap(arr[j],arr[j+1]);
		}

		//or neglecting the last element as it is already sorted,
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++)					
					for(int j=0; j<n-i;j++)				//here ignoring the last element from start to till n-1.
						if(arr[j]> arr[j+1])
							swap(arr [j],arr[j+1]);
			}
		
		//optimizing more.., 
		 in a random round there is no any swapping done, then we can consider that it's sorted.
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++){
					bool isSwappingOn = false;

					for(int j=0; j<n-i;j++)
						if(arr[j] > arr[j+1]){
							swap(arr [j],arr[j+1]);
							//swapping on..
							isSwappingOn = true;
						}
					if(isSwappingOn == false)
						break;        
				}
			}
		
	HW:
		stable or unstable bubble sort?
		in-place sort
---------------------------------------------------------------------------------------------------------
	16/08/23	
Lecture-18: INSERTION SORT
	Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. 
	The array is virtually split into a sorted and an unsorted part. 
	Values from the unsorted part are picked and placed at their correct position in the sorted part.

	-shifting of element done here.
	-https://www.geeksforgeeks.org/insertion-sort/

	-code:
		#include <bits/stdc++.h> 
		void insertionSort(int n, vector<int> &arr){
			for(int i=1; i<n; i++){
				int temp = arr[i],j;
				for(j=i-1; j>=0; j--){
					if(temp< arr[j]){
						//shifting
						arr[j+1] = arr[j]; 
					}else{
						break;
					}
				}
				arr[j+1] = temp;
			}
		}

	Characteristics of Insertion Sort
		-This algorithm is one of the simplest algorithms with a simple implementation
		-Basically, Insertion sort is efficient for small data values
		-Insertion sort is adaptive in nature, i.e. it is appropriate for data sets that are already partially sorted.

	-insertion sort is a STABLE sorting algorithm.
	-insertion sort is a ADAPTABLE sorting algorithm.
	-Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, 
	 and only a few elements are misplaced in a complete big array.
	
	Time complexity:
		O(n²)
		-Best-Case : O(n);
		-Worst-case: O(n²)
	space complexity:
		O(1)
---------------------------------------------------------------------------------------------------------
	17/08/23
Lecture-19: C++ STL (Standard Template Library)
	-Algorithm
	-Containers

	1) STD::array in C++:
		The array is a collection of homogeneous objects and this array container is defined for constant size arrays or (static size). 
		This container wraps around fixed-size arrays and the information of its size are not lost when declared to a pointer. 
		In order to utilize arrays, we need to include the array header:
			#include <array>

			Syntax:
				array<object_type, arr_size> arr_name;

			a)[] Operator : This is similar to the normal array, we use it to access the element store at index ‘i’ .
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <char , 3> arr={'G','f','G'};
						cout<<arr[0] <<" "<<arr[2];			//G G
						return 0;
					}
			
			b) front( ) and back( ) function: 
				-These methods are used to access the first and the last element of the array directly.
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				
			c) swap( ) function: 
				-This swap function is used to swap the content of the two arrays.
					Ex: 
					#include <iostream>
					#include <array>
					using namespace std;
				
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						arr.swap(arr1);  // now arr = {M,M,P}
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				eg.
					#include <iostream>
					#include<array>
					using namespace std;

					int main()
					{
						//double or single braces works fine.
						array<int, 5> a {1,2,3,4};
						array<int, 5> b {{10,20,30,40,150}};
						array<int, 5> c {1,2,3,4,5};
						
						cout<<"A:\n";
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nB : " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
							
						a.swap(b);
						std::cout << "\nAfter swapping: Array A:  " << std::endl;
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nAfter swapping: Array B:  " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
					}

			d)empty(): to check array is empty or not
				first need to cout boolalpha then after print the boolean value, if you print boolean values 
				before cout boolalpha then it will printed like 0,1.
				eg.
					bool x = arr.empty(); // false ( not empty)
					cout<<boolalpha;		//or cout<<boolalpha<<(x);				
					bool y = 1;
					cout<<y;
					cout<<"\n"<<x;

				-boolalpha is a manipulator used in C++ for the std::cout stream (the standard output stream) 
				to display boolean values as their corresponding textual representations "true" or "false," 
				rather than as integer values 1 or 0.
			
			e) at() function: 
				This function is used to access the element stored at a specific location, 
				if we try to access the element which is out of bounds of the array size then it throws an exception. 
				Ex: 
					#include <iostream>
					#include <array>
					using namespace std;

					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						cout<< arr.at(2) <<" " << arr1.at(2);
						//cout<< arr.at(3); // exception{Abort signal from abort(3) (SIGABRT)}
						return 0;
					}
					Output
						71 80

			f) fill( ) function: 
				This is specially used to initialize or fill all the indexes of the array with a similar value.
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 5> arr;
						arr.fill(1);
						for(int i: arr)
							cout<<arr[i]<<" ";
						return 0;
					}
						Output
						1 1 1 1 1 

			g) size( ) or max_size( ) and sizeof( ) function: 
				Both size( ) or max_size( ) are used to get the maximum number of indexes in the array 
				while sizeof( ) is used to get the total size of array in bytes.

				#include <iostream>
				#include <array>
				using namespace std;				
				int main() {
					array <int , 10> arr;   
					cout<<arr.size()<<'\n'; // total num of indexes
					cout<<arr.max_size()<<'\n'; // total num of indexes
					cout<<sizeof(arr); // total size of array
					return 0;
				}
				Output
					10
					10
					40

		eg.
			#include <iostream>
			#include <array>
			using namespace std;

			int main()
			{
				int arr[] = {1,2,3};            //static array
							
				array<int, 4> a = {1,2,3,4};        //this is also static array
				
				std::cout << "Size : "<< a.size() << std::endl;     //to get the length of array    //Size : 4
				
				//printing the array element
				for(int i: a){
					cout<<i<<"\t";              //1       2       3       4
				}
				std::cout << std::endl;
				
				for(int it=0; it<a.size(); it++)
					cout<<a[it]<<" ";               //1       2       3       4
					
				//First last element of array
				std::cout << "\n\n First element of array A :: "<< a.front() << endl;           //  First element of array A :: 1
				std::cout << " Last element of array A :: "<< a.back()<<endl;                   //   Last element of array A :: 4
				
				//random index of array
				std::cout << "\n3rd index : "<< a[3] << std::endl;                  // 3rd index : 4
				std::cout << "2nd index : "<< a.at(2) << std::endl;                 // 2nd index : 3
				
				//checking the array is empty or not?
				cout<<"Array A is empty : "<<a.empty();                         // array is not empty so, Array A is empty : 0
				
				return 0;
			}

		eg.
			#include <iostream>
			#include<array>

			//for sorting algorithm need to include,
			#include <algorithm>
			using namespace std;

			int main()
			{
				//double or single braces works fine.
				array<int, 5> a {1,2,3,4};
				array<int, 5> b {{1,2,3,4,15}};
				array<int, 5> c {1,2,3,4,5};
				
				//printing array
				for(auto i: a){
					std::cout << i <<" ";
				}
				std::cout << std::endl;
				
				for(auto i: b){
					printf("%d ",i);
				}
				
				
				//sort
				std::cout << std::endl;
				array<int, 5> d = {5,4,3,2,1};          //equal sign with single braces.
						
				for(auto i: d)
					cout<<i<<" ";
					
				std::cout  << std::endl;
				
				//after sorting
				sort(d.begin(), d.end());
				
				
				//if you just try to print the begin() function on array it will print the memory location of that array
				//so to print the element at that address Use asterisk.
				
				cout<<"Beging memory address: "<<d.begin()<<"\n";
				cout<<"starting element: "<<*d.begin()<<"\n";
				
				cout<<"End: "<<*d.end()<<"\n";
				
				for(auto i: d)
					cout<<i<<" ";
					
				array<int, 3> e = {{}};         //equal sign with double braces.
				
				
				//by default array e gets initialized with 0.
				cout<<"\n";
				for(int o: e){
					cout<<o<<" ";
				}
				
				
				//initializing array e with default specific element with 97,
				cout<<"\n";
				e.fill(97);
				for(auto i: e)
					cout<<i<<" ";
					
				//initializing string array
				cout<<"\n";
				array<string, 5> strings {"Vivek","Nikate","a","b"};
				
				for(string s: strings)
					cout<<s<<"\t";
					
				//printing string array
				cout<<"\n";
				for(auto s: strings)
					cout<<s<<"\t";

				return 0;
			}

	2) Vector:
		-It's a dynamic array.
		-Vectors are the same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, 
		 with their storage being handled automatically by the container. Vector elements are placed in contiguous storage 
		 so that they can be accessed and traversed using iterators. 
		 In vectors, data is inserted at the end. Inserting at the end takes differential time, 
		 as sometimes the array may need to be extended. Removing the last element takes only constant 
		 time because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.
		 
					vector::push_back() 								|	vector::pop_back()
				It is used to add a new element at the end of the vector. 		|	It is used to remove a new element at the end of the vector.
				Its parameter is the value we want to add in the end of vector. 	|	It does not take any parameters.
				It does not have any return type.							|	It does not have any return value.
				Its complexity is constant.								|	Its complexity is constant.
				`container.push_back(element);							| 	container.pop_back();
			Container-    Vector, Deque, List, etc. 						| 	Vector, Deque, List, etc..
			Effects  -    Increases container size by 1 						|	 Decreases container size by 1.


		-std::vector in C++, It is defined inside the <vector> header file.

		Reverse Vector:
			#include <iostream>
			#include<vector>
			// this algorithm header file is for reverse method,
			#include <algorithm>
			using namespace std;

			int main()
			{
				vector<int> v {10,9,8,7,6,5,4,3,2,1};
				std::cout << "Size "<< v.size() << std::endl;       //Size 10
				
				for(auto i: v)
					cout<<i<<" ";                               // 10 9 8 7 6 5 4 3 2 1 
					
				reverse(v.begin(), v.end());
				
				cout<<"\n After reversing: ";
				for(auto i: v)
					cout<<i<<" ";                               // After reversing: 1 2 3 4 5 6 7 8 9 10 

				return 0;
			}

			//Initialize an array with consecutive numbers using std::iota

				#include <iostream>
				#include <vector>
				#include<numeric>               //for iota 
				#include<algorithm>             //for reversing
				using namespace std;
				int main(){
					vector<int> v(10);
					
					iota(v.begin(), v.end(), 9);        // from 9 to 18
					
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 14 15 16 17 18
						
					reverse(v.begin()+5,v.end());       //reverse after 5th index
					
					cout<<"\n";
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 18 17 16 15 14
					
					return 0;
				}

		Practice:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main()
			{
				vector<int> v;
				
				//Capacity- means how many elements it can contain.
				//Size- means how many elements it is containing/ contained now.
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;
				std::cout << "Size- "<<v.size() << std::endl;
				
				v.push_back(1);
				v.push_back(2);
				v.push_back(3);
				v.push_back(4);
				v.push_back(5);
				v.push_back(48);
				v.push_back(45);
				
				v.push_back(18);
				v.push_back(345);
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //capacity gets double everytime if size is greater than capacity value.
					std::cout << "Size- "<<v.size() << std::endl;                   //9
				
				for(auto i: v)
					cout<<i<<" ";
					
				std::cout << "\nAfter Popping last element : " << std::endl;
				v.pop_back();
				
				for(auto i: v)
					cout<<i<<" ";
					
				v.clear();
				
				std::cout  << std::endl;
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //after clearing also capacity is same.
				std::cout << "Size- "<<v.size() << std::endl;                   //size reduce back to 0.
				return 0;
			}

		-vector initialization:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> a;      //size=0
				std::cout << a.size() << std::endl;
				
				vector<int> b(5);   //size=5, but all element are by default initialized to 0.
				std::cout << b.size() << std::endl;
				
				for(auto i:b)
					cout<<i<<" ";
					
				//vector with initializing default value,
				//vector<DataType> VectorName(size, defaultValue);
				vector<int> c(10, 580);     //10 element having all value 580.
				
				cout<<"\n";
				for(int i: c)
					cout<<i<<" ";
					
				//copying vector from another
				vector<int> d(c);        //copying vector c to d.
				
				cout<<"\n vector D: ";
				for(int i: d)
					cout<<i<<" ";
				
				//inserting value to specific index,
				cout<<"\n";
				
				d.insert(d.begin(),34);     //at start
				d.insert(d.begin()+4,23);     //at 4th index
				
				cout<<"\n vector D After insertion: ";
				for(int i: d)
					cout<<i<<" ";
					
					//inserting specific no.of same element to vector  
					cout<<"\n vector e :";
				vector<int> e(5,4);
				for(int i: e)
					cout<<i<<" ";
				
				std::cout<<"\nAfter insertion 99 in vector e: " << std::endl;
				//vector_name.insert(position, size (no.of times to be inserted), val (defaultValue) )
				e.insert(e.begin()+2, 5, 99);              //inserting 780, 5 times after 2nd index.
				
				for(int i: e)
					cout<<i<<" ";

				return 0;
			}

		eg.
			#include <iostream>
			#include <vector>

			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 5; i++)
					g1.push_back(i);						//inserting element into the vector.

				cout << "Output of begin and end: ";
				for (auto i = g1.begin(); i != g1.end(); ++i)
					cout << *i << " ";						//Output of begin and end: 1 2 3 4 5 

				cout << "\nOutput of cbegin and cend: ";
				for (auto i = g1.cbegin(); i != g1.cend(); ++i)
					cout << *i << " ";						//Output of cbegin and cend: 1 2 3 4 5 

				cout << "\nOutput of rbegin and rend: ";
				for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir)
					cout << *ir << " ";						//Output of rbegin and rend: 5 4 3 2 1 

				cout << "\nOutput of crbegin and crend : ";
				for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir)
					cout << *ir << " ";						//Output of crbegin and crend : 5 4 3 2 1

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 10; i++)
					g1.push_back(i * 10);

				cout << "\nReference operator [g] : g1[2] = " << g1[2];			//Reference operator [g] : g1[2] = 30

				cout << "\nat : g1.at(4) = " << g1.at(4);                   //element at 4th index (means 0-based indexing so 5th)
				//at : g1.at(4) = 50

				cout << "\nfront() : g1.front() = " << g1.front();          //first element
				//front() : g1.front() = 10

				cout << "\nback() : g1.back() = " << g1.back();             //last element
				//back() : g1.back() = 100

				// pointer to the first element
				int* pos = g1.data();           //storing the base address of vector g1 here.

				cout << "\nThe first element is " << *pos;          //accessing first/base element
				//The first element is 10
				
				cout << "\nThe 9th element is " << *(pos+8);
				//The 9th element is 90

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			#include <vector>
			using namespace std;

			int main()
			{
				// Assign vector
				vector<int> v;

				// fill the vector with 10 five times
				v.assign(5, 10);

				cout << "The vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 15 to the last position
				v.push_back(15);
				int n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// removes last element
				v.pop_back();

				// prints the vector
				cout << "\nThe vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 5 at the beginning
				v.insert(v.begin(), 5);

				cout << "\nThe first element is: " << v[0];

				// removes the first element
				v.erase(v.begin());

				cout << "\nThe first element is: " << v[0];

				// inserts at the beginning
				v.emplace(v.begin(), 5);
				cout << "\nThe first element is: " << v[0];

				// Inserts 20 at the end
				v.emplace_back(20);
				n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// erases the vector
				v.clear();
				cout << "\nVector size after clear(): " << v.size();

				// two vector to perform swap
				vector<int> v1, v2;
				v1.push_back(1);
				v1.push_back(2);
				v2.push_back(3);
				v2.push_back(4);

				cout << "\n\nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";

				// Swaps v1 and v2
				v1.swap(v2);

				cout << "\nAfter Swap \nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";
			}
			Output:
				The vector elements are: 10 10 10 10 10 
				The last element is: 15
				The vector elements are: 10 10 10 10 10 
				The first element is: 5
				The first element is: 10
				The first element is: 5
				The last element is: 20
				Vector size after erase(): 0

				Vector 1: 1 2 
				Vector 2: 3 4 
				After Swap 
				Vector 1: 3 4 
				Vector 2: 1 2
		
		-Erase method:
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
					// Assign vector
				vector<int> v;
				
				// fill the vector with 10 five times
				v.push_back(10);
				v.push_back(20);
				v.push_back(30);
				v.push_back(40);
				v.push_back(50);
				
				for(auto i: v)
					std::cout << i << " ";
				
				v.erase(v.begin()+3);       //removing 4th element 40.
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
					
					v.erase(v.begin());     //removing first element
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
				
				return 0;
			}

		Time Complexity of Vector:
			-The time complexity for doing various operations on vectors is-
				Random access – constant O(1)
				Insertion or removal of elements at the end – constant O(1)
				Insertion or removal of elements – linear in the distance to the end of the vector O(N)
				Knowing the size – constant O(1)
				Resizing the vector- Linear O(N)

	3) Deque:
		-Doubly ended queue
		-Means you can perform insertion/Deletion (push/ pop) operation from both ends, front & back.
		-Its implementation is bit complex, it uses static array not on contiguous location
		-It is DYNAMIC.
		-Random Access of element is possible
		-The deque::max_size() is a built-in function in C++ STL,
		 which returns the maximum number of elements that a deque container can hold.
			Syntax:
				deque_name.max_size()

			Parameters: The function does not accept any parameters.
			Return Value: The function returns the maximum number of elements that a deque container can hold.
			eg.
				int main(){
					deque<int> dq;
					
					cout << "The max-size of deque: " << dq.max_size();			//The max-size of deque: 4611686018427387903	
					return 0;
				}
			
		eg.
			#include <iostream>
			#include<deque>
			using namespace std;

			int main()
			{
				deque<int> d;
				
				//inserting at ending,
				d.push_back(1);
				d.push_back(2);
				d.push_back(3);
				d.push_back(4);
				d.push_back(5);
				
				d.push_front(100);
				d.push_front(200);
				d.push_front(300);
				d.push_front(400);
				d.push_front(500);
				
				for(auto i: d)
					std::cout << i << " ";          //500 400 300 200 100 1 2 3 4 5 

				//Removing element from start       //500
				d.pop_front();
				
				//Removing element from back        //5
				d.pop_back();
				
				cout<<"\nAfter removal : \n ";
				for(auto i: d)
					std::cout << i << " ";                  // 400 300 200 100 1 2 3 4 
					
				//accessing first index element
				cout<<"\nFirst index element : "<<d[1];     //First index element : 300
				
				//using at()
				cout<<"\n4th index element : "<<d.at(4);    //4th index element : 1
					
				//start element
				std::cout << "\n Start element : "<< d.front() << std::endl;            //Start element : 400
				
				//end element
				
				std::cout << "End element : "<< d.back() << std::endl;                  //End element : 4
				
				std::cout << "deque empty? : "<<boolalpha<< d.empty() << std::endl;     //0 or false, its not empty.
				
				std::cout << "Deque Size : "<< d.size() << std::endl;                   //Deque Size : 8
				
				std::cout << "Capacity : "<< d.max_size() << std::endl;                 //Capacity : 2305843009213693951
				
				//Deleting range of elements from 3 to 5, 3rd & 4th only not 5th.
				d.erase(d.begin()+3, d.begin()+5);              //100 1
				
				cout<<"\nDeleted few elements: ";
				for(auto i: d)
					std::cout << i << " ";                  // Deleted few elements: 400 300 200 2 3 4 
				
				//Deleting all elements
				d.clear();
				std::cout << "\nDeque Size : "<< d.size() << std::endl;                   //Deque Size : 0

				return 0;
			}

	4) List:
		-Lists are sequence containers that allow non-contiguous memory allocation. 
		-As compared to the vector, the list has slow traversal, but once a position has been found, 
		 insertion and deletion are quick (constant time). 
		-Normally, when we say a List, we talk about a doubly linked list. For implementing a singly linked list, 
		 we use a forward_list.

		-std::list is the class of the List container. 
		-It is the part of C++ Standard Template Library (STL) and is defined inside <list> header file.
		-Random access is not possible.
		Points to Remember about List Container:-
			-It is generally implemented using a dynamic doubly linked list with traversal in both directions.
			-Faster insert and delete operation as compared to arrays and vectors.
			-It provides only sequential access. Random Access to any middle element is not possible
			-It is defined as a template so it is able to hold any data type.
			-It operates as an unsorted list would, which implies that by default, the list’s order is not preserved. However, there are techniques for sorting.

		Syntax:
			std::list <data-type> name_of_list;
			eg.
				list<int> L;
		
		eg.
			#include <iostream>
			#include <list>
			using namespace std;

			int main()
			{
				list<int> L;
				
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;          //The size of List :: 0

				
				L.push_back(90);            //insertion at back
				L.push_back(100);
				
				L.push_front(910);          //insertion at front side
				L.push_front(800);
				
				for(auto i:L)
					cout<<i<<" ";           //800 910 90 100 
					
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;      //The size of List :: 4
				
				std::cout << "\nThe max size of List :: "<< L.max_size();           //The max size of List :: 384307168202282325
				
				//deleting start element      //800
				//you can't delete random element coz list doesn't provide random access to element.
				
				L.erase(L.begin());
				cout<<"\n start element removed : ";            // start element removed : 910 90 100 
				for(auto i:L)
					cout<<i<<" ";
					
				//copy
				list<int> n(L);
				cout<<"\n copied list : ";
				for(auto i:L)
					cout<<i<<" ";                       //copied list : 910 90 100 
					
				//list with default value 0
				
				//list<DataType> list_name(size)
				list<int> a(5);         
				
				cout<<"\n List A: ";
				for(int i:a)
					cout<<i<<" ";           // List A: 0 0 0 0 0 
					
				//list<DataType> list_name(size, DefaultValue);
				
				list<int> b(7, 31);         
				
				cout<<"\n List B: ";
				for(int i:b)
					cout<<i<<" ";           //  List B: 31 31 31 31 31 31 31 
				
				L.clear();      //deleting all list element,
				cout << "\n The size of List AFTER CLEARING :: "<< L.size();            // The size of List AFTER CLEARING :: 0

				return 0;
			}

	5) Stack:
		-LIFO (Last In First Out).
		-new element is added at one end (top) and an element is removed from that end only.
		-Operations:
			push(), pop(), top(), size(), empty() all are having Time complexity of O(1)
		
		eg.
			#include <iostream>
			#include <stack>
			using namespace std;

			int main(){
				stack<string> stsr;
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        //Size of Stack :: 0
				
				stsr.push("Vivek");
				stsr.push("Mahesh");
				stsr.push("Saraswait");
				stsr.push("Rohini");
				stsr.push("Computer");
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;					//TOP element of stack : Computer
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        					//Size of Stack :: 5

				stsr.pop();
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;								//TOP element of stack : Rohini
				
				std::cout << "Stack empty? :: "<< stsr.empty() << " " << boolalpha <<stsr.empty() << std::endl;		//Stack empty? :: 0 false
				return 0;
			}

	6) Queue:
		-operate in a first in first out (FIFO) type of arrangement. 
		-Elements are inserted at the back (end) and are deleted from the front.
		-operations:
			push(), pop(), front(), back(), emplace(), size(), empty() all are have Time complexity of O(1).

		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				queue<string> sq;
				
				std::cout << "Size of Queue before insertion : "<< sq.size() << std::endl;
				
				sq.push("First");
				sq.push("Second");
				sq.push("Third");
				sq.push("Forth");
				
				std::cout << "Size of Queue After insertion : "<< sq.size() << std::endl;
				
				std::cout << "start element of Queue : "<< sq.front() << std::endl;
				
				std::cout << "Last element of Queue : "<< sq.back() << std::endl;
				
				sq.pop();
				
				std::cout << "start element After poping : "<< sq.front() << std::endl;
				
				std::cout << "Queue empty? : "<< boolalpha <<sq.empty() << std::endl;
				return 0;
			}

			//ouput:
				Size of Queue before insertion : 0
				Size of Queue After insertion : 4
				start element of Queue : First
				Last element of Queue : Forth
				start element After poping : Second
				Queue empty? : false

		emplace operation used to insert element in queue:{
			queue<char> myqueue;
			myqueue.emplace('k');
			myqueue.emplace('j');
			myqueue.emplace('y');
			myqueue.emplace('r');
			myqueue.emplace('y');
			myqueue.emplace('u');
			
			// queue becomes k, j, y, r, y, u
			
			while (!myqueue.empty())
			{
				cout << ' ' << myqueue.front();
				myqueue.pop();
			}
			return 0;
		}

	7) Priority Queue:
		https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/
		Time complexity:
			push(), pop() on priority queue is of O(logN).
			top(), size() & empty() are constant time operations O(1).
		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				priority_queue<int> pq;     //by default it creates max-heap(decreasing order).
				
				std::cout << "Size : "<< pq.size() << std::endl;        //Size : 0

				pq.push(1);
				pq.push(3);
				pq.push(5);
				pq.push(2);
				pq.push(4);
				
				std::cout << "First element : "<< pq.top() << std::endl;        //First element : 5
				int pqSize = pq.size();
				
				std::cout << "Size : "<< pqSize << std::endl;           //Size : 5

				for(int i=0;i<pqSize;i++){
					cout<<pq.top()<<" ";            //5 4 3 2 1 
					pq.pop();
				}
				
				//min heap increasing order
				priority_queue<int, vector<int>, greater<int>> min;
				
				min.push(100);
				min.push(200);
				min.push(400);
				min.push(300);
				min.push(500);
				
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty(); //Min priority_queue is empty ? 0
				int minSize= min.size();
				
				cout<<"\n Min elements : ";
				
				for(int i=0;i<minSize;i++){
					cout<<min.top()<<" ";                   //Min elements : 100 200 300 400 500 
					min.pop();
				}
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty();     //Min priority_queue is empty ? 1
				return 0;
			}

	8) Set:
		-Stores unique elements
		-The values are stored in a specific sorted order i.e. either ascending or descending.
		-By default, the std::set is sorted in ascending order.
		-The std::set class is the part of C++ Standard Template Library (STL) and it is defined inside the <set> header file.
		-Syntax:
			std::set <data_type> set_name;

		-we have the option to change the sorting order by using the following syntax.
		-Syntax:
			std::set <data_type, greater<data_type>> set_name;

		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values
		
		Properties-
			Storing order – The set stores the elements in sorted order.
			Values Characteristics – All the elements in a set have unique values.
			Values Nature – The value of the element cannot be modified once it is added to the set, 
						though it is possible to remove and then add the modified value of that element. Thus, the values are immutable.
			Search Technique – Sets follow the Binary search tree implementation.
			Arranging order – The values in a set are unindexed.
		Note: To store the elements in an unsorted(random) order,  unordered_set() can be used.
		-set is little slower than unordered_set.

		•The time complexities for doing various operations on sets are:
			-Insertion of Elements – O(log N)
			-Deletion of Elements – O(log N)
			-insert(), find(), erase(), count() -> O(long N)
			-size(), begin(), empty(), end() -> O(1).
		eg.
			#include <iostream>
			#include <set>
			using namespace std;
			int main(){
				std::set<char> a;
				a.insert('A');
				a.insert('B');
				a.insert('E');
				a.insert('D');
				a.insert('C');
				
				//repeated element will not be inserted again in set.
				a.insert('B');
				a.insert('A');
				
				
				//sorted increasing order,
				for (auto& str : a) {           //& sign used
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (auto str : a) {                //& not used still fine
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (char str : a) {                //dataType char used.
					std::cout << str << ' ';
				}
				
				set<int> inSt;
				inSt.insert(100);
				
				inSt.insert(1);
				inSt.insert(1);
				
				inSt.insert(2);
				
				inSt.insert(5);
				inSt.insert(5);
				
				inSt.insert(4);
				inSt.insert(200);
				
				cout<<"\n";
				for(int i: inSt)
				cout<<i<<" ";
				
				//Decreasing order set
				set<int, greater<int>> descSet;
				
				descSet.insert(0);
				descSet.insert(1);
				
				descSet.insert(3);
				descSet.insert(3);
				
				descSet.insert(4);
				
				
				descSet.insert(200);
				descSet.insert(200);
				descSet.insert(300);
				
				descSet.insert(400);
				
				descSet.insert(2);
				descSet.insert(2);
				
				//descSet 
				cout<<"\n";
				for(int i: descSet)
				cout<<i<<" ";
				
				//erasing
				set<int>::iterator IT = descSet.begin();
				IT++;
				IT++;
				
				descSet.erase(IT);
				cout<<"\n Erased 2nd element:";
				for(int i: descSet)
				cout<<i<<" ";
				
				//deleting 300 from set, directly passing element which want to delete.
				descSet.erase(300);
				cout<<"\n 300 erased: ";
				for(int i: descSet)
				cout<<i<<" ";
				
				cout<<"\n400 is present in descSet ? "<<descSet.count(400);
				cout<<"\n300 is present in descSet ? "<<descSet.count(300);
				
				cout<<"\ndescSet empty? "<<descSet.empty();

				cout<<"\ndescSet max_size? "<<descSet.max_size();
				cout<<"\ndescSet size? "<<descSet.size();
				
				descSet.clear();
				cout<<"\ndescSet empty? "<<descSet.empty();
				
				return 0;
			}
			//ouput:
				A B C D E 
				A B C D E 
				A B C D E 
				1 2 4 5 100 200 
				400 300 200 4 3 2 1 0 
				Erased 2nd element:400 300 4 3 2 1 0 
				300 erased: 400 4 3 2 1 0 
				400 is present in descSet ? 1
				300 is present in descSet ? 0
				descSet empty? 0
				descSet max_size? 230584300921369395
				descSet size? 6
				descSet empty? 1

	9) Map:
		-Stores data in form of key-value pair
		-all keys are unique, one key points to one value only.
		-same keys will not points to different value,
		-value of keys might be same.
		-keys stored in sorted order.
		-Time Complexity:
			insert(), erase(), find(), count() is O(log N).
		eg.

			#include <iostream>
			#include <map>
			using namespace std;

			int main(){
				map<int, string> m;
				std::cout << " Before, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;
				
				m[4] = "Vivek";
				m[70] = "Seven";
				m[80] = "EIGHT";
				m[3] = "Rohini";
				m[2] = "Nikate";
				m[1] = "Aai";
				m[50] = "papa";
				
				m.insert({-10,"Minus num"});
				m.insert({-11, "minus 11"});

				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";

				std::cout << "After, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;

				//key present
				std::cout << "4 key present? "<< m.count(4) << std::endl;
				std::cout << "40 key present? "<< m.count(40) << std::endl;

				//erase
				m.erase(2); //key 2 removed
				m.erase(-11); //key 2 removed
				
				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";
				
				cout<<"\n";
				//print all element after key 4.
				auto it = m.find(4);
				for(auto i=it; i != m.end(); i++)
					cout<<(*i).first<<" "<<(*i).second<<"\n";
				
				return 0;
			}

	10) STL Algorithm:
		sort() works on introsort, its combination of quick sort, heap sort & insertion sort.
		eg.
			#include <algorithm>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> v={11,55,44,33,22,23,78,90,45,67,879,675};
				
				std::cout << "Vector size : "<< v.size() << std::endl;
				
				//find 22 (not working properly)
				std::cout << "22 present? "<< binary_search(v.begin(), v.end(), 55) << std::endl;
				std::cout << "upper_bound : "<< upper_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				std::cout << "lower_bound : "<< lower_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				

				int a=90, b=40;
				std::cout << "MAX of A & B : "<< max(a,b) << std::endl;
				std::cout << "min of A B"<< min(a,b) << std::endl;

				printf("A: %d, B: %d", a,b);
				swap(a,b);
				printf("\nA: %d, B: %d", a,b);
				
				string str = "asdfghjkl";
				std::cout << "String : "<< str << std::endl;
				
				reverse(str.begin(),str.end());
				std::cout << "Reverse String : "<< str << std::endl;

				std::cout  << std::endl;
				//rotate
				for(auto i:v)
					cout<<i<<" ";
				
				rotate(v.begin(), v.begin()+3, v.end());
				
				std::cout  << std::endl;
				for(auto i:v)
					cout<<i<<" ";
					
				//sorted
				sort(v.begin(), v.end());
				std::cout << std::endl << "Sorted: ";
				for(auto i:v)
					cout<<i<<" ";
				return 0;
			}
			//ouput:
				Vector size : 12
				22 present? 0
				upper_bound : 10
				lower_bound : 10
				MAX of A & B : 90
				min of A B40
				A: 90, B: 40
				A: 40, B: 90String : asdfghjkl
				Reverse String : lkjhgfdsa

				11 55 44 33 22 23 78 90 45 67 879 675 
				33 22 23 78 90 45 67 879 675 11 55 44 
				Sorted: 11 22 23 33 44 45 55 67 78 90 675 879
---------------------------------------------------------------------------------------------------------
	27/08/23
Lecture-20:
	LeetCode Practice:
		1) Reverse Vector:
			-reverse(startIndex, endIndex);
			-reverse function defined in the algorithm header file.
			using built in function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					std::cout  << std::endl;
					reverse(v.begin(), v.end());
					
					cout<<"After: ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";

					return 0;
				}

			Without using builtint function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				vector<int> REVERSE(vector<int> a){
					int start=0, end = a.size()-1;
					
					while(start <= end){
						swap(a[start], a[end]);
						start++;
						end--;
					}
					
					return a;
				}

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					
					vector<int> ans= REVERSE(v);
					
					cout<<"\nAfter: ";
					for(int i=0;i<ans.size();i++)
						cout<<ans[i]<<" ";

					return 0;
				}
			
		2) Reverse The Array:
			-Reversing array from given position
			eg.
				Sample Input 1:
				2
				6 3
				1 2 3 4 5 6
				5 2
				10 9 8 7 6
				Sample Output 1:
				1 2 3 4 6 5
				10 9 8 6 7
				Explanation 1:
				For the first test case, 
				Considering 0-based indexing we have M = 3 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {1, 2, 3, 4, 6, 5}.

				For the second test case, 
				Considering 0-based indexing we have M = 2 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {10, 9, 8, 6, 7}.
				Sample Input 2:
				2
				7 3
				1 4 5 6 6 7 7 
				9 3
				10 4 5 2 3 6 1 3 6
				Sample Output 2:
				1 4 5 6 7 7 6
				10 4 5 2 6 3 1 6 3 

			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				return reverse(arr.begin()+m+1,arr.end());
			}

			//or
			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				int start = m+1, end = arr.size()-1;
				while (start <= end) {
					swap(arr[start], arr[end]);
					start++;
					end--;
				}
			}
		
		3) Merge Sorted Array:
			void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
				vector<int> nm;
				int i=0,j=0;
				while(i<m && j<n){
					if(nums1[i] < nums2[j]){
						nm.push_back(nums1[i++]);
					}else{
						nm.push_back(nums2[j++]);
					}
				}

				while(i < m)
					nm.push_back(nums1[i++]);

				while(j < n)
					nm.push_back(nums2[j++]);
				
				//nums1.clear();
				nums1 = nm;
			}
		
			#Program:
				#include<iostream>
				#include<vector>
				using namespace std;

				void merge(int arr1[], int n, int arr2[], int m, int arr3[]) {
					int i = 0, j = 0;
					int k = 0;
					while( i<n && j<m) {
						if(arr1[i] < arr2[j]){
							arr3[k++] = arr1[i++];
						}
						else{
							arr3[k++] = arr2[j++];
						}
					}

					//copy first array k element ko
					while(i<n) {
						arr3[k++] = arr1[i++];
					}

					//copy kardo second array k remaining element ko
					while(j<m) {
						arr2[k++] = arr2[j++];
					}
				}

				void print(int ans[], int n) {
					for(int i=0; i<n; i++) {
						cout<< ans[i] <<" ";
					}
					cout << endl;
				}

				int main(){
					int arr1[5] = {1,3,5,7,9};
					int arr2[3] = {2,4,6};

					int arr3[8] = {0};

					merge(arr1, 5, arr2, 3, arr3);
					print(arr3, 8);
					return 0;
				}

		4) Move Zeroes:
			Given an integer array nums, move all 0's 
			to the end of it while maintaining the relative order of the non-zero elements.
			Note that you must do this in-place without making a copy of the array.
				Example 1:

				Input: nums = [0,1,0,3,12]
				Output: [1,3,12,0,0]
				Example 2:

				Input: nums = [0]
				Output: [0]
			->
				void moveZeroes(vector<int>& nums) {
					int len = nums.size();
					int cnt =0;
					vector<int> temp;
					for(int i=0;i<len;i++){
						if(nums[i] == 0)
							cnt++;
						else
							temp.push_back(nums[i]);
					}
					for(int i=0; i<cnt; i++)
						temp.push_back(0);
					
					nums = temp;
				}

				//or
					int i=0;
					for(int j=0;j<nums.size(); j++)
						if(nums[j] != 0)
							swap(nums[i++], nums[j]);
				
				//or
					nt cnt=0;
					for(int i=0;i<nums.size();i++)
						if(nums[i] != 0)
							nums[cnt++] = nums[i];
					
					while(cnt<nums.size())
						nums[cnt++] = 0;
		
		5) Subarray or not?
			#include <iostream>
			using namespace std;

			bool isSubArr(int mainArr[], int orSize, int part[], int partSize){
				if(partSize > orSize)
					return 0;
				
				int k=0,i;
				for(i=0;i<partSize;){
					if(part[i] == mainArr[k]){
						for(int tr = k;;tr++){
							if((i < partSize) && tr != orSize && part[i] == mainArr[tr]){
								i++;
								if(i == partSize)
								return 1;
								continue;
							}else{
								return 0;
							}
						}
					}
					if(k >= orSize)
					break;
					k++;
				}
				return 0;
			}

			int main(){
				int arr[] = {1,2,3,4,5,6,7,8,9,10}, len=10;
				
				int sub[] = {13,14,15};
				int nSub[] = {6,7,8,9,10,11};
				int largerSizeArr[] = {1,2,3,4,5,6,7,8,9,10,11};
				
				int testArr1[] = {4,5,6,7}, testLen1 = 4;
				int testArr2[] = {8,9,10}, testLen2 = 3;
				int testArr3[] = {9,10,11,12}, testLen3 = 4;
				int testArr4[] = {11,12,15,16,20}, testLen4 = 5;

				isSubArr(arr, len, sub, 3)? std::cout << "Sub is SubArray " << std::endl : std::cout << "Sub is not SubArray" << std::endl;
				isSubArr(arr, len, nSub, 6)? std::cout << "nSub is SubArray " << std::endl : std::cout << "nSub is not SubArray" << std::endl;
				isSubArr(arr, len, largerSizeArr, 11)? std::cout << "largerSizeArr is SubArray " << std::endl : std::cout << "largerSizeArr is not SubArray" << std::endl;
				
				isSubArr(arr, len, testArr1, testLen1)? std::cout << "testArr1 is SubArray " << std::endl : std::cout << "testArr1 is not SubArray" << std::endl;
				isSubArr(arr, len, testArr2, testLen2)? std::cout << "testArr2 is SubArray " << std::endl : std::cout << "testArr2 is not SubArray" << std::endl;
				isSubArr(arr, len, testArr3, testLen3)? std::cout << "testArr3 is SubArray " << std::endl : std::cout << "testArr3 is not SubArray" << std::endl;
			
				//not SubArray
				isSubArr(arr, len, testArr4, testLen4)? std::cout << "testArr4 is SubArray " << std::endl : std::cout << "testArr4 is not SubArray" << std::endl;

				return 0;
			}
---------------------------------------------------------------------------------------------------------
	3/09/23
Lecture-21: Solving LeetCode/CodeStudio Questions [Arrays]
		1) Rotate Array
			Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
				Example 1:

				Input: nums = [1,2,3,4,5,6,7], k = 3
				Output: [5,6,7,1,2,3,4]
				Explanation:
				rotate 1 steps to the right: [7,1,2,3,4,5,6]
				rotate 2 steps to the right: [6,7,1,2,3,4,5]
				rotate 3 steps to the right: [5,6,7,1,2,3,4]
				Example 2:

				Input: nums = [-1,-100,3,99], k = 2
				Output: [3,99,-1,-100]
				Explanation: 
				rotate 1 steps to the right: [99,-1,-100,3]
				rotate 2 steps to the right: [3,99,-1,-100]

			class Solution {
				public:
				void rotate(vector<int>& nums, int k) {
					int n = nums.size();
					vector<int> temp(n);

					for(int i=0;i<n;i++)
						temp[(i+k)%n] = nums[i];

					nums = temp;
				}
			};
		
		2) Check if Array Is Sorted and Rotated:
			https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/
			class Solution {
			public:
				bool check(vector<int>& nums) {
					int cnt=0;
					for(int i=1;i<nums.size();i++)
						if(nums[i-1] > nums[i])
							cnt++; 
					if(nums[nums.size()-1] > nums[0])
						cnt++;
					return cnt<=1;
				}	
			};

		3) Sum Of Two Arrays:
			Sample Input 1:
				2
				4 1 
				1 2 3 4
				6
				3 2
				1 2 3
				9 9    
				Sample Output 1:
				1 2 4 0
				2 2 2
				Explanation For Sample Input 1:
				For the first test case, the integer represented by the first array is 1234 and the second array is 6, so the sum is 1234 + 6 =  1240.

				For the second test case, the integer represented by the first array is 123 and the second array is 99, so the sum is 123 + 99 = 222.
				Sample Input 2:
				2
				3 3 
				4 5 1
				3 4 5
				2 2
				1 1
				1 2
				Sample Output 2:
				7 9 6
				2 3

			#include <bits/stdc++.h> 
			int convertor(vector<int> , int);
			vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {

				int n1 = convertor(a, n);
				int n2 = convertor(b, m);

				int sum = n1 + n2;

				vector<int> sample;

				while(sum){
					int temp = sum % 10;
					sample.push_back(temp);
					sum /=10;
				}

				reverse(sample.begin(), sample.end());
				return sample;	
			}

			int convertor(vector<int> a, int len){
				int num =0;
				//array to num
				for(int i=0;i<len;i++)
					num = num * 10 + a[i];

				return num;
			}

			#include <bits/stdc++.h> 
			vector<int> findArraySum(vector<int>& a, int n, std::vector<int>& b, int m) {
				vector<int> v;
				int i = n - 1;
				int j = m - 1;
				int carry = 0;

				while (i >= 0 && j >= 0) {
						
					int sum = a[i--] + b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//first array len is greater than second
				while (i >= 0) {
					int sum = a[i--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//second array len is greater than first
				while (j >= 0) {
					int sum = b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//carry is remain to add
				while (carry != 0) {
					int sum = carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}
				return v;
			}
---------------------------------------------------------------------------------------------------------
	14/09/23
Lecture-22: All about Char Arrays, Strings & solving LeetCode Questions
		-String: 1D (one-dimensional char array.)
		 '\0' - end of string, present at the end of string (null character).
		 #include <iostream>
		 using namespace std;
		 int main(){
			char name[10];
		 	std::cout << "Enter name : " << std::endl;
		 	
		 	cin>>name;      //cin stop taking input after getting space, new line or tab.
		 	std::cout << name << std::endl;
		 	
		 	// Enter name : 
			// Vivek Nikate
			// Vivek
			return 0;
		}

		-if null character found then compiler consider it as the end of string.
			eg.
			#include <iostream>
			using namespace std;
			int main(){
				char name[15];
				std::cout << "Enter name : " << std::endl;
				
				cin>>name;      //cin stop taking input after getting space, new line or tab.
				name[3] = '\0';	//after 3rd index compiler consider it as end of string.
				std::cout << name << std::endl;
				
				// Enter name : 
				// VivekNikate
				// Viv
				
				return 0;
			}

		// WAP to find the Length of string
			#include <iostream>
			using namespace std;
			int main(){
				char name[15];
				std::cout << "Enter name : " << std::endl;
				
				cin>>name;
				int len=0;

				while(name[len++] != '\0');	
				std::cout << "The Length of string is :: "<< len-1 << std::endl;
				return 0;
			}
			Enter name : 
			Vivek
			The Length of string is :: 5
		
		//String
			#include <iostream>
			using namespace std;
			int main(){
			
				// string s;        //for printf statement string won't work.
				char s[100];
				std::cout << "Enter name: " << std::endl;
				cin>>s;
				
				printf("Your name : %s ",s);
				cout<<"your name: "<<s;
				return 0;
			}

		- WAP Reverse a string:
			#include <iostream>
			#include<algorithm>
			using namespace std;
			int main(){
				
				string s;
				std::cout << "Enter name: " << std::endl;
				cin>>s;
				string temp = s;
				std::cout << "Your name : " <<s<< std::endl;
				
				reverse(s.begin(), s.end());
				//or
				cout<<"reverse : "<<s<<endl;
				
				s = temp;
				cout<<"Length of string is :: "<< s.size()<<endl;             //Length using size() function
				cout<<"Length of string is :: "<< s.length()<<endl;           //Length using length() function
				
				//or custom calculating length of string
				int i=0;
				while(s[i++] != '\0');
				cout<<"Length of string is :: "<< i-1<<endl;
				
				int start =0;
				int len = i-2;
				while(start <= len){
					swap(s[start++],s[len--]);
				}
				
				cout<<"Reverse string custom :"<< s <<endl;
				return 0;
			}		

		- Reverse String
			https://leetcode.com/problems/reverse-string/description/
			class Solution {
			public:
				void reverseString(vector<char>& s) {
					// reverse(s.begin(), s.end());
					int start=0,end=s.size()-1;
					while(start<end)
						swap(s[start++],s[end--]);
				}
			};

		- Check If The String Is A Palindrome
			#include <bits/stdc++.h> 
			bool checkPalindrome(string s){
				string ans;
				for(int i=0;i<s.length();i++){
					if(('a' <= s[i] && s[i] <= 'z') || 
						('A'<=s[i] && s[i] <='Z') || ('0'<=s[i] && s[i] <='9'))
						ans += s[i];


					//or for above if condition,
						//after converting to lowercase
						//if((isalpha(s[i])) || isdigit(s[i]))	 //to check isalphabate or not and isdigit or not.
						//	ans += s[i];
				}

				//or to check is Alphabet or number,
				//for(int i=0;i<s.length();i++){
				//     if(isalnum(s[i]))
				//         ans += s[i];
				// }

				transform(ans.begin(), ans.end(), ans.begin(), ::tolower);
				string temp = ans;
				reverse(temp.begin(), temp.end());
				if(ans == temp)
					return 1;
				return 0;
			}

			//converting Uppercase char to lower
				char toLowerCase(char ch) {
					if(ch >='a' && ch <='z')
						return ch;
					else
						char temp = ch - 'A' + 'a';
					return temp;
				}

			//upper to lower or viceversa,
				#include <iostream>
				using namespace std;
				int main(){
					char ch1 = 'u', ch2='v', ch3='D';
					std::cout << char(ch1-32) << std::endl;             //U
					std::cout << char(ch2-32) << std::endl;             //V
					std::cout << char(ch3+32) << std::endl;             //d
					
					return 0;
				}

				//or
					#include <iostream>
					using namespace std;
					char TOLOWER(char);
					char TOUPPER(char);
					int main(){
						char ch1 = 'A', ch2 = 'b';
						
						cout<<TOLOWER(ch1)<<endl;
						cout<<TOUPPER(ch2)<<endl;
						return 0;
					}

					char TOLOWER(char ch){
						return ch - 'A' + 'a';
					}

					char TOUPPER(char ch){
						return ch - 'a' + 'A';
					}

			//Palindrome:
				#include<string>
				#include<iostream>
				#include<vector>
				using namespace std;
				class Solution {
					private:
					bool valid(char ch) {
						if( (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
							return 1;
						}
						
						return 0;
					}
					
					char toLowerCase(char ch) {
						if( (ch >='a' && ch <='z') || (ch >='0' && ch <='9') )
							return ch;
						else{
							char temp = ch - 'A' + 'a';
							return temp;
						}
					}

					bool checkPalindrome(string a) {
						int s = 0;
						int e = a.length()-1;

						while(s<=e) {
							if(a[s] != a[e])
							{
								return 0;       
							}
							else{
								s++;
								e--;
							}
						}
						return 1;
					}
					public:
					bool isPalindrome(string s) {
						
						//faltu character hatado
						string temp = "";
						
						for(int j=0; j<s.length(); j++) {   
							if(valid(s[j])) {
								temp.push_back(s[j]);
							}
						}
						
						//lowercase me kardo
						for(int j=0; j<temp.length(); j++) { 
							temp[j] = toLowerCase(temp[j]);
						}
						
						//check palindrome
						return checkPalindrome(temp);	
					}
				};

			//without using extra space or temp string:
				#include <bits/stdc++.h> 
				bool checkPalindrome(string s){
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					int i=0, j = s.size()-1;
					while(i<j){
						if(!isalnum(s[i])){
							i++;
							continue;
						}
						if (!isalnum(s[j])) {
							j--;
							continue;
						}
						if (s[i] != s[j])
							return false;
						i++;
						j--;
					}
					return true;
				}

			//or
				#include <bits/stdc++.h> 
				bool checkPalindrome(string s){
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					int i=0, j = s.size()-1;
					while(i<j){
						if (isalnum(s[i])) {
							if(isalnum(s[j])){
								if(s[i] == s[j]){
									i++;j--;
									continue;    
								}else{
									return false;
								}
							}else{
								j--;
							}
						}else{
							i++;
						}
					}
					return true;
				}

		- simple Palindrome checker:
			#include <iostream>
			using namespace std;
			int main(){
				string s;
				cout<<"Enter string to check Palindrome or not?"<<endl;
				cin>>s;
				
				int i=0;
				for(i;i<s.length()/2;i++)
					if(s[i] != s[s.length()-1-i]){
						cout<<"Not Palindrome";
						break;
					}
					
				if(i == s.length()/2)
					cout<<"Palindrome";
				return 0;
			}

		- Valid Palindrome
			https://leetcode.com/problems/valid-palindrome/description/
			 class Solution {
				public:
				bool isPalindrome(string s) {		
					transform(s.begin(), s.end(), s.begin(), ::tolower);
					string ans;

					for(int i=0;i<s.length() ; i++){
						if((s[i] >= 'a' && s[i] <= 'z') || (s[i]>='0' && s[i] <='9'))
							ans += s[i];
					}
					s = ans;
					reverse(ans.begin(), ans.end());
					return (ans == s)? true:false;
				}
			};

			//or
				class Solution {
					public:
					bool isPalindrome(string s) {
						transform(s.begin(), s.end(), s.begin(), ::tolower);
						int i=0,j=s.length()-1;
						while(i<j){
							if(!isalnum(s[i])){
								i++;
								continue;
							}
							if(!isalnum(s[j])){
								j--;
								continue;
							}
							if(s[i] != s[j])
								return false;
							i++;j--;
						}
						return true;
					}
				};

		//String Operations:
			#include <iostream>
			using namespace std;

			int main(){
			
				string s = "Hello World";
				cout<<s<<endl;
				
				s.pop_back();
				cout<<s<<endl;                      //removing element from last.
				
				s.push_back('V');                   //adding element at last or s = s + 'V';
				cout<<s<<endl;
				
				cout<<s.front()<<endl;              //first element of string
				cout<<s.back()<<endl;               //last element of string
				
				cout<<s.at(4)<<endl;                //char at 4th index (0-based index)
				
				cout<<"String length is :: "<<s.length()<<endl;

				s.erase(2,3);
				cout<<s<<endl;                  //from index 2nd remove 3 char here llo got removed.

				cout<<"String length After erasing :: "<<s.length()<<endl;
				return 0;
			}

		// upper/lower case char conversion
			#include <iostream>
			#include <algorithm>
			using namespace std;
			int main(){
				string s = "Hello World";
				
				std::cout << s << std::endl;

				std::cout << char(tolower('A')) << std::endl;
				
				//string upper to lower case
				transform(s.begin(), s.end(), s.begin(), ::tolower);
				// transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
				std::cout << s << std::endl;
				
				transform(s.begin(), s.end(), s.begin(), ::toupper);
				std::cout << s << std::endl;
				
				return 0;
			}

		//convert string to uppercase or lowercase
			#include <iostream>
			#include <algorithm>
			using namespace std;

			int main(){
				string s1 = "VIVEK", s2="nikate", s3 = "third", s4 = "this is first letter capital sentence.";
				
				transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
				std::cout << s1 << std::endl;
				
				transform(s2.begin(), s2.end(), s2.begin(), ::toupper);
				std::cout << s2 << std::endl;
				
				s3[0] = toupper(s3[0]);
				std::cout << s3 << std::endl;
				
				int i=0;
				while(s4[i] != '\0'){
					if(i==0) s4[i] = toupper(s4[i]);
					if(isblank(s4[i])) s4[i+1] = toupper(s4[i+1]);
					i++;
				}

				std::cout << s4 << std::endl;	
				return 0;
			}

		Char Array:
			#include <iostream>
			int main(){
				char str[] = "sadf\0tyuio";
				std::cout << str[0] << std::endl;
				std::cout << str << std::endl;
				
				char ch[] = {'v','i','\0','v','e','k'};
				cout<<ch;
				return 0;
			}

			differences (string & char array):
				-String refers to a sequence of characters represented as a single data type. 
				-Character Array is a sequential collection of data type char.

			  Characteristic					String					Char array
				Data type						Class				 	 Array
				Size							Dynamically allocated		 Fixed size
				Null terminator				Automatically appended		 Not automatically appended
				Memory management				Automatic					 Manual
				Operations					Supported					 Not supported
				Speed						Slower					 Faster
				Safety						Safer					 Less safe

		// Reverse sentence:
			Sample Input 1 :
				Welcome to Coding Ninjas
				Sample Output 1:
				Ninjas Coding to Welcome
				Explanation For Sample Input 1:
				You need to reduce multiple spaces between two words to a single space in the reversed string and observe how the multiple spaces, leading and trailing spaces have been removed.
			Sample Input 2 :
				I am a star
				Sample Output 2:
				star a am I
				Explanation For Sample Input 2:
				Your reversed string should not contain leading or trailing spaces.

			string reverseString(string &str){
				vector<string> ans;
				int i=0;

				while(i<str.length()){
					if(str[i] == ' '){
						i++;
						continue;
					}

					string temp;
					while(str[i] != ' ' && str[i] !='\0'){
						temp += str[i];

						i++;
					}
					ans.push_back(temp);
				}

				i=ans.size()-1;
				str = "";
				while(i>=0){
					str += ans[i];
					if( i!=0)
						str += ' ';
					i--;
				}
				return str;	
			}

		// Reverse Words in a String III
			Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
				Example 1:

				Input: s = "Let's take LeetCode contest"
				Output: "s'teL ekat edoCteeL tsetnoc"
				Example 2:

				Input: s = "God Ding"
				Output: "doG gniD"
			https://leetcode.com/problems/reverse-words-in-a-string-iii/description/
			class Solution {
			public:
				string reverseWords(string s) {
					string temp;
					vector<string> holder;

					int i=0;
					while(i<s.length()){
						if(s[i] == ' '){
							i++;
							continue;
						}

						while(s[i] != ' ' && s[i] != '\0'){
							temp += s[i];
							i++;
						}
						holder.push_back(temp);
						temp="";
						i++;
					}

					s="";
					
					for(int a=0;a<holder.size();a++){
						string st =  holder[a];
						reverse(st.begin(), st.end());
						s += st;
						if(a != holder.size()-1)
							s += " ";               // s = s + ' ' or s = s + " ";
					}
					return s;
				}
			};

			//or
				class Solution {
					public:
					string reverseWords(string s) {
						string revSentence;
						string word;
						for(int i=0; i<s.length(); i++){
							if(s[i] == ' '){
								reverse(word.begin(), word.end());
								revSentence += word + " ";
								word = "";
								continue;
							}
							word += s[i];
						}

						//code to add last word
						reverse(word.begin(), word.end());
						revSentence += word;

						return revSentence;
					}
				};

		// Print first n Fibonacci Numbers
			Given a number N, find the first N Fibonacci numbers. The first two number of the series are 1 and 1.
				Example 1:

				Input:
				N = 5
				Output: 1 1 2 3 5
				Example 2:

				Input:
				N = 7
				Output: 1 1 2 3 5 8 13
				Your Task:
				Your task is to complete printFibb() which takes single argument N and returns a list of first N Fibonacci numbers.

				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(N).
				Note: This space is used to store and return the answer for printing purpose.

				Constraints:
				1<= N <=84

			class Solution{
				public:
				//Function to return list containing first n fibonacci numbers.
				vector<long long> printFibb(int n){
					long long prev=1, curr =1;
					vector<long long> ans;
					ans.push_back(curr);
					
					if(n == 1)
						return ans;
						
					ans.push_back(prev);
					if(n ==2)
						return ans;
					
					for(int i=2;i<n;i++){
						long long fib = curr + prev;
						prev = curr;
						curr = fib;
						ans.push_back(fib);
					}
					return ans;
				}
			};

		// Nth Fibonacci Number:
			class Solution {
				public:
				int nthFibonacci(int n){
					int cur=1,prev=0;
					int mod = 1e9+7;
					if(n == 0)
						return prev;
					else if(n==1)
						return cur;
					else
						for(int i=2;i<=n;i++){
							int fib = (cur +prev) % mod;
							prev = cur;
							cur = fib;
						}

					return cur;
				}
			};

		// Maximum Occuring Character
			Given a string str of lowercase alphabets. The task is to find the maximum occurring character in the string str. 
			 If more than one character occurs the maximum number of time then print the lexicographically smaller character.
				Example 1:

				Input:
				str = testsample
				Output: e
				Explanation: e is the character which
				is having the highest frequency.
				Example 2:

				Input:
				str = output
				Output: t
				Explanation:  t and u are the characters
				with the same frequency, but t is
				lexicographically smaller.
				Your Task:
				The task is to complete the function getMaxOccuringChar() which returns the character which is most occurring.

				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(Number of distinct characters).
				Note: N = |s|

				Constraints:
				1 ≤ |s| ≤ 100
			class Solution{
				public:
				//Function to find the maximum occurring character in a string.
				char getMaxOccuringChar(string str){
					int cnt=1,prev=cnt;
					char mainCh = str[0];
					for(int i=0;i<str.length();i++){
						for(int j=0;j<str.length();j++){
							if(str[i] == str[j])
								cnt++;
						}
						
						if(cnt> prev || (cnt >= prev && str[i] < mainCh)){
							mainCh = str[i];
							prev=cnt;
						}
						cnt=1;
					}
					
					return mainCh;
				}
			};

			//or
				class Solution{
					public:
					//Function to find the maximum occurring character in a string.
					char getMaxOccuringChar(string str){
						int arr[26] = {0};
						for(int i=0; i<str.length();i++){
							int num;
							//between lowercase     
							if(str[i]>='a' && str[i]<='z'){
								num = str[i] - 'a';
							}else{      //between uppercase
								num = str[i] - 'A';
							}
							arr[num]++;
						}
						
						int mx=arr[0], index=0;
						for(int i=0;i<26;i++){
							if(mx<arr[i]){
								mx = arr[i];
								index = i;
							}
						}
						return char('a'+index);
					}
				};

		// WAP to take string as input
			#include <iostream>
			using namespace std;
			int main(){
				
				string s;
				std::cout << "Enter name: (stop taking input when we hit enter) " << std::endl;
				getline(cin, s);                //getline function works for string datatype only.
				cout<<s<<endl;
				
				
				// for character datatype use cin.getline(char_array_name, max_size) function,
				char str[100];
				std::cout << "Enter name again:" << std::endl;
				cin.getline(str, 50);
				std::cout << str << std::endl;
				
				//ending string with some particular delimiter
				//$
				//when user enter $ it stop taking input
				//whatever comes after $ it will not consider it.
				std::cout << "Enter name : delimiter" << std::endl;
				cin.getline(str,100, '$');
				std::cout << str << std::endl;
				
				
				std::cout << "Enter name: delimit by * " << std::endl;
				getline(cin, s, '*');                //getline function works for string datatype only.
				cout<<s<<endl;
				
				//delimiter by [
				std::cout << "Enter name: delimiter [ : " << std::endl;
				cin.getline(str, 100, '[');
				std::cout << str << std::endl;
				
				s="";
				//delimiter with string, stop taking input when you encounter ^.
				std::cout << "Enter name for string delimiter :" << std::endl;
				getline(cin,s,'^');
				std::cout << s << std::endl;
				return 0;
			}

		// char array Operation:
			#include <iostream>
			#include<cstring>
			using namespace std;

			int main(){
				char s1[] ="Vivek_Mahesh_Nikate";
				char s2[] ="Nikate";
				char s3[] ="Vivek";
					
				std::cout << strlen(s1) << std::endl;           //strlen function works with char array only.
				
				std::cout << strcmp(s2,s1) << std::endl;        //s1-s2 first string is smaller so -ve answer
				std::cout << strcmp(s1,s2) << std::endl;        //s2-s1 first string is larger so +ve answer
				
				//if both are equal then 0
				std::cout << strcmp(s3,s1) << std::endl;
				
				std::cout << s1 << std::endl;
				
				//after copying s1 is:
				strcpy(s1,"New_String");        //strcpy(source, destination), strcpy(place_to_take_new_value, new_value),
				std::cout << s1 << std::endl;
				
				char s4[] = "Cat ";
				char s5[] = "Meow ";
				std::cout << s4 << std::endl;
				std::cout << s5 << std::endl;
				strcat(s4,s5);      // s4 = s4 + s5;
				
				std::cout << s4 << std::endl;
				return 0;
			}

		// string insertion:
			#include <iostream>
			using namespace std;

			int main(){
				string s="Hello World";
				string s1("Vivek Nikate");	//we can define string like this also.

				cout<<s<<endl;				//Hello World
				
				s.insert(3," Vivek ");          //after 2nd index insert new string or after 3 char insert this new string
				std::cout << s << std::endl;     //Hel Vivek lo World

				s.insert(1,"Nikate");           //after one character insert new string.
				std::cout << s << std::endl;	  //HNikateel Vivek lo World
					
				return 0;
			}

		// Replace Spaces with @40:
			Sample Input 1:
				2
				Coding Ninjas Is A Coding Platform
				Hello World
				Sample Output 1:
				Coding@40Ninjas@40Is@40A@40Coding@40Platform
				Hello@40World
				Explanation Of Sample Output 1:
				In test case 1, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40Is@40A@40Coding@40Platform

				In test case 2, After replacing the spaces with “@40” string is: 

				Hello@40World
				Sample Input 2:
				3
				Hello
				I love coding
				Coding Ninjas India
				Sample Output 2:
				Hello
				I@40love@40coding
				Coding@40Ninjas@40India    
				Explanation For Sample Output 2:
				In test case 1, After replacing the spaces with “@40” string is: 

				Hello

				In test case 2, After replacing the spaces with “@40” string is: 

				I@40love@40coding

				In test case 3, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40India
			#include <bits/stdc++.h> 
			string replaceSpaces(string &str){
				string temp;
				for(int i=0;i<str.length();i++){
					if(str[i] == ' '){
						temp += "@40";
					}else{
						temp += str[i];
					}
				}
				return temp;
			}

			//or without using extra space/ temp string.
				#include <iostream>
				using namespace std;

				int main(){
					string str= "H M M N";
					std::cout << str << std::endl;
					
					int len = str.length(), spaceCount=0;
						for(int i=0;i<len;i++)
							if(str[i] == ' ')
								spaceCount++;
						
						if(!spaceCount){
						std::cout << str << std::endl;
							return 0;
					}

						len -= spaceCount;
						len += (spaceCount*3);
						str.resize(len);

						for(int i=0;i<len;i++){
							if(str[i] == ' '){
								str.replace(i, 1,"@40");
								i +=2;
							}
						}
						
						std::cout << str << std::endl;
					return 0;
				}

		clear():
			The clear() function is used to remove all the elements of the vector container, thus making it size 0.
			Parameters: No parameters are passed.
			Result: All the elements of the vector are removed (or destroyed).

		erase():
			erase() function is used to remove elements from a container from the specified position or range.

			#include <iostream>
			using namespace std;

			int main(){
				string s;
				s=  "Hello World";
				std::cout << s << std::endl;                //Hello World
				
				s.erase(3,4);                       //after 3 chars remove 4 characters
				std::cout << s << std::endl;        //Helorld
				
				//except first 5 characters remove all
				s = "Hello World";
				s.erase(5);
				std::cout << s << std::endl;    //Hello
				
				//just remove 4th character         if we mention iterator then it remove only one character at that iterator index.
				s = "Hello World";
				s.erase(s.begin()+4); 
				std::cout << s << std::endl;        //Hell World
				
				//remove 4 characters from last
				s = "Hello World";
				s.erase(s.end()-4,s.end());             //s.erase(startIndex, endIndex);
				std::cout << s << std::endl;            //Hello W
				
				//remove last char from string
				s = "Hello World";
				s.pop_back();
				std::cout << s << std::endl;            //Hello Worl
				
				//remove last char from string using erase
				s = "Hello World";
				s.erase(s.end()-1);
				std::cout << s << std::endl;            //Hello Worl
				
				//remove 2nd last char from string using erase
				s = "Hello World";
				s.erase(s.end()-2);
				std::cout << s << std::endl;            //Hello Word
				
				//delete complete string
				s = "Hello World";
				s.erase();
				std::cout <<"String is ::" <<s << std::endl;            //Hello Worl
				
				//or
				s = "Hello World";
				s.clear();
				std::cout<<"Clear string :: " << s << std::endl;            //Hello Worl
				
				//append 4 char to end of string
				s = "Hello World";
				string w = s.substr(1,4);           //substr(startIndex, no.of char)
				s += " "  + w;
				std::cout << s  << std::endl;            //Hello World ello
				
				return 0;
			}

			//string operations:
				Example-1:
					#include <iostream>
					using namespace std;

					int main(){
						string s1 = "Vivek Mahesh Nikate";
						string s2 = "Learning is Hobby";
						
						cout<<"one is not present in s1 :: "<<boolalpha<<(s1.find("one") == string::npos)<<endl;
						
						//string::npos means sub string is not found. if s1.find("--") == string::npos, means substring does not exist.
						cout<<string::npos<<endl;
						
						if(s1.find("Vivek") != string::npos){
							std::cout << "SubString found" << std::endl;
						}else{
							std::cout << "SubString Not found" << std::endl;
						}
						
						//find() method returns the index of starting character of substring, & its case sensitive if not found 
						//it return value of string::npos & if(str.find() == string::npos) then you can say that substring not found.
						
						std::cout <<"learning is present in s2 :: " <<(s2.find("learning") != string::npos) << std::endl;
						
						std::cout <<"Hobby is present?  "<<(s2.find("Hobby") != string::npos) << std::endl;
						
						string s3 = "Learning @#@#@&@#@#@@#@#@@#@#@ pro@#@#@blem@#@#@ solving is @#@#@a most impor@#@#@tant skill @#@#@found in the @#@#@interview";
						
						//removing garbase from string,
						std::cout << s3 << std::endl;
						
						string part = "@#@#@";
						
						while(s3.find(part) != string::npos){
							if(s3.find(part) != string::npos)
								s3.erase(s3.find(part), part.length());
						}
						
						std::cout << s3 << std::endl;
						return 0;
					}

					/*
						output:
						one is not present in s1 :: true
						18446744073709551615
						SubString found
						learning is present in s2 :: false
						Hobby is present?  true
						Learning @#@#@&@#@#@@#@#@@#@#@ pro@#@#@blem@#@#@ solving is @#@#@a most impor@#@#@tant skill @#@#@found in the @#@#@interview
						Learning & problem solving is a most important skill found in the interview
					*/

				Example-2:
					#include <iostream>
					using namespace std;

					int main(){
					
						string s= "Hello_World";
						
						std::cout << s << std::endl;                    //Hello_World
						std::cout << s.substr(0,2) << std::endl;        //He    2 character
						std::cout << s.substr(6,2) << std::endl;        //wo    2 character
						std::cout << s.substr(s.length()-1) << std::endl;     //extracting last char    d
						std::cout << s.substr(4,1) << std::endl;            //o, 1 character extracting
						
						//extracting complete string except first 2 character,
						//or from 2nd index taking all character 
						std::cout << s.substr(2) << std::endl;                  //llo_World
						
						// removing l
						std::cout << s << std::endl;
						s.erase(s.begin()+2);
						std::cout << s << std::endl;
						
						//searching substr 'Hell',
						s = "Hello_World";
						string sub = "Hell";
						
						std::cout << "is string contain "<<sub<<"? " <<( (s.find(sub) != string::npos) ? "Yes":"no")<< std::endl;
						
						if(s.find(sub) != string::npos)
							s.erase(s.find(sub),sub.length());
							
						std::cout << "New string after removing : "<< s << std::endl;
						return 0;
					}

					/*
						ouput
						Hello_World
						He
						Wo
						d
						o
						llo_World
						Hello_World
						Helo_World
						is string contain Hell? Yes
						New string after removing : o_World
					*/

		// Remove All Occurrences of a Substring
			https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
			Given two strings s and part, perform the following operation on 
			 s until all occurrences of the substring part are removed:
				Find the leftmost occurrence of the substring part and remove it from s.
				Return s after removing all occurrences of part.

				A substring is a contiguous sequence of characters in a string.
				Example 1:
					Input: s = "daabcbaabcbc", part = "abc"
					Output: "dab"
					Explanation: The following operations are done:
					- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
					- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
					- s = "dababc", remove "abc" starting at index 3, so s = "dab".
					Now s has no occurrences of "abc".
				Example 2:
					Input: s = "axxxxyyyyb", part = "xy"
					Output: "ab"
					Explanation: The following operations are done:
					- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
					- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
					- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
					- s = "axyb", remove "xy" starting at index 1 so s = "ab".
					Now s has no occurrences of "xy".
			class Solution {
				public:
				string removeOccurrences(string s, string part) {
					while(s.length() != 0 && (s.find(part) < s.length())){
						s.erase(s.find(part), part.length());
					}
					return s;
				}
			};

			//or
				class Solution {
					public:
					string removeOccurrences(string s, string part) {
						// Find the starting index of the 'part' substring in 's'
						int pos = s.find(part);

						// Continue looping until 'part' is found in 's'
						while (pos != string::npos) {
							// Remove 'part' from 's' starting at the found position
							s.erase(pos, part.length());

							// Search for the next occurrence of 'part' in the modified 's'
							pos = s.find(part);
						}

						// Return the modified 's' after removing all occurrences of 'part'
						return s;
					}
				};

			//or
				class Solution {
					public:
					string removeOccurrences(string s, string part){

						while(s.find(part) != string::npos){
							s.erase(s.find(part), part.length());
						}
						return s;
					}
				};

		// Permutation in String
			Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
				In other words, return true if one of s1's permutations is the substring of s2.
				Example 1:
					Input: s1 = "ab", s2 = "eidbaooo"
					Output: true
					Explanation: s2 contains one permutation of s1 ("ba").

				Example 2:
					Input: s1 = "ab", s2 = "eidboaoo"
					Output: false
				Constraints:
					1 <= s1.length, s2.length <= 104
					s1 and s2 consist of lowercase English letters.
			
			class Solution {
				public:
				bool areEqual(int a1[26], int a2[26]){
					for(int i=0;i<26;i++)
						if(a1[i] != a2[i])
							return 0;
					return 1;
				}

				bool checkInclusion(string s1, string s2) {
					int count1[26]={0},count2[26]={0};
					int i=0;
					//what are the characters present in s1 mapping them (0-a, 1-b, 2-c) in count1 array & increment their count.
					while(i<s1.length()){
						count1[s1[i]-'a']++;
						i++;
					}
					
					//what are the characters present in s2 mapping them (0-a, 1-b, 2-c) in count2 array & increment their count.
					//& checking that i should not greater that s2 string length
					i=0;
					while(i<s1.length() && i < s2.length()){
						count2[s2[i]-'a']++;
						i++;
					}

					//if both count1 & count2 have same value in them then, you can say that its permutation of string
					if(areEqual(count1,count2))
						return 1;
					
					//else moving for next s1.length() characters
					while(i<s2.length()){
						count2[s2[i]-'a']++;
						count2[s2[i-s1.length()]-'a']--;
						if(areEqual(count1,count2))
							return 1;
						i++;
					}
					return 0;
				}
			};

		// Remove All Adjacent Duplicates In String
			You are given a string s consisting of lowercase English letters. 
			A duplicate removal consists of choosing two adjacent and equal letters and removing them.
			We repeatedly make duplicate removals on s until we no longer can.

			Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
			Example 1:
				Input: s = "abbaca"
				Output: "ca"
				Explanation: 
				For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, 
				and this is the only possible move.  The result of this move is that the string is "aaca", 
				of which only "aa" is possible, so the final string is "ca".
			Example 2:
				Input: s = "azxxzy"
				Output: "ay"
			Constraints:
				1 <= s.length <= 105
				s consists of lowercase English letters.
			
			//not optimized:
				class Solution {
					public:
					string removeDuplicates(string s) {
						int i=1;
						while(i < s.length()){
							if(s[i] == s[i-1]){
								s.erase(i-1,2);
								i=1;
							}else{
								i++;
							}
						}
						return s;
					}
				};

			//optimized:
				class Solution {
					public:
					string removeDuplicates(string s) {
						int i=0;
						string temp;
						while(i<s.length()){
							if( temp.empty() || temp.back() != s[i]){
								temp.push_back(s[i]);
							}else{
								temp.pop_back();
							}
							i++;
						}
						return temp;
					}
				};

		// String Compression
			Given an array of characters chars, compress it using the following algorithm:
				Begin with an empty string s. For each group of consecutive repeating characters in chars:
				If the group's length is 1, append the character to s.
				Otherwise, append the character followed by the group's length.
				The compressed string s should not be returned separately, but instead, 
				be stored in the input character array chars. Note that group lengths that 
				are 10 or longer will be split into multiple characters in chars.

				After you are done modifying the input array, return the new length of the array.
				You must write an algorithm that uses only constant extra space.

				Example 1:
					Input: chars = ["a","a","b","b","c","c","c"]
					Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
					Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
				Example 2:
					Input: chars = ["a"]
					Output: Return 1, and the first character of the input array should be: ["a"]
					Explanation: The only group is "a", which remains uncompressed since it's a single character.
				Example 3:
					Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
					Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
					Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".

				Constraints:
					1 <= chars.length <= 2000
					chars[i] is a lowercase English letter, 
					uppercase English letter, digit, or symbol.

			//NOT optimized.
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string s="";
						for(int i=0;i<chars.size();i++){
							if(isalpha(chars[i])){
								char ch = chars[i];
								s += ch;
								int cnt=1;
								for(int j=i+1;j<chars.size();j++){
									if(ch == chars[j]){
									chars[j] ='0';
									cnt++;
									}
								}
								if(cnt !=1)
									s += to_string(cnt);
							}else{
								continue;
							}
						}
						for(int i=0;i<s.length();i++)
							chars[i] = s[i];
						return s.length();
					}
				};

			//Optimized.. without using extra space 
				class Solution {
					public:
					int compress(vector<char>& chars) {
						int i=0,ansIndex=0;
						while(i<chars.size()){
							int j=i+1;
							while(j<chars.size() && chars[i] == chars[j])
								j++;
						
							chars[ansIndex++] = chars[i];
							int count = j-i;

							if(count > 1){
								string cnt = to_string(count);
								for(char ch: cnt)
									chars[ansIndex++] = ch;
							}
							i=j;
						}
						return ansIndex;
					}
				};
			
			//Optimized..  using extra space temp string,
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string s;
						for(int i=0;i<chars.size();){
							s += chars[i];
							int j=i+1;
							while(j<chars.size() && chars[i] == chars[j]){
								j++;
							}

							int count = j-i;
							// cout<<count<<endl;
							if(count > 1)
								s += to_string(count);
							// cout<<s<<endl;
							i=j;
						}
						
						for(int i=0;i<s.length();i++){
							chars[i] = s[i]; 
						}
						return s.length();
					}
				};

			//Own code:
				class Solution {
					public:
					int compress(vector<char>& chars) {
						int cnt=1;
						string s;
						chars.push_back('-');
						for(int i=0; i<chars.size()-1; i++){
							if(chars[i] == chars[i+1])
								cnt++;
							else{
								s += chars[i];
								if(cnt >1){ 
									string cntr= to_string(cnt);
									for(char k: cntr)
									s += k;
								}
								cnt=1;
							}
						}

						for(int i=0;i<s.length();i++){
							chars[i] = s[i];
						}
						return s.length();
					}
				};

			//or
				class Solution {
					public:
					int compress(vector<char>& chars) {

						// if(chars.size()==1)
						//     return 1;
						int i=0;
						int cnt=1,ansIndex=0;
						chars.push_back('^');       //dummy char to handle insertion in chars to execute else part once for last char.
						while(i < chars.size()-1){
							if(chars[i] == chars[i+1])
								cnt++;
							else{
								chars[ansIndex++] = chars[i];
								if(cnt>1)
									for(char ch: to_string(cnt))
									chars[ansIndex++] = ch;
								cnt=1;
							}
							i++;
						}
						return ansIndex;
					}
				};
						
			//or
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string ans;
						if(chars.size()==1)
							return 1;
						int cnt=1;
						chars.push_back('-');
						for(int i=0;i<chars.size()-1;i++){
							if(chars[i]==chars[i+1])
								cnt++;
							else{
								if(cnt==1)
									ans+=chars[i];
								else
									ans+=chars[i]+to_string(cnt),cnt=1;
							}
						}
						chars.clear();
						for(auto it:ans)                    //for(char it:ans)
						chars.push_back(it);
						return chars.size();      
					}
				};
---------------------------------------------------------------------------------------------------------
	22/09/23
Lecture-23: Introduction to 2D Arrays in C++ LeetCode Questions
		//2D Array Implementation:
			#include <iostream>
			using namespace std;

			//if you are passing the 2D Array to function need to mention column size, else will get the error
			void printArr(int[][4]);
			bool isPresent(int [][4], int);
			int main(){
				//2D Array
				
				//initialization
				int arr1[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};      //3 rows * 4 columns = 12 boxes
				int arr2[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
				
				printArr(arr1);
				std::cout << std::endl;
				printArr(arr2);
				
				//input from user
				int arr3[3][4];
				for(int row=0; row<3; row++)
					for(int col=0; col<4; col++)
						cin>>arr3[row][col];
				
				std::cout << std::endl;
				printArr(arr3);
				
				int trgt1, trgt2;
				std::cout << "Enter trgt1 & trgt2 : " << std::endl;
				cin>>trgt1>>trgt2;
				
				//for trgt1
				if(isPresent(arr1,trgt1))
					cout<<"\nTarget1 :"<<trgt1<<"  is present";
				else
					cout<<"Target1 not present";
				
				(isPresent(arr1,trgt2))?  cout<<"\nTarget2 :"<<trgt2<<"  is present" :  cout<<"\nTarget2 "<<trgt2<<" not present";
				
				return 0;
			}

			//if you are passing the 2D Array to function need to mention column size.
			void printArr(int a[][4]){          
				//printing 2D Array
				for(int row=0; row<3; row++){
					for(int col=0; col<4; col++)
						cout<<a[row][col]<<"\t";
					cout<<"\n";
				}
			}

			//Linear search function
			bool isPresent(int a[][4], int n){
				for(int row=0; row<3; row++)
					for(int col=0; col<4; col++)
						if(a[row][col] == n)
							return 1;
				return 0;
			}

		//wap to find sum of row elements
			#include <iostream>
			using namespace std;
			int main(){
				int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};

				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[i][j];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					sum=0;
				}
				return 0;
			}
				//ouput
					ROW 1 = 9
					ROW 2 = 15
					ROW 3 = 33

		//wap to find sum of column elements
			#include <iostream>
			using namespace std;
			int main(){
				int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};

				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[j][i];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					sum=0;
				}
				return 0;
			}
				//ouput
					ROW 1 = 18
					ROW 2 = 19
					ROW 3 = 20

		//wap to find row who has largest sum.
			#include <iostream>
			#include<vector>
			using namespace std;
			int main(){

				int arr[3][3] = {{30,30,3},{5,5,5},{10,11,12}};
				
				vector<int> Lrow;
				
				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[i][j];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					Lrow.push_back(sum);
					sum=0;
				}
				
				//finding max sum row
				int row=0;
				for(int i=1;i<Lrow.size();i++){
					if(Lrow[row] < Lrow[i])
						row=i;
				}
				std::cout << "The maximum sum is present in row "<< row+1 << ", The largest sum is :"<< Lrow[row] << std::endl;
				return 0;
			}

			//or
				int largestRowSum(int arr[][3], int row, int col) {
					int maxi = INT_MIN;
					int rowIndex = -1;

					for(int row=0; row<3; row++) {
						int sum = 0;
						for(int col=0; col<3; col++) {
							sum += arr[row][col];
						}

						if(sum > maxi ) {
							maxi = sum;
							rowIndex = row;
						}
						
					}
					cout << "the maximum sum is " << maxi << endl;
					return rowIndex;
				}

		//wap to print array element in wave format
			Sample Input 1:
				2
				3 4
				1 2 3 4
				5 6 7 8
				9 10 11 12
				4 4
				1 2 4 5
				3 6 8 10
				11 12 13 15
				16 14 9 7
				Sample Output 1:
				1 5 9 10 6 2 3 7 11 12 8 4
				1 3 11 16 14 12 6 2 4 8 13 9 7 15 10 5 
				Explanation For Sample Input 1:
				Here, the elements are printed in a form of a wave, first, the 0th column is printed from top to bottom then the 1st column from bottom to top, and so on. Basically, the even column is printed from top to bottom and the odd column in the opposite direction.
			Sample Input 2:
				2
				1 1
				3
				1 2
				6 5
				Sample Output 2:
				3
				6 5 

			//Program:
				#include <iostream>
				#include<vector>
				using namespace std;
				int main(){

					int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};
					
					vector<int> ans;
					
					int sum=0;
					for(int i=0;i<3;i++){
						for(int j=0;j<3;j++)
							cout<<arr[i][j]<<"\t";
						cout<<"\n";
					}
					
					int r=0,c=0;
					
					while(c<3){
						while(1){
							// cout<<arr[r][c]<<"\t";
							ans.push_back(arr[r][c]);
							if(c%2==0){
								r++;
								if(r>2){
									r--; 
									break;
								}
							}else{
								r--;
								if(r<0){
									r++;
									break;
								}
							}
						}
						c++;
					}
					
					std::cout << std::endl;
					for(int i: ans)
						cout<<i<<" ";
					return 0;
				}

			//or
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					int col=0,row=0;
					vector<int> ans;
					while(col<mCols){
						while(1){
							ans.push_back(arr[row][col]);
							if(col%2==0){
								row++;
								if(row>=nRows){
									row--;
									break;
								}
							}else{
								row--;
								if(row<0){
									row++; 
									break;
								}
							}
						}
						col++;
					}
					return ans;
				}

			//or
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					vector<int> ans;
					for (int j = 0; j < mCols; j++){
						if (j % 2 == 0){
							for (int i = 0; i < nRows; i++){
								ans.push_back(arr[i][j]);
							}
						}else{
							for (int i = nRows - 1; i >= 0; i--){
								ans.push_back(arr[i][j]);
							}
						}
					}

					return ans;
				}

			//shorthand
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					vector<int> ans;
					for (int j = 0; j < mCols; j++)
						if (j % 2 == 0)
							for (int i = 0; i < nRows; i++)
								ans.push_back(arr[i][j]);
						else
							for (int i = nRows - 1; i >= 0; i--)
								ans.push_back(arr[i][j]);
					return ans;
				}
		
		//WAP to print array element in Spiral order (Spiral Matrix):
			https://leetcode.com/problems/spiral-matrix/
			class Solution {
				public:
				vector<int> spiralOrder(vector<vector<int>>& matrix) {
					vector<int> ans;

					//retrived no.of rows & columns
					int row = matrix.size();
					int col = matrix[0].size();

					//get to know the indexes
					int startingRow = 0;
					int startingCol = 0;
					int endingRow = row-1;
					int endingCol = col-1;

					//got to know that how many elements are there.
					int total = row * col;
					int cnt=0;
					//running the loop till we cover the all elements
					while(cnt<total){
						
						//printing starting Row
						for(int index=startingCol; cnt<total && index<=endingCol; index++){
							ans.push_back(matrix[startingRow][index]);
							cnt++;
						}
						startingRow++;

						//printing ending Col
						for(int index=startingRow; cnt<total && index<=endingRow; index++){
							ans.push_back(matrix[index][endingCol]);
							cnt++;
						}
						endingCol--;

						//printing ending Row
						for(int index=endingCol; cnt<total && index>=startingCol; index--){
							ans.push_back(matrix[endingRow][index]);
							cnt++;
						}
						endingRow--;

						//printing starting col
						for(int index=endingRow; cnt<total && index>=startingRow; index--){
							ans.push_back(matrix[index][startingCol]);
							cnt++;
						}
						startingCol++;
					}
					return ans;
				}
			};

			//or
				class Solution {
					public:
					vector<int> spiralOrder(vector<vector<int>>& matrix) {
						int row = matrix.size();
						int col = matrix[0].size();

						//creating vector
						vector<int> ans;
						
						//indexes
						int startingRow = 0;
						int startingCol = 0;
						int endingRow = matrix.size();
						int endingCol = matrix[0].size();

						int totalElements = row * col;
						int cnt=0;

						while(cnt<totalElements){
							//traversing starting Row
							for(int i=startingCol; cnt<totalElements && i<endingCol; i++){
								ans.push_back(matrix[startingRow][i]);
								cnt++;
							}
							startingRow++;

							//traversing last col
							for(int i=startingRow; cnt<totalElements && i<endingRow; i++){
								ans.push_back(matrix[i][endingCol-1]);
								cnt++;
							}
							endingCol--;
							
							//traversing last Row
							for(int i=endingCol-1; cnt<totalElements && i>=startingCol; i--){
								ans.push_back(matrix[endingRow-1][i]);
								cnt++;
							}
							endingRow--;
							
							//traversing starting col
							for(int i=endingRow-1; cnt<totalElements && i>=startingRow; i--){
								ans.push_back(matrix[i][startingCol]);
								cnt++;
							}
							startingCol++;
						}
						return ans;
					}
				};
		
		//WAP Rotate Image (array, column to row)
			https://leetcode.com/problems/rotate-image/
			//taking extra space by creating 2 vectors ans & temp,
				class Solution {
					public:
					void rotate(vector<vector<int>>& matrix) {
						vector<vector<int>> ans;
						vector<int> temp;
						for(int col=0; col<matrix[0].size(); col++){
							for(int row=matrix.size()-1; row>=0; row--){
								temp.push_back(matrix[row][col]);
							}
							ans.push_back(temp);
							temp.clear();
						}
						matrix = ans;
					}
				};
			
			//In-Place (without taking extra space)
				class Solution {
					public:
					void rotate(vector<vector<int>>& matrix) {
						int row = matrix.size();
						for(int i=0; i<row;i++){
							for(int j=0; j<=i;j++){
								swap(matrix[i][j], matrix[j][i]);
							}
						}
						for(int i=0;i<row;i++){
							reverse(matrix[i].begin(), matrix[i].end());
						}
					}
				};

		// Search a 2D Matrix:
			https://leetcode.com/problems/search-a-2d-matrix/description/
			class Solution {
				public:
				bool searchMatrix(vector<vector<int>>& matrix, int target) {

					int row = matrix.size();
					int col = matrix[0].size();

					int start =0;
					int end= row*col -1;
					int total = row*col;
					int mid = (start+end)/2;

					while(start<=end){
					int rowIndex = mid / col;
					int colIndex = mid % col;
					int value = matrix[rowIndex][colIndex];
					if(value == target)
						return 1;
					else if(value < target)
						start = mid + 1;
					else
						end = mid - 1;
					mid = (start + end )/2;
					}
					return false;
				}
			};
	
		// Search a 2D Matrix II:
			https://leetcode.com/problems/search-a-2d-matrix-ii/description/
			-here remember that, YOU ARE STARTING TO SEARCH THE TARGET VALUE FROM LAST COLUMN & STARTING ROW.
			class Solution {
				public:
				bool searchMatrix(vector<vector<int>>& matrix, int target) {
					// int row=0,col=0;
					// for(row;row<matrix.size();row++)
					//     for(col=0;col<matrix[0].size();col++)
					//         if(target == matrix[row][col])
					//             return 1;
					// return 0;
					int row = matrix.size();
					int col = matrix[0].size();

					int rowIndex = 0;
					int colIndex = col -1;

					while(rowIndex<row && colIndex>=0){
						int value = matrix[rowIndex][colIndex];
						if(value == target)
							return 1;
						else if(value<target)
							rowIndex++;
						else
							colIndex--;
					}
					return 0;
				}
			};
	
	❌Pending task,
		10 question leet code on 2D array
		1) Spiral Matrix II :
			https://leetcode.com/problems/spiral-matrix-ii/description/
			-Generating Spiral matrix from given n
				#include <iostream>
				#include<vector>
				using namespace std;

				vector<vector<int>> generateMatrix(int n) {

					vector<vector<int>> valueHolder(n,vector<int>(n,0));
					int rows,cols;
					rows = cols = n;

					int totalElements = rows * cols;
					cout<<totalElements<<endl;
					int startRow = 0;
					int startCol = 0;
					int endCol = cols-1;
					int endRow = rows-1;
					int cnt=0;

					while(cnt<totalElements){
						//traversing start row
						for(int i=startCol; cnt<totalElements, i<=endCol; i++){
							valueHolder[startRow][i] = ++cnt;
						}
						startRow++;

						//traversing last Col
						for(int i=startRow; cnt<totalElements, i<=endRow; i++){
							valueHolder[i][endCol] = ++cnt;
						}
						endCol--;

						//traversing last row
						for(int i=endCol; cnt<totalElements, i>=startCol; i--){
							valueHolder[endRow][i] = ++cnt;
						}
						endRow--;

						//traversing start col
						for(int i=endRow; cnt<totalElements, i>=startRow; i--){
							valueHolder[i][startCol] = ++cnt;
						}
						startCol++;
					}
					return valueHolder;
				}

				int main() {
					int n=5;
					vector<vector<int>> ans = generateMatrix(n);
					for(int i=0; i<n; i++){
						for(int j=0; j<n; j++)
							cout<<ans[i][j]<<"\t";
						cout<<endl;
					}
					return 0;
				}
			Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
				class Solution {
					public:
					vector<vector<int>> generateMatrix(int n) {
						vector<vector<int>> valueHolder(n,vector<int>(n,0));
						int rows,cols;
						rows = cols = n;
					
						int totalElements = rows * cols;
						cout<<totalElements<<endl;
						int startRow = 0;
						int startCol = 0;
						int endCol = cols-1;
						int endRow = rows-1;
						int cnt=0;

						while(cnt<totalElements){
							//traversing start row
							for(int i=startCol; cnt<totalElements, i<=endCol; i++){
								valueHolder[startRow][i] = ++cnt;
							}
							startRow++;

							//traversing last Col
							for(int i=startRow; cnt<totalElements, i<=endRow; i++){
								valueHolder[i][endCol] = ++cnt;
							}
							endCol--;

							//traversing last row
							for(int i=endCol; cnt<totalElements, i>=startCol; i--){
								valueHolder[endRow][i] = ++cnt;
							}
							endRow--;

							//traversing start col
							for(int i=endRow; cnt<totalElements, i>=startRow; i--){
								valueHolder[i][startCol] = ++cnt;
							}
							startCol++;
						}
						return valueHolder;
					}
				};

		2)
		3)
		4)
		5)
		6)
		7)
		8)
		9)
		10)
---------------------------------------------------------------------------------------------------------
	05/10/23
Lecture-24:Basic Maths for DSA || Sieve || Modular Arithmetics || Euclid’s Algorithm
	// Count Primes
		TC - O(n * log(log n))
		https://leetcode.com/problems/count-primes/description/
		Given an integer n, return the number of prime numbers that are strictly less than n.		
			Example 1:
				Input: n = 10
				Output: 4
				Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
			Example 2:
				Input: n = 0
				Output: 0
			Example 3:
				Input: n = 1
				Output: 0

			Constraints:
				0 <= n <= 5 * 106

		//NOT optimized:
			class Solution {
				public:
				bool checkPrime(int x)
				{
					for(int i=2;i<x;i++)
					{
						if(x%i==0) return 0;
					}
					return 1;
				}
				int countPrimes(int n) {
					if(n<=1) return 0;
					else
					{
						int count=0;
						for(int i=2;i<n;i++)
						{
							if(checkPrime(i))
							{
								count++;
							}
						}
						return count;
					}
				}
			};

		//Optimized:
			-The Sieve of Eratosthenes is an algorithm used to find all prime numbers less than a number. 
			The way it works is that, starting from 2, it creates a list of all integers from there until n. 
			Then, starting with 2 (which is the smallest prime), every multiple of 2 is marked as not a prime
			class Solution {
				public:
				int countPrimes(int n) {
					
					int cnt=0;
					vector<int> prime(n,1);
					if(n >=0 && n<=2)
						return cnt;

					prime[2] = 1;								//no need.

					
					for(int i=2; i<n; i++)
						if(prime[i] == 1){						// if(primes[i])
							for(int j=i+i; j<n; j += i)			//for(int j=i*2; j<n; j += i)
								prime[j] = 0;
							cnt++;
						}
					return cnt;
				}
			};
			
	❌Segmented sieve:
		https://www.codingninjas.com/studio/library/segmented-sieve

	//Euclid’s Algorithm:
		LCM(A,B) * HCF(A,B) = A*B;
		-computing the Greatest Common Divisor (GCD) of two positive integers
		
		#include <iostream>
		using namespace std;
		int gcd(int a, int b){
			if(a==0)
				return b;
			
			if(b==0)
				return a;
				
			while(a!=b){
				
				if(a>b){
					a-=b;
				}else{
					b-=a;
				}
			}
			return a;
		}

		int main(){	
			int a,b;
			std::cout << "Enter 2 nums: " << std::endl;
			cin>>a>>b;
			
			int ans = gcd(a,b);
			
			std::cout << "The gcd of "<<a<<" "<<b<<" is : "<< ans << std::endl;
			return 0;
		}

	//modularExponentiation:
		-refer this program again in POTD section or search once with this name modularExponentiation.
		#include <bits/stdc++.h>
		int modularExponentiation(int x, int n, int m) {
			long long power=1;
			long long base = x;
			if(n==0)
				return power;
			int i=1;
			while(n>0){
				if(n&1)
					power = (power%m * base%m) % m;

				base = (base * base)%m ;
				n/=2;
			}
			/*
				while(n>0){
					if(n&1)
						power = (1ll * power * x%m)%m;		
					n/=2;
					x = (1ll * x%m * x%m)%m;		//or
													//x = (1LL * x%m * x%m)%m; //type casting to long
				}
			*/
			return power;
		}

	//calculating exponents of any number by any number
		optimized way
		#include <iostream>
		using namespace std;

		int main(){
			
			//here calculating 2¹⁰. for this method requre 10 iteration
			int a=2;
			int ans=1;
			std::cout << "10th power " << std::endl;
			for(int i=0; i<10; i++){
				cout<<"Pass-"<<i+1<<"\n";
				ans = ans * a;
			}
			std::cout << "ANS: "<<ans << std::endl;
			
			//for this method require 4 to 5 iterations
			ans=1;
			int cnt=1;
			for(int i=10; i>0;){
				cout<<"Pass-"<<cnt++<<" ";
				if(i&1)
					ans = ans * a;
				a = a * a;
				i /=2;
			}
			cout<<"ANS:"<<ans;
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;

			int main() {
			
				int ans=1;
				int n=3, power = 10;
				int cnt=0;
				while(power > 0){
					cout<<"pass "<<++cnt<<"\n";
					if(power&1)
						ans = ans * n;
					
					a = a * a;
					power /= 2;
				}
				std::cout << ans << std::endl;
				return 0;
			}
	
	❌
	https://codeforces.com/blog/entry/72527
	https://www.codingninjas.com/studio/library/gcd-euclidean-algorithm
	pigeon hole principle 4 question
	catalan number
	inclusion-exclusion principle.
	-factorial of num 212!%mod , mod = 1e9+7;
---------------------------------------------------------------------------------------------------------
	09/10/23
Lecture 25: Pointers in C++ || Part-1
	-Symbol Table is an important data structure created and maintained by the compiler in
	 order to keep track of semantics of variables i.e. it stores information about the scope and
	 binding information about names, information about instances of various entities such as
	 variable and function names. classes. obiects. etc.
	syntax:
		dataType * pointer_name = &(var_name);

	eg. pointer to double.
		double d = 90.8978;
		double * ptr = &d;

	//BAD PRACTICE:
		-never create pointer like this, just declared, un-initialized.
		int *p;			//this will point to random location & make random changes to memory.
	
	//don't know where to point, initialize with 0.
		int * p = 0;		//null pointer, pointing to memory location which is not exist.
		-this will create a segmentation fault.

	#include <iostream>
	using namespace std;

	int main() {

		int num = 90;           //this num name is mapped to some memory address where 90 is stored. (symbol table)
		std::cout << num << std::endl;

		//memory address is hexadecimal value contains 0-9 & A-F.
		//memory address is retrived by using &(ampersand operator).
		std::cout << "Address of num : " << &num << std::endl;
		
		//storing that memory address, we can store the memory address in pointer.
		//defining different way of declaring pointer.  
		//1. star is in the middle
		int * ptr1 = &num;
		std::cout << ptr1 << std::endl;      //memory location
		std::cout << *ptr1 << std::endl;     //value at that memory location
		
		std::cout << std::endl;
		int a=1;
		//2. star is attched to pointer name.
		int *ptr2 = &a;
		std::cout << ptr2 << std::endl;      //memory location
		std::cout << *ptr2 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)
		
		std::cout << std::endl;
		int b=23;
		//3. star is attched to datatype of pointer
		int* ptr3 = &b;
		std::cout << ptr3 << std::endl;      //memory location
		std::cout << *ptr3 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)
			
		return 0;
	}

	-Here, in above program num has some address & num is a variable name, mapped to that address.
	eg.
		int n=43;
		int* ptr1 = &n;
		cout<<*ptr1;		//* act as dereferencing operator
			-pointer to int
			-you must create pointer of same datatype as that of variable on right side (n).
		
		char ch = 'Z';
		char* ptr2 = &ch;
			-pointer to character.

		
		double d = 4.545;
		double* ptr3 = &d;
			-pointer to double.
	
	-Pointer is used to store the addresses of variable so the size of pointer for any
		dataType will be 8.

	-A string in Solidity is length prefixed with its 256-bit (32 byte) length.
	eg.
			#include <iostream>
			using namespace std;

			int main() {
				int n=43;
				int* ptr1 = &n;
				cout<<"n="<<*ptr1<<endl;		//* act as dereferencing operator
				
				std::cout << "n size : "<< sizeof(n) << std::endl;
				std::cout << "n pointer size "<< sizeof(ptr1) << std::endl;
					
				char ch = 'Z';
				char* ptr2 = &ch;
				std::cout << std::endl;
				std::cout << "ch = "<< *ptr2 << std::endl;
				std::cout << "ch size "<< sizeof(ch) << std::endl;
				std::cout << "ch pointer size "<< sizeof(ptr2) << std::endl;
				
				double d = 4.545;
				double* ptr3 = &d;
				std::cout << std::endl;
				std::cout << "d = "<< *ptr3 << std::endl;
				std::cout << "d size "<< sizeof(d) << std::endl;
				std::cout << "d pointer size "<< sizeof(ptr3) << std::endl;
				
				string s = "Vivek Mahesh Nikate";
				string * str_ptr = &s;
				std::cout << std::endl;
				std::cout << "string = "<< *str_ptr << std::endl;

				std::cout << "s size "<< sizeof(s) << std::endl;
				std::cout << "s pointer size "<< sizeof(ptr2) << std::endl;

				return 0;
			}
			//ouput:
				n=43
				n size : 4
				n pointer size 8

				ch = Z
				ch size 1
				ch pointer size 8

				d = 4.545
				d size 8
				d pointer size 8

				string = Vivek Mahesh Nikate
				s size 32
				s pointer size 8

	//pointer declararing, afterwords initializing
		
		#include <iostream>
			using namespace std;
			int main() {
				
				int n=43;
					int* ptr1 = NULL;          //null pointer  
					
				// 	or
				// 	int* ptr1 = 0;
					
					cout<<ptr1<<endl;					//0
				// 	std::cout << *ptr1 << std::endl;            //segmentation fault
					
					ptr1 = &n;          //re-initialized to address of n.
				std::cout << *ptr1  << std::endl;				//43

				return 0;
			}

		#include <iostream>
			int main() {
				char ch = 'K';
				char* ptrCH = nullptr; // Use nullptr instead of 0
				//char* ptrCH = 0

				if (ptrCH == nullptr) {
					std::cout << "0" << std::endl;			//0
				} else {
					std::cout << *ptrCH << std::endl;
				}

				ptrCH = &ch;
				std::cout << *ptrCH << std::endl;				//K
				return 0;
			}

	//Pointer increment:
		#include <iostream>
		using namespace std;

		int main(){
		
			int a = 45;
			
			int *p = &a;
			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address of a: "<< p << std::endl;
			std::cout << "Address of a: "<< &a << std::endl;
			
			//integer is of 4 bytes so,
			(*p)++;             //use brackets to increment value at that location,
			std::cout <<"value : " <<*p << std::endl;
			
			p++;                                               // nextAddress = prevAddress + 4
			//increment pointing Address use above syntax. Here pointer p incremented by 4 bytes coz int is of 4 bytes.
			std::cout << "Address of ptr : "<< p << std::endl;
			
			return 0;
		}
		//ouput:
			A : 45
			*p : 45
			Address of a: 0x7fff5dd4ba7c
			Address of a: 0x7fff5dd4ba7c				(prev Address)
			value : 46
			Address of ptr : 0x7fff5dd4ba80			(new Address)

			prevAddress last 2 digit = 7c after incremeting by 1 ie. 4 bytes, last digit c after c ,d, e, f, 0.
			after 7, there is 8,
			so new address will be like this 7c+4 => 80 and store in the pointer variable.

	//Operations:
		#include <iostream>
		using namespace std;
		int main() {
			int num =5;
			std::cout << num << std::endl;              //5
			
			int a = num;
			std::cout << a << std::endl;                //5
			a++;
			std::cout << a << std::endl;                //6          
			std::cout << num << std::endl;              //a doesn't affect to num, coz its copy.    //5
			
			int * p1 = &num;
			std::cout << "pointer works: " << std::endl;
			std::cout << "num using pointer : "<< *p1 << std::endl;         //5
			std::cout << "normal num "<< num << std::endl;                  //5
			
			//increment p1, will affect on normal num
			std::cout << "Address before :" << p1 << std::endl;
			*p1++;                              //use brackets here else it will change the pointing address
			std::cout <<"Address After : "<< p1 << std::endl;
			
			p1 = &num;
			std::cout << num << std::endl;
			std::cout << *p1 << std::endl;
			
			(*p1)++;
			std::cout << *p1 << std::endl;
			
			num++;
			std::cout << num << std::endl;
			std::cout << *p1 << std::endl;
			
			return 0;
		}

	//Call By Value & Call by Reference:

		#include <iostream>
		using namespace std;

		void callByValue(int n){
			n++;
			std::cout << "inside function : "<< n << std::endl;
		}

		void callByReference(int &n){
			n++;
			std::cout << "Inside ref function : "<< n << std::endl;
		}

		int main() {
			int a = 88;
			
			//call by value, it makes copy of original variable
			std::cout << "Before "<<a << std::endl;
			callByValue(a);
			std::cout << "After "<<a << std::endl;
			
			//call by reference makes changes in (modify) original variable.
			int *p = &a;
			std::cout << "Before : "<< a << std::endl;
			callByReference(*p);
			std::cout << "After : "<< a << std::endl;
			
			return 0;
		}
		// output:
				Before 88
				inside function : 89
				After 88
				Before : 88
				Inside ref function : 89
				After : 89

	//Copying a pointer to Another pointer:
		#include <iostream>
		using namespace std;
		int main(){
			
			int a = 45;
			int *p = &a;

			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address using &a : "<< &a << std::endl;
			std::cout << "Address using p : "<< &a << std::endl;
			
			// copying pointer
			int *q = p;
			std::cout << "*q : "<< *q << std::endl;
			std::cout << "Address of q " << q << std::endl;
			return 0;
		}
		//ouput:
			A : 45
			*p : 45
			Address using &a : 0x7ffe389b3f14
			Address using p : 0x7ffe389b3f14
			*q 45
			Address of q 0x7ffe389b3f14
		
	//Double Pointer: pointer to pointer
		#include <iostream>
		using namespace std;

		int main(){
			int a = 45;
			
			int *p = &a;
			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address of a: "<< p << std::endl;
			std::cout << "Address of a: "<< &a << std::endl;
			
			int **ptrTOptr = &p;
			std::cout << "pointer to pointer : " <<**ptrTOptr << std::endl;
			std::cout << "Address pointer p:"<< ptrTOptr << std::endl;
			std::cout << "Address pointer p:"<< &p << std::endl;
			return 0;
		}

	//
---------------------------------------------------------------------------------------------------------
#miscellaneous
	//Ternary Operator
		#include <iostream>
		using namespace std;
		int main(){
			//both ways work
			//cout function within ternary operator
			(1==1)? cout<<"Right 1==1"<<endl : cout<<"Wrong X"<<endl;
			
			//ternary operator within cout function
			std::cout << ((2==20)? "Yes True.. 2==20" :"No Wrong 2!=20") << std::endl;
			
			return 0;
		}

	//Curly braces related..

		#include <iostream>
		using namespace std;

		int main()
		{
			if(0)
				if(0)
					std::cout << "nested if" << std::endl;
			else
				cout<<"nested else";					//if this else block is not present then outside else block got attached to inner if block
			else										//works like putting curly braces around if-else block.
				cout<<"outside if main IF got FALSE";
					
			return 0;
		}
	
	//If-else without using {}
		#include <iostream>
		using namespace std;
		int main() {
			int n = 91,cnt=80;
			if (n == 90)
				cout << "It's 90.. ayyyyye.." <<  endl,
				cout << "Another sentence" <<  endl;
			else
				cout << "Wrong, it's not 90" <<  endl, 
				cout << "It's the else part without using {} braces" <<  endl, 
				cnt = 10, 
				cout << "The count in the else block is " << cnt <<  endl;

			return 0;
		}
		
	//Label
		if() can accept any non-zero or -ve value considered as true 
		if 0 then false.
		#include <iostream>
		using namespace std;
		int main(){
		
			if(2)					//if(-2)			this is also true.
				goto L2;

			L1: 
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			
			L2:
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			
			L3:
			return 0;
		}

	//Factorial:
		//fact program
		//position of increment decrement operator matters a LOTTTTTTTTT.
		#include <iostream>
		using namespace std;
		int main(){
			int n,t;
			cin>>n;
			t=n-1;
			
			while(t)
				n *= t--;
			
			std::cout <<endl<< n << std::endl;
			return 0;
		}

	//SWAP function:
		#include <iostream>
		using namespace std;

		int main(){
			int a = 10;
			int b = 20;
			cout << "Value of a before: " << a << endl;
			cout << "Value of b before: " << b << endl;

			// swap values of the variables
			swap(a, b);			//takes 2 values.

			//or
			a = a + b;	//a^b		//10+20=30
			b = a - b;	//a^b		//30-20=10
			a = a - b;	//a^b		//30-10=20

			cout << "Value of a now: " << a << endl;
			cout << "Value of b now: " << b << endl;
			return 0;
		}

	//while loop:
		#include <iostream>
		using namespace std;

		int main(){
			int i=0,j=0;
			
			while(i<5 && j<10){
				
				std::cout << i<<" "<<j << std::endl;			// and Operator is there so both condition must be true.
				i++;j++;									//output will be 0 to 4,
			}
			return 0;
		}

		//or if we used || or (,) then 0 - 9 will be printed.
		#include <iostream>
		using namespace std;

		int main(){
			int i=0,j=0;
			while(i<5 , j<10){          //while(i<5 || j<10)
				std::cout << i<<" "<<j << std::endl;
				i++;j++;
			}

			return 0;
		}

	//Remain 
		//Line 4499 Triplet sum didn't understand❌ (come back here later.).
		-Check TLE again (Time Limit Exceeded). https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/

	//Self Solved:
		1. Two Sum
			vector<int> twoSum(vector<int>& nums, int target){
				vector<int> ans;
				
				for(int i=0;i<nums.size(); i++){
					for(int j=i+1; j<nums.size(); j++){
						if(nums[i]+nums[j] == target){
							ans.push_back(i);
							ans.push_back(j);
						}
					}
				}
				return ans;
			}

		2. Coding Ninja Content:
			Container with Maximum Water:
				#include <bits/stdc++.h> 
				int maxAreaContainer(vector<int> &arr){
					int n = arr.size();
					int area, mainMax=0;

					for(int i=0; i<n-1;i++){
						for(int j=i+1; j<n; j++){
							area = min(arr[i], arr[j]) * (j-i);

							if(mainMax < area)
								mainMax = area;
						}    
					}
						return mainMax;
				}

				//optimized:
					#include <bits/stdc++.h> 
					int maxAreaContainer(vector<int> &arr){
						int n = arr.size();
						int left = 0;
						int right = n - 1;
						int mainMax = 0;

						while (left < right) {
							int width = right - left;
							int height = min(arr[left], arr[right]);
							int area = width * height;

							mainMax = max(mainMax, area);

							if (arr[left] < arr[right]) {
								left++;
							} else {
								right--;
							}
						}
						return mainMax;
					}

		3. Subarray with given sum
			vector<int> subarraySum(vector<int>arr, int n, long long s){
				
				int start = 0;
				long long sum = 0;
				vector<int> v;
			
				if (s == 0) // Handle the case where target sum is 0
				{
					v.push_back(-1);
					return v;
				}
				
				for (int i = 0; i < n; i++)
				{
					sum += arr[i];
			
					while (sum > s && start <= i)
					{
						sum -= arr[start];
						start++;
					}
			
					if (sum == s)
					{
						v.push_back(start + 1);
						v.push_back(i + 1);
						return v;
					}
				}
				v.push_back(-1); // If no subarray found
				return v;
			}

			//or
				vector<int> subarraySum(vector<int>arr, int n, long long s){
					// Your code here
					vector<int> res;
					bool bl = false;
					for (int i = 0; i < n; i++) {
						int currentSum = arr[i];
					
						if (currentSum == s) {
							res.push_back(i+1);
							res.push_back(i+1);
							bl=true;
							break;
						}
						else {
							// Try all subarrays starting with 'i'
							for (int j = i + 1; j < n; j++) {
								currentSum += arr[j];
					
								if (currentSum == s) {
									res.push_back(i+1);
									res.push_back(j+1);
									bl=true;
									break;
								}
							}
							if(bl) break;
						}
					}
					if(bl) return res;
						return {-1};
				}

		4. Smaller and Larger:
			vector<int> getMoreAndLess(int arr[], int n, int x) {
				int GreaterCount=0, LessCount=0;
				
				for(int i=0;i<n; i++){
					if(arr[i]>= x)
						GreaterCount++;
					
					if(arr[i]<=x)
						LessCount++;
				}
				
				vector<int> v;
				v.push_back(LessCount);
				v.push_back(GreaterCount);
				return v;
			}
		
		-Refere few programs from here also...
			https://auth.geeksforgeeks.org/user/viveknikate/practice

	//Char extraction & string addition:
		int main (){
			string firstName = "John ";
			char lastName =firstName[0];
			char n = 'f';
			string s;
			s+= n;
			s+= lastName;
			cout << s;
			return 0;
		}

	//CHAR_BIT:
		-This C++ program will output the value of the `CHAR_BIT` constant, 
		 which represents the number of bits in a `char` data type on the particular platform and compiler being used.
		-In most systems, a `char` data type is 8 bits (1 byte), but it's not guaranteed to be the same on all platforms. 
		 The `CHAR_BIT` constant is defined in the `<climits>` header in C++ and specifies 
		 the number of bits in the smallest addressable unit of the machine's memory.
		-So, when you run this program, it will likely output `8`, indicating that a `char` consists of 8 bits on your platform.
		eg.
			#include <iostream>
			#include <climits>
			using namespace std;
			int main(){
				cout<<CHAR_BIT<<"\n";
				cout<<CHAR_BIT * sizeof(int)<<"\n";
				return 0;
			}
			//ouput:
				8
				32

	//String initialization:
		#include <iostream>
		using namespace std;

		int main(){
			string s(10, 'V');
			std::cout << s << std::endl;
			return 0;
		}

	//String length calculate:
		-use size() or length function.
		#include <iostream>
		using namespace std;

		int main(){
			string s ="Vivek";
			std::cout << s.size() << std::endl;         //11
			std::cout << s.length() << std::endl;       //11

			return 0;
		}

	//Max of integer:
		int max_of_four(int a, int b, int c, int d){
			return max(max(a,b),max(c,d));
		}

	//String assinging value at specific index:
		#include <iostream>
		using namespace std;
		int main(){
			string a,b;
			cin>>a;
			cin>>b;
			
			cout<<a.length()<<" "<<b.length()<<endl;
			cout<<(a+b)<<endl;

			swap(a[0],b[0]);
			cout<<a<<" "<<b<<endl;
			
			a[0]='Z';
			b[2]='Q';
			
			cout<<a<<" "<<b;
			return 0;
		}
		//ouput:
			Vivek 
			Rohini
			5 6
			VivekRohini
			Rivek Vohini
			Zivek VoQini

	//Local variables are stored in an area called a stack. Global variables, static variables, and program instructions 
	 are stored in the permanent storage area. The memory space between these two regions is known as a heap.

	#modulus operator:
		-when you take mod operation on any num with x, then output
		 will be inbetween 0 to (x-1);
		 eg.
		 	with 5: output will be 0 to 4.	|	with 10: output will be 0 to 9.
			1 % 5 = 1						|		1 % 10 = 1
			2 % 5 = 2						|		2 % 10 = 2
			3 % 5 = 3						|		3 % 10 = 3
			4 % 5 = 4						|		4 % 10 = 4
			5 % 5 = 0						|		5 % 10 = 5
			6 % 5 = 1						|		6 % 10 = 6
			7 % 5 = 2						|		7 % 10 = 7
			8 % 5 = 3						|		8 % 10 = 8
			9 % 5 = 4						|		9 % 10 = 9
			10 % 5 = 0					|		10 % 10 = 0
		
		Properties:
			◎  (a % m) + (b % m) = (a + b) % m
			◎  (a % m) - (b % m) = (a - b) % m
			◎  (a % m) * (b % m) = (a * b) % m

	//Finding maximum num from vector
		-using max_element function.
		-we need to take iterator for this.
		-max_element function found in algorithm header file sp include algorithm.
			#include <iostream>
			#include<vector>
			#include<algorithm>
			using namespace std;

			int main(){
				vector<int> ans = {1,2,3,4,5,6,7,8,9,910};
				
				auto maxer = max_element(ans.begin(), ans.end());
				std::cout << *maxer << std::endl;
				
				//max element from 3rd position to 7th position, 0-index based. means between 4 & 8.
				//both index inclusive 3rd & 7th also, but max_element function exclude the last index that's why we added 1 manually
				maxer = max_element(ans.begin()+3, ans.begin()+7+1);        
				std::cout <<*maxer << std::endl;

				//To know the type of particular variable:

				auto maxer = max_element(ans.begin(), ans.end());
				std::cout << *maxer << std::endl;
				std::cout << typeid(maxer).name() << std::endl;
				std::cout << typeid(ans).name() << std::endl;
				
				int c;
				std::cout << typeid(c).name() << std::endl;
				string s="asdf";
				std::cout << typeid(s).name() << std::endl;

				return 0;
			}
		
	//Dynamic array Creation:
		#include<iostream>
		using namespace std;
		int main() {
			int x, n;
			cout << "Enter the number of items:" << "\n";
			cin >>n;
			int *arr = new int(n);
			cout << "Enter " << n << " items" << endl;
			for (x = 0; x < n; x++) {
				cin >> arr[x];
			}
			cout << "You entered: ";
			for (x = 0; x < n; x++) {
				cout << arr[x] << " ";
			}
			return 0;
		}
		1. Include the iostream header file into our program to use its functions.
		2. Include the std namespace in our program in order to use its classes without calling it.
		3. Call the main() function. The program logic should be added within the body of the function.
		4. Declare two integer variables x and n.
		5. Print some text on the console prompting the user to enter the value of variable n.
		10/4/23, 5:42 PM C++ Dynamic Allocation of Arrays with Example
		6. Read user input from the keyboard and assigning it to variable n.
		7. Declare an array to hold a total of n integers and assigning it to pointer variable *arr.
		8. Print a message prompting the user to enter n number of items.
		9. Use a for loop to create a loop variable x to iterate over the items entered by the user.
		10. Read the elements entered by the user and storing them in the array arr.
		11. End of the body of the for loop.
		12. Print some text on the console.
		13. Use a for loop to create a loop variable x to iterate over the items of the array.
		14. Print out the values contained in the array named arr on the console.
		15. End of the body of the for loop.
		16. The program must return value upon successful completion.
		17. End of the body of the main() function.

		//Another example
			Dynamically Deleting Arrays:
				A dynamic array should be deleted from the computer memory once its purpose is fulfilled. 
				The delete statement can help you accomplish this. 
				The released memory space can then be used to hold another set of data. 
				However, even if you do not delete the dynamic array from the computer memory, 
				it will be deleted automatically once the program terminates.

			Note:
				To delete a dynamic array from the computer memory, you should use delete[], 
				instead of delete. The [] instructs the CPU to delete multiple variables rather than one variable. 
				The use of delete instead of delete[] when dealing with a dynamic array may result in problems. 
				Examples of such problems include memory leaks, data corruption, crashes, etc.

			#include<iostream>
			using namespace std;
			int main() {
				int x, n;
				cout << "How many numbers will you type?" << "\n";
				cin >>n;
				int *arr = new int(n);
				cout << "Enter " << n << " numbers" << endl;
				for (x = 0; x < n; x++) {
					cin >> arr[x];
				}
				cout << "You typed: ";
				for (x = 0; x < n; x++) {
					cout << arr[x] << " ";
				}
				cout << endl;
				delete [] arr;
				return 0;
			}
			Summary
				-Regular arrays have a fixed size. You cannot modify their size once declared.
				-With these types of arrays, the memory size is determined during compile time.
				-Dynamic arrays are different. Their sizes can be changed during runtime.
				-In dynamic arrays, the size is determined during runtime.
				-Dynamic arrays in C++ are declared using the new keyword.
				-We use square brackets to specify the number of items to be stored in the dynamic array.
				-C++ Dynamic Allocation of Arrays with Example
				-Once done with the array, we can free up the memory using the delete operator.
				-Use the delete operator with [] to free the memory of all array elements.
				-A delete without [] frees the memory of only a single element.
				-There is no built-in mechanism to resize C++ arrays.

	//count the no.of digit in number:

		#include <iostream>
		#include<cmath>
		using namespace std;

		int main() {
			//get no.of digit in n;
			long n= 123456789;
			
			std::cout << n << std::endl;
			std::cout << "no.of digit : "<< static_cast<int>(log10(n)+1)<< std::endl;
			
			std::cout << "no.of digit : "<< (int) log10(n)+1<< std::endl;
			std::cout << "no.of digit : "<< static_cast<int>(log10(n)+1)<< std::endl;    
			
			//static_cast<int> used to convert from double or float to int.
			// or to count the no.of digit in n, you can use this also...
			int cnt=0;
			while(n>0){
				cnt++;
				n/=10;
			}
			std::cout << "The CNT : "<< cnt << std::endl;
			return 0;
		}
---------------------------------------------------------------------------------------------------------
POTD:-[Problem of the Day]
	1) Minimum Difference in an Array	
		#include <bits/stdc++.h> 
		int minDiff(int n, vector < int > arr) {
			sort(arr.begin(), arr.end());
			// int minDiffHold = abs(arr[0] - arr[1]);      //or you can assign INT_MAX here also

			int minDiffHold =INT_MAX; 
			for (int i = 0; i < n - 1; i++) {
				if (arr[i] == arr[i + 1])
				return 0;

				int value = abs(arr[i] - arr[i + 1]);

				// assigning minimum value to mindiffhold variable.
				minDiffHold = min(value, minDiffHold);
			}
			return minDiffHold;
		}

	2) Reverse Coding:
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int row = mat.size();
			int column = mat[0].size();
			
			vector<vector<int>> v;

			for (int i = 0; i < row; i++) {

				vector<int> second;
				for (int j = column - 1; j >= 0; j--){
					int value = mat[i][j];
					second.push_back(value);
				}
				v.push_back(second);
			}

			return v;
		}

		//or
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int i=0,n = mat.size();

			while(i<n){
				reverse(mat[i].begin(), mat[i].end());
				i++;
			}
			return mat;
		}

	3) Planet Division:
		vector<int> planetDivision(int n) {
			vector<int> v;
			(n % 2 == 0)?(v.push_back(n/2), v.push_back(n/2)):(v.push_back((n/2)+1), v.push_back(n/2));
			return v;
		}

	4) Missing number in array:
		class Solution{
			public:
			int missingNumber(vector<int>& array, int n) {
				//(TLE)
				// for(int i=1;i<=n;i++){
				//     int j;
				//     for(j=0;j<n;j++){
				//         if(array[j] == i)
				//             break;
				//     }
				//         if(j == n)
				//             return i;
				// }
				
				/or (TLE)
				// int counter = 1, i=0;
				// while(i<n){
				//     if(array[i++] == counter){
				//         i=0;
				//         counter++;
				//     }
				// }
				// return counter; 
				
				//or (optimized)
				sort(array.begin(), array.end());
				for(int i=0;i<n;i++){
					if(array[i] != i+1)
						return i+1;
				}
			}
		};

		//more optimized:
			class Solution{
				public:
				int missingNumber(vector<int>& array, int n) {
					// sort(array.begin(), array.end());
					// for(int i=0; i<n; i++){
					//     if(array[i] != i+1)
					//         return i+1;
					// }
					long long actSum = (n*(n+1))/2;
					long long SumArr =0;
					for(int z: array){
						SumArr += z;
					}
					return actSum - SumArr;
				}
			};

	5) Count Odd Even
		void countOddEven(int arr[], int sizeof_array)
		{
			int odd=0, even=0;
			for(int i=0; i<sizeof_array;i++){
				(arr[i] % 2)? odd++ : even++;
			}
			cout<<odd<<" "<<even<<"\n";
		}

	6) Pattern 11
		void printTriangle(int n) {
			int bit = 0;
			for(int i=0;i<n; i++){
				int tempBit = bit;
				for(int j=0; j<=i; j++){
					(tempBit)?(tempBit =0):(tempBit = 1);
					cout<<tempBit<<" ";
				}
				if(bit == 0)
					bit =1;
				else
					bit = 0;
				printf("\n");
			}
		}
		//output
			Input: 5
			Output:
				1 
				0 1 
				1 0 1
				0 1 0 1 
				1 0 1 0 1

	7) Boring Factorial:
		Input:
			3
			2 5			(2!) % 5 =2
			5 11			(5!) % 11 =10
			21 71		(21!) % 71 =6

		Output:
			2
			10
			6
		#include <iostream>
		using namespace std;

		int main(){	
			int fact=1;
			int n=23,p=29;
			
				if(n >= p)
					return 0;

				for(int i=1;i<=n; i++){
					fact = (fact * i) % p; 
				cout<< fact<<"\t";
				}
			return 0;
		}

	8) Class Test:
		Sample Input 1 :
			2
			3
			1
			3 4 4
			4
			3
			1 1 2 2 
		Sample Output 1 :
		4
		1
		Explanation Of Sample Input 1 :
		For test case 1 we have, 

		To get a Rank 1, Ninja must have scored maximum marks in the class.
		Hence, Ninja scored 4 marks.
		For test case 2 we have,
		Students with marks = 2 will achieve ranks 1 and 2 respectively.
		Students with marks = 1 will achieve ranks 3 and 4 respectively.
		So, Ninja scored 1 mark.
		Sample Input 2 :
			test cases : 3
			i.	2
				1
				20 9 

			ii.	2
				1
				9 17 

			iii.	7
				2
				9 6 0 2 20 10 5 
		Sample Output 2 :
			20
			17
			10

		#include <bits/stdc++.h> 
		int classTest(int n, vector<int> &a, int k) {
			sort(a.begin(), a.end());
			reverse(a.begin(), a.end());

			int mark=a[0], temp =1;
			for(int i=0;i<n;i++){
				if(temp == k){
						mark = a[i];
					}
				temp++;
			}
			return mark;
		}

	9) Find the lone set bit & return its index.
		#include <iostream>
		#include <bitset>
		using namespace std;

		int main(){
			int N = 136;
			cout<<"binary form 136 "<<bitset<32>(N);
			std::cout << std::endl;
			if(N == 0){
				cout<<-1;
				return 0;
			}

			int count=0;
			if(N&1){
				cout<<-1;
				return 0;
			}else{
				int setBit =0;
				while(N>0){
					if(setBit == 1 && N >0){
						cout<<-1;
						return 0;
					}
					
					if(N & 1)
						setBit++;       //111010
					
					count++;
					N>>=1;
				}
			}
			cout<<count;
			return 0;
		}
	
	10) String Count:
		Sample Input 1:-
			2
			4 
			##**    
			3
			***
			Sample Output 1:-
			1
			0
			Explanation Of Sample Input 1:-
			First test case:- 
			We have three substrings of size 2 for the string 'S', which are "##", "#*" and "**".
			Only one of them is good(#* or *#) . So, the total number of good substrings of 'S' is 1.

			Second test case:-
			There is no good substring in 'S', so the answer is 0.
			Sample Input 2:-
			2
			4
			#*#*
			2
			*#
			Sample Output 2:-
				3
				1

			int stringCount(int n, string &s) {
				int ttl=0;
				int len = s.length();
				
				for(int i=0; i<len; i++){
					
					char first = s[i];
					char sec = s[i+1];
					string str = "";
					str += first;
					str += sec;
					
					if(str == "#*" || str == "*#")
						ttl++;
				}

				return ttl;
			}

	11) Sequence Query:
		Sample Input 1:
			start value, diff, target
			1 2 7
		Sample Output 1 :
			1
		Explanation For Sample Input 1:
		The sequence here is 1, 3, 5, 7, .... As 7 is present in the sequence, the output is 1.

		Sample Input 2:
		5 0 3
		Sample Output 2 :
		0
		Explanation For Sample Input 2:
		The sequence here is 5, 5, 5, .... As 3 is not present in the sequence, the output is 0.

		int checkSequence(int a, int d, int x) {
			// Write your code here.
			if(a == x || (d==1 && a<x))
				return 1;
			
			if((a > x && d>0) || (a < x && d<0))
				return 0;

			int counter=0;

			for(int start=a; ;start+=d)
			{

				a += d;
				if(a == x)
					return 1;

				counter++;
				if(counter>30)
					return 0;
			}
		}

	12) min & max:
		without using conditional operator, ternary operator
		eg.
			pair<int,int> ans= {a,b};
			for(int i=b;i<a;i++) {
				ans = {b,a};
				break;
			}
			return ans;		//returning minimum, maximum.

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				pair<int,int>pr;

				int max = (a>=b)*a+(b>a)*b;
				int min = (a<=b)*a+(b<a)*b;

				pr.first = min;
				pr.second = max;

				return pr;
			}

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				int mini = min(a,b);
				int maxi = max(a,b);
				
				pair<int,int> pr;
				// pr.first = mini;
				// pr.second = maxi;
				//or

				pr = {mini, maxi};
				return pr;
			}

		eg.
			#include <bits/stdc++.h>
			pair < int , int > findMinMax(int a , int b){
				return {min(a,b),max(a,b)};
			}
	
	13) Fibonacci series nums addition within given range:❌
		#include <bits/stdc++.h> 
		int fiboSum(int n , int m){
			int sum = 0;
			if(n<2) sum = 1;

			int a = 0, b = 1, mod = 1e9+7;

			for(int i=2;i<=m;i++){
				int c = (a+b)%mod;
				a = b;
				b = c;
				if(i>=n && i<=m)sum = (sum+c)%mod;
			}

			return sum;
		}

		#include <bits/stdc++.h> 
		long long int fiboSum(int n , int m){
			long long int prev =0, cur =1, fib=0;
			long long int sum=0;
			
			for(int i=0; i<=m; i++){
				
				// if(i>=n)
				// 	sum += prev;


				sum += prev;

				if(i<n)
					sum -= prev;
					
				fib = cur + prev;		 
				prev = cur;
				cur = fib;				 
			}
			return sum;	
		}

	14) Water Glass
		Sample Input 1:
		2
		2 2 2 3
		1 1 1 3
		Sample Output 1:
		normal
		cold
		##### Explanation Of Sample Input 1:

		For test case 1:
		The arrangement of glasses looks like,
		W W N N C C W W N N C C …………..
		Here the 3rd glass is N means it contains normal water.

		Hence, the answer for this case is "normal".


		For test case 2:
		The arrangement of glasses looks like,
		W N C W N C …………..
		Here the 3rd glass is C means it contains cold water.

		Hence, the answer for this case is "cold".
		Sample Input 2:
		2
		5 6 8 15
		9 3 3 12
		Sample Output 2:
		cold
		normal

		string waterGlass(long long x, long long y, long long z, long long n){
			// Write your code here.
			long long i,wrm, nrm, cld;
			vector<int> v;

			back:
			for(wrm=0; wrm<x; wrm++)
				v.push_back(1);

			for(nrm=0;nrm<y;nrm++)
				v.push_back(2);
			
			for(cld=0; cld<z;cld++)
				v.push_back(3);
			
			if(v.size() < n)
				goto back;


			// for(i=0;i<n;i++){
			// 	if(v[i] == )
			// }
			if(v[n-1] == 1){
				return "warm";
			}else if (v[n-1] == 2){
				return "normal";
			}else{
				return "cold";
			}
		}

	15) Toggle K bits:
		Sample Input 1:
			2
			21 3
			40 4
			Sample Output 1:
			18
			39
			Explanation For Sample Input 1:
			In example 1, the binary representation of 21 is '10101'. After toggling rightmost 3 bits, it becomes ‘10010’ which is equal to 18.
			In example 2, the binary representation of 40 is ‘101000’. After toggling rightmost 4 bits, it becomes ‘100111’ which is equal to 39.
			Sample Input 2:
			2 
			20 2
			85 5
			Sample Output 2:
			23
			74
			Explanation For Sample Input 2:
			In example 1, the binary representation of 20 is '10100'. After toggling rightmost 2 bits, it becomes ‘10111’ which is equal to 23.
			In example 2, the binary representation of 85 is ‘1010101’. After toggling rightmost 5 bits, it becomes ‘1001010’ which is equal to 74.

		#include <bits/stdc++.h> 
		using namespace std;
		int toggleKBits(int n, int k) {

			vector<int> v;
			for(int i=0;i<k;i++){
				int bit = n&1;
				n >>= 1;
				v.push_back(bit);
			}

			for(int i=0;i<v.size();i++)
				if(v[i] == 1){
					v[i] = 0;
				}else{
					v[i] = 1;
				}

			for(int i=0; i<k; i++){
				n <<= 1;
				n = n | v[v.size()-i-1];
			}
			return n;
		}

		//or
			#include <bits/stdc++.h>
				int toggleKBits(int n, int k) {
					return n^((1<<k)-1);
				}

	16) Unlucky Number:
		Num consist of 1 or 3 or 1 & 3 only. not other number;
			Sample Input 1
				1
				Sample Output 1
				1
				Sample Input 2
				2
				Sample Output 2
				3
				Sample Input 3
				5
				Sample Output 3
				31
			eg.
				1, 3, 11, 13, 31, 33, 111, 113, 131, 133, 311, 313, 331, 333.
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
			//Write your code here
			int n;
			cin>>n;

			vector<int> v;
			int IStore=0, checker;

				for(int j=1;j<2000000;j++){
					IStore = j;
					checker = j;
					while(checker>0){
						int temp = checker % 10;

						if(temp == 1 || temp ==3){
							checker /= 10;
							continue;
						}else{
							break;
						}
					}

					if(checker == 0)
						v.push_back(IStore);
				}
				cout<<v[n-1];
				return 0;
			} 

	17) Digit Count In Range:
		Sample Input 1:
			2
			3
			1 15
			2
			2 12
			Sample Output 1:
			2
			2
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [1, 13] = 2 (3, 13). Return 2


			In the second test case, 
			Number of occurrences of 2 in range [2, 12] = 2 (2, 12). Return 2
			Sample Input 2:
			2
			1 
			1 15
			3
			3 33
		
		Sample Output 2:
			8
			8
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 1 in range [1, 15] = 8 (1, 10, 11, 12, 13, 14, 15). Return 8

			In the second test case, 
			Number of occurrences of 3 in range [3, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int digitCount(int K, long long int A, long long int B){
			long long int counter = 0,i,JStorer;
			while(A<=B){
				JStorer = A;
				while(JStorer>0){
					int temp = JStorer % 10;
					if(temp == K)
						counter++;
					JStorer/=10;
				}
				A++;
			}
			return counter;	
		}

	18) Minimum Difference Of Subarrays:
		int minimumDifference(int n, vector<int> arr){
			//Declaring totalSum to store the sum of all elements of arr.
			int totalSum = 0;
			for (int idx = 0; idx < n; idx++)
				totalSum += arr[idx];

			// currentSum stores the sum of first subarray.
			int currentSum = 0, minDiff = INT_MAX;

			for (int idx = 0; idx < n - 1; idx++){

				// updating the sum of the current subarray.
				currentSum += arr[idx];

				// Updating the mininmum difference.
				minDiff = min(minDiff, abs(currentSum - (totalSum - currentSum)));
			}
			return minDiff;
		}

	19) Ninja And The Triangle:
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
			int Istorer, sum=0, i;
			for(i=1; i<n; i++)
				if((sum+i) <= n){
					sum += i;
					Istorer = i;
				}
				else
					break;
			
			return Istorer;
		}
		//or
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
		    int k = (int)(sqrt(2*n));
			while(k*(k+1)/2 > n)
				k--;
			return k;
		}

		//or
			#include <bits/stdc++.h> 
			int ninjaAndTriangle(int n) {
				int d = 1 + 8 * n;
				int x = (1 + sqrt(d))/2;
				return x-1;
			}

	20) Amazing Strings
		Sample Input 1:
			2
			HI HEY EIHYH
			ALL GOOD ADOLLG
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined has 1 A, 2 L, 1 G, 2 O and 1 D. While the string ‘THIRD’ has 1 A, 2 L, 1 G, 1 O and 1 D and So, it has one character less than the combined ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.
			Sample Input 1:
			2
			CODING NINJA NINCODINGJA
			YES NO NEEOOYS
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined have 1 N, 1 Y, 1 E, 1 S and 1 O. While the string ‘THIRD’ has 1 N, 1 Y, 2 E, 1 S and 2 O and So, it has one character more than ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.

		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size(),i=0;

			if((firLen + secLen) != len)
				return "NO";

			while(i<firLen){
				char tempCh = first[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}
			i=0;
			while(i<secLen){
				char tempCh = second[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}

			return "YES";
		}

		//or
		#include <algorithm>
		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size();
			int i=0;

			if((firLen + secLen) != len)
				return "NO";
			
			string full = first + second;
			sort(full.begin(), full.end());

			sort(third.begin(), third.end());
			
			if(full == third)
				return "YES";
			else
				return "NO";
		}

		//optimized:
			string amazingStrings(string first, string second,string third) {
				// Write your code here.
				if((first.length() + second.length()) == third.length())
					return "YES";
				else
					return "NO";
			}

	#Weekend Problem:
		21) Chocolate Removal Challenge:
			Explaination:
				You are given an array 'A' of size 'N'. Each element 'A[i]' represents the number of chocolates in the 'i-th' pile. 
				In a single move, you are allowed to perform the following operation: 
				If a pile contains more than 23 chocolates, you can take out all the chocolates leaving only 23 in the pile.

				Input: A = [25, 24, 29, 15]
				Output: 9

				First pile: Contains 25 chocolates, remove 2 to leave 23. Chocolates removed = 2.
				Second pile: Contains 24 chocolates, remove 1 to leave 23. Chocolates removed = 1.
				Third pile: Contains 29 chocolates, remove 6 to leave 23. Choclates removed = 6
				Fourth pile: Contains 15 chocolates, no chocolates removed as the pile already has less than or equal to 23 chocolates.
				Total chocolates removed = 2 + 1 + 6 = 9.

			Sample Input 1:
				2
				4
				25 24 10 15
				3
				30 20 40
				Sample Output 1 :
				3
				24
				Explanation For Sample Input 1:
				For test case 1:
				We remove 2 chocolates from the first pile and 1 from the second pile. Hence the total chocolates removed = 2 + 1 = 3.

				For test case 2:
				We remove 7 chocolates from the first pile, none from the second pile and 17 from the third pile. Hence the total chocolates removed = 7 + 17 = 24.
				Sample Input 2:
				2
				5
				100 200 300 400 500
				1
				23
				Sample Output 2 :
				1385
				0

			long long totalChocolates(int n, vector<int> a) {
				long long sum =0;
				for(int i=0;i<n;i++){
					if(a[i]> 23)
						sum += (a[i]-23);
				}
				return sum;
			}

		22) Odd Product:
			Ninja loves the odd numbers. He gives you an array 'A' of size 'N'. Help Ninja to find numbers of pairs '(L, R)' 
			such that products of array elements in the range 'L' to 'R' have an odd number of divisors.
			eg.
				'N' = 2
				'A' = [1, 4]

				There are total three possible pairs of '(L, R)':
				L = 1, R = 1, 'product = 1', divisors = [1]
				L = 1, R = 2, 'product = 1*4 = 4', divisors = [1, 2, 4]
				L = 2, R = 2 , 'product = 4', divisors = [1, 2 , 4]

				All three pairs have an odd number of divisors, so the answer is '3'.

			eg.
				Sample Input 1:
					2
					4
					1 2 4 2
					2
					1 2
					Sample Output 1:
					4
					1
					Explanation Of Sample Input 1:
					For test case 1:
					There are total '10' possible pairs of '(L, R)':

					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2', divisors = [1, 2]
					L = 1, R = 3, 'product = 1*2*4 = 8', divisors = [1, 2, 4, 8]
					L = 1, R = 4, 'product = 1*2*4*2 = 16', divisors = [1, 2, 4, 8, 16]
					L = 2, R = 2, 'product = 2', divisors = [1, 2]
					L = 2, R = 3, 'product = 2*4 = 8', divisors = [1, 2, 4, 8]
					L = 2, R = 4, 'product = 2*4*2 = 16', divisors = [1, 2, 4, 8]
					L = 3, R = 3, 'product = 4', divisors = [1, 2, 4]
					L = 3, R = 4, 'product = 4*2 = 8', divisors = [1, 2, 4, 8]
					L = 4, R = 4, 'product = 2', divisors = [1, 2]

					We can see that only '4' pairs have an odd number of divisors, so the answer is '4'.

					For test case 2:
					There are total three possible pairs of '(L, R)':
					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2 = 2', divisors = [1, 2]
					L = 2, R = 2 , 'product = 2', divisors = [1, 2]

					Only one pair has an odd number of divisors, so the answer is '1'.
					Sample Input 2:
					2
					4
					4 4 4 4
					5
					4 2 8 10 16
					Sample Output 2:
					10
					4
			
			long long oddProducts(int n, vector<int> &a){
				int counter=0;
				long long MainCounter=0;
				for(int b=0; b<n; b++){

					int prod=1,j;
					for(int c=b; c<n; c++){
						prod *= a[c];

						j=1;
						while(j<=prod){
							if(prod % j == 0)
								counter++;
							j++;
						}

						if(counter&1)
							MainCounter++;
						
						counter=0;
					}
				}
				return  MainCounter;
			}

	23) Strobogrammatic Number ll:
		-Given a length ‘N’, you need to find all the strobogrammatic numbers of length ‘N’.
		-A strobogrammatic number is a number that looks the same when rotated by 180.
		-In other words, a number that on rotating right side up and upside down appears the same is a strobogrammatic number.
		-‘986’ is a strobogrammatic number because on rotating ‘986’ by 180 degrees, ‘986’ will be obtained.
		-If N = 2, all the strobogrammatic numbers of length = 2 are “11”, “88”, “69”, “96”.
		-Sample Input 1:
			2
			3
			1
			Sample Output 1:
			101 111 181 609 619 689 808 818 888 906 916 986 
			0 1 8 
			Explanation For Sample Input 1:
			Test Case 1: All the possible Strobogrammatic numbers of length = 3 are “101”, “111”, “181”, “609”, “619”, “689”, “808”, “818”, “906”, “916”, “986”.

			Test Case 2: Strobogrammatic numbers of length = 1 are “0”, “1”, and “8”.
			Sample Input 2:
			2
			4
			2
			Sample Output 2:
			1001 1111 1691 1881 1961 6009 6119 6699 6889 6969 8008 8118 8698 8888 8968 9006 9116 9696 9886 9966 
			11 69 88 96 
			Explanation For Sample Input 2:
			Test Case 1: All the possible Strobogrammatic numbers of length = 4 are printed.

			Test Case 2: All the possible Strobogrammatic numbers of length = 2 are printed.

		#include <bits/stdc++.h> 
		bool checker(string st){

			int temp = stoi(st);
			int rev = 0;
			while(temp>0){
				rev = (temp % 10) + rev * 10; 
				temp /=10;
			}

			string tempStr = to_string(rev);
			int index=0;
			while(tempStr[index] != '\0'){
				if(tempStr[index] == '6')
					tempStr[index] = '9';
				else if(tempStr[index] == '9')
					tempStr[index] = '6';
				index++;
			}

			if(st == tempStr)
				return true;
			return false;
		}

		vector<string> findStrobogrammatic(int n){
			vector<string> s;
			if(n == 1)
				return {"0","1","8"};
			
			if(n == 2)
				return {"11","69","88","96"};

			int Digit = 1;
			Digit = pow(10,n-1);

			for(int i = Digit; i<(Digit*10); i++){
				int temp = i;
				while(temp > 0){
					int singleBit = temp % 10;
					if(singleBit == 0 || singleBit == 1 || singleBit == 6 || singleBit == 8 || singleBit == 9)
						temp /=10;
					else
						break;
				}
				if(temp == 0)
					s.push_back(to_string(i));
			}

			vector<string> Upgraded;

			for(int i=0; i<s.size(); i++){
				string tempStr = s[i];
				
				if(checker(tempStr))
					Upgraded.push_back(tempStr);
			}
			return Upgraded;
		}

		//optimized:
			vector < string > findStrobogrammaticHelper(int n, int len) {
				// If len = 0, return empty string.
				if (len == 0) {
					return vector < string > ({ "" });
				}

				if(len == 1){
					return vector < string > ({"0", "1", "8" });
				}

				// Recursively call for len = len - 2.
				vector < string > prev = findStrobogrammaticHelper(n, len - 2);

				// Initialize vector of strings to store resulting strings.
				vector < string > res;

				// Iterate through all strings in "prev".
				for (int i = 0; i < prev.size(); i++) {

					// Add digits around string prev[i].
					if (len != n) {
						res.push_back("0" + prev[i] + "0");
					}

					res.push_back("1" + prev[i] + "1");
					res.push_back("6" + prev[i] + "9");
					res.push_back("8" + prev[i] + "8");
					res.push_back("9" + prev[i] + "6");
				}
				return res;
			}

			vector < string > findStrobogrammatic(int n) {
				// Recursive function to find all strobogrammatic numbers.
				vector < string > ans = findStrobogrammaticHelper(n, n);
				return ans;
			}

	24) Set Matrix Ones:
		//basics to know:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main(){
				//2d vector with 4; 10 rows 5 columns initialized with 4 (default value).
				vector<vector<int>> ans (10, vector<int> (5,4));
				
				for(int i=0;i<10; i++){
					for(int j=0;j<5; j++)
						cout<<ans[i][j]<<"\t";
					cout<<endl;
				}
				
				std::cout << "End" << std::endl;
				return 0;
			}

		//not optimized:	
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<vector<int>> ans(n, vector<int>(m,0));
				for(int i=0;i<n; i++){
					for(int j=0;j<m;j++){
						if(MAT[i][j] == 1){
							for(int b=0;b<m;b++)
								ans[i][b] =1;                
							for(int a =0;a<n;a++)
								ans[a][j] = 1;
						}
					}
				}
				MAT = ans;
			}

		//optimized:
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<pair<int, int>> ones;
				vector<bool> rowHasOne(n, false);
				vector<bool> colHasOne(m, false);

				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (MAT[i][j] == 1) {
							rowHasOne[i] = true;
							colHasOne[j] = true;
						}
				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (rowHasOne[i] || colHasOne[j]) 
							MAT[i][j] = 1;
			}

	25) Count Distinct Element in Every K Size Window
		you are given an array ‘ARR’ of size ‘N’ and an integer ‘K’. Your task is to find the total
		number of distinct elements present in every ‘K’ sized window of the array. A ‘K’ sized
		window can also be viewed as a series of continuous ‘K’ elements present in the
		sequence.
		Note:
			1. The size of ‘ARR’ will always be greater than or equal to the ‘K’.
			2. Here window refers to a subarray of ‘ARR’. Hence ‘K’ sized window means a subarray of size ‘K’.
			3. You are not required to print the output explicitly. It has already been taken care of. Just
			 implement the function and return an array of the count of all distinct elements in the ‘K’ size window.
		eg.
			consider ARR = [ 1, 2, 1, 3, 4, 2,3 ] and K = 3.

			As per the given input, we have a sequence of numbers of length 7, and we need to find the number of
			distinct elements present in all the windows of size 3.
			Window-1 has three elements { 1,2, 1 } and only two elements { 1,2 } are distinct because 1 is repeating two times.
			Window-2 has three elements { 2,1, 3 } and all three elements are distinct { 2, 1, 3 }.
			Window-3 has three elements { 1,3, 4 } and all three elements are distinct { 1, 3, 4 }.
			Window-4 has three elements { 3,4, 2 } and all three elements are distinct { 3, 4, 2 }.
			Window-5 has three elements { 4,2, 3 } and all three elements are

			Hence, the count of distinct elements in all K sized windows is { 2, 3, 3, 3, 3 }.
		eg.
			Sample Input 1:
				2
				7 4
				1 2 1 3 4 2 3
				5 3
				1 1 2 1 3
				Sample Output 1:
				3 4 4 3
				2 2 3
				Explanation Of Sample Input 1:
				Test Case 1:

				Window-1 has four elements { 1, 2, 1, 3 } and only three elements { 1, 2, 3 } are distinct because 1 is repeating two times.
				Window-2 has four elements { 2, 1, 3, 4 } and all four elements { 2, 1, 3, 4 } are distinct.
				Window-3 has four element { 1, 3, 4, 2 } and all four elements { 1, 3, 4, 2 } are distinct. 
				Window-4 has four element { 3, 4, 2, 3 } and only three elements { 3, 4, 2 } are distinct because 3 is repeating two times.

				Hence, the count of distinct elements in all windows is { 3, 4, 4, 3}.

				Test case 2: 

				Window-1 has three elements { 1, 1, 2 } and only two elements { 1, 2 } are distinct because 1 is repeating two times.
				Window-2 has three elements { 1, 2, 1 } and only two elements { 2, 1 } are distinct.
				Window-3 has three elements { 2, 1, 3 } and all three elements { 2, 1, 3 } are distinct.

				Hence, the count of distinct elements in all windows is { 2, 2, 3 }.
				Sample Input 2:
				2
				4 1
				2 3 1 2
				5 2
				2 2 3 2 1
				Sample Output 2:
				1 1 1 1
				1 2 2 2

		#include <bits/stdc++.h> 
		vector<int> countDistinctElements(vector<int> &arr, int k) {
			vector<int> DistinctCount;
			int len = arr.size();
			int Lind =k-1;
			int i=0,j;
			int windowHolder = k;
			while(Lind < len){
				set<int> temp;
				j = i;
				while(windowHolder){
					temp.insert(arr[j++]);
					windowHolder--;
				}
				i++;
				windowHolder = k;
				DistinctCount.push_back(temp.size());
				temp.clear();
				Lind += 1;
			}
			return DistinctCount;
		}

		//optimized:
			#include <bits/stdc++.h> 
			vector<int> countDistinctElements(vector<int> &arr, int k) {
				std::vector<int> distinctCount;
				int len = arr.size();
				
				if (k <= 0 || k > len) {
					return distinctCount;  // Handle invalid input.
				}
				
				std::unordered_map<int, int> elementCount;
				int distinct = 0;
				
				// Calculate distinct elements in the first window.
				for (int i = 0; i < k; ++i) {
					if (elementCount[arr[i]] == 0) {
						distinct++;
					}
					elementCount[arr[i]]++;
				}
				
				distinctCount.push_back(distinct);
				
				// Slide the window and update distinct count.
				for (int i = k; i < len; ++i) {
					int leftElement = arr[i - k];
					int rightElement = arr[i];
					
					// Remove the leftmost element from the window.
					if (elementCount[leftElement] == 1) {
						distinct--;
					}
					elementCount[leftElement]--;
					
					// Add the rightmost element to the window.
					if (elementCount[rightElement] == 0) {
						distinct++;
					}
					elementCount[rightElement]++;
					
					distinctCount.push_back(distinct);
				}
				return distinctCount;	
			}

	26) Tweaked Array:
		Sample Input 1 :
			2
			3
			1 4 1
			3
			5 2 -5
			Sample Output 1 :
			5 2 5
			-3 0 7
			Explanation Of Sample Input 1 :
			For test 1:
			TotalSum = 1 + 4 + 1 = 6
			Tweaked array = {6 - 1,  6 - 4,  6 - 1} = {5, 2, 5}

			For test 2:
			TotalSum = 5 + 2 + (-5) = 2
			Tweaked array = {2 - 5,  2 - 2,  2 - (-5)} = {-3, 0, 7}
			Sample Input 2 :
			2
			2
			1 2
			3
			-1 -2 -4
			Sample Output 2 :
			2 1
			-6 -5 - 3

		#include <bits/stdc++.h> 
		vector<int> tweakTheArray(vector<int> arr, int n){
			int sum=0;
			for(int i=0; i<arr.size(); i++){
				sum += arr[i];
			}

			for(int i=0;i<arr.size();i++)
				arr[i] = sum - arr[i];

			return arr;
		}

	27) Lucky String:
		You are given a string 'S' of length 'N' consisting of lowercase latin letters. If
		there is a letter occurring consecutively three times (at least three times), the
		string becomes unlucky for you. Your task is to erase some characters
		from the string such that it becomes lucky for you. A string which is not unlucky, is considered as lucky.
		Output the minimum number of removals (of characters) required to make the given
		string lucky.
		Sample Input 1 :
			2
			7
			abcccca
			5
			cbazz
			Sample Output 1 :
			2
			0
			Explanation For Sample Input 1 :
			For test case 1:
			If a substring "cc" is deleted from any position, the remaining string becomes lucky. Hence a minimum removal of 2 characters is required. 

			For test case 2:
			Given string is already lucky. No removal is required.
			Sample Input 2 :
			3
			5
			bbbbb
			2
			xy
			9
			abcccbaaa
			Sample Output 2 :
			3
			0
			2

		#include <bits/stdc++.h> 
		int makeLucky(string s, int n){
			int i=0,cnt=0;
			while(i<s.length()-1){
				if(s[i] == s[i+1])
					if(s[i+1] == s[i+2])
						cnt++;
				i++;
			}
			return cnt;
		}

	28) Minimize Bill:
		Sample Input 1 :
			2
			5
			-2 0 5 2 -1
			4
			5 8 7 9
			Sample Output 1 :
			-6
			11
			Explanation For Sample Input 1 :
			For test case 1:
			The optimal way is to make change at A[2]. Minimum sum of array (after change) becomes -2+0+(-5)+2-1 = -6.

			For test case 2:
			Make change at A[3]. Minimum sum becomes 5+8+7+(-9) = 11.
			Sample Input 2 :
			3
			4
			3 -1 0 2
			2
			0 -1
			5
			5 5 5 5 5
			Sample Output 2 :
			-2
			-1
			15

		#include <bits/stdc++.h> 
		long long totalBill(int n, vector<int>& a){
			int mxValInd=0;

			for(int i=0;i<a.size();i++)
				if(a[mxValInd] < a[i])
					mxValInd = i;
			
			a[mxValInd] = -1 * (a[mxValInd]);

			int sum=0;
			for(int i=0;i<a.size(); i++)
				sum += a[i];
			return sum;
		}

	29) Encode The String:
		Sample Input 1 :
			2
			3
			dog
			4
			cazz
			Sample Output 1 :
			cpf
			bbyy
			Explanation Of Sample Input 1 :
			For the first test case :

			Character ‘d’ gets changed to ‘c’.
			Character ‘o’ gets changed to ‘p’.
			Character ‘g’ gets changed to ‘f’.

			Encoded string = “cpf”.


			For the second test case :

			Character ‘c’ gets changed to ‘b’.
			Character ‘a’ gets changed to ‘b’.
			Character ‘z’ gets changed to ‘y’.
			Sample Input 2 :
			2
			4
			gjmf
			3
			abc
			Sample Output 2 :
			file
			bab

		#include <bits/stdc++.h> 
		string encodeString(string &s, int n) {
			for(int i=0;i<s.length();i++){
				if(s[i] == 'a'){
					s[i] = 'b';
				}else if(s[i] == 'e'){
					s[i] = 'f';
				}else if(s[i] == 'i'){
					s[i] = 'j';
				}else if(s[i] == 'o'){
					s[i] = 'p';
				}else if(s[i] == 'u'){
					s[i] = 'v';
				}else{
					s[i] = s[i] - 1;
				}     
			}
			return s;
		}

	30) Next Greater Element
		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			for(int i=0;i<n;i++){
				if(i == (n-1)){
					arr[i] = -1;
					return arr;
				}
				int j=i+1;
				for(j; j<n;j++){
					if(arr[i] < arr[j]){
						arr[i] = arr[j];
						break;
					}
				}
				if(j==n)
					arr[i] = -1;
			}
		}
		
		//optimized
		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			vector<int> res(n, -1);
			stack<int> st;

			for(int i=0;i<n;i++){
				while(!st.empty() && arr[i] > arr[st.top()]){
					res[st.top()] = arr[i];
					st.pop();
				}
				st.push(i);
			}
			return res;
		}

	31) Implement Deque:
		-https://www.codingninjas.com/studio/problems/deque_1170059
		#include <bits/stdc++.h>
		#include<queue>
		using namespace std;
		class Deque
		{
			public:
				// Initialize your data structure.
				int size;
				deque<int> d;
				Deque(int n){
					// Write your code here.
					size = n;
				}

				// Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushFront(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_front(x);
						return true;
					}
					return false;
				}

				// Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushRear(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_back(x);
						return true;
					}
					return false;
				}

				// Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popFront(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.front();
						d.pop_front();
						return temp;
					}
					return -1;
				}

				// Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popRear(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.back();
						d.pop_back();
						return temp;
					}
					return -1;
				}

				// Returns the first element of the deque. If the deque is empty, it returns -1.
				int getFront(){
					// Write your code here.
					if(!d.empty()){
						return d.front();
					}
					return -1;
				}

				// Returns the last element of the deque. If the deque is empty, it returns -1.
				int getRear(){
					// Write your code here.
					if(!d.empty()){
						return d.back();
					}
					return -1;
				}

				// Returns true if the deque is empty. Otherwise returns false.
				bool isEmpty(){
					// Write your code here.
					if(d.empty())
						return true;
					
					return false;
				}

				// Returns true if the deque is full. Otherwise returns false.
				bool isFull(){
					// Write your code here.
					if(d.size() == size)
						return true;
					return false;
				}
		};
	
	32) Direction Game:
		Ninja is currently facing North. An instructor gives him 'N' instructions in the
		form of a binary string 'S'. If 'S[ i ]' is '0', then Ninja will turn clockwise by ‘90’
		degrees. Otherwise, Ninja will turn counterclockwise by ‘90’ degrees.
		Ninja is lazy and doesn't feel like doing all 'N' instructions. So, he decides to just face
		the final direction. Find the final direction of Ninja, which will be one of the
		following: 'NORTH', 'SOUTH', 'EAST', or 'WEST
		Sample Input 1:
			2
			4
			1111
			4
			1101
			Sample Output 1:
			NORTH
			SOUTH
			Explanation Of Sample Input 1:
			For test case 1:
			Ninja’s direction will change in the following order:
			North → West → South  → East → Noth
			So, the answer is 'NORTH'.

			For test case 2:
			Ninja’s direction will change in the following order:
			North → West → South → West → South
			So, the answer is 'SOUTH'.
			Sample Input 2:
			2
			8
			10011101
			7
			0101011
			Sample Output 2:
			SOUTH
			WEST

		string directionGame(int n, string &s){
			vector<string> dire = {"NORTH","WEST","SOUTH","EAST"};
			int index=0;
			for(int i=0;i<n;i++){
				if(s[i] == '1')
					index = (index+1)%4;
				else
					index = (index+3)%4;
			}
			return dire[index];
		}

	33) Apple Harvest:
		Sample Input 1:
			2
			20 15 5
			7 4 6
			Sample Output 1 :
			25
			18
			Explanation For Sample Input 1:
			For test case 1:
			The tree produces 20 apples daily. The basket can hold up to 15 apples. So, every day 5 apples are wasted. Over 5 days, 25 apples are wasted.

			For test case 2:
			The tree produces 7 apples daily. The basket can hold up to 4 apples. So, every day 3 apples are wasted. Over 6 days, 18 apples are wasted.
			Sample Input 2:
			2
			50 25 10
			12 5 7
			Sample Output 2 :
			250
			49

		long long wastedApples(int n, int m, int x) {
			return static_cast<long long>(max(0,(n-m)))*x;
		}

	34) Ninja wants Holiday:
		Ninja is a corporate employee, and like
			other corporate employees, he also wants
			to visit his home on long holidays. He
			wants to spend at least 'K' consecutive
			days at his home.
			You are given an array 'A' of length 'N'
			denoting the list of holidays. Ninja can
			only take leave on holidays.
			You have to find if it's possible for Ninja to
			spend at least 'K' consecutive days at his
			home.
			Example:
			'N' = 4
			'K' = 3
			'A' = [1, 3, 4, 5]
			Ninja can take leave on '1',
			'3', '4', and '5'. Therefore,
			he can take leave consecutively
			for at most 3 days, which are
			from '3' to '5'.
			Thus, minimum requirement of 'K= 3' is satisfied in this case. Hence, the final output will be 'YES'.

		Sample Input 1:
			2
			5 3
			1 3 7 5 8
			4 2
			2 4 8 3
			Sample Output 1:
			NO
			YES
			Explanation Of Sample Input 1:
			For test case 1:
			Holidays cannot be taken for three days in a row.
			Hence, the answer for this case is "NO".

			For test case 2:
			Ninja can take holidays on days '2' and '3', thus satisfying requirement of holiday on two consecutive days.
			Hence, the answer for this case is "YES".
			Sample Input 2:
			2
			5 3
			2 3 5 8 7
			4 2
			4 5 2 3
			Sample Output 2:
			NO
			YES


		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;

		string ninjaWantsHoliday(int n, int k, vector<int> &a) {
			sort(a.begin(), a.end());
			int cnt=1;
			for(int i=0;i<n; i++){      //1 4 5 8 10
				if(a[i]+1 == a[i+1]){
					cnt++;
					if(cnt == k)
						return "YES";
				}else{
					cnt=1;
					continue;
				}
			}
			return "NO";
		}
		int main(){
			int n=5, k=2;

			vector<int>a {5, 10, 1 ,8, 4};
			string s = ninjaWantsHoliday(n,k,a);
			std::cout << s << std::endl;
			return 0;
		}

	35) Vaccination Drive:
			The Indian government recently launched the world's largest vaccination drive for
			COVID-19. Dr Ritesh has been appointed as a nodal officer for vaccinating a
			locality. There are ‘N’ houses numbers from 1 to ‘N’ in that locality. Dr Ritesh will
			visit each house one by one and vaccinate all the people in the house. He
			has already covered ‘K’ number of houses. Since ‘N’ is a very large number,
			‘L’ bits are required to represent the number. You are supposed to help Dr
			Ritesh and find the maximum possible number of houses that are yet to be
			covered under the vaccination drive
			(Hint 2's power)
		Sample Input 1 :
			2
			3 5
			5 3
			Sample output 1 :
			29
			3
			Explanation of Sample output 1 :
			For the first test case, since the number of bits required is 5, the maximum possible value for ‘N’ is 32. So the maximum possible number of remaining houses are 32 - 3 = 29.

			For the second test case, since the number of bits required is 3, the maximum possible value for ‘N’ is 8. So the maximum possible number of remaining houses are 8 - 3 = 5.
			Sample Input 2 :
			2
			1 1
			2 3
			Sample output 2 :
			1
			6
		#include <bits/stdc++.h> 
		int getMaximumHouses(int k, int l){
			return (pow(2,l))-k;
		}

	36) Factorial of Larger nums:
		void multiply(vector<int> &result, int x) {
			int carry = 0;
			for (int i = 0; i < result.size(); i++) {
				int product = result[i] * x + carry;
				result[i] = product % 10;
				carry = product / 10;
			}
			
			while (carry) {
				result.push_back(carry % 10);
				carry /= 10;
			}
		}

		void factorial(int n){
			vector<int> result;
			result.push_back(1); // Initialize the result as 1
			
			for (int i = 2; i <= n; i++) {
				multiply(result, i);
			}
			
			// Print the result in reverse order
			for (int i = result.size() - 1; i >= 0; i--) {
				cout << result[i];
			}
			cout << endl;   
		}

	37) Print all Divisors of a number
		Given an integer 'N', return all the divisors of 'N' in ascending order.
		For Example:
		'N' = 5.
		The divisors of 5 are 1, 5.
		Sample Input 1 :
			10
			Sample Output 1 :
			1 2 5 10
			Explanation Of Sample Input 1:
			The divisors of 10 are 1,2,5,10.
			Sample Input 1 :
			6
			Sample Output 1 :
			1 2 3 6

		vector<int> printDivisors(int n) {
			vector<int> ans;
			for(int i=1;i<=n/2;i++)
				if(n % i == 0)
					ans.push_back(i);

			ans.push_back(n);
			return ans;
		}
	
	38) Rotate array
		Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative
		'arr '= [1,2,3,4,5]
			'k' = 1 rotated array = [2,3,4,5,1] 
			'k' = 2 rotated array = [3,4,5,1,2]
			'k' = 3 rotated array = [4,5,1,2,3] and so on.

		Sample Input 1:
			8
			7 5 2 11 2 43 1 1
			2
			Sample Output 1:
			2 11 2 43 1 1 7 5
			Explanation Of Sample Input 1:
			Rotate 1 steps to the left: 5 2 11 2 43 1 1 7
			Rotate 2 steps to the left: 2 11 2 43 1 1 7 5
			Sample Input 2:
			4
			5 6 7 8
			3
			Sample Output 2:
			8 5 6 7
			Explanation Of Sample Input 2:
			Rotate 1 steps to the left: 6 7 8 5
			Rotate 2 steps to the left: 7 8 5 6
			Rotate 2 steps to the left: 8 5 6 7

		vector<int> rotateArray(vector<int>arr, int k) {
			vector<int> ans;
			for(int i=k;i<arr.size();i++)
				ans.push_back(arr[i]);
			
			for(int i=0;i<k;i++)
				ans.push_back(arr[i]);
			
			return ans;
		}

	39) Generate Binary Numbers:
		Sample Input 1:
			2
			2
			6
			Sample Output 1:
			1 10
			1 10 11 100 101 110
			Explanation 1:
			For the first test case when N = 2. 
			We need all the binary numbers from 1 to 2:
			1 -> 1
			2 -> 10
			Thus, the output is 1, 10.

			For the second test case when N = 6
			We need all the binary numbers from 1 to 6:
			1 -> 1
			2 -> 10
			3 -> 11
			4 -> 100
			5 -> 101
			6 -> 110
			Thus, the output is 1, 10, 11, 100, 101, 110.
			Sample Input 2:
			2
			8
			4
			Sample Output 2:
			1 10 11 100 101 110 111 1000
			1 10 11 100

		#include <bits/stdc++.h>
		string binConvert(int); 
		vector<string> generateBinaryNumbers(int n){
			vector<string> ans;
			for(int i=1;i<=n;i++){
				string s = binConvert(i);
				ans.push_back(s);
			}
			return ans;
		}

		string binConvert(int n){
			string temp;
			while(n>0){
				int t = n % 2;
				temp += to_string(t);
				n/=2;
			}
			reverse(temp.begin(), temp.end());
			return temp;
		}

	40) Sum Of Zeroes
		#include <bits/stdc++.h> 
		int coverageOfMatrix(vector<vector<int>> &matrix) {
		int rows = matrix.size();
		int cols = matrix[0].size();
		int coverage = 0;

		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				if (matrix[i][j] == 0) {
					int adjacent = 0;

					// Check top neighbor
					if (i > 0 && matrix[i - 1][j] == 1) {
						adjacent += 1;
					}

					// Check bottom neighbor
					if (i < rows - 1 && matrix[i + 1][j] == 1) {
						adjacent += 1;
					}

					// Check left neighbor
					if (j > 0 && matrix[i][j - 1] == 1) {
						adjacent += 1;
					}

					// Check right neighbor
					if (j < cols - 1 && matrix[i][j + 1] == 1) {
						adjacent += 1;
					}

					coverage += adjacent;
				}
			}
		}
		return coverage;
		}

	41) Add One To Number
		Sample Input 1
			3
			3
			1 2 3
			2
			9 9
			1
			4
			Sample Output 1
			1 2 4
			1 0 0
			5
			Explanation For Sample Input 1
			In the 1st test case, the number is 123 after adding 1 number becomes 124, hence the output will be {1,2,4}.

			In the 2nd test case, the number is 99 after adding 1 number becomes 100, hence the output will be {1,0,0}.

			In the 3rd test case, the number is 4 after adding 1 number becomes 5, hence the output will be {5}.
			Sample Input 2
			3
			4
			2 4 6 8 
			1
			0
			2
			0 2
			Sample Output 2
			2 4 6 9
			1
			3

		#include <bits/stdc++.h> 
		vector<int> addOneToNumber(vector<int> arr){
			int n = arr.size();
			
			// Add 1 to the least significant digit (rightmost)
			arr[n - 1] += 1;
			
			// Handle carry
			int carry = 0;
			for (int i = n - 1; i >= 0; i--) {
				int sum = arr[i] + carry;
				arr[i] = sum % 10;  // Update the current digit
				carry = sum / 10;   // Calculate the carry for the next digit
			}
			
			// If there is still a carry after processing all digits, insert it at the beginning
			if (carry > 0) {
				arr.insert(arr.begin(), carry);
			}
			//removing leadig zeros
			while(!arr.empty() && arr[0]==0){
				arr.erase(arr.begin());
			}
			return arr;
		}
		
		//or
			#include <bits/stdc++.h> 

				// long long ConvertToNum(vector<int> a){
				//     long long num=0;
				//     for(int i=0;i<a.size();i++){
				//         num = num * 10 + a[i];
				//     }
				//     return num+1;
				// }

			vector<int> addOneToNumber(vector<int> arr){
				// long long n = ConvertToNum(arr);
				// vector<int> ans;
				// string s = to_string(n);
				
				// for(int i=0;i<s.length();i++)
				//     ans.push_back(s[i]-48);
				
				// return ans;

				for(int i=arr.size()-1; i>=0; i--){
					if(i == arr.size()-1)
						arr[i] = arr[i]+1;
					if(arr[i]>9 && i>0){
						int l = arr[i] % 10;
						int s = arr[i] /10;
						arr[i] = l;
						arr[i-1] = arr[i-1] + (s);
					}
				}

				if(arr[0]> 9){
					int n = arr[0] % 10;
					int s = arr[0] / 10;
					arr[0] = n;
					arr.insert(arr.begin(),s);
				}

				//to remove trailing zeros
				int i=0;
				while(arr[i] == 0){
					arr.erase(arr.begin());
				}

				return arr;
			}

	42) Find (indexes) All Anagrams in a String:
		Sample Input 1 :
			2
			10 3
			CBAEBABACD
			ABC
			5 2
			ABADE
			BA
			Sample Output 1 :
			0 6
			0 1
			Explanation For Sample Output 1:
			Test Case 1:

			'STR' is ‘CBAEBABACD’ and ‘PTR’ is ‘ABC’.

			0-2 in 'STR' index 0,1,2 are ‘CBA’, and it is an anagram with ‘ABC’.
			1-3 in 'STR' index 1,2,3 are ‘BAE’, and it is not anagram with ‘ABC’.
			2-4 in 'STR' index 2,3,4 are ‘AEB’, and it is not anagram with ‘ABC’.
			3-5 in 'STR' index 3,4,5 are ‘EBA’, and it is not anagram with ‘ABC’.
			4-6 in 'STR' index 4,5,6 are ‘BAB’, and it is not anagram with ‘ABC’.
			5-7 in 'STR' index 5,6,7 are ‘ABA’, and it is not anagram with ‘ABC’.
			6-8 in 'STR' index 6,7,8 are ‘BAC’, and it is an anagram with ‘ABC’.
			7-9 in 'STR' index 7,8,9 are ‘ACD’, and it is not anagram with ‘ABC’.

			Hence, there are only two substrings in the given string 'STR'  that are anagram with given string  ‘PTR’ which are ‘CBA’, and ‘BAC’ and starting indices of respective anagram substrings are 0 and 6.


			Test case 2:

			'STR' is ‘ABADE’ and ‘PTR’ is ‘BA’.

			In the given string ‘ABADE’ the substring of length 2 starting with index 0 is ‘AB’ which is an anagram with the string ‘BA’ and a substring of length 2 starting with index 1 is ‘BA’ which is also an anagram with the string ‘BA’. Because 0 and 1 are starting indices of the substrings, we print 0 and 1.
			Sample Input 2:
			2
			10 4
			BACDGABCDA
			ABCD
			7 1
			ABABABA
			A
			Sample Output 2:
			0 5 6
			0 2 4 6

		#include <bits/stdc++.h>
		vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
			vector<int> ans;
			unordered_map<char, int> charCountPtr, charCountWindow;

			// Initialize the character counts for ptr
			for (char c : ptr) {
				charCountPtr[c]++;
			}

			for (int i = 0; i < n; i++) {
				// Expand the window
				charCountWindow[str[i]]++;

				// Shrink the window if it's larger than m characters
				if (i >= m) {
					char leftChar = str[i - m];
					if (charCountWindow[leftChar] > 1) {
						charCountWindow[leftChar]--;
					} else {
						charCountWindow.erase(leftChar);
					}
				}

				// Check if the current window is an anagram of ptr
				if (i >= m - 1 && charCountWindow == charCountPtr) {
					ans.push_back(i - m + 1);
				}
			}
			return ans;
		}

	43) Armstrong Number
		You are given an integer ‘NUM’ . Your task
		is to find out whether this number is an
		Armstrong number or not.
		A k-digit number ‘NUM’ is an Armstrong
		number if and only if the k-th power of
		each digit sums to ‘NUM
		eg.
			153 = 1^3 + 5^3 + 3^3.
			Therefore 153 is an Armstrong number
		Sample Input 1:
			1
			13
			Sample Output 1:
			NO
			Explanation For Sample Input 1:
			As 1^2 + 3^2 = 10 which is not equal to 13.So we can say it is not an Armstrong number.
			Sample Input 2:
			1
			371
			Sample Output 2:
			YES

		#include <bits/stdc++.h> 
		bool isArmstrong(int num) {
			string s = to_string(num);
			int len = s.length();
			int sum=0;
			int temp = num;
			while(num){
				sum += pow(num%10, len);
				num /=10;
			}
			if(temp == sum)
				return true;
			return false;
		}

	44) Power of 2:
		Given a non-negative integer N. The task is to check if N is a power of 2. 
			More formally, check if N can be expressed as 2x for some integer x.
			Example 1:

			Input: 
			N = 8
			Output: 
			YES
			Explanation:
			8 is equal to 2 raised to 3 (23 = 8).
			Example 2:

			Input: 
			N = 98
			Output: 
			NO
			Explanation: 
			98 cannot be obtained by any power of 2.
			Your Task:Your task is to complete the function isPowerofTwo() which takes n as a parameter and returns true or false by checking if the given number can be represented as a power of two or not.

			Expected Time Complexity:O(log N).
			Expected Auxiliary Space:O(1).

			Constraints:
			0 ≤ N ≤1018
		class Solution{
			public:
			// Function to check if given number n is a power of two.
			bool isPowerofTwo(long long n){
				long long i;
				for(i=0; i<=n/2, pow(2,i)<=n; i++){       //n = 1001, loop will go to till 500 if pow(2,i) <=n condition was not there,
					if(pow(2,i) == n)
						return true;
				}
				return false;
			}
		};

	44) Find position of set bit
		Given a number N having only one ‘1’ and all other ’0’s in its binary representation, 
			find position of the only set bit. If there are 0 or more than 1 set bit the answer should be -1. 
			Position of  set bit '1' should be counted starting with 1 from LSB side in binary representation of the number.
				Example 1:

				Input:
				N = 2
				Output:
				2
				Explanation:
				2 is represented as "10" in Binary.
				As we see there's only one set bit
				and it's in Position 2 and thus the
				Output 2.
				Example 2:

				Input:
				N = 5
				Output:
				-1
				Explanation:
				5 is represented as "101" in Binary.
				As we see there's two set bits
				and thus the Output -1.
				Your Task:
				You don't need to read input or print anything. Your task is to complete the function findPosition() which takes an integer N as input and returns the answer.

				Expected Time Complexity: O(log(N))
				Expected Auxiliary Space: O(1)

				Constraints:
				0 <= N <= 108
		class Solution {
			public:
			int findPosition(int N) {
				if(N==0)
					return -1;
				
				int cnt=0,pos=0;
				while(N){
					pos++;
					if(N&1)
						cnt++;

					if(cnt>1)
						return -1;
					N>>=1;
				}
				return pos;
			}
		};

	45) Check set bits:
		Given a number N. You have to check whether every bit in 
		 the binary representation of the given number is set or not.
			Example 1:
				Input:
				N = 7
				Output:
				1
				Explanation:
				Binary for 7 is 111 all the
				bits are set so output is 1
			Example 2:
				Input:
				N = 8
				Output:
				0
				Explanation:
				Binary for 8 is 1000 all the
				bits are not set so output is 0.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function isBitSet() 
				which takes an integer N as input parameters and returns 1 if 
				all the bits in N's binary representation is set or return 0 otherwise.

			Expected Time Complexity: O(1)
			Expected Space Complexity: O(1)

			Constraints:
				0<=N<=100000
		class Solution{
			public:
			int isBitSet(int N){
				if(N==0)
					return 0;
				
				while(N){
					if(!(N&1)){
						return 0;
					}
					N>>=1;
				}
				return 1;
			}
		};

	46) 	Admission in Ninja Gram
		Sample Input 1:
			2

			12
			toosmallword
			35
			TheQuickBrownFoxJumpsOverTheLazyDog
			
			Sample Output 1:
			NO
			YES
			Explanation For Sample Input 1:
			In the first test case, the given string is “toosmallword” which contains 
			the characters [‘t’,’o’,’s’,’m’,’a’,’l’,’w’,’r’,’d’], which doesn’t contain 
			all the 26 alphabetic characters. Hence the answer is “NO”.

			In the second test case, the given string is “TheQuickBrownFoxJumpsOverTheLazyDog” 
			which contains the characters: [‘t’,’h’,’e’,’q’,’u’,’i’,’c’,’k’,’b’,’r’,’o’,’w’,’n’,’f’,’x’,’j’,’m’,’p,’’s’,’v’,’l,’a’,’z’,’y’,’ d’,’g’], 
			which contains all the 26 alphabetic characters. Hence the answer is “YES”.
		Sample Input 2:

			2
			16
			CodingNinjas
			10
			CodeStudio
			Sample Output 2:
			NO
			NO
			Explanation For Sample Input 2:
			In the first test case, the given string is “CodingNinjas” which contains the characters 
			[‘c’,’o’,’d’,’i’,’n’,’g’,’i’,’j’,’a’,’s’], which doesn’t contain all the 26 
			alphabetic characters. Hence the answer is “NO”.


			In the first test case, the given string is “CodeStudio” which contains the characters 
			[‘c’,’o’,’d’,’e’,’s’,’t’,’u’,’i’], which doesn’t contain all the 26 alphabetic characters. 
			Hence the answer is “NO”.

		#include <bits/stdc++.h> 
		bool ninjaGram(string &str){
			//to convert string to lower-case,
			transform(str.begin(),str.end(), str.begin(), ::tolower);
			
			char ch = 'a';
			int i=0;
			while(i<str.length()){
				if(str[i] == ch){
					ch++;
					i=0;
				}
				i++;
			}
			if(ch > 'z')
				return 1;
			return 0;
		}

		//or
		#include <bits/stdc++.h> 
		bool ninjaGram(string &str){
			
			string lowerStr = "";
			for (int i  = 0; i < str.length(); i++){
				lowerStr += tolower(str[i]);
			}
			
			int count[26]  = {0};
			
			for (int i  = 0 ; i < lowerStr.length(); i++){
				count[lowerStr[i] - 'a']++;
			}
			for (int i = 0 ; i < 26; i++){
				if(count[i] == 0){
					return false;
				}
			}
			return true;
		}

	47) Find All Anagrams in a String
		https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
		Given two strings s and p, return an array of all the start 
		 indices of p's anagrams in s. You may return the answer in any order.

			An Anagram is a word or phrase formed by rearranging the letters of 
			a different word or phrase, typically using all the original letters exactly once.
			Example 1:
				Input: s = "cbaebabacd", p = "abc"
				Output: [0,6]
				Explanation:
				The substring with start index = 0 is "cba", which is an anagram of "abc".
				The substring with start index = 6 is "bac", which is an anagram of "abc".
			Example 2:
				Input: s = "abab", p = "ab"
				Output: [0,1,2]
				Explanation:
				The substring with start index = 0 is "ab", which is an anagram of "ab".
				The substring with start index = 1 is "ba", which is an anagram of "ab".
				The substring with start index = 2 is "ab", which is an anagram of "ab".
			
			Constraints:
				1 <= s.length, p.length <= 3 * 104
				s and p consist of lowercase English letters.
		class Solution {
			public:
			bool areTheyEqual(int a1[26], int a2[26]){
				for(int i=0;i<26;i++){
					if(a1[i] != a2[i])
						return 0;
				}
				return 1;
			}

			vector<int> findAnagrams(string s, string p) {
				vector<int> ans;

				int count1[26]={0}, count2[26]={0}, i=0;
				//count1 array is for s
				//count2 array is for p

				//mapping for p string
				while(i<p.length()){
					// int ind = p[i]-'a';
					count2[p[i]-'a']++;
					i++;
				}

				//mapping for s string
				i=0;
				while(i<p.length() && i< s.length()){
					// int ind = s[i] - 'a';
					count1[s[i] - 'a']++;
					i++;
				}

				if(areTheyEqual(count1,count2))
					ans.push_back(i-p.length());

				while(i<s.length()){
					// int ind = s[i] - 'a';
					count1[s[i] - 'a']++;
					count1[s[i-p.length()]-'a']--;

					i++;
					if(areTheyEqual(count1,count2))
						ans.push_back(i-p.length());
				}
				return ans;
			}
		};

		//own solution found char array used here
			class Solution {
				public:
				bool areSame(char a[], char b[]){
					for(int i=0;i<26;i++)
						if(a[i] != b[i])
							return 0;
					return 1;
				}
				vector<int> findAnagrams(string s, string p) {
					vector<int> ans;
					if(s.size()<p.size())
						return ans;
					//mapping p's letters
					char forP[26] ={0};
					for(int i=0;i<p.length();i++){
						forP[p[i] - 'a']++;
					}

					int i=0;
					while(i<=s.length()-p.length()){
						string temp = s.substr(i,p.length());
						//mapping here for temp
						char forS[26] = {0};
						for(int l=0; l<temp.length(); l++)
							forS[temp[l]-'a']++;

						if(areSame(forS,forP))
							ans.push_back(i);
						i++;
					}
					return ans;
				}
			};

		//vector used here.
			class Solution {
				public:
				bool areSame(vector<char> a, vector<char> b){
					for(int i=0;i<a.size();i++)
						if(a[i] != b[i])
							return 0;
					return 1;
				}
				vector<int> findAnagrams(string s, string p) {
					vector<int> ans;
					if(s.size()<p.size())
						return ans;
					//mapping p's letters
					vector<char> forP(26,0);
					for(int i=0;i<p.length();i++){
						forP[p[i] - 'a']++;
					}

					int i=0;
					while(i<=s.length()-p.length()){
						string temp = s.substr(i,p.length());
						//mapping here for temp
						vector<char> forS(26,0);
						for(int l=0; l<temp.length(); l++)
							forS[temp[l]-'a']++;

						if(areSame(forS,forP))
							ans.push_back(i);
						i++;
					}
					return ans;
				}
			};

	48) Find first set bit
		Given an integer N. The task is to return the position of first set bit 
			found from the right side in the binary representation of the number.
			Note: If there is no set bit in the integer N, then return 0 from the function.  

			Example 1:
				Input: 
				N = 18
				Output: 
				2
				Explanation: 
				Binary representation of 18 is 010010,the first set bit from the right side is at position 2.
			Example 2:
				Input: 
				N = 12 
				Output: 
				3 
				Explanation: 
				Binary representation of  12 is 1100, the first set bit from the right side is at position 3.
			Your Task:
				The task is to complete the function getFirstSetBit() that 
				takes an integer n as a parameter and returns the position of first set bit.

			Expected Time Complexity: O(log N).
			Expected Auxiliary Space: O(1).

			Constraints:
				0 <= N <= 108
		class Solution{
			public:
			//Function to find position of first set bit in the given number.
			unsigned int getFirstSetBit(int n){
				int cnt=0;
				if(n==0)
					return cnt;
				while(n){
					cnt++;
					if(n&1){
						break;
					}
					n>>=1;
				}
				return cnt;
			}
		};

	49) Duplicate In Array
		Sample Input 1:
			2
			5
			4 2 1 3 1
			7
			6 3 1 5 4 3 2
			Sample Output 1:
			1
			3
			Explanation Of Sample Input 1:
			For the first test case, 
			The duplicate integer value present in the array is 1. Hence, the answer is 1 in this case.

			For the second test case,
			The duplicate integer value present in the array is 3. Hence, the answer is 3 in this case.
			Sample Input 2:
			2
			6 
			5 1 2 3 4 2  
			9
			8 7 2 5 4 7 1 3 6
			Sample Output 2:
			2
			7
		
		#include <bits/stdc++.h>
		int findDuplicate(vector<int> &arr) {
			// for (int i = 0; i < arr.size(); i++)
			//     for (int j = i + 1; j < arr.size(); j++)
			//         if (arr[i] == arr[j])
			//             return arr[i];

			unordered_set<int> seen;

			for(int i:arr){
				if(seen.find(i) != seen.end())
					return i;
				seen.insert(i);
			}
		}

	50) Different Bits Sum Pairwise:
			Sample Input 1 :
				2
				2
				1 2
				2
				6 6
				Sample Output 1 :
				4
				0
				Explanation For Sample Input 1 :
				Test Case 1:
				All the possible pairs in the given array are:-
				f(1, 1) - as both numbers are same, no. of bit differences is 0
				f(1, 2) - 1 in binary is (0001) and 2 in binary is (0010). There are 2 bits which are different in both the numbers. Hence, no. of bit differences is 2.
				f(2, 2) - as both numbers are the same, no, of bit differences is 0
				f(2, 1) - same as (1, 2), hence no. of bit differences is 2.
				Summing the above values (0+2+0+2) we get 4. Hence, the output is 4.

				Test Case 2:
				There is only one possible pair (6,6). As both the numbers are sum, the output is 0.
			Sample Input 2 :
				2
				3 
				1 3 5
				4
				4 6 7 8
				Sample Output 2 :
				8
				26

		//NOT Optimized
			#include <bits/stdc++.h> 
			int differentBitsSumPairwise(vector<int> &arr, int n){
				int sum=0;
				for(int i=0;i<n;i++){
					for(int j=0;j<n;j++){
						
						if(arr[i] == arr[j]){
							continue;
						}else{
							int cnt=0;
							int outer = arr[i],inner=arr[j];
							while(outer !=0 || inner !=0){
								int LBout = outer&1;
								int LBinn = inner&1;
								if(LBout ^ LBinn == 1){
								cnt++;
								}
								outer>>=1;
								inner>>=1;
							}
							sum += cnt;
						}
					}
				}
				return sum;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int differentBitsSumPairwise(vector<int> &arr, int n){
				int sum = 0;
				// Count the number of set bits at each position
				for (int i = 0; i < 32; i++) { 
					// Assuming integers are 32 bits
					int countOnes = 0;
					
					for (int j = 0; j < n; j++) {
						if ((arr[j] >> i) & 1) {
							countOnes++;
						}
					}
					
					int countZeros = n - countOnes;
					
					// For each position, add the count of different bits to the sum
					// Multiply by 2 to count both 0->1 and 1->0 transitions
					sum += countOnes * countZeros * 2; 
				}
				return sum;
			}

	51) First Unique Character in a String
		Sample Input 1:
			2
			bbabcbcb
			babaabea
			Sample Output 1:
			a
			e

			Explanation Of Sample Input 1:
				For the first test case, 
				the first non-repeating character is ‘a’. As depicted the character 
				‘b’ repeats at index 1, 3, 5, 7, and character ‘c’ repeats at index 6. Hence we return the character ‘a’ present at index 2.
				
				For the second test case, 
				the character ‘e’ is the first non-repeating character. As depicted the character ‘b’ repeats at 
				index 2, 5, and character ‘a’ repeats at index 3, 4, and 7. Hence we return the character ‘e’ present at index 6.
		
		Sample Input 2:
			3
			cbbd
			bebeeed
			abcd
			Sample Output 2:
			c
			d
			a

		#include <bits/stdc++.h> 
		char findNonRepeating(string str) {
			int cnt=1;
			for(int i=0;i<str.length();i++){
				if(isalpha(str[i])){
					char ch = str[i];
					int j=i+1;
					cnt=1;
					while(j < str.length()){
						if(isalpha(str[j]))
							if(str[i] == str[j]){
							str[j] = '0';
							cnt++;
							}
						j++;
					}
				}
				if(cnt == 1)
					return str[i];
			}
			return '#';
		}	

	52) MegaPrime Numbers:
		Sample Input 1 :
			2
			2 15
			11 24
			Sample Output 1 :
			4
			1
			Explanation Of Sample Input 1 :
				Test Case 1:
					‘Left’ = ‘2’ and ‘Right’ = ‘15’ 
				All prime numbers from ‘2’ to ‘15’ are 2, 3, 5, 7, 11, 13

					2 is ‘megaprime’ number because its individual digit ‘2’ is prime.
					3 is ‘megaprime’ number because its individual digit ‘3’ is prime.
					5 is ‘megaprime’ number because its individual digit ‘5’ is prime.
					7 is ‘megaprime’ number because its individual digit ‘7’ is prime.
					11 is not ‘megaprime’ number because its individual digits ‘1’ and ‘1’ both are not prime.
					13 is not ‘megaprime’ number because its individual digits ‘1’ is not prime.
					Hence because there are four ‘megaprime’ numbers 2, 3, 5, 7 out of 2, 3, 5, 7, 11, 13, we return four.
				Test case 2:
					‘Left’ = 11 and ‘Right’ = 24 
				All prime numbers from ‘11’ to ‘24’ are 11, 13, 17, 19, 23
					11 is not a ‘megaprime’ number because its individual digit ‘1’ is not prime.
					13 is not ‘megaprime’ number because its individual digit ‘1’ is not prime.
					17 is not ‘megaprime’ number because its individual digit ‘1’ is not prime.
					19 is not ‘megaprime’ number because its individual digits ‘1’ and ‘9’ both are not prime.
					23 is ‘megaprime’ number because its individual digits ‘2’ and ‘3’ both are prime.

				Since there is only one ‘megaprime’ number, 23 out of 11 13, 17, 19, 23, we return one.
		Sample Input 2 :
			2
			1 11
			1 100
			Sample Output 2 :
			4
			8
		#include <bits/stdc++.h> 
		bool isPrime(int num){
			if(num ==1)
				return 0;
			else if(num == 2 || num ==3){
				return 1;
			}else{
				int i=2;
				for(; i<= num/2; i++){
					if(num % i == 0)
						return 0;
				}
				if(i > (num/2))
					return 1;
			}
			return 0;
		}
		int countMegaPrimeNumber(int left, int right) {
			vector<int> megaPrime;
			vector<int> primeNums;
			for(int i=left; i<=right; i++){
				int num = i, start=2;
				while(start <= num/2){
					if(num % start == 0){
						break;
					}
					start++;
				}
				if(start > (num/2))
					primeNums.push_back(num);
			}

			for(int i=0; i<primeNums.size(); i++){
				int n = primeNums[i];
				while(n){
					int lastDigit = n % 10;
					if(lastDigit == 0)
						break;
					else if(isPrime(lastDigit)){
						n/=10;
					}else{
						break;
					}
				}

				if(n == 0)
					megaPrime.push_back(primeNums[i]);
			}
			return megaPrime.size();
		}

		//or

			#include <iostream>
			#include <bits/stdc++.h> 
			using namespace std;

			bool isPrime(int num){
				if(num ==1)
					return 0;
				else if(num == 2 || num ==3){
					return 1;
				}else{
					int i=2;
					for(; i<= num/2; i++){
						if(num % i == 0)
							return 0;
					}
					if(i > (num/2))
						return 1;
				}
				return 0;
			}
			int countMegaPrimeNumber(int left, int right) {
				vector<int> megaPrime;
				vector<int> primeNums;
				for(int i=left; i<=right; i++){
					int num = i, start=2;
					while(start <= num/2){
						if(num % start == 0){
							break;
						}
						start++;
					}
					if(start > (num/2))
						primeNums.push_back(num);
				}

				for(int i=0; i<primeNums.size(); i++){
					int n = primeNums[i];
					while(n){
						int lastDigit = n % 10;
						if(lastDigit == 0)
							break;
						else if(isPrime(lastDigit))
							n/=10;
						else
							break;
					}
					if(n == 0)
						megaPrime.push_back(primeNums[i]);
				}
				cout<<endl<<"Megaprimes are "<<endl;
				for(int j=0; j<megaPrime.size(); j++)
					cout<<megaPrime[j]<<" ";
				cout<<"\n";
				return megaPrime.size();
			}

			int main()
			{
				cout<<countMegaPrimeNumber(7,2547)<<endl;
				return 0;
			}

	53) (moderate) Predict the Winner:
		Description:
			Sample Input 1:
				2
				5
				2
				4
				3
				Sample Output 1:
					3
					1
				Explanation Of Sample Input 1:
				For the first test case:
					The game starts with Person 1. He passes the ball to person 2. 
					The game pauses here. Person 2 passes the ball to person 3 and leaves the game. 
					Then the game resumes. Person 3 passes the ball to person 4. The game pauses here. 
					Person 4 passes the ball to person 5 and leaves the game. 
					Then the game resumes with person 5 having the ball in his hand. 
					He passes the ball to person 1. The game pauses here. Person 1 passes the ball 
					to person 3 and leaves the game. Then the game resumes with person 3 having the ball in his hand. 
					He passes the ball to person 5. The game pauses here. Person 5 passes the ball to person 3 
					and leaves the game. Now only person 3 remains and the game stops here.

				Hence, the winner of the game will be Person 3 and the answer will be 3.
				For the second test case:
					The game starts with Person 1. He passes the ball to person 2. Person 2 passes the ball to Person 3. 
					The game pauses here. Person 3 passes the ball to Person 4 and leaves the game. Then the game resumes. 
					Person 4 passes the ball to person 1. Person 1 passes the ball to person 2.The game pauses here. 
					Person 2 passes the ball to person 4 and leaves the game. Then the game resumes with Person 4 
					having the ball in his hand. He passes the ball to person 1. Person 1 passes the ball to Person 4. 
					The game pauses here. Person 4 passes the ball to person 1 and leaves the game. 
					Now only person 1 remains and the game stops here.
					Hence, the winner of the game will be Person 1 and the answer will be 1.
			Sample Input 2:
				1
				4
				1
				Sample Output 2:
				4
		//not optimized
			#include <bits/stdc++.h> 
			int predictTheWinner(int n, int k) {
				vector<int> v;
				for(int i=1; i<=n; i++)
					v.push_back(i);

				if(v.size() == 1)
					return v[0];

				if(k==1)
					return n;

				int pointer=0;
				while(v.size() > 1){
					pointer = (pointer+k-1) % v.size();
					v.erase(v.begin()+pointer);
				}
				return v[0]; 
			}

		//Optimized
			#include <bits/stdc++.h> 
			int predictTheWinner(int n, int k) {
				if (k == 1) {
					return n;
				}

				int winner = 0;
				for (int i = 2; i <= n; i++) {
					winner = (winner + k) % i;
				}

				return winner + 1;
			}

	54) Ninja And The Nested Ranges:
		//Not Optimized:
			Sample Input 1 :
				2
				3
				3 8
				1 3
				7 8
				4
				4 9
				9 10
				4 10
				2 3
				Sample Output 1 :
				1 0 0
				0 0 1
				0 0 1 0
				1 1 0 0
				Explanation Of Sample Output 1 :
				Test Case 1 :  
				For ‘RESULT[ 0 ]’ array:
				Since the range [3, 8] contains the range [7, 8], the output corresponding to [3, 8] is 1.
				The range [1, 3] does not contain any of the ranges. Therefore, the output corresponding to [1, 3] is 0.
				The range [7, 8] does not contain any of the ranges. Therefore, the output corresponding to [7, 8] is 0.

				For ‘RESULT[ 1 ]’ array:
				The range [3, 8] is not contained by any of the ranges. Therefore, the output corresponding to [3, 8] is 0.
				The range [1, 3] is not contained by any of the ranges. Therefore, the output corresponding to [1, 3] is 0.
				Since the range [7, 8] is contained by the range [3, 8], the output corresponding to [7, 8] is 1.

				Test Case 2 :     
				For ‘RESULT[ 0 ]’ array:
				The range [4, 9] does not contain any of the ranges. Therefore, the output corresponding to [4, 9] is 0.
				The range [9, 10] does not contain any of the ranges. Therefore, the output corresponding to [9, 10] is 0.
				Since the range [4, 10] contains the ranges [4, 9] and [9, 10], the output corresponding to [4, 10] is 1.
				The range [2, 3] does not contain any of the ranges. Therefore, the output corresponding to [2, 3] is 0.

				For ‘RESULT[ 1 ]’ array:
				Since the range [4, 9] is contained by the range [4, 10], the output corresponding to [4, 9] is 1.
				Since the range [9, 10] is contained by the range [4, 10], the output corresponding to [9, 10] is 1.
				The range [4, 10] is not contained by any of the ranges. Therefore, the output corresponding to [4, 10] is 0.
				The range [2, 3] is not contained by any of the ranges. Therefore, the output corresponding to [2, 3] is 0.
				Sample Input 2 :
				2
				5
				5 8
				8 11
				5 13
				13 14
				3 15
				4
				22 91
				25 40
				66 85
				57 83
				Sample Output 2 :
				0 0 1 0 1
				1 1 1 1 0
				1 0 0 0
				0 1 1 1

			#include <iostream>
			#include <bits/stdc++.h> 
			using namespace std;
			vector<vector<int>> nestedRangesCheck(vector<vector<int>> &ranges, int n){
				vector<vector<int>> ans;
				vector<int> temp;

				int i=0;

				//for first array checking contains or not?
				while(i<n){
					int root1 = ranges[i][0];
					int root2 = ranges[i][1];
					int inner=0;
					bool flag = true;
					while(inner<n){
						if(inner == i){
							inner++;
							continue;
						}
						int check1 = ranges[inner][0];
						int check2 = ranges[inner][1];

						if(root1<= check1 && root2>=check2){
							temp.push_back(1);
							flag = false;
							break;
						}
						inner++;
					}
					if(flag)
						temp.push_back(0);
					i++;
				}
				ans.push_back(temp);
				temp.clear();
				
				//for second array checking contained by any of ranges
				i=0;
				while(i<n){
					int root1 = ranges[i][0];
					int root2 = ranges[i][1];
					bool flag = true;
					int inner = 0;
					while(inner<n){
						if(inner == i){
							inner++;
							continue;
						}
						
						int check1 = ranges[inner][0];
						int check2 = ranges[inner][1];
						
						if(check1<=root1 && check2>=root2){
							temp.push_back(1);
							flag = false;
							break;
						}
						inner++;
					}
					if(flag)
						temp.push_back(0);
					i++;
				}
				ans.push_back(temp);
				return ans;
				}

			int main(){
				vector<vector<int>> ans;
				// int n=4;
				// vector<vector<int>> temp = {{4,9},{9,10},{4,10},{2,3}};
				int n=3;
				vector<vector<int>> temp = {{3,8},{1,3},{7,8}};
				ans = nestedRangesCheck(temp, n);
				
				for(int i=0;i<2;i++){
					for(int j=0;j<n;j++)
						cout<<ans[i][j]<<" ";
					cout<<"\n";
				}
				return 0;	
			}

	55) Count unsorted columns
		You are given an array ‘STRINGS’ having
				‘N’ number of strings. The strings are
				assumed to be arranged such that there
				is one string in one line.
				You need to return the number of columns
				that are not sorted lexicographically.
				Note:
				The length of all the string in the array is the same
		Sample Input 1:
			2
			3
			bccde
			dehrt
			gabzy
			2
			wr
			yz
			Sample Output 1:
			2
			0
			Explanation Of Sample Input 1:
			Test Case 1: In the given strings -
			Column 0 - b, d, g is sorted
			Column 1 - c, e, a is not sorted
			Column 2 - c, h, b is not sorted
			Column 3 - d, r, z is sorted
			Column 4 - e, t, y is sorted.

			Column 1, column 2 is not sorted, so the required answer is ‘2’.

			Test Case 2: Both the columns (‘w’, ‘y’) and (‘r’, ‘z’ ) are sorted. So the answer is ‘0’.
			Sample Input 2:
			2
			4
			u
			e 
			y 
			b
			2
			cterub
			aybsgn
			Sample Output 2:
			1
			3
		
		//checks the strings columns wise, are they sorted or not? 
		//length of all string in vector are same
		#include <iostream>
		#include<vector>
		using namespace std;

		int main(){
			int unsortedCnt=0;
			int col=0;
			
			vector<string> strings = {"cterub","aybsgn"};
			while(col<strings[0].size()){
				for(int i=0; i< strings.size()-1; i++){
					string word1 = strings[i];
					string word2 = strings[i+1];
					
					if(word1[col]>word2[col]){
						unsortedCnt++;
						break;
					}
				}
				col++;
			}
			
			cout<<unsortedCnt;
			return 0;
		}

	56) Wave Array:
		Example 1:
			Input:
			n = 5
			arr[] = {1,2,3,4,5}
			Output: 2 1 4 3 5
			Explanation: Array elements after 
			sorting it in wave form are 
			2 1 4 3 5.

		Example 2:
			Input:
			n = 6
			arr[] = {2,4,7,8,9,10}
			Output: 4 2 8 7 10 9
			Explanation: Array elements after 
			sorting it in wave form are 
			4 2 8 7 10 9.
		Your Task:
			The task is to complete the function convertToWave(), which converts the given array to a wave array.

		Expected Time Complexity: O(n).
		Expected Auxiliary Space: O(1).

		Constraints:
			1 ≤ n ≤ 106
			0 ≤ arr[i] ≤107
		#include <iostream>
		#include<vector>
		using namespace std;

		void toWaveForm(vector<int> a){
			cout<<"Wave form array:\t";
			for(int i=0;i<a.size()-1; i +=2)
				swap(a[i],a[i+1]);
			
			for(int i:a)
				cout<<i<<"\t";
				
			cout<<"\n";
		}

		void normalArray(vector<int> a){
			std::cout << "Normal array :\t\t";
			for(int i: a)
				cout<<i<<"\t";
			cout<<"\n";    
		}

		int main(){
			vector<int> a = {1,2,3,4,5,6,7,8,9,10};
			normalArray(a);
			
			toWaveForm(a);
			
			vector<int> b = {22,33,44,5,66,77,88,99,12,90,89};
			normalArray(b);
			
			toWaveForm(b);
			
			return 0;
		}

	57) Monotonic Array
		An array is monotonic if it is either monotone increasing or monotone decreasing.
			An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. 
			An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
			Given an integer array nums, return true if the given array is monotonic, or false otherwise.
			
			Example 1:
				Input: nums = [1,2,2,3]
				Output: true

			Example 2:
				Input: nums = [6,5,4,4]
				Output: true
			Example 3:
				Input: nums = [1,3,2]
				Output: false
			Constraints:
				1 <= nums.length <= 105
				-105 <= nums[i] <= 105
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {
				int i=0, n=1;
				back:
				if( (i+n)<nums.size() && nums[i] <= nums[i+n]){
					if(nums[i] == nums[i+n]){
						n++;
						goto back;
					}
					for(int j=i+1; j<nums.size()-1; j++)
						if(nums[j] > nums[j+1])
							return 0;
				}else{
					for(int j=i+1; j<nums.size()-1; j++)
						if(nums[j] < nums[j+1])
							return 0;
				}
				return 1;
			}
		};

		//or
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {
				bool increasing = true;
				bool decreasing = true;

				for (int i = 1; i < nums.size(); ++i) {
					if (nums[i] > nums[i - 1]) {
						decreasing = false;
					}
					if (nums[i] < nums[i - 1]) {
						increasing = false;
					}
				}
				return increasing || decreasing;
			}
		};

		//or
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {

				if(nums.size()==1)
					return 1;
				
				bool increORdecre= false;
				int i=0;
				while(i<nums.size()-1){
					if(nums[i]<= nums[i+1]){
						increORdecre = true;
					}
					else{
						increORdecre = false;
						break;
					}
					i++;
				}
				
				if(increORdecre)
					return 1;

				i=0;
				while(i<nums.size()-1){
					if(nums[i]>=nums[i+1]){
						increORdecre = true;
					}else{
						increORdecre = false;
						break;
					}
					i++;
				}
				return increORdecre;
			}
		};

	58) Mirror String :
		-The String which contains the letter A,H,I,M,O,T,U,V,W,X,Y etc are the same looks in mirror.
		-& check for string is palindrome or not,
		Sample Input 1:
			1
			ITATI
			Sample Output 1:
			YES
			Explanation Of Sample Input 1:
			String “ITATI” is the same as its reflection in the mirror.
			Sample Input 2:
			2
			MMMM
			MZM
			Sample Output 2:
			YES
			NO

		#include <bits/stdc++.h> 
		bool isPalindrome(string &s){
			for(int i=0;i<s.length()/2;i++)
				if(s[i] != s[s.length()-i-1])
					return 0;
			return 1;
		}

		bool isReflectionEqual(string &s){
			for(int i=0; i<s.length(); i++){
				if(s[i] == 'A' || s[i] == 'H' || s[i] == 'I' ||
					s[i] == 'M' || s[i] == 'O' || s[i] == 'T' ||
					s[i] == 'U' || s[i] == 'V' || s[i] == 'W' || 
					s[i] == 'X' || s[i] == 'Y'){
						continue;
					}
				else{
					return false;
				}
			}

			bool check = isPalindrome(s);
			return check;
		}

	59) Detect Odd:
		You are given an array of ‘N’ nonnegative integers where all elements
			appear an even number of times except
			two, print the two odd occurring
			elements in increasing order. It may be
			assumed that the size of the array is atleast two and there will always be
			exactly two numbers which appear an
			odd number of times in the given array.
			EXAMPLE:
			Input: 'N' = 6, 'NUMS' = [1,
			1, 2, 3, 4, 4]
			Output: 2 3
			Here in the given array we can
			see that 2 and 3 occur 1 time
			which is an odd number. Hence,
			the output will be 2 and 3.
		Sample Input 1 :
			2
			6
			1 1 2 3 4 4
			2
			1 2
			Sample Output 1 :
			2 3
			1 2
			Explanation Of Sample Input 1 :
			For the first test case,
			'N' = 6 and 'NUMS' = [1, 1, 2, 3, 4, 4]
			Here in the given array we can see that 2 and 3 occur 1 time which is an odd  number. Hence, the output will be 2 and 3.

			For the second test case,
			'N' = 2 and 'NUMS' = [1, 2]
			Here in the given array we can see that 1 and 2 occur 1 time which is an odd  number. Hence, the output will be 1 and 2.
		Sample Input 2 :
			2
			4
			8 2 2 7
			4
			3 1 3 5
			Sample Output 2 :
			7 8   
			1 5
		
		//not Optimized:
			#include <bits/stdc++.h> 
			vector <int> detectOdd(int n, vector <int> nums) {
				if(nums.size()==2)
					return nums;
				
				vector<int> ans;
				for(int i=0;i<nums.size(); i++){
					int cnt=1,j;
					if(nums[i] == INT_MIN){
						continue;
					}
					
					for(j=0; j<nums.size(); j++){
						if(i==j || nums[j] == INT_MIN)
							continue;
						else if(nums[i] == nums[j]){
							nums[i] = INT_MIN;
							nums[j] = INT_MIN;
							cnt++;
							break;
						}
					}
					if(cnt==1)
						ans.push_back(nums[i]);
				}

				sort(ans.begin(), ans.end());
				return ans;
			}
		
		//Optimized:
			#include <bits/stdc++.h> 
			vector <int> detectOdd(int n, vector < int > nums) {
				if(nums.size()==2)
					return nums;
				
				vector<int> ans;
				unordered_set<int> doublChecker;

				for(int i=0; i<nums.size(); i++){
					if(doublChecker.count(nums[i]) == 0)
						doublChecker.insert(nums[i]);
					else
						doublChecker.erase(nums[i]);
				}

				ans.assign(doublChecker.begin(), doublChecker.end());				//assigning unordered_set to vector
				sort(ans.begin(), ans.end());
				return ans;
			}
		
	60) Ninja and Range Max
		Sample Input 1:
			2
			6 0 3
			3 2 2 4 5 2
			6 4 4
			2 4 6 8 9 10
			Sample Output 1:
			4
			9
			Explanation Of Sample Input 1:
			For test case 1:
			The maximum element in the range [0, 3] is 4.
			Hence, the answer for this case is 4.

			For test case 2:
			The maximum element in the range [4, 4] is 9.
			Hence, the answer for this case is 9.
			Sample Input 2:
			2
			5 2 3
			6 6 8 5 1
			5 3 4
			2 4 5 3 1
			Sample Output 2:
			8
			3

		int ninjaAndRangeMax(int n, int x, int y, vector<int> &a) {
			int maxer = a[x];
			for(int i=x+1; i<=y; i++)
				maxer = max(maxer, a[i]);
			return maxer;
		}

		//more optimized:
			int ninjaAndRangeMax(int n, int x, int y, vector<int> &a) {
				auto max_iter = std::max_element(a.begin() + x, a.begin() + y + 1);
				return *max_iter;
			}

	61) 132 Pattern:
		Given an array of n integers nums, a 132 pattern is a subsequence of three 
		integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
		Return true if there is a 132 pattern in nums, otherwise, return false.
			Example 1:
				Input: nums = [1,2,3,4]
				Output: false
				Explanation: There is no 132 pattern in the sequence.
			Example 2:
				Input: nums = [3,1,4,2]
				Output: true
				Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
			Example 3:
				Input: nums = [-1,3,2,0]
				Output: true
				Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
			Constraints:
				n == nums.length
				1 <= n <= 2 * 105
				-109 <= nums[i] <= 109
		//Not Optimized:
			class Solution {
				public:
				bool find132pattern(vector<int>& nums) {
					if(nums.size() < 3)
						return 0;

					//checking that more than 3 different nums present in vector or not?
					set<int> checking;
					for(int i: nums)
						checking.insert(i);
					
					if(checking.size()<3)
						return 0;

					//reducing 2 coz its subarray of 3 elements.
					int iRange = nums.size()-2;
					int jRange = nums.size()-1;

					for(int i=0; i< iRange; i++){
						for(int j=i+1; j< jRange; j++){
							for(int k=j+1; k<nums.size(); k++){
								if((nums[i] < nums[k])  && (nums[k] < nums[j]))
									return 1;
							}                
						}
					}
					return 0;  
				}
			};
		
		//optimized:
			class Solution {
				public:
				bool find132pattern(vector<int>& nums) {
					int n = nums.size();
					if (n < 3) {
						return false;
					}

					vector<int> minSoFar(n);
					minSoFar[0] = nums[0];

					// Calculate the minimum element so far for each index
					for (int i = 1; i < n; i++) {
						minSoFar[i] = min(minSoFar[i - 1], nums[i]);
					}

					stack<int> s;

					for (int j = n - 1; j >= 0; j--) {
						// If nums[j] is greater than the minimum element so far, we have a candidate for 'k'
						if (nums[j] > minSoFar[j]) {
							// Find the maximum 'i' that is less than nums[j]
							while (!s.empty() && s.top() <= minSoFar[j]) {
								s.pop();
							}

							// If we found a valid 'i', return true
							if (!s.empty() && s.top() < nums[j]) {
								return true;
							}
							// Push nums[j] onto the stack as a potential 'k'
							s.push(nums[j]);
						}
					}
					return false; 
				}
			};

	62) Maximum Value of F(x) - VI:
		problem Statement
			You are provided with a sorted array of integers
			‘ARR’ having length ‘N’ and a function ‘F(X)’, such
			that:
			F(X) = S + G
			Where:
			‘X’ = Any integer that belongs to array
			‘ARR’.
			‘S’ = Number of integers in ‘ARR’ that
			are strictly smaller than ‘X’.
			‘G’ = Number of integers in ‘ARR’ that
			are strictly greater than ‘X’.
			For Example:
			‘ARR’ = {1, 1, 1, 2, 2, 3, 4}
			Let, ‘X’ = 1
			F(X) = 0 + 4 = 4 (as ‘0’ numbers of
			elements are smaller than ‘1’ and ‘4’
			elements that are ‘2’, ‘2’, ‘3’, and ‘4’
			are greater than ‘1’.
			Let ‘X’ = 2
			F(X) = 3 + 2 = 5 (as ‘3’ numbers
			(‘1’, ‘1’, and ‘1’) are smaller than ‘2’
			and ‘2’ numbers that are ‘3’, and ‘4’ are
			greater than ‘2’.
			Let ‘X’ = 3
			F(X) = 5 + 1 = 6 (as ‘5’ numbers
			(three times ‘1’ and two times ‘2’) are
			smaller than ‘3’ and ‘1’ number that is
			‘4’ is greater than ‘3’.
			Let ‘X’ = 4
			F(X) = 6 + 0 = 6 (as ‘6’ numbers
			(three times ‘1’, two times ‘2’, and one
			time ‘3’) are smaller than ‘4’ and ‘0’
			numbers are greater than ‘3’.
			All you have to do is to find the maximum value of
			‘F(X)’.

		Sample Input 1 :
			1
			7
			1 1 1 2 2 3 4
			Sample Output 1 :
			6
			Explanation For Sample Input 1 :
			For the first test case, an explanation is given in the description.
			Sample Input 2 :
			2
			5
			10 20 30 40 40
			2
			3 4
			Sample Output 2 :
			4
			1
		//not optimized:
			#include <bits/stdc++.h> 
			int maxFXVI(int n, vector<int> &arr){
				vector<int> maxer;
				for(int i=0;i<n; i++){
					int cnt=0;
					for(int j=0; j<n; j++){
						if(i==j)
							continue;
						if(arr[i] != arr[j])
							cnt++;
					}
					maxer.push_back(cnt);
				}
				auto mxValue = max_element(maxer.begin(), maxer.end());
				return *mxValue;
			}

	63) Find the length of last word:
		https://leetcode.com/problems/length-of-last-word/
		#include <iostream>
		#include<algorithm>
		using namespace std;
		int main(){
			// string s = "Vivek Mahesh Nikate";
			string s = "Hello world";
			string Lword;
			
			for(int i=s.length()-1; i>=0;i--){
				if(s[i] != ' ')
					Lword += s[i];
				else
					break;

				//or you can use this also instead of above if checking condition
					//if(isblank(s[i]))
					//	break;
					//Lword += s[i];
			}
			reverse(Lword.begin(), Lword.end());
			std::cout << Lword<<" & the length of its is :: "<< Lword.length() << std::endl;
			return 0;
		}

		//ignoring the trailing spaces also,
		class Solution {
			public:
			int lengthOfLastWord(string s) {
				int i=s.length()-1;
				while(i>=0){
					if(isblank(s[i]))
						s.erase(i,1);
					else 
						break;
					i--;
				}
					
				i = s.size()-1;
				string temp;
				while(i>=0){
					if(isblank(s[i]))
						break;
					temp += s[i];
					i--;
				}
				return temp.length();
			}
		};
		
		//or 0ms second
			class Solution {
				public:
				int lengthOfLastWord(string s) {
					int count=0;
					for(int i=s.length()-1; i>=0; i--){
						while(int(s[i])==32){
							i--;
						}
						while(int(s[i])!=32){
							count++;
							i--;
							if(i<0){
								break;
							}
						}
						break;
					}
					return count;
				}
			};

	64) Column name from a given column number:
		Given a positive integer, return its corresponding column title as appear in an Excel sheet.
		Excel columns has a pattern like A, B, C, … ,Z, AA, AB, AC,…. ,AZ, BA, BB, … ZZ, AAA, AAB ….. etc. 
		In other words, column 1 is named as “A”, column 2 as “B”, column 27 as “AA” and so on.

			Example 1:
				Input:
				N = 28
				Output: AB
				Explanation: 1 to 26 are A to Z.
				Then, 27 is AA and 28 = AB.

			Example 2:
				Input: 
				N = 13
				Output: M
				Explanation: M is the 13th character of
				alphabet.
				Your Task:
			You don't need to read input or print anything. Your task is to complete the function colName() which takes the column number N as input and returns the column name represented as a string.
			Expected Time Complexity: O(LogN).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <= 1018
		class Solution{
			public:
			string colName (long long int n){
				
				string s;
			
				while (n > 0) {
					int GenNum = (n-1) % 26;  // Subtract 1 to get the correct column name
					char ch = 'A';
			
					for (int i =0; i < GenNum; i++) {
						ch++;
					}
					s += ch;
					n = (n-1) / 26;  // Subtract 1 here as well
				}
				reverse(s.begin(), s.end());
				return s;
			}
		};

	65) Roman Number to Integer:
		Given a string in roman no format (s)  your task is to convert it to an integer . 
		Various symbols and their values are given below.
			I 1
			V 5
			X 10
			L 50
			C 100
			D 500
			M 1000

			Example 1:
			Input:
				s = V
				Output: 5
			Example 2:
				Input:
				s = III 
				Output: 3
			Your Task:
				Complete the function romanToDecimal() which takes a string as input parameter and returns the 
				equivalent decimal number. 

			Expected Time Complexity: O(|S|), |S| = length of string S.
			Expected Auxiliary Space: O(1)

			Constraints:
				1<=roman no range<=3999
			class Solution {
				public:
				int romanToDecimal(string &str) {
					int i=str.length()-1;
					int num=0;

					while (i >= 0) {
						char val = str[i];
						int temp, prev = 0;
				
						if (val == 'I') {
							temp = 1;
						} else if (val == 'V') {
							temp = 5;
						} else if (val == 'X') {
							temp = 10;
						} else if (val == 'L') {
							temp = 50;
						} else if (val == 'C') {
							temp = 100;
						} else if (val == 'D') {
							temp = 500;
						} else if (val == 'M') {
							temp = 1000;
						}
				
						if (i > 0) {
							char prevVal = str[i - 1];
							if (prevVal == 'I') {
								prev = 1;
							} else if (prevVal == 'V') {
								prev = 5;
							} else if (prevVal == 'X') {
								prev = 10;
							} else if (prevVal == 'L') {
								prev = 50;
							} else if (prevVal == 'C') {
								prev = 100;
							} else if (prevVal == 'D') {
								prev = 500;
							} else if (prevVal == 'M') {
								prev = 1000;
							}
						}
				
						if (prev > 0 && prev < temp) {
							temp -= prev;
							i--; // Skip the previous character
						}
				
						num += temp;
						i--;
					}
					return num;
				}
			};

			//or
				int mapRomanToDecimal(char ch){
					if(ch == 'I'){
						return 1;
					}else if(ch == 'V'){
						return 5;
					}else if(ch == 'X'){
						return 10;
					}else if(ch == 'L'){
						return 50;
					}else if(ch == 'C'){
						return 100;
					}else if(ch == 'D'){
						return 500;
					}else if(ch == 'M'){
						return 1000;
					}
				}

				int romanToInt(string s) {
					int i=s.length()-1;
					int num = 0;
					while(i>=0){
						char curVal = s[i];
						int temp = mapRomanToDecimal(curVal);
						int prev=0;

						if(i>0){
							char prevVal = s[i-1];
							prev = mapRomanToDecimal(prevVal);
						}

						if(prev< temp){
							temp -= prev;
							i--;
						}

						num += temp;
						i--;

					}
					return num;
				}

	66) Modular Exponentiation :
		You are given a three integers 'X','N', and 'M'. Your task is to find ('X'^ 'N') % 'M'. A ^ B is defined 
		as X raised to power N and X % M is the remainder when X is divided by M.

			Constraints :
			1 <= T <= 100
			1 <= X, N, M <= 10^9
			Time limit: 1 sec
		Sample Input 1 :
			2 
			3 1 2
			4 3 10
			Sample Output 1 :
			1
			4
			Explanation For Sample Output 1:
			In test case 1, 
			X = 3, N = 1, and M = 2 
			X ^ N = 3 ^ 1 = 3 
			X ^ N % M = 3 % 2 = 1. 
			So the answer will be 1.

			In test case 2,
			X = 4, N = 3, and M = 10 
			X ^ N = 4 ^ 3 = 64 
			X ^ N % M = 64 % 10 = 4. 
			So the answer will be 4.
			Sample Input 2 :
			2
			5 2 10 
			2 5 4
		Sample Output 2 :
			5
			0
			Explanation For Sample Output 2:
			In test case 1, 
			X = 5, N = 2, and M = 10 
			X^N = 5^2 = 25 
			X^N %M = 25 % 10 = 5. 
			So the answer will be 5.

			In test case 2,
			X = 2, N = 5, and M = 4 
			X^N = 2^5 = 32 
			X^N %M = 32 % 4 = 0. 
			So the answer will be 0.

			//NOT Optimized:
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;
					
					for(int i=0; i<n; i++){
						power = (power * x) % m;
					}
					return power;
				}
			
			//Optimized:
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;

					if(n==0)
						return power;

					long long base = x % m;
					while(n>0){
						if(n&1)
							power = (power * base) %m;
						base = (base*base)%m;
						n/=2;
					}
					return (int)((power+m)%m);
				}
			
			//or
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;
					long long base = x;
					if(n==0)
						return power;
					int i=1;
					while(n > 0){
						if(n&1)
							power = (power % m * base % m) % m;

						base = (base * base) % m ;
						n /= 2;
					}
					return power;
				}

	67) Largest Element in the Array
		Given an array ‘arr’ of size ‘n’ find the largest element in the array.
		Example:
		Input: 'n' = 5, 'arr' = [1, 2,3, 4, 5]
		Output: 5
		Explanation: From the array {1,2, 3, 4, 5}, the largest element is 5.

		Sample Input 1:
			6
			4 7 8 6 7 6 
			Sample Output 1:
			8
			Explanation Of Sample Input 1: The answer is 8. From {4 7 8 6 7 6}, 8 is the largest element.
		Sample Input 2:
			8
			5 9 3 4 8 4 3 10 
			Sample Output 2:
			10
			Expected Time Complexity:
			O(n), Where ‘n’ is the size of an input array ‘arr’.
			Constraints :
			1 <= 'n' <= 10^5
			1 <= 'arr[i]' <= 10^9

			Time Limit: 1 sec

		#include <bits/stdc++.h> 
		int largestElement(vector<int> &arr, int n) {
			// auto mxr = max_element(arr.begin(), arr.end());
			// return *mxr;
			int mx = arr[0];
			for(int i=1;i<n;i++)
				mx = max(mx,arr[i]);
			return mx;
		}

	68) Sum Of Even Numbers Till N:
		Sample Input 1 :
			2
			6
			2
			Sample Output 1 :
			12
			2
			Explanation For Sample Input 1 :
			For test case 1 :
			Sum of all even numbers till 6 will be : 2 + 4 + 6 = 12

			For test case 2 :
			Sum of all even numbers till 2 will be : 2
			Sample Input 2 :
			2
			4
			5
			Sample Output 2 :
			6
			6
			Explanation For Sample Input 2 :
			For test case 1 :
			Sum of all even numbers till 4 will be : 2 + 4 = 6

			For test case 2 :
			Sum of all even numbers till 5 will be : 2 + 4 = 6

		#include <bits/stdc++.h> 
		long long evenSumTillN(int n) {
			long long sum =0;
			for(int i=2; i<=n; i+=2)
				sum += i;
			return sum;
		}

	69) Find Character Case
		You are given a character ‘CH’ as input, return either 1,
		0 or -1 according to the following rules:
		1, if the character is an uppercase alphabet (A - Z).
		0, if the character is a lowercase alphabet (a - z).
		-1, if the character is not an alphabet.
		For Example :
			If ‘CH’ = ‘a’, then since it is a
			lowercase letter, your program should return 0
		Sample Input 1:
			2
			A
			t
			Sample Output 1:
			1
			0
			Explanation For Sample Input 1:
			For sample case 1, ‘A’ is an uppercase letter, hence output is 1.
			For sample case 2, ‘t’ is a lowercase letter, hence output is 0.
			Sample Input 2:
			2
			#
			P
			Sample Output 2:
			-1
			1
			Explanation For Sample Input 2:
			For sample case 1, ‘#’ is not an alphabet, hence output is -1.
			For sample case 2, ‘P’ is an uppercase letter, hence output is 1.

		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(islower(ch))
				return 0;
			else if(isupper(ch))
				return 1;
			else
				return -1;
		}

	70) Two Repeated Elements:
		You are given an array of N+2 integer elements. 
			All elements of the array are in the range 1 to N. 
			Also, all elements occur once except two numbers which occur twice. 
			Find the two repeating numbers.

			Note: Return the numbers in their order of appearing twice. 
			So, if X and Y are the repeating numbers, and X repeats twice before Y 
			repeating twice, then the order should be (X, Y).

			Example 1:
				Input:
				N = 4
				array[] = {1,2,1,3,4,3}
				Output: 1 3
				Explanation: In the given array, 
				1 and 3 are repeated two times.
				
			Example 2:
				Input:
				N = 2
				array[] = {1,2,2,1}
				Output: 2 1
				Explanation: In the given array,
				1 and 2 are repeated two times 
				and second occurence of 2 comes 
				before 1. So the output is 2 1.

			Your Task:
				The task is to complete the function repeatedElements() which takes array arr[] and 
				an integer N as inputs (the size of the array is N + 2 and elements are in the range[1, N]) 
				and finds the two repeated element in the array and return them in a list.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1). 

			Constraints:
				2 ≤ N ≤ 105
				1 ≤ array[i] ≤ N

		class Solution {
			public:
			//Function to find two repeated elements.
			vector<int> twoRepeated (int arr[], int n) {
				
				vector<int> ans;
				vector<int> counts(n+2, 0);
				
				for(int i=0; i<n+2; i++){
					counts[arr[i]]++;
					if(counts[arr[i]] == 2)
						ans.push_back(arr[i]);
					
					if(ans.size()==2)
						break;
				}
				return ans;
			}
		};

	71) String Mania
		Rohit love strings. But he has many strings with him,
			and he is confused about which one he loves more. So
			he decided to come up with a scoring system for the
			strings. The scoring system took two strings as input,
			let's call them ‘STR1’ and ‘STR2’ of length ‘N’ and
			length ‘M’ respectively.
			The system will return ‘1’ if ‘STR1’ is better than ‘STR2’.
			The system will return ‘0’ if ‘STR1’ is the same as ‘STR2’.
			The system will return ‘-1’ if ‘STR2’ is better than ‘STR1’.
			To decide which string is better he followed the below steps.
			Let’s suppose there exists a index ‘i’ such that ‘0’ <= ‘i’ < ‘min(N,M)’ and for all ‘j<i’, ‘STR1[j]’ is equal to
			‘STR2[j]’, and ‘STR1[i] != STR2[i]’.
			Then if ‘STR1[i]>STR2[i]’, ‘STR1’ is better otherwise if
			‘STR2[i]>STR1[i]’, ‘STR2’ is better,
			And if there doesn’t exist any such ‘i’ then if ‘N>M’,
			‘STR1’ is better,
			And if ‘N<M’, ‘STR2’ is better, and if ‘N’ is equal to ‘M’,
			both strings are the same.
			But Rohit has so many strings, so he doesn’t have time
			to go through all strings, So being his friend can you
			help him automate this process?.

		Sample Input 1 :
			2
			1 3
			a
			abc
			3 3
			abz
			abc
		Sample Output 1 :
			-1
			1
		Explanation Of Sample Input 1 :
			For the first test case, ‘STR2’ is better than ‘STR1’, 
			as they are the same until the ‘0th’ index and then string ‘STR1’ ends and 
			as explained in the statement for ‘M>N’, the answer is ‘-1’.

			Hence, the output will be: -1

		For the second test case, ‘STR1’ is better than ‘STR2’, as they are the same until 
		the ‘1st’ index and then ‘STR1[2]>STR2[2]’.

		Hence, the output will be: 1
			Sample Input 2 :
				3
				2 3
				ez
				ehz
				5 5
				acefi
				acefi
				3 5
				ags
				agtaa
			Sample Output 2 :
				1
				0
				-1
		#include <bits/stdc++.h> 
		int stringMania(int n, int m, string str1, string str2) {
			if(str1 == str2)
				return 0;
			int i=0;
			while(i<n && i<m){
				if(str1[i] == str2[i]){
					i++;
					continue;
				}else if(str1[i] > str2[i]){
					return 1;
				}else{
					return -1;
				}
				i++;
			}
			return -1;
		}

	72) Count Of 3s:
		You are given an integer ‘N’. You simply need to find out the number of occurrences of 3 as a digit in the
			range of numbers from [0, N]. 
			Note: You need to count occurrences at every place of the number.
			For Example :
				You are given N = 13, then the number of occurrences 
				of 3 in range [0, 13] = 2 (3,13), you need to return 2.
			Sample Input 1:
				2
				13
				24
			Sample Output 1:
				2
				3
			Explanation For Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [0, 13] = 2 (3, 13). Return 2

			In the second test case, 
			Number of occurrences of 3 in range [0, 24] = 3 (3, 13, 23). Return 3
			Sample Input 2:
				2
				10
				33
			Sample Output 2:
				1
				8
			Explanation For Sample Input 2:
			In the first test case, 
			Number of occurrences of 3 in range [0, 10] = 1 (3). Return 1

			In the second test case, 
			Number of occurrences of 3 in range [0, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int countOf3(int x) {
			long long int cnt=0;
			for(int i=3; i<=x; i++){
				int curNum = i;
				while(curNum>0){
					int lastDigit = curNum%10;
					if(lastDigit == 3)
						cnt++;
					curNum/=10;
				}
			}
			return cnt;
		}

	73) Valid String:
		There is a town named Chefland where Chef lives.
			One can only enter the Chefland through visa which is
			granted by head Chef of the town named Chef
			Sanjeev Kapoor. Chef Sanjeev is very interested in the
			validation of string.
			Hence he devised a test to get into the Chefland. Chef
			Sanjeev Kapoor considers a string to be valid if all
			characters of the string appear the same number of
			times. It is also valid if he can remove just 1 character
			at 1 index in the string, and the remaining characters
			will occur the same number of times. Given a string S,
			determine if it is valid. If so, return YES, otherwise
			return NO.
			For example, if S="abc", it is a valid string because
			frequencies are {a:1, b:1,c:1}. So is S="abcc" because
			we can remove one c and have 1 of each character in
			the remaining string. If S="abccc" however, the string
			is not valid as we can only remove 1 occurrence of c.
			That would leave character frequencies of {a:1, b:1,c:2}.
		
			Input Format:
				A single string S.
			Constraints:
				1 ≤ |S| ≤ 100000
				Each character s[i] belongs to [a-z]
			Time limit = 1 sec
			Output Format:
				Print YES if string S is valid, otherwise, print NO.
			
			Sample Input 1:
				aabbcd
			Sample Output 1:
				NO
			Sample Input 2:
				abcdefghhgfedecba
			Sample Output 2:
				YES
				Explanation:
				For testcase 2:
				All characters occur twice except for e which occurs 3 times. We can delete one instance of e to have a valid string.

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			string s;
			cin>>s;
			int charCountArr[26] = {0};
			
			//counting the characters..
			for(int i=0; i<s.length(); i++){
				charCountArr[s[i]-'a']++;
			}

			//checking count
			int cnt=0;
			int num = charCountArr[0];

			for(int i=1; i<26; i++){
				if(charCountArr[i] == num || charCountArr[i] == 0){
					continue;
				}else{
					cnt++;
				}
			}

			if(cnt<=1 || s.length()==1)
				cout<<"YES";
			else
				cout<<"NO";
			return 0;
		}

	74) Find the correct password:
		Mike is an evil plotting genius and has gotten hold of a
			list of all possible passwords for a certain user
			account. The first thing he noticed was all the
			passwords are of odd length. Mike assumes that the
			correct password is the one which can be found in
			both the original and reverse order in the list. For
			example, if the word “tulipan” would be the correct
			password, the word “napilut” has to also appear in the
			list. Given that both words are correct passwords,
			Mike will try to use both, one at a time.
			Help Mike discover what the correct password is and
			output its length and central character.
			Input Format:
				The first line of input contains the integer N, the number of possible
				passwords. Each of the following N lines contains a single word S, its length being an odd
				number. All characters are lowercase letters of the English alphabet.
			Constraints:
				1 ≤ N ≤ 100
				2 < S < 14
				Time limit = 1 sec
			Output Format:
				The first and only line of output must contain the length of the correct password
				and its central letter. The solution will be unique.
			
			Sample Input 1:
				4
				las
				god
				psala
				sal 
			Sample Output 1:
				3 a
			Sample Input 2:
				4
				kisik
				ptq
				tttrp
				tulipan 
			Sample Output 2:
				5 s
			Explanation:
				For testcase 1:
				The required pair of words is “las” and “sal”. Their length is 3 letters and the central character is 'a'.

				For testcase 2:
				The word “kisik” can be found in both the original and reverse order on the list (the word is a palindrome), so it is a valid correct password. 

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			int n;
			cin>>n;

			vector<string> s(n);
			for(int i=0; i<n; i++){
				string temp;
				cin>>temp;
				s[i] = temp;
			}
			int len=0,flg=0;
			char midL;
			for(int i=0; i<n; i++){
				string f1 = s[i];
				reverse(f1.begin(), f1.end());

				for(int j=0; j<n; j++){
					if(f1 == s[j]){

						len = f1.length();
						midL = f1[len/2];
						flg = 1;
						break;
					}
				}
				if(flg)
					break;
			}

			cout<<len<<" "<<midL;
			return 0;
		}

	75) Self Dividing Numbers:
		A Ninja wants to collect all possible self-dividing numbers from a given range of numbers.
			A self-dividing number is a number that is divisible by every digit it contains.
			For Example:
				128 is a self-dividing number because
				128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
			Given a ‘LOWER’ and ‘UPPER’ number bound, your
			task is to find all possible self-diving numbers in
			the range of ‘LOWER’ to ‘UPPER’.
			Note:
				A self-dividing number is not allowed to contain the digit zero.
				You do not need to print anything, it has already been taken care of. Just
				implement the given function.
			Sample Input 1:
				2
				10 30
				15 45
				Sample Output 1:
				11 12 15 22 24
				15 22 24 33 36 44
				Explanation For Sample Input 1:
				Test Case 1:

				For the first test case, the output [11, 12, 15, 22, 24] is the required list of self-dividing numbers containing only those numbers that have all the digits that can divide the number and do not contain the digit ‘0’ in it.

				Test Case 2:

				For the first test case, The output [15, 22, 24, 33, 36, 44] is the required list of self-dividing numbers containing only those set of numbers that have all the digits which can divide the number and that do not contain the digit ‘0’ in it.
			Sample Input 2:
				2
				1 22
				100 150
				Sample Output 2:
				1 2 3 4 5 6 7 8 9 11 12 15 22
				111 112 115 122 124 126 128 132 135 144

		#include <bits/stdc++.h> 
		vector < int > findAllSelfDividingNumbers(int lower, int upper) {

			//vector for storing the ans
			vector<int> ans;

			for(int i=lower; i<= upper; i++){
				int currentDigitHolder = i;
				int currentDigit = i;
				while(currentDigit>0){
					int lastDigit = currentDigit % 10;
					if(lastDigit == 0 || (currentDigitHolder % lastDigit != 0))
						break;
					currentDigit /=10;
				}
				if(currentDigit == 0)
					ans.push_back(i);
			}
			return ans;
		}

	76) Rearrange in Zig-Zag Order:
		https://www.codingninjas.com/studio/problems/zig-zag-array_1698577
		-just returned the empty vector (GLITCHED QUESTION).
		#include <bits/stdc++.h> 
		vector<int> zigZag(vector<int> arr, int n){
			vector<int> ans;
			return ans;
		}

	77) Fourth Largest Element in the Array:
		You are given an array consisting of 'N' integers. You have to find the fourth
			largest element present in the array. If there is no such number present in the
			array, then print the minimum value of an integer which is -2147483648.
			Follow Up: 
				Constraints :
				1 <= N < 10^6
				-10^6 <= element <= 10^6
			Time Limit: 1 sec
			Sample Input 1:
				5
				3 5 1 3 1
				Sample Output 1:
				1
				Explanation Of Sample Input 1:
				5 is the largest element, 3 is the second-largest element, again we have a 3 so it's the third largest and 1 is the fourth-largest, hence the answer 1.
				Sample Input 2:
				4
				9 9 9 9
				Sample Output 2:
				9
		//not optimized:
			#include <bits/stdc++.h>
			int getFourthLargest(int arr[], int n){
				if(n<4)
					return -2147483648;

				vector<int> ans(n);

				for(int i=0; i<n;i++){
					ans.push_back(arr[i]);
				}

				sort(ans.begin(), ans.end());
				reverse(ans.begin(), ans.end());
				return ans[3];
			}

	78) Next Smaller Element / Nearest Smaller Element:
		https://www.codingninjas.com/studio/problems/next-smaller-element_1112581

		//NOT Optimized:
			#include <bits/stdc++.h>
			vector<int> nextSmallerElement(vector<int> &arr, int n){
				int i=0;
				vector<int> ans;
				while(i<n){
					int currentNum = arr[i];
					int currentIndex = i+1;

					while(currentIndex < n){
						if(currentNum > arr[currentIndex]){
							ans.push_back(arr[currentIndex]);
							break;
						}
						currentIndex++;
					}
					if(currentIndex == n)
						ans.push_back(-1);
					i++;
				}
				return ans;
			}
		
		// Optimized:
			#include <bits/stdc++.h>
			vector<int> nextSmallerElement(vector<int> &arr, int n){
				vector<int> ans(n, -1);  // Initialize the result vector with -1.
				stack<int> st;  // Create a stack to keep track of indices.

				for (int i = 0; i < n; i++) {
					while (!st.empty() && arr[i] < arr[st.top()]) {
						ans[st.top()] = arr[i];  // Update the result for elements in the stack.
						st.pop();
					}
					st.push(i);  // Push the current index onto the stack.
				}
				return ans;   
			}

		#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				int n;
				cin>>n;
				vector<int> holder(n);
				
				for(int i=0;i<n;i++){
					cin>>holder[i];
				}
				
				for(int a: holder)
					cout<<a<<" ";
					
				std::cout << std::endl;
				
				vector<int> MainAns(n);
				
				for(int i=n-1;i>=0;i--){
					int currentElement = holder[i];
					int index = i-1;
					
					while(index>=0){
						if(currentElement > holder[index]){
							MainAns.push_back(holder[index]);
							break;
						}
						index--;
					}
					if(index<0)
						MainAns.push_back(-1);
				}
				
				std::cout << std::endl;
				reverse(MainAns.begin(), MainAns.end());
				for(int i=0; i<n; i++)
					cout<<MainAns[i]<<" ";
				
				return 0;
			}
			ouput:
			5
			11
			4
			24
			32
			32
			11 4 24 32 32 

			-1 -1 4 24 24 

	79) Added Character:
		You are given a string 'S'. Now one more additional character is introduced in this string, which turns 'S'
			into new string 'T'. You have to find out this newly added character.
			Note:
			1. All the characters in string 'S' and 'T' consist of uppercase English
			alphabets.
			2. Length of string 'T' is always 1 more than the length of string 'S'.
			Constraints:
				1 <= TEST <= 100
				1 <= |S|, |T| <= 10^4
				Where '|S|' and '|T|' denotes the length
				of he strings 'S' and 'T' respectively.
			Time Limit: 1 sec.

			Sample Input 1:
				2
				APPLE 
				APPHLE
				CODE
				CODER
				Sample Output 1:
				H
				R
				Explanation For Sample Output 1:
				In test case 1, As only character which is present in “APPHLE” but didn’t present in “APPLE” is ‘H’.

				In test case 2, As only character which is present in “CODER” but didn’t present in “CODE" is ‘R’.
				Sample Input 2:
				2
				MANGO 
				MANNGO
				NINJA
				NIINJA
				Sample Output 2:
				N
				I
				Explanation For Sample Output 2:
				In test case 1, As “MANGO” contains only 1 occurrence of ‘N’ but “MANNGO” contains 2 occurrences of ‘N’.

				In test case 2, As “NINJA” contains only 1 occurrence of ‘I’ but “NIINJA" contains 2 occurrences of ‘I’.

		#include <bits/stdc++.h> 
		char findAddedCharacter(string &s, string &t) {
			int i=0;
			while(i<s.length()){
				if(s[i] != t[i])
					return t[i];
				i++;
			}
			if(i==s.length())
				return t[t.length()-1];
		}
	
	80) Three Pointer:
		You are given three arrays X, Y and Z of size A,B and C
			respectively.Also, all three arrays are sorted in nondecreasing order. Find i, j, k such that : 0 <= i < A, 0 <=
			j < B, 0 <= k < C and max(abs(X[i] - Y[j]), abs(Y[j] - Z[k]), abs(Z[k] - X[i])) is minimized. 
			Your task is to return the minimum of all the max(abs(X[i] - Y[j]), abs(Y[j] - Z[k]), abs(Z[k] - X[i]))
			Note:
				1. All the arrays are sorted in nondecreasing order.
				2. abs(x) denotes the absolute value of x, i.e. if x<0, the abs function returns (-x)
					so that the final value of x becomes positive.
			Constraints:
				1 <= T <= 100
				1 <= A,B,C <= 10^4
				1 <= X[i] <= 10^4
				1 <= Y[i] <= 10^4
				1 <= Z[i] <= 10^4
				Time Limit: 1 sec
			
			Sample Input 1:
				1
					5
					1 2 3 4 5
					5
					1 3 5 7 9
					3
					2 4 6
					Sample Output 1:
					1 
					Explanation For Sample Input 1:
					For firstestcase :
					One of the possible answer is choose i = 0, j = 0 and k = 1.
					Thus it will 1 answer.
					Sample Input 2:
					1
					4
					1 1 1 1
					4
					2 2 2 2
					5
					7 7 7 7 7
					Sample Output 2:
					6

		//NOT Optimized:
			#include <bits/stdc++.h> 
			int threePointer(vector<int>& X, vector<int>& Y, vector<int>& Z){   
				int i,j,k,currentMax = INT_MAX;
				for(i=0;i<X.size(); i++){
					for(j=0; j<Y.size(); j++){
						for(k=0; k<Z.size();k++){
							int temp = max(abs(X[i]-Y[j]), max(abs(Y[j]-Z[k]), abs(Z[k]-X[i])));
							if(temp < currentMax)
								currentMax=temp;
						}
					}
				}
				return currentMax;
			}
		
		// Partially Optimized:
			#include <bits/stdc++.h> 
			int threePointer(vector<int>& X, vector<int>& Y, vector<int>& Z){	
				std::sort(X.begin(), X.end());
				std::sort(Y.begin(), Y.end());
				std::sort(Z.begin(), Z.end());

				int i = 0, j = 0, k = 0;
				int currentMax = INT_MAX;

				while (i < X.size() && j < Y.size() && k < Z.size()) {
					int maxX = X[i], maxY = Y[j], maxZ = Z[k];
					int minX = X[i], minY = Y[j], minZ = Z[k];

					int temp = std::max({abs(maxX - minY), abs(maxY - maxZ), abs(maxZ - minX)});
					currentMax = std::min(currentMax, temp);

					// Move the pointer associated with the minimum value
					if (X[i] <= Y[j] && X[i] <= Z[k]) {
						i++;
					} else if (Y[j] <= X[i] && Y[j] <= Z[k]) {
						j++;
					} else {
						k++;
					}
				}
				return currentMax;
			}

	81) Row Wave Form:
		Problem Statement
			You are given a 2D array with dimensions "N*M'. You need to read the array elements
			row-wise and return a linear array that stores the elements like a wave ie the 1st-
			row elements are stored from left to right, 2nd-row elements are stored from right to
			left, and so on.
			Constraints:
				1 <= (T' <= 10
				1 <= 'N', 'M' <= 10^3
				1 <= 'ARR[i][g] <= 10^5
			Where ARR[i][j] is the array element in the ith row of the jth column.
				Time limit: 1 second
			Sample Input 1:
				2
				2 2 
				1 2
				0 5
				2 3
				5 1 2
				7 0 1
			Sample Output 1:
				1 2 5 0
				5 1 2 1 0 7
				Explanation Of Input 1:
				For test case 1, the array is traversed as:
				The first row is traversed from left to right. -> [1, 2]
				The second row is traversed from right to left. -> [5, 0]
				Therefore the final answer is [1, 2, 5, 0].

				For test case 2, the array is traversed as:
				First row is traversed from left to right. -> [5, 1, 2]
				Second row is traversed from right to left. -> [1, 0, 7]
				Therefore the final answer is [5, 1, 2, 1, 0, 7]
			Sample Input 2:
				1
				3 3
				0 1 1
				8 0 9
				5 4 1
			Sample Output 2
				0 1 1 9 0 8 5 4 1
				Explanation Of Input 1:
				For test case 1, the array is traversed as:
				The first row is traversed from left to right. -> [0, 1, 1]
				The second row is traversed from right to left. -> [9, 0, 8]
				The third row is traversed from left to right -> [5, 4, 1]
				Therefore the final answer is [0, 1, 1, 9, 0, 8, 5, 4, 1]
		#include <bits/stdc++.h> 
		vector<int> rowWaveForm(vector<vector<int>> &mat) {
			vector<int> ans;
			for(int i=0; i<mat.size(); i++){
				int j;
				if(i&1){
					j=mat[0].size()-1;
					for(;j>=0;j--)
						ans.push_back(mat[i][j]);
				}else{            
					j=0;
					for(;j<mat[0].size();j++)
						ans.push_back(mat[i][j]);
				}
			}
			return ans;
		}

	82) Move Zeroes To End:
		Problem Statement
			Given an unsorted array of integers, you have to move the array elements in a way
			such that all the zeroes are transferred to the end, and all the non-zero elements are
			moved to the front. The non-zero elements must be ordered in their order of
			appearance.
			For example, if the input array is: [0, 1, -2, 3, 4, 0, 5, -27, 9, 0], then the output array
			must be:
			[1, -2, 3, 4, 5, -27, 9, 0, 0, 0].
			Expected Complexity: Try doing it in O(n) time complexity and O(1) space complexity.
			Here, 'n' is the size of the array.
			Sample Input 1:
				2
				7
				2 0 4 1 3 0 28
				5
				0 0 0 0 1
			Sample Output 1:
				2 4 1 3 28 0 0
				1 0 0 0 0
			The Explanation For Sample Output 1 :
				-In the first testcase, All the zeros are moved towards the end of the array, 
				and the non-zero elements are pushed towards the left, maintaining their order with respect to the original array.
				-In the second testcase, All zero are moved towards the end, 
				hence the only non-zero element i.e 1 is in the starting of the array 
			Sample Input 2:
				2
				5
				0 3 0 2 0
				4
				0 0 0 0
			Sample Output 2:
				3 2 0 0 0
				0 0 0 0

		void pushZerosAtEnd(vector<int> &arr) {
			int cnt=0;
			vector<int> ans;
			for(int i=0; i<arr.size() ; i++)
				if(arr[i] != 0)
					ans.push_back(arr[i]);
				else
					cnt++;
			
			for(int i=0; i<cnt; i++)
				ans.push_back(0);
			
			arr = ans;
		}

		//or in-place optimization:
			void pushZerosAtEnd(vector<int> &arr) {
				int nonZeroPos = 0;  // Initialize a pointer to track the position for non-zero elements

				for (int i = 0; i < arr.size(); i++)
					if (arr[i] != 0) {
						// Swap the current element with the element at nonZeroPos
						swap(arr[i], arr[nonZeroPos]);
						nonZeroPos++;
					}
			}

	83) Minimum and Maximum Cost to buy N Candies:
		Problem Statement
			Ram went to a specialty candy store in Ninjaland which has 'N' candies with different costs.
			The Candy shop gives a special offer to its customers. A customer can buy a single candy from
			the store and get at most 'K' different candies for free. Now, Ram is interested in knowing the
			maximum and the minimum amount he needs to spend for buying all the candies available in
			the store.
			Note: In both cases, Ram must utilize the offer i.e. if 'K' or more candies are available, he must
			take 'K' candies for every candy purchase. If less than K candies are available, he must take all
			candies for a candy purchase.
			For Example
				For 'N'= 5 and 'K' = 2
				Let the cost of different candies in the store be: [9 8 2 6 4]
				For the minimum amount:
				Ram can buy a candy with cost 2 and take candies with costs 9 and 8 for free.
				Then, he can buy a candy with cost 4 and take candy with cost 7 for free.
				Thus, the minimum cost will be 6 i.e. 2 + 4.
				For the maximum amount:
				Ram can buy a candy with cost 9 and take candies with costs 2 and 6 for free.
				Then, he can buy candy at cost 8 and take candy at cost 4 for free.
				Thus, the minimum cost will be 17 i.e. 9 + 8.
			Thus, Minimum = 6 and Maximum = 17.
			Sample Input 1:
				1
				4 2
				3 2 1 4
				Sample Output 1 :
				3 7
				Explanation :
				For the minimum amount: 
				Ram can buy candy with cost 1 and take candies with costs 3 and 4 for free. 
				Then, he can buy candy with cost 2.
				Thus, the minimum cost will be 3 i.e. 1 + 2. 

				For the maximum amount: 
				Ram can buy candy with cost 4 and take candies with costs 1 and 2 for free. 
				Then, he can buy candy with cost 3. 
				Thus, the minimum cost will be 7 i.e. 4 + 3.
			Sample Input 2:
				2
				5 2
				9 8 2 6 4
				3 0
				1 5 4
				Sample Output 2 :
				6 17
				10 10

		#include <bits/stdc++.h>
		long long minimumCost(vector<int> &cost, int n, int k){
			long long sum=0;
			// if(k==0){
			//     for(int i=0; i<n;i++)			//we can ignore these lines of code
			//         sum += cost[i];
			//     return sum;
			// }

			sort(cost.begin(), cost.end());
			int cnt=0, i=0;
			while(cnt<n){
				cnt += k+1;
				sum += cost[i++];
			}
			return sum;
		}

		// Function to calculate maximum cost.
		long long maximumCost(vector<int> &cost, int n, int k){
			long long sum=0;

			// if(k==0){
			//     for(int i=0; i<n;i++)			//we can ignore these lines of code
			//         sum += cost[i];
			//     return sum;
			// }

			sort(cost.begin(), cost.end());  //increasing order sorted
			reverse(cost.begin(), cost.end());  //decreasing order sorted
			int cnt=0, i=0;
			while(cnt<n){
				cnt += k+1;
				sum += cost[i++];
			}
			return sum;
		}

	84) Number of Good Indices:
		Problem statement:
			You are given an array 'A' of length 'N' consisting of positive integers. 
			Your task is to tell the number of 'good indices' in the array 'A'.
			An index 'X' is called a 'good index' if and only if:
			There are at least 2 indices 'i != X' and 'j != X', such that 'A[X] % A[i] = 0' and 'A[X] % A[j] = 0'.
			Your task is to return the number of 'good indices'.
			Example:
				'N' = 5
				'A' - [4, 2, 2, 6, 7]
				Here, index '9' is a good index because its value '4' is divisible by values
				present at the indices *1' and '2'. Similarly, index '3' is a good index.
				Therefore, the answer is '2
			Sample Input 1:
				2
				6
				4 8 6 3 7 1
				6
				4 1 10 4 5 9
				Sample Output 1:
				2
				3
				Explanation Of Sample Input 1:
				For test case 1:
				The good indices are '1' and '2' because, for index '1', there are two indices whose value perfectly divides the value present at the index '1', i.e., index '0' and index '5'. Similarly, for index '2', the two indices are '3' and '5'.

				For test case 2:
				The good indices are '0', '2' and '3'. For index '0', the two indices are '1' and '3', whose value at those indices in the array perfectly divides the array. Similar is the case for index '2' and '3'.
				Sample Input 2:
				2
				6
				3 10 7 4 2 10
				6
				4 5 4 8 1 4
				Sample Output 2 :
				2
				4
		
		int numberOfGoodIndices(int n, vector<int>& a) {
			int MainCNT=0;
			for(int i=0; i<n; i++){
				int currentNum= a[i],cnt=0;
				for(int j=0; j<n; j++){
					if(i==j)
						continue;
					if(currentNum%a[j] == 0)
						cnt++;
					if(cnt>=2){
						MainCNT++;
						break;
					}
				}
			}
			return MainCNT;
		}

	85) Find First and Last Position of Element in Sorted Array:
		https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
		Given an array of integers nums sorted in non-decreasing order, 
		     find the starting and ending position of a given target value.
			If target is not found in the array, return [-1, -1].
			You must write an algorithm with O(log n) runtime complexity.

			Example 1:
				Input: nums = [5,7,7,8,8,10], target = 8
				Output: [3,4]
			Example 2:
				Input: nums = [5,7,7,8,8,10], target = 6
				Output: [-1,-1]
			Example 3:
				Input: nums = [], target = 0
				Output: [-1,-1]
			Constraints:
				0 <= nums.length <= 105
				-109 <= nums[i] <= 109
				nums is a non-decreasing array.
				-109 <= target <= 109
		//Brute Force Tech, Optimized.
			class Solution {
				public:
				vector<int> searchRange(vector<int>& nums, int target) {
					vector<int> ans;
					//traversing from start
					for(int i=0; i<nums.size(); i++){
						if(nums[i] == target){
							ans.push_back(i);
							break;
						}
					}
				
					if(ans.size()==0)
						ans = {-1,-1};

					/* or
						if(ans.size()==0){
							ans = {-1,-1};
							return ans;
						}

						if(ans.size()==0)
							return {-1,-1};					
					*/
				
					//traversing from end
					for(int i=nums.size()-1; i>=0; i--){
						if(nums[i] == target){
							ans.push_back(i);
							break;
						}
					}
					return ans;
				}
			};
		
		//Binary Search Tech. Optimized
			class Solution {
				public:
				vector<int> searchRange(vector<int>& nums, int target) {
					int start=0,end=nums.size()-1;
					int mid = (start+end)/2;
					int found;
					while(start<=end){
						if(nums[mid] == target){
							found = mid;
							break;
						}else if(target<nums[mid]){
							end = mid-1;
						}else{
							start = mid+1;
						}
						mid = (start+end)/2;
					}

					if(start>end)
						return {-1,-1};

					int left = found, right = found;
					leftCheck:
					if(left>0 && nums[left] == nums[left-1]){
						left--;
						goto leftCheck;
					}

					rightCheck:
					if(right<nums.size()-1 && nums[right] == nums[right+1]){
						right++;
						goto rightCheck;
					}
					return {left, right};
				}
			};

	86) 

	87)

	88)

	89)

	90)
POTD-END
---------------------------------------------------------------------------------------------------------
calender:
	today 2nd sept 2023 (saturday)
	what is day on 30th may 2023?
	->
		how many days between dates = may +june + july +august+ sept
						 1 + 30d + 31d + 31d + 2  = 95
						 =95/7 -> 4 remainder,
						 4 days back from today (fri, thurs, wed, tuesday)
						 => Tuesday is on 30th of may.
--------------------------------------------------------------------------------------------------------
	#include <bits/stdc++.h>
		using namespace std;
		#define setSize 32
		int main() {
		bitset<setSize> bset1; // value is 00000000000000000000000000000000
		bitset<setSize> bset2(20); //value is 00000000000000000000000000010100
		bitset<setSize> bset3(string("1100")); // value is 00000000000000000000000000001100
		cout<<"The values of bitsets are :
		" ;
		cout<<"bitset 1 : "<<bset1<<endl;
		cout<<"bitset 2 : "<<bset2<<endl;
		cout<<"bitset 3 : "<<bset3<<endl;
		cout << endl;
		bitset<8> bset4; // value is 00000000
		bset4[1] = 1;
		cout<<"value after changing a bit :"<<bset4<<endl;
		bset4[4] = bset4[1];
		cout <<"changing value using other method :"<<bset4<<endl;
		int numberofone = bset4.count();
		int numberofzero = bset4.size() - numberofone;
		cout<<"The set"<<bset4<<"has"<<numberofone<<"ones and"<<numberofzero<<"zeros
		";
		cout << "bool representation of " << bset4 << " : ";
		for (int i = 0; i < bset4.size(); i++)
			cout << bset4.test(i) << " ";
		cout << endl;
		if (!bset1.none())
			cout << "bset1 has some bit set
		";
			cout <<".set() method sets all bits, bset4.set() = "<< bset4.set() << endl;
			cout<<"changing a specific bit(4) to 0 "<<bset4.set(4, 0)<<endl;
			cout<<"changing a specific bit(4) to 1 "<<bset4.set(4)<<endl;
			cout<<"Resetting bit at position 2 :"<<bset4.reset(2)<<endl;
			cout<<"Resetting bits of full bitset : "<<bset4.reset()<<endl;
			cout<<"Flipping bit at position 2 : "<< bset4.flip(2) << endl;
			cout<<"Flipping bit of array : "<<bset4.flip() << endl;
			int num = 100;
			cout << "
		Decimal number: " << num << " Binary equivalent: " << bitset<8>(num);
		return 0;
		}

	The bitset all() function an inbuilt function of the C++ STL( Standard Template Library).
		This function returns a Boolean value. The returned value is true if all the bits of the 
		calling bitset are 1 else it will return false.

		The function does not accept any parameter and returns a Boolean value.

		Syntax
		Bool bitset_name .all()
		Sample
		Bitset = 100101
		Output
		false
		Because all bits of the set need to be true in order to return a true value.

		Example
		#include <bits/stdc++.h>
		using namespace std;
		void printer(bool val){
		if(val){
			cout<< "The bitset has all bits set"<< endl;
		} else{
			cout << "The bitset does not have all bits set"<< endl;
		}
		}
		int main() {
		bitset<4> bit1(string("1011"));
		bitset<6> bit2(string("111111"));
		cout<<"The bitset is "<<bit1<<endl;
		printer(bit1.all());
		cout<<"The bitset is "<<bit2<<endl;
		printer(bit2.all());
		return 0;
		}

	The bitset flip() method is an inbuilt method of C++ STL( Standard Template Library). 
		It flips the bits of the calling bitset. This method flips all 0’s to 1’s 
		and all 1’s to 0’s, which means it reverse each and every bit of the calling bitset when no parameter is passed.

		If a parameter is passed the flip method will flip only the nth bit for the integer n passed. 
		For example, if 5 is passed then the flip method will flip 5th bit of of the calling bitset.

		Syntax
		bitset_name.flip(int pos)
		Sample

		Initial bitset: 011001
		After applying the bits flip function with no parameter: 100110

		After applying the Beta function with 6: 011000

		Example
		#include <bits/stdc++.h>
		using namespace std;
		int main() {
		bitset<6> bit1(string("100110"));
		bitset<10> bit2(string("0100001111"));
		cout << bit1 << " after applying flip() function with nothing passed as parameter returns "
		<< bit1.flip() << endl;
		cout << bit2 << " after applying flip() function with 7 passed as parameter returns "
		<< bit2.flip(7);
		return 0;
		}

	#include <iostream>
		#include<algorithm>
		#include<bitset>

		using namespace std;
		int main(){
		
		int n=8;
		string s = bitset<8> (n).to_string('V','S');
		
		int num =15;
		bitset<32> numBit(num);
		
		std::cout << s << std::endl;
		std::cout << "Size of bitset n is :: "<< bitset<8>(n).size() << std::endl;
		
		std::cout << "Set bits in numBit "<< numBit.count() << std::endl;
		std::cout << "no.of zeros in numBit "<< numBit.size() - numBit.count() << std::endl;
		
		std::cout << "flipping the bits of numBit \nBefore: "<< numBit << "\nAfter : "<< numBit.flip() << std::endl;
		std::cout << "Flipping 5th bit of numBit (0-indexed) from last : "<< numBit.flip(5) << std::endl;
		std::cout <<  bitset<8>(n).flip(2) << std::endl;
		return 0;
		}

	#include <iostream>
	#include<bitset>
	using namespace std;

	int main()
	{
	int arr[] = {1,2,3,4,5,6,7,8,9,10,100000};
	long long arr2[10];
	
	//printing binary for all,
	for(int i=0;i<11;i++){
		string s = bitset<32> (arr[i]).to_string();
		long long j = 0;
	
		// Traversing string
		for (char c : s) {
			// Checking if the element is number
			if (c >= '0' && c <= '9') 
				j = j * 10 + (c - '0');
		}
		cout<<j<<endl;
		arr2[i] = j; 
		std::cout << s << std::endl;
	}
	
	std::cout << "Second array" << std::endl;
	for(int i=0;i<11;i++)
		std::cout << arr2[i] << std::endl;
	return 0;
	}
--------------------------------------------------------------------------------------------------------
