-When you start reading/ revising notes, read problem statement properly & think logical,
 if you don't understand the program, Google the question.
-----------------------------------------------------------------------------------------------------------
	01/08/2023
Lecture-1: Intro to Programming & Flowcharts
     -Understand the problem
     -check given data
     -search approach (make flowchart)
     -start programming

     -Flowchart:
          Diagrammatic representation of an approach
          Components:
               1.Terminator: start/end
               2.Parallelogram block   : represent IO/OP 
               3.Rectangular block: represent process
               4.Diamond: decision making (condition)
          e.g., Sum of 2 num:
	-Pseudocode:	Generic way of representing look of code.
	-Flowchart for Simple Interest
		SI = (P*R*T)/100
		eg.
			Calculate Simple Interest
				#include <bits/stdc++.h> 
				#include <iostream>
				using namespace std;

				int main(){
					float pr,time, RI;
					cin>>pr>>RI>>time;
					float ans;
					ans =(int) (pr*time*RI)/100;
					cout<<ans;
					return 0;
				}

	-Two colons (::) are used in C++ as a scope resolution operator

	-Flowchart for average of 3 num
		avg = (a+b+c)/3;

	-Greater between 2 num:
		a>b? print(a greater) : print(b greater);

		//Largest of 3 numbers
			#include <bits/stdc++.h> 
			#include <iostream>
			using namespace std;

			int main() {
				int a,b,c;
				cin>>a>>b>>c;
				cout<<max(a,max(b,c));
				return 0;
			}

	-Odd or even num:
		(num %2 ==0) ? print(even):print(odd)

	-num is +ve or -ve or zero?
		If(num >0) print(+ve)
		else if (num<0) print(-ve)
		else print(zero)
		
	-Valid triangle or not?
		Angles A, B & C
		A+B > C
		B+C > A
		C+A > B

	-Loops:
		-Print 1 to 5 nums.

		-print even nums from given range (copy paste program directly on compiler to check)

			#include <iostream>
			using namespace std;
			int main() {
				// Write C++ code here
				cout << "Range..!"<<"\n";
				int s=1,e=10,i;
				for(i=s; i<=e; i++){	
					cout<<i<<"\t";
				}
				cout<<"\neven nums.."<<"\n";
				for(i=s;i<e;i++){
					if(i%2==0){
						cout<<i<<endl;
					}else{
						continue;
					}
				}
				cout<<"\nend";
				return 0;
			}

		-Sum of 1 to N nums:
			#include <iostream>
			using namespace std;

			int main() {
				// Write C++ code here
				cout<<"Enter n::";
				int n;
				cin>>n;
				int sum = 0;
				
				// sum = n*(n+1)/2;
				//or
				for(int i=1;i<=n;i++){
					sum = sum +i;
				}
				cout<<"The sum of first "<<n<<" numbers ::"<<sum;
				cout<<"\nend";

				return 0;
			}

		-Factorial:
			#include <iostream>			//using namespace std not used here.
			int main() {
				std::cout<<"Enter n::";
				int n,fact=1;
				std::cin>>n;
				
				for(int i=1;i<=n;i++){
					fact = fact * i;
				}
				std::cout<<"The factorial of "<<n<<" is ::"<<fact;
				std::cout<<"\nend";

				return 0;
			}

				//or
					#include <iostream>
					using namespace std;

					int main() {
						int n;
						cin>>n;
						int fact=1;
						if (n == 0) {
							cout << 1;
							return 0;
						}else if (n<0){
							cout<<"Error";
							return 0;
						}else{
							while(n>0){
								fact = fact * n;
								n--;
							}
						}

						cout<<fact;
						return 0;
					}

		-Prime num:
			#include <iostream>
			int main() {
				// Write C++ code here
				std::cout<<"Enter n to check prime or not::";
				int n;
				std::cin>>n;
				bool flag = true;
				
				if(n == 1){
					std::cout<<"1 is neither prime nor composite";
					return 0;
				}
				
				for(int i=2;i<n;i++){
					if(n % i ==0){
						flag = false;
						break;
					}else{
						flag = true;
					}
				}
				
				if(flag){
					std::cout<<n<<" is Prime num.";
				}else{
					std::cout<<n<<" is not Prime num.";
				}
				
				std::cout<<"\nend";
				return 0;
			}
		
	-Compiler: convert High Level Language to Binary Language (machine understandable)
---------------------------------------------------------------------------------------------------------
	02/08/2023
Lecture-2: Write Your First Program in C++
	Compiler:
		-convert program to machine understandable Language ( Binary ).
		-checks the error & let you know.
	
	IDE: Integrated Development Environment
	
	-Program always start from main function.
	eg.
		#include <iostream>
		int main() {
			std::cout << "Hello world!"<<endl;
			return 0;
		}

		//if you used this statement no need to mention std in program
		using namespace std;
		#include <iostream>
		int main() {
			cout << "Hello world!";
			return 0;
		}

		where,
			std 			- is a namespace.
			cout 		- is function for printing
			<< 			- is outputing a output.
			endl  or '\n' 	- end line/ new line.
			; 			- represent end line.

	-Datatype & Variables:
		1 Byte is 8 bit.
		4bit is 1 nibble.
		int-
			size is 4 byte(32bit) generally (sometimes 2 bytes also, depends on compiler).
			Stores whole numbers, without decimals
			eg.
				int a = 20;

			min size -2³¹
			max size 2³¹-1
		
		char-
			size is 1 byte
			Stores a single character/letter/number, or ASCII values
			eg.
				char ch = 'a';		//valid

				char ch = 'ab';	//invalid
			
			Alternatively, you can use ASCII values to display certain characters:
			eg.
				char a = 65, b = 66, c = 67;
				cout << a;		//A
				cout << b;		//B
				cout << c;		//C

			-ASCII values:	ASCII - 'American Standard Code for Information Interchange'
				32 		is value of space.
				48 to 57 	is for 	0 to 9.
				65 to 90 	is for 	A to Z.
				97 to 122 is for 	a to z.

		boolean-
			1 byte	
			Stores true or false values
			you can keep any value for this boolean if it is non-zero(+ve) or -ve  then its considered as true (1).
				if it is zero then its considered as false(0).
			eg.
				bool a = true;

				bool b = 1,c =true, d = false;
				cout <<b<<endl;         //1
				cout <<c<<endl;         //1
				cout <<d<<endl;         //0
	
		float-
			4 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 6-7 decimal digits.
			eg.
				float f1 = 35e3;
				double d1 = 12E4;
				float ff = 35.453f;				//f to represent its is a floating point num.
				double dd = 12.78909d;			//d to represent its is a double
				cout << f1 << "\n";				// 35000
				cout << d1;					// 120000
		
		double-
			8 bytes	
			Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits.
		
		NOTE:
			float vs. double
			The precision of a floating point value indicates how many digits the value can have after the decimal point. 
			The precision of float is only six or seven decimal digits, while double variables have a precision of about 15 digits. 
			Therefore it is safer to use double for most calculations.
		
		string-
			32 byte.
			string type is used to store a sequence of characters (text).
			This is not a built-in type, but it behaves like one in its most basic usage. 
			String values must be surrounded by double quotes:
			eg.
				#include <string>				//including this header file is not mandatory.
				string str  = "Vivek";
				cout << str;
			
			-Different ways to initialize string in cpp:
				   char str1[10] = "Freshers";

				#include <iostream>
				using namespace std;

				int main() {
					char str1[10] = "Freshers";
					std::cout << str1 << std::endl;
					
					char str2[6] = "Geeks";
					std::cout << str2 << std::endl;
					
					char str3[] = {'G', 'e', 'e', 'k', 's', '\0'};
					std::cout << str3 << std::endl;
					
					char str4[6] = {'G', 'e', 'e', 'k', 's', '\0'};
					std::cout << str4 << std::endl;
					
					
					string str5 = "Welcome to GeeksforGeeks!"; 
					std::cout << str5 << std::endl;
					
					// Initialization by raw string 
					string str6("A Computer Science Portal"); 
					std::cout << str6 << std::endl;
					
					//char to to string
					char ch = 'Z';
					std::cout << ch << std::endl;
					
					ch='A';
					string temp = str6 + ch;
					std::cout << temp << std::endl;
					
					ch++;
					temp = ch+str6;
					std::cout << temp << std::endl;
					
					std::cout << string(5,ch) << std::endl;
					
					std::cout << str5.front() << std::endl;
					std::cout << str5.back() << std::endl;
					return 0;
				}

				//or

					#include <iostream>
					using namespace std;

					int main() {
						string s1("qwerqty");
						string s2 ("asdf");
						string s3 = "vivek";
						string s4 = {"one two"};
						
						std::cout << s1 << std::endl;       //qwerqty
						std::cout << s2 << std::endl;       //asdf
						std::cout << s3 << std::endl;       //vivek
						std::cout << s4 << std::endl;       //one two
						return 0;
					}

		Variable Naming Convention:
			int abc1 = 1;			//valid
			int _abc = 21;			//valid
			int 1abc = -10; 		//invalid because the first character letter/underscore not number

		sizeof:
			eg.
				#include <iostream>

				int main() {
					bool c  = -12;
					int i   = 10;
					char ch = 'A';
					float f =  11.12; 
					double d   = 12.1245d;
					std::string str = "Vivek ";
					
					std::cout<<"The size of "<<c<<" Boolean :: "<<sizeof(c)<<" Byte\n";
					std::cout<<"The size of "<<i<<" integer :: "<<sizeof(i)<<" Byte\n";
					std::cout<<"The size of "<<ch<<" char :: "<<sizeof(ch)<<" Byte\n";
					std::cout<<"The size of "<<f<<" float :: "<<sizeof(f)<<" Byte\n";
					std::cout<<"The size of "<<d<<" double :: "<<sizeof(d)<<" Byte\n";
					std::cout<<"The size of "<<str<<" string :: "<<sizeof(str)<<" Byte\n";
					
					return 0;
				}

				//output
					The size of 1 Boolean :: 1 Byte
					The size of 10 integer :: 4 Byte
					The size of A char :: 1 Byte
					The size of 11.12 float :: 4 Byte
					The size of 12.1245 double :: 8 Byte
					The size of Vivek  string :: 32 Byte

		storing process:
			int is 4 bytes ie. 32 bits.
				4 blocks of bits are made
				eg.
					[-------- -------- -------- --------] this how integer converted to binary & store data in bits format.

		TypeCasting:
			when you assign a value of one primitive data type to another type.
			eg.
				int a = 'a';
				cout<<a;

				char ch = 98;
				cout<<ch;

				-int is 4 byte & char is 1 byte, if we try to store big integer to char
				 warning will be thrown & last 1 byte of data will be store in char.
				 eg.
				 	char ch = 123456		//binary of 123456 = 11110001001000000
					cout<< ch;			//@

					but char is of size 1 byte ie. 8 bits, so last 8 bit of binary 123456 will extracted ie.01000000 
						& rest all bits will be lost
					& if we print the ch then output will be @.
					coz this binary 01000000 is 64 in decimal.
					& 64 is mapped with @ char.
			
			eg.
				#Converting strings to numerical types
					C++ provides several functions for converting strings to numerical types, 
					each with different ranges and precision. Here are some commonly used ones:

						std::stoi (String to Integer):
							Converts a string to an int.
							Usage: int result = std::stoi(str);

						std::stol (String to Long):
							Converts a string to a long.
							Usage: long result = std::stol(str);

						std::stoll (String to Long Long):
							Converts a string to a long long.
							Usage: long long result = std::stoll(str);

						std::stof (String to Float):
							Converts a string to a float.
							Usage: float result = std::stof(str);

						std::stod (String to Double):
							Converts a string to a double.
							Usage: double result = std::stod(str);

						std::stold (String to Long Double):
							Converts a string to a long double.
							Usage: long double result = std::stold(str);

						These functions are part of the <string> header in C++. 
						Choose the appropriate function based on the 
						data type you need for your specific use case.

			eg.
				include <iostream>
				int main() {
					float f = 45.99f;
					int b = f;
					
					float f1 = b;
					
					std::string str = "1234";
					// int a = int(str);       // this won't work
					int a = stoi(str);       //to convert string to int
					
					std::cout<<a<<std::endl;		//1234
					std::cout<<a+6<<std::endl;	//1240
					
					std::cout<<f<<"\n";		//45.99
					std::cout<<b+2<<"\n";	//47
					std::cout<<f1<<"\n";	//45
					
					return 0;
				}

				#include <iostream>
				int main() {
					std::string str = "450";
					int a;
					std::cout<<str<<std::endl;
					std::cout<<a<<std::endl;
					std::cout<<stoi(str)+10;			//string to integer stoi().
					return 0;
				}

				//or
					string to Int
						#include <iostream>
						#include<sstream>
						using namespace std;

						int main() {
							string s = "1234";
							
							stringstream ss;        //ss obj of stringstream class
							ss<<s;          //inserting string
							
							int n;
							ss>>n;          //outputing num to n
							
							std::cout <<n*2<< std::endl;        //2468
							return 0;
						}

		How -ve num stored:
			if first bit is 1, then num is -ve.
			if first bit is 0, then num is +ve.
			eg.
				want to store -8.
				step 1:	
					ignore negative sing(-ve)
					8
				step 2:
					convert 8 to binary format
					1000
					stored as
						[-------- -------- -------- ----1000] rest all are zero only like below,
						[00000000 00000000 00000000 00001000]

				step 3:
					-Take 2's (two's) complement & store.
					 for taking 2's complement first take 1's complement
					 
					 step 1: 
					 	1's complement change 0 to 1 & viceversa.
						[11111111 11111111 11111111 11110111]

					 step 2:
					 	add 1 in 1's complement.
						[11111111 11111111 11111111 11110111]
						+							1
						______________________________________
						[11111111 11111111 11111111 11111000]		
							--here in the answer first bit is 1, so it denotes its -ve num.
							--this is 2s complement of 8
				
				step 4:
					-To print that -ve num then take 2's complement of above output:
						[11111111 11111111 11111111 11111000]		
					
					-1's complement
						[00000000 00000000 00000000 00000111]
						+							1
						_____________________________________
						[00000000 00000000 00000000 00001000]
					
					now print above as its 8, but -ve.

		For +ve num only:
			unsigned int a = 122;
			range:
				0 to 2³²-1;

			if you try to store -ve num then it will generate huge num becoz 
			of most significant bit (first bit) is 1 to represent it is a -ve but,
			you said its +ve by mentioning usigned so compiler treat it as positive & generates huge num.
		
		Operator:
			Unary:
				increment (++)
				decrement (--)
				eg.
					postIncrement/postDecrement means the value will get incremented or decremented after using.
					old value gets used then value gets updated
						a++;		//postIncrement
						a--;		//postDecrement
					
					
					preIncrement/ preDecrement means the value will get incremented or decremented before using.
					value gets incresed or decresed first then it will gets used.
						++a;		//pretIncrement
						--a;		//pretDecrement
					
			Arithmetic:-
				+,-,*,/,%

				int/ int  = int		//if we divide int by int the answer will be integer
				float / int = float		//if we divide float by int the answer will be floating point num.
				double / int = double		//if we divide double by int the answer will be double.

				eg.
					#include <iostream>
					#include<cmath>
					using namespace std;
					int main(){
						int n=60, sum =101;
						
						double d = sum/(double)n;			//getting value in double.		
						std::cout << d << std::endl;					//1.68333
						std::cout << round(d) << std::endl;			//2
						
						return 0;
					}

			Relational:- 
				To Check
				== is equal to equal to (double equals to)
				< is less than
				> is greater than
				<= is less than equal to
				>= is greater than equal to
				!= is not equal to
			
			Assignment operator:
				=, +=, *=, -=, /=, %= etc
				eg.
					a = 10;
					a = a + 10;		-->		a += 10;
					a = a * 10;		-->		a *= 10;
					a = a - 10;		-->		a -= 10;
					a = a / 10;		-->		a /= 10;
					a = a % 10;		-->		a %= 10;

			Logical:-
				&& AND operation takes two boolean values and returns True if both are True else False.
				|| OR any one conditions should true for that statement to execute.
				! NOT reverse value.
				eg.
					ignores the sign.
					int a = 0;
						std::cout << !a;		//1
					int b = 1;
						std::cout << !b;		//0
					int c = 10;
						std::cout << !c;		//0
					int d = -10;
						std::cout << !d;		//0
					int e = -0;
						std::cout << !e;		//1

				eg.
					#include <iostream>
					using namespace std;

					int main() {
						int x = -5;
						int y = -10;

						// ||- or
						if (x > 0 or y > 0) {
							std::cout << "Both x and y are greater than 0." << std::endl;
						}else{
							std::cout << "nothing" << std::endl;
						}
						
						x=90,y=88;
						// Logical AND using 'and'
						if (x > 0 and y > 0) {
							std::cout << "Both x and y are greater than 0." << std::endl;
						}else{
							std::cout << "nothing" << std::endl;
						}   
						return 0;
					}

			Ternary Operator:
				syntax:
					(condition) ? ([if true execute this]) : ([if false execute this])
				eg.
					#include <iostream>
					using namespace std;

					int main() {
						int a = 100;
						
						//ternary operator
						(a>20) ? cout<< a << " Greater Than 20" : cout<< a << "Less than 20";

						return 0;
					}
				
				-for single statement don't use ( ) in ternary operator direct mention your statement.
				-for multiple statement to print or do operation use ( ).
				eg.
					printing twice,
						#include <iostream>
						using namespace std;

						int main()
						{
							int n =91;
							(n % 2 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or above there is just one condition so no need to use braces near condition also, like
							n % 2 == 0 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//if more than one condition is there in ternary operator, use braces ( ), for best practices
							//if you don't use still it works

							//first even condition is true but 2nd 400 is not less than 50, its false 
							//but && requires both condition must be true so complete equation is false,
							//output odd world.
							n =400;
							(n % 2==0 && n< 50 == 1) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							

							//output for below is even n<50 which is false means 0, & 0 == 0 so n= 400 is even & 0 == 0 both condition are true so even world will printed.
							(n % 2==0 && n< 50 == 0) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							//or even world will run
							//first condition is true, 2nd is false
							n=400;
							(n % 2==0 || n< 50) ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
  
							//without braces
							//works fine and (,) comma is behaves like && operator,
							n % 2==0 && n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");
							n % 2==0 , n< 50 ? (cout<<"Hello Even World ", cout<<"Hello 2nd World ") : (cout<<"Hello Odd World", cout<<"Hello 3rd World");

							return 0;
						}

					initializing int inside ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							//syntax to initialize,
							(condition)? ([] {//initialization,//statement, //code})(): ([] {//initialization,//statement, //code})()

							//integer initialized
							n % 2 == 0 && n < 50 ? ([]{ int v = 80; cout << "Hello Even World " << v << " Hello 2nd World "; })() : ([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							//string initialized
							n%2 ? ([]{ string v = "Vivek"; cout << "Hello Even World " << v << " Hello 2nd World ";})() :([]{ cout << "Hello Odd World"; cout << " Hello 3rd World"; })();

							return 0;
						}

					ternary operator:
						#include <iostream>
						using namespace std;

						int main() {
							int n = 42; // Replace with your desired value of n

							n % 2 == 0 && n < 50 ? ([]{
								int v = 80;
								string evenMessage = "Hello Even World " + to_string(v);
								string secondMessage = "Hello 2nd World";
								cout << evenMessage << " " << secondMessage;
							})() : ([]{
								string oddMessage = "Hello Odd World";
								string thirdMessage = "Hello 3rd World";
								cout << oddMessage << " " << thirdMessage;
							})();

							return 0;
						}

					string ternary:
						#include <iostream>
						using namespace std;

						int main()
						{
							string finalgrade = []() {
								int grade = 100;
								return (grade < 60) ? "fail" : "pass";
							}();

							std::cout << finalgrade << std::endl;

							return 0;
						}

			Bitwise:-
				& and
				| or
				^ xor
				~ complement of bits in binary representation
				<< left shift
				>> right shift
			
			//Converting num to string & counting digit in it.
				#include <iostream>
				using namespace std;
				int main(){
					int i=1234,j=12,k=9686854;
					cout<<"no.of digit in i: "<<(to_string(i).length())<<endl;            //4
					cout<<"no.of digit in j: "<<to_string(j).size()<<endl;                //2
					cout<<"no.of digit in k: "<<to_string(k).size()<<endl;                //7
					
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-3: Conditionals, Loops, Patterns
	1) if Statement
		if(condition){
			//code block executed when condition evaluates as TRUE
		}

	2) if-else Statement
		if(condition){ 
			//This code block will be executed only if 'condition' is evaluated as TRUE
		}
		else{   
			//this block gets executed when if block evaluates to FALSE
		}
		
	3) else-if Statement
		if (cond_A) { 
			//first conditional expression
			/* statements */
		}
		else if (cond_B) {
			//second condtional expression
			/* other statements*/
		}
		else if (cond_C) {
			//third condtional expression
			/* other statements*/
		}
		else {
			/* last statement for default case */
		}
		//else is last default block not mandatory to write.
	
	4) Nested If statements / Nested If-else:
		if-statement inside another if statement

		if(cond){
			//if true
		}else{
			if(nestedCond){ 
				// nested condition code here
			} else{

			}
		}
	
	5) Switch Case Statement
			Why we use switch case instead of if-else?
				Editing in switch statement is easier as compared to the 'if-else' statement. 
				If we remove any of the cases from the switch, then it will not interrupt the execution of other cases. 
				Therefore, we can say that the switch statement is easy to modify and maintain.

				-If we have multiple choices then the
				switch statement is the best option as
				the speed of the execution will be much
				higher than 'if-else'

				-Break keyword:
					The break in C++ is a loop control statement that is used to terminate the loop. 
					As soon as the break statement is encountered from within a loop, 
					the loop iterations stop there and control returns from the loop immediately to the first statement after the loop.
				
				-Continue:
					C++ continue statement is a loop control statement that forces the 
					program control to execute the next iteration of the loop. As a result, 
					the code inside the loop following the continue statement will be 
					skipped and the next iteration of the loop will begin.

			eg.
				#include <iostream>
				using namespace std;

				int main() {
					char oper;
					float num1, num2;
					cout << "Enter an operator (+, -, *, /): ";
					cin >> oper;
					cout << "Enter two numbers: " << endl;
					cin >> num1 >> num2;

					switch (oper) {
						case '+':
							cout << num1 << " + " << num2 << " = " << num1 + num2;
							break;
						case '-':
							cout << num1 << " - " << num2 << " = " << num1 - num2;
							break;
						case '*':
							cout << num1 << " * " << num2 << " = " << num1 * num2;
							break;
						case '/':
							cout << num1 << " / " << num2 << " = " << num1 / num2;
							break;
						default:
							// operator is doesn't match any case constant (+, -, *, /)
							cout << "Error! The operator is not correct";
							break;
					}
					return 0;
				}

	6) While Loop:
		while loop require just a num inside as condition it may be -ve or +ve, it will work, 
		except the 0, if zero cames then loop breaks.
		eg.
			while(1)		//works
			while(100)	//works
			while(-23)	//works
			while(5)		//works

			while(0)		//stops this will breaks the loop.
			eg.
				#include <iostream>
				using namespace std;

				int main()
				{
					int i=1, b=-5;
					while(b++){
						std::cout << "say hii" << i++ << std::endl;
						//b++;
					}
					return 0;
				}

	 eg
	 	//WAP TO PRINT THE N NUMS:
			#include <iostream>
			using namespace std;

			int main() {
				int i=1;
				// while(i<11)
				//     cout << i++ <<"\t";
				//or
				
				while(i<11){
					cout << i << end;
					i++;                //i = i + 1
				}
				return 0;
			}

			#include <iostream>
			using namespace std;

			int main() {
				int i=1,n;
				cout << "enter n :: ";
				cin>>n;
				while(i<=n)
					cout << i++ <<"\t";
				//or
				
				//while(i<=n){
				//	cout << i << "\t";
				//	i++;                //i = i + 1
				//}
				return 0;
			}

		//WAP sum of first n num
			#include <iostream>
			using namespace std;

			int main() {
				int n,i=1,sum=0;
				cout << "enter n:: ";
				cin>>n;

				//shorthand
				while(i<=n)
					sum += i++;
				
				// or
				// while(i<=n){
				//     sum = sum + i;       //sum = sum + i
				//     i++;            //i = i +1;
				// }

				cout<< "The sum of "<<n<<" is "<<sum;
				
				return 0;
			}

		//WAP sum of even num
			#include <iostream>
			using namespace std;

			int main() {
				// sum of even num
				int n,i=2;
				cout << "Enter n:: ";
				cin>>n;
				
				int sum =0;
				while(i<=n){
					if(i % 2 == 0)
						sum = sum + i;
					i++;
				}
				
				// or shorhand
				// while(i <= n){
				//     if(i % 2 == 0)
				//         sum += i;
				//     i++;
				// }
					
				cout << "Sum of even till "<< n << " is :: "<< sum;
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					int sum=0;
					int n;
					cin>>n;

					for(int i=2;i<=n;i+=2)
						sum +=i;
					cout<<sum;
					return 0;
				}							
			
		//WAP to check entered num is prime or not?
			#include <iostream>
			using namespace std;

			int main() {
				//WAP num is prime or not.
				int n,i=2,flag=0;
				cout << "enter num :: ";
				cin>>n;
				
				while(i <= n/2){
					if(n % i == 0){
						flag = 1;
						break;
					}
					i++;
				}
				
				if(flag)
					cout << n << " is not prime";
				else
					cout << n << " is Prime Num";
				
				return 0;
			}
		
		//WAP to print:
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			* * * * * * * *
			->
				#include <iostream>
				int main() {
					int i=1,j=1;
					while(i++ <6){              //shorthands
						while(j++ < 8){         //shorthands for increment
							std::cout << "* ";
							// j++              
						}
						j=1;
						// i++;     
						std::cout<<"\n";
					}
					return 0;
				}
		
		//WAP to take rows & column from user.
			#include <iostream>
			int main() {
				int i=1,j=1,n;
				
				std::cout<<"Enter rows column :: ";
				std::cin>>n;
				
				while(i++ <n){              //shorthands
					while(j++ < n){         //shorthands for increment
						std::cout << "* ";
						// j++              
					}
					j=1;
					// i++;     
					std::cout<<"\n";
				}

				return 0;
			}
		
		//WAP to print this Patterns with custom rows:
		 if rows are 5,
			1 1 1 1 1 
			2 2 2 2 2 
			3 3 3 3 3 
			4 4 4 4 4 
			5 5 5 5 5
		     ->
			#include <iostream>
			int main() {
			
				int z,p,rows;
				std::cout << "Enter num of rows you want :: ";
				std::cin >> rows;
				for(z=1; z<=rows; z++){
					for(p=1; p<=rows; p++)
						std::cout << z << " ";
					std::cout<<std::endl;
				}
				return 0;
			}
			//output:
				Enter num of rows you want :: 8
					1 1 1 1 1 1 1 1 
					2 2 2 2 2 2 2 2 
					3 3 3 3 3 3 3 3 
					4 4 4 4 4 4 4 4 
					5 5 5 5 5 5 5 5 
					6 6 6 6 6 6 6 6 
					7 7 7 7 7 7 7 7 
					8 8 8 8 8 8 8 8

	eg.
		1).WAP to check num is +ve, -ve or zero?
			#include <iostream>
			using namespace std;

			int main() {
				cout<<"Enter value for A::";
				int a;
				cin>>a;
				if(a>0){
					cout<<"A is +ve "<<a;
				}else if(a<0){
					cout<<"A is -ve "<<a;
				}else{
					cout<<"A is Zero "<<a;
				}
				return 0;
			}
			--here cin function takes the input, cin function don't read tabs, space & new line char.

		2).WAP for Greater num
			#include <iostream>
			using namespace std;

			int main() {
				cout << "Enter values of A & B::";
				int a,b;
				cin >> a >> b;						//taking input at same time.
				
				cout << "A :: " << a << " B :: " << b << endl;
				if(a>b)
					cout << "A is Greater than B";
				else if(b > a)
					cout << "B is Greater than A";
				else
					cout << "A is equals to B";
				return 0;
			}

			--if there is one statement in if block then no need to put the { } curly braces

		3). WAP to check char is lowercase or uppercase or digit?
			#include <iostream>
			using namespace std;

			int main() {
				char ch;
				cout<< "Enter char :: ";
				cin>>ch;
				
				if(ch >= 'a' && ch<='z')
					cout << "Char is Lowercase "<<ch;
				else if(ch >= 'A' && ch <= 'Z')
					cout << "Char is Uppercase "<<ch;
				else if(ch >= '0' && ch <= '9')
					cout << "Char is Digit "<<ch;
				else
					cout << "Char is something Strange "<<ch;
				return 0;
			}

			CHAR Functions:
				-To use below functions you have to include this library,
					#include <ctype.h>
					//or
					#include <cctype>

				1) isalnum:
					int isalnum ( int ch );
					
					-return true if char is alphabet (upper or lower) or digit (0-9). (alphanumeric = alphabet or number).
					-The function returns a non-zero value if the character is alphanumeric and 0 otherwise.

					#include <iostream>
					#include <ctype.h>

					int main() {
						char ch1 = 'A';
						char ch2 = '7';
						char ch3 = '$';
						
						char ch4 = 'z';
						char ch5 = '8';

						if (isalnum(ch1)) {
							std::cout << ch1 << " is alphanumeric.\n";
						} else {
							std::cout << ch1 << " is not alphanumeric.\n";
						}

						if (isalnum(ch2)) {
							std::cout << ch2 << " is alphanumeric.\n";
						} else {
							std::cout << ch2 << " is not alphanumeric.\n";
						}

						if (isalnum(ch3)) {
							std::cout << ch3 << " is alphanumeric.\n";
						} else {
							std::cout << ch3 << " is not alphanumeric.\n";
						}
						
						if (isalnum(ch4)) {
							std::cout << ch4 << " is alphanumeric.\n";
						} else {
							std::cout << ch4 << " is not alphanumeric.\n";
						}
						
						if (isalnum(ch5)) {
							std::cout << ch5 << " is alphanumeric.\n";
						} else {
							std::cout << ch5 << " is not alphanumeric.\n";
						}
						return 0;
					}
					//output:
						A is alphanumeric.
						7 is alphanumeric.
						$ is not alphanumeric.
						z is alphanumeric.
						8 is alphanumeric.

				2) isalpha:
					isalpha function is also part of the <cctype> header. 
					and is used to check whether a given character is an alphabetic character (a letter lowercase or uppercase). 
					The function returns (true) a non-zero value if the character is an alphabetic character and (false) 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = 'a';
						char ch3 = '7';
						char ch4 = '$';

						if (isalpha(ch1)) {
							std::cout << ch1 << " is an alphabetic character.\n";
						} else {
							std::cout << ch1 << " is not an alphabetic character.\n";
						}

						if (isalpha(ch2)) {
							std::cout << ch2 << " is an alphabetic character and in lowercase.\n";
						} else {
							std::cout << ch2 << " is not an alphabetic character.\n";
						}

						if (isalpha(ch3)) {
							std::cout << ch3 << " is an alphabetic character.\n";
						} else {
							std::cout << ch3 << " is not an alphabetic character.\n";
						}

						if (isalpha(ch4)) {
							std::cout << ch4 << " is an alphabetic character.\n";
						} else {
							std::cout << ch4 << " is not an alphabetic character.\n";
						}

						return 0;
					}
					//output:
						A is an alphabetic character.
						a is an alphabetic character and in lowercase.
						7 is not an alphabetic character.
						$ is not an alphabetic character.

				3) isblank:
					The isblank function is another function from the <cctype> header in C++. 
					It is used to check whether a given character is a blank character, 
					which includes space (' ') 
					and horizontal tab ('\t'). 
					The function returns a non-zero value if the character is a blank character and 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = ' ';
						char ch3 = '\t';

						if (isblank(ch1)) {
							std::cout << ch1 << " is a blank character.\n";
						} else {
							std::cout << ch1 << " is not a blank character.\n";
						}

						if (isblank(ch2)) {
							std::cout << ch2 << " is a blank character.\n";
						} else {
							std::cout << ch2 << " is not a blank character.\n";
						}

						if (isblank(ch3)) {
							std::cout << "Tab character is a blank character.\n";
						} else {
							std::cout << "Tab character is not a blank character.\n";
						}

						return 0;
					}
					//output:
						A is not a blank character.
						   is a blank character.
						Tab character is a blank character.

				4) iscntrl:
					The iscntrl function in C++ is part of the <cctype> header, 
					and it checks whether a given character is a control character. 
					Control characters are non-printing characters that are used to control 
					the formatting and other aspects of output. 
					Examples of control characters include newline ('\n'), carriage return ('\r'), and tab ('\t').

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = '\n';
						char ch3 = '\t';
						char ch4 = '\r';

						if (iscntrl(ch1)) {
							std::cout << ch1 << " is a control character.\n";
						} else {
							std::cout << ch1 << " is not a control character.\n";
						}

						if (iscntrl(ch2)) {
							std::cout << "Newline character is a control character.\n";
						} else {
							std::cout << "Newline character is not a control character.\n";
						}

						if (iscntrl(ch3)) {
							std::cout << "Tab character is a control character.\n";
						} else {
							std::cout << "Tab character is not a control character.\n";
						}

						if (iscntrl(ch4)) {
							std::cout << "Carriage return character is a control character.\n";
						} else {
							std::cout << "Carriage return character is not a control character.\n";
						}

						return 0;
					}
					//output:
						A is not a control character.
						Newline character is a control character.
						Tab character is a control character.
						Carriage return character is a control character.

				5) isdigit:
					The isdigit function in C++ is used to check whether a given 
					character is a digit (0-9). 
					The function returns a non-zero (true) value if the character is a digit and (false) 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = '7';
						char ch3 = '$';

						if (isdigit(ch1)) {
							std::cout << ch1 << " is a digit.\n";
						} else {
							std::cout << ch1 << " is not a digit.\n";
						}

						if (isdigit(ch2)) {
							std::cout << ch2 << " is a digit.\n";
						} else {
							std::cout << ch2 << " is not a digit.\n";
						}

						if (isdigit(ch3)) {
							std::cout << ch3 << " is a digit.\n";
						} else {
							std::cout << ch3 << " is not a digit.\n";
						}

						return 0;
					}
					//output:
						A is not a digit.
						7 is a digit.
						$ is not a digit.

				6) isgraph:
					The isgraph function in C++ is used to check whether a given character is a graphical character. 
					A graphical character is any character that has a visible representation, 
					meaning it is printable and not a space (' '). 
					-The function returns a non-zero value if the character is a graphical character and 0 otherwise.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is a graphical character.
						char ch2 = ' ';
						char ch3 = '7';         // 7 is a graphical character.
						char ch4 = '@';         // @ is a graphical character.
						char ch5 = '\t';        // Tab character is not a graphical character.
						char ch6 = '!';         // ! is a graphical character.

						if (isgraph(ch1)) {
							std::cout << ch1 << " is a graphical character.\n";
						} else {
							std::cout << ch1 << " is not a graphical character.\n";
						}

						if (isgraph(ch2)) {
							std::cout << "Space character is not a graphical character.\n";
						} else {
							std::cout << "Space character is a graphical character.\n";
						}

						if (isgraph(ch3)) {
							std::cout << ch3 << " is a graphical character.\n";
						} else {
							std::cout << ch3 << " is not a graphical character.\n";
						}

						if (isgraph(ch4)) {
							std::cout << ch4 << " is a graphical character.\n";
						} else {
							std::cout << ch4 << " is not a graphical character.\n";
						}

						if (isgraph(ch5)) {
							std::cout << "Tab character is not a graphical character.\n";
						} else {
							std::cout << "Tab character is a graphical character.\n";
						}

						if (isgraph(ch6)) {
							std::cout << ch6 << " is a graphical character.\n";
						} else {
							std::cout << ch6 << " is not a graphical character.\n";
						}

						return 0;
					}
					//output:
						A is a graphical character.
						Space character is not a graphical character.
						7 is a graphical character.
						@ is a graphical character.
						Tab character is not a graphical character.
						! is a graphical character.

				7) islower:
					The islower function in C++ is used to check whether a given character is a 
					lowercase alphabetic character. 
					The function returns a non-zero(true) value if the character is a lowercase letter and 0(false) otherwise.
					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is not a lowercase letter.
						char ch2 = 'a';         // a is a lowercase letter.
						char ch3 = '7';         // 7 is not a lowercase letter.
						char ch4 = '!';         // ! is not a lowercase letter.
						char ch5 = 'z';         // z is a lowercase letter.
						char ch6 = ' ';         // Space character is not a lowercase letter.

						if (islower(ch1)) {
							std::cout << ch1 << " is a lowercase letter.\n";
						} else {
							std::cout << ch1 << " is not a lowercase letter.\n";
						}

						if (islower(ch2)) {
							std::cout << ch2 << " is a lowercase letter.\n";
						} else {
							std::cout << ch2 << " is not a lowercase letter.\n";
						}

						if (islower(ch3)) {
							std::cout << ch3 << " is not a lowercase letter.\n";
						} else {
							std::cout << ch3 << " is not a lowercase letter.\n";
						}

						if (islower(ch4)) {
							std::cout << ch4 << " is not a lowercase letter.\n";
						} else {
							std::cout << ch4 << " is not a lowercase letter.\n";
						}

						if (islower(ch5)) {
							std::cout << ch5 << " is a lowercase letter.\n";
						} else {
							std::cout << ch5 << " is not a lowercase letter.\n";
						}

						if (islower(ch6)) {
							std::cout << ch6 << " is not a lowercase letter.\n";
						} else {
							std::cout << ch6 << " is not a lowercase letter.\n";
						}

						return 0;
					}
					//output:
						A is not a lowercase letter.
						a is a lowercase letter.
						7 is not a lowercase letter.
						! is not a lowercase letter.
						z is a lowercase letter.
						Space character is not a lowercase letter.

				8) isupper:
					isupper function in C++ is a part of the <cctype> library, 
					and it is used to determine whether a given character is an uppercase alphabetic character.
					-Returns a non-zero(true) value if c is an uppercase alphabetic character.
					-Returns 0(false) otherwise.
					
					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is an uppercase letter.
						char ch2 = 'a';         // a is not an uppercase letter.
						char ch3 = '7';         // 7 is not an uppercase letter.
						char ch4 = '!';         // ! is not an uppercase letter.
						char ch5 = 'Z';         // Z is an uppercase letter.
						char ch6 = ' ';         // Space character is not an uppercase letter.

						if (isupper(ch1)) {
							std::cout << ch1 << " is an uppercase letter.\n";
						} else {
							std::cout << ch1 << " is not an uppercase letter.\n";
						}

						if (isupper(ch2)) {
							std::cout << ch2 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch2 << " is not an uppercase letter.\n";
						}

						if (isupper(ch3)) {
							std::cout << ch3 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch3 << " is not an uppercase letter.\n";
						}

						if (isupper(ch4)) {
							std::cout << ch4 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch4 << " is not an uppercase letter.\n";
						}

						if (isupper(ch5)) {
							std::cout << ch5 << " is an uppercase letter.\n";
						} else {
							std::cout << ch5 << " is not an uppercase letter.\n";
						}

						if (isupper(ch6)) {
							std::cout << ch6 << " is not an uppercase letter.\n";
						} else {
							std::cout << ch6 << " is not an uppercase letter.\n";
						}

						return 0;
					}
					//output:
						A is an uppercase letter.
						a is not an uppercase letter.
						7 is not an uppercase letter.
						! is not an uppercase letter.
						Z is an uppercase letter.
						Space character is not an uppercase letter.

				9) isspace:
					The isspace function in C++ is used to check whether a given character is a white-space character. 
					White-space characters include space (' '), tab ('\t'), newline ('\n'), carriage return ('\r'), 
					form feed ('\f'), and vertical tab ('\v'). 
					-The function returns a non-zero value if the character is a white-space character and 0 otherwise.

					#include <iostream>
					#include <cctype>
					int main() {
						char ch1 = 'A';
						char ch2 = ' ';
						char ch3 = '\t';  // Tab character
						char ch4 = '\n';  // Newline character
						char ch5 = '\v';  // Vertical tab character
						char ch6 = '\r';  // Carriage return character

						if (isspace(ch1)) {
							std::cout << ch1 << " is a white-space character.\n";
						} else {
							std::cout << ch1 << " is not a white-space character.\n";
						}

						if (isspace(ch2)) {
							std::cout << ch2 << " is a white-space character.\n";
						} else {
							std::cout << ch2 << " is not a white-space character.\n";
						}

						if (isspace(ch3)) {
							std::cout << "Tab character is a white-space character.\n";
						} else {
							std::cout << "Tab character is not a white-space character.\n";
						}

						if (isspace(ch4)) {
							std::cout << "Newline character is a white-space character.\n";
						} else {
							std::cout << "Newline character is not a white-space character.\n";
						}

						if (isspace(ch5)) {
							std::cout << "Vertical tab character is a white-space character.\n";
						} else {
							std::cout << "Vertical tab character is not a white-space character.\n";
						}

						if (isspace(ch6)) {
							std::cout << "Carriage return character is a white-space character.\n";
						} else {
							std::cout << "Carriage return character is not a white-space character.\n";
						}

						return 0;
					}

					//output:
						A is not a white-space character.
						 is a white-space character.
						Tab character is a white-space character.
						Newline character is a white-space character.
						Vertical tab character is a white-space character.
						Carriage return character is a white-space character.

				10) ispunct:
					ispunct function in C++, punctuation characters are considered to be special characters. 
					Punctuation characters are those that are not letters, digits, or whitespace characters. 
					They typically include characters like '.', ',', '!', '?', ';', and other symbols commonly 
					used for punctuation in written language.

					So, when you use the ispunct function, 
					it will return a non-zero value for characters that are considered punctuation characters, 
					and 0 for characters that are not. 
					In the provided example, characters like '.', ',', '!', ';', and '?' are considered punctuation characters.

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is not a punctuation character.
						char ch2 = '!';         // ! is a punctuation character.
						char ch3 = '7';         // 7 is not a punctuation character.
						char ch4 = ' ';         // Space character is not a punctuation character.
						char ch5 = '.';         // . is a punctuation character.
						char ch6 = ',';         // , is a punctuation character.
						char ch7 = ';';         // ; is a punctuation character.
						char ch8 = '?';         // ? is a punctuation character.
						char ch9 = '#';         // # is a punctuation character.
						char ch10 = '$';        // $ is a punctuation character.
						char ch11 = '%';        // % is a punctuation character.
						char ch12 = '^';        // ^ is a punctuation character.
						char ch13 = '&';        // & is a punctuation character.
						char ch14 = '@';        // @ is a punctuation character.

						if (ispunct(ch1)) {
							std::cout << ch1 << " is not a punctuation character.\n";
						} else {
							std::cout << ch1 << " is not a punctuation character.\n";
						}

						if (ispunct(ch2)) {
							std::cout << ch2 << " is a punctuation character.\n";
						} else {
							std::cout << ch2 << " is not a punctuation character.\n";
						}

						if (ispunct(ch3)) {
							std::cout << ch3 << " is not a punctuation character.\n";
						} else {
							std::cout << ch3 << " is not a punctuation character.\n";
						}

						if (ispunct(ch4)) {
							std::cout << "Space character is not a punctuation character.\n";
						} else {
							std::cout << "Space character is not a punctuation character.\n";
						}

						if (ispunct(ch5)) {
							std::cout << ch5 << " is a punctuation character.\n";
						} else {
							std::cout << ch5 << " is not a punctuation character.\n";
						}

						if (ispunct(ch6)) {
							std::cout << ch6 << " is a punctuation character.\n";
						} else {
							std::cout << ch6 << " is not a punctuation character.\n";
						}

						if (ispunct(ch7)) {
							std::cout << ch7 << " is a punctuation character.\n";
						} else {
							std::cout << ch7 << " is not a punctuation character.\n";
						}

						if (ispunct(ch8)) {
							std::cout << ch8 << " is a punctuation character.\n";
						} else {
							std::cout << ch8 << " is not a punctuation character.\n";
						}

						if (ispunct(ch9)) {
							std::cout << ch9 << " is a punctuation character.\n";
						} else {
							std::cout << ch9 << " is not a punctuation character.\n";
						}

						if (ispunct(ch10)) {
							std::cout << ch10 << " is a punctuation character.\n";
						} else {
							std::cout << ch10 << " is not a punctuation character.\n";
						}

						if (ispunct(ch11)) {
							std::cout << ch11 << " is a punctuation character.\n";
						} else {
							std::cout << ch11 << " is not a punctuation character.\n";
						}

						if (ispunct(ch12)) {
							std::cout << ch12 << " is a punctuation character.\n";
						} else {
							std::cout << ch12 << " is not a punctuation character.\n";
						}

						if (ispunct(ch13)) {
							std::cout << ch13 << " is a punctuation character.\n";
						} else {
							std::cout << ch13 << " is not a punctuation character.\n";
						}

						if (ispunct(ch14)) {
							std::cout << ch14 << " is a punctuation character.\n";
						} else {
							std::cout << ch14 << " is not a punctuation character.\n";
						}

						return 0;
					}
					//output:
						A is not a punctuation character.
						! is a punctuation character.
						7 is not a punctuation character.
						Space character is not a punctuation character.
						. is a punctuation character.
						, is a punctuation character.
						; is a punctuation character.
						? is a punctuation character.
						# is a punctuation character.
						$ is a punctuation character.
						% is a punctuation character.
						^ is a punctuation character.
						& is a punctuation character.
						@ is a punctuation character.

				11) isprint:
					isprint function in C++ is used to check whether a given character is a printable character. 
					A printable character is any character that is not a control character (like newline or tab) 
					and is not part of the extended character set (values greater than 127 in ASCII). 
					The function returns a non-zero value if the character is printable and 0 otherwise.


					#include <stdio.h>
					#include <ctype.h>
					int main () {
						int i=0;
						char str[]="first line \n second line \n";
						while (isprint(str[i])) {
							putchar (str[i]);
							i++;
						}
						return 0;
					}
					//output:
						first line 

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';         // A is a printable character.
						char ch2 = ' ';         //   is a printable character.
						char ch3 = '\t';        // Tab character is not a printable character.
						char ch4 = '\n';        // Newline character is not a printable character.
						char ch5 = '#';         // # is a printable character.
						char ch6 = 7;           // ASCII control character (Bell) is not a printable character.
						char ch7 = 127;         // ASCII control character (Delete) is not a printable character.
						char ch8 = '0';         // 0 is a printable character.
						char ch9 = '7';         // 7 is a printable character.
						char ch10 = 'a';        // a is a printable character.
						char ch11 = 'z';        // z is a printable character.

						if (isprint(ch1)) {
							std::cout << ch1 << " is a printable character.\n";
						} else {
							std::cout << ch1 << " is not a printable character.\n";
						}

						if (isprint(ch2)) {
							std::cout << ch2 << " is a printable character.\n";
						} else {
							std::cout << ch2 << " is not a printable character.\n";
						}

						if (isprint(ch3)) {
							std::cout << "Tab character is not a printable character.\n";
						} else {
							std::cout << "Tab character is not a printable character.\n";
						}

						if (isprint(ch4)) {
							std::cout << "Newline character is not a printable character.\n";
						} else {
							std::cout << "Newline character is not a printable character.\n";
						}

						if (isprint(ch5)) {
							std::cout << ch5 << " is a printable character.\n";
						} else {
							std::cout << ch5 << " is not a printable character.\n";
						}

						if (isprint(ch6)) {
							std::cout << "Bell character is not a printable character.\n";
						} else {
							std::cout << "Bell character is not a printable character.\n";
						}

						if (isprint(ch7)) {
							std::cout << "Delete character is not a printable character.\n";
						} else {
							std::cout << "Delete character is not a printable character.\n";
						}

						if (isprint(ch8)) {
							std::cout << ch8 << " is a printable character.\n";
						} else {
							std::cout << ch8 << " is not a printable character.\n";
						}

						if (isprint(ch9)) {
							std::cout << ch9 << " is a printable character.\n";
						} else {
							std::cout << ch9 << " is not a printable character.\n";
						}

						if (isprint(ch10)) {
							std::cout << ch10 << " is a printable character.\n";
						} else {
							std::cout << ch10 << " is a printable character.\n";
						}

						if (isprint(ch11)) {
							std::cout << ch11 << " is a printable character.\n";
						} else {
							std::cout << ch11 << " is a printable character.\n";
						}

						return 0;
					}
				
				12) isxdigit:
					isxdigit function in C++ is used to check whether a given character is a hexadecimal digit. 
					Hexadecimal digits include the numbers 0-9 and the letters A-F (or a-f) representing the values 10-15. 
					The function returns a non-zero value if the character is a hexadecimal digit and 0 

					#include <iostream>
					#include <cctype>

					int main() {
						char ch1 = 'A';
						char ch2 = '7';
						char ch3 = '$';
						char ch4 = '2';
						char ch5 = 'f';
						char ch6 = 'G';  // Uppercase G is not a hexadecimal digit.
						char ch7 = 'x';  // Lowercase x is not a hexadecimal digit.
						char ch8 = ' ';  // Space is not a hexadecimal digit.

						// Output for given characters
						std::cout << ch1 << ": " << (isxdigit(ch1) ? ch1 + " is a hexadecimal digit." : ch1 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch2 << ": " << (isxdigit(ch2) ? ch2 + " is a hexadecimal digit." : ch2 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch3 << ": " << (isxdigit(ch3) ? ch3 + " is a hexadecimal digit." : ch3 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch4 << ": " << (isxdigit(ch4) ? ch4 + " is a hexadecimal digit." : ch4 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch5 << ": " << (isxdigit(ch5) ? ch5 + " is a hexadecimal digit." : ch5 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch6 << ": " << (isxdigit(ch6) ? ch6 + " is a hexadecimal digit." : ch6 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch7 << ": " << (isxdigit(ch7) ? ch7 + " is a hexadecimal digit." : ch7 + " is not a hexadecimal digit.") << "\n";
						std::cout << ch8 << ": " << (isxdigit(ch8) ? ch8 + " is a hexadecimal digit." : ch8 + " is not a hexadecimal digit.") << "\n";

						// Additional cases for all lowercase and uppercase hexadecimal digits
						for (char ch = 'A'; ch <= 'F'; ++ch) {
							std::cout << ch << ": " << (isxdigit(ch) ? ch + " is a hexadecimal digit." : ch + " is not a hexadecimal digit.") << "\n";
						}

						for (char ch = 'a'; ch <= 'f'; ++ch) {
							std::cout << ch << ": " << (isxdigit(ch) ? ch + " is a hexadecimal digit." : ch + " is not a hexadecimal digit.") << "\n";
						}

						return 0;
					}

					//output:
						A: A is a hexadecimal digit.
						7: 7 is a hexadecimal digit.
						$: $ is not a hexadecimal digit.
						2: 2 is a hexadecimal digit.
						f: f is a hexadecimal digit.
						G: G is not a hexadecimal digit.
						x: x is not a hexadecimal digit.
						:   is not a hexadecimal digit.
						A: A is a hexadecimal digit.
						B: B is a hexadecimal digit.
						C: C is a hexadecimal digit.
						D: D is a hexadecimal digit.
						E: E is a hexadecimal digit.
						F: F is a hexadecimal digit.
						a: a is a hexadecimal digit.
						b: b is a hexadecimal digit.
						c: c is a hexadecimal digit.
						d: d is a hexadecimal digit.
						e: e is a hexadecimal digit.
						f: f is a hexadecimal digit.

				13) tolower:
					tolower function in C++ is used to convert a given character to its lowercase equivalent.
					It is part of the <cctype> header.

					#include <iostream>
					#include <cctype>

					int main() {
						char uppercaseChar = 'A';
						char lowercaseChar = tolower(uppercaseChar);

						std::cout << "Original character: " << uppercaseChar << std::endl;
						std::cout << "Lowercase character: " << lowercaseChar << std::endl;

						char nonUppercaseChar = '1';
						char unchangedChar = tolower(nonUppercaseChar);

						std::cout << "Original character: " << nonUppercaseChar << std::endl;
						std::cout << "Unchanged character: " << unchangedChar << std::endl;

						char mixedCaseChar = 'M';
						char convertedMixedCaseChar = tolower(mixedCaseChar);

						std::cout << "Original character: " << mixedCaseChar << std::endl;
						std::cout << "Converted character: " << convertedMixedCaseChar << std::endl;

						char specialChar = '$';
						char unchangedSpecialChar = tolower(specialChar);

						std::cout << "Original character: " << specialChar << std::endl;
						std::cout << "Unchanged character: " << unchangedSpecialChar << std::endl;

						return 0;
					}
					//output:
						Original character: A
						Lowercase character: a
						Original character: 1
						Unchanged character: 1
						Original character: M
						Converted character: m
						Original character: $
						Unchanged character: $

				14) toupper:
					The toupper function in C++ is used to convert a given character to its uppercase equivalent. 
					It is part of the <cctype> header.

					#include <cctype>
					#include <iostream>
					using namespace std;
					int main() {
						char c1 = 'A', c2 = 'b', c3 = '9', c4 = 'z', c5 = 'g';

						cout << toupper(c1) << endl;            //type conversion NOT used		//65
						cout << toupper(c2) << endl;  		//66
						cout << toupper(c3) << endl;			//57			(ASCII value of 9)
						cout << char(toupper(c4)) << endl;    //type conversion used	//Z
						cout <<(char) toupper(c5);            //type conversion used	//G

						return 0;
					}
					//output:
						65
						66
						57
						Z
						G
					
					#include <iostream>
					#include <cctype>

					int main() {
						char lowercaseChar = 'a';
						char uppercaseChar = toupper(lowercaseChar);

						std::cout << "Original character: " << lowercaseChar << std::endl;
						std::cout << "Uppercase character: " << uppercaseChar << std::endl;

						char nonLowercaseChar = '1';
						char unchangedChar = toupper(nonLowercaseChar);

						std::cout << "Original character: " << nonLowercaseChar << std::endl;
						std::cout << "Unchanged character: " << unchangedChar << std::endl;

						char mixedCaseChar = 'm';
						char convertedMixedCaseChar = toupper(mixedCaseChar);

						std::cout << "Original character: " << mixedCaseChar << std::endl;
						std::cout << "Converted character: " << convertedMixedCaseChar << std::endl;

						char specialChar = '$';
						char unchangedSpecialChar = toupper(specialChar);

						std::cout << "Original character: " << specialChar << std::endl;
						std::cout << "Unchanged character: " << unchangedSpecialChar << std::endl;

						return 0;
					}
					//output:
						Original character: a
						Uppercase character: A
						Original character: 1
						Unchanged character: 1
						Original character: m
						Converted character: M
						Original character: $
						Unchanged character: $

		-to take space, new line as input use cin.get() function.
			int a= cin.get();
			cout<<"A :: "<<a;
---------------------------------------------------------------------------------------------------------
	03/08/2023
Lecture-4: Solving Pattern Questions (Part-2)
	if 'return 0' is not there at the end still program works.
	Patterns solving
	1)	1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		1 2 3 4 5
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){            			//shorthand checking as well as incrementing king as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementingking as well as incrementing
					while(b <= n){          			//for be also you can increment while checking
						cout << b++ << " ";         	//shorthand (printing as well as incrementing)
						// b++;
					}
					b=1;
					// a++; 
					cout<<"\n";
				}

				return 0;
			}

	2)
		n = 5
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
			5 4 3 2 1
		->
			#include <iostream>
			using namespace std;		

			int main() {
			
				int n,a=1,b=1;
				
				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n) {          //shorthand
					while(b <= n){    
						cout << n - b +1<< " ";
						b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}

	3)
		1	2	3 	4	 5
		6	7 	8 	9	 10
		11	12 	13 	14	 15
		16 	17 	18	19	 20
		21 	22 	23	24	 25
		->
			#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1,counter=1;

				cout << "Enter n:: ";
				cin>>n;
				
				while(a++ <= n){          //shorthand
					while(b++ <= n){    //shorthand
						cout<<counter++<<"\t";
						// b++;
					}
					b=1;
					// a++;
					cout<<"\n";
				}
				return 0;
			}
	
	4) Start pattern for custom rows:
		Enter rows:: 5
			* 
			* * 
			* * * 
			* * * * 
			* * * * * 
		->
			#include <iostream>
			using namespace std;

			int main() {
			
				int n,a=1,b=1;
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){      //shorthand 
						cout<< "* ";
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			}
	
	5)
		take rows from user:
		 Enter rows:: 5
			1 
			1 2 
			1 2 3 
			1 2 3 4 
			1 2 3 4 5 
		->
			#include <iostream>
			using namespace std;

			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b <= a){      
						cout<< b++ <<" ";     //shorthand 
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}
			return 0;
			}
	
	6)
		take rows from user:
		 Enter rows:: 5
			1 
			2 2 
			3 3 3
			4 4 4 4
			5 5 5 5 5
		 ->
		 	#include <iostream>
			using namespace std;

			int main() {
				
				int n,a=1,b=1;
				
				cout << "Enter rows:: ";
				cin>>n;
				
				while(a <= n){
					while(b++ <= a){            //shorthand
						cout<< a <<" ";     
						// b++;
					}
					cout<<"\n";
					b=1;
					a++;
				}

				return 0;
			} 

	7)
		Take rows input from user..
			Enter rows:5
				1	
				2	3	
				4	5	6	
				7	8	9	10	
				11	12	13	14	15	
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,counter=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){        //shorthand
						while(b++ <= a){                    //shorthand
							cout << counter++ << "\t";      //shorthand
							// counter++;
							// b++;
						}
						b=1;
						a++;
						cout << "\n";
					}
					
					
					return 0;
				}

	8)
		Take user input for rows
			Enter rows:5
			1	
			2	3	
			3	4	5	
			4	5	6	7	
			5	6	7	8	9
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,temp;
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					temp = a;						//need to try without using extra var.
					while(b <= a){
						cout << temp++ << "\t";
						b++;
					}
					cout << "\n";
					a++;
					b=1;      //important step
				}
				return 0;
			}

			//or without using temp.
			#include <iostream>
			using namespace std;
			int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << a + b - 1 << "\t";
							b++;
						}
						cout << "\n";
						a++;
						b=1;      //important step
					}
					return 0;
			}
	
	9)
		Take user input for rows
			Enter rows:5
			1
			2 1
			3 2 1
			4 3 2 1
			5 4 3 2 1
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1,temp;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						temp = a;
						while(b <= a){
							cout << temp-- << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
			
			//or without using that extra temp variable

				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						// temp = a;
						while(b <= a){
							cout << a - b + 1 << "\t";
							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}

	10)
		Take user input for rows
			enter rows:3
				A A A
				B B B
				C C C
			->	
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a++ <= n){						//shorhand
						while(b++ <= n){					//shorhand
							cout << ch <<" ";
							//b++;
						}
						ch++;
						//a++;
						b=1;
						cout<< "\n";
					}

					//for above while loop short code.
					// 	while(a++ <= n){
					// 	    while(b++ <= n)1
					// 	        cout << ch <<" ";
					// 	    ch++;b=1;
					// 	    cout<< "\n";
					// 	}


					return 0;
				}
			
			//without using that extra char ch variable.
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				
				cout << "Enter rows:";
				cin>>n;
				
				//using char function to convert the int to char.
				
				while(a <= n){
					while(b++ <= n)
						cout << char('A' + a - 1) <<" ";

					b=1;
					a++;
					cout<< "\n";
				}
				return 0;
			}
	
	11)
		Take user input for rows
			enter rows: 3
				A B C
				A B C
				A B C
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';
				
				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
						cout << ch << " ";
						b++;
					}
					ch++;
					a++;
					b=1;
					cout << "\n";
				}
				
				return 0;
			}

			//or without using that extra ch
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							
							cout << char(64 + a) << " ";					//ASCII value of A is 65 so we purposefully added 64 before it.
							
							//or
							//cout << char('A' + a - 1) << " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}
					
					return 0;
				}
		
	12)
		Take user input for rows
			Enter rows:5
			A B C D E 
			F G H I J 
			K L M N O 
			P Q R S T 
			U V W X Y 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
						cout << ch++ << " ";			//shorhand for ch.
							b++;
							//ch++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	14)
		Take user input for rows
		Enter rows:5
			A B C D E 
			B C D E F 
			C D E F G 
			D E F G H 
			E F G H I 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1;
				char ch = 'A';

				cout << "Enter rows:";
				cin>>n;
				
				while(a <= n){
					while(b <= n){
					cout << ch++  << " ";
						b++;
						// ch++;
					}
					ch = 'A' + a;
					a++;
					b=1;
					cout << endl;
				}
				return 0;
			}

			//or without using that extra char ch.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;

					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= n){
							cout << char('A' + b - 1 + a - 1) << " ";			//to match the above pattern so we did adjustment.

							//or using ASCII value to print A , for first iteration (63 + 1 + 1 = 65) which is A.
							//cout << char(63 + b + a) << " ";
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	15)
		Take user input for rows
		  enter rows: 3
		  	A
			B B
			C C C
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
						cout << ch << " ";
						b++;
						}
						ch++;
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

			//without using ch char.
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + a - 1) << " ";

							//or
							//cout << char(64 + a) << " ";

							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	16)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				D E F 
				G H I J 
				K L M N O 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b++ <= a)				//shorhand for b first checking then incrementing.
							cout << ch++ << " ";
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	17)
		Take user input for rows
			Enter rows:5
				A 
				B C 
				C D E 
				D E F G 
				E F G H I
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							// cout << char('A' - 1 + b + a -1) << " ";
							// or
							cout << char(63 + b + a ) << " ";
							
							b++;
						}
						a++;
						b=1;
						cout << endl;
					}
					return 0;
				}

	18)
		Take user input for rows
			Enter rows:5
				E 
				D D 
				C C C 
				B B B B 
				A A A A A 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					char ch = 'A';
					
					cout << "Enter rows:";
					cin>>n;
					
					
					while(a <= n){
						while(b <= a){
							cout << char(ch + n - a)<< " ";

							//or without using that char ch.
							//cout << char('A' + n - a)<< " ";

							b++;
						}
						a++;
						b=1;
						cout << "\n";
					}	
					return 0;
				}

	19)
		Take user input for rows
			Enter rows:5
				E 
				D E 
				C D E 
				B C D E 
				A B C D E 
			->
				#include <iostream>
				using namespace std;
				int main() {
					int n,a=1,b=1;
					
					cout << "Enter rows:";
					cin>>n;
					
					while(a <= n){
						while(b <= a){
							cout << char('A' + n - a + b -1) << " ";
							b++;
						}
						a++;
						b=1;
						
						cout << "\n";
					}
					
					return 0;
				}

				//or short
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows:";
						cin>>n;
						
						while(a <= n){
							while(b <= a)
								cout << char(64 + n - a + b++) << " ";
							a++;b=1;
							cout << "\n";
						}
						return 0;
					}

	20)
		Take user input for rows
			Enter rows: 5
			     *
			    **
			   ***
			  ****
			 *****
			->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,c,temp;
			
				cout << "Enter rows: ";
				cin >>n;
				c=n;
				
				while(a <= n){  
					temp = c--;                 //shorthand for c
					while(temp >= 1){
						cout << " ";
						temp--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;
			}

			//or
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b=1,space;
			
				cout << "Enter rows: ";
				cin >>n;
			
				while(a <= n){
					space = n - a;
					while(space){
						cout << " ";
						space--;
					}
					// c--;
					while(b <= a){
						cout << "*";
						b++;
					}
					b=1;
					a++;
					cout << "\n";
				}
				return 0;			
			}

	21)
			Take user input for rows
				Enter rows: 5
					XXXXX
					XXXX
					XXX
					XX
					X
				->
					#include <iostream>
					using namespace std;
					int main() {
						int n,a=1,b=1;
						
						cout << "Enter rows: ";
						cin >>n;
						b=n;
						
						while(a <= n){
							while(b--){         //b shorthand
								cout << "X";
								// b--;
							}
							b=n-a++;        //a shorthand
							// a++;
							cout << endl;
						}
						return 0;
					}

	22)Take user input for rows
		Enter rows: 5
			* * * * * 
			  * * * * 
			    * * * 
			      * * 
			        * 
		->
		#include <iostream>
		using namespace std;
		int main() {
			int n,a=1,b, space;
			
			cout << "Enter rows: ";
			cin >>n;

			b = n;
			
			while(a <= n){
				space = a - 1;
				while(space--){         //space shorthand
					cout << "  ";
					// space--;
				}
				while(b--){             //b shorthand
					cout << "* ";
					// b--;
				}
				
				b= n - a;
				a++;
				cout << "\n";
			}
			return 0;
		}

	23)Take user input for rows
		Enter rows: 5
			1 1 1 1 1 
			  2 2 2 2 
			    3 3 3 
			      4 4 
			        5 
		->
			#include <iostream>
			using namespace std;
			int main() {
				int n,a=1,b, space;
				cout << "Enter rows: ";
				cin >>n;
				b = n;
				
				while(a <= n){
					space = a - 1;
					while(space--){         //space shorthand
						cout << "  ";
						// space--;
					}
					while(b--){             //b shorthand
						cout << a <<" ";
						// b--;
					}
					
					b= n - a;
					a++;
					cout << "\n";
				}	
				return 0;
			}

	24)Take user input for rows
		Enter rows:5
						1
					2	2
				3	3	3
			4   	4	4	4
		5  	5	5	5	5
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			space = n-1;
			
			while(i <= n){
				while(space--){                 //shorthand for space 
					cout << "  ";
					// space--;
				}
				
				while(j++ <= i){                //shorthand for j
					cout << i << " ";
					// j++;
				}
				i++;
				j = 1;
				
				space = n - i;          //important step.
				
				cout << "\n";
			}

			return 0;
		}

	25)Take user input for rows
	 Enter rows:4
		1 2 3 4
		  2 3 4
		    3 4
		      4
	 ->
	 	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){
				
				//spacing
				space = 1;
				while(space < i){
					cout << "  ";
					space++;
				}
				
				//printing num
				while(j <= n){
					cout << j << " " ;
					j++;
				}
				cout << "\n";
				i++;
				j=i;            //important step
			}
			return 0;
		}

	26)Take user input for rows
	    Enter rows:4
					1
				2	3
			4	5	6
		7	8	9	10
	   ->
	   	#include <iostream>
		using namespace std;

		int main()
		{
			int n,i=1,j=1,counter=1,space;
			
			cout << "Enter rows: ";
			cin >> n;
			
			while(i <= n){	
				//spacing
				space = n - i;
				while(space--){		//shorhand for space
					cout << "\t";
				}
				
				while(j <= i){
					cout << counter++ << "\t";
					j++;
				}
				i++;
				cout << "\n";
				j=1;
			}	
			return 0;
		}

	27)Take user input for rows
		Enter rows:4

						1
					1	2	1
				1	2	3	2	1
			1	2	3	4	3	2	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, k=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--) {
						cout << "  ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << j << " ";
						j++;
					}
					
					while(k < i){
						cout << i - k << " ";
						k++;
					}
					
					cout<<endl;
					k=1;
					j=1;
					i++;
				}				
				return 0;
			}

	28)Take user input for rows
		Enter rows:5
		1	2	3	4	5	5	4	3	2	1
		1	2	3	4	*	*	4	3	2	1
		1	2	3	*	*	*	*	3	2	1
		1	2	*	*	*	*	*	*	2	1
		1	*	*	*	*	*	*	*	*	1
		->
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space=1;
				
				cout << "Enter rows: ";
				cin >> n;
				
				while(i <= n){
					
					//start looping
					while(j <= n-i+1){              //important step
						cout << j  << " "; 
						j++;
					}
					
					//spacing
					while(space < i){
						cout << "* * ";
						space++;
					}
					
					//reverse loop
					while(--j){
						cout << j << " ";
					}
					
					//resetting the values
					j=1;
					space=1;
					
					cout << endl;
					i++;
				}
				return 0;
			}
			//output
				Enter rows: 5
					1 2 3 4 5 5 4 3 2 1 
					1 2 3 4 * * 4 3 2 1 
					1 2 3 * * * * 3 2 1 
					1 2 * * * * * * 2 1 
					1 * * * * * * * * 1 

	29) pyramid start pattern:
		Enter rows: 5
 			    * 
 			   * * 
 			  * * * 
 			 * * * * 
 			* * * * *
		->

			#include <iostream>
			using namespace std;

			int main()
			{
				int n, i=1, j=1, space;
				cout << "Enter rows: ";
				cin >> n;
				space = n;
				
				while(i <= n){
					
					//for space
					while(space--){
						cout << " ";
					}
					
					space = n - i;
					
					while(j <= i){
						cout << "* ";
						j++;
					}
					cout<<endl;
					j=1;
					i++;
				}
				return 0;
			}
---------------------------------------------------------------------------------------------------------
	04/08/2023
Lecture-5: Bitwise Operators, For Loops, Operator Precedence & Variable Scoping
	-Bitwise Operator
		This operator will work on BIT level.
			1). AND (&)
			2). OR (|)
			3). NOT (~)
			4). XOR (^)
		
		Let’s look at the truth table of the bitwise operators
			  Operator	Description				Example
				&		Bitwise AND	 			a & b
				|		Bitwise OR	 			a | b
				^		Bitwise XOR	 			a ^ b
				~		Bitwise NOT (Complement)		  ~a
				<<		Bitwise Left Shift			a << n
				>>		Bitwise Right Shift			a >> n


		Table:
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   a   |   b   | a & b | (a | b)| a ^ b |   ~a  | a << 1 | a >> 1 |
			+-------+-------+-------+--------+-------+-------+--------+--------+
			|   0   |   0   |   0   |   0    |   0   |   1   |   0    |   0    |
			|   0   |   1   |   0   |   1    |   1   |   1   |   0    |   0    |
			|   1   |   0   |   0   |   1    |   1   |   0   |   2    |   0    |
			|   1   |   1   |   1   |   1    |   0   |   0   |   2    |   0    |
			+-------+-------+-------+--------+-------+-------+--------+--------+


		eg.
			#include <iostream>
			#include <bitset>
			using namespace std;

			int main() {
				// Bitwise AND (&)
				int a = 12;  // 1100 in binary
				int b = 25;  // 11001 in binary
				int result_and = a & b;
				cout << "Bitwise AND: " << result_and << " (" << bitset<8>(result_and) << ")" << endl;  // Output: 8 (00001000)

				// Bitwise OR (|)
				int result_or = a | b;
				cout << "Bitwise OR: " << result_or << " (" << bitset<8>(result_or) << ")" << endl;  // Output: 29 (00011101)

				// Bitwise XOR (^)
				int result_xor = a ^ b;
				cout << "Bitwise XOR: " << result_xor << " (" << bitset<8>(result_xor) << ")" << endl;  // Output: 21 (00010101)

				// Bitwise NOT (~)
				int result_not = ~a;
				cout << "Bitwise NOT: " << result_not << " (" << bitset<8>(result_not) << ")" << endl;  // Output: -13 (11110011)

				// Bitwise Left Shift (<<)
				int n_left = 2;
				int result_left = a << n_left;
				cout << "Bitwise Left Shift: " << result_left << " (" << bitset<8>(result_left) << ")" << endl;  // Output: 48 (00110000)

				// Bitwise Right Shift (>>)
				int n_right = 2;
				int result_right = a >> n_right;
				cout << "Bitwise Right Shift: " << result_right << " (" << bitset<8>(result_right) << ")" << endl;  // Output: 3 (00000011)

				return 0;
			}
		
			Practice:
				#include <iostream>
				using namespace std;

				int main()
				{
					int a=4,b=6;
					
					cout<<"A&B "<< (a&b) << endl;           //4
					cout << "A|B "<< (a|b) << endl;         //6
					cout << "A^B "<< (a^b) << endl;         //2
					cout << "~A "<< (~a) << endl;           //-5
					
					//~a --> 32 bit
						// 4 ==> [-------- -------- -------- -----100] all bits are zero 
						// ~a ==> [11111111 11111111 11111111 11111011]    reverse of above 
						
						// from first bit you can say that it's -ve num.
						//     so before to print take its 2's complement
						//     1's complement [-------- -------- -------- -----100] adding + 1 in it.
						//     ==> [-------- -------- -------- -----101]
							//this above binary in decimal is 5 so ans is -5.
					return 0;
				}
		
		-Left shift:
			syntax.
				var << num;
			eg.
				5 << 1		ie.		101 after shifting 1 bit to left 1010, so 1010 is 10.
				3 << 2         ie. 		011 after shifting 2 bit to left 1100 so its 12.

		-NOTE: here you can see when we use left shift it will get multiplied by 2 in most cases.
				but BE CAREFULL SOMETIME IT WILL GENERATE AN -VE NUM ALSO, WHEN NUM IS TOO LARGE,
				SO, ITS NOT LIKE THAT WHEN WE DO LEFT SHIFT THEN IT'LL GET MULTIPLIED BY 2.
			
		-Right Shift:
			syntax.
				var >> num;
			eg.
				15 >> 1;			ie. right shift by 1 bit.
				
				5 >> 2;			ie. right shift by 2 bit,
								101 >> 2 -->	001 its 1.

				5/2 = 2 ------- pass 1
				2/2 = 1 ------- pass 2	
				so 5 >> 2 => 1
		
		NOTE: 
			either it is a left shift(<<) or right shift(>>) to any +VE NUM, 
			then num of bits padded with zero(0). (means zero will get added after shifting).

			else if the num is -ve then padding will depends on compiler
		
		eg.
			int a=1,b=2;

			if(a-- >0 && ++b > 2)				//it will check for b also cause && require all condition must be true
				cout<<"if";
			else
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 3 
		
			//OR
			int a=1,b=2;
			if(a-- >0 || ++b > 2)				//it will check for a only, cause one condition needs to be true,
				cout<<"if";					//so if first condition is true then control don't go for next condition & 
			else								//b won't get incremented also. check output
				cout<<"else";
			
			cout<<endl<<a<<" "<<b;		//0 2
		
	-For Loop:
		flow:
			once we visit initialization part, 
			then for next all iteration we just check the condition & updation value.

		for(initialize; condition; increment/ decrement){
			//statement
		}
		//or
		for(;;){
				
		}
		eg.
			for(int i=1; i<=5; i++){
				cout << i;
			}
			//or

			int i = 1;
			for(;;){
				if(i<=n){
					cout << i++ ;
				}else{
					break;
				}
			}

			//multiple
			for(int a=0, b=1; a>=0, b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;

			for(int a=0, b=1; a>=0 && b>=1; a--, b--)
				cout<<a<<" "<<b<<endl;
		
		1). WAP Sum of n
			#include <iostream>
			using namespace std;

			int main()
			{
				int n, sum=0;
				cout << "enter n ";
				cin>>n;
				for(int i =1; i<=n; i++)
					sum += i;
					
				std::cout <<"The sum of "<<n<<" num is "<<sum << std::endl;
				
				return 0;
			}
		
		2). WAP for Fibonacci series
			#include <iostream>
			using namespace std;

			int main()
			{
				int n,prev=0, cur=1,temp;
				cout << "enter n ";
				cin>>n;
				
				for(int i =1; i<=n; i++){
					
					cout << prev << " ";
					
					temp = cur + prev;
					prev = cur;
					cur = temp;
					
				}
					
				return 0;
			}
		
		3). check entered num is Prime num or not?
			#include <iostream>
			using namespace std;

			int main()
			{
				int n;
				cout << "Enter num : ";
				cin >> n;
				
				bool PRM = true;
				
				for(int i=2; i < n/2; i++)
					if(n % i == 0){
						PRM = false;
						break;
					}
				
				if(PRM)
					cout << n << " is prime num.";
				else
					cout << n << " is not prime num.";
				
				cout << endl << "END";
				return 0;
			}
		
		4). Print all prime nums between given range
			#include <iostream>
			using namespace std;

			int main()
			{
				int startNum, endNum;
				
				std::cout << "Enter Range to print all Prime nums in-between : " << std::endl;
				
				std::cout << "Enter Starting num :: ";
				std::cin >> startNum;
				
				std::cout << "Enter Ending num :: ";
				std::cin >> endNum;
				
				std::cout << "Prime nums in-between given range :: " << std::endl;
					
				for(int i = startNum; i <= endNum; i++){
					
					bool PRM = true;
					
					if( i == 1){
						std::cout << "1 neither prime nor composite" << std::endl;
						continue;
					}
					
					for(int j=2; j <= i/2; j++)
						if(i % j == 0){
							PRM = false;
							break;
						}
					
					if(PRM)
						std::cout << i << " is Prime num." << std::endl;
					else{
						// std::cout << i << " is not Prime num." << std::endl;
						continue;
					}
				}
				
				cout << endl << "END";
				return 0;
			}

		5). 

	-Variable & Scope:
		-You can't create same variable within single block.
		eg.
			#include <iostream>
			int main()
			{    
				int a =10;
				std::cout << a << std::endl;                //10
				
				if(true){
					std::cout <<"inside if before creating "<< a << std::endl;          //10
					int a = 89, b = 77;
					std::cout <<"inside if after creating "<< a << std::endl;           //89
					std::cout << "b = "<< b << std::endl;
				}
				
				// std::cout << "b" <<b<< std::endl;                       //you cant access b outside if block
				std::cout << "Outside if : "<< a << std::endl;          //10
				
				int i=1;
				for(int i= 5;i<=5;i++)
					std::cout << "HII" << std::endl;
					
				//below code works fine.
				if(1){
					int b;
					
					if(1){
						int b;
						
						if(1){
							int b;
							
							if(1){
								int b;
							}
						}
					}
				}
				std::cout << std::endl << "END";
				return 0;
			}

	-Operator Precedence:
		BODMAS
			-Brackets
			-Orders (Exponents and Roots): 
				Evaluate exponents and roots next. This includes calculations involving powers (^) and square roots (√).
			D - Division
			M - Multiplication
			A - Addition
			S - Subtraction
		
	-Practice:
		1].WAP print the difference of product & sum of given num.
		
			#include <iostream>
			using namespace std;

			int main()
			{
				int num;
				cout << "Enter num ";
				cin >> num;
				
				int sum =0 , prod=1;
				
				while(num > 0){
					int temp = num % 10;
					
					sum = sum + temp;
					prod = prod * temp;
					
					num = num / 10;
				}
				
				std::cout << "SUM "<< sum << std::endl;
				std::cout << "Product "<< prod << std::endl;
				std::cout << "Product - SUM "<< prod-sum << std::endl;
				
				cout << "END";
				return 0;
			}

		2]. WAP to count  Number of 1 Bits in given num:
			#include <iostream>
			using namespace std;

			int main()
			{
				int count =0,n=123;
				while(n > 0){
					if(n & 1){
						c++;
					}
					n >>= 1;
				}
				cout << "no.of 1 bit " <<count;
			}
		
		3]. Reverse integer

			int reverse(int n) {
				int rev = 0;
				while(n){
					if( rev > INT_MAX/10 || rev < INT_MIN/10)   return 0;		//if crossing the limit then return 0.
					rev = (rev * 10) +  n % 10;
					n /= 10;
				}
				return rev;
			}

			#include <iostream>
				using namespace std;
				int main()
				{
					int rev = 0, n;
					
					cin>>n; //123

						while(n > 0){
							int lastDigit = (n % 10);
							rev = rev * 10 + lastDigit;
							n /= 10;
						}
						cout << rev;
					return 0;
				}

			int reverse(int x) {
				int rev = 0, n = abs(x);				//abs() it convert num -ve to +ve, & +ve is +ve only. 

				while(n > 0){
					rev += (n % 10);
					
					if(n > 10){
						rev *= 10;
					}
					
					n /= 10;
				}
				if(x <0 )
					return -rev;
	
				return rev;
			}

			//using do-while loop.
			#include <iostream>
				using namespace std;

				int main()
				{
					int n;
					std::cout << "enter n:" << std::endl;
					cin>> n;
					int rev =0;
					
					do{
						rev = (n % 10) + rev * 10;
					}while(n /=10);
					
					cout<<"The Reverse "<< rev;
					return 0;
				}
	
		4]. WAP to find entered num is even or odd.
			#include <iostream>
			using namespace std;
				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					if( num % 2 == 0)
						cout << num << " is Even." <<endl;
					else
						cout << num << " is Odd." <<endl;

					//or
					//(num % 2 == 0)? std::cout << num << " is Even" : cout << num << " is odd";


					return 0;
				}

			//or without using modulo operator,
				cout << (num & 1 == 1); 
				-This part is attempting to check whether the least significant bit (LSB) of num is 1. 
				However, the code is not written correctly for this purpose.
				The issue lies in operator precedence. 
				The equality operator (==) has higher precedence than the bitwise AND operator (&). 
				So, the expression is evaluated like this:
					(num & (1 == 1))
				
				To fix this issue add parentheses,
					cout << ((num & 1) == 1);
				#include <iostream>
				using namespace std;

				int main()
				{
					//check num is Even or odd..
					int num;
					cout << "Enter num :";
					cin >> num;
					
					((num & 1) == 1) ? printf("%d is Odd num",num) : printf("%d is Even num.",num);

					//or
					//((num & 1) == 0) ? printf("%d is Even num.",num) : printf("%d is Odd num",num) ;
	
					return 0;
				}

			//or
				first division then multiply, it because of rounding in integer,
				#include <iostream>
				using namespace std;
				int main() {
					int num;
					std::cout << "Enter num: ";
					std::cin >> num;

					if((num / 2) * 2 == num)
						cout << "even"<<std::endl;
					else
						cout << "Odd"<<std::endl;
						
					std::cout << "End" ;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	05/08/23
Lecture-6: Binary & Decimal Num System
		1) Decimal to Binary
			-divide by 2.
			-Store remainder
			-repeat above 2 step until n != 0.
			-at last reverse the answer
			eg.
				5 -> 101
				7 -> 111
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main(){
					int num, i=0;
					std::cout << "Enter num :" << std::endl;
					cin>>num;
					
					int binaryForm = 0;
					cout << "Binary of " << num << " is ";
					
					while(num){
						int bit = num & 1;
						
						binaryForm = (bit * pow(10,i++)) + binaryForm;
						
						num >>= 1;          //num = num >> 1;
					}
					std::cout << binaryForm <<std::endl;	
					return 0;
				}

				//or
					#include <iostream>
					#include<algorithm>
					using namespace std;
					int main(){
						string s;
						int n = 8;
						while(n){
							s += to_string(n%2);
							n /= 2;
						}
						
						reverse(s.begin(), s.end());
						std::cout << s << std::endl;
						return 0;
					}
			
			eg. to keep same sequence of num.
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int a = 203,b=0,last,i=0;
					
					std::cout << a << std::endl;
					
					while(a){
						last = a % 10;
						b = b + last* pow(10,i++);
						a /=10;
					}

					cout<<b;
					return 0;
				}

			//Homework -ve num to binary
				->

		2) Binary to Decimal
			-multiply by 2's power to that numbers binary bit
			-if that bit is 1, then consider 2's power else ignore
			-last add all 2's power

				1 -> 1011

				=(2⁰ * 1) + (2¹ * 1) + (2² * 0) + (2³ * 1)
				=1+2+0+8
				=11.
			->
				#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int num,i=0;
					std::cout << "Enter num in binary : " << std::endl;
					cin>>num;            //1010
					
					int deci=0;

					//using while loop
					while(num){
						
						if(num % 10 == 1)					//if(num%10)
							deci = pow(2,i) + deci;
						i++; 
						num /= 10;
					}
					
					//or using do-while loop
					//do{
					//	if(num % 10 == 1)				//if(num%10)
					//		deci = pow(2,i) + deci;
					//	i++;
					//}while(num /=10);

					cout << "The Decimal num is :: "<<deci;
					return 0;
				}
		
		#Bitset:
			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<5> bits; // Creates a bitset with 5 bits, initialized to all zeros
				
				bits[2] = 1; // Set the third bit to 1
				std::cout << "Bitset value: " << bits << std::endl; // Output: 00100
				
				return 0;
			}

		eg.
			#include <bitset>
			std::bitset<8> bits; // Creates a bitset with 8 bits, defaultly initialized to all zeros
			std::bitset<8> anotherBits("10101010"); // Initializes the bitset with the given binary string

			std::bitset<32> thirtyTwoBits;   // Creates a bitset with 32 bits
			std::bitset<64> sixtyFourBits;   // Creates a bitset with 64 bits
			std::bitset<128> oneTwentyEightBits; // Creates a bitset with 128 bits, & all are zero.
			
			#include <iostream>
			#include<bitset>
			using namespace std;

			int main() {
				
				int n=9;
				bitset<32> bits (n);         //bitset<num> name (decimal_num_to_convert_into_binary);
				
				std::cout << n << "\t" << bits << std::endl;
				
				int a = 10;
				bitset<32> b2(a);
				std::cout << a << "\t" << b2 << std::endl;
				
				
				//converting bitset datatype value into string.
				string s = bits.to_string();
				std::cout << s << std::endl;
				
				int num = stoi(s,0,2);              //from binary to decimal coversion.
				std::cout << num << std::endl;

				bitset<12> nt;
				std::cout << nt << std::endl;       //000000000000
				return 0;
			}
		
		eg.
			it's okay to define a std::bitset<8> and initialize it with a binary string that has fewer than 8 characters. 
			The missing bits will be implicitly set to 0. In your example, std::bitset<8> anotherBits("101"), 
			since the binary string "101" has only 3 characters, the remaining 5 bits will be set to 0, 
			resulting in a bitset equivalent to "00000101".

			#include <bitset>
			#include <iostream>

			int main() {
				std::bitset<8> anotherBits("101"); // Initializes the bitset with "101"

				std::cout << "Bitset value: " << anotherBits << std::endl; // Output: 00000101

				//printing any binary num
					int n;
					cin>>n;
					std::cout << "n "<< bitset<8>(n) << std::endl;
   				
				return 0;
			}
				In this example, the std::bitset<8> is initialized with the binary string "101", 
				which fills the lower three bits. The remaining bits are automatically set to 0, 
				resulting in the bitset value "00000101".
---------------------------------------------------------------------------------------------------------
	06/08/23
Lecture-7: LeetCode Problem Solving Session
	eg.
		max/min int printing:
			#include<climits>				
				cout<<INT_MIN;				//minimum value of int stored in INT_MIN
				cout<<INT_MAX;				//maximum value of int stored in INT_MAX

	Practice:
		1]. Complement of base 10 integer
			5 -> 101
			complement -> 010
			which is 2 in decimal

			7 -> 111
			complement -> 000
			which is 0 in decimal

			#include <iostream>
				#include<bitset>
				using namespace std;

				int main()
				{
					
					int n;
					cin>>n;
					
					if(!n){                                 //if(n == 0)
						cout << "new num "<< !n;            //cout << "new num "<< 1;
						return 0;
					}
					
					int temp = n, mask=0;
					
					while(temp){
						mask <<= 1;              //mask = mask << 1;
						mask |= 1;               //mask = mask | 1;
						temp >>=1;               //temp =  temp >> 1;
					}
					
					n = (~n) & mask;
					
					cout << "new num "<<n;
					
					return 0;
				}

			LeetCode:
				int bitwiseComplement(int n) {

					if(!n){
						return !n;
					}

					int temp = n,mask=0;

					while(temp){
						mask <<=1;
						mask |= 1;
						temp >>= 1;
					}

					n = (~n) & mask;
					return n;
				}

		2]. Given num is representation of power of 2.	(hint if no.of setbits = 1 then that num is power of 2)
			#include <iostream>
				#include <math.h>
				using namespace std;

				int main()
				{
					int n,i=0;
					cin>>n;
					
					while(n >=1){
						int temp = pow(2,i++);
						if(n == temp){
							std::cout << "TRUE" << std::endl;
							return 0;
						}
						
						if(temp > n)
						{
							cout <<"FALSE";
							return 0;
						}
					}
					cout << "FALSE";
					return 0;
				}
				//or
					int main()
					{
						int a;
						
						std::cout << "Enter num " << std::endl;
						cin>>a;
						
						for(int i=0; ;i++){
							int temp = pow(2,i);
							if(temp == a){
								std::cout << "Yes power of 2" << std::endl;
								break;
							}
							
							if(temp > a){
								std::cout << "No it's not power of 2" << std::endl;
								break;
							}
						}
						
						std::cout << "END" << std::endl;
						return 0;
					}

			LeetCode:
				bool isPowerOfTwo(int n) {
					int temp=1;					
					while(n>=1){
						if(n == temp)
							return true;
						
						if(temp > n)
							return false;

						temp = temp * 2;
					}
					return false;
				}	

				//or
				if(n==0) return false;
				while(n%2==0) n/=2;
				return n==1;

			// power finding without using * & pow().
				#include <iostream>
				#include<cmath>
				using namespace std;
				int main(){
					
					int n=-9;
					int sqr =0;
					
					//without using *,/ or pow()
					if(n<0)
						n = -n;
					for(int i=1; i<=n; i++)
						sqr +=n;
					std::cout << sqr << std::endl;
					
					//using pow()
					std::cout << pow(n,2) << std::endl;
					
					//using *
					std::cout << n*n << std::endl;
					return 0;
				}
---------------------------------------------------------------------------------------------------------
	07/08/23
Lecture-8: Switch case & functions:
		syntax.
			switch(condition){
				case value_1 :
					//statement block ;
					break;
					
				case value_2:
					//statement block ;
					break;

				case value_3:
					//statement block;
					break;

				default:
					//statement block ;
			}
			--here for above case no need to use break after default, coz default is at the last of switch case,
				so it will automatically go out of switch case and continue with next line.

			--in place of condition in switch case [switch(condition)], you can keep integer or character value,
				but not float / string value.
				you can keep expression also, like	
				switch(a+b*10)		which generates an constant value.
				
			
			--default case is not mandatory, if its there in code then GOOD, if its not then NO WORRIES.
			--default case is better to keep at last,
		->		
			Include break after default: 
				If you want the switch statement to exit immediately after the default case is executed, 
				you should include a break statement. This prevents the program from continuing to execute 
				code in other case blocks that come after the default case.
				switch(condition){
					case value_1 :
						//statement block ;
						break;
						
					case value_2:
						//statement block ;
						break;

					default:
						//statement block ;
						break;
					
					case value_3:
						//statement block;
						break;
				}

				--if the code is like this above then better to keep the break after default, if you don't 
					write break; after default, then it'll continues to executes the next cases which are after default.

				Nested switch:
					switch(condition){
						case value_1 :
							//statement block ;
							break;
							
						case value_2:
							switch(condition){
									case value_1 :
										//statement block ;
										break;
										
									case value_2:
										//statement block ;
										break;

									default:
										//statement block ;
										break;
									
									case value_3:
										//statement block;
										break;
								}
							break;

						default:
							//statement block ;
							break;
						
						case value_3:
							//statement block;
							break;
					}
		
		eg.
			#include <iostream>
			using namespace std;

			int main()
			{
				int num = 1;
				char ch = '1';
				switch(ch){
					case '2':
						std::cout << "2nd Character" << std::endl;
						break;
						
					case '3':
						std::cout << "3rd Character" << std::endl;
						break;
						
					case '1':
						switch(num){
							case 1:
								std::cout << "1st Character Nested switch" << std::endl;
								break;
						}
						break;
						
					default:
						std::cout << "Default case" << std::endl;
				}
				return 0;
			}
			//output : 1st Character Nested switch

		-Function exit(0)
			--used to come out from infinite loop if we got stuck, without using break. 
			--The most common convention is to use exit(0) to indicate successful execution.
			--and exit(1) (or any non-zero value) to indicate an error or abnormal termination.

			#include <iostream>
			#include <stdlib.h>
			using namespace std;

			int main()
			{
				int num = 1;
				
				while(1){
					std::cout << num << std::endl;
					if(num > 10)
						exit(0);
					num++;
				}
			return 0;
			}
		
		Practice:
			#include <iostream>
				using namespace std;

				int main()
				{
					int a,b;
					char Op;
					
					std::cout << "Enter A :: ";
					std::cin >> a;
					std::cout << "Enter B :: ";
					cin>>b;
					
					cout<<"Enter Operation want to perform: ";
					cin>>Op;
					
					switch(Op){
						case '+':
							{
								std::cout << "Addition: " <<a+b << std::endl;				//you can use Brackets for cases also.
								break;
							}
							
						case '*':
							{
								std::cout <<  "Multiplication: " << a*b << std::endl;
							}
							break;
						
						case '-':
							std::cout <<  "Subtraction: " <<  a-b << std::endl;
							break;
						
						case '/':
							std::cout <<   "Division: " << a/b << std::endl;
							break;
						
						case '%':
							std::cout <<  "Remainder: " <<  a%b << std::endl;
							break;
						default:
							cout << "Not Matching Operation.\n";
					}
					
					std::cout << "END" << std::endl;
					return 0;
				}

			#include <iostream>
				using namespace std;

				int main()
				{
					int num;
					std::cout << "Enter Num : " << std::endl;
					cin >>num;
					
					switch(1){
						
					}
					int temp = num;
					//1234      =12
					
					std::cout << "you need "<< num/ 100 << " 100 notes" << std::endl;        //12
					num -= (num/100) * 100;                     //1234-1200 = 34
					
					std::cout << "you need "<< num / 50 << " 50 notes" << std::endl;         //0
					num -= (num/50) * 50;                                               //34
					
					std::cout << "you need "<<num/20 << " 20 notes" << std::endl;        //1
					num -= (num/20) * 20;                                           //34-20 =14
					
					std::cout << "you need "<< num/10 << " 10 notes" << std::endl;       //1
					num -= (num/10) * 10;                                       //14-10=4
					
					std::cout << "you need "<< num/1 << " 1 coins" << std::endl;       //4
					num = num;

					std::cout << "For "<<temp<<" Amout." << std::endl;
					
					std::cout << "END" << std::endl;
					return 0;
				}	

		Functions:
			A function is a block of code that performs a specific task.
			Suppose we need to create a program to create a circle and color it. We can create two functions to solve this problem:

				a function to draw the circle
				a function to color the circle
			Dividing a complex problem into smaller chunks makes our program easy to understand and reusable.

			There are two types of function:
				Standard Library Functions: Predefined in C++
				User-defined Function: Created by users 
			
			syntax to declare a function is:

				returnType functionName (parameter1, parameter2,...) {
					// function body   
				}

				Here's an example of a function declaration.
				
				// function declaration
				void greet() {
					cout << "Hello World";
				}

				Here,
					the name of the function is greet()
					the return type of the function is void
					the empty parentheses mean it doesn't have any parameters
					the function body is written inside {}
				
				Calling a Function
					In the above program, we have declared a function named greet(). 
					To use the greet() function, we need to call it.
					Here's how we can call the above greet() function.
						greet();
			eg.
				Power of n, pow(a,b);
					#include <iostream>
					using namespace std;

					int power(int, int);            //function declaration,because after main function
											//we are giving the function definition
					int main()
					{
						int a,b;
						std::cout << "Enter a, b :: " << std::endl;
						std::cin >> a>>b;
						
						int ans = power(a,b);
						
						cout<<"Power "<<ans;
						
						return 0;
					}

						int power(int a, int b){

							if(a == 0)                  //if(!a)
								return 0;       
							
							int t=a;
							while(--b){
								a = a * t;
							}
							return a;
						}
					
					//or
						Find power of a number
						#include <bits/stdc++.h> 
						#include <iostream>
						using namespace std;

						int main() {
							int n,x;
							cin>>x>>n;
							int ans = pow(x,n);
							int mod = 1e9+7;
							cout<< ans % mod;
							return 0;
						}

				Even Odd function:
					#include <iostream>
					using namespace std;

					bool isEven(int);        //function declaration

					int main()
					{
						int a;
						std::cout << "Enter a ";
						cin >> a;
						
						// (a&1)?cout<<"Odd":cout<<"Even";      
						//or
						
						isEven(a)?cout<<" Even": cout<< " Odd";         //using function
						
						return 0;
					}

						bool isEven(int num){
							if(num % 2 ==0)
								return 1;
							return 0;
						}

				nCr= n!/(r!* (n-r)!)
					#include <iostream>
					using namespace std;

					int fact(int);
					int nCr(int, int); 	          //function declaration  its not required if 
											//we defined function before main function
											//but here we are giving the function definition after main function.
					int main()
					{
						int n,r;
						cout<<"Enter n & r :: ";
						cin>>n>>r;
						
						cout<<n<<"C"<<r<<" = "<< nCr(n,r);
						return 0;
					}

						int nCr(int a, int b){
						
						int NMR = fact(a);                  //numerator
						
						int DNMR = fact(b) * fact(a-b);                     //denominator
						
						return NMR/DNMR;
					}

					int fact(int num){
					
						if(num == 0)
							return 1;
						int t = num;
						
						for(int i=1; i<t; i++)
							num *= i;                               //num = num * i;

						return num;
					}

				Printcouting:
					//void function returns nothing, 

					#include <iostream>
					using namespace std;

					// void printCouting(int);             //function declaration no need here coz 
												//we defined the function with its definition here.

					void printCouting(int c){
					for(int i=1;i<=c;i++)
						std::cout << i << std::endl;
					}

					int main()
					{
						int n;
						cin>>n;
						
						printCouting(n);
						
						std::cout << "END" << std::endl;
						return 0;
					}

				isPrime:
					#include <iostream>
					using namespace std;

					bool isPrime(int num){
						for(int i=2; i<= num/2; i++)
							if(num % i == 0)
								return 1;
						
						return 0;
					}

					int main()
					{
						
						int n;
						cin>>n;
						
						isPrime(n)? cout<<"NO "<<n<<" is NOT Prime num" :cout<<"Yes "<<n<<" is Prime num"; 

						return 0;
					}

				NOTE:
					You can use return in void returnType function without specifying any number;
					eg.
						This is OK.
						void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;							
								return ;
							}
						
						This is not OK.
							void isPrime(int num){
								for(int i=2; i<= num; i++)
									cout<<i;
								
								return 0;						//here return 0, void doesn't return anything will generate error.
							}

			function calling stack:
				FILO	: First in Last out
			
			-Parameter/ argument:
				Formal Parameter:
					-A variable and its type as they appear in the prototype of the function or method.
					-Formal parameters are declared in the function signature and 
					 act as placeholders for values that the function will receive.
					 eg.
					 	void displayNumber(int num); // Formal parameter: "int num"

				Actual Parameter: 
					-The variable or expression corresponding to a formal parameter that appears in 
					 the function or method call in the calling environment.
					-Actual parameters (arguments) are the specific values that are 
					 provided to the function when it is called, corresponding to the formal parameters
					eg.
						displayNumber(42); // Actual parameter: "42"

			-Pass by Value/ call by value:
				#include <iostream>
				using namespace std;
				void func(int n){						//formal parameter
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90
					func(n);											//91			//Actual parameter
					std::cout << "After func: "<< n << std::endl;			//90
					return 0;
				}

			-Pass by reference/ call by reference:
				#include <iostream>
				using namespace std;

				void func(int &n){
					n++;
					std::cout << "Inside func: "<< n << std::endl;
				}

				int main()
				{
					int n = 90;
					std::cout << "Before func: "<< n << std::endl;			//90

					//pass by reference- sending memory 
					func(n);											//91
					
					std::cout << "After func: "<< n << std::endl;			//91
					return 0;
				}

			Homework:
				1)ArithmeticProgression  = 3 * n +  7 make function of it.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int n;
							std::cout << "enter n: " << std::endl;
							cin>>n;
							
							std::cout << "The Arithmetic Progression for "<< n << " is "<< (3*n)+7;
							return 0;
						}

				2)Total no.of set bits (1) from given 2 numbers.
					eg.
						2 -> 10 			->1
						3 -> 11			->2
						Total set bits : 1+2 = 3
					->
						#include <iostream>
						#include <bitset>
						using namespace std;

						int setBitCouter(int z){
							int counter=0;
							
							while(z != 0){
								if(z&1)
									counter++;
								z >>=1;
							}
							return counter;
						}

						int main()
						{
							int a,b;
							std::cout << "enter a: ";
							cin>>a;
							
							std::cout << "enter b: ";
							cin>>b;
							
							std::cout << "Binary if a :: "<< bitset<32>(a) << std::endl;
							std::cout << "Binary if b :: "<< bitset<32>(b) << std::endl;
							
							//couting the no.of setbits, for a
							int sbA = setBitCouter(a);
							
							//for b
							int sbB = setBitCouter(b);
							
							std::cout << "The no.of setbits in "<<a<< " & "<<b<<" is "<< sbA+sbB << std::endl;
							
							return 0;
						}

					#include <iostream>
					using namespace std;
					int main(){
						int n=3;
						int ans = __builtin_popcount(n);
						std::cout << ans << std::endl;
						return 0;   
					}

				3)Fibonacci series nth term function:
					input: n = 5;			// 0 1 1 2 3 5 8 13
					output: 3			//5th num of that series.
					->
						#include <iostream>
						using namespace std;

						int main()
						{
							int prev= 0, curr= 1;
							
							int n;
							cout<<"Enter n:";
							cin>>n;
							
							int i=0;
							
							for(;i<n-1; i++){
								// cout<<prev<<" ";            
								
								int next = prev + curr;
								prev = curr;          
								curr = next;          
							}
							
							std::cout << "The "<< i+1 <<" number term is "<< prev << std::endl;
							return 0;
						}

			Local variable: 
				A variable declared within a function or a block of code is called a local variable. 
				Local variables are frequently used to temporarily store data in a defined 
				scope where they can be accessed and manipulated. They are stored in the memory stack, 
				Once the function or block of code in which the local variable is declared finishes executing. 
				The variable is automatically removed from the memory.

		2]. Number complement

			#include <iostream>
			#include <bitset>
			using namespace std;
			int main()
			{
				int n;
				std::cout << "Enter num : " << std::endl;
				cin>>n;
				
				cout<<"Binary of "<<n<<" "<<bitset<32>(n)<<endl;
				std::cout << "Complement of above binary "<< bitset<32>(~n) << std::endl;
				
				return 0;
			}
			
		3]. Square root of n ❌
---------------------------------------------------------------------------------------------------------
	08/08/23
Lecture-9: Introduction to Arrays in C++
	Introduction to Arrays
		-Array is a collection of variables of the same type.
		-Arrays are used to store multiple values of same Datatype in a single variable, 
		 instead of declaring separate variables for each value.
		-To declare an array, define the variable type, specify the name of the array 
		 followed by square brackets and specify the number of elements it should store

		-All arrays consist of contiguous memory locations. 
		 The lowest address corresponds to the first element and the highest address to the last element.

		-Array elements/ value we can access by INDEX.
		-Array start from 0.
		-defaultly they contain garbage value inside it.
		-use index num to access value of array on that location.
		
		-size of array = n, then till (n-1) index we can access.

		-Array declaration:
			 int a[10] ={1,2,3};         //ok
    
			int b[3] = {1,2,3};         //ok
			
			int c[] = {1,2,3,4,5,6,7};      //ok
			
			// int d[2] = {1,2,3,4,5,6,7};     //not ok
			
			// int e[];            //not ok

			// int f[10];              //not ok
			// f[10] = {1,2,2};
			// f[] = {1,2,4,3};

			int g[15];				//ok
	
		-declararing array with random/ Garbage value:
			int a[10];
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

		-Initializing all array element with 0.
			int a[10] ={0};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			-When you try to initialize some elements of array, they will get your specified value, 
				& rest all element of array elements become zero.

			--here in above case first element is initialized with 0, & rest all become will initialized with zero. 
		
		-Initializing all array element with 1 WON'T WORK ❌, only with 0 it will work.
			int a[10] ={5};		
			for(int i=0;i<10;i++)
				cout<<i<<" "<<a[i]<<"\n";

			In the above example, only the first element will be initialized to 5. All others are initialized to 0.

		--Here in below
			example you can see that if you try to initialize any position's value in array,
			then that position will get specified mentioned value, rest all by default initialized with zero.

			#include <iostream>
			using namespace std;

			int main()
			{
				int a[10] = {2,8};
				a[9]=90;
				a[5]=60;
				
				for(int i=0;i<10;i++)
					std::cout << i <<" "<<a[i]<< "\t";					
					
				return 0;
			}
				//2       8       0       0       0       60      0       0       0       90
			
		-To initialize array element with some default value,
			int a[10];
			for(int i=0;i<10;i++)
				a[i] = 4;
			
			for(int i=0; i<10;i++)
				std::cout << i << " " << a[i] << std::endl;
			
			//or using fill_n method
			std::fill_n(arrayName, arraySize, defaultValue);

			std::fill_n(a,10,90);

		string cars[4];
		eg.
		 int a[] = {1,2,3};
		 std::cout << sizeof(a) << std::endl;			//each int size is 4 so here, 12.

		 int b[] = {1,2,3,4};
		 std::cout << sizeof(b) << std::endl;			//each int size is 4 so here, 16.

		 //to print memory address of variable stored use &.
		 	int b=90;
			cout<< "memory location of B :: "<<b<<" "<<&b;

		for array just print the variable name it will give the memory address
			int a[] = {1,2,3};
			cout<< "memory location of Array a :: "<<a<<" "<<&a<<endl;			//this both a & (&a) will print the same thing.
		
		-Index accessing:
			int a[5] ={1,2,3,4,5};
				//100 , 104, 108, 112, 116			--memory address.
			
			-variable a will store the base address.
			-Suppose 100, first element's address, the next will be 104, next 108 coz size of int is 4 byte.

			a[0];			//base address	100, output value will be 1
			a[3];			//(base address + indexNum * sizeOfDatatype) =100 + 3*4 = 112, value will be 4.
        
	   	----External Link---------
			https://www.tutorialspoint.com/cplusplus/cpp_arrays.htm	
		-------------

		-If we try to access the index which is greater than size of array,
			then you will get an GARBAGE value.
		
		-Finding array length
			we can find the length using sizeof operator,
			-first find the sizeof whole array
			-then divide it by sizeof Datatype of that array.
			eg.
				int a[10];
				sizeof (a); //output : 40
				sizeof(int);	//output:4
				sizeof (a)/sizeof(int); //output : 10

			BUT,here in below case we initialized just 2 element then it should show the 
				length is 2 but according to that above method it will print length as whole 
				array size. drawback.
				eg.
					int b[10]={1,5};			//length:2
					int len = sizeof(b)/sizeof(int);		//len: 10 		(not expected this.)

		-Advance for loop in c++:
			int b[10] = {90};

			for(int j: b){
				cout<<j<<"\t";
			}

			for(int i: b)
				cout<<i<<"\t";
		
		-BAD Practice:
			int size;
			cin>>size;

			int arr[size];				//never do this.
				//instead of doing like this directly mention constant as size of array thats better,
			int arr[10000];			//this is ok than above

		-Practice:
			1.Array:
				#include <iostream>
				using namespace std;
				void printArray(int[], int);        //function declaration says that takes input parameter first as array, 2nd is integer

				int main()
				{
					//creating array & initializing
					int arr[10]= {1,2,3,4,5,6,7,8,9,10};
					
					//printing it,
					for(int i=0;i<10;i++)
						std::cout << arr[i] << "\t";
						
					std::cout << std::endl;     //or
					
					//printing using function
					printArray(arr, 10);
					
					std::cout << std::endl;
					
					//using advance loop,
					for(int j: arr)
						cout << j << "\t";
					
					return 0;
				}

				void printArray(int v[],int size){
					for(int i=0;i<size;i++)
						std::cout << v[i] << "\t";
				}

			2.Min/Max Array:
				#include <iostream>
				#include <climits>
				using namespace std;

				void getMax(int n[], int len){
					int maxi = INT_MIN;
					
					for(int a=0; a<len; a++){
						
						// if(maxi < n[a]){
						//     maxi = n[a];
						// }
						
						maxi = max(maxi, n[a]);     //it will compare these 2 values we passed then 
												// decides which one is maximum & stores maximum value.
					}
					cout<<"MAX : "<<maxi;
				}

				void getMin(int k[], int L){
					int mini = INT_MAX;
					
					for(int a=0; a<L; a++){
						
						// if(mini > k[a]){
						//     mini = k[a];
						// }
						
						//or using built in function
						mini = min(mini,k[a]);       //it will compare these 2 values we passed then 
												// decides which is min & stores minimum value
					}
					
					cout<<"Min : "<<mini;
				}

				int main(){
					int array[100];
					
					int size;
					std::cout << "Enter size of array : (should be <100)" << std::endl;
					cin>>size;
					
					std::cout << "Enter "<<size<<" elements in array :" << std::endl;
					
					//taking array elements
					for(int i=0; i<size; i++)
						cin>>array[i];
						
					//printing array
					for(int o=0; o<size; o++)
						cout<<array[o]<<" ";
					
					std::cout << std::endl;
					getMax(array,size);
					
					std::cout << std::endl;
					getMin(array,size);
					
					return 0;
				}

		-Passing array to function:
			--here passing array to function means passing memory address of that array to function,
			  so as we learnt name of array holds the base/ starting memory address of array.
			  eg.
			  	int ar[10];		//here ar holds the memory address, so if we pass ar to function
								//then we passing memory address of array, not copy of array.
			
			--so if you update the array inside any other function also, this will affect 
			  the original array.
			eg.
				#include <iostream>
				using namespace std;

				void UpdateArr(int z[], int len){
				
					z[5] = 500;			//updating value at 6th location.
					
					std::cout << "Inside Update function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<z[i]<<"\t";
						
					cout<<"\n";
				}

				int main(){
					int arr[100] = {1,2,3,4,5,6,7,8,9,10};
					
					std::cout << "Inside main function array: " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					std::cout  << std::endl;
					UpdateArr(arr, 10);
					
					std::cout << "Back to main function again Now Array : " << std::endl;
					for(int i=0;i<10;i++)
						cout<<arr[i]<<"\t";
						
					return 0;
				}
				//output:
					Inside main function array: 
					1       2       3       4       5       6       7       8       9       10
					Inside Update function array: 
					1       2       3       4       5       500     7       8       9       10
					Back to main function again Now Array : 
					1       2       3       4       5       500     7       8       9       10

				Sum of array elements:
					#include <iostream>
					using namespace std;

					int SUM(int z[], int len){	
						int sum =0; 
						
						for(int i=0;i<10;i++)
							sum += z[i];
							
						return sum;
					}

					int main()
					{
						int arr[100] = {1,2,3,4,5,6,7,8,9,-10};
						
						int sum = SUM(arr,10);
						std::cout << "Sum of Array elements :: "<< sum << std::endl;	//Sum of Array elements :: 35
						
						return 0;
					}

					//in reverse order
						int sumElement(int arr[],int n){
							int s=0;
							//Your code here
							while(n)
								s += arr[--n];
							return s;
						}


				Reverse Array:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						
						//Array
						for(int q: arr)
							std::cout << q << "\t";                 //use this advance loop if your are using whole size of array.
							
						std::cout << std::endl;
						
						//printing array in reverse way. means not reversing actual array.
						for(int i=9; i>=0; i--)
							cout<< arr[i]<<"\t";
						
						//for this you should know the length of array
						//array reversed.
						int len = 10;
						for(int i=0; i<len/2; i++){
							
							int temp = arr[i];
							arr[i] = arr[(len-1)-i];
							arr[(len-1)-i] = temp;
						}
						
						//printing original array
						std::cout << std::endl;
						for(int i: arr){
							cout<<i<<"\t";
						}
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;

						void reverse(int arr[], int n) {

							int start = 0;
							int end = n-1;

							while(start<=end) {
								swap(arr[start], arr[end]);
								start++;
								end--;
							}
						}

						void printArray(int arr[], int n) {
							
							for(int i=0; i<n; i++) {
								cout << arr[i] << " ";
							}
							cout << endl;
						}

						int main() {

							int arr[6] = {1,4,0,5,-2,15};
							int brr[5] = {2,6,3,9,4};

							reverse(arr, 6);
							reverse(brr, 5);

							printArray(arr, 6);
							printArray(brr, 5);

							return 0;
						}

				Linear search:
					#include <iostream>
					using namespace std;

					int main()
					{
						int arr[10]= {1,2,3,4,5,6,7,8,9,10};
						int key;
						
						std::cout << "enter key: " << std::endl;
						cin>>key;
						
						for(int i=0;i<10;i++){
							if(arr[i] == key){
								std::cout << "Key Found, at "<< i << std::endl;
								break;
							}
							
							if(i==9)
								std::cout << "Key Not Found." << std::endl;             //array traversed till last but didn't found key
						}
							
						return 0;
					}
---------------------------------------------------------------------------------------------------------
	09/08/23
Lecture-10: Solving LeetCode/CodeStudio Questions [Arrays]
	Alternate swap
		i/p-> {1,2,3,4,5,6};
		o/p-> {2,1,4,3,6,5};
		->
			#include <iostream>
			using namespace std;

			void swapAlternate(int ar[], int size){
    
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = ar[i];
					//     ar[i] = ar[i+1];
					//     ar[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(ar[i],ar[i+1]);
				}
			}


			int main()
			{
				int a[100];
				
				int size;
				std::cout << "Enter size of array:" << std::endl;
				cin>>size;
				
				cout<<"Enter "<< size << "elements in array: ";
				
				//inputing array elements
				for(int i=0;i<size;i++)
					cin>>a[i];
				
				//printing array.
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";
					
				
				for(int i=0; i<size; i +=2){
					// if((i+1)<size){
					//     int temp = a[i];
					//     a[i] = a[i+1];
					//     a[i+1] = temp;
					// }
					
					// or
					
					if((i+1)<size)
						swap(a[i],a[i+1]);
				}

				//or using function
				//swapAlternate(a, size);
				
				cout<<"\n";
				
				for(int i=0; i<size; i++)
					cout<<a[i]<<"\t";

				return 0;
			}

	-find unique element in array
		(hint: XOR with same num will give output 0) a ^ a =0
		eg.
			5 ^ 5 = 0
		(XOR with zero & any other num will output the same num ) 0 ^ a = a
		eg.
			0 ^ 5 = 5
			0 ^ 23 = 23.
		->
			int findUnique(int arr, int size){
				int ans = 0;
				for(int i=0;i<size;i++)
					ans = ans ^ arr[i];

				return ans;
			}
	
	-check the occurence of elements are unique or not?
		bool uniqueOccurrences(vector<int>& arr) {
			vector<int> ans;

			int counter=1;
			
			for(int i=0;i<arr.size(); i++){
				int temp = arr[i];
				if(arr[i] == -2000)
					continue;
				for(int j=i+1; j<arr.size();j++){
					if(temp == arr[j]){
						arr[j] = -2000;
						counter++;
					}
				}
				ans.push_back(counter);
				counter=1;
			}

			for(int i=0; i<ans.size(); i++){
				int temp = ans[i];
				for(int j=i+1; j<ans.size(); j++){
					if(temp == ans[j])
						return false;
				}
			}
			return true;
		}

	-find duplicate element in array
		Vector- It's dyanamic kind of thing.

		//not optimized
			int n = arr.size();
			for(int o=0;o<n;o++){
				int t = arr[o];

				if(o<n-1)
					for(int i=o+1; i<n; i++)
						if(t == arr[i])
							return t;
			}
		
		//optimized
			int findDuplicate(vector<int> &arr) 
			{
				// Write your code here
				int ans =0;

				//first we initialized the ans to 0 coz xor 0 with any other num will
				//give ans as that num only.

				//then we run for loop 0 to till length of array some answer will come,
				//again we will run loop from 1 to length-1 of array means to skip any one value.
				//then the answer will be duplicate value.

				for(int a=0; a<arr.size(); a++)
					ans = ans ^ arr[a];
				
				//we are doing xor with a directly coz there is only one duplicate element
				//& array contain the element from 1 & n-1 at least once
				for(int a=1; a< arr.size(); a++)
					ans = ans ^ a;

				return ans;
			}

	-find all duplicates num in array.
		//dyamica array in c++
			#include <iostream>
			#include <vector>
			int main() {
				// Write C++ code here
				//dynamic array
				
				std::vector<int> arr = {1,2,3};
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
					
				arr.push_back(100);
				
				std::cout<<"\n";
				
				arr.push_back(200);			//inserting num in array.
				
				for(int i=0;i<arr.size(); i++)
					std::cout<<arr[i]<<" ";
				
				return 0;
			}

		//brute force-> TIME LIMIT EXCEEDED
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				for(int a=0; a< nums.size(); a++)
				{
					int temp = nums[a];
					for(int b =a+1; b< nums.size(); b++){
						if(temp == nums[b]){
							dual.push_back(nums[b]);
							break;
						}
					}
				}
				return dual;
			}

		//optimized
			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;
				sort(nums.begin(), nums.end());			//built in function to sort array.

				for(int a=1; a< nums.size(); a++)
				{
					if(nums[a-1] == nums[a]){
						dual.push_back(nums[a]);
					}
				}
				return dual;
			}

			vector<int> findDuplicates(vector<int>& nums) {

				vector<int> dual;			//dynamic array.
				set<int> st;				//set which contains any element once only.

				for(int a=0; a< nums.size(); a++)
				{
					if(st.count(nums[a])){				//count method return 1 if that element present in set, else 0.
						dual.push_back(nums[a]);
					}else{	
						st.insert(nums[a]);				//insert method will insert that element/value into set.
					}
				}
				return dual;
			}

	-Sorting array:
		#include <iostream>
		#include <set>
		#include<algorithm> //mandatory for sort functionality
		using namespace std;

		int main() {
			// Write C++ code here
			int nums[] = {5,4,3,2,1};
			
			int len = sizeof(nums)/sizeof(nums[0]);     //calculating the length of array. 
												//this works if complete array which length is specified is filled completely, like a[100], then all 100 elements should be present.
												//or they if left length of array empty, like int arr[] = {1,2,3};
			
			for(int i=0;i<len; i++)
					cout<<" "<<nums[i];
					
			cout<<"\n";
			
			sort(nums, nums+len);			//from base(starting) address to till last
			
			//sort(starting array_memory_address, end array_memory_address);
			
			for(int i=0;i<len; i++)
				cout<<" "<<nums[i];
			return 0;
		}
	
	-sort & reverse array:
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> holder = {5,9,3,10,8,4,1,2,6,7};
			
			std::cout << "The size of array is :: " << holder.size() << std::endl;
			
			//sorting first 5 elements only.
			//output = 3,5,8,9,10,4,1,2,6,7
			
			std::cout << "Before sorting: " << std::endl;
			for(int i: holder)
				std::cout << i << "\t";             //5,9,3,10,8,4,1,2,6,7.
				
			std::cout << std::endl;
			std::cout << "After sorting first 5 elements: " << std::endl;
			
			sort(holder.begin(), holder.begin()+5);
			for(auto i: holder)
				std::cout << i << "\t";             //3,5,8,9,10,4,1,2,6,7
			
			std::cout << std::endl;
			cout<<"sorting array in increasing order: \n";
			sort(holder.begin(), holder.end());
			
			for(int o: holder)
				std::cout << o << "\t";
				
			std::cout << std::endl;
			cout<<"sorting array in decreasing order: \n";
			sort(holder.begin(), holder.end(), greater<int>());
			
			for(int o: holder)
				std::cout << o << "\t";
				
			//reversing the array
			std::cout << std::endl;
			cout<<"Reversing the given array: \n";
			reverse(holder.begin(), holder.end());
			
			for(int o: holder)
				std::cout << o << "\t";
				
			
			//sorting first 5 elements in decreasing order
			std::cout << std::endl;
			cout<<"sorting first 5 elements in decreasing order: \n";
			sort(holder.begin(), holder.begin()+5, greater<int>());
			
			for(int o: holder)
				std::cout << o << "\t";
			
			//Reversing first 6 elements
			std::cout << std::endl;
			cout<<"Reversing first 6 elements: \n";
			reverse(holder.begin(), holder.begin()+6);
			
			for(int o: holder)
				std::cout << o << "\t";
			return 0;
		}
		//output:
			The size of array is :: 10
			Before sorting: 
			5       9       3       10      8       4       1       2       6       7
			After sorting first 5 elements: 
			3       5       8       9       10      4       1       2       6       7
			sorting array in increasing order: 
			1       2       3       4       5       6       7       8       9       10
			sorting array in decreasing order: 
			10      9       8       7       6       5       4       3       2       1
			Reversing the given array: 
			1       2       3       4       5       6       7       8       9       10
			sorting first 5 elements in decreasing order: 
			5       4       3       2       1       6       7       8       9       10
			Reversing first 6 elements: 
			6       1       2       3       4       5       7       8       9       10

	-Set:
		-set by default store element in ascending order,
		-set store unique elements. not duplicate.
		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.
		eg.
			std::set <data_type> set_name;

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values

			//to check element present in set or not use count method with parameter in it.
			val.count(5);			//if that value present in set it returns 1
			val.count(12);			//if that value absent in set it returns 0
		Pratical:
			#include <iostream>
			#include <set>
			using namespace std;
			int main() {
				std::set<int> a;
				a.insert(10);
				a.insert(9);
				a.insert(7);
				
				a.insert(9);        //these 2 values won't get added.
				a.insert(7);
				
				a.insert(90);
				a.insert(70);
				
				
				a.insert(23);
				a.insert(34);            //inserting into set.


				cout<<*a.begin()<<"\t";     //return first element of set.
				
				cout<<*a.end()<<"\t";       //return the last element index, Length of set

				//length of set:
				cout<<"\n the length of set A is :: "<<a.size();

				//printing set
				for (int str : a) {
					cout << str << ' ';
				}
				
				cout<<"\n";
				cout<<"is 12 present in set A :: "<<a.count(12);			//0 means not present
				cout<<"is 10 present in set A :: "<<a.count(10);			//1 means present
				
				std::cout << '\n';

				return 0;
			}
		
			//printing char set,
			--need to define the iterator on it which is character (char) type.
				set<char> set1;
				set<char> :: iterator MY;
				for(MY = set1.begin(); MY != set1.end(); MY++){
					cout<< *MY;
				}

	-Array intersection (common element from 2 array).
		Intersection Of Two Sorted Arrays
		Constraints:
			1 <= T <= 100
			1 <= N, M <= 10^4
			0 <= A[i] <= 10^5
			0 <= B[i] <= 10^5
			Time Limit: 1 sec
		
		Sample Input 1 :
			2				T		test cases
			6 4				N M
			1 2 2 2 3 4		A	array 
			2 2 3 3			B	array

			3 2				N M  lengths
			1 2 3			array A
			3 4  			array B
		Sample Output 1 :
			2 2 3		
			3   
		Explanation For Sample Input 1 :
			For the first test case, the common elements are 2 2 3 in both the arrays, so we print it.
			For the second test case, only 3 is common so we print 3.
		->
			//Time Limit EXCEEDED (TLE)
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;

					for(int i=0; i<n; i++){
						int temp = arr1[i];

						for(int j=0; j<m; j++){
							if(temp == arr2[j]){
								common.push_back(temp);
								arr2[j] = -1;
								break;
							}
						}
					}
					return common;
				}
			
			//optimized:
				#include <bits/stdc++.h> 
				vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
				{
					// Write your code here.
					vector<int> common;
					int i=0,j=0;
					
					while(i<n && j<m){
						if(arr1[i] == arr2[j]){
							common.push_back(arr1[i]);
							i++;j++;
						}else if(arr1[i]< arr2[j]){
							i++;
						}else{
							j++;
						}
					}
					return common;
				}

	-Pair sum
		-https://www.codingninjas.com/studio/problems/pair-sum_697295
		Sample Input 1:
		5
		1 2 3 4 5
		Sample Output 1:
		1 4
		2 3

		Explaination For Sample Output 1:
		Here, 1 + 4 = 5
			2 + 3 = 5
		Hence the output will be, (1,4) , (2,3).
		
		Sample Input 2:
		0
		2 -3 3 3 -2
		Sample Output 2:
		-3 3
		-3 3
		-2 2

		#include <bits/stdc++.h>
		vector<vector<int>> pairSum(vector<int> &arr, int s){
			vector< vector<int> > ans;

			for(int i=0; i<arr.size(); i++){
				for(int j=i+1; j<arr.size(); j++){
					if(arr[i]+arr[j] == s){
						vector<int> temp;
						temp.push_back(min(arr[i], arr[j]));            
						temp.push_back(max(arr[i], arr[j]));
						ans.push_back(temp);
					}
				}
			}
			sort(ans.begin(), ans.end());
			return ans;
		}
		
	-Triplet sum:
		#include <bits/stdc++.h> 
		vector<vector<int>> findTriplets(vector<int>arr, int n, int K) {  
			sort(arr.begin(),arr.end());
				vector<vector<int>>ans;
			set<vector<int>> s;
			for(int i=0;i<n;i++){
				int sum = K - arr[i];
				int j = i+1;
				int k = n-1;
				while(j<k){
						if(arr[j]+arr[k] == sum){
							vector<int> temp;
							temp.push_back(arr[i]);
							temp.push_back(arr[j]);
							temp.push_back(arr[k]);
							sort(temp.begin(),temp.end());
							s.insert(temp);
							j++;
						}
					else if(arr[j]+arr[k]<sum){
						j++;
					}
					else{
						k--;
					}
				}
			}
			for(auto val: s){
				ans.push_back(val);
			}
			return ans;
		}

	-sort 0's & 1's:
		#include <iostream>
		using namespace std;

		void printArr(int a[], int n){
			for(int i=0;i<n; i++){
				cout<<a[i] << "\t";
			}
			cout<<"\n";
		}

		int main() {
			int arr[] = {1,1,1,1,1,0,0,0,0,0};
			int len = 10;
			printArr(arr, len);
						
			int i=0, j = len-1;
			while(i <= j ){
				if(arr[i] > arr[j]){
					swap(arr[i],arr[j]);
					i++;j--;
				}else if(arr[i] < arr[j]){
					i++;
				}else if(arr[i] ==  arr[j]){
					j--;
				}
			}
			
			printArr(arr, len);
			return 0;
		}

	-sort 0's, 1's & 2's:
		remain.. ❌
---------------------------------------------------------------------------------------------------------
	10/08/23
Lecture-11: Time & Space Complexity, How to avoid Time Limit Exceeded [TLE]
		Time Complexity:
			-It is the amount of time taken by an algorithm to run, as function of length of input.
			-the computational complexity that describes the amount of computer time it takes to run an algorithm. or
			-The Time Complexity of an algorithm/code is not equal to the actual time required to execute a particular code, 
			 but the number of times a statement executes.

			-we use time/space complexity for making better programs.
			-using these terms, we can decide algorithm is fast or slow.
			-It represented in 3 forms,
				1). Big O - Upper bound, (at max this much time program will take). worst case scenario
				2). Theta θ - Average, average case scenario.
				3). Omega Ω - Lower bound (at minimum, this much amount of time program will take) best case scenario.
			
			-Time:
				1) Constant time O(1).
				2) Linear time O(n).
				3) Logarithmic time O(log n).
				4) Quadratic time O(n²).		(nested loops)
				5) Cubic time O(n³).		(nested nested loops)

				chart: 
						O(N!)			--maximum time takes.
						O(2ⁿ)
					↑	O(n³)
					↑	O(n²)
					↑	O(n log(n))
					↑	O(n)
					↑	O(log(n))
					↑	O(1)			--minimum time takes.
			eg.
				-ignore constant, choose highest degree in equation.
					f(n) = 2n² + 3n 
					->
						O(n²)
					f(n) = 4n⁴ + 3n³
					->
						O(n⁴)
					
					f(n) = n² + log(n)
					-> O(n²).

					f(n) = 120043
					->
						O(1).
					
					f(n) = 5n³ + 3n² + 5
					->
						O(n³)
					
					f(n) = n³ / 300
					->
						O(n³)
					
					f(n) = 5n² + log(n)
					->
						O(n²)
					
					f(n) = n/4
					->
						O(n)				(Linear Time complexity)
					
					f(n) = (n+4)/4
					->
						O(n)				(Linear Time complexity)

				-Take this function to find its time complexity:
					void printArr(int a[], int n){
						for(int i=0;i<n; i++){
							cout<<a[i] << "\t";
						}
						cout<<"\n";
					}
					->
						here the length of array is n, so time depends length of array,
						so 
						Time Complexity will be O(n).
				
				-for calculating time complexity, if 2 for loops are there which are nested then their last
				value will be multiplied with eachother,
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements
					->
						time complexity: n*n  = O(n²);
					
				-if 2 for loops are there which are next to each other then we add their last value;
					for(int i=0;i<n; i++) ->	O(n)
						//statements
					
					for(j=0;j<m;j++)		-> O(m)
						//statements
					
					Time Complexity = O(n+m)

				-for this?
					for(i=0;i<n;i++)
						for(j=0;j<n;j++)
							//statements		// O(n²)
					
					for(j=0;j<n;j++)			// O(n)
						//statements
					
					= O(n²) + O(n)
					Time Complexity = O(n²)
				
				-for this?
					for(i=0;i<n;i++)			//this loop will run till (n-1)	ie.	O(n)
						for(j=n;j>i;j--)		//suppose i=0 then, this loop will run n to 0, ie. O(n)
							//statements		
					
					Time Complexity = O(n²)

		Space Complexity:
			-The total amount of memory space used by an algorithm/program, including the space of input values for execution.
			-The space complexity of an algorithm or a computer program is the amount of memory space required to solve an instance 
			 of the computational problem as a function of characteristics of the input. 
			 It is the memory required by an algorithm until it executes completely.
			-This includes the memory space used by its inputs, called input space, and any other (auxiliary) memory it uses during execution, 
			 which is called auxiliary space.

			-Similar to time complexity, space complexity is often expressed asymptotically in big O notation, such as O(n), O(n long(n)), 
			eg.
				-if we mention the array size then its fixed space complexity O(1).
				-if we declare any variable, it will take fixed space, so space Complexity O(1).
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-12: Binary Search:
		Binary search is applied only in list/ array where the data is sorted, 
		 either in increasing or in decreasing order, called monotonic function.
		Steps for Binary Search :
		1. Find middle element of the given array.
			If the value found at mid index is equal to key, return true else,
		2. if key >  mid,
			then go left side of the array by start = mid+1 to end is same.
		3. if Key <  mid,
			then go right side of the array from start is same & end = mid -1
		3. If key not found after searching whole array, return false.

		--here in case of binary search the Time Complexity is O(log(n)), where n is length of array.
		--because for every next iteration the array size is getting half,
		  for first len/2
		  for 2nd len/4
		  for 3rd len/8, like len/2¹, len/2², len/2³,... len/2ⁿ
		  len/2ⁿ = 1
		  len = 2ⁿ
		  n = log₂(len) 

		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[],int size){
				for(int i=0;i<size;i++){
					cout<<a[i]<<" ";
				}
				
				std::cout << std::endl;
			}

			int BinarySearch(int b[], int len, int key){
			
				int start = 0, end = len-1;
				
				//int mid = (start+end)/2;
				
				int mid = start + (end - start)/2;
    
				//sometimes array length is too large that start & end index is of (2³¹ - 1) & (2³¹ - 1) 
				//then their addition will be out of range of integer
				
				// so to avoid this issue we can use this formula,			

				while(start <= end){
					
					if(b[mid] == key)
						return mid;
					else if(key > b[mid])
						start = mid+1;
					else
						end = mid-1;
						
					mid = start + (end - start)/2;
				}
				return -1;
			}

			int main()
			{
				int Even[] = {2,4,6,8,12,14,16,22,28,30};
				int Odd[] = {1,3,5,9,13,17,41,43,59,55,69};
				
				cout<<"Even array: ";
				printArr(Even,10);
				
				
				cout<<"Odd array: ";
				printArr(Odd,11);
				
				int element;
				std::cout << "Enter element you want to find in Even array: " << std::endl;
				cin>>element;
				
				std::cout << element << " is at " << BinarySearch(Even, 10, element) << " Index." << std::endl;
				
				std::cout << "Enter element you want to find in Odd array: " << std::endl;
				cin>>element;
				std::cout << element << " is at " << BinarySearch(Odd, 11, element) << " Index." << std::endl;
				
				std::cout << "--END--" << std::endl;
			}
---------------------------------------------------------------------------------------------------------
	12/08/23
Lecture-13: Questions on BinarySearch
	#Pair in C++ Standard Template Library (STL)
		-Pair is used to combine together two values that may be of different data types. 
		-Pair provides a way to store two heterogeneous objects as a single unit. 
		-It is basically used if we want to store tuples. 
		-The pair container is a simple container defined in <utility> header consisting of two data elements or objects. 

		-The first element is referenced as ‘first’ and the second element as ‘second’ and the order is fixed (first, second).
		-Pair can be assigned, copied, and compared. 
		-The array of objects allocated in a map or hash_map is of type ‘pair’ by default in which all the ‘first’ elements are unique keys associated with their ‘second’ value objects.
		-To access the elements, we use variable name followed by dot operator followed by the keyword first or second.
		Syntax: 
			pair <data_type1, data_type2> Pair_name
			eg.
				#include <iostream>
				#include <utility>
				using namespace std;
				int main()
				{
					// defining a pair
					pair<int, char> PAIR1;

					// first part of the pair
					PAIR1.first = 100;

					// second part of the pair
					PAIR1.second = 'G';

					cout << PAIR1.first << " ";
					cout << PAIR1.second << endl;

					// defining a pair
					pair<string, double> PAIR2("GeeksForGeeks", 1.23);
					
					cout << PAIR2.first << " ";
					cout << PAIR2.second << endl;

					return 0;
				}
				output:	100 G

				Initializing a Pair: We can also initialize a pair. 
					Syntax:
						pair <data_type1, data_type2> Pair_name (value1, value2) ;
					
					Different ways to initialize pair:  

						pair  g1;         //default
						pair  g2(1, 'a');  //initialized,  different data type
						pair  g3(1, 10);   //initialized,  same data type
						pair  g4(g3);    //copy of g3
						
						Another way to initialize a pair is by using the make_pair() function. 
							g2 = make_pair(1, 'a');

						Another valid syntax to declare pair is:
							g2 = {1, 'a'};
							pair<int, int> p1 {a,b};		
							pair<int, int> p1 = {a,b};
							eg.
								#include <iostream>
								using namespace std;

								int main(){
									int a = 10,b =20;

									pair<int, int> p1 {a,b};
									pair<char, string> p2('A',"First Alphabet");
									
									std::cout << p1.first<<" ";                     //10 20
									std::cout << p1.second << std::endl;
									
									std::cout << p2.first <<" ";                    //A First Alphabet
									std::cout << p2.second << std::endl;
									
									
									return 0;
								}

				Note: If not initialized, the first value of the pair gets automatically initialized. 
				
					#include <iostream>
					#include <utility>
					using namespace std;
					int main()
					{
						pair<int, double> PAIR1;
						pair<string, char> PAIR2;
						
						// it is initialised to 0
						cout << PAIR1.first;
						
						// it is initialised to 0
						cout << PAIR1.second;
						
						cout << " ";
						
						// it prints nothing i.e NULL
						cout << PAIR2.first;
							
						// it prints nothing i.e NULL
						cout << PAIR2.second;
						
						return 0;
					}
				-for more example Visit GFG pair
					1)swap
					2)make_pair
					3)tie

	1)Find the First & Last occurence of element in array:
		//Linear search method
			#include <bits/stdc++.h> 
			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				int i;
				int len = arr.size();

				for(i=0; i< len;i++){
					if(k == arr[i]){
						ans.first = i;
						break;
					}
				}
				
				if(i == len)
					ans.first = -1;
				

				for(i=len-1; i>-1; i--)
				{
					if(k == arr[i]){
						ans.second = i;
						break;
					}
				}

				if(i == -1)
					ans.second = -1;

				return ans;
			}

		//Binary search method
			#include <bits/stdc++.h> 
			int firstOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						e = mid -1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			int lastOcc(vector<int>& arr, int n, int k){
				int s=0,e=n-1,i=-1;
				int mid = (s+e)/2;
				while(s<=e){
					if(k == arr[mid]){
						i = mid;
						s = mid + 1;
					}else if(k > arr[mid]){
						s = mid +1;
					}else{
						e = mid -1;
					}
					mid = (s+e)/2;
				}
				return i;
			}

			pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
			{
				pair<int, int> ans;
				ans.first = firstOcc(arr, n, k);
				ans.second = lastOcc(arr, n, k);
				return ans;
			}

	example:To find the total no.of occurence of key in sorted array
		find the first/start index & last/end index, then 
		no.of occurence = (last - first)+1;
		eg.
			1 2 3 4 4 4 4 4 5 6 7
			--here 4's first index is 3 & last index is 7
			 so 7-3+1 = 5
			-no.of occurence of 4 is 5 times.
		
	2)Peak Index in Mountain Array:
		https://leetcode.com/problems/peak-index-in-a-mountain-array/
		//Linear or Brute force  algorithm			//TC- O(n)
			int peakIndexInMountainArray(vector<int>& arr) {
				int temp = arr[0], ans=0;
				for(int i=1; i< arr.size(); i++){
					if(temp < arr[i]){
						ans = i;
						temp = arr[i];
					}   
				}
				return ans;
			}

			//or
				class Solution {
					public:
					int peakIndexInMountainArray(vector<int>& arr) {
						for(int i=1; i<arr.size(); i++){
							if((arr[i-1]<arr[i]) && (arr[i]>arr[i+1]))
								return i;
						}
						return 0;

						//or
						//int n;
						//for(int i=1; i<arr.size(); i++){
						//	if((arr[i-1]<arr[i]) && (arr[i]>arr[i+1])){
						//		n= i;
						//		break;
						//	}
						//}
						//return n;
					}
				};
		
		//using Binary Search algorithm
			int peakIndexInMountainArray(vector<int>& arr) {
				int s=0, e= arr.size()-1;
				int mid = (s+e)/2;
				
				while(s < e){
					if(arr[mid] < arr[mid+1]){
						s = mid +1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}
				return e;
			}

	3)Find Pivot Index: HW
		-Left side summation & right side summation must be same then return the index of that element.
		//Linear search method:
			https://leetcode.com/problems/find-pivot-index/description/
			int pivotIndex(vector<int>& nums) {
				int left=0,right=0;
				int i=0;
				for(;i<nums.size(); i++){

					//for rightSide
					for(int j=i+1; j<nums.size(); j++){
						right += nums[j]; 
					}

					//for leftSide
					for(int k=0; k<i; k++){
						left += nums[k];
					}

					if(left == right)
					{
						break;
					}
					right=0; left=0;
				}

				if(i == nums.size())
						return -1;
				return i;
			}
---------------------------------------------------------------------------------------------------------
	13/08/23
Lecture-14: Binary Search Interview Questions | Problem set-2
		Find the pivot in sorted & rotated array,
		eg.
			sorted array : [1,2,3,4,5,6,7,8,9];	
			rotated array by 3 in right direction : [7,8,9,1,2,3,4,5,6];
		-finding pivot in it,
			-> The minimum value in array is a pivot element.
		Pratical:
			#include <iostream>
			using namespace std;

			void printArr(int a[], int L){
				for(int i=0;i<L;i++){
					cout<<a[i]<<" ";
				}
				std::cout << std::endl;
			}

			int main()
			{
				int arr[] = {4,5,6,7,8,9,10,1,2,3};
				int len = 10;

				std::cout << "The array is : " << std::endl;
				printArr(arr, len);

				int s=0, e=len-1;
				int mid = (s+e)/2;

				while(s < e){
					if(arr[mid] >= arr[0]){
						s = mid + 1;
					}else{
						e = mid;
					}
					mid = (s+e)/2;
				}

				cout<<"The pivot Element is at location/index :"<<s<<" or at "<<e;
				return 0;
			}

		1). Search K In Rotated Sorted Array

			//Linear way O(n) time complexity,
				int search(vector<int>& arr, int n, int k)
				{
					// Write your code here.
					// Return the position of K in ARR else return -1.
					int i=0;
					for(;i<arr.size();i++){
						if(k == arr[i]){
							return i;
						}
					}

					if(i == arr.size())
						return -1;
				}

			//Using Binary search O(log(n)) Time complexity,
				int BinarySearch(vector<int>& arr, int start, int n, int key){
					int s = start, e= n-1;
					int mid= (s+e)/2;
					
					while(s <= e){
						if(arr[mid] == key){
							return mid;
						}else if(key > arr[mid]){
							s = mid + 1;
						}else{
							e = mid -1;
						}
						mid = (s+e)/2;
					}
					return -1;
				}

				int pivotFind(vector<int>& arr, int len){
					
					int s=0, e = len-1;
					int mid = (s+e)/2;

					while(s < e){
						if(arr[mid] > arr[0] ){
							s = mid +1;
						}else{
							e =mid;
						}
						mid = (s+e)/2;
					}
					return s;
				}

				int search(vector<int>& arr, int n, int k){
					// Return the position of K in ARR else return -1
					int pivot = pivotFind(arr, n);
					
					if(arr[0] <= k && k <= arr[pivot-1]){
						//first line from start to till pivot
						return BinarySearch(arr, 0, pivot, k);        
					}else{
						// second line from pivot to till end.
						return  BinarySearch(arr, pivot, n, k);
					}				
				}

		2). Square Root of a number
			//Linear Search, not optimized
				int floorSqrt(int n){
					for(int i=1;i<=n/2;i++){
						if(n == pow(i,2)){
							return i;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
				}

			//using BinarySearch optimized
				int floorSqrt(int n){
					int s=0, e = n;
					long long int mid = (s+e)/2;
					long long int sqr;
					long long int ans;

					while(s <= e){
						sqr = mid * mid;
						if(sqr == n){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid -1;
						}else{
							ans = mid;
							s = mid +1;
						}
						mid = (s+e)/2;
					}
					return ans;
				}

		3). Sqrt(x):
			//Linear search not optimized
				int mySqrt(int n) {
					int i=0;
					for(;i<=n;i++){

						if(n == pow(i,2)){
							break;
						}else if((n < pow(i,2)) && (n > pow(i-1,2))){
							return i-1;
						}else{
							continue;
						}
					}
					return i;
				}
			
			//using BinarySearch 
				int mySqrt(int n) {
					int s=0, e =n;
					long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
					long long int ans;
					long long int sqr;

					while(s <= e){
						sqr = mid * mid;
						if(n == sqr){
							ans = mid;
							break;
						}else if(sqr > n){
							e = mid-1;
						}else{
							ans = mid;
							s=mid+1;
						}
						mid = (s+e)/2;
					}
					return ans;  
				}

		4). Square Root with decimal precision:
			#include <iostream>
			using namespace std;
			long long int SQRTn(int n){
				int s=0, e =n;
				long long int mid = (s+e)/2;			//used long long int to avoid int overflow exception.
				long long int ans;
				long long int sqr;

				while(s <= e){
					sqr = mid * mid;
					if(n == sqr){
						ans = mid;
						break;
					}else if(sqr > n){
						e = mid-1;
					}else{
						ans = mid;
						s=mid+1;
					}
					mid = (s+e)/2;			//or mid = s + (e-s)/2;
				}
				return ans;
			}

			double morePrecision(int n, int uptoDecimal, int sqrtNum){

				double factor=1;
				double ans= sqrtNum;

				for(int i=0; i< uptoDecimal; i++){
					factor = factor/10;

					for(double j=sqrtNum; j*j < n; j = j + factor){
						ans = j;
					}
				}
				return ans;
			}

			int main(){
				int n;
				cout<<"Enter n";
				cin>>n;

				int sqrt1 = SQRTn(n);
				cout<<"answer is upto 4 decimal precision ::"<< morePrecision(n, 4, sqrt1);
				return 0;	
			}
---------------------------------------------------------------------------------------------------------
	14/08/23
Lecture-15: Allocation Problem || Aggressive Cows Problem || Binary Search Advanced Problems
		1). Book Allocation:
			HW- https://www.codingninjas.com/studio/problems/allocate-books_1090540
		2). Painter partition
			HW.
		3). Aggressive cows

	COME BACK TO THIS LECTURE AGAIN. ❌
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-16: Selection Sort
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1;i++){
			int minIndex = i;
			for(int j=i+1; j<n;j++){
				if(arr[j] < arr[minIndex])
					minIndex = j;
			}
			swap(arr[minIndex],arr[i]);
		}
	}

	//or
	void selectionSort(vector<int>& arr, int n){   
		for(int i=0; i<n-1; i++){
			for(int j=i+1;j<n;j++){
				if(arr[i] > arr[j])
					swap(arr[i],arr[j]);
			}
		}
	}

	//or
	#include <bits/stdc++.h> 
	void selectionSort(vector<int>& arr, int n){
		int i,j;
		for(i=0;i<n-1;i++)
			for(j=i+1; j<n; j++)
				if(arr[i]> arr[j])
					swap(arr[i], arr[j]);
	}

		-for Selection Sort program,
			Space complexity:	O(1).
			Time complexity: O(n²);		
		
		-Use case:
			if given array/vector size is small then we can go for Selection sort.
		
		HW
			-Flowchart : 
			-Stable & unstable algorithm

	Practice:
		#include <iostream>
		using namespace std;
		void printArray(int [], int);		//or void printArray(int anyName[], int)	or if you don't give name to array still its fine, its just function declaration.

		int main()
		{
			int arr[] = {55,44,33,32,11,22,57,90,87,76,65,1};
			//1,11,22,32,33,44,55,57,65,76,87,90
			
			int len = 12;
			
			printf("Before Sorting :: \n");
			printArray(arr, len);
			
			int minValueIndex = arr[0];
			
			//sorting array,
			for(int i=0; i<len-1; i++){
				for(int j=i+1; j < len; j++)
					if(arr[minValueIndex] > arr[j])
						minValueIndex = j;
				
				//after getting the minimum value's index swap it, 
				swap(arr[i],arr[minValueIndex]);
			}
			printf("\nAfter Sorting :: \n");
			printArray(arr, len);

			return 0;
		}

		void printArray(int brr[], int len){
			for(int i=0;i<len;i++)
				printf("%d ",brr[i]);
		}
---------------------------------------------------------------------------------------------------------
	15/08/23
Lecture-17: BUBBLE SORT
	-Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. 
	-This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.
	Bubble Sort Algorithm
		In this algorithm,
		-traverse from left and compare adjacent elements and the higher one is placed at right side. 
		-In this way, the LARGEST element is moved to the rightmost end at first, at the end of array. 
		-This process is then continued to find the second largest and place it and so on until the data is sorted.
		
		Advantages of Bubble Sort:
			-Bubble sort is easy to understand and implement.
			-It does not require any additional memory space.
			-It is a stable sorting algorithm, 
			 meaning that elements with the same key value maintain their relative order in the sorted output.

		Disadvantages of Bubble Sort:
			-Bubble sort has a time complexity of O(n²) which makes it very slow for large data sets.
			-Bubble sort is a comparison-based sorting algorithm, 
			 which means that it requires a comparison operator to determine the relative order of elements in the input data set. 
			 It can limit the efficiency of the algorithm in certain cases.

	QnA:
		-In Bubble Sort, after each pass, the largest element among the unsorted elements "bubbles up" to which position?
		-> Last

		-main drawback of the Bubble Sort algorithm?
		->It has a high time complexity. ie. O(n²).

		-space complexity:
			O(1), haven't created a dynamic variable so no space complexity.

		-true regarding Bubble Sort?
		->It is an in-place sorting algorithm.
		Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. 
		Hence Bubble sort algorithm is an in-place algorithm.

		-Bubble Sort is an example of a sorting algorithm that:
		->Swaps adjacent elements directly

		-Bubble Sort is an example of a ______ sorting algorithm.
		->Comparison - based

		-worst-case time complexity of the Bubble sort Algorithm?
		->O(n²)

		-What is the maximum number of comparisons that can take place when a bubble sort algorithm is implemented?, 
		suppose there are n elements in the array.
		->	(n*(n-1))/2

		-The number of swappings needed to sort the numbers 8, 22, 7, 9, 31, 5, 13 in ascending order, using bubble sort is,
		->10

		-Assume that we use Bubble Sort to sort n distinct elements in ascending order. When does the best case of Bubble Sort occur?
		->When elements are sorted in ascending order
		the time complexity of bubble sort in the BEST-CASE scenario is O(n).

	eg.
		#include <bits/stdc++.h> 
		void bubbleSort(vector<int>& arr, int n){
			for(int i=0;i<n-1; i++)
				for(int j=0; j<n-1;j++)				//here covering the last element looping from start to till end.
					if(arr[j]> arr[j+1])
						swap(arr[j],arr[j+1]);
		}

		//or neglecting the last element as it is already sorted,
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++)					
					for(int j=0; j<n-i;j++)				//here ignoring the last element from start to till n-1.
						if(arr[j]> arr[j+1])
							swap(arr [j],arr[j+1]);
			}
		
		//optimizing more.., 
		 in a random round there is no any swapping done, then we can consider that it's sorted.
			#include <bits/stdc++.h> 
			void bubbleSort(vector<int>& arr, int n){
				for(int i=1;i<n; i++){
					bool isSwappingOn = false;

					for(int j=0; j<n-i;j++)
						if(arr[j] > arr[j+1]){
							swap(arr [j],arr[j+1]);
							//swapping on..
							isSwappingOn = true;
						}
					if(isSwappingOn == false)
						break;        
				}
			}
		
	HW:
		stable or unstable bubble sort?
		in-place sort
---------------------------------------------------------------------------------------------------------
	16/08/23	
Lecture-18: INSERTION SORT
	Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. 
	The array is virtually split into a sorted and an unsorted part. 
	Values from the unsorted part are picked and placed at their correct position in the sorted part.

	-shifting of element done here.
	-https://www.geeksforgeeks.org/insertion-sort/

	-code:
		#include <bits/stdc++.h> 
		void insertionSort(int n, vector<int> &arr){
			for(int i=1; i<n; i++){
				int temp = arr[i],j;
				for(j=i-1; j>=0; j--){
					if(temp< arr[j]){
						//shifting
						arr[j+1] = arr[j]; 
					}else{
						break;
					}
				}
				arr[j+1] = temp;
			}
		}

	Characteristics of Insertion Sort
		-This algorithm is one of the simplest algorithms with a simple implementation
		-Basically, Insertion sort is efficient for small data values
		-Insertion sort is adaptive in nature, i.e. it is appropriate for data sets that are already partially sorted.

	-insertion sort is a STABLE sorting algorithm.
	-insertion sort is a ADAPTABLE sorting algorithm.
	-Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, 
	 and only a few elements are misplaced in a complete big array.
	
	Time complexity:
		O(n²)
		-Best-Case : O(n);
		-Worst-case: O(n²)
	space complexity:
		O(1)
---------------------------------------------------------------------------------------------------------
	17/08/23
Lecture-19: C++ STL (Standard Template Library)
	-Algorithm
	-Containers

	1) STD::array in C++:
		The array is a collection of homogeneous objects and this array container is defined for constant size arrays or (static size). 
		This container wraps around fixed-size arrays and the information of its size are not lost when declared to a pointer. 
		In order to utilize arrays, we need to include the array header:
			#include <array>

			Syntax:
				array<object_type, arr_size> arr_name;

			a)[] Operator : This is similar to the normal array, we use it to access the element store at index ‘i’ .
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <char , 3> arr={'G','f','G'};
						cout<<arr[0] <<" "<<arr[2];			//G G
						return 0;
					}
			
			b) front( ) and back( ) function: 
				-These methods are used to access the first and the last element of the array directly.
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				
			c) swap( ) function: 
				-This swap function is used to swap the content of the two arrays.
					Ex: 
					#include <iostream>
					#include <array>
					using namespace std;
				
					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						arr.swap(arr1);  // now arr = {M,M,P}
						cout<<arr.front() <<" "<<arr.back();
						return 0;
					}
				eg.
					#include <iostream>
					#include<array>
					using namespace std;

					int main()
					{
						//double or single braces works fine.
						array<int, 5> a {1,2,3,4};
						array<int, 5> b {{10,20,30,40,150}};
						array<int, 5> c {1,2,3,4,5};
						
						cout<<"A:\n";
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nB : " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
							
						a.swap(b);
						std::cout << "\nAfter swapping: Array A:  " << std::endl;
						for(auto i: a)
							std::cout << i << "\t";
							
						std::cout << "\nAfter swapping: Array B:  " << std::endl;
						for(auto i: b)
							std::cout << i << "\t";
					}

			d)empty(): to check array is empty or not
				first need to cout boolalpha then after print the boolean value, if you print boolean values 
				before cout boolalpha then it will printed like 0,1.
				eg.
					bool x = arr.empty(); // false ( not empty)
					cout<<boolalpha;		//or cout<<boolalpha<<(x);				
					bool y = 1;
					cout<<y;
					cout<<"\n"<<x;

				-boolalpha is a manipulator used in C++ for the std::cout stream (the standard output stream) 
				to display boolean values as their corresponding textual representations "true" or "false," 
				rather than as integer values 1 or 0.
			
			e) at() function: 
				This function is used to access the element stored at a specific location, 
				if we try to access the element which is out of bounds of the array size then it throws an exception. 
				Ex: 
					#include <iostream>
					#include <array>
					using namespace std;

					int main() {
						array <int , 3> arr={'G','f','G'};  // ASCII val of 'G' =71
						array <int , 3> arr1={'M','M','P'}; // ASCII val of 'M' = 77 and 'P' = 80
						cout<< arr.at(2) <<" " << arr1.at(2);
						//cout<< arr.at(3); // exception{Abort signal from abort(3) (SIGABRT)}
						return 0;
					}
					Output
						71 80

			f) fill( ) function: 
				This is specially used to initialize or fill all the indexes of the array with a similar value.
				Ex:
					#include <iostream>
					#include <array>
					using namespace std;
					
					int main() {
						array <int , 5> arr;
						arr.fill(1);
						for(int i: arr)
							cout<<arr[i]<<" ";
						return 0;
					}
						Output
						1 1 1 1 1 

			g) size( ) or max_size( ) and sizeof( ) function: 
				Both size( ) or max_size( ) are used to get the maximum number of indexes in the array 
				while sizeof( ) is used to get the total size of array in bytes.

				#include <iostream>
				#include <array>
				using namespace std;				
				int main() {
					array <int , 10> arr;   
					cout<<arr.size()<<'\n'; // total num of indexes
					cout<<arr.max_size()<<'\n'; // total num of indexes
					cout<<sizeof(arr); // total size of array
					return 0;
				}
				Output
					10
					10
					40

		eg.
			#include <iostream>
			#include <array>
			using namespace std;

			int main()
			{
				int arr[] = {1,2,3};            //static array
							
				array<int, 4> a = {1,2,3,4};        //this is also static array
				
				std::cout << "Size : "<< a.size() << std::endl;     //to get the length of array    //Size : 4
				
				//printing the array element
				for(int i: a){
					cout<<i<<"\t";              //1       2       3       4
				}
				std::cout << std::endl;
				
				for(int it=0; it<a.size(); it++)
					cout<<a[it]<<" ";               //1       2       3       4
					
				//First last element of array
				std::cout << "\n\n First element of array A :: "<< a.front() << endl;           //  First element of array A :: 1
				std::cout << " Last element of array A :: "<< a.back()<<endl;                   //   Last element of array A :: 4
				
				//random index of array
				std::cout << "\n3rd index : "<< a[3] << std::endl;                  // 3rd index : 4
				std::cout << "2nd index : "<< a.at(2) << std::endl;                 // 2nd index : 3
				
				//checking the array is empty or not?
				cout<<"Array A is empty : "<<a.empty();                         // array is not empty so, Array A is empty : 0
				
				return 0;
			}

		eg.
			#include <iostream>
			#include<array>

			//for sorting algorithm need to include,
			#include <algorithm>
			using namespace std;

			int main()
			{
				//double or single braces works fine.
				array<int, 5> a {1,2,3,4};
				array<int, 5> b {{1,2,3,4,15}};
				array<int, 5> c {1,2,3,4,5};
				
				//printing array
				for(auto i: a){
					std::cout << i <<" ";
				}
				std::cout << std::endl;
				
				for(auto i: b){
					printf("%d ",i);
				}
				
				
				//sort
				std::cout << std::endl;
				array<int, 5> d = {5,4,3,2,1};          //equal sign with single braces.
						
				for(auto i: d)
					cout<<i<<" ";
					
				std::cout  << std::endl;
				
				//after sorting
				sort(d.begin(), d.end());
				
				
				//if you just try to print the begin() function on array it will print the memory location of that array
				//so to print the element at that address Use asterisk.
				
				cout<<"Beging memory address: "<<d.begin()<<"\n";
				cout<<"starting element: "<<*d.begin()<<"\n";
				
				cout<<"End: "<<*d.end()<<"\n";
				
				for(auto i: d)
					cout<<i<<" ";
					
				array<int, 3> e = {{}};         //equal sign with double braces.
				
				
				//by default array e gets initialized with 0.
				cout<<"\n";
				for(int o: e){
					cout<<o<<" ";
				}
				
				
				//initializing array e with default specific element with 97,
				cout<<"\n";
				e.fill(97);
				for(auto i: e)
					cout<<i<<" ";
					
				//initializing string array
				cout<<"\n";
				array<string, 5> strings {"Vivek","Nikate","a","b"};
				
				for(string s: strings)
					cout<<s<<"\t";
					
				//printing string array
				cout<<"\n";
				for(auto s: strings)
					cout<<s<<"\t";

				return 0;
			}

	2) Vector:
		-It's a dynamic array.
		-Vectors are the same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, 
		 with their storage being handled automatically by the container. Vector elements are placed in contiguous storage 
		 so that they can be accessed and traversed using iterators. 
		 In vectors, data is inserted at the end. Inserting at the end takes differential time, 
		 as sometimes the array may need to be extended. Removing the last element takes only constant 
		 time because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.
		 
					vector::push_back() 								|	vector::pop_back()
				It is used to add a new element at the end of the vector. 		|	It is used to remove a new element at the end of the vector.
				Its parameter is the value we want to add in the end of vector. 	|	It does not take any parameters.
				It does not have any return type.							|	It does not have any return value.
				Its complexity is constant.								|	Its complexity is constant.
				`container.push_back(element);							| 	container.pop_back();
			Container-    Vector, Deque, List, etc. 						| 	Vector, Deque, List, etc..
			Effects  -    Increases container size by 1 						|	 Decreases container size by 1.

		-std::vector in C++, It is defined inside the <vector> header file.

		Reverse Vector:
			#include <iostream>
			#include<vector>
			// this algorithm header file is for reverse method,
			#include <algorithm>
			using namespace std;

			int main()
			{
				vector<int> v {10,9,8,7,6,5,4,3,2,1};
				std::cout << "Size "<< v.size() << std::endl;       //Size 10
				
				for(auto i: v)
					cout<<i<<" ";                               // 10 9 8 7 6 5 4 3 2 1 
					
				reverse(v.begin(), v.end());
				
				cout<<"\n After reversing: ";
				for(auto i: v)
					cout<<i<<" ";                               // After reversing: 1 2 3 4 5 6 7 8 9 10 

				return 0;
			}

			//Initialize an array with consecutive numbers using std::iota

				#include <iostream>
				#include <vector>
				#include<numeric>               //for iota 
				#include<algorithm>             //for reversing
				using namespace std;
				int main(){
					vector<int> v(10);
					
					iota(v.begin(), v.end(), 9);        // from 9 to 18
					
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 14 15 16 17 18
						
					reverse(v.begin()+5,v.end());       //reverse after 5th index
					
					cout<<"\n";
					for(int i=0; i<v.size(); i++)
						cout<<v[i]<<" ";                //9 10 11 12 13 18 17 16 15 14
					
					return 0;
				}

		Practice:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main()
			{
				vector<int> v;
				
				//Capacity- means how many elements it can contain.
				//Size- means how many elements it is containing/ contained now.
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;
				std::cout << "Size- "<<v.size() << std::endl;
				
				v.push_back(1);
				v.push_back(2);
				v.push_back(3);
				v.push_back(4);
				v.push_back(5);
				v.push_back(48);
				v.push_back(45);
				
				v.push_back(18);
				v.push_back(345);
				
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //capacity gets double everytime if size is greater than capacity value.
					std::cout << "Size- "<<v.size() << std::endl;                   //9
				
				for(auto i: v)
					cout<<i<<" ";
					
				std::cout << "\nAfter Popping last element : " << std::endl;
				v.pop_back();
				
				for(auto i: v)
					cout<<i<<" ";
					
				v.clear();
				
				std::cout  << std::endl;
				std::cout << "Capacity- "<<v.capacity() << std::endl;           //after clearing also capacity is same.
				std::cout << "Size- "<<v.size() << std::endl;                   //size reduce back to 0.
				return 0;
			}

		-vector initialization:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> a;      //size=0
				std::cout << a.size() << std::endl;
				
				vector<int> b(5);   //size=5, but all element are by default initialized to 0.
				std::cout << b.size() << std::endl;
				
				for(auto i:b)
					cout<<i<<" ";
					
				//vector with initializing default value,
				//vector<DataType> VectorName(size, defaultValue);
				vector<int> c(10, 580);     //10 element having all value 580.
				
				cout<<"\n";
				for(int i: c)
					cout<<i<<" ";
					
				//copying vector from another
				vector<int> d(c);        //copying vector c to d.
				
				cout<<"\n vector D: ";
				for(int i: d)
					cout<<i<<" ";
				
				//inserting value to specific index,
				cout<<"\n";
				
				d.insert(d.begin(),34);     //at start
				d.insert(d.begin()+4,23);     //at 4th index
				
				cout<<"\n vector D After insertion: ";
				for(int i: d)
					cout<<i<<" ";
					
					//inserting specific no.of same element to vector  
					cout<<"\n vector e :";
				vector<int> e(5,4);
				for(int i: e)
					cout<<i<<" ";
				
				std::cout<<"\nAfter insertion 99 in vector e: " << std::endl;
				//vector_name.insert(position, size (no.of times to be inserted), val (defaultValue) )
				e.insert(e.begin()+2, 5, 99);              //inserting 780, 5 times after 2nd index.
				
				for(int i: e)
					cout<<i<<" ";

				return 0;
			}

		eg.
			#include <iostream>
			#include <vector>

			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 5; i++)
					g1.push_back(i);						//inserting element into the vector.

				cout << "Output of begin and end: ";
				for (auto i = g1.begin(); i != g1.end(); ++i)
					cout << *i << " ";						//Output of begin and end: 1 2 3 4 5 

				cout << "\nOutput of cbegin and cend: ";
				for (auto i = g1.cbegin(); i != g1.cend(); ++i)
					cout << *i << " ";						//Output of cbegin and cend: 1 2 3 4 5 

				cout << "\nOutput of rbegin and rend: ";
				for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir)
					cout << *ir << " ";						//Output of rbegin and rend: 5 4 3 2 1 

				cout << "\nOutput of crbegin and crend : ";
				for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir)
					cout << *ir << " ";						//Output of crbegin and crend : 5 4 3 2 1

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
				vector<int> g1;

				for (int i = 1; i <= 10; i++)
					g1.push_back(i * 10);

				cout << "\nReference operator [g] : g1[2] = " << g1[2];			//Reference operator [g] : g1[2] = 30

				cout << "\nat : g1.at(4) = " << g1.at(4);                   //element at 4th index (means 0-based indexing so 5th)
				//at : g1.at(4) = 50

				cout << "\nfront() : g1.front() = " << g1.front();          //first element
				//front() : g1.front() = 10

				cout << "\nback() : g1.back() = " << g1.back();             //last element
				//back() : g1.back() = 100

				// pointer to the first element
				int* pos = g1.data();           //storing the base address of vector g1 here.

				cout << "\nThe first element is " << *pos;          //accessing first/base element
				//The first element is 10
				
				cout << "\nThe 9th element is " << *(pos+8);
				//The 9th element is 90

				return 0;
			}

		eg.
			#include <bits/stdc++.h>
			#include <vector>
			using namespace std;

			int main()
			{
				// Assign vector
				vector<int> v;

				// fill the vector with 10 five times
				v.assign(5, 10);

				//or you can pass array in assign
				v.assign({23,24,55,46,57,78});

				cout << "The vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 15 to the last position
				v.push_back(15);
				int n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// removes last element
				v.pop_back();

				// prints the vector
				cout << "\nThe vector elements are: ";
				for (int i = 0; i < v.size(); i++)
					cout << v[i] << " ";

				// inserts 5 at the beginning
				v.insert(v.begin(), 5);

				cout << "\nThe first element is: " << v[0];

				// removes the first element
				v.erase(v.begin());

				cout << "\nThe first element is: " << v[0];

				// inserts at the beginning
				v.emplace(v.begin(), 5);
				cout << "\nThe first element is: " << v[0];

				// Inserts 20 at the end
				v.emplace_back(20);
				n = v.size();
				cout << "\nThe last element is: " << v[n - 1];

				// erases the vector
				v.clear();
				cout << "\nVector size after clear(): " << v.size();

				// two vector to perform swap
				vector<int> v1, v2;
				v1.push_back(1);
				v1.push_back(2);
				v2.push_back(3);
				v2.push_back(4);

				cout << "\n\nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";

				// Swaps v1 and v2
				v1.swap(v2);

				cout << "\nAfter Swap \nVector 1: ";
				for (int i = 0; i < v1.size(); i++)
					cout << v1[i] << " ";

				cout << "\nVector 2: ";
				for (int i = 0; i < v2.size(); i++)
					cout << v2[i] << " ";
			}
			Output:
				The vector elements are: 10 10 10 10 10 
				The last element is: 15
				The vector elements are: 10 10 10 10 10 
				The first element is: 5
				The first element is: 10
				The first element is: 5
				The last element is: 20
				Vector size after erase(): 0

				Vector 1: 1 2 
				Vector 2: 3 4 
				After Swap 
				Vector 1: 3 4 
				Vector 2: 1 2
		
		-Erase method:
			#include <bits/stdc++.h>
			using namespace std;

			int main()
			{
					// Assign vector
				vector<int> v;
				
				// fill the vector with 10 five times
				v.push_back(10);
				v.push_back(20);
				v.push_back(30);
				v.push_back(40);
				v.push_back(50);
				
				for(auto i: v)
					std::cout << i << " ";
				
				v.erase(v.begin()+3);       //removing 4th element 40.
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
					
					v.erase(v.begin());     //removing first element
				
				std::cout << std::endl;
					for(auto i: v)
					std::cout << i << " ";
				
				return 0;
			}

		Time Complexity of Vector:
			-The time complexity for doing various operations on vectors is-
				Random access – constant O(1)
				Insertion or removal of elements at the end – constant O(1)
				Insertion or removal of elements – linear in the distance to the end of the vector O(N)
				Knowing the size – constant O(1)
				Resizing the vector- Linear O(N)
		
		◉ NOTE:
			if you mention the size of vector while declaring it, like vector<int> ans(n); or vector<int> ans(5);
			then don't use push_back() to insert element at the end,
			directly use the index where you want to insert the value.
			like
				ans[0] = 1;
				ans[1] = 2;
				//no			ans.push_back(1);

	3) Deque:
		-Doubly ended queue
		-Means you can perform insertion/Deletion (push/ pop) operation from both ends, front & back.
		-Its implementation is bit complex, it uses static array not on contiguous location
		-It is DYNAMIC.
		-Random Access of element is possible
		-The deque::max_size() is a built-in function in C++ STL,
		 which returns the maximum number of elements that a deque container can hold.
			Syntax:
				deque_name.max_size()

			Parameters: The function does not accept any parameters.
			Return Value: The function returns the maximum number of elements that a deque container can hold.
			eg.
				int main(){
					deque<int> dq;
					
					cout << "The max-size of deque: " << dq.max_size();			//The max-size of deque: 4611686018427387903	
					return 0;
				}
			
		eg.
			#include <iostream>
			#include<deque>
			using namespace std;

			int main()
			{
				deque<int> d;
				
				//inserting at ending,
				d.push_back(1);
				d.push_back(2);
				d.push_back(3);
				d.push_back(4);
				d.push_back(5);
				
				d.push_front(100);
				d.push_front(200);
				d.push_front(300);
				d.push_front(400);
				d.push_front(500);
				
				for(auto i: d)
					std::cout << i << " ";          //500 400 300 200 100 1 2 3 4 5 

				//Removing element from start       //500
				d.pop_front();
				
				//Removing element from back        //5
				d.pop_back();
				
				cout<<"\nAfter removal : \n ";
				for(auto i: d)
					std::cout << i << " ";                  // 400 300 200 100 1 2 3 4 
					
				//accessing first index element
				cout<<"\nFirst index element : "<<d[1];     //First index element : 300
				
				//using at()
				cout<<"\n4th index element : "<<d.at(4);    //4th index element : 1
					
				//start element
				std::cout << "\n Start element : "<< d.front() << std::endl;            //Start element : 400
				
				//end element
				
				std::cout << "End element : "<< d.back() << std::endl;                  //End element : 4
				
				std::cout << "deque empty? : "<<boolalpha<< d.empty() << std::endl;     //0 or false, its not empty.
				
				std::cout << "Deque Size : "<< d.size() << std::endl;                   //Deque Size : 8
				
				std::cout << "Capacity : "<< d.max_size() << std::endl;                 //Capacity : 2305843009213693951
				
				//Deleting range of elements from 3 to 5, 3rd & 4th only not 5th.
				d.erase(d.begin()+3, d.begin()+5);              //100 1
				
				cout<<"\nDeleted few elements: ";
				for(auto i: d)
					std::cout << i << " ";                  // Deleted few elements: 400 300 200 2 3 4 
				
				//Deleting all elements
				d.clear();
				std::cout << "\nDeque Size : "<< d.size() << std::endl;                   //Deque Size : 0

				return 0;
			}

	4) List:
		-Lists are sequence containers that allow non-contiguous memory allocation. 
		-As compared to the vector, the list has slow traversal, but once a position has been found, 
		 insertion and deletion are quick (constant time). 
		-Normally, when we say a List, we talk about a doubly linked list. For implementing a singly linked list, 
		 we use a forward_list.

		-std::list is the class of the List container. 
		-It is the part of C++ Standard Template Library (STL) and is defined inside <list> header file.
		-Random access is not possible.
		Points to Remember about List Container:-
			-It is generally implemented using a dynamic doubly linked list with traversal in both directions.
			-Faster insert and delete operation as compared to arrays and vectors.
			-It provides only sequential access. Random Access to any middle element is not possible
			-It is defined as a template so it is able to hold any data type.
			-It operates as an unsorted list would, which implies that by default, the list’s order is not preserved. However, there are techniques for sorting.

		Syntax:
			std::list <data-type> name_of_list;
			eg.
				list<int> L;
		
		eg.
			#include <iostream>
			#include <list>
			using namespace std;

			int main()
			{
				list<int> L;
				
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;          //The size of List :: 0

				
				L.push_back(90);            //insertion at back
				L.push_back(100);
				
				L.push_front(910);          //insertion at front side
				L.push_front(800);
				
				for(auto i:L)
					cout<<i<<" ";           //800 910 90 100 
					
				std::cout << "\nThe size of List :: "<< L.size() << std::endl;      //The size of List :: 4
				
				std::cout << "\nThe max size of List :: "<< L.max_size();           //The max size of List :: 384307168202282325
				
				//deleting start element      //800
				//you can't delete random element coz list doesn't provide random access to element.
				
				L.erase(L.begin());
				cout<<"\n start element removed : ";            // start element removed : 910 90 100 
				for(auto i:L)
					cout<<i<<" ";
					
				//copy
				list<int> n(L);
				cout<<"\n copied list : ";
				for(auto i:L)
					cout<<i<<" ";                       //copied list : 910 90 100 
					
				//list with default value 0
				
				//list<DataType> list_name(size)
				list<int> a(5);         
				
				cout<<"\n List A: ";
				for(int i:a)
					cout<<i<<" ";           // List A: 0 0 0 0 0 
					
				//list<DataType> list_name(size, DefaultValue);
				
				list<int> b(7, 31);         
				
				cout<<"\n List B: ";
				for(int i:b)
					cout<<i<<" ";           //  List B: 31 31 31 31 31 31 31 
				
				L.clear();      //deleting all list element,
				cout << "\n The size of List AFTER CLEARING :: "<< L.size();            // The size of List AFTER CLEARING :: 0

				return 0;
			}

	5) Stack:
		-LIFO (Last In First Out).
		-new element is added at one end (top) and an element is removed from that end only.
		-Operations:
			push(), pop(), top(), size(), empty() all are having Time complexity of O(1)
		
		eg.
			#include <iostream>
			#include <stack>
			using namespace std;

			int main(){
				stack<string> stsr;
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        //Size of Stack :: 0
				
				stsr.push("Vivek");
				stsr.push("Mahesh");
				stsr.push("Saraswait");
				stsr.push("Rohini");
				stsr.push("Computer");
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;					//TOP element of stack : Computer
				std::cout << "Size of Stack :: "<< stsr.size() << std::endl;        					//Size of Stack :: 5

				stsr.pop();
				
				std::cout << "TOP element of stack : "<< stsr.top() << std::endl;								//TOP element of stack : Rohini
				
				std::cout << "Stack empty? :: "<< stsr.empty() << " " << boolalpha <<stsr.empty() << std::endl;		//Stack empty? :: 0 false
				return 0;
			}

	6) Queue:
		-operate in a first in first out (FIFO) type of arrangement. 
		-Elements are inserted at the back (end) and are deleted from the front.
		-operations:
			push(), pop(), front(), back(), emplace(), size(), empty() all are have Time complexity of O(1).

		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				queue<string> sq;
				
				std::cout << "Size of Queue before insertion : "<< sq.size() << std::endl;
				
				sq.push("First");
				sq.push("Second");
				sq.push("Third");
				sq.push("Forth");
				
				std::cout << "Size of Queue After insertion : "<< sq.size() << std::endl;
				
				std::cout << "start element of Queue : "<< sq.front() << std::endl;
				
				std::cout << "Last element of Queue : "<< sq.back() << std::endl;
				
				sq.pop();
				
				std::cout << "start element After poping : "<< sq.front() << std::endl;
				
				std::cout << "Queue empty? : "<< boolalpha <<sq.empty() << std::endl;
				return 0;
			}

			//output:
				Size of Queue before insertion : 0
				Size of Queue After insertion : 4
				start element of Queue : First
				Last element of Queue : Forth
				start element After poping : Second
				Queue empty? : false

		emplace operation used to insert element in queue:{
			queue<char> myqueue;
			myqueue.emplace('k');
			myqueue.emplace('j');
			myqueue.emplace('y');
			myqueue.emplace('r');
			myqueue.emplace('y');
			myqueue.emplace('u');
			
			// queue becomes k, j, y, r, y, u
			
			while (!myqueue.empty())
			{
				cout << ' ' << myqueue.front();
				myqueue.pop();
			}
			return 0;
		}

	7) Priority Queue:
		https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/
		Time complexity:
			push(), pop() on priority queue is of O(logN).
			top(), size() & empty() are constant time operations O(1).
		eg.
			#include <iostream>
			#include <queue>
			using namespace std;

			int main(){
				priority_queue<int> pq;     //by default it creates max-heap(decreasing order).
				
				std::cout << "Size : "<< pq.size() << std::endl;        //Size : 0

				pq.push(1);
				pq.push(3);
				pq.push(5);
				pq.push(2);
				pq.push(4);
				
				std::cout << "First element : "<< pq.top() << std::endl;        //First element : 5
				int pqSize = pq.size();
				
				std::cout << "Size : "<< pqSize << std::endl;           //Size : 5

				for(int i=0;i<pqSize;i++){
					cout<<pq.top()<<" ";            //5 4 3 2 1 
					pq.pop();
				}
				
				//min heap increasing order
				priority_queue<int, vector<int>, greater<int>> min;
				
				min.push(100);
				min.push(200);
				min.push(400);
				min.push(300);
				min.push(500);
				
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty(); //Min priority_queue is empty ? 0
				int minSize= min.size();
				
				cout<<"\n Min elements : ";
				
				for(int i=0;i<minSize;i++){
					cout<<min.top()<<" ";                   //Min elements : 100 200 300 400 500 
					min.pop();
				}
				
				cout<<"\nMin priority_queue is empty ? "<< min.empty();     //Min priority_queue is empty ? 1
				return 0;
			}

	8) Set:
		-Stores unique elements
		-The values are stored in a specific sorted order i.e. either ascending or descending.
		-By default, the std::set is sorted in ascending order.
		-The std::set class is the part of C++ Standard Template Library (STL) and it is defined inside the <set> header file.
		-Syntax:
			std::set <data_type> set_name;

		-we have the option to change the sorting order by using the following syntax.
		-Syntax:
			std::set <data_type, greater<data_type>> set_name;

		-Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.

			set<int> val; // defining an empty set
			set<int> val = {6, 10, 5, 1}; // defining a set with values
		
		Properties-
			Storing order – The set stores the elements in sorted order.
			Values Characteristics – All the elements in a set have unique values.
			Values Nature – The value of the element cannot be modified once it is added to the set, 
						though it is possible to remove and then add the modified value of that element. Thus, the values are immutable.
			Search Technique – Sets follow the Binary search tree implementation.
			Arranging order – The values in a set are unindexed.
		Note: To store the elements in an unsorted(random) order,  unordered_set() can be used.
		-set is little slower than unordered_set.

		•The time complexities for doing various operations on sets are:
			-Insertion of Elements – O(log N)
			-Deletion of Elements – O(log N)
			-insert(), find(), erase(), count() -> O(long N)
			-size(), begin(), empty(), end() -> O(1).
		eg.
			#include <iostream>
			#include <set>
			using namespace std;
			int main(){
				std::set<char> a;
				a.insert('A');
				a.insert('B');
				a.insert('E');
				a.insert('D');
				a.insert('C');
				
				//repeated element will not be inserted again in set.
				a.insert('B');
				a.insert('A');
				
				
				//sorted increasing order,
				for (auto& str : a) {           //& sign used
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (auto str : a) {                //& not used still fine
					std::cout << str << ' ';
				}
				
				std::cout << '\n';
				for (char str : a) {                //dataType char used.
					std::cout << str << ' ';
				}
				
				set<int> inSt;
				inSt.insert(100);
				
				inSt.insert(1);
				inSt.insert(1);
				
				inSt.insert(2);
				
				inSt.insert(5);
				inSt.insert(5);
				
				inSt.insert(4);
				inSt.insert(200);
				
				cout<<"\n";
				for(int i: inSt)
				cout<<i<<" ";
				
				//Decreasing order set
				set<int, greater<int>> descSet;
				
				descSet.insert(0);
				descSet.insert(1);
				
				descSet.insert(3);
				descSet.insert(3);
				
				descSet.insert(4);
				
				
				descSet.insert(200);
				descSet.insert(200);
				descSet.insert(300);
				
				descSet.insert(400);
				
				descSet.insert(2);
				descSet.insert(2);
				
				//descSet 
				cout<<"\n";
				for(int i: descSet)
				cout<<i<<" ";
				
				//erasing
				set<int>::iterator IT = descSet.begin();
				IT++;
				IT++;
				
				descSet.erase(IT);
				cout<<"\n Erased 2nd element:";
				for(int i: descSet)
				cout<<i<<" ";
				
				//deleting 300 from set, directly passing element which want to delete.
				descSet.erase(300);
				cout<<"\n 300 erased: ";
				for(int i: descSet)
				cout<<i<<" ";
				
				cout<<"\n400 is present in descSet ? "<<descSet.count(400);
				cout<<"\n300 is present in descSet ? "<<descSet.count(300);
				
				cout<<"\ndescSet empty? "<<descSet.empty();

				cout<<"\ndescSet max_size? "<<descSet.max_size();
				cout<<"\ndescSet size? "<<descSet.size();
				
				descSet.clear();
				cout<<"\ndescSet empty? "<<descSet.empty();
				
				return 0;
			}
			//output:
				A B C D E 
				A B C D E 
				A B C D E 
				1 2 4 5 100 200 
				400 300 200 4 3 2 1 0 
				Erased 2nd element:400 300 4 3 2 1 0 
				300 erased: 400 4 3 2 1 0 
				400 is present in descSet ? 1
				300 is present in descSet ? 0
				descSet empty? 0
				descSet max_size? 230584300921369395
				descSet size? 6
				descSet empty? 1

	9) Map:
		-Stores data in form of key-value pair
		-all keys are unique, one key points to one value only.
		-same keys will not points to different value,
		-value of keys might be same.
		-keys stored in sorted order.
		-Time Complexity:
			insert(), erase(), find(), count() is O(log N).
		eg.

			#include <iostream>
			#include <map>
			using namespace std;

			int main(){
				map<int, string> m;
				std::cout << " Before, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;
				
				m[4] = "Vivek";
				m[70] = "Seven";
				m[80] = "EIGHT";
				m[3] = "Rohini";
				m[2] = "Nikate";
				m[1] = "Aai";
				m[50] = "papa";
				
				m.insert({-10,"Minus num"});
				m.insert({-11, "minus 11"});

				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";

				std::cout << "After, map size : "<< m.size() << std::endl;
				std::cout << "map size : "<< m.max_size() << std::endl;
				std::cout << "map empty? : "<< m.empty() << std::endl;

				//key present
				std::cout << "4 key present? "<< m.count(4) << std::endl;
				std::cout << "40 key present? "<< m.count(40) << std::endl;

				//erase
				m.erase(2); //key 2 removed
				m.erase(-11); //key 2 removed
				
				for(auto i: m)
					cout<<i.first<<" "<<i.second<<"\n";
				
				cout<<"\n";
				//print all element after key 4.
				auto it = m.find(4);
				for(auto i=it; i != m.end(); i++)
					cout<<(*i).first<<" "<<(*i).second<<"\n";
				
				return 0;
			}

	10) STL Algorithm:
		sort() works on introsort, its combination of quick sort, heap sort & insertion sort.
		eg.
			#include <algorithm>
			#include <vector>
			using namespace std;

			int main()
			{
				vector<int> v={11,55,44,33,22,23,78,90,45,67,879,675};
				
				std::cout << "Vector size : "<< v.size() << std::endl;
				
				//find 22 (not working properly)
				std::cout << "22 present? "<< binary_search(v.begin(), v.end(), 55) << std::endl;
				std::cout << "upper_bound : "<< upper_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				std::cout << "lower_bound : "<< lower_bound(v.begin(), v.end(),90)-v.begin() << std::endl;
				

				int a=90, b=40;
				std::cout << "MAX of A & B : "<< max(a,b) << std::endl;
				std::cout << "min of A B"<< min(a,b) << std::endl;

				printf("A: %d, B: %d", a,b);
				swap(a,b);
				printf("\nA: %d, B: %d", a,b);
				
				string str = "asdfghjkl";
				std::cout << "String : "<< str << std::endl;
				
				reverse(str.begin(),str.end());
				std::cout << "Reverse String : "<< str << std::endl;

				std::cout  << std::endl;
				//rotate
				for(auto i:v)
					cout<<i<<" ";
				
				rotate(v.begin(), v.begin()+3, v.end());
				
				std::cout  << std::endl;
				for(auto i:v)
					cout<<i<<" ";
					
				//sorted
				sort(v.begin(), v.end());
				std::cout << std::endl << "Sorted: ";
				for(auto i:v)
					cout<<i<<" ";
				return 0;
			}
			//output:
				Vector size : 12
				22 present? 0
				upper_bound : 10
				lower_bound : 10
				MAX of A & B : 90
				min of A B40
				A: 90, B: 40
				A: 40, B: 90String : asdfghjkl
				Reverse String : lkjhgfdsa

				11 55 44 33 22 23 78 90 45 67 879 675 
				33 22 23 78 90 45 67 879 675 11 55 44 
				Sorted: 11 22 23 33 44 45 55 67 78 90 675 879
---------------------------------------------------------------------------------------------------------
	27/08/23
Lecture-20: LeetCode Practice:
		1) Reverse Vector:
			-reverse(startIndex, endIndex);
			-reverse function defined in the algorithm header file.
			using built in function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					std::cout  << std::endl;
					reverse(v.begin(), v.end());
					
					cout<<"After: ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";

					return 0;
				}

			Without using builtint function:
				#include <iostream>
				#include <vector>
				#include <algorithm>
				using namespace std;

				vector<int> REVERSE(vector<int> a){
					int start=0, end = a.size()-1;
					
					while(start <= end){
						swap(a[start], a[end]);
						start++;
						end--;
					}
					
					return a;
				}

				int main(){
					vector<int> v {33,55,66,22,11,32};
					
					cout<<"Before : ";
					for(int i=0;i<v.size();i++)
						cout<<v[i]<<" ";
						
					
					vector<int> ans= REVERSE(v);
					
					cout<<"\nAfter: ";
					for(int i=0;i<ans.size();i++)
						cout<<ans[i]<<" ";

					return 0;
				}
			
		2) Reverse The Array:
			-Reversing array from given position
			eg.
				Sample Input 1:
				2
				6 3
				1 2 3 4 5 6
				5 2
				10 9 8 7 6
				Sample Output 1:
				1 2 3 4 6 5
				10 9 8 6 7
				Explanation 1:
				For the first test case, 
				Considering 0-based indexing we have M = 3 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {1, 2, 3, 4, 6, 5}.

				For the second test case, 
				Considering 0-based indexing we have M = 2 so the 
				subarray[M+1 … N-1] has to be reversed.
				Therefore the required output will be {10, 9, 8, 6, 7}.
				Sample Input 2:
				2
				7 3
				1 4 5 6 6 7 7 
				9 3
				10 4 5 2 3 6 1 3 6
				Sample Output 2:
				1 4 5 6 7 7 6
				10 4 5 2 6 3 1 6 3 

			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				return reverse(arr.begin()+m+1,arr.end());
			}

			//or
			#include <bits/stdc++.h> 
			void reverseArray(vector<int> &arr , int m){
				int start = m+1, end = arr.size()-1;
				while (start <= end) {
					swap(arr[start], arr[end]);
					start++;
					end--;
				}
			}
		
		3) Merge Sorted Array:
			void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
				vector<int> nm;
				int i=0,j=0;
				while(i<m && j<n){
					if(nums1[i] < nums2[j]){
						nm.push_back(nums1[i++]);
					}else{
						nm.push_back(nums2[j++]);
					}
				}

				while(i < m)
					nm.push_back(nums1[i++]);

				while(j < n)
					nm.push_back(nums2[j++]);
				
				//nums1.clear();
				nums1 = nm;
			}
		
			#Program:
				#include<iostream>
				#include<vector>
				using namespace std;

				void merge(int arr1[], int n, int arr2[], int m, int arr3[]) {
					int i = 0, j = 0;
					int k = 0;
					while( i<n && j<m) {
						if(arr1[i] < arr2[j]){
							arr3[k++] = arr1[i++];
						}
						else{
							arr3[k++] = arr2[j++];
						}
					}

					//copy first array k element ko
					while(i<n) {
						arr3[k++] = arr1[i++];
					}

					//copy kardo second array k remaining element ko
					while(j<m) {
						arr2[k++] = arr2[j++];
					}
				}

				void print(int ans[], int n) {
					for(int i=0; i<n; i++) {
						cout<< ans[i] <<" ";
					}
					cout << endl;
				}

				int main(){
					int arr1[5] = {1,3,5,7,9};
					int arr2[3] = {2,4,6};

					int arr3[8] = {0};

					merge(arr1, 5, arr2, 3, arr3);
					print(arr3, 8);
					return 0;
				}

		4) Move Zeroes:
			Given an integer array nums, move all 0's 
			to the end of it while maintaining the relative order of the non-zero elements.
			Note that you must do this in-place without making a copy of the array.
				Example 1:

				Input: nums = [0,1,0,3,12]
				Output: [1,3,12,0,0]
				Example 2:

				Input: nums = [0]
				Output: [0]
			->
				void moveZeroes(vector<int>& nums) {
					int len = nums.size();
					int cnt =0;
					vector<int> temp;
					for(int i=0;i<len;i++){
						if(nums[i] == 0)
							cnt++;
						else
							temp.push_back(nums[i]);
					}
					for(int i=0; i<cnt; i++)
						temp.push_back(0);
					
					nums = temp;
				}

				//or
					int i=0;
					for(int j=0;j<nums.size(); j++)
						if(nums[j] != 0)
							swap(nums[i++], nums[j]);
				
				//or
					int cnt=0;
					for(int i=0;i<nums.size();i++)
						if(nums[i] != 0)
							nums[cnt++] = nums[i];
					
					while(cnt<nums.size())
						nums[cnt++] = 0;
		
		5) Subarray or not?
			#include <iostream>
			using namespace std;

			bool isSubArr(int mainArr[], int orSize, int part[], int partSize){
				if(partSize > orSize)
					return 0;
				
				int k=0,i;
				for(i=0;i<partSize;){
					if(part[i] == mainArr[k]){
						for(int tr = k;;tr++){
							if((i < partSize) && tr != orSize && part[i] == mainArr[tr]){
								i++;
								if(i == partSize)
								return 1;
								continue;
							}else{
								return 0;
							}
						}
					}
					if(k >= orSize)
					break;
					k++;
				}
				return 0;
			}

			int main(){
				int arr[] = {1,2,3,4,5,6,7,8,9,10}, len=10;
				
				int sub[] = {13,14,15};
				int nSub[] = {6,7,8,9,10,11};
				int largerSizeArr[] = {1,2,3,4,5,6,7,8,9,10,11};
				
				int testArr1[] = {4,5,6,7}, testLen1 = 4;
				int testArr2[] = {8,9,10}, testLen2 = 3;
				int testArr3[] = {9,10,11,12}, testLen3 = 4;
				int testArr4[] = {11,12,15,16,20}, testLen4 = 5;

				isSubArr(arr, len, sub, 3)? std::cout << "Sub is SubArray " << std::endl : std::cout << "Sub is not SubArray" << std::endl;
				isSubArr(arr, len, nSub, 6)? std::cout << "nSub is SubArray " << std::endl : std::cout << "nSub is not SubArray" << std::endl;
				isSubArr(arr, len, largerSizeArr, 11)? std::cout << "largerSizeArr is SubArray " << std::endl : std::cout << "largerSizeArr is not SubArray" << std::endl;
				
				isSubArr(arr, len, testArr1, testLen1)? std::cout << "testArr1 is SubArray " << std::endl : std::cout << "testArr1 is not SubArray" << std::endl;
				isSubArr(arr, len, testArr2, testLen2)? std::cout << "testArr2 is SubArray " << std::endl : std::cout << "testArr2 is not SubArray" << std::endl;
				isSubArr(arr, len, testArr3, testLen3)? std::cout << "testArr3 is SubArray " << std::endl : std::cout << "testArr3 is not SubArray" << std::endl;
			
				//not SubArray
				isSubArr(arr, len, testArr4, testLen4)? std::cout << "testArr4 is SubArray " << std::endl : std::cout << "testArr4 is not SubArray" << std::endl;

				return 0;
			}
---------------------------------------------------------------------------------------------------------
	3/09/23
Lecture-21: Solving LeetCode/CodeStudio Questions [Arrays]
		1) Rotate Array
			Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
				Example 1:

				Input: nums = [1,2,3,4,5,6,7], k = 3
				Output: [5,6,7,1,2,3,4]
				Explanation:
				rotate 1 steps to the right: [7,1,2,3,4,5,6]
				rotate 2 steps to the right: [6,7,1,2,3,4,5]
				rotate 3 steps to the right: [5,6,7,1,2,3,4]
				Example 2:

				Input: nums = [-1,-100,3,99], k = 2
				Output: [3,99,-1,-100]
				Explanation: 
				rotate 1 steps to the right: [99,-1,-100,3]
				rotate 2 steps to the right: [3,99,-1,-100]

			class Solution {
				public:
				void rotate(vector<int>& nums, int k) {
					int n = nums.size();
					vector<int> temp(n);

					for(int i=0;i<n;i++)
						temp[(i+k)%n] = nums[i];

					nums = temp;
				}
			};
		
		2) Check if Array Is Sorted and Rotated:
			https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/
			class Solution {
			public:
				bool check(vector<int>& nums) {
					int cnt=0;
					for(int i=1;i<nums.size();i++)
						if(nums[i-1] > nums[i])
							cnt++; 
					if(nums[nums.size()-1] > nums[0])
						cnt++;
					return cnt<=1;
				}	
			};

		3) Sum Of Two Arrays:
			Sample Input 1:
				2
				4 1 
				1 2 3 4
				6
				3 2
				1 2 3
				9 9    
				Sample Output 1:
				1 2 4 0
				2 2 2
				Explanation For Sample Input 1:
				For the first test case, the integer represented by the first array is 1234 and the second array is 6, so the sum is 1234 + 6 =  1240.

				For the second test case, the integer represented by the first array is 123 and the second array is 99, so the sum is 123 + 99 = 222.
				Sample Input 2:
				2
				3 3 
				4 5 1
				3 4 5
				2 2
				1 1
				1 2
				Sample Output 2:
				7 9 6
				2 3

			#include <bits/stdc++.h> 
			int convertor(vector<int> , int);
			vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {

				int n1 = convertor(a, n);
				int n2 = convertor(b, m);

				int sum = n1 + n2;

				vector<int> sample;

				while(sum){
					int temp = sum % 10;
					sample.push_back(temp);
					sum /=10;
				}

				reverse(sample.begin(), sample.end());
				return sample;	
			}

			int convertor(vector<int> a, int len){
				int num =0;
				//array to num
				for(int i=0;i<len;i++)
					num = num * 10 + a[i];

				return num;
			}

			#include <bits/stdc++.h> 
			vector<int> findArraySum(vector<int>& a, int n, std::vector<int>& b, int m) {
				vector<int> v;
				int i = n - 1;
				int j = m - 1;
				int carry = 0;

				while (i >= 0 && j >= 0) {
						
					int sum = a[i--] + b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//first array len is greater than second
				while (i >= 0) {
					int sum = a[i--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//second array len is greater than first
				while (j >= 0) {
					int sum = b[j--] + carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}

					//carry is remain to add
				while (carry != 0) {
					int sum = carry;

					carry = sum / 10;
					sum = sum % 10;

					v.insert(v.begin(), sum);
				}
				return v;
			}
---------------------------------------------------------------------------------------------------------
	14/09/23
Lecture-22: All about Char Arrays, Strings & solving LeetCode Questions
		-String: 1D (one-dimensional char array.)
		 '\0' - end of string, present at the end of string (null character).
		 #include <iostream>
		 using namespace std;
		 int main(){
			char name[10];
		 	std::cout << "Enter name : " << std::endl;
		 	
		 	cin>>name;      //cin stop taking input after getting space, new line or tab.
		 	std::cout << name << std::endl;
		 	
		 	// Enter name : 
			// Vivek Nikate
			// Vivek
			return 0;
		}

		-if null character found then compiler consider it as the end of string.
			eg.
			#include <iostream>
			using namespace std;
			int main(){
				char name[15];
				std::cout << "Enter name : " << std::endl;
				
				cin>>name;      //cin stop taking input after getting space, new line or tab.
				name[3] = '\0';	//after 3rd index compiler consider it as end of string.
				std::cout << name << std::endl;
				
				// Enter name : 
				// VivekNikate
				// Viv
				
				return 0;
			}

		// WAP to find the Length of string
			#include <iostream>
			using namespace std;
			int main(){
				char name[15];
				std::cout << "Enter name : " << std::endl;
				
				cin>>name;
				int len=0;

				while(name[len++] != '\0');	
				std::cout << "The Length of string is :: "<< len-1 << std::endl;
				return 0;
			}
			Enter name : 
			Vivek
			The Length of string is :: 5
		
		//String
			#include <iostream>
			using namespace std;
			int main(){
			
				// string s;        //for printf statement string won't work.
				char s[100];
				std::cout << "Enter name: " << std::endl;
				cin>>s;
				
				printf("Your name : %s ",s);
				cout<<"your name: "<<s;
				return 0;
			}

		- WAP Reverse a string:
			#include <iostream>
			#include<algorithm>
			using namespace std;
			int main(){
				
				string s;
				std::cout << "Enter name: " << std::endl;
				cin>>s;
				string temp = s;
				std::cout << "Your name : " <<s<< std::endl;
				
				reverse(s.begin(), s.end());
				//or
				cout<<"reverse : "<<s<<endl;
				
				s = temp;
				cout<<"Length of string is :: "<< s.size()<<endl;             //Length using size() function
				cout<<"Length of string is :: "<< s.length()<<endl;           //Length using length() function
				
				//or custom calculating length of string
				int i=0;
				while(s[i++] != '\0');
				cout<<"Length of string is :: "<< i-1<<endl;
				
				int start =0;
				int len = i-2;
				while(start <= len){
					swap(s[start++],s[len--]);
				}
				
				cout<<"Reverse string custom :"<< s <<endl;
				return 0;
			}		

		- Reverse String
			https://leetcode.com/problems/reverse-string/description/
			class Solution {
			public:
				void reverseString(vector<char>& s) {
					// reverse(s.begin(), s.end());
					int start=0,end=s.size()-1;
					while(start<end)
						swap(s[start++],s[end--]);
				}
			};

		- Check If The String Is A Palindrome
			#include <bits/stdc++.h> 
			bool checkPalindrome(string s){
				string ans;
				for(int i=0;i<s.length();i++){
					if(('a' <= s[i] && s[i] <= 'z') || 
						('A'<=s[i] && s[i] <='Z') || ('0'<=s[i] && s[i] <='9'))
						ans += s[i];


					//or for above if condition,
						//after converting to lowercase
						//if((isalpha(s[i])) || isdigit(s[i]))	 //to check isalphabate or not and isdigit or not.
						//	ans += s[i];
				}

				//or to check is Alphabet or number,
				//for(int i=0;i<s.length();i++){
				//     if(isalnum(s[i]))
				//         ans += s[i];
				// }

				transform(ans.begin(), ans.end(), ans.begin(), ::tolower);
				string temp = ans;
				reverse(temp.begin(), temp.end());
				if(ans == temp)
					return 1;
				return 0;
			}

			//converting Uppercase char to lower
				char toLowerCase(char ch) {
					if(ch >='a' && ch <='z')
						return ch;
					else
						char temp = ch - 'A' + 'a';
					return temp;
				}

			//upper to lower or viceversa,
				#include <iostream>
				using namespace std;
				int main(){
					char ch1 = 'u', ch2='v', ch3='D';
					std::cout << char(ch1-32) << std::endl;             //U
					std::cout << char(ch2-32) << std::endl;             //V
					std::cout << char(ch3+32) << std::endl;             //d
					
					return 0;
				}

				//or
					#include <iostream>
					using namespace std;
					char TOLOWER(char);
					char TOUPPER(char);
					int main(){
						char ch1 = 'A', ch2 = 'b';
						
						cout<<TOLOWER(ch1)<<endl;
						cout<<TOUPPER(ch2)<<endl;
						return 0;
					}

					char TOLOWER(char ch){
						return ch - 'A' + 'a';
					}

					char TOUPPER(char ch){
						return ch - 'a' + 'A';
					}

			//Palindrome:
				#include<string>
				#include<iostream>
				#include<vector>
				using namespace std;
				class Solution {
					private:
					bool valid(char ch) {
						if( (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
							return 1;
						}
						
						return 0;
					}
					
					char toLowerCase(char ch) {
						if( (ch >='a' && ch <='z') || (ch >='0' && ch <='9') )
							return ch;
						else{
							char temp = ch - 'A' + 'a';
							return temp;
						}
					}

					bool checkPalindrome(string a) {
						int s = 0;
						int e = a.length()-1;

						while(s<=e) {
							if(a[s] != a[e])
							{
								return 0;       
							}
							else{
								s++;
								e--;
							}
						}
						return 1;
					}
					public:
					bool isPalindrome(string s) {
						
						//faltu character hatado
						string temp = "";
						
						for(int j=0; j<s.length(); j++) {   
							if(valid(s[j])) {
								temp.push_back(s[j]);
							}
						}
						
						//lowercase me kardo
						for(int j=0; j<temp.length(); j++) { 
							temp[j] = toLowerCase(temp[j]);
						}
						
						//check palindrome
						return checkPalindrome(temp);	
					}
				};

			//without using extra space or temp string:
				#include <bits/stdc++.h> 
				bool checkPalindrome(string s){
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					int i=0, j = s.size()-1;
					while(i<j){
						if(!isalnum(s[i])){
							i++;
							continue;
						}
						if (!isalnum(s[j])) {
							j--;
							continue;
						}
						if (s[i] != s[j])
							return false;
						i++;
						j--;
					}
					return true;
				}

			//or
				#include <bits/stdc++.h> 
				bool checkPalindrome(string s){
					transform(s.begin(), s.end(), s.begin(), ::tolower);

					int i=0, j = s.size()-1;
					while(i<j){
						if (isalnum(s[i])) {
							if(isalnum(s[j])){
								if(s[i] == s[j]){
									i++;j--;
									continue;    
								}else{
									return false;
								}
							}else{
								j--;
							}
						}else{
							i++;
						}
					}
					return true;
				}

		- simple Palindrome checker:
			#include <iostream>
			using namespace std;
			int main(){
				string s;
				cout<<"Enter string to check Palindrome or not?"<<endl;
				cin>>s;
				
				int i=0;
				for(i;i<s.length()/2;i++)
					if(s[i] != s[s.length()-1-i]){
						cout<<"Not Palindrome";
						break;
					}
					
				if(i == s.length()/2)
					cout<<"Palindrome";
				return 0;
			}

		- Valid Palindrome
			https://leetcode.com/problems/valid-palindrome/description/
			 class Solution {
				public:
				bool isPalindrome(string s) {		
					transform(s.begin(), s.end(), s.begin(), ::tolower);
					string ans;

					for(int i=0;i<s.length() ; i++){
						if((s[i] >= 'a' && s[i] <= 'z') || (s[i]>='0' && s[i] <='9'))
							ans += s[i];
					}
					s = ans;
					reverse(ans.begin(), ans.end());
					return (ans == s)? true:false;
				}
			};

			//or
				class Solution {
					public:
					bool isPalindrome(string s) {
						transform(s.begin(), s.end(), s.begin(), ::tolower);
						int i=0,j=s.length()-1;
						while(i<j){
							if(!isalnum(s[i])){
								i++;
								continue;
							}
							if(!isalnum(s[j])){
								j--;
								continue;
							}
							if(s[i] != s[j])
								return false;
							i++;j--;
						}
						return true;
					}
				};

		//String Operations:
			#include <iostream>
			using namespace std;

			int main(){
			
				string s = "Hello World";
				cout<<s<<endl;
				
				s.pop_back();
				cout<<s<<endl;                      //removing element from last.
				
				s.push_back('V');                   //adding element at last or s = s + 'V';
				cout<<s<<endl;
				
				cout<<s.front()<<endl;              //first element of string
				cout<<s.back()<<endl;               //last element of string
				
				cout<<s.at(4)<<endl;                //char at 4th index (0-based index)
				
				cout<<"String length is :: "<<s.length()<<endl;

				s.erase(2,3);
				cout<<s<<endl;                  //from index 2nd remove 3 char here llo got removed.

				cout<<"String length After erasing :: "<<s.length()<<endl;
				return 0;
			}

		// upper/lower case char conversion
			#include <iostream>
			#include <algorithm>
			using namespace std;
			int main(){
				string s = "Hello World";
				
				std::cout << s << std::endl;

				std::cout << char(tolower('A')) << std::endl;
				
				//string upper to lower case
				transform(s.begin(), s.end(), s.begin(), ::tolower);
				// transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
				std::cout << s << std::endl;
				
				transform(s.begin(), s.end(), s.begin(), ::toupper);
				std::cout << s << std::endl;
				
				return 0;
			}

		//convert string to uppercase or lowercase
			#include <iostream>
			#include <algorithm>
			using namespace std;

			int main(){
				string s1 = "VIVEK", s2="nikate", s3 = "third", s4 = "this is first letter capital sentence.";
				
				transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
				std::cout << s1 << std::endl;
				
				transform(s2.begin(), s2.end(), s2.begin(), ::toupper);
				std::cout << s2 << std::endl;
				
				s3[0] = toupper(s3[0]);
				std::cout << s3 << std::endl;
				
				int i=0;
				while(s4[i] != '\0'){
					if(i==0) s4[i] = toupper(s4[i]);
					if(isblank(s4[i])) s4[i+1] = toupper(s4[i+1]);
					i++;
				}

				std::cout << s4 << std::endl;	
				return 0;
			}

		Char Array:
			#include <iostream>
			int main(){
				char str[] = "sadf\0tyuio";
				std::cout << str[0] << std::endl;
				std::cout << str << std::endl;
				
				char ch[] = {'v','i','\0','v','e','k'};
				cout<<ch;
				return 0;
			}

			differences (string & char array):
				-String refers to a sequence of characters represented as a single data type. 
				-Character Array is a sequential collection of data type char.

			  Characteristic					String					Char array
				Data type						Class				 	 Array
				Size							Dynamically allocated		 Fixed size
				Null terminator				Automatically appended		 Not automatically appended
				Memory management				Automatic					 Manual
				Operations					Supported					 Not supported
				Speed						Slower					 Faster
				Safety						Safer					 Less safe

		// Reverse sentence:
			Sample Input 1 :
				Welcome to Coding Ninjas
				Sample Output 1:
				Ninjas Coding to Welcome
				Explanation For Sample Input 1:
				You need to reduce multiple spaces between two words to a single space in the reversed string and observe how the multiple spaces, leading and trailing spaces have been removed.
			Sample Input 2 :
				I am a star
				Sample Output 2:
				star a am I
				Explanation For Sample Input 2:
				Your reversed string should not contain leading or trailing spaces.

			string reverseString(string &str){
				vector<string> ans;
				int i=0;

				while(i<str.length()){
					if(str[i] == ' '){
						i++;
						continue;
					}

					string temp;
					while(str[i] != ' ' && str[i] !='\0'){
						temp += str[i];

						i++;
					}
					ans.push_back(temp);
				}

				i=ans.size()-1;
				str = "";
				while(i>=0){
					str += ans[i];
					if( i!=0)
						str += ' ';
					i--;
				}
				return str;	
			}

		// Reverse Words in a String III
			Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
				Example 1:

				Input: s = "Let's take LeetCode contest"
				Output: "s'teL ekat edoCteeL tsetnoc"
				Example 2:

				Input: s = "God Ding"
				Output: "doG gniD"
			https://leetcode.com/problems/reverse-words-in-a-string-iii/description/
			class Solution {
			public:
				string reverseWords(string s) {
					string temp;
					vector<string> holder;

					int i=0;
					while(i<s.length()){
						if(s[i] == ' '){
							i++;
							continue;
						}

						while(s[i] != ' ' && s[i] != '\0'){
							temp += s[i];
							i++;
						}
						holder.push_back(temp);
						temp="";
						i++;
					}

					s="";
					
					for(int a=0;a<holder.size();a++){
						string st =  holder[a];
						reverse(st.begin(), st.end());
						s += st;
						if(a != holder.size()-1)
							s += " ";               // s = s + ' ' or s = s + " ";
					}
					return s;
				}
			};

			//or
				class Solution {
					public:
					string reverseWords(string s) {
						string revSentence;
						string word;
						for(int i=0; i<s.length(); i++){
							if(s[i] == ' '){
								reverse(word.begin(), word.end());
								revSentence += word + " ";
								word = "";
								continue;
							}
							word += s[i];
						}

						//code to add last word
						reverse(word.begin(), word.end());
						revSentence += word;

						return revSentence;
					}
				};

		// Print first n Fibonacci Numbers
			Given a number N, find the first N Fibonacci numbers. The first two number of the series are 1 and 1.
				Example 1:

				Input:
				N = 5
				Output: 1 1 2 3 5
				Example 2:

				Input:
				N = 7
				Output: 1 1 2 3 5 8 13
				Your Task:
				Your task is to complete printFibb() which takes single argument N and returns a list of first N Fibonacci numbers.

				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(N).
				Note: This space is used to store and return the answer for printing purpose.

				Constraints:
				1<= N <=84

			class Solution{
				public:
				//Function to return list containing first n fibonacci numbers.
				vector<long long> printFibb(int n){
					long long prev=1, curr =1;
					vector<long long> ans;
					ans.push_back(curr);
					
					if(n == 1)
						return ans;
						
					ans.push_back(prev);
					if(n ==2)
						return ans;
					
					for(int i=2;i<n;i++){
						long long fib = curr + prev;
						prev = curr;
						curr = fib;
						ans.push_back(fib);
					}
					return ans;
				}
			};

		// Nth Fibonacci Number:
			class Solution {
				public:
				int nthFibonacci(int n){
					int cur=1,prev=0;
					int mod = 1e9+7;
					if(n == 0)
						return prev;
					else if(n==1)
						return cur;
					else
						for(int i=2;i<=n;i++){
							int fib = (cur +prev) % mod;
							prev = cur;
							cur = fib;
						}

					return cur;
				}
			};

		// Maximum Occuring Character
			Given a string str of lowercase alphabets. The task is to find the maximum occurring character in the string str. 
			 If more than one character occurs the maximum number of time then print the lexicographically smaller character.
				Example 1:

				Input:
				str = testsample
				Output: e
				Explanation: e is the character which
				is having the highest frequency.
				Example 2:

				Input:
				str = output
				Output: t
				Explanation:  t and u are the characters
				with the same frequency, but t is
				lexicographically smaller.
				Your Task:
				The task is to complete the function getMaxOccuringChar() which returns the character which is most occurring.

				Expected Time Complexity: O(N).
				Expected Auxiliary Space: O(Number of distinct characters).
				Note: N = |s|

				Constraints:
				1 ≤ |s| ≤ 100
			class Solution{
				public:
				//Function to find the maximum occurring character in a string.
				char getMaxOccuringChar(string str){
					int cnt=1,prev=cnt;
					char mainCh = str[0];
					for(int i=0;i<str.length();i++){
						for(int j=0;j<str.length();j++){
							if(str[i] == str[j])
								cnt++;
						}
						
						if(cnt> prev || (cnt >= prev && str[i] < mainCh)){
							mainCh = str[i];
							prev=cnt;
						}
						cnt=1;
					}
					
					return mainCh;
				}
			};

			//or
				class Solution{
					public:
					//Function to find the maximum occurring character in a string.
					char getMaxOccuringChar(string str){
						int arr[26] = {0};
						for(int i=0; i<str.length();i++){
							int num;
							//between lowercase     
							if(str[i]>='a' && str[i]<='z'){
								num = str[i] - 'a';
							}else{      //between uppercase
								num = str[i] - 'A';
							}
							arr[num]++;
						}
						
						int mx=arr[0], index=0;
						for(int i=0;i<26;i++){
							if(mx<arr[i]){
								mx = arr[i];
								index = i;
							}
						}
						return char('a'+index);
					}
				};

		// WAP to take string as input
			#include <iostream>
			using namespace std;
			int main(){
				
				string s;
				std::cout << "Enter name: (stop taking input when we hit enter) " << std::endl;
				getline(cin, s);                //getline function works for string datatype only.
				cout<<s<<endl;
				
				
				// for character datatype use cin.getline(char_array_name, max_size) function,
				char str[100];
				std::cout << "Enter name again:" << std::endl;
				cin.getline(str, 50);
				std::cout << str << std::endl;
				
				//ending string with some particular delimiter
				//$
				//when user enter $ it stop taking input
				//whatever comes after $ it will not consider it.
				std::cout << "Enter name : delimiter" << std::endl;
				cin.getline(str,100, '$');
				std::cout << str << std::endl;
				
				
				std::cout << "Enter name: delimit by * " << std::endl;
				getline(cin, s, '*');                //getline function works for string datatype only.
				cout<<s<<endl;
				
				//delimiter by [
				std::cout << "Enter name: delimiter [ : " << std::endl;
				cin.getline(str, 100, '[');
				std::cout << str << std::endl;
				
				s="";
				//delimiter with string, stop taking input when you encounter ^.
				std::cout << "Enter name for string delimiter :" << std::endl;
				getline(cin,s,'^');
				std::cout << s << std::endl;
				return 0;
			}

		// char array Operation:
			#include <iostream>
			#include<cstring>
			using namespace std;

			int main(){
				char s1[] ="Vivek_Mahesh_Nikate";
				char s2[] ="Nikate";
				char s3[] ="Vivek";
					
				std::cout << strlen(s1) << std::endl;           //strlen function works with char array only.
				
				std::cout << strcmp(s2,s1) << std::endl;        //s1-s2 first string is smaller so -ve answer
				std::cout << strcmp(s1,s2) << std::endl;        //s2-s1 first string is larger so +ve answer
				
				//if both are equal then 0
				std::cout << strcmp(s3,s1) << std::endl;
				
				std::cout << s1 << std::endl;
				
				//after copying s1 is:
				strcpy(s1,"New_String");        //strcpy(source, destination), strcpy(place_to_take_new_value, new_value),
				std::cout << s1 << std::endl;
				
				char s4[] = "Cat ";
				char s5[] = "Meow ";
				std::cout << s4 << std::endl;
				std::cout << s5 << std::endl;
				strcat(s4,s5);      // s4 = s4 + s5;
				
				std::cout << s4 << std::endl;
				return 0;
			}

		// string insertion
			#include <iostream>
			using namespace std;

			int main(){
				string s="Hello World";
				string s1("Vivek Nikate");	//we can define string like this also.

				cout<<s<<endl;				//Hello World
				
				s.insert(3," Vivek ");          //after 2nd index insert new string or after 3 char insert this new string
				std::cout << s << std::endl;     //Hel Vivek lo World

				s.insert(1,"Nikate");           //after one character insert new string.
				std::cout << s << std::endl;	  //HNikateel Vivek lo World

				string s5 = "Name:.";
				string s6 = "VivekMaheshNikate";
				
				s5.insert(5, s6,5,6);               //after 5 char insert s6 to s5, but just first 6 char of s6 only. from 5th index (0-index based)
				std::cout << s5 << std::endl;       //Name:Mahesh.
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					string s = "BIG WORLD";
					
					std::cout << s << std::endl;
					s.insert(2,3,';');         //from 2nd index, means after char of s, insert (;) 3 times.
					std::cout << s << std::endl;
					
					string s2 = "SMALL world";
					
					std::cout << s2 << std::endl;
					s2.insert(3,4,'\\');           //After char 'A', means after 3rd char, insert (\) 4 times, 
												// (\) is escape char so need to use twice
					std::cout << s2 << std::endl;
					
					return 0;
				}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					string s = "BIG WORLD";
					
					std::cout << s << std::endl;        //BIG WORLD
					
					//if you want to  insert just a char to string use this method
					s.insert(s.begin()+1,'%'); 
					std::cout << s << std::endl;        //B%IG WORLD

					s = "BIG WORLD";
					s.insert(s.end()-1,'+');      	//from ending of string   
					std::cout << s << std::endl;        //BIG WORL+D

					s = "BIG WORLD";
					s.insert(s.begin()+2,'@');         //from starting of string
					std::cout << s << std::endl;        //BI@G WORLD

					
					//want to insert string to string use below method
					s = "BIG WORLD";
					s.insert(4,"1234");
					std::cout << s << std::endl;		//BIG 1234WORLD
					
					s = "BIG WORLD";
					s.insert(3,"qwerty", 1);         //insert to s after 3 char but just insert first char of qwerty ie. q
					std::cout << s << std::endl;		//BIGq WORLD
					
					s = "BIG WORLD";
					s.insert(0,"qwerty", 2);         //insert to s from start, but just insert first 2 char of qwerty ie. qw
					std::cout << s << std::endl;		//qwBIG WORLD
					
					s = "BIG WORLD";
					s.insert(4,"qwerty", 3);         //insert to s after 4 char, but just insert first 3 char of qwerty ie. qwe
					std::cout << s << std::endl;		//BIG qweWORLD
					
					s = "BIG WORLD";
					s.insert(5,"qwerty", 3,3);         //insert to s after 5 char but just insert 3 char of qwerty, from 3rd index (0-based index).
					std::cout << s << std::endl;		//BIG WrtyORLD
					
					return 0;
				}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					string s1 ("ABCDef");             //length: 4
					string s2 ("//\\\\");           //length: 6, but Actual length: 4 due to escape char \.
					
					std::cout << s1 << std::endl;
					std::cout << s2 << std::endl;

					s2.insert(2,s1);
					std::cout << s2 << std::endl;
					
					//but just AB we need
					s2 = "{{}}";
					std::cout <<endl<< s2 << std::endl;

					//GLITCH
					s2.insert(2,s1,3);                  //sending string as variable s1 to insert function will output, start inserting from 3rd index of s1 till last.(0-based index)
					std::cout << s2 << std::endl;               //{{D}}
					
					s2 = "{{}}";
					s2.insert(2,"ABCDef",3);              //sending string directly to insert function will output, just takes first 3 char of given string.
					std::cout << s2 << std::endl;           //{{ABC}}
					
					
					s2="{{}}";
					
					s2.insert(2,s1,3);                  //start inserting s1 to s2 from 3rd index of s1.
					std::cout << s2 << std::endl;       //{{Def}}
					
					s2="[[]]";
					s2.insert(2,s1,3,2);                 //here we mentioned the start & no.of chars to take. 
													//start index :3, no.of chars to take :2
													//from 3rd of s1 take 2 chars ie. s1 is ABCDef from 3rd index is D
													//from there 2 chars means ie. De
													
					std::cout << s2 << std::endl;           //[[De]].
					
					return 0;
				}
			


		// Replace Spaces with @40:
			Sample Input 1:
				2
				Coding Ninjas Is A Coding Platform
				Hello World
				Sample Output 1:
				Coding@40Ninjas@40Is@40A@40Coding@40Platform
				Hello@40World
				Explanation Of Sample Output 1:
				In test case 1, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40Is@40A@40Coding@40Platform

				In test case 2, After replacing the spaces with “@40” string is: 

				Hello@40World
				Sample Input 2:
				3
				Hello
				I love coding
				Coding Ninjas India
				Sample Output 2:
				Hello
				I@40love@40coding
				Coding@40Ninjas@40India    
				Explanation For Sample Output 2:
				In test case 1, After replacing the spaces with “@40” string is: 

				Hello

				In test case 2, After replacing the spaces with “@40” string is: 

				I@40love@40coding

				In test case 3, After replacing the spaces with “@40” string is: 

				Coding@40Ninjas@40India
			#include <bits/stdc++.h> 
			string replaceSpaces(string &str){
				string temp;
				for(int i=0;i<str.length();i++){
					if(str[i] == ' '){
						temp += "@40";
					}else{
						temp += str[i];
					}
				}
				return temp;
			}

			//or without using extra space/ temp string.
				#include <iostream>
				using namespace std;

				int main(){
					string str= "H M M N";
					std::cout << str << std::endl;
					
					int len = str.length(), spaceCount=0;
						for(int i=0;i<len;i++)
							if(str[i] == ' ')
								spaceCount++;
						
						if(!spaceCount){
						std::cout << str << std::endl;
							return 0;
					}

						len -= spaceCount;
						len += (spaceCount*3);
						str.resize(len);

						for(int i=0;i<len;i++){
							if(str[i] == ' '){
								str.replace(i, 1,"@40");
								i +=2;
							}
						}
						
						std::cout << str << std::endl;
					return 0;
				}

		clear():
			The clear() function is used to remove all the elements of the vector container, thus making it size 0.
			Parameters: No parameters are passed.
			Result: All the elements of the vector are removed (or destroyed).

		erase():
			erase() function is used to remove elements from a container from the specified position or range.

			#include <iostream>
			using namespace std;

			int main(){
				string s;
				s=  "Hello World";
				std::cout << s << std::endl;                //Hello World
				
				s.erase(3,4);                       //after 3 chars remove 4 characters
				std::cout << s << std::endl;        //Helorld
				
				//except first 5 characters remove all
				s = "Hello World";
				s.erase(5);
				std::cout << s << std::endl;    //Hello
				
				//just remove 4th character         if we mention iterator then it remove only one character at that iterator index.
				s = "Hello World";
				s.erase(s.begin()+4); 
				std::cout << s << std::endl;        //Hell World
				
				//remove 4 characters from last
				s = "Hello World";
				s.erase(s.end()-4,s.end());             //s.erase(startIndex, endIndex);
				std::cout << s << std::endl;            //Hello W
				
				//remove last char from string
				s = "Hello World";
				s.pop_back();
				std::cout << s << std::endl;            //Hello Worl
				
				//remove last char from string using erase
				s = "Hello World";
				s.erase(s.end()-1);
				std::cout << s << std::endl;            //Hello Worl
				
				//remove 2nd last char from string using erase
				s = "Hello World";
				s.erase(s.end()-2);
				std::cout << s << std::endl;            //Hello Word
				
				//delete complete string
				s = "Hello World";
				s.erase();
				std::cout <<"String is ::" <<s << std::endl;            //Hello Worl
				
				//or
				s = "Hello World";
				s.clear();
				std::cout<<"Clear string :: " << s << std::endl;            //Hello Worl
				
				//append 4 char to end of string
				s = "Hello World";
				string w = s.substr(1,4);           //substr(startIndex, no.of char)
				s += " "  + w;
				std::cout << s  << std::endl;            //Hello World ello
				
				return 0;
			}

			//string operations:
				Example-1:
					#include <iostream>
					using namespace std;

					int main(){
						string s1 = "Vivek Mahesh Nikate";
						string s2 = "Learning is Hobby";
						
						cout<<"one is not present in s1 :: "<<boolalpha<<(s1.find("one") == string::npos)<<endl;
						
						//string::npos means sub string is not found. if s1.find("--") == string::npos, means substring does not exist.
						cout<<string::npos<<endl;
						
						if(s1.find("Vivek") != string::npos){
							std::cout << "SubString found" << std::endl;
						}else{
							std::cout << "SubString Not found" << std::endl;
						}
						
						//find() method returns the index of starting character of substring, & its case sensitive if not found 
						//it return value of string::npos & if(str.find() == string::npos) then you can say that substring not found.
						
						std::cout <<"learning is present in s2 :: " <<(s2.find("learning") != string::npos) << std::endl;
						
						std::cout <<"Hobby is present?  "<<(s2.find("Hobby") != string::npos) << std::endl;
						
						string s3 = "Learning @#@#@&@#@#@@#@#@@#@#@ pro@#@#@blem@#@#@ solving is @#@#@a most impor@#@#@tant skill @#@#@found in the @#@#@interview";
						
						//removing garbase from string,
						std::cout << s3 << std::endl;
						
						string part = "@#@#@";
						
						while(s3.find(part) != string::npos){
							if(s3.find(part) != string::npos)
								s3.erase(s3.find(part), part.length());
						}
						
						std::cout << s3 << std::endl;
						return 0;
					}

					/*
						output:
						one is not present in s1 :: true
						18446744073709551615
						SubString found
						learning is present in s2 :: false
						Hobby is present?  true
						Learning @#@#@&@#@#@@#@#@@#@#@ pro@#@#@blem@#@#@ solving is @#@#@a most impor@#@#@tant skill @#@#@found in the @#@#@interview
						Learning & problem solving is a most important skill found in the interview
					*/

				Example-2:
					#include <iostream>
					using namespace std;

					int main(){
					
						string s= "Hello_World";
						
						std::cout << s << std::endl;                    //Hello_World
						std::cout << s.substr(0,2) << std::endl;        //He    2 character
						std::cout << s.substr(6,2) << std::endl;        //wo    2 character
						std::cout << s.substr(s.length()-1) << std::endl;     //extracting last char    d
						std::cout << s.substr(4,1) << std::endl;            //o, 1 character extracting
						
						//extracting complete string except first 2 character,
						//or from 2nd index taking all character 
						std::cout << s.substr(2) << std::endl;                  //llo_World
						
						// removing l
						std::cout << s << std::endl;
						s.erase(s.begin()+2);
						std::cout << s << std::endl;
						
						//searching substr 'Hell',
						s = "Hello_World";
						string sub = "Hell";
						
						std::cout << "is string contain "<<sub<<"? " <<( (s.find(sub) != string::npos) ? "Yes":"no")<< std::endl;
						
						if(s.find(sub) != string::npos)
							s.erase(s.find(sub),sub.length());
							
						std::cout << "New string after removing : "<< s << std::endl;
						return 0;
					}

					/*
						output
						Hello_World
						He
						Wo
						d
						o
						llo_World
						Hello_World
						Helo_World
						is string contain Hell? Yes
						New string after removing : o_World
					*/

		// Remove All Occurrences of a Substring
			https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
			Given two strings s and part, perform the following operation on 
			 s until all occurrences of the substring part are removed:
				Find the leftmost occurrence of the substring part and remove it from s.
				Return s after removing all occurrences of part.

				A substring is a contiguous sequence of characters in a string.
				Example 1:
					Input: s = "daabcbaabcbc", part = "abc"
					Output: "dab"
					Explanation: The following operations are done:
					- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
					- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
					- s = "dababc", remove "abc" starting at index 3, so s = "dab".
					Now s has no occurrences of "abc".
				Example 2:
					Input: s = "axxxxyyyyb", part = "xy"
					Output: "ab"
					Explanation: The following operations are done:
					- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
					- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
					- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
					- s = "axyb", remove "xy" starting at index 1 so s = "ab".
					Now s has no occurrences of "xy".
			class Solution {
				public:
				string removeOccurrences(string s, string part) {
					while(s.length() != 0 && (s.find(part) < s.length())){
						s.erase(s.find(part), part.length());
					}
					return s;
				}
			};

			//or
				class Solution {
					public:
					string removeOccurrences(string s, string part) {
						// Find the starting index of the 'part' substring in 's'
						int pos = s.find(part);

						// Continue looping until 'part' is found in 's'
						while (pos != string::npos) {
							// Remove 'part' from 's' starting at the found position
							s.erase(pos, part.length());

							// Search for the next occurrence of 'part' in the modified 's'
							pos = s.find(part);
						}

						// Return the modified 's' after removing all occurrences of 'part'
						return s;
					}
				};

			//or
				class Solution {
					public:
					string removeOccurrences(string s, string part){

						while(s.find(part) != string::npos){
							s.erase(s.find(part), part.length());
						}
						return s;
					}
				};

		// Permutation in String
			Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
				In other words, return true if one of s1's permutations is the substring of s2.
				Example 1:
					Input: s1 = "ab", s2 = "eidbaooo"
					Output: true
					Explanation: s2 contains one permutation of s1 ("ba").

				Example 2:
					Input: s1 = "ab", s2 = "eidboaoo"
					Output: false
				Constraints:
					1 <= s1.length, s2.length <= 104
					s1 and s2 consist of lowercase English letters.
			
			class Solution {
				public:
				bool areEqual(int a1[26], int a2[26]){
					for(int i=0;i<26;i++)
						if(a1[i] != a2[i])
							return 0;
					return 1;
				}

				bool checkInclusion(string s1, string s2) {
					int count1[26]={0},count2[26]={0};
					int i=0;
					//what are the characters present in s1 mapping them (0-a, 1-b, 2-c) in count1 array & increment their count.
					while(i<s1.length()){
						count1[s1[i]-'a']++;
						i++;
					}
					
					//what are the characters present in s2 mapping them (0-a, 1-b, 2-c) in count2 array & increment their count.
					//& checking that i should not greater that s2 string length
					i=0;
					while(i<s1.length() && i < s2.length()){
						count2[s2[i]-'a']++;
						i++;
					}

					//if both count1 & count2 have same value in them then, you can say that its permutation of string
					if(areEqual(count1,count2))
						return 1;
					
					//else moving for next s1.length() characters
					while(i<s2.length()){
						count2[s2[i]-'a']++;
						count2[s2[i-s1.length()]-'a']--;
						if(areEqual(count1,count2))
							return 1;
						i++;
					}
					return 0;
				}
			};

		// Remove All Adjacent Duplicates In String
			You are given a string s consisting of lowercase English letters. 
			A duplicate removal consists of choosing two adjacent and equal letters and removing them.
			We repeatedly make duplicate removals on s until we no longer can.

			Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
			Example 1:
				Input: s = "abbaca"
				Output: "ca"
				Explanation: 
				For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, 
				and this is the only possible move.  The result of this move is that the string is "aaca", 
				of which only "aa" is possible, so the final string is "ca".
			Example 2:
				Input: s = "azxxzy"
				Output: "ay"
			Constraints:
				1 <= s.length <= 105
				s consists of lowercase English letters.
			
			//not optimized:
				class Solution {
					public:
					string removeDuplicates(string s) {
						int i=1;
						while(i < s.length()){
							if(s[i] == s[i-1]){
								s.erase(i-1,2);
								i=1;
							}else{
								i++;
							}
						}
						return s;
					}
				};

			//optimized:
				class Solution {
					public:
					string removeDuplicates(string s) {
						int i=0;
						string temp;
						while(i<s.length()){
							if( temp.empty() || temp.back() != s[i]){
								temp.push_back(s[i]);
							}else{
								temp.pop_back();
							}
							i++;
						}
						return temp;
					}
				};

		// String Compression
			Given an array of characters chars, compress it using the following algorithm:
				Begin with an empty string s. For each group of consecutive repeating characters in chars:
				If the group's length is 1, append the character to s.
				Otherwise, append the character followed by the group's length.
				The compressed string s should not be returned separately, but instead, 
				be stored in the input character array chars. Note that group lengths that 
				are 10 or longer will be split into multiple characters in chars.

				After you are done modifying the input array, return the new length of the array.
				You must write an algorithm that uses only constant extra space.

				Example 1:
					Input: chars = ["a","a","b","b","c","c","c"]
					Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
					Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
				Example 2:
					Input: chars = ["a"]
					Output: Return 1, and the first character of the input array should be: ["a"]
					Explanation: The only group is "a", which remains uncompressed since it's a single character.
				Example 3:
					Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
					Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
					Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".

				Constraints:
					1 <= chars.length <= 2000
					chars[i] is a lowercase English letter, 
					uppercase English letter, digit, or symbol.

			//NOT optimized.
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string s="";
						for(int i=0;i<chars.size();i++){
							if(isalpha(chars[i])){
								char ch = chars[i];
								s += ch;
								int cnt=1;
								for(int j=i+1;j<chars.size();j++){
									if(ch == chars[j]){
									chars[j] ='0';
									cnt++;
									}
								}
								if(cnt !=1)
									s += to_string(cnt);
							}else{
								continue;
							}
						}
						for(int i=0;i<s.length();i++)
							chars[i] = s[i];
						return s.length();
					}
				};

			//Optimized.. without using extra space 
				class Solution {
					public:
					int compress(vector<char>& chars) {
						int i=0,ansIndex=0;
						while(i<chars.size()){
							int j=i+1;
							while(j<chars.size() && chars[i] == chars[j])
								j++;
						
							chars[ansIndex++] = chars[i];
							int count = j-i;

							if(count > 1){
								string cnt = to_string(count);
								for(char ch: cnt)
									chars[ansIndex++] = ch;
							}
							i=j;
						}
						return ansIndex;
					}
				};
			
			//Optimized..  using extra space temp string,
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string s;
						for(int i=0;i<chars.size();){
							s += chars[i];
							int j=i+1;
							while(j<chars.size() && chars[i] == chars[j]){
								j++;
							}

							int count = j-i;
							// cout<<count<<endl;
							if(count > 1)
								s += to_string(count);
							// cout<<s<<endl;
							i=j;
						}
						
						for(int i=0;i<s.length();i++){
							chars[i] = s[i]; 
						}
						return s.length();
					}
				};

			//Own code:
				class Solution {
					public:
					int compress(vector<char>& chars) {
						int cnt=1;
						string s;
						chars.push_back('-');
						for(int i=0; i<chars.size()-1; i++){
							if(chars[i] == chars[i+1])
								cnt++;
							else{
								s += chars[i];
								if(cnt >1){ 
									string cntr= to_string(cnt);
									for(char k: cntr)
									s += k;
								}
								cnt=1;
							}
						}

						for(int i=0;i<s.length();i++){
							chars[i] = s[i];
						}
						return s.length();
					}
				};

			//or
				class Solution {
					public:
					int compress(vector<char>& chars) {

						// if(chars.size()==1)
						//     return 1;
						int i=0;
						int cnt=1,ansIndex=0;
						chars.push_back('^');       //dummy char to handle insertion in chars to execute else part once for last char.
						while(i < chars.size()-1){
							if(chars[i] == chars[i+1])
								cnt++;
							else{
								chars[ansIndex++] = chars[i];
								if(cnt>1)
									for(char ch: to_string(cnt))
									chars[ansIndex++] = ch;
								cnt=1;
							}
							i++;
						}
						return ansIndex;
					}
				};
						
			//or
				class Solution {
					public:
					int compress(vector<char>& chars) {
						string ans;
						if(chars.size()==1)
							return 1;
						int cnt=1;
						chars.push_back('-');
						for(int i=0;i<chars.size()-1;i++){
							if(chars[i]==chars[i+1])
								cnt++;
							else{
								if(cnt==1)
									ans+=chars[i];
								else
									ans+=chars[i]+to_string(cnt),cnt=1;
							}
						}
						chars.clear();
						for(auto it:ans)                    //for(char it:ans)
						chars.push_back(it);
						return chars.size();      
					}
				};
---------------------------------------------------------------------------------------------------------
	22/09/23
Lecture-23: Introduction to 2D Arrays in C++ LeetCode Questions
		//2D Array Implementation:
			#include <iostream>
			using namespace std;

			//if you are passing the 2D Array to function need to mention column size, else will get the error
			void printArr(int[][4]);
			bool isPresent(int [][4], int);
			int main(){
				//2D Array
				
				//initialization
				int arr1[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};      //3 rows * 4 columns = 12 boxes
				int arr2[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
				
				printArr(arr1);
				std::cout << std::endl;
				printArr(arr2);
				
				//input from user
				int arr3[3][4];
				for(int row=0; row<3; row++)
					for(int col=0; col<4; col++)
						cin>>arr3[row][col];
				
				std::cout << std::endl;
				printArr(arr3);
				
				int trgt1, trgt2;
				std::cout << "Enter trgt1 & trgt2 : " << std::endl;
				cin>>trgt1>>trgt2;
				
				//for trgt1
				if(isPresent(arr1,trgt1))
					cout<<"\nTarget1 :"<<trgt1<<"  is present";
				else
					cout<<"Target1 not present";
				
				(isPresent(arr1,trgt2))?  cout<<"\nTarget2 :"<<trgt2<<"  is present" :  cout<<"\nTarget2 "<<trgt2<<" not present";
				
				return 0;
			}

			//if you are passing the 2D Array to function need to mention column size.
			void printArr(int a[][4]){          
				//printing 2D Array
				for(int row=0; row<3; row++){
					for(int col=0; col<4; col++)
						cout<<a[row][col]<<"\t";
					cout<<"\n";
				}
			}

			//Linear search function
			bool isPresent(int a[][4], int n){
				for(int row=0; row<3; row++)
					for(int col=0; col<4; col++)
						if(a[row][col] == n)
							return 1;
				return 0;
			}

		//wap to find sum of row elements
			#include <iostream>
			using namespace std;
			int main(){
				int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};

				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[i][j];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					sum=0;
				}
				return 0;
			}
				//output
					ROW 1 = 9
					ROW 2 = 15
					ROW 3 = 33

		//wap to find sum of column elements
			#include <iostream>
			using namespace std;
			int main(){
				int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};

				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[j][i];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					sum=0;
				}
				return 0;
			}
				//output
					ROW 1 = 18
					ROW 2 = 19
					ROW 3 = 20

		//wap to find row who has largest sum.
			#include <iostream>
			#include<vector>
			using namespace std;
			int main(){

				int arr[3][3] = {{30,30,3},{5,5,5},{10,11,12}};
				
				vector<int> Lrow;
				
				int sum=0;
				for(int i=0;i<3;i++){
					for(int j=0;j<3;j++)
						sum += arr[i][j];
					std::cout << "ROW "<< i+1 << " = " << sum << std::endl;
					Lrow.push_back(sum);
					sum=0;
				}
				
				//finding max sum row
				int row=0;
				for(int i=1;i<Lrow.size();i++){
					if(Lrow[row] < Lrow[i])
						row=i;
				}
				std::cout << "The maximum sum is present in row "<< row+1 << ", The largest sum is :"<< Lrow[row] << std::endl;
				return 0;
			}

			//or
				int largestRowSum(int arr[][3], int row, int col) {
					int maxi = INT_MIN;
					int rowIndex = -1;

					for(int row=0; row<3; row++) {
						int sum = 0;
						for(int col=0; col<3; col++) {
							sum += arr[row][col];
						}

						if(sum > maxi ) {
							maxi = sum;
							rowIndex = row;
						}
						
					}
					cout << "the maximum sum is " << maxi << endl;
					return rowIndex;
				}

		//wap to print array element in wave format
			Sample Input 1:
				2
				3 4
				1 2 3 4
				5 6 7 8
				9 10 11 12
				4 4
				1 2 4 5
				3 6 8 10
				11 12 13 15
				16 14 9 7
				Sample Output 1:
				1 5 9 10 6 2 3 7 11 12 8 4
				1 3 11 16 14 12 6 2 4 8 13 9 7 15 10 5 
				Explanation For Sample Input 1:
				Here, the elements are printed in a form of a wave, first, the 0th column is printed from top to bottom then the 1st column from bottom to top, and so on. Basically, the even column is printed from top to bottom and the odd column in the opposite direction.
			Sample Input 2:
				2
				1 1
				3
				1 2
				6 5
				Sample Output 2:
				3
				6 5 

			//Program:
				#include <iostream>
				#include<vector>
				using namespace std;
				int main(){

					int arr[3][3] = {{3,3,3},{5,5,5},{10,11,12}};
					
					vector<int> ans;
					
					int sum=0;
					for(int i=0;i<3;i++){
						for(int j=0;j<3;j++)
							cout<<arr[i][j]<<"\t";
						cout<<"\n";
					}
					
					int r=0,c=0;
					
					while(c<3){
						while(1){
							// cout<<arr[r][c]<<"\t";
							ans.push_back(arr[r][c]);
							if(c%2==0){
								r++;
								if(r>2){
									r--; 
									break;
								}
							}else{
								r--;
								if(r<0){
									r++;
									break;
								}
							}
						}
						c++;
					}
					
					std::cout << std::endl;
					for(int i: ans)
						cout<<i<<" ";
					return 0;
				}

			//or
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					int col=0,row=0;
					vector<int> ans;
					while(col<mCols){
						while(1){
							ans.push_back(arr[row][col]);
							if(col%2==0){
								row++;
								if(row>=nRows){
									row--;
									break;
								}
							}else{
								row--;
								if(row<0){
									row++; 
									break;
								}
							}
						}
						col++;
					}
					return ans;
				}

			//or
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					vector<int> ans;
					for (int j = 0; j < mCols; j++){
						if (j % 2 == 0){
							for (int i = 0; i < nRows; i++){
								ans.push_back(arr[i][j]);
							}
						}else{
							for (int i = nRows - 1; i >= 0; i--){
								ans.push_back(arr[i][j]);
							}
						}
					}

					return ans;
				}

			//shorthand
				#include <bits/stdc++.h> 
				vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols){
					vector<int> ans;
					for (int j = 0; j < mCols; j++)
						if (j % 2 == 0)
							for (int i = 0; i < nRows; i++)
								ans.push_back(arr[i][j]);
						else
							for (int i = nRows - 1; i >= 0; i--)
								ans.push_back(arr[i][j]);
					return ans;
				}
		
		//WAP to print array element in Spiral order (Spiral Matrix):
			https://leetcode.com/problems/spiral-matrix/
			class Solution {
				public:
				vector<int> spiralOrder(vector<vector<int>>& matrix) {
					vector<int> ans;

					//retrived no.of rows & columns
					int row = matrix.size();
					int col = matrix[0].size();

					//get to know the indexes
					int startingRow = 0;
					int startingCol = 0;
					int endingRow = row-1;
					int endingCol = col-1;

					//got to know that how many elements are there.
					int total = row * col;
					int cnt=0;
					//running the loop till we cover the all elements
					while(cnt<total){
						
						//printing starting Row
						for(int index=startingCol; cnt<total && index<=endingCol; index++){
							ans.push_back(matrix[startingRow][index]);
							cnt++;
						}
						startingRow++;

						//printing ending Col
						for(int index=startingRow; cnt<total && index<=endingRow; index++){
							ans.push_back(matrix[index][endingCol]);
							cnt++;
						}
						endingCol--;

						//printing ending Row
						for(int index=endingCol; cnt<total && index>=startingCol; index--){
							ans.push_back(matrix[endingRow][index]);
							cnt++;
						}
						endingRow--;

						//printing starting col
						for(int index=endingRow; cnt<total && index>=startingRow; index--){
							ans.push_back(matrix[index][startingCol]);
							cnt++;
						}
						startingCol++;
					}
					return ans;
				}
			};

			//or
				class Solution {
					public:
					vector<int> spiralOrder(vector<vector<int>>& matrix) {
						int row = matrix.size();
						int col = matrix[0].size();

						//creating vector
						vector<int> ans;
						
						//indexes
						int startingRow = 0;
						int startingCol = 0;
						int endingRow = matrix.size();
						int endingCol = matrix[0].size();

						int totalElements = row * col;
						int cnt=0;

						while(cnt<totalElements){
							//traversing starting Row
							for(int i=startingCol; cnt<totalElements && i<endingCol; i++){
								ans.push_back(matrix[startingRow][i]);
								cnt++;
							}
							startingRow++;

							//traversing last col
							for(int i=startingRow; cnt<totalElements && i<endingRow; i++){
								ans.push_back(matrix[i][endingCol-1]);
								cnt++;
							}
							endingCol--;
							
							//traversing last Row
							for(int i=endingCol-1; cnt<totalElements && i>=startingCol; i--){
								ans.push_back(matrix[endingRow-1][i]);
								cnt++;
							}
							endingRow--;
							
							//traversing starting col
							for(int i=endingRow-1; cnt<totalElements && i>=startingRow; i--){
								ans.push_back(matrix[i][startingCol]);
								cnt++;
							}
							startingCol++;
						}
						return ans;
					}
				};
		
		//WAP Rotate Image (array, column to row)
			https://leetcode.com/problems/rotate-image/
			//taking extra space by creating 2 vectors ans & temp,
				class Solution {
					public:
					void rotate(vector<vector<int>>& matrix) {
						vector<vector<int>> ans;
						vector<int> temp;
						for(int col=0; col<matrix[0].size(); col++){
							for(int row=matrix.size()-1; row>=0; row--){
								temp.push_back(matrix[row][col]);
							}
							ans.push_back(temp);
							temp.clear();
						}
						matrix = ans;
					}
				};
			
			//In-Place (without taking extra space)
				class Solution {
					public:
					void rotate(vector<vector<int>>& matrix) {
						int row = matrix.size();
						for(int i=0; i<row;i++){
							for(int j=0; j<=i;j++){
								swap(matrix[i][j], matrix[j][i]);
							}
						}
						for(int i=0;i<row;i++){
							reverse(matrix[i].begin(), matrix[i].end());
						}
					}
				};

			//in-place
				Sample Input 1:
					2
					3
					1  2  3
					4  5  6
					7  8  9
					4
					1  2  3  4 
					5  6  7  8 
					9 10 11 12 
					13 14 15 16
					Sample Output 1:
					3  6  9 
					2  5  8 
					1  4  7
					4  8 12 16 
					3  7 11 15 
					2  6 10 14 
					1  5  9 13
					Explanation Of Input 1:
					(i) The array has been rotated by 90 degrees in an anticlockwise direction as the first row is now the first column inverted and so on for second and third rows.

					(ii) The array has been rotated by 90 degrees in an anticlockwise direction as the first row is now first column inverted and so on for second, third and fourth rows.
					Sample Input 2:
					2
					3
					7  4  1 
					8  5  2 
					9  6  3
					4
					13  9  5  1 
					14  10  6  2 
					15 11 7 3 
					16 12 8 4
					Sample Output 2:
					1  2  3
					4  5  6
					7  8  9
					1  2  3  4 
					5  6  7  8 
					9 10 11 12 
					13 14 15 16

				#include <bits/stdc++.h> 
				void inplaceRotate(vector<vector<int>> &matrix){
					int row = matrix.size();
					for(int i=0; i<row;i++){
						for(int j=0; j<=i;j++){
							swap(matrix[i][j], matrix[j][i]);
						}
					}
					for(int i=0;i<row;i++){
						reverse(matrix[i].begin(), matrix[i].end());
					};
					reverse(matrix.begin(), matrix.end());
					
					for(int i=0;i<row;i++){
						reverse(matrix[i].begin(), matrix[i].end());
					};
				}

		// Search a 2D Matrix:
			https://leetcode.com/problems/search-a-2d-matrix/description/
			class Solution {
				public:
				bool searchMatrix(vector<vector<int>>& matrix, int target) {

					int row = matrix.size();
					int col = matrix[0].size();

					int start =0;
					int end= row*col -1;
					int total = row*col;
					int mid = (start+end)/2;

					while(start<=end){
					int rowIndex = mid / col;
					int colIndex = mid % col;
					int value = matrix[rowIndex][colIndex];
					if(value == target)
						return 1;
					else if(value < target)
						start = mid + 1;
					else
						end = mid - 1;
					mid = (start + end )/2;
					}
					return false;
				}
			};
	
		// Search a 2D Matrix II:
			https://leetcode.com/problems/search-a-2d-matrix-ii/description/
			-here remember that, YOU ARE STARTING TO SEARCH THE TARGET VALUE FROM LAST COLUMN & STARTING ROW.
			class Solution {
				public:
				bool searchMatrix(vector<vector<int>>& matrix, int target) {
					// int row=0,col=0;
					// for(row;row<matrix.size();row++)
					//     for(col=0;col<matrix[0].size();col++)
					//         if(target == matrix[row][col])
					//             return 1;
					// return 0;
					int row = matrix.size();
					int col = matrix[0].size();

					int rowIndex = 0;
					int colIndex = col -1;

					while(rowIndex<row && colIndex>=0){
						int value = matrix[rowIndex][colIndex];
						if(value == target)
							return 1;
						else if(value<target)
							rowIndex++;
						else
							colIndex--;
					}
					return 0;
				}
			};
	
	❌Pending task,
		10 question leet code on 2D array
		1) Spiral Matrix II :
			https://leetcode.com/problems/spiral-matrix-ii/description/
			-Generating Spiral matrix from given n
				#include <iostream>
				#include<vector>
				using namespace std;

				vector<vector<int>> generateMatrix(int n) {

					vector<vector<int>> valueHolder(n,vector<int>(n,0));
					int rows,cols;
					rows = cols = n;

					int totalElements = rows * cols;
					cout<<totalElements<<endl;
					int startRow = 0;
					int startCol = 0;
					int endCol = cols-1;
					int endRow = rows-1;
					int cnt=0;

					while(cnt<totalElements){
						//traversing start row
						for(int i=startCol; cnt<totalElements, i<=endCol; i++){
							valueHolder[startRow][i] = ++cnt;
						}
						startRow++;

						//traversing last Col
						for(int i=startRow; cnt<totalElements, i<=endRow; i++){
							valueHolder[i][endCol] = ++cnt;
						}
						endCol--;

						//traversing last row
						for(int i=endCol; cnt<totalElements, i>=startCol; i--){
							valueHolder[endRow][i] = ++cnt;
						}
						endRow--;

						//traversing start col
						for(int i=endRow; cnt<totalElements, i>=startRow; i--){
							valueHolder[i][startCol] = ++cnt;
						}
						startCol++;
					}
					return valueHolder;
				}

				int main() {
					int n=5;
					vector<vector<int>> ans = generateMatrix(n);
					for(int i=0; i<n; i++){
						for(int j=0; j<n; j++)
							cout<<ans[i][j]<<"\t";
						cout<<endl;
					}
					return 0;
				}
			Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
				class Solution {
					public:
					vector<vector<int>> generateMatrix(int n) {
						vector<vector<int>> valueHolder(n,vector<int>(n,0));
						int rows,cols;
						rows = cols = n;
					
						int totalElements = rows * cols;
						cout<<totalElements<<endl;
						int startRow = 0;
						int startCol = 0;
						int endCol = cols-1;
						int endRow = rows-1;
						int cnt=0;

						while(cnt<totalElements){
							//traversing start row
							for(int i=startCol; cnt<totalElements, i<=endCol; i++){
								valueHolder[startRow][i] = ++cnt;
							}
							startRow++;

							//traversing last Col
							for(int i=startRow; cnt<totalElements, i<=endRow; i++){
								valueHolder[i][endCol] = ++cnt;
							}
							endCol--;

							//traversing last row
							for(int i=endCol; cnt<totalElements, i>=startCol; i--){
								valueHolder[endRow][i] = ++cnt;
							}
							endRow--;

							//traversing start col
							for(int i=endRow; cnt<totalElements, i>=startRow; i--){
								valueHolder[i][startCol] = ++cnt;
							}
							startCol++;
						}
						return valueHolder;
					}
				};

		2) Set Matrix Zeroes
			https://leetcode.com/problems/set-matrix-zeroes/description/
			Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
			You must do it in place.
			Example 1:
				Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
				Output: [[1,0,1],[0,0,0],[1,0,1]]
			Example 2:
				Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
				Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
			Constraints:
				m == matrix.length
				n == matrix[0].length
				1 <= m, n <= 200
				-231 <= matrix[i][j] <= 231 - 1
			Follow up:
				A straightforward solution using O(mn) space is probably a bad idea.
				A simple improvement uses O(m + n) space, but still not the best solution.
				Could you devise a constant space solution?

			//In-Place approach:
				class Solution {
					public:
					void setZeroes(vector<vector<int>>& matrix) {
						//first create bool vector which will store the places of zero present in matrix, default set to 0.
						vector<vector<bool>> isZero(matrix.size(), vector<bool>(matrix[0].size(), 0));

						//this below code will check that if that position contain zero then in bool vector it make changes to 1
						for(int i=0; i<matrix.size(); i++){
							for(int j=0; j<matrix[0].size(); j++){
								if(matrix[i][j] == 0){
									isZero[i][j] = 1;
								}
							}
						}

						//here is isZero vector contain 1 then that complete row & column of matrix set to 0.
						for(int i=0; i<matrix.size(); i++){
							for(int j=0; j<matrix[0].size(); j++){
								if(isZero[i][j] == 1){
									for(int row =0; row<matrix.size(); row++){
									matrix[row][j] = 0;
									}
									
									for(int col =0; col<matrix[0].size(); col++){
									matrix[i][col] = 0;
									}
								}
							}
						}
					}
				};

			//creating new vector & assigning it back to old one,
				class Solution {
					public:
					void setZeroes(vector<vector<int>>& matrix) {
						vector<vector<int>> TEMP(matrix.size(), vector<int>(matrix[0].size(), 0));

						// for(int i=0; i<matrix.size(); i++)
						//     for(int j=0; j<matrix[0].size(); j++)
						//         TEMP[i][j] = matrix[i][j];
						//or instead of above 3 lines of code. you can use below one liner also.
						//copying one vector to other.
						TEMP = matrix;

						//or you can use below line also to copy.
						//TEMP.assign(matrix.begin(), matrix.end());

						for(int i=0; i<matrix.size(); i++){
							for(int j=0; j<matrix[0].size(); j++){
								if(matrix[i][j] == 0){
									for(int row=0; row<matrix.size(); row++){
										TEMP[row][j] = 0;
									}
									for(int col=0; col<matrix[0].size(); col++){
										TEMP[i][col] = 0;
									}
								}
							}
						}
						matrix = TEMP;
					}
				};

		3)
			
		4)
		5)
		6)
		7)
		8)
		9)
		10)
---------------------------------------------------------------------------------------------------------
	05/10/23
Lecture-24: Basic Maths for DSA || Sieve || Modular Arithmetics || Euclid’s Algorithm
	// Count Primes
		TC - O(n * log(log n))
		https://leetcode.com/problems/count-primes/description/
		Given an integer n, return the number of prime numbers that are strictly less than n.		
			Example 1:
				Input: n = 10
				Output: 4
				Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
			Example 2:
				Input: n = 0
				Output: 0
			Example 3:
				Input: n = 1
				Output: 0

			Constraints:
				0 <= n <= 5 * 106

		//NOT optimized:
			class Solution {
				public:
				bool checkPrime(int x)
				{
					for(int i=2;i<x;i++)
					{
						if(x%i==0) return 0;
					}
					return 1;
				}
				int countPrimes(int n) {
					if(n<=1) return 0;
					else
					{
						int count=0;
						for(int i=2;i<n;i++)
						{
							if(checkPrime(i))
							{
								count++;
							}
						}
						return count;
					}
				}
			};

		//Optimized:
			-The Sieve of Eratosthenes is an algorithm used to find all prime numbers less than a number. 
			The way it works is that, starting from 2, it creates a list of all integers from there until n. 
			Then, starting with 2 (which is the smallest prime), every multiple of 2 is marked as not a prime
			class Solution {
				public:
				int countPrimes(int n) {
					
					int cnt=0;
					vector<int> prime(n,1);
					if(n >=0 && n<=2)
						return cnt;

					prime[2] = 1;								//no need.

					
					for(int i=2; i<n; i++)
						if(prime[i] == 1){						// if(primes[i])
							for(int j=i+i; j<n; j += i)			//for(int j=i*2; j<n; j += i)
								prime[j] = 0;
							cnt++;
						}
					return cnt;
				}
			};
			
	❌Segmented sieve:
		https://www.codingninjas.com/studio/library/segmented-sieve

	//Euclid’s Algorithm:
		LCM(A,B) * HCF(A,B) = A*B;
		-computing the Greatest Common Divisor (GCD) of two positive integers
		
		#include <iostream>
		using namespace std;
		int gcd(int a, int b){
			if(a==0)
				return b;
			
			if(b==0)
				return a;
				
			while(a!=b){
				
				if(a>b){
					a-=b;
				}else{
					b-=a;
				}
			}
			return a;
		}

		int main(){	
			int a,b;
			std::cout << "Enter 2 nums: " << std::endl;
			cin>>a>>b;
			
			int ans = gcd(a,b);
			
			std::cout << "The gcd of "<<a<<" "<<b<<" is : "<< ans << std::endl;
			return 0;
		}

	//modularExponentiation:
		-refer this program again in POTD section or search once with this name modularExponentiation.
		#include <bits/stdc++.h>
		int modularExponentiation(int x, int n, int m) {
			long long power=1;
			long long base = x;
			if(n==0)
				return power;
			int i=1;
			while(n>0){
				if(n&1)
					power = (power%m * base%m) % m;

				base = (base * base)%m ;
				n/=2;
			}
			/*
				while(n>0){
					if(n&1)
						power = (1ll * power * x%m)%m;		
					n/=2;
					x = (1ll * x%m * x%m)%m;		//or
													//x = (1LL * x%m * x%m)%m; //type casting to long
				}
			*/
			return power;
		}

	//calculating exponents of any number by any number
		optimized way
		#include <iostream>
		using namespace std;

		int main(){
			
			//here calculating 2¹⁰. for this method requre 10 iteration
			int a=2;
			int ans=1;
			std::cout << "10th power " << std::endl;
			for(int i=0; i<10; i++){
				cout<<"Pass-"<<i+1<<"\n";
				ans = ans * a;
			}
			std::cout << "ANS: "<<ans << std::endl;
			
			//for this method require 4 to 5 iterations
			ans=1;
			int cnt=1;
			for(int i=10; i>0;){
				cout<<"Pass-"<<cnt++<<" ";
				if(i&1)
					ans = ans * a;
				a = a * a;
				i /=2;
			}
			cout<<"ANS:"<<ans;
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;

			int main() {
			
				int ans=1;
				int n=3, power = 10;
				int cnt=0;
				while(power > 0){
					cout<<"pass "<<++cnt<<"\n";
					if(power&1)
						ans = ans * n;
					
					a = a * a;
					power /= 2;
				}
				std::cout << ans << std::endl;
				return 0;
			}
	
	❌
	https://codeforces.com/blog/entry/72527
	https://www.codingninjas.com/studio/library/gcd-euclidean-algorithm
	pigeon hole principle 4 question
	catalan number
	inclusion-exclusion principle.
	-factorial of num 212!%mod , mod = 1e9+7;
---------------------------------------------------------------------------------------------------------
	09/10/23
Lecture-25: Pointers in C++ || Part-1
	-Symbol Table is an important data structure created and maintained by the compiler in
	 order to keep track of semantics of variables i.e. it stores information about the scope and
	 binding information about names, information about instances of various entities such as
	 variable and function names. classes. obiects. etc.
	syntax:
		dataType * pointer_name = &(var_name);

	-By default the name of array contains the address of the first element of the array.
		int myArray[5] = {1, 2, 3, 4, 5};
		int* ptr = myArray;  // This sets ptr to point to the first element of myArray
		
		//no need of & sign, if you want you can use like this,
		int* ptr = &myArray[0];

		//compilation error:
			int* ptr = &myArray;
				You will get a compilation error. 
				This is because myArray is an array, 
				and when you try to take the address of the entire array using &myArray, 
				it is not directly convertible to a pointer-to-int (int*) because it's a pointer-to-array.

	eg. pointer to double.
		double d = 90.8978;
		double * ptr = &d;

	//BAD PRACTICE:
		-never create pointer like this, just declared, un-initialized.
		int *p;			//this will point to random location & make random changes to memory.
	
	//don't know where to point, initialize with 0.
		int * p = 0;		//null pointer.
		//or
		int *p = NULL;		//null pointer, symbolic constant increases readability of code.
		-if pointing to memory location which is not exist, this will create a segmentation fault.

	#include <iostream>
	using namespace std;

	int main() {

		int num = 90;           //this num name is mapped to some memory address where 90 is stored. (symbol table)
		std::cout << num << std::endl;

		//memory address is hexadecimal value contains 0-9 & A-F.
		//memory address is retrived by using &(ampersand operator).
		std::cout << "Address of num : " << &num << std::endl;
		
		//storing that memory address, we can store the memory address in pointer.
		//defining different way of declaring pointer.  
		//1. star is in the middle
		int * ptr1 = &num;
		std::cout << ptr1 << std::endl;      //memory location
		std::cout << *ptr1 << std::endl;     //value at that memory location
		
		std::cout << std::endl;
		int a=1;
		//2. star is attched to pointer name.
		int *ptr2 = &a;
		std::cout << ptr2 << std::endl;      //memory location
		std::cout << *ptr2 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)
		
		std::cout << std::endl;
		int b=23;
		//3. star is attched to datatype of pointer
		int* ptr3 = &b;
		std::cout << ptr3 << std::endl;      //memory location
		std::cout << *ptr3 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)
		
		//4. star is attched to both, datatype & pointer:
		int*ptr4 = &b;
		std::cout << ptr3 << std::endl;      //memory location
		std::cout << *ptr3 << std::endl;     //value at that memory location, *(asterisk used to retrived the value at that memory location)

		return 0;
	}

	-Here, in above program num has some address & num is a variable name, mapped to that address.
	eg.
		int n=43;
		int* ptr1 = &n;
		cout<<*ptr1;		//* act as dereferencing operator
			-pointer to int
			-you must create pointer of same datatype as that of variable on right side (n).
		
		char ch = 'Z';
		char* ptr2 = &ch;
			-pointer to character.

		
		double d = 4.545;
		double* ptr3 = &d;
			-pointer to double.
	
	-Pointer is used to store the addresses of variable so the size of pointer for any
		dataType will be 8.

	-A string in Solidity is length prefixed with its 256-bit (32 byte) length.
	eg.
			#include <iostream>
			using namespace std;

			int main() {
				int n=43;
				int* ptr1 = &n;
				cout<<"n="<<*ptr1<<endl;		//* act as dereferencing operator
				
				std::cout << "n size : "<< sizeof(n) << std::endl;
				std::cout << "n pointer size "<< sizeof(ptr1) << std::endl;
					
				char ch = 'Z';
				char* ptr2 = &ch;
				std::cout << std::endl;
				std::cout << "ch = "<< *ptr2 << std::endl;
				std::cout << "ch size "<< sizeof(ch) << std::endl;
				std::cout << "ch pointer size "<< sizeof(ptr2) << std::endl;
				
				double d = 4.545;
				double* ptr3 = &d;
				std::cout << std::endl;
				std::cout << "d = "<< *ptr3 << std::endl;
				std::cout << "d size "<< sizeof(d) << std::endl;
				std::cout << "d pointer size "<< sizeof(ptr3) << std::endl;
				
				string s = "Vivek Mahesh Nikate";
				string * str_ptr = &s;
				std::cout << std::endl;
				std::cout << "string = "<< *str_ptr << std::endl;

				std::cout << "s size "<< sizeof(s) << std::endl;
				std::cout << "s pointer size "<< sizeof(ptr2) << std::endl;

				return 0;
			}
			//output:
				n=43
				n size : 4
				n pointer size 8

				ch = Z
				ch size 1
				ch pointer size 8

				d = 4.545
				d size 8
				d pointer size 8

				string = Vivek Mahesh Nikate
				s size 32
				s pointer size 8

	//pointer declararing, afterwords initializing
		-when you declare the pointer, then on next line initializing that pointer
		 no need to give * again,
		 eg.
			int i=99;
			int *p;
			p = &i;
		#include <iostream>
			using namespace std;
			int main() {
				
				int n=43;
					int* ptr1 = NULL;          //null pointer  
					
				// 	or
				// 	int* ptr1 = 0;
					
					cout<<ptr1<<endl;					//0
				// 	std::cout << *ptr1 << std::endl;            //segmentation fault
					
					ptr1 = &n;          //re-initialized to address of n.
				std::cout << *ptr1  << std::endl;				//43

				return 0;
			}

		#include <iostream>
			int main() {
				char ch = 'K';
				char* ptrCH = nullptr; // Use nullptr instead of 0
				//char* ptrCH = 0

				if (ptrCH == nullptr) {
					std::cout << "0" << std::endl;			//0
				} else {
					std::cout << *ptrCH << std::endl;
				}

				ptrCH = &ch;
				std::cout << *ptrCH << std::endl;				//K
				return 0;
			}

	//Pointer increment:
		#include <iostream>
		using namespace std;

		int main(){
		
			int a = 45;
			
			int *p = &a;
			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address of a: "<< p << std::endl;
			std::cout << "Address of a: "<< &a << std::endl;
			
			//integer is of 4 bytes so,
			(*p)++;             //use brackets to increment value at that location,
			std::cout <<"value : " <<*p << std::endl;
			
			p++;                                               // nextAddress = prevAddress + 4
			//increment pointing Address use above syntax. Here pointer p incremented by 4 bytes coz int is of 4 bytes.
			std::cout << "Address of ptr : "<< p << std::endl;
			
			return 0;
		}
		//output:
			A : 45
			*p : 45
			Address of a: 0x7fff5dd4ba7c
			Address of a: 0x7fff5dd4ba7c				(prev Address)
			value : 46
			Address of ptr : 0x7fff5dd4ba80			(new Address)

			prevAddress last 2 digit = 7c after incremeting by 1 ie. 4 bytes, last digit c after c ,d, e, f, 0.
			after 7, there is 8,
			so new address will be like this 7c+4 => 80 and store in the pointer variable.

	//Operations:
		#include <iostream>
		using namespace std;
		int main() {
			int num =5;
			std::cout << num << std::endl;              //5
			
			int a = num;
			std::cout << a << std::endl;                //5
			a++;
			std::cout << a << std::endl;                //6          
			std::cout << num << std::endl;              //a doesn't affect to num, coz its copy.    //5
			
			int * p1 = &num;
			std::cout << "pointer works: " << std::endl;
			std::cout << "num using pointer : "<< *p1 << std::endl;         //5
			std::cout << "normal num "<< num << std::endl;                  //5
			
			//increment p1, will affect on normal num
			std::cout << "Address before :" << p1 << std::endl;
			*p1++;                              //use brackets here else it will change the pointing address
			std::cout <<"Address After : "<< p1 << std::endl;
			
			p1 = &num;
			std::cout << num << std::endl;
			std::cout << *p1 << std::endl;
			
			(*p1)++;
			std::cout << *p1 << std::endl;
			
			num++;
			std::cout << num << std::endl;
			std::cout << *p1 << std::endl;
			
			return 0;
		}

	//Call By Value & Call by Reference:

		#include <iostream>
		using namespace std;

		void callByValue(int n){
			n++;
			std::cout << "inside function : "<< n << std::endl;
		}

		void callByReference(int &n){
			n++;
			std::cout << "Inside ref function : "<< n << std::endl;
		}

		int main() {
			int a = 88;
			
			//call by value, it makes copy of original variable
			std::cout << "Before "<<a << std::endl;
			callByValue(a);
			std::cout << "After "<<a << std::endl;
			
			//call by reference makes changes in (modify) original variable.
			int *p = &a;
			std::cout << "Before : "<< a << std::endl;
			callByReference(*p);
			std::cout << "After : "<< a << std::endl;
			
			return 0;
		}
		// output:
				Before 88
				inside function : 89
				After 88
				Before : 88
				Inside ref function : 89
				After : 89

	//Call by Reference:
		#include <iostream>
		using namespace std;

		void swapper(int &y, int &z){
			int t;
			t = y;
			y = z;
			z = t;
		}

		int main(){
			int a =20, b = 30;
			std::cout << "Before : "<<a<<" " <<b << std::endl;
			int*pa,*pb;
			pa = &a;
			pb = &b;
			
			swapper(*pa,*pb);
			std::cout << "After "<<a<<" "<<b<< std::endl;
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;
			void fun(int &f, int &s){           //we can use pointer also, else directly accessing the address of variables
				int t;
				t = f;
				f = s;
				s = t;
			}
			int main() {
				int a=90, b=101;
				std::cout << a<<"       "<<b << std::endl;
				fun(a,b);
				std::cout << a<<"       "<<b << std::endl;
				return 0;
			}

	//Copying a pointer to Another pointer:
		#include <iostream>
		using namespace std;
		int main(){
			
			int a = 45;
			int *p = &a;

			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address using &a : "<< &a << std::endl;
			std::cout << "Address using p : "<< &a << std::endl;
			
			// copying pointer
			int *q = p;
			std::cout << "*q : "<< *q << std::endl;
			std::cout << "Address of q " << q << std::endl;
			return 0;
		}
		//output:
			A : 45
			*p : 45
			Address using &a : 0x7ffe389b3f14
			Address using p : 0x7ffe389b3f14
			*q 45
			Address of q 0x7ffe389b3f14
		
	//Double Pointer: pointer to pointer
		#include <iostream>
		using namespace std;

		int main(){
			int a = 45;
			
			int *p = &a;
			std::cout << "A : "<< a << std::endl;
			std::cout << "*p : "<< *p << std::endl;
			std::cout << "Address of a: "<< p << std::endl;
			std::cout << "Address of a: "<< &a << std::endl;
			
			int **ptrTOptr = &p;
			std::cout << "pointer to pointer : " <<**ptrTOptr << std::endl;
			std::cout << "Address pointer p:"<< ptrTOptr << std::endl;
			std::cout << "Address pointer p:"<< &p << std::endl;
			return 0;
		}

	//Types of pointer:
		Here are the different types of pointers in C++:
		1) Normal pointers
			are the most common type of pointer. They are declared using the asterisk (*) operator, 
			followed by the data type of the pointer's target. For example, int *ptr is a pointer to an integer.
			
		2) Void pointers
			can point to any type of data. They are declared using the void* keyword.
			
		3) Null pointers
			are pointers that do not point to any data. 
			They are used to indicate that a pointer is not currently pointing to anything. 
			They are declared using the nullptr keyword.

		4) Dangling pointers
			are pointers that point to data that has been deallocated. 
			They can cause undefined behavior if they are dereferenced.

		5) Wild pointers
			are pointers that point to memory that is not part of a program's memory space. 
			They can cause undefined behavior if they are dereferenced.

		●It is important to use pointers correctly to avoid undefined behavior. 
		 Undefined behavior can cause your program to crash, produce unexpected output, 
		 or behave in other unpredictable ways. 
		 
		◉Here are some tips for using pointers correctly:
		-Always initialize pointers before using them.
		-Never dereference a null pointer.
		-Never dereference a dangling pointer.
		-Never dereference a wild pointer.
		-Always use the correct type of pointer for the data you are pointing to.
		By following these tips, you can avoid undefined behavior and keep your programs running smoothly.
---------------------------------------------------------------------------------------------------------
	10/10/23
Lecture-26: Pointers in C++ || Part-2
	-Intro:
		int arr[10];
		-Declaring integer array with name arr with 10 elements.
		-total size is 40 (sizeof(int)*10)
		-name of array stores the first elements memory block address.  
	NOTE:
		-gives the value.
		arr[i] = *(arr+i)				//or
		i[arr] = *(i+arr);
		//or
		arr[i] = *(arr+i) = i[arr];
	eg.
		#include <iostream>
		using namespace std;

		int main(){
			int arr[10] = {45,2,3,4,5};
			
			std::cout << "Address first element: " << arr << std::endl;
			std::cout << "Address first element: " << &arr[0] << std::endl;
			std::cout << arr[0] << std::endl;
			
			//dereference, value at that location.
			std::cout << "Value at 0th index : " << *arr << std::endl;
			std::cout << "Value at 4th index : " << *(arr+4) << std::endl;
			std::cout << "Value at 4th index + 2 : " << *(arr+4) + 2 << std::endl;
			
			std::cout << "Index inside: arr[0]" << arr[0] << std::endl;
			std::cout << "Index outside: 0[arr]" << 0[arr] << std::endl;
			std::cout << "Index outside: 2[arr] " <<  2[arr] << std::endl;

			return 0;
		}

	//Array Pointer:
		#include <iostream>
		using namespace std;

		int main() {
			int temp[10] = {12,3,4,5,6,7,324};
			
			std::cout << "Size of array : "<< sizeof(temp) << std::endl;
			std::cout << "value at first : "<< *temp << std::endl;
			std::cout << "Address of first "<< temp << std::endl;
			std::cout << "Address of first "<< &temp << std::endl;
			std::cout << "Address of first "<< &temp[0] << std::endl;
			std::cout << "Address of second "<< &temp[1] << std::endl;
			
			std::cout << "Size of pointer : "<< sizeof(&temp) << std::endl;
			
			// int *ptr = &temp;           //no need to use & (ampersand) here, directly stores the address.
			int *ptr = temp;
			
			std::cout << "size of first element: which is int "<< sizeof(*ptr) << std::endl;
			std::cout << "pointer size: "<< sizeof(ptr) << std::endl;
			std::cout << "pointer address " << &ptr << std::endl;
			std::cout << "pointer's address size: (its also a pointer only)  "<< sizeof(&ptr) << std::endl;
			
			return 0;
		}

	◉ Symbol table can't be changed.	
	
	//Char Array:

		#include <iostream>
			using namespace std;
			int main() {
				int arr[] = {1,2,3,4,5};
				char ch[] = "Hello World";

				std::cout << arr << std::endl;  //this will print the first element address
				std::cout << ch << std::endl;   //this will print all content of char array.

				char ch2[] = {'a','b','c','d','e','f','g','h'};
				std::cout << ch2 << std::endl;
				
				
				char ch3[] = {'2','4','8'};
				std::cout << ch3 << std::endl;


				// output: there is no null char at the end so it goes on printing the character in char array
				//          to avoid this keep reading below...
				//     0x7ffd483ffa50
				//     Hello World
				//     abcdefghHello World
				//     248abcdefghHello World
				return 0;
			}

		#include <iostream>
		using namespace std;
		int main() {
			int arr1[] = {1,2,3,4,5};
			char ch4[] = "Hello World\0";
			
			std::cout << arr1 << std::endl;  //this will print the first element address

			//ATTENTION HERE
			std::cout << ch4 << std::endl;   //this will print all content of char array.

			char ch5[] = {'a','b','c','d','e','f','g','h','\0'};
			std::cout << ch5 << std::endl;
			
			char ch6[] = {'2','4','8','\0'};
			std::cout << ch6 << std::endl;
			return 0;
		}
		output:
			0x7ffce665c580
			Hello World
			abcdefgh
			248

	//pointer char:
		#include <iostream>
		using namespace std;
		int main() {
			int arr[] = {1,2,3,4,5};
			char ch[] = "Hello World";
			
		
			std::cout << arr << std::endl;  //this will print the first element address
			std::cout << arr[0] << std::endl;   //first element
			
			std::cout << ch << std::endl;   //this will print all content of char array.
		
			int*intPtr = arr;
			std::cout << "Int pointer : " <<intPtr << std::endl;
			
			char *ptr = ch;             //pointer will store adress of first character.
			std::cout << &ch << std::endl;      //prints the address of array.
			std::cout << ch[0] << std::endl;        //first character
			std::cout << ptr << std::endl;          //prints all content
			std::cout << ch << std::endl;
			
			char*ptr2 = &ch[0];             //points to first character.
			std::cout << ptr2 << std::endl;     //start from 0th index
			
			char*ptr3 = &ch[2];                 //points to 3rd char, ptr3 contains everything after 3rd char.
			std::cout << ptr3 << std::endl;     //start from 2nd index
			
			char ch2[] = {'g','o','o','d'};
			std::cout << ch2 << std::endl;              //goodHello World
			
			char*ch2PTR = &ch2[2];
			std::cout << ch2PTR << std::endl;           //odHello World
			
			return 0;
		}

		//or
			#include <iostream>
			using namespace std;

			int main() {
				char c[] = "asdfqwerty";
				
				std::cout << c[0] << std::endl;         //a
				std::cout << 3[c] << std::endl;         //f
				std::cout << c << std::endl;            //asdfqwerty
				
				char* ptr = c;
				std::cout << ptr << std::endl;          //asdfqwerty
				
				std::cout << ptr[1] << std::endl;       //s
				std::cout << *(ptr+2) << std::endl;     //d
				std::cout << (ptr+2) << std::endl;      //dfqwerty
				std::cout << (c+2) << std::endl;        //this prints all content from 2nd index        //dfqwerty
				std::cout << *(c+2) << std::endl;       //this prints the value at 2nd index           //d
				
				return 0;
			}

	//char pointer:
		-When you create a pointer to single character, then use & operator to give the address,
		-if you are creating a pointer to char array or int array then no need to use & operator (ampersand).
		#include <iostream>
		using namespace std;
		int main() {
			char ch = 's';
			
			char * ptr = &ch;           //pointer prints random things
			std::cout << ptr << std::endl;          //s?���
			std::cout << ch << std::endl;           //s

			return 0;
		}

	//ATTENTION here
		do's
		char ch[] = "abcd"; 		//fine

		don't
		char *chPTR = "abcd";		//works, but risky

	//Function:
		#include <iostream>
		using namespace std;

		void update(int *p){
			(*p)++;
		}

		int main() {
			
			int n = 50;
			int*ptr = &n;
			
			std::cout << "before: " <<n<< std::endl;            //50
			//passing pointer to function
			update(ptr);
			std::cout << "After: " <<n<< std::endl;     //51
			
			update(&n);         //passing direct variable address

			std::cout << "After After : "<< n << std::endl;			//52
			
			return 0;
		}

	//Passing Array to Function:
		-when we passing array to function, actually we are passing pointer to that function or array's first element
		 address to function.
		 eg.
		 	int getSum(int arr[], int size)		//or
		 	int getSum(int *arr, int size)			

			-both are same, calling above function,
				int arr[] = {1,2,3,4,5},n=5;
				getSum(arr, n);
			
			//Sum array element

				#include <iostream>	
				using namespace std;

				// int sum(int *array, int size){          //or
				int sum (int array[], int size){
					int s=0;
					for(int i=0; i<size; i++)
						s += array[i];
					return s;
				}

				int main() {
					int arr[] = {1,2,3,4,5,6,7,8,9,10};
					int n=10;
					
					//calculate sum from 6 to 10; sendig array partially
					std::cout<< "Sum is: " << sum(arr+5,5) << std::endl;            //6+7+8+9+10 = 40
						
					//calculate sum from 1 to 5;
					std::cout << "2 to 4 sum : "<< sum(arr+1, 3) << std::endl;  //2+4+5=9
					
					std::cout << "Whole SUM: "<< sum(arr,10) << std::endl;      //55
					return 0;
				}

	//char array practice:
		#include <iostream>
		using namespace std;
		int main() {	
			char ch2[] = "abcdef";          //by default it considered the last null character so sizeof is 7
			std::cout << "ch2 "<< ch2 << " " <<sizeof(ch2) << std::endl;            //7
			
			char ch[] = {'a','b','c','d','e','f','\0'};
			std::cout << "ch "<< ch <<" " << sizeof(ch)<< std::endl;            
			//here in ch if we don't mention last \0 (null) character then sizeof will be 6 else it will be 7 only.
			
			std::cout << "ch contents are :: " << std::endl;
			for(char c : ch)
				std::cout << c << "\t";
				
			cout<<"\nch2 contents are :: "<<endl;
			for(char c: ch2)
				std::cout << c << "\t";
				
			std::cout << std::endl;
			char ch3[] = {'a','b','c','d','e','f'};
			std::cout << "ch3 ="<< sizeof(ch3) << std::endl;         //6 coz \0 not given at the end.
			
			return 0;
		}
---------------------------------------------------------------------------------------------------------
	02/11/23
Lecture-27: Double Pointers in C++
	1)int*ptr = &i;
		why syntax is like this?
		why not
		pointer ptr = &num;
	->
		coz in the first expression int*ptr = &i, we can get to know that this is integer pointer pointing to int
		value.

		in the 2nd expression "pointer ptr = &num", we just know that its just a pointer pointing to nums address,
		but we don't know the datatype of that pointer.

	2) integer pointer increment its self by 4 byte after increment operation.
	   float pointer increment its self by 4 byte after increment operation.
	   double pointer increment its self by 8 byte after increment operation.
	   but, if we used the second expression (pointer ptr = &num), if we want to perform
	   any operation like (ptr = ptr + 1;) if it is int datatype pointer will point to next by 4byte 
	   if double then will point to next data after 8byte
	   if float then will point to next data after 4byte, but in 2nd expression pointer ptr = &num; we are not getting 
	   which type of pointer is this, we don't get to know this pointer where will points next, coz we don't know
	   the datatype, to it is pointing. that's why we don't use the 2nd (pointer ptr = &num) this expression.

	//Double Pointer:-
		int i = 5;
		int* ptr = &i;			//pointer to integer
		int** ptr2 = &ptr;		//pointer to pointer
		int*** ptr3 = &ptr2;		//pointer to pointer to pointer chain of pointer
	eg.
		#include <iostream>
		using namespace std;

		int main() {
			
			int i =90;
			int* p = &i;
			int** p2 = &p;
			
			std::cout << "Address of i "<< &i << std::endl;
			std::cout << "Address of i using pointer: "<< p << std::endl;
			
			std::cout << "Value of i "<< i << std::endl;
			std::cout << "Value of i using pointer: "<< *p << std::endl;
			std::cout << "Value of i using double pointer: "<< **p2 << std::endl;
			
			std::cout << "Address of p: using & operator "<< &p << std::endl;
			std::cout << "Address of p: using pointer "<< p2 << std::endl;
			
			std::cout << "Value of p:  "<< p << std::endl;
			std::cout << "Value of p: using pointer "<< *p2 << std::endl;
			
			return 0;
		}
		//output:
			Address of i 0x7fff421cdce4
			Address of i using pointer: 0x7fff421cdce4
			Value of i 90
			Value of i using pointer: 90
			Value of i using double pointer: 90
			Address of p: using & operator 0x7fff421cdce8
			Address of p: using pointer 0x7fff421cdce8
			Value of p:  0x7fff421cdce4
			Value of p: using pointer 0x7fff421cdce4

	//DATE: 19/11/2023
		p = p + 1
			//NO ANY CHANGES.
				#include <iostream>
				using namespace std;

				void update(int **p){           //parameter you will pass in future should be double pointer, ie. pointer pointing to pointer.
					p = p + 1;            
				}

				int main() {
					int i=90;
					int * p1 = &i;
					int ** p2 = &p1;
					
					std::cout << "BEFORE:" << std::endl;
					cout<<"Value of i = "<<i <<endl;
					cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
					cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
					
					update(p2);     
					
					std::cout << "AFTER:" << std::endl;
					cout<<"Value of i = "<<i <<endl;
					cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
					cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
				}
		
		*p = *p + 1
			//p2 is pointing to p1, so here we manipulating the address of p1 so p1 will only changed
			#include <iostream>
			using namespace std;

			void update(int **p){           //parameter you will pass in future should be double pointer, ie. pointer pointing to pointer.
				*p = *p + 1;              
			}

			int main() {				
				int i=90;
				int * p1 = &i;
				int ** p2 = &p1;
				
				std::cout << "BEFORE:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
				
				update(p2);     
				
				std::cout << "AFTER:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
			}
		
		**p = **p + 1;
			//changes the value of i
			#include <iostream>
			using namespace std;

			void update(int **p){           //parameter you will pass in future should be double pointer, ie. pointer pointing to pointer.
				** p = ** p + 1;           // 
			}
			int main() {
				
				int i=90;
				int * p1 = &i;
				int ** p2 = &p1;
				
				std::cout << "BEFORE:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
				
				update(p2);     
				
				std::cout << "AFTER:" << std::endl;
				cout<<"Value of i = "<<i <<endl;
				cout<<"Value of p1 = "<< p1 << ".\tAdress of i = " << &i <<endl;
				cout<<"Value of p2 = "<< p2 << ".\tAdress of p1 = " << &p1 <<endl;
			}

	//MCQ:
		1)
			#include <iostream>
			using namespace std;

			int main() {
				
				int first = 20;
				int second = 30;
				
				int * p = &second;
				std::cout << first << "\t" << second << std::endl;
				
				*p = 99;
				
				std::cout << first << "\t" << second << std::endl;
				return 0;
			}
			//output:
				20      30
				20      99
		
		2)
			#include <iostream>
			using namespace std;

			int main() {
				int first = 8;
				int *p = &first;
				
				int *q = p;
				
				std::cout << first << std::endl;        //8
				(*q)++;
				
				std::cout << first << std::endl;        //9
				return 0;
			}

		3)
			#include <iostream>
			using namespace std;
			int main() {
				
				int first = 8;
				int *p = &first;
				
				std::cout << ++(*p) << std::endl;   	//9
				std::cout << first << std::endl;    	//9
				
				std::cout << (*p)++ << std::endl;       //9
				std::cout << first << std::endl;        //10
				return 0;
			}
		
		4)
			#include <iostream>
			using namespace std;

			int main() {
				
				int *p = 0;				//This pointer don't have any memory address, currently pointer no where, null pointer.
				int first = 110;
				
				*p = first;             //segmentation fault. for null pointer after declaring initialize like this (p = &first)
									//but here we are giving value of 110 to a particular memory address where the pointer is
									//pointing, but pointer is pointing no where, so this cause error.
									//we need to give a memory address to a pointer to point & then you can change its value.
				std::cout << *p << std::endl;
				
				return 0;
			}

			//or
				#include <iostream>
				using namespace std;

				int main() {
					int first = 4;
					int second = 101;
					
					int *p = &second;
					
					std::cout << *p  << std::endl;
					std::cout << second << std::endl;
					std::cout << p << "\t"<< &second << std::endl;
					
					
					*p = first;         //if it is not null pointer then only you can use this line.
					std::cout << second << std::endl;
					
					p = &first;
					
					std::cout << "Second sec" << std::endl;
					first = 10;
					std::cout << second << std::endl;
					std::cout << first << std::endl;
					std::cout << *p << std::endl;
					std::cout << p << "\t" << &first << std::endl;
					
					return 0;
				}

		5)
			#include <iostream>
			using namespace std;

			int main() {
				int first = 10;
				int second = 20;
				int *third = &second;
				
				first = *third;
				*third = *third + 2;
				
				std::cout << first << "\t" << second <<  std::endl;             //20        22
				
				return 0;
			}

		6)
			#include <iostream>
			using namespace std;

			int main() {
				float f = 12.5;
				float p = 21.5;
				float *ptr = &f;
				
				(*ptr)++;

				*ptr = p;
				
				std::cout << f << "\t" << p  << "\t" << *ptr << std::endl;      //21.5    21.5    21.5
				
				return 0;
			}

		7)
			#include <iostream>
			using namespace std;

			int main() {
				int *ptr;
				int arr[5];			//sizeof int is 4, so 4*5=20.
				
				std::cout << sizeof(arr) << "\t" << sizeof(ptr) << std::endl;       //20        8
				return 0;
			}

		8)
			#include <iostream>
			using namespace std;

			int main() {
				int arr[] = {11,222,333,444};
				
				std::cout << *arr <<"\t"<< *arr+1 << "\t" << arr[0] << std::endl;           //11    12      11
				std::cout << *(arr+2) << std::endl;         //333
				
				return 0;
			}
		
		9)
			#include <iostream>
			using namespace std;

			int main() {
			
				int arr[6] = {11,222,333};
				
				std::cout << arr << "\t" << &arr << "\t" << &arr[0] << std::endl;       //0x7ffed7c23010  0x7ffed7c23010  0x7ffed7c23010
				
				//arr is equal to &arr is equal to &arr[0]
				//all will print same 
				//arr = &arr = &arr[0]
				
				return 0;
			}

		10)
			#include <iostream>
			using namespace std;

			int main() {
				
				int arr[6] = {11,222,333};
				
				std::cout << (arr+1) << std::endl;      //prints the address of 222 element
				
				return 0;
			}

		11)
			#include <iostream>
			using namespace std;

			int main() {
				int arr[6] = {11,222,333};
				
				int *ptr = arr;
				std::cout << ptr[2] << std::endl;      //p[2] = *(p+2)      //333
				
				return 0;
			}

		12)
			#include <iostream>
			using namespace std;
			int main() {
				int arr[6] = {11,222,333,14,15};
				std::cout << *arr << "\t" << *(arr+3) << std::endl;      // 11          14	
				return 0;
			}
		
		13)
			#include <iostream>
			using namespace std;

			int main() {
				int arr[] = {11,222,333,14,15};
			
				int *ptr = arr++;           	//you can increment pointer but not the arr, base address of array you can not change.
										//ERROR.
				std::cout << *ptr << std::endl;
				return 0;
			}

		14)
			#include <iostream>
			using namespace std;
			int main() {
				char ch = 'a';
				char *ptr = & ch;           //you can keep space between '&' and variable name.
				ch++;
				std::cout << *ptr << std::endl;	//b
				return 0;
			}

		15)
			#include <iostream>
			using namespace std;

			int main() {
				char arr[] = "abcdef";
				char *ptr = &arr[0];        //char array & int array difference is there when pointer is used.
				
				std::cout << ptr << std::endl;          //abcdef
				
				ptr = &arr[2];
				std::cout << ptr << std::endl;      //cdef
				
				return 0;
			}
		
		16)
			#include <iostream>
			using namespace std;
		
			int main() {
				char arr[] = "abcdef";
				char *ptr = &arr[0];        //char array & int array behave differently with pointer.
				
				std::cout << ptr << std::endl;          //abcdef
				std::cout << *ptr << std::endl;         //a
				std::cout << *(++ptr) << std::endl;     //b
				
				ptr++;
				std::cout << ptr << std::endl;      //cdef
				
				std::cout << *ptr << std::endl;     //c					for printing one char
		
				return 0;
			}

		17)
			#include <iostream>
			using namespace std;
			int main() {
				char str[] = "abcdef";
				char * ptr = str;
				
				std::cout << str[0] <<"\t"<< ptr[0] << std::endl;           //a     a
				return 0;
			}

		18)
			#include <iostream>
			using namespace std;

			void update(int *n){			//pointer n.
				(*n) = (*n) * 20;
				std::cout << "n inside function: "<< *n << std::endl;			//200
			}
			int main() {
				int i=10;
				std::cout <<"Before: "<< i << std::endl;				//10

				update(&i);				//passing address, it must be received by pointer only.
				
				std::cout <<"After: "<< i << std::endl;					//200
				return 0;
			}
		
		19)
			#include <iostream>
			using namespace std;

			void func(int a[]){
				std::cout << a[0] << std::endl;
				std::cout << a[1] << std::endl;
			}

			int main() {
				int arr[] = {11,222,333,444,555};
				
				std::cout << arr[0] << std::endl;
				
				//passing array from 1st index
				func(arr+1);
				
				std::cout << arr[0] << std::endl;
				
				return 0;
			}

			//or updating value:
				#include <iostream>
				using namespace std;

				void func(int a[]){
					std::cout << a[0] << std::endl;
					std::cout << a[1] << std::endl;
					
					a[0] = 1001;
					a[1] = 1001;
				}

				int main() {
					int arr[] = {11,222,333,444,555};
					
					//passing array from 1st index
					std::cout << arr[0] << std::endl;
					
					func(arr+1);
					
					
					for(int i: arr)
						std::cout << i << "\t";
					return 0;
				}
		
		20)
			#include <iostream>
			using namespace std;

			void sqr(int *p){
				int b = 90;
				
				p = &b;         //here we changed the pointer pointing. now pointer is pointing to another variable
				
				*p = (*p) * (*p);
				std::cout << "pointer inside function : "<< *p << std::endl;            //8100
			}

			int main() {	
				int a = 70;
				sqr(&a);                                //passing address 
				std::cout << a << std::endl;            //70
				
				return 0;
			}

		21)
			#include <iostream>
			using namespace std;

			int main() {
				
				int first = 110;
				int * ptr = &first;
				int ** qtr = &ptr;
				
				int second = (**qtr)++ + 9;
				
				std::cout << first << "\t" << second << std::endl;          //111       119
				return 0;
			}

		22)
			#include <iostream>
			using namespace std;

			int main() {
			
				int first = 100;
				int * ptr = &first;
				int ** qtr = &ptr;
				
				int second = ++(**qtr);
				
				int * rtr = *qtr;
				
				++(*rtr);
				
				std::cout << first << "\t" << second << std::endl;          //102       101
				return 0;
			}
			
		23)
			#include <iostream>
			using namespace std;

			int main() {
				
				int first = 100;
				int * ptr = &first;
				int ** qtr = &ptr;
				
				int second = ++(**qtr);
				
				int * rtr = *qtr;
				
				++(*rtr);
				
				std::cout << first << "\t" << second << std::endl;          //102       101
				return 0;
			}

		24)
			#include <iostream>
			using namespace std;

			void increment(int **doubler){
				++(**doubler);
			}

			int main() {
				int num = 110;
				int * ptr = &num;
				
				increment(&ptr);
				
				std::cout << num << std::endl;      //111
				return 0;
			}

		25)
		25)
		25)
		25)❌Pending
---------------------------------------------------------------------------------------------------------
	07/12/2023
Lecture-28: Reference Variable | Static vs Dynamic Memory | Part-1
	-Reference Variable:
		-Reference variable has same memory location but different names;
		-single variable/ memory location has multiple names means reference variable.
		eg.
			int i=5;
			int& j = i;		//& you can attach it to int (dataType).
			int & k = i;		//& you can keep space in between also.
			int &l = i;		//& you can attach it to variable also. NO error

			-j, k, l are the example of reference variable.
		eg.
			
			#include <iostream>
			using namespace std;

			int main() {
				int i=90;
				
				int& j =i;          //reference variable
				int & k = i;
				int &l = i;
				
				std::cout << i << std::endl;            //90
				
				//reference variable also has same value as i.
				std::cout << "Ref var j "<< j << std::endl;         //90
				std::cout << "Ref var k "<< k << std::endl;         //90
				std::cout << "Ref var l "<< l << std::endl;         //90
				
				//if we change any of the value from i, j, k or l it will affect to other also
				
				k = 99;
				std::cout << i << std::endl;            //99
				
				//After updation.
				std::cout << "Ref var j "<< j << std::endl;         //99
				std::cout << "Ref var k "<< k << std::endl;         //99
				std::cout << "Ref var l "<< l << std::endl;         //99
				
				i++;
				
				std::cout << i << std::endl;            //100
				
				//After i increment. affected to all variable
				std::cout << "Ref var j "<< j << std::endl;         //100
				std::cout << "Ref var k "<< k << std::endl;         //100
				std::cout << "Ref var l "<< l << std::endl;         //100
				return 0;
			}

		-Why?
			-When we pass a variable to function it takes it & create its copy.
			 but when we use reference variable, it don't create copy of variable, 
			 it makes changes to same variable.
			
			eg.
				#include <iostream>
				using namespace std;

				void passValue(int u){
					u++;
				}

				void passRef(int &z){			//z is reference variable, which is another name for i from main function.
					z++;
				}

				int main() {
					int i=90;
					
					//passing Value
					std::cout << "Before " << i << std::endl;   //90
					passValue(i);   
					std::cout << "After " << i << std::endl;    //90
					
					std::cout << std::endl;
					//passing Reference
					std::cout << "Before " << i << std::endl;       //90
					passRef(i);
					std::cout << "After " << i << std::endl;        //91
					return 0;         
				}
	
		//BAD PRACTICE:
			int& RefFunction(){

			}

			//or
			int* RefFunction(){

			}
				
			//returntype is Reference of variable/ memory address of variable.
			//program runs but warning will be there, coz its returning the memory address
			//of 'a' which is local variable of RefFunction, & as soon as function ends the variable gets deleted
			//so that's why.

			int& RefFunction(){                 
				std::cout << "Reference function" << std::endl;
				int a =90;
				return a;           // will not get passed by to main function.
			}

			eg.
				//BAD Practice int*:
					you can write it return type like below, it won't give error
					
					int *functionName(){		
						//* attached to functionName
					}
					
					//or
					int* functionName(){
						//* attached to returnType
					}

					//or
					int*functionName(){
						//* attached to both
					}

					//or
					int * functionName(){
						//* not attached to anything.
					}

					#include <iostream>
						using namespace std;

						int* pointerReturningFunction(){
						//int*pointerReturningFunction(){
						//int *pointerReturningFunction(){

							int a =12;
							int * p = &a;
							
							std::cout << a << std::endl;		//12
							std::cout << p << std::endl;		//memory address
							
							return p;
						}

						int main() {
							int *ptr = pointerReturningFunction();

							//Ask any one thing here either value of its address if you ask both,
							//it prints the correct address but wrong value.

							//if you want to ask both address & value then you need to 
							//allocate the memory to HEAP.
							//for previous case we are allocating memory to stack that's why giving wrong value.		
							// Refere below program also. IMPORTANT.

							//std::cout << ptr << std::endl;
							std::cout << *ptr << std::endl;			//12
							
							return 0;               
						}

					//below program works perfectly fine.
					#include <iostream>
						using namespace std;

						int*pointerReturningFunction(){
							int * p = new int(20);				//Memory allocated on HEAP.
							
							std::cout << p << std::endl;			//0x56105a3ffeb0
							std::cout << *p << std::endl;			//20
							
							return p;
						}

						int main() {
							int *ptr = pointerReturningFunction();

							std::cout << ptr << std::endl;			//0x56105a3ffeb0
							std::cout << *ptr << std::endl;			//20
							
							return 0;               
						}

				//BAD Practice int&:
					-you can write it return type like below, it won't give error
						
						int &functionName(){		
							//& attached to functionName
						}
						
						//or
						int& functionName(){
							//& attached to returnType
						}

						//or
						int&functionName(){
							//& attached to both
						}

						//or
						int & functionName(){
							//& not attached to anything.
						}
					//works fine.
						#include <iostream>
						using namespace std;

						int & RefFunction(){
							int i=88;
							int& j = i;
							std::cout << std::endl;
							std::cout << "inside function: " << std::endl;
							std::cout << i << std::endl;        //88
							std::cout << &j << std::endl;       //0x7ffed7a7eefc
							std::cout << &i << std::endl;       //0x7ffed7a7eefc
							std::cout << std::endl;
							return j;
						}

						int main() {
							int a = RefFunction();              //normal variable that's why different memory address is printed
							std::cout << a << std::endl;        //88
							std::cout << &a << std::endl;       //0x7ffcdfee1704
							
							int &z = RefFunction();             //reference variable, printed same memory address as printed in function 
														 //(but sometimes won't be printed same address, if compiler is optimized then only prints the same address)
														 //better should not use this returning reference function.
							std::cout << z << std::endl;        //88
							std::cout << &z << std::endl;       //0x7ffed7a7eefc
							
							return 0;               
						}

	-Array:
		-BAD practice:
			int n;
			cin>>n;
			int arr[n];		//n is not known at compile time.
							//bad never do this, the size should be constant/number should be known at compile time.
							//if the program knows that the array size is large, then before coming for execution
							//it brings extra memory. eg. int arr[10000];
							//if don't know the size & size is larger then it will exceed memory limit, program gets crashed.
			-here in above case we are taking n from user & creating array on stack.
			-stack have limited/less memory than heap & this stack memory program brings
			 before the starting the execution.
			-suppose stack have 20 bytes of memory size, but you given n=25
			 so it is not able store the 25 values, so program crashes/ terminates abnormally.
			-Solution for this, to use Heap memory (Dynamic memory).
						                       +----------------+
				+-----------+				   |                |
				|           |                    |                |
				|           |                    |                |
				|           |                    |                |
				+-----------+ 				   |                |
                  	  Stack size				   +----------------+
				                     	    		    Heap size
			
		-Static memory allocation:
			-memory alloted from stack
			eg.
				int arr[100];
				char ch[1000];			//depends on stack memory
				int a=45;
				string s = "qwerty";
			
		-Dynamic memory allocation: (HEAP memory)
			-need to use 'new' keyword.
			-memory alloted from heap
			-programmer is responsible for freeing the memory.
			-eg.
				//to create a int variable on heap, use this syntax:
					new int;
					-but above created variable don't have any name,
					 it returns the address so we have to store that address, so
					-Actual syntax
						int *p = new int;			//pointer storing address of that variable which is on Heap.
												//pointer is on stack
					
					eg.
						#include <iostream>
						using namespace std;

						int main() {
							int * p = new int;          //memory alloted on heap
							
							std::cout << p << std::endl;        //0x557055e95eb0
							std::cout << *p << std::endl;       //0
							
							*p = 90;
							
							std::cout << p << std::endl;        //0x557055e95eb0
							std::cout << *p << std::endl;       //90  
							delete p;                   //memory freed from heap
							
							
							return 0;
						}

					//to create a int array on heap, use this syntax:
						new int[10];
						eg.
							#include <iostream>
							using namespace std;

							int main() {
								int n;
								cin>>n;                 //creating dynamic array
								
								int * p = new int[n];          //memory alloted on heap
								
								p[1] = 45;
								p[2] = 60;
								p[3] = 23;
								p[4] = 1;
								
								for(int i=0; i<n; i++)
									// std::cout <<*(p+i) << "\t";         //or
									std::cout << p[i] << "\t";
									
								delete[] p;          //syntax works          //memory freed from heap
								// delete [] p;      //syntax works
								// delete []p;       //syntax works   
								// delete[]p;        //syntax works
								return 0;
							}

							//or
								#include <iostream>
								using namespace std;

								int main() {
									int n;
									cin>>n;
									
									int * arr = new int[n];
									
									for(int i=0; i<n; i++)
										cin>>arr[i];
									
									std::cout << "Array elements are : " << std::endl;
									
									for(int i=0;i<n; i++)
										// std::cout << *(arr+i) << "\t";
										std::cout << i[arr] << "\t";
									return 0;
								}

					//to create a string on heap, use this syntax:
						new string;
					
					//to create a string array on heap, use this syntax:
						new string[10];
					
					//to create a char array on heap, use this syntax:
						new char[10];

			-Total memory used by below line
				1)char * ptr = new char;
					where,
						pointer ptr has 8 bytes of size
						char has 1 byte of size
						so total is 8+1= 9 bytes memory used.
					
				2)int *p1 = new int[10];
					where,
					-pointer p1 has 8 bytes of size
					-int has 4 bytes of size & its of 10 elements
					so total is 4*10 = 40 bytes
					-40 + 8 = 48 bytes of total memory used.
			
	-Dynamic allocated memory uses 8 bytes extra, which is a pointer on stack.
	-in stack (static memory allocation) memory gets released automatically
	-in Dynamic memory allocation, mannually have to release the memory.

	void pointer
		-A void pointer is a general-purpose pointer. 
		 that can hold the address of any data type, but it is not associated with any data type.
		-A void pointer can hold an address of any type and can be typecasted to any type.
		
		-A void pointer in C++ is a special pointer that can point to objects of any data type. 
		 In other words, a void pointer is a general purpose pointer that can store the address 
		 of any data type and it can be typecasted to any type. 
		-A void pointer is not associated with any particular data type.

		-The size of a void pointer is different in different systems. 
		-In 16-bit systems, the size of a void pointer is 2 bytes. 
		-In a 32-bit system, the size of a void pointer is 4 bytes. 
		-in a 64-bit system, the size of a void pointer is 8 bytes.

		syntax:
			void *ptr;
			void* pointer_name;
			void * pointer_name;
			void*pointer_name;

		
		In C++, we cannot assign the memory address of a variable to the variable of a different data type. 
		Consider the following example:
			int *ptr;  // integer pointer declaration  
			float a=10.2; // floating variable initialization  
			ptr= &a;  // This statement throws an error.
		
		In the above example, we declare a pointer of type integer, i.e., ptr and a float variable, i.e., 'a'. 
		After declaration, we try to store the address of 'a' variable in 'ptr', 
		but this is not possible in C++ as the variable cannot hold the address of different data types.

		#include <iostream.h>  
		using namespace std;  
		int main() {  
			int *ptr;  
			float f=10.3;  
			ptr = &f; // error  
			std::cout << "The value of *ptr is : " <<*ptr<< std::endl;  
			return 0;  
		}
		In the above program, we declare a pointer of integer type and variable of float type. 
		An integer pointer variable cannot point to the float variable, but it can point to an only integer variable.

		-C++ has overcome the above problem by using the C++ void pointer as 
		a void pointer can hold the address of any data type.

		#include <iostream>  
		using namespace std;  
		int main() {  
			void *ptr;   // void pointer declaration  
			int a=9;   // integer variable initialization  
			ptr=&a;   // storing the address of 'a' variable in a void pointer variable.  
			std::cout << &a << std::endl;  
			std::cout << ptr << std::endl;  
			return 0;  
		}
		In the above program, we declare a void pointer variable 
		and an integer variable where the void pointer contains the address of an integer variable.

		Difference between void pointer in C and C++ :-
			In C, we can assign the void pointer to any other pointer type without any typecasting, 
			whereas in C++, we need to typecast when we assign the void pointer type to any other pointer type.
			eg.
				in C:
					#include <stdio.h>  
					int main() {  
						void *ptr; // void pointer declaration  
						int *ptr1;  // integer pointer declaration  
						int a =90;  // integer variable initialization  
						ptr=&a; // storing the address of 'a' in ptr  
						ptr1=ptr; // assigning void pointer to integer pointer type.  		//without typecasting
						printf("The value of *ptr1 : %d",*ptr1);  
						return 0;  
					}
				
				in C++ :
					#include <iostream>  
					using namespace std;  
					int main() {  
						void *ptr; // void pointer declaration  
						int *ptr1; // integer pointer declaration  
						int data=10; // integer variable initialization  
						ptr=&data;  // storing the address of data variable in void pointer variable  
						ptr1=(int *)ptr; // assigning void pointer to integer pointer  
						std::cout << "The value of *ptr1 is : " <<*ptr1<< std::endl;  
						return 0;  
					}
					In the above program, we declare two pointer variables of type void and int type respectively. 
					We also create another integer type variable, i.e., 'data'. 
					After declaration, we store the address of variable 'data' in a void pointer variable, i.e., ptr. 
					Now, we want to assign the void pointer to integer pointer, 
					in order to do this, we need to apply the cast operator, i.e., (int *) to the void pointer variable. 
					This cast operator tells the compiler which type of value void pointer is holding. 
					For casting, we have to type the data type and * in a bracket like (char *) or (int *).

		-void pointer can not be dereferenced.
			#include <iostream>
			using namespace std;

			int main() {
				// C++ Program to demonstrate that a void pointer
				// cannot be dereferenced
				
				//void pointer
				int a=80;
				void * ptr = &a;
				
				std::cout << ptr << std::endl;      //we can print the address, 
												//but can't print value of void pointer pointing value
											
				// std::cout << *ptr << std::endl;         //error
				
				//to print the value ptr is pointing
				// The void pointer 'ptr' is cast to an integer pointer
				// using '(int*)ptr' Then, the value is dereferenced
				// with `*(int*)ptr` to get the value at that memory location
				std::cout << *(int *) ptr << std::endl;
				
				//or
				int * pointer = (int *) ptr;            //need to tell the compiler that it is a int pointer.
				std::cout << *pointer << std::endl;
				return 0;
			}	

	address TypeCasting:
		In C++, address typecasting is the process of converting a pointer of one type to a pointer of another type.
---------------------------------------------------------------------------------------------------------
	12/12/2023
Lecture29: Dynamic Memory Allocation of 2D Arrays
	-When you use the HEAP memory, always free it once your work is done.	
	//2D Array Using Dynamic memory (HEAP).
		#include <iostream>
		using namespace std;
		int main() {
			//2D array using dynamic memory (heap)
			int rows,cols;
			std::cout << "Enter no.of Rows: ";
			cin>>rows;
			
			std::cout << "Enter no.of Cols: ";
			cin>>cols;
			
			int ** arr = new int*[rows];        
			
			for(int i=0; i<rows; i++)
				arr[i] = new int[cols];
			
			for(int i=0; i<rows; i++)
				for(int j=0; j<cols; j++)
					cin>>arr[i][j];
					
			for(int i=0; i<rows; i++){
				for(int j=0; j<cols; j++)
					cout<<arr[i][j]<<"\t";
				std::cout << std::endl;
			}
			
			for(int i=0; i<rows; i++)
				delete [] arr[i];               //to delete each array individually
				
			delete [] arr;                  //delete main double pointer holdoing other pointers
			
			return 0;
		}

	//2D jagged array (Array having different no.of columns in rows) Using Dynamic Memory (HEAP):
		#include <iostream>
		using namespace std;

		int main() {
			//2D Jagged array, dynamic way
			int rows, cols;
			std::cout << "Enter Rows:" << std::endl;
			cin>> rows;
			
			int ** arr = new int *[rows];
			
			int ttl_elements =0;
			
			int * indiRowSize = new int[rows];
			
			for(int i=0; i<rows; i++){
				std::cout << "Enter cols in : " << i <<"th row: "<< std::endl;
				cin>>cols;
				
				ttl_elements += cols;
				
				arr[i] = new int [cols];
				indiRowSize[i] = cols;
			}
			
			std::cout << "Enter "<< ttl_elements << " array elements." << std::endl;
			for(int i=0; i<rows; i++){
				std::cout << "In "<< i <<"th row, Enter "<< indiRowSize[i] <<" elements." << std::endl;
				for(int j=0; j<indiRowSize[i]; j++)
					cin>>arr[i][j];
			}
			
			std::cout << "The array elements are : " << std::endl;
			for(int i=0; i<rows; i++){
				for(int j=0; j<indiRowSize[i]; j++)
					std::cout << arr[i][j]<<"\t";
				std::cout << std::endl;
			}
			
			for(int i=0; i<rows; i++){
				//deleting individual array
				delete [] arr[i];
			}
			
			//deleting main array
			delete [] arr;
			delete [] indiRowSize;
					
			return 0;
		}
		//output:
			Enter Rows:
				4
				Enter cols in : 0th row: 
					1
				Enter cols in : 1th row: 
					2
				Enter cols in : 2th row: 
					3
				Enter cols in : 3th row: 
					4
				Enter 10 array elements.
				In 0th row, Enter 1 elements.
				1
				In 1th row, Enter 2 elements.
				1
				2
				In 2th row, Enter 3 elements.
				1
				2
				3
				In 3th row, Enter 4 elements.
				1
				2
				3
				4 
				The array elements are : 
				1
				1       2
				1       2       3
				1       2       3       4
---------------------------------------------------------------------------------------------------------
	14/12/23
Lecture30: Macros, Global Variables, Inline Functions & Default Args
	-#include<iostream>
		-here #include is a preprocessor directive, tell compiler to add built-in functionality in code
		-like, cout<< function we use to print the output on screen but to access this fuction we have to add iostream.

		double PI = 3.14;
		-affect on performance, very very small(negligible).
		-used storage to for this variable.
		-sometime or by mistake somebody can change the value also.

	-Macros:
		-Macro syntax #define <name> <value>
		-no need of memory, the value gets replaced wherever you mention the name of Macro.
		-& Macro is not modifiable, means PI = PI +1; not possible.
		-Macro is piece of code in program that is replaced by value of Macro.
		eg.
			#include <iostream>
			#define PI 3.14               //Macro
			using namespace std;

			int main() {
				
				int r=5;
				//double PI = 3.14;				//if we define PI as double then we are taking 8 bytes of memory space & its modifiable. like pi =pi+1;
				double area = PI * r * r;
				std::cout << area << std::endl;
				std::cout << PI << std::endl;
				return 0;
			}

		Practice:
			#include <iostream>
			#define VIVEK 4                 //Macro Defined & value
			using namespace std;

			int main() {
				
				std::cout << VIVEK << std::endl;            //Priting value of Macro
				std::cout << VIVEK+1 << std::endl;          //math operation on Macro
				return 0;
			}

		-A macro is a piece of code in a program that is replaced by the value of the macro. 
		 Macro is defined by #define directive. 
		 Whenever a macro name is encountered by the compiler, 
		 it replaces the name with the definition of the macro. 
		-Macro definitions need not be terminated by a semi-colon(;).
		eg.
			#include <iostream>
			#define LIMIT 9
			using namespace std;

			int main() {
				cout<<"The value of LIMIT : "<< LIMIT;			//The value of LIMIT : 9
				return 0;
			}

		eg.
			#include <iostream>
			//Macro definition
			#define AREA(l,b) (l*b)                 //don't give space between AREA & (l,b)
			using namespace std;

			int main() {
				int len, bre;
				
				std::cout << "Enter len & bre :: " << std::endl;
				cin>>len>>bre;
				
				std::cout << "The Area: "<< AREA(len,bre) << std::endl;         //finding area using Macro
				return 0;
			}
			//output:
				Enter len & bre :: 
				9 9
				The Area: 81
		
		eg.you can define macro & var with same name, but good practice is to use
			different names.

			#include <iostream>
			//Macro definition
			#define area(l,b) (l*b)
			using namespace std;

			int main() {
				int len, bre;
				
				std::cout << "Enter len & bre :: " << std::endl;
				cin>>len>>bre;
				
				int area = area(len,bre);
				
				std::cout << "The Area: "<< area <<std::endl;         //finding area using Macro
				return 0;
			}

		#Types of Macros:
			1]Object-Like macro:
				An object-like macro is a simple identifier that will be replaced by a code fragment. 
				It is called object-like because it looks like an object in code that uses it. 
				It is popularly used to replace a symbolic name with numerical/variable represented as constant.
				eg.
					#include<iostream>
					#define DATE 31
					using namespace std;
					int main(){
						std::cout << "Today is :"<< DATE << "st." << std::endl;			//Today is :31st.
						return 0;
					}

			2]Chain Macros:
				-Macro inside macro is termed as chain macro.
				-In chain macros first of all parent macro is expanded then the child macro is expanded.
				eg.
					#include<iostream>
					using namespace std;
					#define Name fname
					#define fname "Vivek"

					//or this also works
					/*
						#define fname "Vivek"		
						#define Name fname
					*/

					int main(){
						std::cout << "My name is (parent Macro):" << Name << std::endl;
						std::cout << "My first name is (child Macro):: " << fname <<std::endl;
						return 0;
					}
					//output:
						My name is (parent Macro):Vivek
						My first name is (child Macro):: Vivek
					
			3]Multi-line Macros: 
				An object-like macro could have a multi-line. 
				So to create a multi-line macro you have to use backslash-newline.
				eg.
					#include<iostream>
					using namespace std;
					#define ELE 1,\
							2,\
							3,\
							4
					int main(){
						int arr[] = {ELE};
						for(int i=0; i<4; i++)
							std::cout << arr[i] << "\t";	
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;
						#define SUM(a,b)    \
							cout<<"A: "<<a<<"\t"; \
							cout<<"B: "<<b<<"\t"; \
							cout<<"Sum : "<<a+b;

						int main(){
							SUM(5,5);
							return 0;
						}
	
			4]Function-like Macro:
				These macros are the same as a function call. 
				It replaces the entire code instead of a function name. 
				Pair of parentheses immediately after the macro name is necessary. 
				If we put a space between the macro name and the parentheses in the macro definition, 
				then the macro will not work. 
				A function-like macro is only lengthened if and only if its name appears with a pair of parentheses after it.
				If we don’t do this, the function pointer will get the address of the real function and lead to a syntax error.
				eg.
					#include<iostream>
					using namespace std;
					#define MINN(a,b) ((a<b)?cout<<a : cout<<b)
					int main(){
						MINN(14,5);
						return 0;
					}

					//or
						#include<iostream>
						using namespace std;
						#define MINN(a,b) ((a<b)?a:b)           //this value you can assign to another variable

						#define LARG(a,b) ((a<b)?cout<<b:cout<<a)                   //this you cant assign to other variable

						int main(){
							int a =MINN(14,5);
							std::cout << a << std::endl;
							LARG(14,5);
							
							return 0;
						}

	-Global Variable:
		-BAD Practice/ don't use
		-all fuction can changes its value of variable.
		-same variables(memory location) any function can access.
		-you can use Reference Variable concept.

		#include <iostream>
		using namespace std;

		int main() {
			//local variable for main function
			int a=10;
			
			std::cout << "inside main function A: "<< a << std::endl;
			
			{
				//local variable for this block
				//accessible for this block only
				int a =90, b=88;
				std::cout <<"Inside block A: "<< a << std::endl;
				std::cout << "Inside block B: " << b << std::endl;
			}
			
			// std::cout << b << std::endl;    //can't access b here.
			return 0;
		}
	
		eg.
			#include <iostream>
			using namespace std;
			int score = 99;			//Global variable
			void a(){
				std::cout << "in a " << score  << std::endl;
			}

			void b(){
				std::cout << "in b "<< score << std::endl;
			}

			void c(){
				score++;
				std::cout << "in c: " << score << std::endl;
			}

			int main() {
				a();
				b();
				std::cout << "Main function: "<< score << std::endl;
				
				//this c function call affected score in all other function
				c();
				a();
				b();
				std::cout << "Main function: "<< score << std::endl;
				
				return 0;
			}

	-Inline function:
		-Increases the code readability.
		-increases performance, because when we create a normal function then function call takes little time (negligible) 
		 [kind of performance damage very little, but yes performance damages].
		-In Inline function it don't call to function it just replaces the single line code of that function to where you called.
		-don't create extra memory for (pass by value) function argument.
		-its like macro only, when function having one line code then you can use inline keyword, compiler accept this
		-if function is of 2 to 3 lines of code then sometime compiler accept the function as inline or sometime don't.
		-if fuction is more than 3 lines then compiler don't consider it as inline function, but code executes without any error.
		eg.	
			#include <iostream>
			using namespace std;

			//inline function
			inline int getMax(int a, int b){
				return (a>b)? a: b;
			}

			int main() {
				std::cout << getMax(5,4) << std::endl;              //getMax(5,4) gets replaced by [(a>b)? a: b] this.
				std::cout << getMax(100,104) << std::endl;
				
				return 0;
			}

	-Default Args:
		-A default argument is a value provided in a function declaration that is automatically assigned by the compiler 
		if the calling function doesn’t provide a value for the argument. 
		In case any value is passed, the default value is overridden. 	
		eg.
			#include <iostream>
				using namespace std;
				void sum(int a, int b, int c=0){            //c is optional argument here
					std::cout << a+b+c  << std::endl;
				}

				int main() {

					sum(10,20);         // not passing last argument which is optional
					sum(5,4,3);         //passing last argument
					
					return 0;
				}
			
			#include <iostream>
				using namespace std;

				void printer(int arr[], int size, int start=0){
				for(int i=start; i<size; i++)
					std::cout << arr[i] << "\t";
				}

				int main() {
				
					int a[] = {1,2,3,4,5,6,7,8,9,10};
					int n=10;
					
					printer(a, n);          //keeping last argument as optional
					std::cout << std::endl;
					printer(a,n,3);
					return 0;
				}

		// valid
			int sum(int x, int y, int z = 0, int w=0).

		// Invalid because z has default value, but w after it doesn't have a default value
			int sum(int x, int y, int z = 0, int w).	

	Constant Variables
		-constant variables identified by the const keyword in C++. 
		-As the name suggests, if we declare any keyword as constant, we can’t change its value throughout the program.
		Note: The constant variable needs to be assigned during initialization only,
		 else it will store garbage values that can’t be changed further.
		Syntax:
			const datatype variable_name = value;
		Example:
			const int a = 5;
---------------------------------------------------------------------------------------------------------
	//18/12/2023
Lecture 31: Learning Recursion the Best Way
	Recursion:
		when function calls itself again & again.
		-splitting big problem into smaller same problem.
		-base case is mandatory in recursion
		-when base condition occurs then it stops calling function again.
		-recursive call always lead towards base case.
		-in base case return is mandatory.
		-if we don't give return in base case then segmentation fault will occur.
		#In RECURSION -> Base case is mandatory (return statement in base case).
				    -> Recursive relation is mandatory.
				    -> Processing part
				if in function if recursive relation [return n*fun(n-1)] comes at the end or after some process is called as Tail Recursion.
				if in function if recursive relation comes before processing or at start is called as tail recursion.
	eg.
		//Factorial of num
			#include <iostream>
			using namespace std;

			int fact(int n){
				if(n==0)
					return 1;
				// std::cout << n << std::endl;
				return n* fact(n-1);                //recursive relation
			}

			int main() {
				int n;
				std::cout << "Enter num: " << std::endl;
				cin>>n;
				
				std::cout << "Factorial of "<< n << " is:";
				n = fact(n);
				std::cout << n << std::endl;
				return 0;
			}

		//Power of num:
			#include <iostream>
			using namespace std;

			long long power(int n, int ex) {
				//base case
				if(ex==0)
					return 1;
					
				return n*power(n,ex-1);
			}

			int main() {
				int num;
				cout<<"Enter num:";
				cin>>num;
				
				int expo;
				std::cout << "Enter its power: ";
				cin>>expo;

				std::cout << num << "^" << expo << ": ";
				std::cout << power(num,expo) << std::endl;
				return 0;
			}
			//output:	
				Enter num:2
				Enter its power: 32
				2^32: 4294967296

		//Counting (Reverse Order):
			#include <iostream>
			using namespace std;

			void printer(int z){
				std::cout << z << " ";
				if(z==0)
					exit(0);                //or you can use just return; instead of exit(0);
					// return;
				printer(z-1);
			}

			int main() {
				int n;
				std::cout << "Enter num: " << std::endl;
				cin>>n;
				
				printer(n);
				return 0;
			}
			//output:
				Enter num: 
					5
					5 4 3 2 1 



			//Original Order:
				#include <iostream>
				using namespace std;

				void printer(int z){
					if(z==0)
						return;
					printer(z-1);
					std::cout << z << " ";
				}

				int main() {
					int n;
					std::cout << "Enter num: " << std::endl;
					cin>>n;
					
					printer(n);
					return 0;
				}
				//output:
					Enter num: 
						5
						1 2 3 4 5 
---------------------------------------------------------------------------------------------------------
	//18/12/2023
Lecture32: Understanding Recursion the easiest way || Day-2:
	
---------------------------------------------------------------------------------------------------------
#miscellaneous
	//Ternary Operator
		#include <iostream>
		using namespace std;
		int main(){
			//both ways work
			//cout function within ternary operator
			(1==1)? cout<<"Right 1==1"<<endl : cout<<"Wrong X"<<endl;
			
			//ternary operator within cout function
			std::cout << ((2==20)? "Yes True.. 2==20" :"No Wrong 2!=20") << std::endl;
			
			return 0;
		}

	//Curly braces related..

		#include <iostream>
		using namespace std;

		int main()
		{
			if(0)
				if(0)
					std::cout << "nested if" << std::endl;
			else
				cout<<"nested else";					//if this else block is not present then outside else block got attached to inner if block
			else										//works like putting curly braces around if-else block.
				cout<<"outside if main IF got FALSE";
					
			return 0;
		}
	
	//If-else without using {}
		#include <iostream>
		using namespace std;
		int main() {
			int n = 91,cnt=80;
			if (n == 90)
				cout << "It's 90.. ayyyyye.." <<  endl,
				cout << "Another sentence" <<  endl;
			else
				cout << "Wrong, it's not 90" <<  endl, 
				cout << "It's the else part without using {} braces" <<  endl, 
				cnt = 10, 
				cout << "The count in the else block is " << cnt <<  endl;

			return 0;
		}
		
	//Label
		if() can accept any non-zero or -ve value considered as true 
		if 0 then false.
		#include <iostream>
		using namespace std;
		int main(){
		
			if(2)					//if(-2)			this is also true.
				goto L2;

			L1: 
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			std::cout << "Lable 1st" << std::endl;
			
			L2:
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			std::cout << "Lable 2nd" << std::endl;
			
			L3:
			return 0;
		}

	//Factorial:
		//fact program
		//position of increment decrement operator matters a LOTTTTTTTTT.
		#include <iostream>
		using namespace std;
		int main(){
			int n,t;
			cin>>n;
			t=n-1;
			
			while(t)
				n *= t--;
			
			std::cout <<endl<< n << std::endl;
			return 0;
		}

	//SWAP function:
		#include <iostream>
		using namespace std;

		int main(){
			int a = 10;
			int b = 20;
			cout << "Value of a before: " << a << endl;
			cout << "Value of b before: " << b << endl;

			// swap values of the variables
			swap(a, b);			//takes 2 values.

			//or
			a = a + b;	//a^b		//10+20=30
			b = a - b;	//a^b		//30-20=10
			a = a - b;	//a^b		//30-10=20

			cout << "Value of a now: " << a << endl;
			cout << "Value of b now: " << b << endl;
			return 0;
		}

	//while loop:
		#include <iostream>
		using namespace std;

		int main(){
			int i=0,j=0;
			
			while(i<5 && j<10){
				
				std::cout << i<<" "<<j << std::endl;			// and Operator is there so both condition must be true.
				i++;j++;									//output will be 0 to 4,
			}
			return 0;
		}

		//or if we used || or (,) then 0 - 9 will be printed.
		#include <iostream>
		using namespace std;

		int main(){
			int i=0,j=0;
			while(i<5 , j<10){          //while(i<5 || j<10)
				std::cout << i<<" "<<j << std::endl;
				i++;j++;
			}

			return 0;
		}

	//Remain 
		//Line 4499 Triplet sum didn't understand❌ (come back here later.).
		-Check TLE again (Time Limit Exceeded). https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/

	//Self Solved:
		1. Two Sum
			vector<int> twoSum(vector<int>& nums, int target){
				vector<int> ans;
				
				for(int i=0;i<nums.size(); i++){
					for(int j=i+1; j<nums.size(); j++){
						if(nums[i]+nums[j] == target){
							ans.push_back(i);
							ans.push_back(j);
						}
					}
				}
				return ans;
			}

		2. Coding Ninja Content:
			Container with Maximum Water:
				#include <bits/stdc++.h> 
				int maxAreaContainer(vector<int> &arr){
					int n = arr.size();
					int area, mainMax=0;

					for(int i=0; i<n-1;i++){
						for(int j=i+1; j<n; j++){
							area = min(arr[i], arr[j]) * (j-i);

							if(mainMax < area)
								mainMax = area;
						}    
					}
						return mainMax;
				}

				//optimized:
					#include <bits/stdc++.h> 
					int maxAreaContainer(vector<int> &arr){
						int n = arr.size();
						int left = 0;
						int right = n - 1;
						int mainMax = 0;

						while (left < right) {
							int width = right - left;
							int height = min(arr[left], arr[right]);
							int area = width * height;

							mainMax = max(mainMax, area);

							if (arr[left] < arr[right]) {
								left++;
							} else {
								right--;
							}
						}
						return mainMax;
					}

		3. Subarray with given sum
			vector<int> subarraySum(vector<int>arr, int n, long long s){
				
				int start = 0;
				long long sum = 0;
				vector<int> v;
			
				if (s == 0) // Handle the case where target sum is 0
				{
					v.push_back(-1);
					return v;
				}
				
				for (int i = 0; i < n; i++)
				{
					sum += arr[i];
			
					while (sum > s && start <= i)
					{
						sum -= arr[start];
						start++;
					}
			
					if (sum == s)
					{
						v.push_back(start + 1);
						v.push_back(i + 1);
						return v;
					}
				}
				v.push_back(-1); // If no subarray found
				return v;
			}

			//or
				vector<int> subarraySum(vector<int>arr, int n, long long s){
					// Your code here
					vector<int> res;
					bool bl = false;
					for (int i = 0; i < n; i++) {
						int currentSum = arr[i];
					
						if (currentSum == s) {
							res.push_back(i+1);
							res.push_back(i+1);
							bl=true;
							break;
						}
						else {
							// Try all subarrays starting with 'i'
							for (int j = i + 1; j < n; j++) {
								currentSum += arr[j];
					
								if (currentSum == s) {
									res.push_back(i+1);
									res.push_back(j+1);
									bl=true;
									break;
								}
							}
							if(bl) break;
						}
					}
					if(bl) return res;
						return {-1};
				}

		4. Smaller and Larger:
			vector<int> getMoreAndLess(int arr[], int n, int x) {
				int GreaterCount=0, LessCount=0;
				
				for(int i=0;i<n; i++){
					if(arr[i]>= x)
						GreaterCount++;
					
					if(arr[i]<=x)
						LessCount++;
				}
				
				vector<int> v;
				v.push_back(LessCount);
				v.push_back(GreaterCount);
				return v;
			}
		
		-Refere few programs from here also...
			https://auth.geeksforgeeks.org/user/viveknikate/practice

	//Char extraction & string addition:
		int main (){
			string firstName = "John ";
			char lastName =firstName[0];
			char n = 'f';
			string s;
			s+= n;
			s+= lastName;
			cout << s;
			return 0;
		}

	//CHAR_BIT:
		-This C++ program will output the value of the `CHAR_BIT` constant, 
		 which represents the number of bits in a `char` data type on the particular platform and compiler being used.
		-In most systems, a `char` data type is 8 bits (1 byte), but it's not guaranteed to be the same on all platforms. 
		 The `CHAR_BIT` constant is defined in the `<climits>` header in C++ and specifies 
		 the number of bits in the smallest addressable unit of the machine's memory.
		-So, when you run this program, it will likely output `8`, indicating that a `char` consists of 8 bits on your platform.
		eg.
			#include <iostream>
			#include <climits>
			using namespace std;
			int main(){
				cout<<CHAR_BIT<<"\n";
				cout<<CHAR_BIT * sizeof(int)<<"\n";
				return 0;
			}
			//output:
				8
				32

	//String initialization:
		#include <iostream>
		using namespace std;

		int main(){
			string s(10, 'V');
			std::cout << s << std::endl;			//VVVVVVVVVV
			return 0;
		}
	
		//or
			#include <iostream>
			using namespace std;

			int main() {
				string s1 ("asdf"), s2 ("wertwret");
				
				std::cout << s1 << std::endl;		//asdf
				std::cout << s2 << std::endl;		//wertwret
				
				return 0;
			}

	//String front() back() method:

		#include <iostream>
		using namespace std;

		int main() {
			string s= "Hello World";
			std::cout << s << std::endl; 			//Hello World
			s.front() = 'V';
			s.back() = 'N';
			std::cout << s << std::endl;			//Vello WorlN
			return 0;
		}

	//String length calculate:
		-use size() or length function.
		#include <iostream>
		using namespace std;

		int main(){
			string s ="Vivek";
			std::cout << s.size() << std::endl;         //11
			std::cout << s.length() << std::endl;       //11

			return 0;
		}

	//Max of integer:
		int max_of_four(int a, int b, int c, int d){
			return max(max(a,b),max(c,d));
		}

	//String assinging value at specific index:
		#include <iostream>
		using namespace std;
		int main(){
			string a,b;
			cin>>a;
			cin>>b;
			
			cout<<a.length()<<" "<<b.length()<<endl;
			cout<<(a+b)<<endl;

			swap(a[0],b[0]);
			cout<<a<<" "<<b<<endl;
			
			a[0]='Z';
			b[2]='Q';
			
			cout<<a<<" "<<b;
			return 0;
		}
		//output:
			Vivek 
			Rohini
			5 6
			VivekRohini
			Rivek Vohini
			Zivek VoQini

	//Local variables are stored in an area called a stack. Global variables, static variables, and program instructions 
	 are stored in the permanent storage area. The memory space between these two regions is known as a heap.

	#modulus operator:
		-when you take mod operation on any num with x, then output
		 will be inbetween 0 to (x-1);
		 eg.
		 	with 5: output will be 0 to 4.	|	with 10: output will be 0 to 9.
			1 % 5 = 1						|		1 % 10 = 1
			2 % 5 = 2						|		2 % 10 = 2
			3 % 5 = 3						|		3 % 10 = 3
			4 % 5 = 4						|		4 % 10 = 4
			5 % 5 = 0						|		5 % 10 = 5
			6 % 5 = 1						|		6 % 10 = 6
			7 % 5 = 2						|		7 % 10 = 7
			8 % 5 = 3						|		8 % 10 = 8
			9 % 5 = 4						|		9 % 10 = 9
			10 % 5 = 0					|		10 % 10 = 0
		
		Properties:
			◎  (a % m) + (b % m) = (a + b) % m
			◎  (a % m) - (b % m) = (a - b) % m
			◎  (a % m) * (b % m) = (a * b) % m

	//to find the datatype of variable in c++ 
		//use typeid(varName).name() function.
		#include <bits/stdc++.h> 
		#define M 32
		using namespace std; 
		int main() { 
			auto x = 5;    //i for integer
			auto y = 3.37; //D for double
			auto ptr = &x; //Pi for pointer
			auto z = "Hello";//PKc for string
			auto ch = 'Z';      //c for char
			bitset <M> bset(2);
			auto k = bset; //bitset :: St6bitsetILm32EE 
			
			cout << typeid(x).name() << endl 
				<< typeid(y).name() << endl 
				<< typeid(k).name() << endl 
				<< typeid(ptr).name() << endl 
				<< typeid(z).name() << endl 
				<< typeid(ch).name() << endl; 

			return 0; 
		} 

	//Finding maximum num from vector
		-using max_element function.
		-we need to take iterator for this.
		-max_element function found in algorithm header file sp include algorithm.
			#include <iostream>
			#include<vector>
			#include<algorithm>
			using namespace std;

			int main(){
				vector<int> ans = {1,2,3,4,5,6,7,8,9,910};
				
				auto maxer = max_element(ans.begin(), ans.end());
				std::cout << *maxer << std::endl;
				
				//max element from 3rd position to 7th position, 0-index based. means between 4 & 8.
				//both index inclusive 3rd & 7th also, but max_element function exclude the last index that's why we added 1 manually
				maxer = max_element(ans.begin()+3, ans.begin()+7+1);        
				std::cout <<*maxer << std::endl;

				//To know the type of particular variable:

				auto maxer = max_element(ans.begin(), ans.end());
				std::cout << *maxer << std::endl;
				std::cout << typeid(maxer).name() << std::endl;
				std::cout << typeid(ans).name() << std::endl;
				
				int c;
				std::cout << typeid(c).name() << std::endl;
				string s="asdf";
				std::cout << typeid(s).name() << std::endl;

				return 0;
			}

	//Finding maximum & minimum num from vector:
		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;

		int main(){
			vector<int> v = {1,2,3,-9,5,6,707,8,9,10};
			
			auto mx = max_element(v.begin(), v.end());
			std::cout << *mx << std::endl;              //707
			
			auto mn = min_element(v.begin(), v.end());			//endIndex is excluded.
			std::cout << *mn << std::endl;      //-9
			
			return 0;
		}

	//Dynamic array Creation:
		#include<iostream>
		using namespace std;
		int main() {
			int x, n;
			cout << "Enter the number of items:" << "\n";
			cin >>n;
			int *arr = new int(n);				//or
			//int * arr = new int[n];

			cout << "Enter " << n << " items" << endl;
			for (x = 0; x < n; x++) {
				cin >> arr[x];
			}
			cout << "You entered: ";
			for (x = 0; x < n; x++) {
				cout << arr[x] << " ";
			}
			return 0;
		}
		1. Include the iostream header file into our program to use its functions.
		2. Include the std namespace in our program in order to use its classes without calling it.
		3. Call the main() function. The program logic should be added within the body of the function.
		4. Declare two integer variables x and n.
		5. Print some text on the console prompting the user to enter the value of variable n.
		C++ Dynamic Allocation of Arrays with Example
		6. Read user input from the keyboard and assigning it to variable n.
		7. Declare an array to hold a total of n integers and assigning it to pointer variable *arr.
		8. Print a message prompting the user to enter n number of items.
		9. Use a for loop to create a loop variable x to iterate over the items entered by the user.
		10. Read the elements entered by the user and storing them in the array arr.
		11. End of the body of the for loop.
		12. Print some text on the console.
		13. Use a for loop to create a loop variable x to iterate over the items of the array.
		14. Print out the values contained in the array named arr on the console.
		15. End of the body of the for loop.
		16. The program must return value upon successful completion.
		17. End of the body of the main() function.

		//Another example
			Dynamically Deleting Arrays:
				A dynamic array should be deleted from the computer memory once its purpose is fulfilled. 
				The delete statement can help you accomplish this. 
				The released memory space can then be used to hold another set of data. 
				However, even if you do not delete the dynamic array from the computer memory, 
				it will be deleted automatically once the program terminates.

			Note:
				To delete a dynamic array from the computer memory, you should use delete[], 
				instead of delete. The [] instructs the CPU to delete multiple variables rather than one variable. 
				The use of delete instead of delete[] when dealing with a dynamic array may result in problems. 
				Examples of such problems include memory leaks, data corruption, crashes, etc.

			#include<iostream>
			using namespace std;
			int main() {
				int x, n;
				cout << "How many numbers will you type?" << "\n";
				cin >>n;
				int *arr = new int(n);
				cout << "Enter " << n << " numbers" << endl;
				for (x = 0; x < n; x++) {
					cin >> arr[x];
				}
				cout << "You typed: ";
				for (x = 0; x < n; x++) {
					cout << arr[x] << " ";
				}
				cout << endl;
				delete [] arr;
				return 0;
			}
			Summary
				-Regular arrays have a fixed size. You cannot modify their size once declared.
				-With these types of arrays, the memory size is determined during compile time.
				-Dynamic arrays are different. Their sizes can be changed during runtime.
				-In dynamic arrays, the size is determined during runtime.
				-Dynamic arrays in C++ are declared using the new keyword.
				-We use square brackets to specify the number of items to be stored in the dynamic array.
				-C++ Dynamic Allocation of Arrays with Example
				-Once done with the array, we can free up the memory using the delete operator.
				-Use the delete operator with [] to free the memory of all array elements.
				-A delete without [] frees the memory of only a single element.
				-There is no built-in mechanism to resize C++ arrays.

	//count the no.of digit in number:

		#include <iostream>
		#include<cmath>
		using namespace std;

		int main() {
			//get no.of digit in n;
			long n= 123456789;
			
			std::cout << n << std::endl;
			std::cout << "no.of digit : "<< static_cast<int>(log10(n)+1)<< std::endl;
			
			std::cout << "no.of digit : "<< (int) log10(n)+1<< std::endl;
			std::cout << "no.of digit : "<< static_cast<int>(log10(n)+1)<< std::endl;    
			
			//static_cast<int> used to convert from double or float to int.
			// or to count the no.of digit in n, you can use this also...
			int cnt=0;
			while(n>0){
				cnt++;
				n/=10;
			}
			std::cout << "The CNT : "<< cnt << std::endl;
			return 0;
		}

	//string erase practice:

		#include <iostream>
		using namespace std;

		int main() {
		
			//erasing last single characters
			string s = "Hello World";
			std::cout << s << std::endl;            //Hello World
			
			s.erase(s.end()-1);
			std::cout << s << std::endl;            //Hello Worl
			
			s.erase(s.length()-1);
			std::cout << s << std::endl;            //Hello Wor
			
			//erasing starting characters
			s.erase(s.begin());
			std::cout << s << std::endl;            //ello Wor
			
			// erase 4th character from start
			s = "Hello World";
			std::cout << s << std::endl;            //Hello World
			s.erase(s.begin()+4);
			std::cout << s << std::endl;            //Hell World
			
			//erase all except first character
			s.erase(1);
			std::cout << s << std::endl;            //H

				//delete all except first 4  character
			s = "Hello World";
			std::cout << s << std::endl;    //Hello World
			s.erase(4);
			std::cout << s << std::endl;        //Hell
			
			//erase starting 3 character
			s = "Hello World";
			s.erase(s.begin(),s.begin()+3);             //Hello World
			std::cout << s << std::endl;                //lo World
			
			//delete everything except last 3 character
			s = "Hello World";
			s.erase(s.begin(), s.end()-3);      //Hello World
			std::cout << s << std::endl;        //rld
			
			//delete everything except last 5 character
			s = "Sveri college of Engineering";
			std::cout << s << std::endl;            //Sveri college of Engineering
			s.erase(s.begin(), s.end()-5);          
			std::cout << s << std::endl;            //ering

			return 0;
		}

	//Substring:

		#include <iostream>
		using namespace std;

		int main() {
			
			string s="Hello World";
			
			//extracting last char.
			std::cout << s << std::endl;            //Hello World
			cout<<s.substr(s.length()-1)<<endl;     //d     //stringName.substr(starIndex,(optional, how many character you want));
			
			//extracting first char using substr method
			std::cout << s.substr(0,1) << std::endl;        //H  //from startIndex, extract 1 char.
			
			//extract all from 2nd index
			std::cout << s.substr(2) << std::endl;          //llo World
			
			return 0;
		}

	//Array to Vector:
		//using range in vector:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main() {
				int arr[] = { 1,3,5,7,9,11,7,8,9,10 };

				vector<int> vec(arr, arr+3);			(3-0 = 3 elements)

				for (int i = 0; i < 3; i++) 
					cout << vec[i] << " ";                  //1, 3, 5

				
				// from 4th index to till last 0-based
				vector<int> vec1(arr+4,arr+10);             //9,11,7,8,9,10      (10-4=6 elements will be there in vec1)
				std::cout << std::endl;
				for(int z: vec1)
					cout<<z<<" ";
				
					return 0;
			}

		//copying array to vector using insert
			#include <iostream>
			#include <vector>
			using namespace std;
			int main(){
				
				int arr[] = {0,9,8,7,6,5,4,3,2,10};
				
				//copying array to vector;
				
				for(int i=0; i<10; i++)
					cout<<arr[i]<<" ";
					
				std::cout << std::endl;
				vector<int> copied;
				
				//copying
				copied.insert(copied.begin(), arr, arr+10);         //vectorName.insert(startIndex, arrayStartIndex, arrayEndIndex)
				
				for(int z: copied)
					cout<<z<<" ";
				
				return 0;
			}

		//using assign:
			#include <iostream>
			#include <vector>
			using namespace std;

			int main() {
				int arr[] = {0,9,8,7,6,5,4,3,2,10};
				
				//copying array to vector;
				
				for(int i=0; i<10; i++)
					cout<<arr[i]<<" ";          //0,9,8,7,6,5,4,3,2,10
					
				std::cout << std::endl;
				vector<int> copied;
				
				//copying complete array
				copied.assign(arr,arr+10);          //vectorName.insert(startIndex, arrayStartIndex, arrayEndIndex)
									
				for(int z: copied)
					cout<<z<<" ";               //0,9,8,7,6,5,4,3,2,10
					
				copied.clear();
				
				//copying 4 elements from 3rd index (0-based)
				copied.assign(arr+3, arr+7);
				std::cout << std::endl;
				
				for(int z: copied)
					cout<<z<<" ";               //7,6,5,4 (last index excluded 7th which is 3.)
				
				return 0;
			}

	//Vector Practice:
		#include <iostream>
		#include<vector>
		using namespace std;
		int main() {
			int arr[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
			std::cout << "Main ARR: "<< "\t\t";
			for(int i: arr){
				std::cout << i << " ";
			}
			std::cout << std::endl;
			
			//array to vector using insert method
			vector<int> vecIns;
			
			std::cout << "vecIns : " <<"\t\t";
			vecIns.insert(vecIns.begin(), arr, arr+10);         //first 10 elements
			
			for(int h: vecIns)
				std::cout << h <<"\t";
				
			std::cout << std::endl;
			std::cout << std::endl;
			
			//array to vector using assign method,
			// 10th to 20th elements            (20-10=10 elements will be there in new vector)
			vector<int> vecAssign;
			vecAssign.assign(arr+10, arr+20);
			std::cout << "vecAssign : "<< "\t\t";
			for(int h: vecAssign)
				std::cout << h <<"\t";
				
			std::cout  << std::endl;
			std::cout << "vecAssign Whole array: " <<" ";
			//assigning whole array to vecAssign,
			vecAssign.assign(arr, arr+20);
			for(int h: vecAssign)
				std::cout << h <<" ";
				
			
			std::cout << std::endl;
			std::cout << std::endl;
			
			//array to vector using range, first 5 elements
			vector<int> vec1(arr, arr+5);        //(5-0=5 elements)
			
			for(int i=0; i<5; i++)
				cout<<vec1[i]<<" ";
			
			//or
			std::cout << std::endl;
			for(int z: vec1)
				cout<<z<<" ";
				
			
			std::cout << std::endl;
			std::cout << std::endl;
			//creating vector of specific size & specific value,
				std::cout << std::endl;
				vector<int> vec2 (8, 127);          //size=8, default value= 127.
				for(auto aa: vec2)
					std::cout << aa << " ";
					
				std::cout << std::endl;
				std::cout << std::endl;
				
			//creating 2D char vector with specific size, & default value.
				vector<vector<char>> vec2D (4, vector<char>(5,'$'));            //2D char vector of 4 rows & 5 cols of default value is $ dollar sign.
				
				for(int i=0; i<vec2D.size(); i++){
					for(int j=0; j<vec2D[0].size(); j++)
						cout<<vec2D[i][j]<<" ";
					std::cout << std::endl;
				}
			
			std::cout << std::endl;
			//create 3D vector of int type with default value 9.
				//row =3
				//cols =4
				//height =2
				
				vector<vector<vector<int>>> vec3D (3, vector<vector<int>>(4, vector<int>(2,0)));
				
				for(int i=0; i<3; i++){
					for(int j=0; j<4; j++){
						for(int k=0; k<2; k++){
							cout<<vec3D[i][j][k]<<" ";
						}
						std::cout << "\t";
					}
					std::cout << std::endl;
				}
			
			return 0;
		}
		output:
			Main ARR:               1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
			vecIns :                1       2       3       4       5       6       7       8       9       10

			vecAssign :             11      12      13      14      15      16      17      18      19      20
			vecAssign Whole array:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 

			1 2 3 4 5 
			1 2 3 4 5 


			127 127 127 127 127 127 127 127 

			$ $ $ $ $ 
			$ $ $ $ $ 
			$ $ $ $ $ 
			$ $ $ $ $ 

			0 0     0 0     0 0     0 0 
			0 0     0 0     0 0     0 0 
			0 0     0 0     0 0     0 0 

	//Static variables are stored in the memory in
		Heap
		Permanent storage area
		Free memory
		Stack
		( Correct Answer
				#### Local variables are stored in an area called a stack. Global variables, static
				variables, and program instructions are stored in the permanent storage area. The
				memory space between these two regions is known as a heap.

	//Repeated num in array
		Sample Input:
			2
			10
			1 2 3 4 5 5 5 6 7 7
			15
			1 1 1 1 1 2 2 2 2 2 3 3 3 3 3
		Output:
			1->1
			2->1
			3->1
			4->1
			5->3
			6->1
			7->2

			1->5
			2->5
			3->5

		#include <iostream>
		#include<unordered_map>
		using namespace std;

		int main() {
			int arr[] = {1,2,3,4,5,4,4,2,2,2};
			int n=10;
			unordered_map<int, int> countRepetition;
			
			cout<<"arr: ";
			for(int i: arr)
				cout<<i<<" ";
				
			std::cout << std::endl;
			for(int i=0; i<n; i++)
				countRepetition[arr[i]]++;
			
			for(auto itr = countRepetition.begin(); itr != countRepetition.end(); itr++)        //use -> (arrow) operator in traditional for loop.
				cout<<itr->first<<" repeated\t"<<itr->second<<" times\n";
			
			std::cout << std::endl;
			std::cout << std::endl;
			
			//to print the conent of map
			for(const auto i: countRepetition)            //use . (dot) operator in advance for loop
				cout<<i.first<<" repeated "<<i.second<<" times\n";

			return 0;
		}

		//counting frequency using unordered_map ❌Pending

	//Pointer function practice:
		#include <iostream>
		using namespace std;

		//function receives address
		void function1(int *p){          //storing passed address into pointer p.
			(*p)++;                     //incrementing the value at that address.
		}

		//function receives value. make copy of it & as soon as function
		//ends it delete the new value & in main come back to original value.
		void function2(int a){
			a++;
			std::cout << "inside "<< a << std::endl;
		}

		//here receiving value's address & modifying the address value,
		//so updated value will be preserved.
		void function3(int &a){
			a++;
			std::cout << "inside :"<< a << std::endl;
		}


		int main() {
			// passing pointer to the function
			int a=90;
			int*ptr = &a;
			
			std::cout << "before ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;
			function1(ptr);          //passing address indirectly, then function receiver must be pointer only coz we're passing address
			std::cout << "After ptr: "<< *ptr << std::endl;
			std::cout << "After A: "<< a << std::endl;
			std::cout << std::endl;
			
			*ptr = 90;
			std::cout << "before ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;
			function2(*ptr);          //passing values directly(pointer). 
									// so function receiver must be either simple datatype variable or address of that variable
			std::cout << "After ptr: "<< *ptr << std::endl;
			std::cout << "After A: "<< a << std::endl;
			std::cout << std::endl;
			
			*ptr = 90;
			std::cout << "before ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;
			function3(*ptr);          //passing values directly.
			std::cout << "After ptr: "<< *ptr << std::endl;
			std::cout << "before A: "<< a << std::endl;

			return 0;
		}
		//output
			before ptr: 90
			before A: 90
			After ptr: 91
			After A: 91

			before ptr: 90
			before A: 90
			inside 91
			After ptr: 90
			After A: 90

			before ptr: 90
			before A: 90
			inside :91
			After ptr: 91
			before A: 91

	//Array Practice:
		#include <iostream>
		using namespace std;
		int main() {
			int a[l={5,6,7,8};
			cout<< * (a + 2) <<  " " << a[1];		//	7 6
			return 0;
		}

	//Binary to decimal & decimal to binary:
		using built-in function
		#include <iostream>
		#include<bitset>
		using namespace std;

		int main() {
			int num = 21;
			
			std::cout << num << std::endl;    
			//decimal to binary, binary to string & storing it into s
			string s = bitset<32>(num).to_string();			//converting bitset output to string.
			std::cout << s << std::endl;
			
			//decimal to binary
			// changing last 4 bits
			s[31] = '1';
			s[30] = '1';          
			s[29] = '1';          
			s[28] = '1'; 
			s[27] = '0';
			std::cout << s << std::endl;
			
			//string binary to decimal
			num = stoi(s,0,2);
			std::cout << num << std::endl;          //15
			std::cout << s << std::endl;

			return 0;
		}
		//output:
			21
			00000000000000000000000000010101
			00000000000000000000000000001111
			15
			00000000000000000000000000001111

	//Finding maximum/ minimum element from array & its index
		using built in function:
		#include <iostream>
		#include <algorithm>

		int main() {
			int arr[] = {3, 7, 1, 9, 4, 2, 6, 8, 5};
			int n = sizeof(arr) / sizeof(arr[0]);

			// Use std::max_element to find the iterator to the maximum element
			auto maxElementIter = std::max_element(arr, arr + n);

			if (maxElementIter != arr + n) {				//(arr+n) indicate its end of array
													//meaning of (maxElementIter != arr + n) is iterator is not reached to the end, 
													//if its reaches to the end then else block will gets executed
				int maxIndex = std::distance(arr, maxElementIter);
				int maxElement = *maxElementIter;					//using * operator getting value at that iterator.
				std::cout << "Maximum element: " << maxElement << std::endl;
				std::cout << "Index of maximum element: " << maxIndex << std::endl;
			} else {
				std::cout << "Array is empty" << std::endl;
			}

			return 0;
		}

		//if its vector then in max_element function parameter will be like (arr.begin(), arr.end())

		-auto keyword is automatically determine the type of variable we are creating.
		-here auto, we used for creating iterator.

		//or

			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {   
				//for array finding max & min & their indexes
				int arr[] = {1,2,3,4,-5,90,7,8,9,10};           //min=-5, minIndx = 4 & max = 90, maxIndx = 5
				
				std::cout << "In Array: " << std::endl;
				
				auto mx = max_element(arr, arr+10);         //traversing complete Array.
				int maxIndx = distance(arr, mx);            //using distance method also you can find the index of element.
				
				std::cout << "maximum num in array: "<< *mx << " maxIndex: "<< maxIndx << std::endl;
				std::cout << "index of max num : "<< (mx-arr) << std::endl;             //
				
				auto mn = min_element(arr,arr+10);
				int minIndx = distance(arr, mn);
				std::cout << "minimum num in array: "<< *mn << " minIndx: "<< minIndx << std::endl;
				//or finding index be like
				std::cout << "index of min num : "<< (mn-arr) << std::endl;             //min num address - base address will be index of that min num.
				
				return 0;
			}
	
		//or using pointer you can create a iterator for array
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {   
				//for array finding max & min & their indexes
				int arr[] = {1,2,3,4,-5,90,7,8,9,10};           //min=-5, minIndx = 4 & max = 90, maxIndx = 5
				
				std::cout << "In Array: " << std::endl;
				
				std::cout << "maximum element is : "<< *max_element(arr,arr+10) << std::endl;
				
				//or
				int * ptr = max_element(arr,arr+10);
				std::cout << "maximum element using pointer : "<< *ptr << std::endl;
				std::cout << "index of max element : "<< (ptr-arr) << std::endl;            //elements address - base address.
				
				ptr = min_element(arr,arr+10);
				std::cout << "manimum element using pointer : "<< *ptr << std::endl;
				std::cout << "index of min element : "<< (ptr-arr) << std::endl;            //elements address - base address.
				
				//or using distance
				std::cout << "index of min element : "<< distance(arr, min_element(arr,arr+10)) << std::endl;
				return 0;
			}
	
	//Vector max/min element & its index
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {  
			//for vector finding max & min & their indexes
			vector<int> vec = {10,9,8,7,6,5,4,3,2,1};           //maxElement = 10 , maxIndex = 0
														//minElement= 1, minIndex = 9.
			
			for(int i: vec)
				cout<<i<<"\t";
			std::cout << std::endl;
			std::cout << "In vector: " << std::endl;
			
			//using auto keyword which is like iterator
			auto mx = max_element(vec.begin(), vec.end());
			int maxIndex = distance(vec.begin(), mx);				//for vector passing parameter is base address is (vectorName.begin(), iterator)
			std::cout << "maxElement : "<< *mx << ", maxIndex : "<< maxIndex << std::endl;
			
			//using iterator (in vector iterator is like pointer only easy to create, you can create actual/basic pointer also but no need)
			// in array you have to create pointer instead of iterator, 
			// iterator for vector & pointer for array
			
			vector<int>::iterator ptr = max_element(vec.begin(), vec.end());
			maxIndex = distance(vec.begin(), ptr);
			std::cout << "using POINTER, maxElement : "<< *ptr << ", maxIndex : "<< maxIndex << std::endl;
			
			std::cout << "minElement : "<< *min_element(vec.begin(), vec.end())<< ", minIndex : "<< distance(vec.begin(), min_element(vec.begin(), vec.end())) << std::endl;
			std::cout << "minElement: "<< *min_element(vec.begin(), vec.end()) <<", min element index: "<< (min_element(vec.begin(), vec.end())-vec.begin()) << std::endl;              //(element address - base address) = index of element
			
			return 0;
		}

	//auto iterator, extracting value using * & value to iterator
		#include<bits/stdc++.h>             //all header file include in this #include<bits/stdc++.h>
		#include <iostream>
		using namespace std;
		int main() {
			vector<int> vec = {1,2,3,4,5,6,707,8,9,10,11,12};       //maximum=707 index=6
			int n = vec.size();
			std::cout << "vec1 size: "<< n << std::endl;
			
			//traditional way,
			int mx = INT_MIN;                   //for INT_MIN  climits header file should be added. #include<climits>
			int indx;
			for(int i=0; i<n; i++){
				if(vec[i] > mx){
					mx = vec[i];
					indx = i;
				}
			}
			
			std::cout << "Traditional way, maximum element: "<< mx << ", At index: "<< indx << std::endl;
			
			//using built-in function.
			//finding maximum element
			auto maxer = max_element(vec.begin(), vec.end());
			cout<<"built-in function, Maximum element : "<<*maxer<<",\t";
			
			//finding index of Maximum element
			int index = distance(vec.begin(), maxer);
			std::cout << "At index: "<< index << std::endl<< std::endl;
			
			//other way to create a iterator for vector,
			vector<int> vec2 = {10,90,20,0,40};                     //min_element=0, index=3
			std::cout << "vec2 size: "<< vec2.size() << std::endl;
			
			//iterator
			vector<int>::iterator IT_vec2;
			IT_vec2 = min_element(vec2.begin(), vec2.end());
			
			//Minimum element from 2nd vector
			std::cout <<"Minimum element of vec2: "<< *IT_vec2 << ", ";
			
			//extracting the index of minimum element
			int indx_vec2_min_elmnt = distance(vec2.begin(), IT_vec2);
			std::cout << "At index: "<< indx_vec2_min_elmnt << std::endl;
			
			std::cout << "Address of minimum element: "<< &vec2[indx_vec2_min_elmnt] << std::endl;
			std::cout << "Address of minimum element using iterator: "<< &(*IT_vec2) << std::endl;
			
			std::cout << "Address of iterator IT_vec2: "<< &IT_vec2 << std::endl;           //stays constant
			
			IT_vec2++;
			
			std::cout << "Address of iterator IT_vec2 after updating: "<< &IT_vec2 << std::endl;        //same as previous
			std::cout << "Value at iterator IT_vec2: "<< *IT_vec2 << std::endl;
			
			//reseting the iterator to start of vec2
			IT_vec2 = vec2.begin();
			std::cout << "Value at iterator IT_vec2: after resetting "<< *IT_vec2 << std::endl;
			std::cout << "Address of iterator IT_vec2 after resetting: "<< &IT_vec2  << std::endl;      //still same as previous
			
			//updating value of vec2 using iterator
			//currently IT_vec2 is pointing to first element of vec2 which is 10
			//update it to 44
			*IT_vec2 = 4;
			std::cout <<"using vec2 index: "<< vec2[0] << std::endl;          //or
			std::cout << "using iterator: "<< *IT_vec2 << std::endl;
			
			std::cout << "vec2: ";
			for(int i: vec2)
				std::cout << i << " ";
			
			return 0;
		}
			//output:
				vec1 size: 12
				Traditional way, maximum element: 707, At index: 6
				built-in function, Maximum element : 707, At index: 6

				vec2 size: 5
				Minimum element of vec2: 0, At index: 3
				Address of minimum element: 0x55a4b02f730c
				Address of minimum element using iterator: 0x55a4b02f730c
				Address of iterator IT_vec2: 0x7ffc266acae0							//Address of iterator won't change
				Address of iterator IT_vec2 after updating: 0x7ffc266acae0				//Address of iterator won't change
				Value at iterator IT_vec2: 40
				Value at iterator IT_vec2: after resetting 10
				Address of iterator IT_vec2 after resetting: 0x7ffc266acae0				//Address of iterator won't change
				using vec2 index: 4
				using iterator: 4
				vec2: 4 90 20 0 40 

	//bitset, substr, extracting some char from starting or ending
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			int i= 8, len=4;
			string startS = bitset<32>(i).to_string();
			std::cout << startS  << std::endl;
			
			std::cout << startS.substr(startS.length()-5) << std::endl;         //extracting last 5 char
			
			int n=15;
			string second =  bitset<32>(n).to_string();
			
			std::cout << n << " = ";
			std::cout <<second << std::endl;

			second = second.substr(second.length()-8);
			std::cout << second << std::endl;           //extracting last 8 char

			//extracting 1st 5 char 00001
			std::cout << second.substr(0,5) << std::endl;
			return 0;
		}

	//string array sorting
		Practice-1:
			#include <iostream>
			#include<vector>
			#include<algorithm>
			using namespace std;

			int main() {
				vector<string> vec ={"Vivek", "Mahesh", "Nikate"};
				for(auto i: vec)
					std::cout << i << "\t";     //Vivek   Mahesh  Nikate
				
				std::cout << std::endl;
				
				sort(begin(vec), end(vec));         //Mahesh Nikate Vivek
				for(auto i: vec)
					std::cout << i << "\t";
					
				std::cout << std::endl;
				vector<string> vec2= {"ABC","ABCD","ABCDE","ABCDEF","ABCDEFG"};
				for(auto i: vec2)
					std::cout << i << "\t";     //ABC     ABCD    ABCDE   ABCDEF  ABCDEFG
				
				std::cout << std::endl;
				
				//sorting string array
				sort(begin(vec2),end(vec2));
				for(auto i: vec2)
					std::cout << i << "\t";     //ABC     ABCD    ABCDE   ABCDEF  ABCDEFG

				std::cout  << std::endl;
				vector<string> vec3 = {"vivek","Vivek"};
				for(auto i: vec3)
					std::cout << i << "\t";     //vivek Vivek               //ascii value of V is less than v.
				
				std::cout << std::endl;
				sort(begin(vec3),end(vec3));
				for(auto i: vec3)
					std::cout << i << "\t";     //Vivek   vivek
				
				std::cout << std::endl;
				// sorted in alphabetical order
				vector<string> vec4 = {"FG","GH","HI","CD","AB","BC","DE","EF"};    
				for(auto i: vec4)
					std::cout << i << "\t";     // "FG","GH","HI","CD","AB","BC","DE","EF"
				
				std::cout << std::endl;
				// after sorting
				sort(begin(vec4),end(vec4));
				for(auto i: vec4)
					std::cout << i << "\t";             //"AB","BC","CD","DE","EF","FG","GH","HI"
				
				return 0;
			}

		Practice-2:
			-you can replace all header files with <bits/stdc++.h>
			// #include <iostream>
			// #include<vector>
			// #include<algorithm>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				vector<string> vec1 = {"ABC", "ABCD", "ABCE", "ABCA"};
				for(string i: vec1)
					std::cout << i << "\t";         //"ABC", "ABCD", "ABCE", "ABCA"
					
				// after sorting
				std::cout << std::endl;
				sort(begin(vec1),end(vec1));
				for(auto i: vec1)
					std::cout << i << "\t";     // ABC     ABCA    ABCD    ABCE
					
				std::cout << std::endl;
				vector<string> vec2 = {"ABCD", "ABCE", "ABCA","ABC"};
				
				for(auto i: vec2)
					std::cout << i << "\t";     //"ABCD", "ABCE", "ABCA","ABC"
					
				std::cout << std::endl;
				
				sort(begin(vec2),end(vec2));
				for(auto i: vec2)
					std::cout << i << "\t";     //ABC     ABCA    ABCD    ABCE


				return 0;
			}

	//Iterator:
		-ContainerType should be replaced with the type of your container (e.g., std::vector<int>, std::list<double>, etc.).
		-container is the container you want to search within.
		-value is the value you want to find within the container.
		-std::find returns an iterator pointing to the found element. 
		-You can compare it to container.end() to determine if the element was found. 
		 If the iterator is not equal to container.end(), the element was found, and you can access it using *result.

		Here's an example using std::find with a std::vector:
		eg.
			#include <algorithm> // Include the algorithm header for std::find
			#include <iterator>  // Include the iterator header for iterator types

			// Using std::find to search for an element in a container
				ContainerType::iterator result = std::find(container.begin(), container.end(), value);

			// Check if the element was found
			if (result != container.end()) {
				// Element found, you can access it using *result
			} else {
				// Element not found
			}


		#include <iostream>
		#include <vector>
		// #include<bits/stdc++.h>
		#include<algorithm>
		using namespace std;
		int main() {
			std::vector<int> numbers = {1, 2, 3, 4, 5};

			// Obtain an iterator to a specific element.
			std::vector<int>::iterator it = std::find(numbers.begin(), numbers.end(), 3);

			// Check if the element was found before accessing it.
			if (it != numbers.end()) {
				// Calculate the position using std::distance.
				int position = std::distance(numbers.begin(), it);
				std::cout << "Element 3 found at position " << position << std::endl;
			} else {
				std::cout << "Element not found" << std::endl;
			}
			return 0;
		}

	//vector sorting & finding their indexes using find() & distance() method
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> vec = {40,50,30,60,20,70,10};
			
			for(int i: vec)
				std::cout << i << " ";
			std::cout << std::endl;
			
			//printing the vector element in reverse order
			for(auto i = vec.rbegin(); i != vec.rend(); i++)
				std::cout << *i << std::endl;
			
			vector<int> sortedVec = vec;    
			//index of element sorted way
			sort(sortedVec.begin(), sortedVec.end());
			std::cout << std::endl;
			std::cout << "Address of element in vec: " << std::endl;
			for(int i=0; i<vec.size(); i++){
				// std::cout <<"index of " << sortedVec[i] <<" at "<< abs(vec.begin() - find(vec.begin(), vec.end(), sortedVec[i])) << std::endl;
				std::cout <<"index of " << sortedVec[i] <<" at "<< distance(vec.begin(), find(vec.begin(), vec.end(), sortedVec[i])) << std::endl;
			}
			return 0;
		}

		//or
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				int ans=0;
				vector<int> h = {20, 2, 3, 4, 1};
				for(int i: h)
					std::cout << i << " ";
				std::cout << std::endl;
				
				//using find method showing the index
				for(int i: h){
					std::cout << i << " is present at index: "<< abs(find(h.begin(), h.end(), i)- h.begin()) << std::endl;
				}
			}

	//unordered_map mapping indexes with respective element
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		int main() {
			vector<int> h = {100, 200, 300, 400};
			int n=5;

			unordered_map<int, int> indexMap;
			for (int i = 0; i < n; i++) {
				indexMap[h[i]] = i;
			}
			
			cout<<"unordered_map : "<<endl;
			for(auto i: indexMap){
				std::cout << "key " << i.first <<" at index "<< i.second << " indexMap[i.first] inserting key outputing value :"<< indexMap[i.first];
				std::cout << "\tindexMap[i.second] inserting value : " << indexMap[i.second]  << std::endl;
				//if that value is present in keys list then it will output as the value associated with that key, else it will be 0.
			}			
			
			return 0;
		}

	//unordered_map
		-if you use advance for loop then you have to use . (dot) Syntax.
		eg.
			for(auto i: unMP){
				std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
			}
		
		-if you use traditional/ normal for look then you have to use -> (arrow) syntax.
		eg. 
			normal for loop, to access the data use -> syntax, for map data type should be auto.
			for(auto i = unMP.begin(); i!= unMP.end(); i++)
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;

		eg.
			-when we pass key to unordered_map like unMP[i] (key), then it will print the corresponding value of it.
			 if value is not present for that key, then it will considered as 0.
			for(int i: sortedVersion)
				std::cout << "Key: "<< i << "  Value: "<< unMP[i] << std::endl;
				

		eg.
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				vector<int> vec = {600,700, 100 ,800, 900, 1,400,200,300,500};
				std::cout << "Toal "<< vec.size()<< " elements present in vector" << std::endl;
				
				std::cout << "The vector elements are :: " << std::endl;
				for(int i: vec)
					std::cout << i << " ";
				cout<<endl;
				
				vector<int> sortedVersion = vec;
				sort(sortedVersion.begin(), sortedVersion.end());
				
				std::cout << "vector elements in sorted order : " << std::endl;
				for(int i: sortedVersion)
					std::cout << i << " ";
				cout<<endl;
				
				//using map printing vector elements & their indexes
				unordered_map<int, int> unMP;
				int cnt=0;
				for(int i: vec)
					unMP[i] = cnt++;
					
				//unordered_map printing
				std::cout << endl << "unordered_map : " << std::endl;
				for(auto i = unMP.begin(); i!= unMP.end(); i++)
					std::cout << "Key: "<< i->first << " Value: " << i->second << std::endl;
					
				//using advance for loop
				std::cout << endl << "using advance for loop printing key value of unordered_map : " << std::endl;
				for(auto i: unMP){
					std::cout << "key: " << i.first << " Value: " << i.second << std::endl;
				}
				std::cout << std::endl;
				
				std::cout <<endl<< "printing using unordered_map with sortedVersion : " << std::endl;
				for(int i: sortedVersion)
					std::cout << "Key: "<< i << "  Value: "<< unMP[i] << std::endl;
				
				return 0;
			}

	//Sorting unordered_map:
		#include <iostream>
		#include<bits/stdc++.h>
		using namespace std;

		bool functionSortingByValue (pair<int, int> a, pair<int, int> b){
			return a.second < b.second;             //in ascending Order
			
			// return a.second > b.second;          // in descending Order
		}

		int main() {
			unordered_map<int, int> umap;
			
			umap[10] = 1;
			umap[200] = 20;
			umap[3] = 11;
			umap[40] = 25;
			umap[500] = 4;
			umap[1] = 35;
			
			std::cout << "Original Map: " << std::endl;
			
			vector<pair<int, int>> sorted;
			
			for(auto i: umap){
				std::cout << i.first << "\t" << i.second << std::endl;
				sorted.push_back({i.first, i.second});
			}
				
			std::cout << "\nSorted Order by keys: " << std::endl;
			
			//simple sort function
			sort(sorted.begin(), sorted.end());
			
			for(pair<int, int> i: sorted){
				std::cout << i.first << "\t" << i.second << std::endl;
			}
			std::cout << std::endl;
			
			std::cout << "\nSorted Order by value : " << std::endl;
			//sort function to sort based on key's value.
			
			// sort(sorted.begin(), sorted.end(), functionSortingByValue);
			
			//or
			/*
				sort(sorted.begin(), sorted.end(),[](pair<int, int> a, pair<int, int> b){
					return a.second > b.second;         //in Descending order.      function within another function
				});

			*/
			
			for(pair<int, int> i: sorted){
				std::cout << i.first << "\t" << i.second << std::endl;
			}
			return 0;
		}

	//Accumulator in c++:
		#include <numeric> 
		sum = accumulate(arr.begin(), arr.end(), 0);			//accumulate(startAddressArray, endAddressArray, initialSum);
		where 0, initialSum is in int type ie. 32 bit

		if you want sum of array of containing long long int values then accumulate function's initialSum = 0LL
		eg.
			sum = accumulate(v.begin(),v.end(),0LL);
			//or
			sum = accumulate(v.begin(),v.end(),0ll);
			//or
			long long value=0;
			sum = accumulate(v.begin(),v.end(),value);

		The accumulate function is used to calculate the sum of all elements 
		in the specified range (in this case, the range is defined by arr.begin() and arr.end()). 
		The result is then added to the sum variable, which holds the running sum of the elements in the array. 
		After this line of code is executed, sum will contain the total sum of all elements in the array.

		#include <iostream>
		#include<numeric>
		#include<vector>
		using namespace std;

		int main() {
			vector<int> v = {1,2,3,4,5,6,7,8,9,10};
			int sum = accumulate(v.begin(), v.end(), 0);
			
			std::cout << accumulate(v.begin()+1,v.begin()+3,0) << std::endl;    //5     //exclude last index, means 3-1 = 2, total no.of elements to be added will be 2 only
			
			std::cout << "complete array summation : "<< sum << std::endl; //55
			
			std::cout << "sum of first 5 elements :"<< accumulate(v.begin(), v.begin()+5,0) << std::endl;           //15
			
			std::cout << "sum of 4 elements from 2nd index: "<< accumulate(v.begin()+1,v.begin()+5,0) << std::endl;     //14
			
			std::cout << "Sum of 3rd index & 4th index:" << accumulate(v.begin()+3, v.begin()+5,0) << std::endl;        //9
			
			std::cout << "sum of first 5 elements initial sum 3 :"<< accumulate(v.begin(), v.begin()+5, 3) << std::endl;           //18
		}

	//C++ OOPS:
		-In C++, the default access specifier for members of a class is private. 
		 This means that if you don't explicitly specify an access specifier for 
		 your class members (methods or variables), they will be private by default.

	//TimeConversion 12 hour to 24 hour format:
		#include <iostream>
		#include<bits/stdc++.h>

		using namespace std;

		int main() {
			string s = "12:15:06 AM";
			
			string AmPm = s.substr(s.length()-2,2);
			// std::cout << AmPm << std::endl;
			string hour = s.substr(0,2);
			// std::cout << hour << std::endl;
			
			if(AmPm == "PM" && hour != "12"){
				hour = to_string(stoi(hour)+12);
			}else if(AmPm == "AM" && hour == "12"){
				hour ="00";
			}
			
			string timeString = hour + s.substr(2,6);
			
			std::cout << timeString  << std::endl;
			return 0;
		}

	//is_sorted:
		-The is_sorted function is part of the C++ Standard Template Library (STL), 
		 specifically provided by the <algorithm> header. 
		 This function is used to check whether a range of elements is sorted in non-decreasing order. 
		-It returns a boolean value indicating whether the elements in the specified range are sorted.
		
		#include <iostream>
		#include <algorithm>
		#include <vector>

		int main() {
			std::vector<int> numbers = {1, 2, 3, 5, 4, 6};

			if (std::is_sorted(numbers.begin(), numbers.end())) {
				std::cout << "The vector is sorted.\n";
			} else {
				std::cout << "The vector is not sorted.\n";
			}

			return 0;
		}
---------------------------------------------------------------------------------------------------------
POTD:-[Problem of the Day]
	1) Minimum Difference in an Array
		#include <bits/stdc++.h> 
		int minDiff(int n, vector < int > arr) {
			sort(arr.begin(), arr.end());
			// int minDiffHold = abs(arr[0] - arr[1]);      //or you can assign INT_MAX here also

			int minDiffHold =INT_MAX; 
			for (int i = 0; i < n - 1; i++) {
				if (arr[i] == arr[i + 1])
				return 0;

				int value = abs(arr[i] - arr[i + 1]);

				// assigning minimum value to mindiffhold variable.
				minDiffHold = min(value, minDiffHold);
			}
			return minDiffHold;
		}

	2) Reverse Coding:
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int row = mat.size();
			int column = mat[0].size();
			
			vector<vector<int>> v;

			for (int i = 0; i < row; i++) {

				vector<int> second;
				for (int j = column - 1; j >= 0; j--){
					int value = mat[i][j];
					second.push_back(value);
				}
				v.push_back(second);
			}

			return v;
		}

		//or
		#include <bits/stdc++.h> 
		vector<vector<int>> ninjaCity(vector<vector<int>> &mat){
			int i=0,n = mat.size();

			while(i<n){
				reverse(mat[i].begin(), mat[i].end());
				i++;
			}
			return mat;
		}

	3) Planet Division:
		vector<int> planetDivision(int n) {
			vector<int> v;
			(n % 2 == 0)?(v.push_back(n/2), v.push_back(n/2)):(v.push_back((n/2)+1), v.push_back(n/2));
			return v;
		}

	4) Missing number in array:
		class Solution{
			public:
			int missingNumber(vector<int>& array, int n) {
				//(TLE)
				// for(int i=1;i<=n;i++){
				//     int j;
				//     for(j=0;j<n;j++){
				//         if(array[j] == i)
				//             break;
				//     }
				//         if(j == n)
				//             return i;
				// }
				
				/or (TLE)
				// int counter = 1, i=0;
				// while(i<n){
				//     if(array[i++] == counter){
				//         i=0;
				//         counter++;
				//     }
				// }
				// return counter; 
				
				//or (optimized)
				sort(array.begin(), array.end());
				for(int i=0;i<n;i++){
					if(array[i] != i+1)
						return i+1;
				}
			}
		};

		//more optimized:
			class Solution{
				public:
				int missingNumber(vector<int>& array, int n) {
					// sort(array.begin(), array.end());
					// for(int i=0; i<n; i++){
					//     if(array[i] != i+1)
					//         return i+1;
					// }
					long long actSum = (n*(n+1))/2;
					long long SumArr =0;
					for(int z: array){
						SumArr += z;
					}
					return actSum - SumArr;
				}
			};

	5) Count Odd Even
		void countOddEven(int arr[], int sizeof_array)
		{
			int odd=0, even=0;
			for(int i=0; i<sizeof_array;i++){
				(arr[i] % 2)? odd++ : even++;
			}
			cout<<odd<<" "<<even<<"\n";
		}

	6) Pattern 11
		void printTriangle(int n) {
			int bit = 0;
			for(int i=0;i<n; i++){
				int tempBit = bit;
				for(int j=0; j<=i; j++){
					(tempBit)?(tempBit =0):(tempBit = 1);
					cout<<tempBit<<" ";
				}
				if(bit == 0)
					bit =1;
				else
					bit = 0;
				printf("\n");
			}
		}
		//output
			Input: 5
			Output:
				1 
				0 1 
				1 0 1
				0 1 0 1 
				1 0 1 0 1

	7) Boring Factorial:
		Input:
			3
			2 5			(2!) % 5 =2
			5 11			(5!) % 11 =10
			21 71		(21!) % 71 =6

		Output:
			2
			10
			6
		#include <iostream>
		using namespace std;

		int main(){	
			int fact=1;
			int n=23,p=29;
			
				if(n >= p)
					return 0;

				for(int i=1;i<=n; i++){
					fact = (fact * i) % p; 
				cout<< fact<<"\t";
				}
			return 0;
		}

	8) Class Test:
		Sample Input 1 :
			2
			3
			1
			3 4 4
			4
			3
			1 1 2 2 
		Sample Output 1 :
		4
		1
		Explanation Of Sample Input 1 :
		For test case 1 we have, 

		To get a Rank 1, Ninja must have scored maximum marks in the class.
		Hence, Ninja scored 4 marks.
		For test case 2 we have,
		Students with marks = 2 will achieve ranks 1 and 2 respectively.
		Students with marks = 1 will achieve ranks 3 and 4 respectively.
		So, Ninja scored 1 mark.
		Sample Input 2 :
			test cases : 3
			i.	2
				1
				20 9 

			ii.	2
				1
				9 17 

			iii.	7
				2
				9 6 0 2 20 10 5 
		Sample Output 2 :
			20
			17
			10

		#include <bits/stdc++.h> 
		int classTest(int n, vector<int> &a, int k) {
			sort(a.begin(), a.end());
			reverse(a.begin(), a.end());

			int mark=a[0], temp =1;
			for(int i=0;i<n;i++){
				if(temp == k){
						mark = a[i];
					}
				temp++;
			}
			return mark;
		}

	9) Find the lone set bit & return its index.
		#include <iostream>
		#include <bitset>
		using namespace std;

		int main(){
			int N = 136;
			cout<<"binary form 136 "<<bitset<32>(N);
			std::cout << std::endl;
			if(N == 0){
				cout<<-1;
				return 0;
			}

			int count=0;
			if(N&1){
				cout<<-1;
				return 0;
			}else{
				int setBit =0;
				while(N>0){
					if(setBit == 1 && N >0){
						cout<<-1;
						return 0;
					}
					
					if(N & 1)
						setBit++;       //111010
					
					count++;
					N>>=1;
				}
			}
			cout<<count;
			return 0;
		}
	
	10) String Count:
		Sample Input 1:-
			2
			4 
			##**    
			3
			***
			Sample Output 1:-
			1
			0
			Explanation Of Sample Input 1:-
			First test case:- 
			We have three substrings of size 2 for the string 'S', which are "##", "#*" and "**".
			Only one of them is good(#* or *#) . So, the total number of good substrings of 'S' is 1.

			Second test case:-
			There is no good substring in 'S', so the answer is 0.
			Sample Input 2:-
			2
			4
			#*#*
			2
			*#
			Sample Output 2:-
				3
				1

			int stringCount(int n, string &s) {
				int ttl=0;
				int len = s.length();
				
				for(int i=0; i<len; i++){
					
					char first = s[i];
					char sec = s[i+1];
					string str = "";
					str += first;
					str += sec;
					
					if(str == "#*" || str == "*#")
						ttl++;
				}

				return ttl;
			}

	11) Sequence Query:
		Sample Input 1:
			start value, diff, target
			1 2 7
		Sample Output 1 :
			1
		Explanation For Sample Input 1:
		The sequence here is 1, 3, 5, 7, .... As 7 is present in the sequence, the output is 1.

		Sample Input 2:
		5 0 3
		Sample Output 2 :
		0
		Explanation For Sample Input 2:
		The sequence here is 5, 5, 5, .... As 3 is not present in the sequence, the output is 0.

		int checkSequence(int a, int d, int x) {
			// Write your code here.
			if(a == x || (d==1 && a<x))
				return 1;
			
			if((a > x && d>0) || (a < x && d<0))
				return 0;

			int counter=0;

			for(int start=a; ;start+=d)
			{

				a += d;
				if(a == x)
					return 1;

				counter++;
				if(counter>30)
					return 0;
			}
		}

	12) min & max:
		without using conditional operator, ternary operator
		eg.
			pair<int,int> ans= {a,b};
			for(int i=b;i<a;i++) {
				ans = {b,a};
				break;
			}
			return ans;		//returning minimum, maximum.

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				pair<int,int>pr;

				int max = (a>=b)*a+(b>a)*b;
				int min = (a<=b)*a+(b<a)*b;

				pr.first = min;
				pr.second = max;

				return pr;
			}

		eg.
			#include <bits/stdc++.h> 
			pair < int , int > findMinMax(int a , int b){
				int mini = min(a,b);
				int maxi = max(a,b);
				
				pair<int,int> pr;
				// pr.first = mini;
				// pr.second = maxi;
				//or

				pr = {mini, maxi};
				return pr;
			}

		eg.
			#include <bits/stdc++.h>
			pair < int , int > findMinMax(int a , int b){
				return {min(a,b),max(a,b)};
			}
	
	13) Fibonacci series nums addition within given range:❌
		#include <bits/stdc++.h> 
		int fiboSum(int n , int m){
			int sum = 0;
			if(n<2) sum = 1;

			int a = 0, b = 1, mod = 1e9+7;

			for(int i=2;i<=m;i++){
				int c = (a+b)%mod;
				a = b;
				b = c;
				if(i>=n && i<=m)sum = (sum+c)%mod;
			}

			return sum;
		}

		#include <bits/stdc++.h> 
		long long int fiboSum(int n , int m){
			long long int prev =0, cur =1, fib=0;
			long long int sum=0;
			
			for(int i=0; i<=m; i++){
				
				// if(i>=n)
				// 	sum += prev;


				sum += prev;

				if(i<n)
					sum -= prev;
					
				fib = cur + prev;		 
				prev = cur;
				cur = fib;				 
			}
			return sum;	
		}

	14) Water Glass
		Sample Input 1:
		2
		2 2 2 3
		1 1 1 3
		Sample Output 1:
		normal
		cold
		##### Explanation Of Sample Input 1:

		For test case 1:
		The arrangement of glasses looks like,
		W W N N C C W W N N C C …………..
		Here the 3rd glass is N means it contains normal water.

		Hence, the answer for this case is "normal".


		For test case 2:
		The arrangement of glasses looks like,
		W N C W N C …………..
		Here the 3rd glass is C means it contains cold water.

		Hence, the answer for this case is "cold".
		Sample Input 2:
		2
		5 6 8 15
		9 3 3 12
		Sample Output 2:
		cold
		normal

		string waterGlass(long long x, long long y, long long z, long long n){
			// Write your code here.
			long long i,wrm, nrm, cld;
			vector<int> v;

			back:
			for(wrm=0; wrm<x; wrm++)
				v.push_back(1);

			for(nrm=0;nrm<y;nrm++)
				v.push_back(2);
			
			for(cld=0; cld<z;cld++)
				v.push_back(3);
			
			if(v.size() < n)
				goto back;


			// for(i=0;i<n;i++){
			// 	if(v[i] == )
			// }
			if(v[n-1] == 1){
				return "warm";
			}else if (v[n-1] == 2){
				return "normal";
			}else{
				return "cold";
			}
		}

	15) Toggle K bits:
		Sample Input 1:
			2
			21 3
			40 4
			Sample Output 1:
			18
			39
			Explanation For Sample Input 1:
			In example 1, the binary representation of 21 is '10101'. After toggling rightmost 3 bits, it becomes ‘10010’ which is equal to 18.
			In example 2, the binary representation of 40 is ‘101000’. After toggling rightmost 4 bits, it becomes ‘100111’ which is equal to 39.
			Sample Input 2:
			2 
			20 2
			85 5
			Sample Output 2:
			23
			74
			Explanation For Sample Input 2:
			In example 1, the binary representation of 20 is '10100'. After toggling rightmost 2 bits, it becomes ‘10111’ which is equal to 23.
			In example 2, the binary representation of 85 is ‘1010101’. After toggling rightmost 5 bits, it becomes ‘1001010’ which is equal to 74.

		#include <bits/stdc++.h> 
		using namespace std;
		int toggleKBits(int n, int k) {

			vector<int> v;
			for(int i=0;i<k;i++){
				int bit = n&1;
				n >>= 1;
				v.push_back(bit);
			}

			for(int i=0;i<v.size();i++)
				if(v[i] == 1){
					v[i] = 0;
				}else{
					v[i] = 1;
				}

			for(int i=0; i<k; i++){
				n <<= 1;
				n = n | v[v.size()-i-1];
			}
			return n;
		}

		//or
			#include <bits/stdc++.h>
				int toggleKBits(int n, int k) {
					return n^((1<<k)-1);
				}

	16) Unlucky Number:
		Num consist of 1 or 3 or 1 & 3 only. not other number;
			Sample Input 1
				1
				Sample Output 1
				1
				Sample Input 2
				2
				Sample Output 2
				3
				Sample Input 3
				5
				Sample Output 3
				31
			eg.
				1, 3, 11, 13, 31, 33, 111, 113, 131, 133, 311, 313, 331, 333.
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
			//Write your code here
			int n;
			cin>>n;

			vector<int> v;
			int IStore=0, checker;

				for(int j=1;j<2000000;j++){
					IStore = j;
					checker = j;
					while(checker>0){
						int temp = checker % 10;

						if(temp == 1 || temp ==3){
							checker /= 10;
							continue;
						}else{
							break;
						}
					}

					if(checker == 0)
						v.push_back(IStore);
				}
				cout<<v[n-1];
				return 0;
			} 

	17) Digit Count In Range:
		Sample Input 1:
			2
			3
			1 15
			2
			2 12
			Sample Output 1:
			2
			2
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [1, 13] = 2 (3, 13). Return 2


			In the second test case, 
			Number of occurrences of 2 in range [2, 12] = 2 (2, 12). Return 2
			Sample Input 2:
			2
			1 
			1 15
			3
			3 33
		
		Sample Output 2:
			8
			8
			Explanation Of Sample Input 1:
			In the first test case, 
			Number of occurrences of 1 in range [1, 15] = 8 (1, 10, 11, 12, 13, 14, 15). Return 8

			In the second test case, 
			Number of occurrences of 3 in range [3, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int digitCount(int K, long long int A, long long int B){
			long long int counter = 0,i,JStorer;
			while(A<=B){
				JStorer = A;
				while(JStorer>0){
					int temp = JStorer % 10;
					if(temp == K)
						counter++;
					JStorer/=10;
				}
				A++;
			}
			return counter;	
		}

	18) Minimum Difference Of Subarrays:
		int minimumDifference(int n, vector<int> arr){
			//Declaring totalSum to store the sum of all elements of arr.
			int totalSum = 0;
			for (int idx = 0; idx < n; idx++)
				totalSum += arr[idx];

			// currentSum stores the sum of first subarray.
			int currentSum = 0, minDiff = INT_MAX;

			for (int idx = 0; idx < n - 1; idx++){

				// updating the sum of the current subarray.
				currentSum += arr[idx];

				// Updating the mininmum difference.
				minDiff = min(minDiff, abs(currentSum - (totalSum - currentSum)));
			}
			return minDiff;
		}

	19) Ninja And The Triangle:
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
			int Istorer, sum=0, i;
			for(i=1; i<n; i++)
				if((sum+i) <= n){
					sum += i;
					Istorer = i;
				}
				else
					break;
			
			return Istorer;
		}
		//or
		#include <bits/stdc++.h> 
		int ninjaAndTriangle(int n) {
		    int k = (int)(sqrt(2*n));
			while(k*(k+1)/2 > n)
				k--;
			return k;
		}

		//or
			#include <bits/stdc++.h> 
			int ninjaAndTriangle(int n) {
				int d = 1 + 8 * n;
				int x = (1 + sqrt(d))/2;
				return x-1;
			}

	20) Amazing Strings
		Sample Input 1:
			2
			HI HEY EIHYH
			ALL GOOD ADOLLG
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined has 1 A, 2 L, 1 G, 2 O and 1 D. While the string ‘THIRD’ has 1 A, 2 L, 1 G, 1 O and 1 D and So, it has one character less than the combined ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.
			Sample Input 1:
			2
			CODING NINJA NINCODINGJA
			YES NO NEEOOYS
			Sample Output 1:
			YES
			NO
			Explanation For Sample Input 1:
			In the first test case, the string ‘THIRD’ has all the characters present in the strings ‘FIRST’ and ‘SECOND’. So, we will return “YES”.

			In the second test case, the strings ‘FIRST’ and ‘SECOND’ combined have 1 N, 1 Y, 1 E, 1 S and 1 O. While the string ‘THIRD’ has 1 N, 1 Y, 2 E, 1 S and 2 O and So, it has one character more than ‘FIRST’ and ‘SECOND’. Thus, we will return “NO”.

		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size(),i=0;

			if((firLen + secLen) != len)
				return "NO";

			while(i<firLen){
				char tempCh = first[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}
			i=0;
			while(i<secLen){
				char tempCh = second[i];
				int j=0;
				while(j <len){
					if(third[j] == tempCh){
						third[j] = '0';
						break;
					}
					j++;
				}
				if(j ==  len)
					return "NO";
				i++;
			}

			return "YES";
		}

		//or
		#include <algorithm>
		string amazingStrings(string first, string second,string third) {
			int len = third.size();
			int firLen = first.size();
			int secLen = second.size();
			int i=0;

			if((firLen + secLen) != len)
				return "NO";
			
			string full = first + second;
			sort(full.begin(), full.end());

			sort(third.begin(), third.end());
			
			if(full == third)
				return "YES";
			else
				return "NO";
		}

		//optimized:
			string amazingStrings(string first, string second,string third) {
				// Write your code here.
				if((first.length() + second.length()) == third.length())
					return "YES";
				else
					return "NO";
			}

	#Weekend Problem:
		21) Chocolate Removal Challenge:
			Explaination:
				You are given an array 'A' of size 'N'. Each element 'A[i]' represents the number of chocolates in the 'i-th' pile. 
				In a single move, you are allowed to perform the following operation: 
				If a pile contains more than 23 chocolates, you can take out all the chocolates leaving only 23 in the pile.

				Input: A = [25, 24, 29, 15]
				Output: 9

				First pile: Contains 25 chocolates, remove 2 to leave 23. Chocolates removed = 2.
				Second pile: Contains 24 chocolates, remove 1 to leave 23. Chocolates removed = 1.
				Third pile: Contains 29 chocolates, remove 6 to leave 23. Choclates removed = 6
				Fourth pile: Contains 15 chocolates, no chocolates removed as the pile already has less than or equal to 23 chocolates.
				Total chocolates removed = 2 + 1 + 6 = 9.

			Sample Input 1:
				2
				4
				25 24 10 15
				3
				30 20 40
				Sample Output 1 :
				3
				24
				Explanation For Sample Input 1:
				For test case 1:
				We remove 2 chocolates from the first pile and 1 from the second pile. Hence the total chocolates removed = 2 + 1 = 3.

				For test case 2:
				We remove 7 chocolates from the first pile, none from the second pile and 17 from the third pile. Hence the total chocolates removed = 7 + 17 = 24.
				Sample Input 2:
				2
				5
				100 200 300 400 500
				1
				23
				Sample Output 2 :
				1385
				0

			long long totalChocolates(int n, vector<int> a) {
				long long sum =0;
				for(int i=0;i<n;i++){
					if(a[i]> 23)
						sum += (a[i]-23);
				}
				return sum;
			}

		22) Odd Product:
			Ninja loves the odd numbers. He gives you an array 'A' of size 'N'. Help Ninja to find numbers of pairs '(L, R)' 
			such that products of array elements in the range 'L' to 'R' have an odd number of divisors.
			eg.
				'N' = 2
				'A' = [1, 4]

				There are total three possible pairs of '(L, R)':
				L = 1, R = 1, 'product = 1', divisors = [1]
				L = 1, R = 2, 'product = 1*4 = 4', divisors = [1, 2, 4]
				L = 2, R = 2 , 'product = 4', divisors = [1, 2 , 4]

				All three pairs have an odd number of divisors, so the answer is '3'.

			eg.
				Sample Input 1:
					2
					4
					1 2 4 2
					2
					1 2
					Sample Output 1:
					4
					1
					Explanation Of Sample Input 1:
					For test case 1:
					There are total '10' possible pairs of '(L, R)':

					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2', divisors = [1, 2]
					L = 1, R = 3, 'product = 1*2*4 = 8', divisors = [1, 2, 4, 8]
					L = 1, R = 4, 'product = 1*2*4*2 = 16', divisors = [1, 2, 4, 8, 16]
					L = 2, R = 2, 'product = 2', divisors = [1, 2]
					L = 2, R = 3, 'product = 2*4 = 8', divisors = [1, 2, 4, 8]
					L = 2, R = 4, 'product = 2*4*2 = 16', divisors = [1, 2, 4, 8]
					L = 3, R = 3, 'product = 4', divisors = [1, 2, 4]
					L = 3, R = 4, 'product = 4*2 = 8', divisors = [1, 2, 4, 8]
					L = 4, R = 4, 'product = 2', divisors = [1, 2]

					We can see that only '4' pairs have an odd number of divisors, so the answer is '4'.

					For test case 2:
					There are total three possible pairs of '(L, R)':
					L = 1, R = 1, 'product = 1', divisors = [1]
					L = 1, R = 2, 'product = 1*2 = 2', divisors = [1, 2]
					L = 2, R = 2 , 'product = 2', divisors = [1, 2]

					Only one pair has an odd number of divisors, so the answer is '1'.
					Sample Input 2:
					2
					4
					4 4 4 4
					5
					4 2 8 10 16
					Sample Output 2:
					10
					4
			
			long long oddProducts(int n, vector<int> &a){
				int counter=0;
				long long MainCounter=0;
				for(int b=0; b<n; b++){

					int prod=1,j;
					for(int c=b; c<n; c++){
						prod *= a[c];

						j=1;
						while(j<=prod){
							if(prod % j == 0)
								counter++;
							j++;
						}

						if(counter&1)
							MainCounter++;
						
						counter=0;
					}
				}
				return  MainCounter;
			}

	23) Strobogrammatic Number ll:
		-Given a length ‘N’, you need to find all the strobogrammatic numbers of length ‘N’.
		-A strobogrammatic number is a number that looks the same when rotated by 180.
		-In other words, a number that on rotating right side up and upside down appears the same is a strobogrammatic number.
		-‘986’ is a strobogrammatic number because on rotating ‘986’ by 180 degrees, ‘986’ will be obtained.
		-If N = 2, all the strobogrammatic numbers of length = 2 are “11”, “88”, “69”, “96”.
		-Sample Input 1:
			2
			3
			1
			Sample Output 1:
			101 111 181 609 619 689 808 818 888 906 916 986 
			0 1 8 
			Explanation For Sample Input 1:
			Test Case 1: All the possible Strobogrammatic numbers of length = 3 are “101”, “111”, “181”, “609”, “619”, “689”, “808”, “818”, “906”, “916”, “986”.

			Test Case 2: Strobogrammatic numbers of length = 1 are “0”, “1”, and “8”.
			Sample Input 2:
			2
			4
			2
			Sample Output 2:
			1001 1111 1691 1881 1961 6009 6119 6699 6889 6969 8008 8118 8698 8888 8968 9006 9116 9696 9886 9966 
			11 69 88 96 
			Explanation For Sample Input 2:
			Test Case 1: All the possible Strobogrammatic numbers of length = 4 are printed.

			Test Case 2: All the possible Strobogrammatic numbers of length = 2 are printed.

		//Not optimized:
			#include <bits/stdc++.h> 
			bool checker(string st){

				int temp = stoi(st);
				int rev = 0;
				while(temp>0){
					rev = (temp % 10) + rev * 10; 
					temp /=10;
				}

				string tempStr = to_string(rev);
				int index=0;
				while(tempStr[index] != '\0'){
					if(tempStr[index] == '6')
						tempStr[index] = '9';
					else if(tempStr[index] == '9')
						tempStr[index] = '6';
					index++;
				}

				if(st == tempStr)
					return true;
				return false;
			}

			vector<string> findStrobogrammatic(int n){
				vector<string> s;
				if(n == 1)
					return {"0","1","8"};
				
				if(n == 2)
					return {"11","69","88","96"};

				int Digit = 1;
				Digit = pow(10,n-1);

				for(int i = Digit; i<(Digit*10); i++){
					int temp = i;
					while(temp > 0){
						int singleBit = temp % 10;
						if(singleBit == 0 || singleBit == 1 || singleBit == 6 || singleBit == 8 || singleBit == 9)
							temp /=10;
						else
							break;
					}
					if(temp == 0)
						s.push_back(to_string(i));
				}

				vector<string> Upgraded;

				for(int i=0; i<s.size(); i++){
					string tempStr = s[i];
					
					if(checker(tempStr))
						Upgraded.push_back(tempStr);
				}
				return Upgraded;
			}

		//or
			#include <bits/stdc++.h> 
			vector<string> findStrobogrammatic(int n) {
				vector<string> ans;
				int start = pow(10,n-1);
				if(n == 1)
					start =0;
				int end = pow(10,n);
				for(int i=start; i<end; i++){
					string s = to_string(i);
					string temp = to_string(i);

					int f=0;
					for(int g=0; g<s.length(); g++)
						if(s[g] == '2' || s[g] == '3' || s[g] == '4' || s[g] == '5' || s[g] == '7'){
							f=1;
							break;
						}
					if(f)
						continue;
					
					reverse(s.begin(), s.end());
					for(int a=0; a<s.length(); a++)
						if(s[a] == '9')
							s[a] = '6';
						else if(s[a] == '6')
							s[a] = '9';
					
					if(temp == s)
						ans.push_back(s);
				}
				return ans;
			}

		//optimized:
			vector < string > findStrobogrammaticHelper(int n, int len) {
				// If len = 0, return empty string.
				if (len == 0) {
					return vector < string > ({ "" });
				}

				if(len == 1){
					return vector < string > ({"0", "1", "8" });
				}

				// Recursively call for len = len - 2.
				vector < string > prev = findStrobogrammaticHelper(n, len - 2);

				// Initialize vector of strings to store resulting strings.
				vector < string > res;

				// Iterate through all strings in "prev".
				for (int i = 0; i < prev.size(); i++) {

					// Add digits around string prev[i].
					if (len != n) {
						res.push_back("0" + prev[i] + "0");
					}

					res.push_back("1" + prev[i] + "1");
					res.push_back("6" + prev[i] + "9");
					res.push_back("8" + prev[i] + "8");
					res.push_back("9" + prev[i] + "6");
				}
				return res;
			}

			vector < string > findStrobogrammatic(int n) {
				// Recursive function to find all strobogrammatic numbers.
				vector < string > ans = findStrobogrammaticHelper(n, n);
				return ans;
			}

	24) Set Matrix Ones:
		Note:
			when you know the vector size like (vector<int> ans), then don't use push_back method to insert 
			element into it.
			directly use index to insert 
			like 
			at 3rd index you want to insert 4;
				ans[3] = 4;
		//basics to know:
			#include <iostream>
			#include<vector>
			using namespace std;

			int main(){
				//2d vector with 4; 10 rows 5 columns initialized with 4 (default value).
				vector<vector<int>> ans (10, vector<int> (5,4));
				
				for(int i=0;i<10; i++){
					for(int j=0;j<5; j++)
						cout<<ans[i][j]<<"\t";
					cout<<endl;
				}
				
				std::cout << "End" << std::endl;
				return 0;
			}

		//not optimized:	
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<vector<int>> ans(n, vector<int>(m,0));
				for(int i=0;i<n; i++){
					for(int j=0;j<m;j++){
						if(MAT[i][j] == 1){
							for(int b=0;b<m;b++)
								ans[i][b] =1;                
							for(int a =0;a<n;a++)
								ans[a][j] = 1;
						}
					}
				}
				MAT = ans;
			}

		//optimized:
			#include <bits/stdc++.h> 
			void setMatrixOnes(vector<vector<int>> &MAT, int n, int m){
				vector<pair<int, int>> ones;
				vector<bool> rowHasOne(n, false);
				vector<bool> colHasOne(m, false);

				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (MAT[i][j] == 1) {
							rowHasOne[i] = true;
							colHasOne[j] = true;
						}
				for (int i = 0; i < n; i++)
					for (int j = 0; j < m; j++)
						if (rowHasOne[i] || colHasOne[j]) 
							MAT[i][j] = 1;
			}

	25) Count Distinct Element in Every K Size Window
		you are given an array ‘ARR’ of size ‘N’ and an integer ‘K’. Your task is to find the total
		number of distinct elements present in every ‘K’ sized window of the array. A ‘K’ sized
		window can also be viewed as a series of continuous ‘K’ elements present in the
		sequence.
		Note:
			1. The size of ‘ARR’ will always be greater than or equal to the ‘K’.
			2. Here window refers to a subarray of ‘ARR’. Hence ‘K’ sized window means a subarray of size ‘K’.
			3. You are not required to print the output explicitly. It has already been taken care of. Just
			 implement the function and return an array of the count of all distinct elements in the ‘K’ size window.
		eg.
			consider ARR = [ 1, 2, 1, 3, 4, 2,3 ] and K = 3.

			As per the given input, we have a sequence of numbers of length 7, and we need to find the number of
			distinct elements present in all the windows of size 3.
			Window-1 has three elements { 1,2, 1 } and only two elements { 1,2 } are distinct because 1 is repeating two times.
			Window-2 has three elements { 2,1, 3 } and all three elements are distinct { 2, 1, 3 }.
			Window-3 has three elements { 1,3, 4 } and all three elements are distinct { 1, 3, 4 }.
			Window-4 has three elements { 3,4, 2 } and all three elements are distinct { 3, 4, 2 }.
			Window-5 has three elements { 4,2, 3 } and all three elements are

			Hence, the count of distinct elements in all K sized windows is { 2, 3, 3, 3, 3 }.
		eg.
			Sample Input 1:
				2
				7 4
				1 2 1 3 4 2 3
				5 3
				1 1 2 1 3
				Sample Output 1:
				3 4 4 3
				2 2 3
				Explanation Of Sample Input 1:
				Test Case 1:

				Window-1 has four elements { 1, 2, 1, 3 } and only three elements { 1, 2, 3 } are distinct because 1 is repeating two times.
				Window-2 has four elements { 2, 1, 3, 4 } and all four elements { 2, 1, 3, 4 } are distinct.
				Window-3 has four element { 1, 3, 4, 2 } and all four elements { 1, 3, 4, 2 } are distinct. 
				Window-4 has four element { 3, 4, 2, 3 } and only three elements { 3, 4, 2 } are distinct because 3 is repeating two times.

				Hence, the count of distinct elements in all windows is { 3, 4, 4, 3}.

				Test case 2: 

				Window-1 has three elements { 1, 1, 2 } and only two elements { 1, 2 } are distinct because 1 is repeating two times.
				Window-2 has three elements { 1, 2, 1 } and only two elements { 2, 1 } are distinct.
				Window-3 has three elements { 2, 1, 3 } and all three elements { 2, 1, 3 } are distinct.

				Hence, the count of distinct elements in all windows is { 2, 2, 3 }.
				Sample Input 2:
				2
				4 1
				2 3 1 2
				5 2
				2 2 3 2 1
				Sample Output 2:
				1 1 1 1
				1 2 2 2

		#include <bits/stdc++.h> 
		vector<int> countDistinctElements(vector<int> &arr, int k) {
			vector<int> DistinctCount;
			int len = arr.size();
			int Lind =k-1;
			int i=0,j;
			int windowHolder = k;
			while(Lind < len){
				set<int> temp;
				j = i;
				while(windowHolder){
					temp.insert(arr[j++]);
					windowHolder--;
				}
				i++;
				windowHolder = k;
				DistinctCount.push_back(temp.size());
				temp.clear();
				Lind += 1;
			}
			return DistinctCount;
		}

		//optimized:
			#include <bits/stdc++.h> 
			vector<int> countDistinctElements(vector<int> &arr, int k) {
				std::vector<int> distinctCount;
				int len = arr.size();
				
				if (k <= 0 || k > len) {
					return distinctCount;  // Handle invalid input.
				}
				
				std::unordered_map<int, int> elementCount;
				int distinct = 0;
				
				// Calculate distinct elements in the first window.
				for (int i = 0; i < k; ++i) {
					if (elementCount[arr[i]] == 0) {
						distinct++;
					}
					elementCount[arr[i]]++;
				}
				
				distinctCount.push_back(distinct);
				
				// Slide the window and update distinct count.
				for (int i = k; i < len; ++i) {
					int leftElement = arr[i - k];
					int rightElement = arr[i];
					
					// Remove the leftmost element from the window.
					if (elementCount[leftElement] == 1) {
						distinct--;
					}
					elementCount[leftElement]--;
					
					// Add the rightmost element to the window.
					if (elementCount[rightElement] == 0) {
						distinct++;
					}
					elementCount[rightElement]++;
					
					distinctCount.push_back(distinct);
				}
				return distinctCount;	
			}

	26) Tweaked Array:
		Sample Input 1 :
			2
			3
			1 4 1
			3
			5 2 -5
			Sample Output 1 :
			5 2 5
			-3 0 7
			Explanation Of Sample Input 1 :
			For test 1:
			TotalSum = 1 + 4 + 1 = 6
			Tweaked array = {6 - 1,  6 - 4,  6 - 1} = {5, 2, 5}

			For test 2:
			TotalSum = 5 + 2 + (-5) = 2
			Tweaked array = {2 - 5,  2 - 2,  2 - (-5)} = {-3, 0, 7}
			Sample Input 2 :
			2
			2
			1 2
			3
			-1 -2 -4
			Sample Output 2 :
			2 1
			-6 -5 - 3

		#include <bits/stdc++.h> 
		vector<int> tweakTheArray(vector<int> arr, int n){
			int sum=0;
			for(int i=0; i<arr.size(); i++){
				sum += arr[i];
			}

			for(int i=0;i<arr.size();i++)
				arr[i] = sum - arr[i];

			return arr;
		}

	27) Lucky String:
		You are given a string 'S' of length 'N' consisting of lowercase latin letters. If
		there is a letter occurring consecutively three times (at least three times), the
		string becomes unlucky for you. Your task is to erase some characters
		from the string such that it becomes lucky for you. A string which is not unlucky, is considered as lucky.
		Output the minimum number of removals (of characters) required to make the given
		string lucky.
		Sample Input 1 :
			2
			7
			abcccca
			5
			cbazz
			Sample Output 1 :
			2
			0
			Explanation For Sample Input 1 :
			For test case 1:
			If a substring "cc" is deleted from any position, the remaining string becomes lucky. Hence a minimum removal of 2 characters is required. 

			For test case 2:
			Given string is already lucky. No removal is required.
			Sample Input 2 :
			3
			5
			bbbbb
			2
			xy
			9
			abcccbaaa
			Sample Output 2 :
			3
			0
			2

		#include <bits/stdc++.h> 
		int makeLucky(string s, int n){
			int i=0,cnt=0;
			while(i<s.length()-1){
				if(s[i] == s[i+1])
					if(s[i+1] == s[i+2])
						cnt++;
				i++;
			}
			return cnt;
		}

	28) Minimize Bill:
		Sample Input 1 :
			2
			5
			-2 0 5 2 -1
			4
			5 8 7 9
			Sample Output 1 :
			-6
			11
			Explanation For Sample Input 1 :
			For test case 1:
			The optimal way is to make change at A[2]. Minimum sum of array (after change) becomes -2+0+(-5)+2-1 = -6.

			For test case 2:
			Make change at A[3]. Minimum sum becomes 5+8+7+(-9) = 11.
			Sample Input 2 :
			3
			4
			3 -1 0 2
			2
			0 -1
			5
			5 5 5 5 5
			Sample Output 2 :
			-2
			-1
			15

		#include <bits/stdc++.h> 
		long long totalBill(int n, vector<int>& a){
			int mxValInd=0;

			for(int i=0;i<a.size();i++)
				if(a[mxValInd] < a[i])
					mxValInd = i;
			
			a[mxValInd] = -1 * (a[mxValInd]);

			int sum=0;
			for(int i=0;i<a.size(); i++)
				sum += a[i];
			return sum;
		}

	29) Encode The String:
		Sample Input 1 :
			2
			3
			dog
			4
			cazz
			Sample Output 1 :
			cpf
			bbyy
			Explanation Of Sample Input 1 :
			For the first test case :

			Character ‘d’ gets changed to ‘c’.
			Character ‘o’ gets changed to ‘p’.
			Character ‘g’ gets changed to ‘f’.

			Encoded string = “cpf”.


			For the second test case :

			Character ‘c’ gets changed to ‘b’.
			Character ‘a’ gets changed to ‘b’.
			Character ‘z’ gets changed to ‘y’.
			Sample Input 2 :
			2
			4
			gjmf
			3
			abc
			Sample Output 2 :
			file
			bab

		#include <bits/stdc++.h> 
		string encodeString(string &s, int n) {
			for(int i=0;i<s.length();i++){
				if(s[i] == 'a'){
					s[i] = 'b';
				}else if(s[i] == 'e'){
					s[i] = 'f';
				}else if(s[i] == 'i'){
					s[i] = 'j';
				}else if(s[i] == 'o'){
					s[i] = 'p';
				}else if(s[i] == 'u'){
					s[i] = 'v';
				}else{
					s[i] = s[i] - 1;
				}     
			}
			return s;
		}

	30) Next Greater Element:
		Problem Statement
			You are given an array 'a' of size 'n'
			Print the Next Greater Element(NGE) for every element.
			The Next Greater Element for an element 'x' is the first element on the right side of 'x' in the array, which is
			greater than 'x'.
			If no greater elements exist to the right of 'x', consider the next greater element as - 1.
			For Example:
			Input: 'a' • [7, 12, 1, 20]
			Output: NGE = [12, 20, 20, -1]
			Explanation: For the given array,
			- The next greater element for 7 is 12.
			- The next greater element for 12 is 20.
			- The next greater element for 1 is 20.
			- There is no greater element for 20 on the right side. So we consider NGE as
		
			Sample Input 1:
				5
				1 5 3 4 2


				Sample Output 1:
				5 -1 4 -1 -1


				Sample Input 2:
				5
				5 5 5 5 5


				Sample Output 2:
				-1 -1 -1 -1 -1


				Expected Time Complexity :
				The expected time complexity is O(n).


				Constraints :
				1 <= 'n' <= 10^5
				1 <= 'a[i]' <= 10^9

				Time Limit: 1 sec

		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			for(int i=0;i<n;i++){
				if(i == (n-1)){
					arr[i] = -1;
					return arr;
				}
				int j=i+1;
				for(j; j<n;j++){
					if(arr[i] < arr[j]){
						arr[i] = arr[j];
						break;
					}
				}
				if(j==n)
					arr[i] = -1;
			}
		}
		
		//optimized
		#include <bits/stdc++.h> 
		vector<int> nextGreater(vector<int> &arr, int n) {
			vector<int> res(n, -1);
			stack<int> st;

			for(int i=0;i<n;i++){
				while(!st.empty() && arr[i] > arr[st.top()]){
					res[st.top()] = arr[i];
					st.pop();
				}
				st.push(i);
			}
			return res;
		}

	31) Implement Deque:
		-https://www.codingninjas.com/studio/problems/deque_1170059
		#include <bits/stdc++.h>
		#include<queue>
		using namespace std;
		class Deque
		{
			public:
				// Initialize your data structure.
				int size;
				deque<int> d;
				Deque(int n){
					// Write your code here.
					size = n;
				}

				// Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushFront(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_front(x);
						return true;
					}
					return false;
				}

				// Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
				bool pushRear(int x){
					// Write your code here.
					if(d.size() < size){
						d.push_back(x);
						return true;
					}
					return false;
				}

				// Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popFront(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.front();
						d.pop_front();
						return temp;
					}
					return -1;
				}

				// Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
				int popRear(){
					// Write your code here.
					if(!d.empty()){
						int temp = d.back();
						d.pop_back();
						return temp;
					}
					return -1;
				}

				// Returns the first element of the deque. If the deque is empty, it returns -1.
				int getFront(){
					// Write your code here.
					if(!d.empty()){
						return d.front();
					}
					return -1;
				}

				// Returns the last element of the deque. If the deque is empty, it returns -1.
				int getRear(){
					// Write your code here.
					if(!d.empty()){
						return d.back();
					}
					return -1;
				}

				// Returns true if the deque is empty. Otherwise returns false.
				bool isEmpty(){
					// Write your code here.
					if(d.empty())
						return true;
					
					return false;
				}

				// Returns true if the deque is full. Otherwise returns false.
				bool isFull(){
					// Write your code here.
					if(d.size() == size)
						return true;
					return false;
				}
		};
	
	32) Direction Game:
		Ninja is currently facing North. An instructor gives him 'N' instructions in the
		form of a binary string 'S'. If 'S[ i ]' is '0', then Ninja will turn clockwise by ‘90’
		degrees. Otherwise, Ninja will turn counterclockwise by ‘90’ degrees.
		Ninja is lazy and doesn't feel like doing all 'N' instructions. So, he decides to just face
		the final direction. Find the final direction of Ninja, which will be one of the
		following: 'NORTH', 'SOUTH', 'EAST', or 'WEST
		Sample Input 1:
			2
			4
			1111
			4
			1101
			Sample Output 1:
			NORTH
			SOUTH
			Explanation Of Sample Input 1:
			For test case 1:
			Ninja’s direction will change in the following order:
			North → West → South  → East → Noth
			So, the answer is 'NORTH'.

			For test case 2:
			Ninja’s direction will change in the following order:
			North → West → South → West → South
			So, the answer is 'SOUTH'.
			Sample Input 2:
			2
			8
			10011101
			7
			0101011
			Sample Output 2:
			SOUTH
			WEST

		string directionGame(int n, string &s){
			vector<string> dire = {"NORTH","WEST","SOUTH","EAST"};
			int index=0;
			for(int i=0;i<n;i++){
				if(s[i] == '1')
					index = (index+1)%4;
				else
					index = (index+3)%4;
			}
			return dire[index];
		}

	33) Apple Harvest:
		Sample Input 1:
			2
			20 15 5
			7 4 6
			Sample Output 1 :
			25
			18
			Explanation For Sample Input 1:
			For test case 1:
			The tree produces 20 apples daily. The basket can hold up to 15 apples. So, every day 5 apples are wasted. Over 5 days, 25 apples are wasted.

			For test case 2:
			The tree produces 7 apples daily. The basket can hold up to 4 apples. So, every day 3 apples are wasted. Over 6 days, 18 apples are wasted.
			Sample Input 2:
			2
			50 25 10
			12 5 7
			Sample Output 2 :
			250
			49

		long long wastedApples(int n, int m, int x) {
			return static_cast<long long>(max(0,(n-m)))*x;
		}

	34) Ninja wants Holiday:
		Ninja is a corporate employee, and like
			other corporate employees, he also wants
			to visit his home on long holidays. He
			wants to spend at least 'K' consecutive
			days at his home.
			You are given an array 'A' of length 'N'
			denoting the list of holidays. Ninja can
			only take leave on holidays.
			You have to find if it's possible for Ninja to
			spend at least 'K' consecutive days at his
			home.
			Example:
			'N' = 4
			'K' = 3
			'A' = [1, 3, 4, 5]
			Ninja can take leave on '1',
			'3', '4', and '5'. Therefore,
			he can take leave consecutively
			for at most 3 days, which are
			from '3' to '5'.
			Thus, minimum requirement of 'K= 3' is satisfied in this case. Hence, the final output will be 'YES'.

		Sample Input 1:
			2
			5 3
			1 3 7 5 8
			4 2
			2 4 8 3
			Sample Output 1:
			NO
			YES
			Explanation Of Sample Input 1:
			For test case 1:
			Holidays cannot be taken for three days in a row.
			Hence, the answer for this case is "NO".

			For test case 2:
			Ninja can take holidays on days '2' and '3', thus satisfying requirement of holiday on two consecutive days.
			Hence, the answer for this case is "YES".
			Sample Input 2:
			2
			5 3
			2 3 5 8 7
			4 2
			4 5 2 3
			Sample Output 2:
			NO
			YES


		#include <iostream>
		#include<vector>
		#include<algorithm>
		using namespace std;

		string ninjaWantsHoliday(int n, int k, vector<int> &a) {
			sort(a.begin(), a.end());
			int cnt=1;
			for(int i=0;i<n; i++){      //1 4 5 8 10
				if(a[i]+1 == a[i+1]){
					cnt++;
					if(cnt == k)
						return "YES";
				}else{
					cnt=1;
					continue;
				}
			}
			return "NO";
		}
		int main(){
			int n=5, k=2;

			vector<int>a {5, 10, 1 ,8, 4};
			string s = ninjaWantsHoliday(n,k,a);
			std::cout << s << std::endl;
			return 0;
		}

	35) Vaccination Drive:
			The Indian government recently launched the world's largest vaccination drive for
			COVID-19. Dr Ritesh has been appointed as a nodal officer for vaccinating a
			locality. There are ‘N’ houses numbers from 1 to ‘N’ in that locality. Dr Ritesh will
			visit each house one by one and vaccinate all the people in the house. He
			has already covered ‘K’ number of houses. Since ‘N’ is a very large number,
			‘L’ bits are required to represent the number. You are supposed to help Dr
			Ritesh and find the maximum possible number of houses that are yet to be
			covered under the vaccination drive
			(Hint 2's power)
		Sample Input 1 :
			2
			3 5
			5 3
			Sample output 1 :
			29
			3
			Explanation of Sample output 1 :
			For the first test case, since the number of bits required is 5, the maximum possible value for ‘N’ is 32. So the maximum possible number of remaining houses are 32 - 3 = 29.

			For the second test case, since the number of bits required is 3, the maximum possible value for ‘N’ is 8. So the maximum possible number of remaining houses are 8 - 3 = 5.
			Sample Input 2 :
			2
			1 1
			2 3
			Sample output 2 :
			1
			6
		#include <bits/stdc++.h> 
		int getMaximumHouses(int k, int l){
			return (pow(2,l))-k;
		}

	36) Factorial of Larger nums:
		void multiply(vector<int> &result, int x) {
			int carry = 0;
			for (int i = 0; i < result.size(); i++) {
				int product = result[i] * x + carry;
				result[i] = product % 10;
				carry = product / 10;
			}
			
			while (carry) {
				result.push_back(carry % 10);
				carry /= 10;
			}
		}

		void factorial(int n){
			vector<int> result;
			result.push_back(1); // Initialize the result as 1
			
			for (int i = 2; i <= n; i++) {
				multiply(result, i);
			}
			
			// Print the result in reverse order
			for (int i = result.size() - 1; i >= 0; i--) {
				cout << result[i];
			}
			cout << endl;   
		}

	37) Print all Divisors of a number
		Given an integer 'N', return all the divisors of 'N' in ascending order.
		For Example:
		'N' = 5.
		The divisors of 5 are 1, 5.
		Sample Input 1 :
			10
			Sample Output 1 :
			1 2 5 10
			Explanation Of Sample Input 1:
			The divisors of 10 are 1,2,5,10.
			Sample Input 1 :
			6
			Sample Output 1 :
			1 2 3 6

		vector<int> printDivisors(int n) {
			vector<int> ans;
			for(int i=1;i<=n/2;i++)
				if(n % i == 0)
					ans.push_back(i);

			ans.push_back(n);
			return ans;
		}
	
	38) Rotate array
		Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative
		'arr '= [1,2,3,4,5]
			'k' = 1 rotated array = [2,3,4,5,1] 
			'k' = 2 rotated array = [3,4,5,1,2]
			'k' = 3 rotated array = [4,5,1,2,3] and so on.

		Sample Input 1:
			8
			7 5 2 11 2 43 1 1
			2
			Sample Output 1:
			2 11 2 43 1 1 7 5
			Explanation Of Sample Input 1:
			Rotate 1 steps to the left: 5 2 11 2 43 1 1 7
			Rotate 2 steps to the left: 2 11 2 43 1 1 7 5
			Sample Input 2:
			4
			5 6 7 8
			3
			Sample Output 2:
			8 5 6 7
			Explanation Of Sample Input 2:
			Rotate 1 steps to the left: 6 7 8 5
			Rotate 2 steps to the left: 7 8 5 6
			Rotate 2 steps to the left: 8 5 6 7

		vector<int> rotateArray(vector<int>arr, int k) {
			vector<int> ans;
			for(int i=k;i<arr.size();i++)
				ans.push_back(arr[i]);
			
			for(int i=0;i<k;i++)
				ans.push_back(arr[i]);
			
			return ans;
		}

	39) Generate Binary Numbers:
		Sample Input 1:
			2
			2
			6
			Sample Output 1:
			1 10
			1 10 11 100 101 110
			Explanation 1:
			For the first test case when N = 2. 
			We need all the binary numbers from 1 to 2:
			1 -> 1
			2 -> 10
			Thus, the output is 1, 10.

			For the second test case when N = 6
			We need all the binary numbers from 1 to 6:
			1 -> 1
			2 -> 10
			3 -> 11
			4 -> 100
			5 -> 101
			6 -> 110
			Thus, the output is 1, 10, 11, 100, 101, 110.
			Sample Input 2:
			2
			8
			4
			Sample Output 2:
			1 10 11 100 101 110 111 1000
			1 10 11 100

		#include <bits/stdc++.h>
		string binConvert(int); 
		vector<string> generateBinaryNumbers(int n){
			vector<string> ans;
			for(int i=1;i<=n;i++){
				string s = binConvert(i);
				ans.push_back(s);
			}
			return ans;
		}

		string binConvert(int n){
			string temp;
			while(n>0){
				int t = n % 2;
				temp += to_string(t);
				n/=2;
			}
			reverse(temp.begin(), temp.end());
			return temp;
		}

	40) Sum Of Zeroes
		#include <bits/stdc++.h> 
		int coverageOfMatrix(vector<vector<int>> &matrix) {
		int rows = matrix.size();
		int cols = matrix[0].size();
		int coverage = 0;

		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				if (matrix[i][j] == 0) {
					int adjacent = 0;

					// Check top neighbor
					if (i > 0 && matrix[i - 1][j] == 1) {
						adjacent += 1;
					}

					// Check bottom neighbor
					if (i < rows - 1 && matrix[i + 1][j] == 1) {
						adjacent += 1;
					}

					// Check left neighbor
					if (j > 0 && matrix[i][j - 1] == 1) {
						adjacent += 1;
					}

					// Check right neighbor
					if (j < cols - 1 && matrix[i][j + 1] == 1) {
						adjacent += 1;
					}

					coverage += adjacent;
				}
			}
		}
		return coverage;
		}

	41) Add One To Number
		Sample Input 1
			3
			3
			1 2 3
			2
			9 9
			1
			4
			Sample Output 1
			1 2 4
			1 0 0
			5
			Explanation For Sample Input 1
			In the 1st test case, the number is 123 after adding 1 number becomes 124, hence the output will be {1,2,4}.

			In the 2nd test case, the number is 99 after adding 1 number becomes 100, hence the output will be {1,0,0}.

			In the 3rd test case, the number is 4 after adding 1 number becomes 5, hence the output will be {5}.
			Sample Input 2
			3
			4
			2 4 6 8 
			1
			0
			2
			0 2
			Sample Output 2
			2 4 6 9
			1
			3

		#include <bits/stdc++.h> 
		vector<int> addOneToNumber(vector<int> arr){
			int n = arr.size();
			
			// Add 1 to the least significant digit (rightmost)
			arr[n - 1] += 1;
			
			// Handle carry
			int carry = 0;
			for (int i = n - 1; i >= 0; i--) {
				int sum = arr[i] + carry;
				arr[i] = sum % 10;  // Update the current digit
				carry = sum / 10;   // Calculate the carry for the next digit
			}
			
			// If there is still a carry after processing all digits, insert it at the beginning
			if (carry > 0) {
				arr.insert(arr.begin(), carry);
			}
			//removing leadig zeros
			while(!arr.empty() && arr[0]==0){
				arr.erase(arr.begin());
			}
			return arr;
		}

		//optimized:
			#include <bits/stdc++.h> 
			vector<int> addOneToNumber(vector<int> arr){
				int n= arr.size();
				arr[n-1] += 1;

				int carry=0;
				for(int i= n-1; i>=0; i--){
					arr[i] += carry;
					carry = arr[i] / 10;
					if(!carry)					//if(carry == 0)
						break;					//	break;
					arr[i] = arr[i] % 10;  // Update the current digit
				}

				if(carry>0)
				arr.insert(arr.begin(), carry);

				
				// //removing leading 0 zeros
				while(!arr.empty() && arr[0] == 0)
					arr.erase(arr.begin());

				return arr;
			}
		
		//or
			#include <bits/stdc++.h> 

				// long long ConvertToNum(vector<int> a){
				//     long long num=0;
				//     for(int i=0;i<a.size();i++){
				//         num = num * 10 + a[i];
				//     }
				//     return num+1;
				// }

			vector<int> addOneToNumber(vector<int> arr){
				// long long n = ConvertToNum(arr);
				// vector<int> ans;
				// string s = to_string(n);
				
				// for(int i=0;i<s.length();i++)
				//     ans.push_back(s[i]-48);
				
				// return ans;

				for(int i=arr.size()-1; i>=0; i--){
					if(i == arr.size()-1)
						arr[i] = arr[i]+1;
					if(arr[i]>9 && i>0){
						int l = arr[i] % 10;
						int s = arr[i] /10;
						arr[i] = l;
						arr[i-1] = arr[i-1] + (s);
					}
				}

				if(arr[0]> 9){
					int n = arr[0] % 10;
					int s = arr[0] / 10;
					arr[0] = n;
					arr.insert(arr.begin(),s);
				}

				//to remove trailing zeros
				int i=0;
				while(arr[i] == 0){
					arr.erase(arr.begin());
				}

				return arr;
			}

	42) Find (indexes) All Anagrams in a String:
		Sample Input 1 :
			2
			10 3
			CBAEBABACD
			ABC
			5 2
			ABADE
			BA
			Sample Output 1 :
			0 6
			0 1
			Explanation For Sample Output 1:
			Test Case 1:

			'STR' is ‘CBAEBABACD’ and ‘PTR’ is ‘ABC’.

			0-2 in 'STR' index 0,1,2 are ‘CBA’, and it is an anagram with ‘ABC’.
			1-3 in 'STR' index 1,2,3 are ‘BAE’, and it is not anagram with ‘ABC’.
			2-4 in 'STR' index 2,3,4 are ‘AEB’, and it is not anagram with ‘ABC’.
			3-5 in 'STR' index 3,4,5 are ‘EBA’, and it is not anagram with ‘ABC’.
			4-6 in 'STR' index 4,5,6 are ‘BAB’, and it is not anagram with ‘ABC’.
			5-7 in 'STR' index 5,6,7 are ‘ABA’, and it is not anagram with ‘ABC’.
			6-8 in 'STR' index 6,7,8 are ‘BAC’, and it is an anagram with ‘ABC’.
			7-9 in 'STR' index 7,8,9 are ‘ACD’, and it is not anagram with ‘ABC’.

			Hence, there are only two substrings in the given string 'STR'  that are anagram with given string  ‘PTR’ which are ‘CBA’, and ‘BAC’ and starting indices of respective anagram substrings are 0 and 6.


			Test case 2:

			'STR' is ‘ABADE’ and ‘PTR’ is ‘BA’.

			In the given string ‘ABADE’ the substring of length 2 starting with index 0 is ‘AB’ which is an anagram with the string ‘BA’ and a substring of length 2 starting with index 1 is ‘BA’ which is also an anagram with the string ‘BA’. Because 0 and 1 are starting indices of the substrings, we print 0 and 1.
			Sample Input 2:
			2
			10 4
			BACDGABCDA
			ABCD
			7 1
			ABABABA
			A
			Sample Output 2:
			0 5 6
			0 2 4 6

		#include <bits/stdc++.h>
		vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
			vector<int> ans;
			unordered_map<char, int> charCountPtr, charCountWindow;

			// Initialize the character counts for ptr
			for (char c : ptr) {
				charCountPtr[c]++;
			}

			for (int i = 0; i < n; i++) {
				// Expand the window
				charCountWindow[str[i]]++;

				// Shrink the window if it's larger than m characters
				if (i >= m) {
					char leftChar = str[i - m];
					if (charCountWindow[leftChar] > 1) {
						charCountWindow[leftChar]--;
					} else {
						charCountWindow.erase(leftChar);
					}
				}

				// Check if the current window is an anagram of ptr
				if (i >= m - 1 && charCountWindow == charCountPtr) {
					ans.push_back(i - m + 1);
				}
			}
			return ans;
		}

	43) Armstrong Number
		You are given an integer ‘NUM’ . Your task
		is to find out whether this number is an
		Armstrong number or not.
		A k-digit number ‘NUM’ is an Armstrong
		number if and only if the k-th power of
		each digit sums to ‘NUM
		eg.
			153 = 1^3 + 5^3 + 3^3.
			Therefore 153 is an Armstrong number
		Sample Input 1:
			1
			13
			Sample Output 1:
			NO
			Explanation For Sample Input 1:
			As 1^2 + 3^2 = 10 which is not equal to 13.So we can say it is not an Armstrong number.
			Sample Input 2:
			1
			371
			Sample Output 2:
			YES

		#include <bits/stdc++.h> 
		bool isArmstrong(int num) {
			string s = to_string(num);
			int len = s.length();
			int sum=0;
			int temp = num;
			while(num){
				sum += pow(num%10, len);
				num /=10;
			}
			if(temp == sum)
				return true;
			return false;
		}

	44) Power of 2:
		Given a non-negative integer N. The task is to check if N is a power of 2. 
			More formally, check if N can be expressed as 2x for some integer x.
			Example 1:

			Input: 
			N = 8
			Output: 
			YES
			Explanation:
			8 is equal to 2 raised to 3 (23 = 8).
			Example 2:

			Input: 
			N = 98
			Output: 
			NO
			Explanation: 
			98 cannot be obtained by any power of 2.
			Your Task:Your task is to complete the function isPowerofTwo() which takes n as a parameter and returns true or false by checking if the given number can be represented as a power of two or not.

			Expected Time Complexity:O(log N).
			Expected Auxiliary Space:O(1).

			Constraints:
			0 ≤ N ≤1018
		class Solution{
			public:
			// Function to check if given number n is a power of two.
			bool isPowerofTwo(long long n){
				long long i;
				for(i=0; i<=n/2, pow(2,i)<=n; i++){       //n = 1001, loop will go to till 500 if pow(2,i) <=n condition was not there,
					if(pow(2,i) == n)
						return true;
				}
				return false;
			}
		};

	44) Find position of set bit
		Given a number N having only one ‘1’ and all other ’0’s in its binary representation, 
			find position of the only set bit. If there are 0 or more than 1 set bit the answer should be -1. 
			Position of  set bit '1' should be counted starting with 1 from LSB side in binary representation of the number.
				Example 1:

				Input:
				N = 2
				Output:
				2
				Explanation:
				2 is represented as "10" in Binary.
				As we see there's only one set bit
				and it's in Position 2 and thus the
				Output 2.
				Example 2:

				Input:
				N = 5
				Output:
				-1
				Explanation:
				5 is represented as "101" in Binary.
				As we see there's two set bits
				and thus the Output -1.
				Your Task:
				You don't need to read input or print anything. Your task is to complete the function findPosition() which takes an integer N as input and returns the answer.

				Expected Time Complexity: O(log(N))
				Expected Auxiliary Space: O(1)

				Constraints:
				0 <= N <= 108
		class Solution {
			public:
			int findPosition(int N) {
				if(N==0)
					return -1;
				
				int cnt=0,pos=0;
				while(N){
					pos++;
					if(N&1)
						cnt++;

					if(cnt>1)
						return -1;
					N>>=1;
				}
				return pos;
			}
		};

	45) Check set bits:
		Given a number N. You have to check whether every bit in 
		 the binary representation of the given number is set or not.
			Example 1:
				Input:
				N = 7
				Output:
				1
				Explanation:
				Binary for 7 is 111 all the
				bits are set so output is 1
			Example 2:
				Input:
				N = 8
				Output:
				0
				Explanation:
				Binary for 8 is 1000 all the
				bits are not set so output is 0.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function isBitSet() 
				which takes an integer N as input parameters and returns 1 if 
				all the bits in N's binary representation is set or return 0 otherwise.

			Expected Time Complexity: O(1)
			Expected Space Complexity: O(1)

			Constraints:
				0<=N<=100000
		class Solution{
			public:
			int isBitSet(int N){
				if(N==0)
					return 0;
				
				while(N){
					if(!(N&1)){
						return 0;
					}
					N>>=1;
				}
				return 1;
			}
		};

	46) Admission in Ninja Gram
		Sample Input 1:
			2

			12
			toosmallword
			35
			TheQuickBrownFoxJumpsOverTheLazyDog
			
			Sample Output 1:
			NO
			YES
			Explanation For Sample Input 1:
			In the first test case, the given string is “toosmallword” which contains 
			the characters [‘t’,’o’,’s’,’m’,’a’,’l’,’w’,’r’,’d’], which doesn’t contain 
			all the 26 alphabetic characters. Hence the answer is “NO”.

			In the second test case, the given string is “TheQuickBrownFoxJumpsOverTheLazyDog” 
			which contains the characters: [‘t’,’h’,’e’,’q’,’u’,’i’,’c’,’k’,’b’,’r’,’o’,’w’,’n’,’f’,’x’,’j’,’m’,’p,’’s’,’v’,’l,’a’,’z’,’y’,’ d’,’g’], 
			which contains all the 26 alphabetic characters. Hence the answer is “YES”.
		Sample Input 2:

			2
			16
			CodingNinjas
			10
			CodeStudio
			Sample Output 2:
			NO
			NO
			Explanation For Sample Input 2:
			In the first test case, the given string is “CodingNinjas” which contains the characters 
			[‘c’,’o’,’d’,’i’,’n’,’g’,’i’,’j’,’a’,’s’], which doesn’t contain all the 26 
			alphabetic characters. Hence the answer is “NO”.


			In the first test case, the given string is “CodeStudio” which contains the characters 
			[‘c’,’o’,’d’,’e’,’s’,’t’,’u’,’i’], which doesn’t contain all the 26 alphabetic characters. 
			Hence the answer is “NO”.

		#include <bits/stdc++.h> 
		bool ninjaGram(string &str){
			//to convert string to lower-case,
			transform(str.begin(),str.end(), str.begin(), ::tolower);
			
			char ch = 'a';
			int i=0;
			while(i<str.length()){
				if(str[i] == ch){
					ch++;
					i=0;
				}
				i++;
			}
			if(ch > 'z')
				return 1;
			return 0;
		}
		
		//or
		#include <bits/stdc++.h> 
		bool ninjaGram(string &str) {
			//convert all letter of string into lowercase
			transform(str.begin(), str.end(), str.begin(), ::tolower);
			char ch = 'a';
			int i;
			for(i=0; i<str.length(); i++){
				if (ch == str[i]) {
				ch++;
				i = 0;
				}
			}
			if (ch > 'z')
				return 1;
			return 0;
		}

		//or
		#include <bits/stdc++.h> 
		bool ninjaGram(string &str){
			
			string lowerStr = "";
			for (int i  = 0; i < str.length(); i++){
				lowerStr += tolower(str[i]);
			}
			
			int count[26]  = {0};
			
			for (int i  = 0 ; i < lowerStr.length(); i++){
				count[lowerStr[i] - 'a']++;
			}
			for (int i = 0 ; i < 26; i++){
				if(count[i] == 0){
					return false;
				}
			}
			return true;
		}

	47) Find All Anagrams in a String
		https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
		Given two strings s and p, return an array of all the start 
		 indices of p's anagrams in s. You may return the answer in any order.

			An Anagram is a word or phrase formed by rearranging the letters of 
			a different word or phrase, typically using all the original letters exactly once.
			Example 1:
				Input: s = "cbaebabacd", p = "abc"
				Output: [0,6]
				Explanation:
				The substring with start index = 0 is "cba", which is an anagram of "abc".
				The substring with start index = 6 is "bac", which is an anagram of "abc".
			Example 2:
				Input: s = "abab", p = "ab"
				Output: [0,1,2]
				Explanation:
				The substring with start index = 0 is "ab", which is an anagram of "ab".
				The substring with start index = 1 is "ba", which is an anagram of "ab".
				The substring with start index = 2 is "ab", which is an anagram of "ab".
			
			Constraints:
				1 <= s.length, p.length <= 3 * 104
				s and p consist of lowercase English letters.
		class Solution {
			public:
			bool areTheyEqual(int a1[26], int a2[26]){
				for(int i=0;i<26;i++){
					if(a1[i] != a2[i])
						return 0;
				}
				return 1;
			}

			vector<int> findAnagrams(string s, string p) {
				vector<int> ans;

				int count1[26]={0}, count2[26]={0}, i=0;
				//count1 array is for s
				//count2 array is for p

				//mapping for p string
				while(i<p.length()){
					// int ind = p[i]-'a';
					count2[p[i]-'a']++;
					i++;
				}

				//mapping for s string
				i=0;
				while(i<p.length() && i< s.length()){
					// int ind = s[i] - 'a';
					count1[s[i] - 'a']++;
					i++;
				}

				if(areTheyEqual(count1,count2))
					ans.push_back(i-p.length());

				while(i<s.length()){
					// int ind = s[i] - 'a';
					count1[s[i] - 'a']++;
					count1[s[i-p.length()]-'a']--;

					i++;
					if(areTheyEqual(count1,count2))
						ans.push_back(i-p.length());
				}
				return ans;
			}
		};

		//own solution found char array used here
			class Solution {
				public:
				bool areSame(char a[], char b[]){
					for(int i=0;i<26;i++)
						if(a[i] != b[i])
							return 0;
					return 1;
				}
				vector<int> findAnagrams(string s, string p) {
					vector<int> ans;
					if(s.size()<p.size())
						return ans;
					//mapping p's letters
					char forP[26] ={0};
					for(int i=0;i<p.length();i++){
						forP[p[i] - 'a']++;
					}

					int i=0;
					while(i<=s.length()-p.length()){
						string temp = s.substr(i,p.length());
						//mapping here for temp
						char forS[26] = {0};
						for(int l=0; l<temp.length(); l++)
							forS[temp[l]-'a']++;

						if(areSame(forS,forP))
							ans.push_back(i);
						i++;
					}
					return ans;
				}
			};

		//vector used here.
			class Solution {
				public:
				bool areSame(vector<char> a, vector<char> b){
					for(int i=0;i<a.size();i++)
						if(a[i] != b[i])
							return 0;
					return 1;
				}
				vector<int> findAnagrams(string s, string p) {
					vector<int> ans;
					if(s.size()<p.size())
						return ans;
					//mapping p's letters
					vector<char> forP(26,0);
					for(int i=0;i<p.length();i++){
						forP[p[i] - 'a']++;
					}

					int i=0;
					while(i<=s.length()-p.length()){
						string temp = s.substr(i,p.length());
						//mapping here for temp
						vector<char> forS(26,0);
						for(int l=0; l<temp.length(); l++)
							forS[temp[l]-'a']++;

						if(areSame(forS,forP))
							ans.push_back(i);
						i++;
					}
					return ans;
				}
			};

	48) Find first set bit
		Given an integer N. The task is to return the position of first set bit 
			found from the right side in the binary representation of the number.
			Note: If there is no set bit in the integer N, then return 0 from the function.  

			Example 1:
				Input: 
				N = 18
				Output: 
				2
				Explanation: 
				Binary representation of 18 is 010010,the first set bit from the right side is at position 2.
			Example 2:
				Input: 
				N = 12 
				Output: 
				3 
				Explanation: 
				Binary representation of  12 is 1100, the first set bit from the right side is at position 3.
			Your Task:
				The task is to complete the function getFirstSetBit() that 
				takes an integer n as a parameter and returns the position of first set bit.

			Expected Time Complexity: O(log N).
			Expected Auxiliary Space: O(1).

			Constraints:
				0 <= N <= 108
		class Solution{
			public:
			//Function to find position of first set bit in the given number.
			unsigned int getFirstSetBit(int n){
				int cnt=0;
				if(n==0)
					return cnt;
				while(n){
					cnt++;
					if(n&1){
						break;
					}
					n>>=1;
				}
				return cnt;
			}
		};

	49) Duplicate In Array
		Sample Input 1:
			2
			5
			4 2 1 3 1
			7
			6 3 1 5 4 3 2
			Sample Output 1:
			1
			3
			Explanation Of Sample Input 1:
			For the first test case, 
			The duplicate integer value present in the array is 1. Hence, the answer is 1 in this case.

			For the second test case,
			The duplicate integer value present in the array is 3. Hence, the answer is 3 in this case.
			Sample Input 2:
			2
			6 
			5 1 2 3 4 2  
			9
			8 7 2 5 4 7 1 3 6
			Sample Output 2:
			2
			7
		
		#include <bits/stdc++.h>
		int findDuplicate(vector<int> &arr) {
			// for (int i = 0; i < arr.size(); i++)
			//     for (int j = i + 1; j < arr.size(); j++)
			//         if (arr[i] == arr[j])
			//             return arr[i];

			unordered_set<int> seen;

			for(int i:arr){
				if(seen.find(i) != seen.end())
					return i;
				seen.insert(i);
			}
		}

	50) Different Bits Sum Pairwise:
			Sample Input 1 :
				2
				2
				1 2
				2
				6 6
				Sample Output 1 :
				4
				0
				Explanation For Sample Input 1 :
				Test Case 1:
				All the possible pairs in the given array are:-
				f(1, 1) - as both numbers are same, no. of bit differences is 0
				f(1, 2) - 1 in binary is (0001) and 2 in binary is (0010). There are 2 bits which are different in both the numbers. Hence, no. of bit differences is 2.
				f(2, 2) - as both numbers are the same, no, of bit differences is 0
				f(2, 1) - same as (1, 2), hence no. of bit differences is 2.
				Summing the above values (0+2+0+2) we get 4. Hence, the output is 4.

				Test Case 2:
				There is only one possible pair (6,6). As both the numbers are sum, the output is 0.
			Sample Input 2 :
				2
				3 
				1 3 5
				4
				4 6 7 8
				Sample Output 2 :
				8
				26

		//NOT Optimized
			#include <bits/stdc++.h> 
			int differentBitsSumPairwise(vector<int> &arr, int n){
				int sum=0;
				for(int i=0;i<n;i++){
					for(int j=0;j<n;j++){
						
						if(arr[i] == arr[j]){
							continue;
						}else{
							int cnt=0;
							int outer = arr[i],inner=arr[j];
							while(outer !=0 || inner !=0){
								int LBout = outer&1;
								int LBinn = inner&1;
								if(LBout ^ LBinn == 1){
								cnt++;
								}
								outer>>=1;
								inner>>=1;
							}
							sum += cnt;
						}
					}
				}
				return sum;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int differentBitsSumPairwise(vector<int> &arr, int n){
				int sum = 0;
				// Count the number of set bits at each position
				for (int i = 0; i < 32; i++) { 
					// Assuming integers are 32 bits
					int countOnes = 0;
					
					for (int j = 0; j < n; j++) {
						if ((arr[j] >> i) & 1) {
							countOnes++;
						}
					}
					
					int countZeros = n - countOnes;
					
					// For each position, add the count of different bits to the sum
					// Multiply by 2 to count both 0->1 and 1->0 transitions
					sum += countOnes * countZeros * 2; 
				}
				return sum;
			}

	51) First Unique Character in a String
		Sample Input 1:
			2
			bbabcbcb
			babaabea
			Sample Output 1:
			a
			e

			Explanation Of Sample Input 1:
				For the first test case, 
				the first non-repeating character is ‘a’. As depicted the character 
				‘b’ repeats at index 1, 3, 5, 7, and character ‘c’ repeats at index 6. Hence we return the character ‘a’ present at index 2.
				
				For the second test case, 
				the character ‘e’ is the first non-repeating character. As depicted the character ‘b’ repeats at 
				index 2, 5, and character ‘a’ repeats at index 3, 4, and 7. Hence we return the character ‘e’ present at index 6.
		
		Sample Input 2:
			3
			cbbd
			bebeeed
			abcd
			Sample Output 2:
			c
			d
			a

		#include <bits/stdc++.h> 
		char findNonRepeating(string str) {
			int cnt=1;
			for(int i=0;i<str.length();i++){
				if(isalpha(str[i])){
					char ch = str[i];
					int j=i+1;
					cnt=1;
					while(j < str.length()){
						if(isalpha(str[j]))
							if(str[i] == str[j]){
							str[j] = '0';
							cnt++;
							}
						j++;
					}
				}
				if(cnt == 1)
					return str[i];
			}
			return '#';
		}	

	52) MegaPrime Numbers:
		Sample Input 1 :
			2
			2 15
			11 24
			Sample Output 1 :
			4
			1
			Explanation Of Sample Input 1 :
				Test Case 1:
					‘Left’ = ‘2’ and ‘Right’ = ‘15’ 
				All prime numbers from ‘2’ to ‘15’ are 2, 3, 5, 7, 11, 13

					2 is ‘megaprime’ number because its individual digit ‘2’ is prime.
					3 is ‘megaprime’ number because its individual digit ‘3’ is prime.
					5 is ‘megaprime’ number because its individual digit ‘5’ is prime.
					7 is ‘megaprime’ number because its individual digit ‘7’ is prime.
					11 is not ‘megaprime’ number because its individual digits ‘1’ and ‘1’ both are not prime.
					13 is not ‘megaprime’ number because its individual digits ‘1’ is not prime.
					Hence because there are four ‘megaprime’ numbers 2, 3, 5, 7 out of 2, 3, 5, 7, 11, 13, we return four.
				Test case 2:
					‘Left’ = 11 and ‘Right’ = 24 
				All prime numbers from ‘11’ to ‘24’ are 11, 13, 17, 19, 23
					11 is not a ‘megaprime’ number because its individual digit ‘1’ is not prime.
					13 is not ‘megaprime’ number because its individual digit ‘1’ is not prime.
					17 is not ‘megaprime’ number because its individual digit ‘1’ is not prime.
					19 is not ‘megaprime’ number because its individual digits ‘1’ and ‘9’ both are not prime.
					23 is ‘megaprime’ number because its individual digits ‘2’ and ‘3’ both are prime.

				Since there is only one ‘megaprime’ number, 23 out of 11 13, 17, 19, 23, we return one.
		Sample Input 2 :
			2
			1 11
			1 100
			Sample Output 2 :
			4
			8
		#include <bits/stdc++.h> 
		bool isPrime(int num){
			if(num ==1)
				return 0;
			else if(num == 2 || num ==3){
				return 1;
			}else{
				int i=2;
				for(; i<= num/2; i++){
					if(num % i == 0)
						return 0;
				}
				if(i > (num/2))
					return 1;
			}
			return 0;
		}
		int countMegaPrimeNumber(int left, int right) {
			vector<int> megaPrime;
			vector<int> primeNums;
			for(int i=left; i<=right; i++){
				int num = i, start=2;
				while(start <= num/2){
					if(num % start == 0){
						break;
					}
					start++;
				}
				if(start > (num/2))
					primeNums.push_back(num);
			}

			for(int i=0; i<primeNums.size(); i++){
				int n = primeNums[i];
				while(n){
					int lastDigit = n % 10;
					if(lastDigit == 0)
						break;
					else if(isPrime(lastDigit)){
						n/=10;
					}else{
						break;
					}
				}

				if(n == 0)
					megaPrime.push_back(primeNums[i]);
			}
			return megaPrime.size();
		}

		//or

			#include <iostream>
			#include <bits/stdc++.h> 
			using namespace std;

			bool isPrime(int num){
				if(num ==1)
					return 0;
				else if(num == 2 || num ==3){
					return 1;
				}else{
					int i=2;
					for(; i<= num/2; i++){
						if(num % i == 0)
							return 0;
					}
					if(i > (num/2))
						return 1;
				}
				return 0;
			}
			int countMegaPrimeNumber(int left, int right) {
				vector<int> megaPrime;
				vector<int> primeNums;
				for(int i=left; i<=right; i++){
					int num = i, start=2;
					while(start <= num/2){
						if(num % start == 0){
							break;
						}
						start++;
					}
					if(start > (num/2))
						primeNums.push_back(num);
				}

				for(int i=0; i<primeNums.size(); i++){
					int n = primeNums[i];
					while(n){
						int lastDigit = n % 10;
						if(lastDigit == 0)
							break;
						else if(isPrime(lastDigit))
							n/=10;
						else
							break;
					}
					if(n == 0)
						megaPrime.push_back(primeNums[i]);
				}
				cout<<endl<<"Megaprimes are "<<endl;
				for(int j=0; j<megaPrime.size(); j++)
					cout<<megaPrime[j]<<" ";
				cout<<"\n";
				return megaPrime.size();
			}

			int main()
			{
				cout<<countMegaPrimeNumber(7,2547)<<endl;
				return 0;
			}

	53) (moderate) Predict the Winner:
		Description:
			Sample Input 1:
				2
				5
				2
				4
				3
				Sample Output 1:
					3
					1
				Explanation Of Sample Input 1:
				For the first test case:
					The game starts with Person 1. He passes the ball to person 2. 
					The game pauses here. Person 2 passes the ball to person 3 and leaves the game. 
					Then the game resumes. Person 3 passes the ball to person 4. The game pauses here. 
					Person 4 passes the ball to person 5 and leaves the game. 
					Then the game resumes with person 5 having the ball in his hand. 
					He passes the ball to person 1. The game pauses here. Person 1 passes the ball 
					to person 3 and leaves the game. Then the game resumes with person 3 having the ball in his hand. 
					He passes the ball to person 5. The game pauses here. Person 5 passes the ball to person 3 
					and leaves the game. Now only person 3 remains and the game stops here.

				Hence, the winner of the game will be Person 3 and the answer will be 3.
				For the second test case:
					The game starts with Person 1. He passes the ball to person 2. Person 2 passes the ball to Person 3. 
					The game pauses here. Person 3 passes the ball to Person 4 and leaves the game. Then the game resumes. 
					Person 4 passes the ball to person 1. Person 1 passes the ball to person 2.The game pauses here. 
					Person 2 passes the ball to person 4 and leaves the game. Then the game resumes with Person 4 
					having the ball in his hand. He passes the ball to person 1. Person 1 passes the ball to Person 4. 
					The game pauses here. Person 4 passes the ball to person 1 and leaves the game. 
					Now only person 1 remains and the game stops here.
					Hence, the winner of the game will be Person 1 and the answer will be 1.
			Sample Input 2:
				1
				4
				1
				Sample Output 2:
				4
		//not optimized
			#include <bits/stdc++.h> 
			int predictTheWinner(int n, int k) {
				vector<int> v;
				for(int i=1; i<=n; i++)
					v.push_back(i);

				if(v.size() == 1)
					return v[0];

				if(k==1)
					return n;

				int pointer=0;
				while(v.size() > 1){
					pointer = (pointer+k-1) % v.size();
					v.erase(v.begin()+pointer);
				}
				return v[0]; 
			}

		//Optimized
			#include <bits/stdc++.h> 
			int predictTheWinner(int n, int k) {
				if (k == 1) {
					return n;
				}

				int winner = 0;
				for (int i = 2; i <= n; i++) {
					winner = (winner + k) % i;
				}

				return winner + 1;
			}

	54) Ninja And The Nested Ranges:
		//Not Optimized:
			Sample Input 1 :
				2
				3
				3 8
				1 3
				7 8
				4
				4 9
				9 10
				4 10
				2 3
				Sample Output 1 :
				1 0 0
				0 0 1
				0 0 1 0
				1 1 0 0
				Explanation Of Sample Output 1 :
				Test Case 1 :  
				For ‘RESULT[ 0 ]’ array:
				Since the range [3, 8] contains the range [7, 8], the output corresponding to [3, 8] is 1.
				The range [1, 3] does not contain any of the ranges. Therefore, the output corresponding to [1, 3] is 0.
				The range [7, 8] does not contain any of the ranges. Therefore, the output corresponding to [7, 8] is 0.

				For ‘RESULT[ 1 ]’ array:
				The range [3, 8] is not contained by any of the ranges. Therefore, the output corresponding to [3, 8] is 0.
				The range [1, 3] is not contained by any of the ranges. Therefore, the output corresponding to [1, 3] is 0.
				Since the range [7, 8] is contained by the range [3, 8], the output corresponding to [7, 8] is 1.

				Test Case 2 :     
				For ‘RESULT[ 0 ]’ array:
				The range [4, 9] does not contain any of the ranges. Therefore, the output corresponding to [4, 9] is 0.
				The range [9, 10] does not contain any of the ranges. Therefore, the output corresponding to [9, 10] is 0.
				Since the range [4, 10] contains the ranges [4, 9] and [9, 10], the output corresponding to [4, 10] is 1.
				The range [2, 3] does not contain any of the ranges. Therefore, the output corresponding to [2, 3] is 0.

				For ‘RESULT[ 1 ]’ array:
				Since the range [4, 9] is contained by the range [4, 10], the output corresponding to [4, 9] is 1.
				Since the range [9, 10] is contained by the range [4, 10], the output corresponding to [9, 10] is 1.
				The range [4, 10] is not contained by any of the ranges. Therefore, the output corresponding to [4, 10] is 0.
				The range [2, 3] is not contained by any of the ranges. Therefore, the output corresponding to [2, 3] is 0.
				Sample Input 2 :
				2
				5
				5 8
				8 11
				5 13
				13 14
				3 15
				4
				22 91
				25 40
				66 85
				57 83
				Sample Output 2 :
				0 0 1 0 1
				1 1 1 1 0
				1 0 0 0
				0 1 1 1

			#include <iostream>
			#include <bits/stdc++.h> 
			using namespace std;
			vector<vector<int>> nestedRangesCheck(vector<vector<int>> &ranges, int n){
				vector<vector<int>> ans;
				vector<int> temp;

				int i=0;

				//for first array checking contains or not?
				while(i<n){
					int root1 = ranges[i][0];
					int root2 = ranges[i][1];
					int inner=0;
					bool flag = true;
					while(inner<n){
						if(inner == i){
							inner++;
							continue;
						}
						int check1 = ranges[inner][0];
						int check2 = ranges[inner][1];

						if(root1<= check1 && root2>=check2){
							temp.push_back(1);
							flag = false;
							break;
						}
						inner++;
					}
					if(flag)
						temp.push_back(0);
					i++;
				}
				ans.push_back(temp);
				temp.clear();
				
				//for second array checking contained by any of ranges
				i=0;
				while(i<n){
					int root1 = ranges[i][0];
					int root2 = ranges[i][1];
					bool flag = true;
					int inner = 0;
					while(inner<n){
						if(inner == i){
							inner++;
							continue;
						}
						
						int check1 = ranges[inner][0];
						int check2 = ranges[inner][1];
						
						if(check1<=root1 && check2>=root2){
							temp.push_back(1);
							flag = false;
							break;
						}
						inner++;
					}
					if(flag)
						temp.push_back(0);
					i++;
				}
				ans.push_back(temp);
				return ans;
				}

			int main(){
				vector<vector<int>> ans;
				// int n=4;
				// vector<vector<int>> temp = {{4,9},{9,10},{4,10},{2,3}};
				int n=3;
				vector<vector<int>> temp = {{3,8},{1,3},{7,8}};
				ans = nestedRangesCheck(temp, n);
				
				for(int i=0;i<2;i++){
					for(int j=0;j<n;j++)
						cout<<ans[i][j]<<" ";
					cout<<"\n";
				}
				return 0;	
			}

	55) Count unsorted columns
		You are given an array ‘STRINGS’ having
				‘N’ number of strings. The strings are
				assumed to be arranged such that there
				is one string in one line.
				You need to return the number of columns
				that are not sorted lexicographically.
				Note:
				The length of all the string in the array is the same
		Sample Input 1:
			2
			3
			bccde
			dehrt
			gabzy
			2
			wr
			yz
			Sample Output 1:
			2
			0
			Explanation Of Sample Input 1:
			Test Case 1: In the given strings -
			Column 0 - b, d, g is sorted
			Column 1 - c, e, a is not sorted
			Column 2 - c, h, b is not sorted
			Column 3 - d, r, z is sorted
			Column 4 - e, t, y is sorted.

			Column 1, column 2 is not sorted, so the required answer is ‘2’.

			Test Case 2: Both the columns (‘w’, ‘y’) and (‘r’, ‘z’ ) are sorted. So the answer is ‘0’.
			Sample Input 2:
			2
			4
			u
			e 
			y 
			b
			2
			cterub
			aybsgn
			Sample Output 2:
			1
			3
		
		//checks the strings columns wise, are they sorted or not? 
		//length of all string in vector are same
		#include <iostream>
		#include<vector>
		using namespace std;

		int main(){
			int unsortedCnt=0;
			int col=0;
			
			vector<string> strings = {"cterub","aybsgn"};
			while(col<strings[0].size()){
				for(int i=0; i< strings.size()-1; i++){
					string word1 = strings[i];
					string word2 = strings[i+1];
					
					if(word1[col]>word2[col]){
						unsortedCnt++;
						break;
					}
				}
				col++;
			}
			
			cout<<unsortedCnt;
			return 0;
		}

	56) Wave Array:
		Example 1:
			Input:
			n = 5
			arr[] = {1,2,3,4,5}
			Output: 2 1 4 3 5
			Explanation: Array elements after 
			sorting it in wave form are 
			2 1 4 3 5.

		Example 2:
			Input:
			n = 6
			arr[] = {2,4,7,8,9,10}
			Output: 4 2 8 7 10 9
			Explanation: Array elements after 
			sorting it in wave form are 
			4 2 8 7 10 9.
		Your Task:
			The task is to complete the function convertToWave(), which converts the given array to a wave array.

		Expected Time Complexity: O(n).
		Expected Auxiliary Space: O(1).

		Constraints:
			1 ≤ n ≤ 106
			0 ≤ arr[i] ≤107
		#include <iostream>
		#include<vector>
		using namespace std;

		void toWaveForm(vector<int> a){
			cout<<"Wave form array:\t";
			for(int i=0;i<a.size()-1; i +=2)
				swap(a[i],a[i+1]);
			
			for(int i:a)
				cout<<i<<"\t";
				
			cout<<"\n";
		}

		void normalArray(vector<int> a){
			std::cout << "Normal array :\t\t";
			for(int i: a)
				cout<<i<<"\t";
			cout<<"\n";    
		}

		int main(){
			vector<int> a = {1,2,3,4,5,6,7,8,9,10};
			normalArray(a);
			
			toWaveForm(a);
			
			vector<int> b = {22,33,44,5,66,77,88,99,12,90,89};
			normalArray(b);
			
			toWaveForm(b);
			
			return 0;
		}

	57) Monotonic Array
		An array is monotonic if it is either monotone increasing or monotone decreasing.
			An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. 
			An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
			Given an integer array nums, return true if the given array is monotonic, or false otherwise.
			
			Example 1:
				Input: nums = [1,2,2,3]
				Output: true

			Example 2:
				Input: nums = [6,5,4,4]
				Output: true
			Example 3:
				Input: nums = [1,3,2]
				Output: false
			Constraints:
				1 <= nums.length <= 105
				-105 <= nums[i] <= 105
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {
				int i=0, n=1;
				back:
				if( (i+n)<nums.size() && nums[i] <= nums[i+n]){
					if(nums[i] == nums[i+n]){
						n++;
						goto back;
					}
					for(int j=i+1; j<nums.size()-1; j++)
						if(nums[j] > nums[j+1])
							return 0;
				}else{
					for(int j=i+1; j<nums.size()-1; j++)
						if(nums[j] < nums[j+1])
							return 0;
				}
				return 1;
			}
		};

		//or
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {
				bool increasing = true;
				bool decreasing = true;

				for (int i = 1; i < nums.size(); ++i) {
					if (nums[i] > nums[i - 1]) {
						decreasing = false;
					}
					if (nums[i] < nums[i - 1]) {
						increasing = false;
					}
				}
				return increasing || decreasing;
			}
		};

		//or
		class Solution {
			public:
			bool isMonotonic(vector<int>& nums) {

				if(nums.size()==1)
					return 1;
				
				bool increORdecre= false;
				int i=0;
				while(i<nums.size()-1){
					if(nums[i]<= nums[i+1]){
						increORdecre = true;
					}
					else{
						increORdecre = false;
						break;
					}
					i++;
				}
				
				if(increORdecre)
					return 1;

				i=0;
				while(i<nums.size()-1){
					if(nums[i]>=nums[i+1]){
						increORdecre = true;
					}else{
						increORdecre = false;
						break;
					}
					i++;
				}
				return increORdecre;
			}
		};

	58) Mirror String :
		-The String which contains the letter A,H,I,M,O,T,U,V,W,X,Y etc are the same looks in mirror.
		-& check for string is palindrome or not,
		Sample Input 1:
			1
			ITATI
			Sample Output 1:
			YES
			Explanation Of Sample Input 1:
			String “ITATI” is the same as its reflection in the mirror.
			Sample Input 2:
			2
			MMMM
			MZM
			Sample Output 2:
			YES
			NO

		#include <bits/stdc++.h> 
		bool isPalindrome(string &s){
			for(int i=0;i<s.length()/2;i++)
				if(s[i] != s[s.length()-i-1])
					return 0;
			return 1;
		}

		bool isReflectionEqual(string &s){
			for(int i=0; i<s.length(); i++){
				if(s[i] == 'A' || s[i] == 'H' || s[i] == 'I' ||
					s[i] == 'M' || s[i] == 'O' || s[i] == 'T' ||
					s[i] == 'U' || s[i] == 'V' || s[i] == 'W' || 
					s[i] == 'X' || s[i] == 'Y'){
						continue;
					}
				else{
					return false;
				}
			}

			bool check = isPalindrome(s);
			return check;
		}

	59) Detect Odd:
		You are given an array of ‘N’ nonnegative integers where all elements
			appear an even number of times except
			two, print the two odd occurring
			elements in increasing order. It may be
			assumed that the size of the array is atleast two and there will always be
			exactly two numbers which appear an
			odd number of times in the given array.
			EXAMPLE:
			Input: 'N' = 6, 'NUMS' = [1,
			1, 2, 3, 4, 4]
			Output: 2 3
			Here in the given array we can
			see that 2 and 3 occur 1 time
			which is an odd number. Hence,
			the output will be 2 and 3.
		Sample Input 1 :
			2
			6
			1 1 2 3 4 4
			2
			1 2
			Sample Output 1 :
			2 3
			1 2
			Explanation Of Sample Input 1 :
			For the first test case,
			'N' = 6 and 'NUMS' = [1, 1, 2, 3, 4, 4]
			Here in the given array we can see that 2 and 3 occur 1 time which is an odd  number. Hence, the output will be 2 and 3.

			For the second test case,
			'N' = 2 and 'NUMS' = [1, 2]
			Here in the given array we can see that 1 and 2 occur 1 time which is an odd  number. Hence, the output will be 1 and 2.
		Sample Input 2 :
			2
			4
			8 2 2 7
			4
			3 1 3 5
			Sample Output 2 :
			7 8   
			1 5
		
		//not Optimized:
			#include <bits/stdc++.h> 
			vector <int> detectOdd(int n, vector <int> nums) {
				if(nums.size()==2)
					return nums;
				
				vector<int> ans;
				for(int i=0;i<nums.size(); i++){
					int cnt=1,j;
					if(nums[i] == INT_MIN){
						continue;
					}
					
					for(j=0; j<nums.size(); j++){
						if(i==j || nums[j] == INT_MIN)
							continue;
						else if(nums[i] == nums[j]){
							nums[i] = INT_MIN;
							nums[j] = INT_MIN;
							cnt++;
							break;
						}
					}
					if(cnt==1)
						ans.push_back(nums[i]);
				}

				sort(ans.begin(), ans.end());
				return ans;
			}
		
		//Optimized:
			#include <bits/stdc++.h> 
			vector <int> detectOdd(int n, vector < int > nums) {
				if(nums.size()==2)
					return nums;
				
				vector<int> ans;
				unordered_set<int> doublChecker;

				for(int i=0; i<nums.size(); i++){
					if(doublChecker.count(nums[i]) == 0)
						doublChecker.insert(nums[i]);
					else
						doublChecker.erase(nums[i]);
				}

				ans.assign(doublChecker.begin(), doublChecker.end());				//assigning unordered_set to vector
				sort(ans.begin(), ans.end());
				return ans;
			}
		
	60) Ninja and Range Max
		Sample Input 1:
			2
			6 0 3
			3 2 2 4 5 2
			6 4 4
			2 4 6 8 9 10
			Sample Output 1:
			4
			9
			Explanation Of Sample Input 1:
			For test case 1:
			The maximum element in the range [0, 3] is 4.
			Hence, the answer for this case is 4.

			For test case 2:
			The maximum element in the range [4, 4] is 9.
			Hence, the answer for this case is 9.
			Sample Input 2:
			2
			5 2 3
			6 6 8 5 1
			5 3 4
			2 4 5 3 1
			Sample Output 2:
			8
			3

		int ninjaAndRangeMax(int n, int x, int y, vector<int> &a) {
			int maxer = a[x];
			for(int i=x+1; i<=y; i++)
				maxer = max(maxer, a[i]);
			return maxer;
		}

		//more optimized:
			int ninjaAndRangeMax(int n, int x, int y, vector<int> &a) {
				auto max_iter = std::max_element(a.begin() + x, a.begin() + y + 1);
				return *max_iter;
			}

	61) 132 Pattern:
		Given an array of n integers nums, a 132 pattern is a subsequence of three 
		integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
		Return true if there is a 132 pattern in nums, otherwise, return false.
			Example 1:
				Input: nums = [1,2,3,4]
				Output: false
				Explanation: There is no 132 pattern in the sequence.
			Example 2:
				Input: nums = [3,1,4,2]
				Output: true
				Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
			Example 3:
				Input: nums = [-1,3,2,0]
				Output: true
				Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
			Constraints:
				n == nums.length
				1 <= n <= 2 * 105
				-109 <= nums[i] <= 109
		//Not Optimized:
			class Solution {
				public:
				bool find132pattern(vector<int>& nums) {
					if(nums.size() < 3)
						return 0;

					//checking that more than 3 different nums present in vector or not?
					set<int> checking;
					for(int i: nums)
						checking.insert(i);
					
					if(checking.size()<3)
						return 0;

					//reducing 2 coz its subarray of 3 elements.
					int iRange = nums.size()-2;
					int jRange = nums.size()-1;

					for(int i=0; i< iRange; i++){
						for(int j=i+1; j< jRange; j++){
							for(int k=j+1; k<nums.size(); k++){
								if((nums[i] < nums[k])  && (nums[k] < nums[j]))
									return 1;
							}                
						}
					}
					return 0;  
				}
			};
		
		//optimized:
			class Solution {
				public:
				bool find132pattern(vector<int>& nums) {
					int n = nums.size();
					if (n < 3) {
						return false;
					}

					vector<int> minSoFar(n);
					minSoFar[0] = nums[0];

					// Calculate the minimum element so far for each index
					for (int i = 1; i < n; i++) {
						minSoFar[i] = min(minSoFar[i - 1], nums[i]);
					}

					stack<int> s;

					for (int j = n - 1; j >= 0; j--) {
						// If nums[j] is greater than the minimum element so far, we have a candidate for 'k'
						if (nums[j] > minSoFar[j]) {
							// Find the maximum 'i' that is less than nums[j]
							while (!s.empty() && s.top() <= minSoFar[j]) {
								s.pop();
							}

							// If we found a valid 'i', return true
							if (!s.empty() && s.top() < nums[j]) {
								return true;
							}
							// Push nums[j] onto the stack as a potential 'k'
							s.push(nums[j]);
						}
					}
					return false; 
				}
			};

	62) Maximum Value of F(x) - VI:
		problem Statement
			You are provided with a sorted array of integers
			‘ARR’ having length ‘N’ and a function ‘F(X)’, such
			that:
			F(X) = S + G
			Where:
			‘X’ = Any integer that belongs to array
			‘ARR’.
			‘S’ = Number of integers in ‘ARR’ that
			are strictly smaller than ‘X’.
			‘G’ = Number of integers in ‘ARR’ that
			are strictly greater than ‘X’.
			For Example:
			‘ARR’ = {1, 1, 1, 2, 2, 3, 4}
			Let, ‘X’ = 1
			F(X) = 0 + 4 = 4 (as ‘0’ numbers of
			elements are smaller than ‘1’ and ‘4’
			elements that are ‘2’, ‘2’, ‘3’, and ‘4’
			are greater than ‘1’.
			Let ‘X’ = 2
			F(X) = 3 + 2 = 5 (as ‘3’ numbers
			(‘1’, ‘1’, and ‘1’) are smaller than ‘2’
			and ‘2’ numbers that are ‘3’, and ‘4’ are
			greater than ‘2’.
			Let ‘X’ = 3
			F(X) = 5 + 1 = 6 (as ‘5’ numbers
			(three times ‘1’ and two times ‘2’) are
			smaller than ‘3’ and ‘1’ number that is
			‘4’ is greater than ‘3’.
			Let ‘X’ = 4
			F(X) = 6 + 0 = 6 (as ‘6’ numbers
			(three times ‘1’, two times ‘2’, and one
			time ‘3’) are smaller than ‘4’ and ‘0’
			numbers are greater than ‘3’.
			All you have to do is to find the maximum value of
			‘F(X)’.

		Sample Input 1 :
			1
			7
			1 1 1 2 2 3 4
			Sample Output 1 :
			6
			Explanation For Sample Input 1 :
			For the first test case, an explanation is given in the description.
			Sample Input 2 :
			2
			5
			10 20 30 40 40
			2
			3 4
			Sample Output 2 :
			4
			1
		//not optimized:
			#include <bits/stdc++.h> 
			int maxFXVI(int n, vector<int> &arr){
				vector<int> maxer;
				for(int i=0;i<n; i++){
					int cnt=0;
					for(int j=0; j<n; j++){
						if(i==j)
							continue;
						if(arr[i] != arr[j])
							cnt++;
					}
					maxer.push_back(cnt);
				}
				auto mxValue = max_element(maxer.begin(), maxer.end());
				return *mxValue;
			}

	63) Find the length of last word:
		https://leetcode.com/problems/length-of-last-word/
		#include <iostream>
		#include<algorithm>
		using namespace std;
		int main(){
			// string s = "Vivek Mahesh Nikate";
			string s = "Hello world";
			string Lword;
			
			for(int i=s.length()-1; i>=0;i--){
				if(s[i] != ' ')
					Lword += s[i];
				else
					break;

				//or you can use this also instead of above if checking condition
					//if(isblank(s[i]))
					//	break;
					//Lword += s[i];
			}
			reverse(Lword.begin(), Lword.end());
			std::cout << Lword<<" & the length of its is :: "<< Lword.length() << std::endl;
			return 0;
		}

		//ignoring the trailing spaces also,
		class Solution {
			public:
			int lengthOfLastWord(string s) {
				int i=s.length()-1;
				while(i>=0){
					if(isblank(s[i]))
						s.erase(i,1);
					else 
						break;
					i--;
				}
					
				i = s.size()-1;
				string temp;
				while(i>=0){
					if(isblank(s[i]))
						break;
					temp += s[i];
					i--;
				}
				return temp.length();
			}
		};
		
		//or 0ms second
			class Solution {
				public:
				int lengthOfLastWord(string s) {
					int count=0;
					for(int i=s.length()-1; i>=0; i--){
						while(int(s[i])==32){
							i--;
						}
						while(int(s[i])!=32){
							count++;
							i--;
							if(i<0){
								break;
							}
						}
						break;
					}
					return count;
				}
			};

	64) Column name from a given column number:
		Given a positive integer, return its corresponding column title as appear in an Excel sheet.
		Excel columns has a pattern like A, B, C, … ,Z, AA, AB, AC,…. ,AZ, BA, BB, … ZZ, AAA, AAB ….. etc. 
		In other words, column 1 is named as “A”, column 2 as “B”, column 27 as “AA” and so on.

			Example 1:
				Input:
				N = 28
				Output: AB
				Explanation: 1 to 26 are A to Z.
				Then, 27 is AA and 28 = AB.

			Example 2:
				Input: 
				N = 13
				Output: M
				Explanation: M is the 13th character of
				alphabet.
				Your Task:
			You don't need to read input or print anything. Your task is to complete the function colName() which takes the column number N as input and returns the column name represented as a string.
			Expected Time Complexity: O(LogN).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 <= N <= 1018
		class Solution{
			public:
			string colName (long long int n){
				
				string s;
			
				while (n > 0) {
					int GenNum = (n-1) % 26;  // Subtract 1 to get the correct column name
					char ch = 'A';
			
					for (int i =0; i < GenNum; i++) {
						ch++;
					}
					s += ch;
					n = (n-1) / 26;  // Subtract 1 here as well
				}
				reverse(s.begin(), s.end());
				return s;
			}
		};

	65) Roman Number to Integer:
		Given a string in roman no format (s)  your task is to convert it to an integer . 
		Various symbols and their values are given below.
			I 1
			V 5
			X 10
			L 50
			C 100
			D 500
			M 1000

			Example 1:
			Input:
				s = V
				Output: 5
			Example 2:
				Input:
				s = III 
				Output: 3
			Your Task:
				Complete the function romanToDecimal() which takes a string as input parameter and returns the 
				equivalent decimal number. 

			Expected Time Complexity: O(|S|), |S| = length of string S.
			Expected Auxiliary Space: O(1)

			Constraints:
				1<=roman no range<=3999
			class Solution {
				public:
				int romanToDecimal(string &str) {
					int i=str.length()-1;
					int num=0;

					while (i >= 0) {
						char val = str[i];
						int temp, prev = 0;
				
						if (val == 'I') {
							temp = 1;
						} else if (val == 'V') {
							temp = 5;
						} else if (val == 'X') {
							temp = 10;
						} else if (val == 'L') {
							temp = 50;
						} else if (val == 'C') {
							temp = 100;
						} else if (val == 'D') {
							temp = 500;
						} else if (val == 'M') {
							temp = 1000;
						}
				
						if (i > 0) {
							char prevVal = str[i - 1];
							if (prevVal == 'I') {
								prev = 1;
							} else if (prevVal == 'V') {
								prev = 5;
							} else if (prevVal == 'X') {
								prev = 10;
							} else if (prevVal == 'L') {
								prev = 50;
							} else if (prevVal == 'C') {
								prev = 100;
							} else if (prevVal == 'D') {
								prev = 500;
							} else if (prevVal == 'M') {
								prev = 1000;
							}
						}
				
						if (prev > 0 && prev < temp) {
							temp -= prev;
							i--; // Skip the previous character
						}
				
						num += temp;
						i--;
					}
					return num;
				}
			};

			//or
				int mapRomanToDecimal(char ch){
					if(ch == 'I'){
						return 1;
					}else if(ch == 'V'){
						return 5;
					}else if(ch == 'X'){
						return 10;
					}else if(ch == 'L'){
						return 50;
					}else if(ch == 'C'){
						return 100;
					}else if(ch == 'D'){
						return 500;
					}else if(ch == 'M'){
						return 1000;
					}
				}

				int romanToInt(string s) {
					int i=s.length()-1;
					int num = 0;
					while(i>=0){
						char curVal = s[i];
						int temp = mapRomanToDecimal(curVal);
						int prev=0;

						if(i>0){
							char prevVal = s[i-1];
							prev = mapRomanToDecimal(prevVal);
						}

						if(prev< temp){
							temp -= prev;
							i--;
						}

						num += temp;
						i--;

					}
					return num;
				}

	66) Modular Exponentiation :
		You are given a three integers 'X','N', and 'M'. Your task is to find ('X'^ 'N') % 'M'. A ^ B is defined 
		as X raised to power N and X % M is the remainder when X is divided by M.

			Constraints :
			1 <= T <= 100
			1 <= X, N, M <= 10^9
			Time limit: 1 sec
		Sample Input 1 :
			2 
			3 1 2
			4 3 10
			Sample Output 1 :
			1
			4
			Explanation For Sample Output 1:
			In test case 1, 
			X = 3, N = 1, and M = 2 
			X ^ N = 3 ^ 1 = 3 
			X ^ N % M = 3 % 2 = 1. 
			So the answer will be 1.

			In test case 2,
			X = 4, N = 3, and M = 10 
			X ^ N = 4 ^ 3 = 64 
			X ^ N % M = 64 % 10 = 4. 
			So the answer will be 4.
			Sample Input 2 :
			2
			5 2 10 
			2 5 4
		Sample Output 2 :
			5
			0
			Explanation For Sample Output 2:
			In test case 1, 
			X = 5, N = 2, and M = 10 
			X^N = 5^2 = 25 
			X^N %M = 25 % 10 = 5. 
			So the answer will be 5.

			In test case 2,
			X = 2, N = 5, and M = 4 
			X^N = 2^5 = 32 
			X^N %M = 32 % 4 = 0. 
			So the answer will be 0.

			//NOT Optimized:
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;
					
					for(int i=0; i<n; i++){
						power = (power * x) % m;
					}
					return power;
				}
			
			//Optimized:
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;

					if(n==0)
						return power;

					long long base = x % m;
					while(n>0){
						if(n&1)
							power = (power * base) %m;
						base = (base*base)%m;
						n/=2;
					}
					return (int)((power+m)%m);
				}
			
			//or
				#include <bits/stdc++.h>
				int modularExponentiation(int x, int n, int m) {
					long long power=1;
					long long base = x;
					if(n==0)
						return power;
					int i=1;
					while(n > 0){
						if(n&1)
							power = (power % m * base % m) % m;

						base = (base * base) % m ;
						n /= 2;
					}
					return power;
				}

	67) Largest Element in the Array
		Given an array ‘arr’ of size ‘n’ find the largest element in the array.
		Example:
		Input: 'n' = 5, 'arr' = [1, 2,3, 4, 5]
		Output: 5
		Explanation: From the array {1,2, 3, 4, 5}, the largest element is 5.

		Sample Input 1:
			6
			4 7 8 6 7 6 
			Sample Output 1:
			8
			Explanation Of Sample Input 1: The answer is 8. From {4 7 8 6 7 6}, 8 is the largest element.
		Sample Input 2:
			8
			5 9 3 4 8 4 3 10 
			Sample Output 2:
			10
			Expected Time Complexity:
			O(n), Where ‘n’ is the size of an input array ‘arr’.
			Constraints :
			1 <= 'n' <= 10^5
			1 <= 'arr[i]' <= 10^9

			Time Limit: 1 sec

		#include <bits/stdc++.h> 
		int largestElement(vector<int> &arr, int n) {
			// auto mxr = max_element(arr.begin(), arr.end());
			// return *mxr;
			int mx = arr[0];
			for(int i=1;i<n;i++)
				mx = max(mx,arr[i]);
			return mx;
		}

	68) Sum Of Even Numbers Till N:
		Sample Input 1 :
			2
			6
			2
			Sample Output 1 :
			12
			2
			Explanation For Sample Input 1 :
			For test case 1 :
			Sum of all even numbers till 6 will be : 2 + 4 + 6 = 12

			For test case 2 :
			Sum of all even numbers till 2 will be : 2
			Sample Input 2 :
			2
			4
			5
			Sample Output 2 :
			6
			6
			Explanation For Sample Input 2 :
			For test case 1 :
			Sum of all even numbers till 4 will be : 2 + 4 = 6

			For test case 2 :
			Sum of all even numbers till 5 will be : 2 + 4 = 6

		#include <bits/stdc++.h> 
		long long evenSumTillN(int n) {
			long long sum =0;
			for(int i=2; i<=n; i+=2)
				sum += i;
			return sum;
		}

	69) Find Character Case
		You are given a character ‘CH’ as input, return either 1,
		0 or -1 according to the following rules:
		1, if the character is an uppercase alphabet (A - Z).
		0, if the character is a lowercase alphabet (a - z).
		-1, if the character is not an alphabet.
		For Example :
			If ‘CH’ = ‘a’, then since it is a
			lowercase letter, your program should return 0
		Sample Input 1:
			2
			A
			t
			Sample Output 1:
			1
			0
			Explanation For Sample Input 1:
			For sample case 1, ‘A’ is an uppercase letter, hence output is 1.
			For sample case 2, ‘t’ is a lowercase letter, hence output is 0.
			Sample Input 2:
			2
			#
			P
			Sample Output 2:
			-1
			1
			Explanation For Sample Input 2:
			For sample case 1, ‘#’ is not an alphabet, hence output is -1.
			For sample case 2, ‘P’ is an uppercase letter, hence output is 1.

		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(islower(ch))
				return 0;
			else if(isupper(ch))
				return 1;
			else
				return -1;
		}

	70) Two Repeated Elements:
		You are given an array of N+2 integer elements. 
			All elements of the array are in the range 1 to N. 
			Also, all elements occur once except two numbers which occur twice. 
			Find the two repeating numbers.

			Note: Return the numbers in their order of appearing twice. 
			So, if X and Y are the repeating numbers, and X repeats twice before Y 
			repeating twice, then the order should be (X, Y).

			Example 1:
				Input:
				N = 4
				array[] = {1,2,1,3,4,3}
				Output: 1 3
				Explanation: In the given array, 
				1 and 3 are repeated two times.
				
			Example 2:
				Input:
				N = 2
				array[] = {1,2,2,1}
				Output: 2 1
				Explanation: In the given array,
				1 and 2 are repeated two times 
				and second occurence of 2 comes 
				before 1. So the output is 2 1.

			Your Task:
				The task is to complete the function repeatedElements() which takes array arr[] and 
				an integer N as inputs (the size of the array is N + 2 and elements are in the range[1, N]) 
				and finds the two repeated element in the array and return them in a list.

			Expected Time Complexity: O(N).
			Expected Auxiliary Space: O(1). 

			Constraints:
				2 ≤ N ≤ 105
				1 ≤ array[i] ≤ N

		class Solution {
			public:
			//Function to find two repeated elements.
			vector<int> twoRepeated (int arr[], int n) {
				
				vector<int> ans;
				vector<int> counts(n+2, 0);
				
				for(int i=0; i<n+2; i++){
					counts[arr[i]]++;
					if(counts[arr[i]] == 2)
						ans.push_back(arr[i]);
					
					if(ans.size()==2)
						break;
				}
				return ans;
			}
		};

	71) String Mania
		Rohit love strings. But he has many strings with him,
			and he is confused about which one he loves more. So
			he decided to come up with a scoring system for the
			strings. The scoring system took two strings as input,
			let's call them ‘STR1’ and ‘STR2’ of length ‘N’ and
			length ‘M’ respectively.
			The system will return ‘1’ if ‘STR1’ is better than ‘STR2’.
			The system will return ‘0’ if ‘STR1’ is the same as ‘STR2’.
			The system will return ‘-1’ if ‘STR2’ is better than ‘STR1’.
			To decide which string is better he followed the below steps.
			Let’s suppose there exists a index ‘i’ such that ‘0’ <= ‘i’ < ‘min(N,M)’ and for all ‘j<i’, ‘STR1[j]’ is equal to
			‘STR2[j]’, and ‘STR1[i] != STR2[i]’.
			Then if ‘STR1[i]>STR2[i]’, ‘STR1’ is better otherwise if
			‘STR2[i]>STR1[i]’, ‘STR2’ is better,
			And if there doesn’t exist any such ‘i’ then if ‘N>M’,
			‘STR1’ is better,
			And if ‘N<M’, ‘STR2’ is better, and if ‘N’ is equal to ‘M’,
			both strings are the same.
			But Rohit has so many strings, so he doesn’t have time
			to go through all strings, So being his friend can you
			help him automate this process?.

		Sample Input 1 :
			2
			1 3
			a
			abc
			3 3
			abz
			abc
		Sample Output 1 :
			-1
			1
		Explanation Of Sample Input 1 :
			For the first test case, ‘STR2’ is better than ‘STR1’, 
			as they are the same until the ‘0th’ index and then string ‘STR1’ ends and 
			as explained in the statement for ‘M>N’, the answer is ‘-1’.

			Hence, the output will be: -1

		For the second test case, ‘STR1’ is better than ‘STR2’, as they are the same until 
		the ‘1st’ index and then ‘STR1[2]>STR2[2]’.

		Hence, the output will be: 1
			Sample Input 2 :
				3
				2 3
				ez
				ehz
				5 5
				acefi
				acefi
				3 5
				ags
				agtaa
			Sample Output 2 :
				1
				0
				-1
		#include <bits/stdc++.h> 
		int stringMania(int n, int m, string str1, string str2) {
			if(str1 == str2)
				return 0;
			int i=0;
			while(i<n && i<m){
				if(str1[i] == str2[i]){
					i++;
					continue;
				}else if(str1[i] > str2[i]){
					return 1;
				}else{
					return -1;
				}
				i++;
			}
			return -1;
		}

	72) Count Of 3s:
		You are given an integer ‘N’. You simply need to find out the number of occurrences of 3 as a digit in the
			range of numbers from [0, N]. 
			Note: You need to count occurrences at every place of the number.
			For Example :
				You are given N = 13, then the number of occurrences 
				of 3 in range [0, 13] = 2 (3,13), you need to return 2.
			Sample Input 1:
				2
				13
				24
			Sample Output 1:
				2
				3
			Explanation For Sample Input 1:
			In the first test case, 
			Number of occurrences of 3 in range [0, 13] = 2 (3, 13). Return 2

			In the second test case, 
			Number of occurrences of 3 in range [0, 24] = 3 (3, 13, 23). Return 3
			Sample Input 2:
				2
				10
				33
			Sample Output 2:
				1
				8
			Explanation For Sample Input 2:
			In the first test case, 
			Number of occurrences of 3 in range [0, 10] = 1 (3). Return 1

			In the second test case, 
			Number of occurrences of 3 in range [0, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8

		#include <bits/stdc++.h> 
		long long int countOf3(int x) {
			long long int cnt=0;
			for(int i=3; i<=x; i++){
				int curNum = i;
				while(curNum>0){
					int lastDigit = curNum%10;
					if(lastDigit == 3)
						cnt++;
					curNum/=10;
				}
			}
			return cnt;
		}

	73) Valid String:
		There is a town named Chefland where Chef lives.
			One can only enter the Chefland through visa which is
			granted by head Chef of the town named Chef
			Sanjeev Kapoor. Chef Sanjeev is very interested in the
			validation of string.
			Hence he devised a test to get into the Chefland. Chef
			Sanjeev Kapoor considers a string to be valid if all
			characters of the string appear the same number of
			times. It is also valid if he can remove just 1 character
			at 1 index in the string, and the remaining characters
			will occur the same number of times. Given a string S,
			determine if it is valid. If so, return YES, otherwise
			return NO.
			For example, if S="abc", it is a valid string because
			frequencies are {a:1, b:1,c:1}. So is S="abcc" because
			we can remove one c and have 1 of each character in
			the remaining string. If S="abccc" however, the string
			is not valid as we can only remove 1 occurrence of c.
			That would leave character frequencies of {a:1, b:1,c:2}.
		
			Input Format:
				A single string S.
			Constraints:
				1 ≤ |S| ≤ 100000
				Each character s[i] belongs to [a-z]
			Time limit = 1 sec
			Output Format:
				Print YES if string S is valid, otherwise, print NO.
			
			Sample Input 1:
				aabbcd
			Sample Output 1:
				NO
			Sample Input 2:
				abcdefghhgfedecba
			Sample Output 2:
				YES
				Explanation:
				For testcase 2:
				All characters occur twice except for e which occurs 3 times. We can delete one instance of e to have a valid string.

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			string s;
			cin>>s;
			int charCountArr[26] = {0};
			
			//counting the characters..
			for(int i=0; i<s.length(); i++){
				charCountArr[s[i]-'a']++;
			}

			//checking count
			int cnt=0;
			int num = charCountArr[0];

			for(int i=1; i<26; i++){
				if(charCountArr[i] == num || charCountArr[i] == 0){
					continue;
				}else{
					cnt++;
				}
			}

			if(cnt<=1 || s.length()==1)
				cout<<"YES";
			else
				cout<<"NO";
			return 0;
		}

	74) Find the correct password:
		Mike is an evil plotting genius and has gotten hold of a
			list of all possible passwords for a certain user
			account. The first thing he noticed was all the
			passwords are of odd length. Mike assumes that the
			correct password is the one which can be found in
			both the original and reverse order in the list. For
			example, if the word “tulipan” would be the correct
			password, the word “napilut” has to also appear in the
			list. Given that both words are correct passwords,
			Mike will try to use both, one at a time.
			Help Mike discover what the correct password is and
			output its length and central character.
			Input Format:
				The first line of input contains the integer N, the number of possible
				passwords. Each of the following N lines contains a single word S, its length being an odd
				number. All characters are lowercase letters of the English alphabet.
			Constraints:
				1 ≤ N ≤ 100
				2 < S < 14
				Time limit = 1 sec
			Output Format:
				The first and only line of output must contain the length of the correct password
				and its central letter. The solution will be unique.
			
			Sample Input 1:
				4
				las
				god
				psala
				sal 
			Sample Output 1:
				3 a
			Sample Input 2:
				4
				kisik
				ptq
				tttrp
				tulipan 
			Sample Output 2:
				5 s
			Explanation:
				For testcase 1:
				The required pair of words is “las” and “sal”. Their length is 3 letters and the central character is 'a'.

				For testcase 2:
				The word “kisik” can be found in both the original and reverse order on the list (the word is a palindrome), so it is a valid correct password. 

		#include<bits/stdc++.h>
		using namespace std;
		int main() {
			int n;
			cin>>n;

			vector<string> s(n);
			for(int i=0; i<n; i++){
				string temp;
				cin>>temp;
				s[i] = temp;
			}
			int len=0,flg=0;
			char midL;
			for(int i=0; i<n; i++){
				string f1 = s[i];
				reverse(f1.begin(), f1.end());

				for(int j=0; j<n; j++){
					if(f1 == s[j]){

						len = f1.length();
						midL = f1[len/2];
						flg = 1;
						break;
					}
				}
				if(flg)
					break;
			}

			cout<<len<<" "<<midL;
			return 0;
		}

	75) Self Dividing Numbers:
		A Ninja wants to collect all possible self-dividing numbers from a given range of numbers.
			A self-dividing number is a number that is divisible by every digit it contains.
			For Example:
				128 is a self-dividing number because
				128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
			Given a ‘LOWER’ and ‘UPPER’ number bound, your
			task is to find all possible self-diving numbers in
			the range of ‘LOWER’ to ‘UPPER’.
			Note:
				A self-dividing number is not allowed to contain the digit zero.
				You do not need to print anything, it has already been taken care of. Just
				implement the given function.
			Sample Input 1:
				2
				10 30
				15 45
				Sample Output 1:
				11 12 15 22 24
				15 22 24 33 36 44
				Explanation For Sample Input 1:
				Test Case 1:

				For the first test case, the output [11, 12, 15, 22, 24] is the required list of self-dividing numbers containing only those numbers that have all the digits that can divide the number and do not contain the digit ‘0’ in it.

				Test Case 2:

				For the first test case, The output [15, 22, 24, 33, 36, 44] is the required list of self-dividing numbers containing only those set of numbers that have all the digits which can divide the number and that do not contain the digit ‘0’ in it.
			Sample Input 2:
				2
				1 22
				100 150
				Sample Output 2:
				1 2 3 4 5 6 7 8 9 11 12 15 22
				111 112 115 122 124 126 128 132 135 144

		#include <bits/stdc++.h> 
		vector < int > findAllSelfDividingNumbers(int lower, int upper) {

			//vector for storing the ans
			vector<int> ans;

			for(int i=lower; i<= upper; i++){
				int currentDigitHolder = i;
				int currentDigit = i;
				while(currentDigit>0){
					int lastDigit = currentDigit % 10;
					if(lastDigit == 0 || (currentDigitHolder % lastDigit != 0))
						break;
					currentDigit /=10;
				}
				if(currentDigit == 0)
					ans.push_back(i);
			}
			return ans;
		}

	76) Rearrange in Zig-Zag Order:
		https://www.codingninjas.com/studio/problems/zig-zag-array_1698577
		-just returned the empty vector (GLITCHED QUESTION).
		#include <bits/stdc++.h> 
		vector<int> zigZag(vector<int> arr, int n){
			vector<int> ans;
			return ans;
		}

	77) Fourth Largest Element in the Array:
		You are given an array consisting of 'N' integers. You have to find the fourth
			largest element present in the array. If there is no such number present in the
			array, then print the minimum value of an integer which is -2147483648.
			Follow Up: 
				Constraints :
				1 <= N < 10^6
				-10^6 <= element <= 10^6
			Time Limit: 1 sec
			Sample Input 1:
				5
				3 5 1 3 1
				Sample Output 1:
				1
				Explanation Of Sample Input 1:
				5 is the largest element, 3 is the second-largest element, again we have a 3 so it's the third largest and 1 is the fourth-largest, hence the answer 1.
				Sample Input 2:
				4
				9 9 9 9
				Sample Output 2:
				9
		//not optimized:
			#include <bits/stdc++.h>
			int getFourthLargest(int arr[], int n){
				if(n<4)
					return -2147483648;

				vector<int> ans(n);

				for(int i=0; i<n;i++){
					ans.push_back(arr[i]);
				}

				sort(ans.begin(), ans.end());
				reverse(ans.begin(), ans.end());
				return ans[3];
			}

	78) Next Smaller Element / Nearest Smaller Element:
		https://www.codingninjas.com/studio/problems/next-smaller-element_1112581

		//NOT Optimized:
			#include <bits/stdc++.h>
			vector<int> nextSmallerElement(vector<int> &arr, int n){
				int i=0;
				vector<int> ans;
				while(i<n){
					int currentNum = arr[i];
					int currentIndex = i+1;

					while(currentIndex < n){
						if(currentNum > arr[currentIndex]){
							ans.push_back(arr[currentIndex]);
							break;
						}
						currentIndex++;
					}
					if(currentIndex == n)
						ans.push_back(-1);
					i++;
				}
				return ans;
			}
		
		// Optimized:
			#include <bits/stdc++.h>
			vector<int> nextSmallerElement(vector<int> &arr, int n){
				vector<int> ans(n, -1);  // Initialize the result vector with -1.
				stack<int> st;  // Create a stack to keep track of indices.

				for (int i = 0; i < n; i++) {
					while (!st.empty() && arr[i] < arr[st.top()]) {
						ans[st.top()] = arr[i];  // Update the result for elements in the stack.
						st.pop();
					}
					st.push(i);  // Push the current index onto the stack.
				}
				return ans;   
			}

		#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			int main() {
				int n;
				cin>>n;
				vector<int> holder(n);
				
				for(int i=0;i<n;i++){
					cin>>holder[i];
				}
				
				for(int a: holder)
					cout<<a<<" ";
					
				std::cout << std::endl;
				
				vector<int> MainAns(n);
				
				for(int i=n-1;i>=0;i--){
					int currentElement = holder[i];
					int index = i-1;
					
					while(index>=0){
						if(currentElement > holder[index]){
							MainAns.push_back(holder[index]);
							break;
						}
						index--;
					}
					if(index<0)
						MainAns.push_back(-1);
				}
				
				std::cout << std::endl;
				reverse(MainAns.begin(), MainAns.end());
				for(int i=0; i<n; i++)
					cout<<MainAns[i]<<" ";
				
				return 0;
			}
			output:
			5
			11
			4
			24
			32
			32
			11 4 24 32 32 

			-1 -1 4 24 24 

	79) Added Character:
		You are given a string 'S'. Now one more additional character is introduced in this string, which turns 'S'
			into new string 'T'. You have to find out this newly added character.
			Note:
			1. All the characters in string 'S' and 'T' consist of uppercase English
			alphabets.
			2. Length of string 'T' is always 1 more than the length of string 'S'.
			Constraints:
				1 <= TEST <= 100
				1 <= |S|, |T| <= 10^4
				Where '|S|' and '|T|' denotes the length
				of he strings 'S' and 'T' respectively.
			Time Limit: 1 sec.

			Sample Input 1:
				2
				APPLE 
				APPHLE
				CODE
				CODER
				Sample Output 1:
				H
				R
				Explanation For Sample Output 1:
				In test case 1, As only character which is present in “APPHLE” but didn’t present in “APPLE” is ‘H’.

				In test case 2, As only character which is present in “CODER” but didn’t present in “CODE" is ‘R’.
				Sample Input 2:
				2
				MANGO 
				MANNGO
				NINJA
				NIINJA
				Sample Output 2:
				N
				I
				Explanation For Sample Output 2:
				In test case 1, As “MANGO” contains only 1 occurrence of ‘N’ but “MANNGO” contains 2 occurrences of ‘N’.

				In test case 2, As “NINJA” contains only 1 occurrence of ‘I’ but “NIINJA" contains 2 occurrences of ‘I’.

		#include <bits/stdc++.h> 
		char findAddedCharacter(string &s, string &t) {
			int i=0;
			while(i<s.length()){
				if(s[i] != t[i])
					return t[i];
				i++;
			}
			if(i==s.length())
				return t[t.length()-1];
		}
	
	80) Three Pointer:
		You are given three arrays X, Y and Z of size A,B and C
			respectively.Also, all three arrays are sorted in nondecreasing order. Find i, j, k such that : 0 <= i < A, 0 <=
			j < B, 0 <= k < C and max(abs(X[i] - Y[j]), abs(Y[j] - Z[k]), abs(Z[k] - X[i])) is minimized. 
			Your task is to return the minimum of all the max(abs(X[i] - Y[j]), abs(Y[j] - Z[k]), abs(Z[k] - X[i]))
			Note:
				1. All the arrays are sorted in nondecreasing order.
				2. abs(x) denotes the absolute value of x, i.e. if x<0, the abs function returns (-x)
					so that the final value of x becomes positive.
			Constraints:
				1 <= T <= 100
				1 <= A,B,C <= 10^4
				1 <= X[i] <= 10^4
				1 <= Y[i] <= 10^4
				1 <= Z[i] <= 10^4
				Time Limit: 1 sec
			
			Sample Input 1:
				1
					5
					1 2 3 4 5
					5
					1 3 5 7 9
					3
					2 4 6
					Sample Output 1:
					1 
					Explanation For Sample Input 1:
					For firstestcase :
					One of the possible answer is choose i = 0, j = 0 and k = 1.
					Thus it will 1 answer.
					Sample Input 2:
					1
					4
					1 1 1 1
					4
					2 2 2 2
					5
					7 7 7 7 7
					Sample Output 2:
					6

		//NOT Optimized:
			#include <bits/stdc++.h> 
			int threePointer(vector<int>& X, vector<int>& Y, vector<int>& Z){   
				int i,j,k,currentMax = INT_MAX;
				for(i=0;i<X.size(); i++){
					for(j=0; j<Y.size(); j++){
						for(k=0; k<Z.size();k++){
							int temp = max(abs(X[i]-Y[j]), max(abs(Y[j]-Z[k]), abs(Z[k]-X[i])));
							if(temp < currentMax)
								currentMax=temp;
						}
					}
				}
				return currentMax;
			}
		
		// Partially Optimized:
			#include <bits/stdc++.h> 
			int threePointer(vector<int>& X, vector<int>& Y, vector<int>& Z){	
				std::sort(X.begin(), X.end());
				std::sort(Y.begin(), Y.end());
				std::sort(Z.begin(), Z.end());

				int i = 0, j = 0, k = 0;
				int currentMax = INT_MAX;

				while (i < X.size() && j < Y.size() && k < Z.size()) {
					int maxX = X[i], maxY = Y[j], maxZ = Z[k];
					int minX = X[i], minY = Y[j], minZ = Z[k];

					int temp = std::max({abs(maxX - minY), abs(maxY - maxZ), abs(maxZ - minX)});
					currentMax = std::min(currentMax, temp);

					// Move the pointer associated with the minimum value
					if (X[i] <= Y[j] && X[i] <= Z[k]) {
						i++;
					} else if (Y[j] <= X[i] && Y[j] <= Z[k]) {
						j++;
					} else {
						k++;
					}
				}
				return currentMax;
			}

	81) Row Wave Form:
		Problem Statement
			You are given a 2D array with dimensions "N*M'. You need to read the array elements
			row-wise and return a linear array that stores the elements like a wave ie the 1st-
			row elements are stored from left to right, 2nd-row elements are stored from right to
			left, and so on.
			Constraints:
				1 <= (T' <= 10
				1 <= 'N', 'M' <= 10^3
				1 <= 'ARR[i][g] <= 10^5
			Where ARR[i][j] is the array element in the ith row of the jth column.
				Time limit: 1 second
			Sample Input 1:
				2
				2 2 
				1 2
				0 5
				2 3
				5 1 2
				7 0 1
			Sample Output 1:
				1 2 5 0
				5 1 2 1 0 7
				Explanation Of Input 1:
				For test case 1, the array is traversed as:
				The first row is traversed from left to right. -> [1, 2]
				The second row is traversed from right to left. -> [5, 0]
				Therefore the final answer is [1, 2, 5, 0].

				For test case 2, the array is traversed as:
				First row is traversed from left to right. -> [5, 1, 2]
				Second row is traversed from right to left. -> [1, 0, 7]
				Therefore the final answer is [5, 1, 2, 1, 0, 7]
			Sample Input 2:
				1
				3 3
				0 1 1
				8 0 9
				5 4 1
			Sample Output 2
				0 1 1 9 0 8 5 4 1
				Explanation Of Input 1:
				For test case 1, the array is traversed as:
				The first row is traversed from left to right. -> [0, 1, 1]
				The second row is traversed from right to left. -> [9, 0, 8]
				The third row is traversed from left to right -> [5, 4, 1]
				Therefore the final answer is [0, 1, 1, 9, 0, 8, 5, 4, 1]
		#include <bits/stdc++.h> 
		vector<int> rowWaveForm(vector<vector<int>> &mat) {
			vector<int> ans;
			for(int i=0; i<mat.size(); i++){
				int j;
				if(i&1){
					j=mat[0].size()-1;
					for(;j>=0;j--)
						ans.push_back(mat[i][j]);
				}else{            
					j=0;
					for(;j<mat[0].size();j++)
						ans.push_back(mat[i][j]);
				}
			}
			return ans;
		}

	82) Move Zeroes To End:
		Problem Statement
			Given an unsorted array of integers, you have to move the array elements in a way
			such that all the zeroes are transferred to the end, and all the non-zero elements are
			moved to the front. The non-zero elements must be ordered in their order of
			appearance.
			For example, if the input array is: [0, 1, -2, 3, 4, 0, 5, -27, 9, 0], then the output array
			must be:
			[1, -2, 3, 4, 5, -27, 9, 0, 0, 0].
			Expected Complexity: Try doing it in O(n) time complexity and O(1) space complexity.
			Here, 'n' is the size of the array.
			Sample Input 1:
				2
				7
				2 0 4 1 3 0 28
				5
				0 0 0 0 1
			Sample Output 1:
				2 4 1 3 28 0 0
				1 0 0 0 0
			The Explanation For Sample Output 1 :
				-In the first testcase, All the zeros are moved towards the end of the array, 
				and the non-zero elements are pushed towards the left, maintaining their order with respect to the original array.
				-In the second testcase, All zero are moved towards the end, 
				hence the only non-zero element i.e 1 is in the starting of the array 
			Sample Input 2:
				2
				5
				0 3 0 2 0
				4
				0 0 0 0
			Sample Output 2:
				3 2 0 0 0
				0 0 0 0

		void pushZerosAtEnd(vector<int> &arr) {
			int cnt=0;
			vector<int> ans;
			for(int i=0; i<arr.size() ; i++)
				if(arr[i] != 0)
					ans.push_back(arr[i]);
				else
					cnt++;
			
			for(int i=0; i<cnt; i++)
				ans.push_back(0);
			
			arr = ans;
		}

		//or in-place optimization:
			void pushZerosAtEnd(vector<int> &arr) {
				int nonZeroPos = 0;  // Initialize a pointer to track the position for non-zero elements

				for (int i = 0; i < arr.size(); i++)
					if (arr[i] != 0) {
						// Swap the current element with the element at nonZeroPos
						swap(arr[i], arr[nonZeroPos]);
						nonZeroPos++;
					}
			}

	83) Minimum and Maximum Cost to buy N Candies:
		Problem Statement
			Ram went to a specialty candy store in Ninjaland which has 'N' candies with different costs.
			The Candy shop gives a special offer to its customers. A customer can buy a single candy from
			the store and get at most 'K' different candies for free. Now, Ram is interested in knowing the
			maximum and the minimum amount he needs to spend for buying all the candies available in
			the store.
			Note: In both cases, Ram must utilize the offer i.e. if 'K' or more candies are available, he must
			take 'K' candies for every candy purchase. If less than K candies are available, he must take all
			candies for a candy purchase.
			For Example
				For 'N'= 5 and 'K' = 2
				Let the cost of different candies in the store be: [9 8 2 6 4]
				For the minimum amount:
				Ram can buy a candy with cost 2 and take candies with costs 9 and 8 for free.
				Then, he can buy a candy with cost 4 and take candy with cost 7 for free.
				Thus, the minimum cost will be 6 i.e. 2 + 4.
				For the maximum amount:
				Ram can buy a candy with cost 9 and take candies with costs 2 and 6 for free.
				Then, he can buy candy at cost 8 and take candy at cost 4 for free.
				Thus, the minimum cost will be 17 i.e. 9 + 8.
			Thus, Minimum = 6 and Maximum = 17.
			Sample Input 1:
				1
				4 2
				3 2 1 4
				Sample Output 1 :
				3 7
				Explanation :
				For the minimum amount: 
				Ram can buy candy with cost 1 and take candies with costs 3 and 4 for free. 
				Then, he can buy candy with cost 2.
				Thus, the minimum cost will be 3 i.e. 1 + 2. 

				For the maximum amount: 
				Ram can buy candy with cost 4 and take candies with costs 1 and 2 for free. 
				Then, he can buy candy with cost 3. 
				Thus, the minimum cost will be 7 i.e. 4 + 3.
			Sample Input 2:
				2
				5 2
				9 8 2 6 4
				3 0
				1 5 4
				Sample Output 2 :
				6 17
				10 10

		#include <bits/stdc++.h>
		long long minimumCost(vector<int> &cost, int n, int k){
			long long sum=0;
			// if(k==0){
			//     for(int i=0; i<n;i++)			//we can ignore these lines of code
			//         sum += cost[i];
			//     return sum;
			// }

			sort(cost.begin(), cost.end());
			int cnt=0, i=0;
			while(cnt<n){
				cnt += k+1;
				sum += cost[i++];
			}
			return sum;
		}

		// Function to calculate maximum cost.
		long long maximumCost(vector<int> &cost, int n, int k){
			long long sum=0;

			// if(k==0){
			//     for(int i=0; i<n;i++)			//we can ignore these lines of code
			//         sum += cost[i];
			//     return sum;
			// }

			sort(cost.begin(), cost.end());  //increasing order sorted
			reverse(cost.begin(), cost.end());  //decreasing order sorted
			int cnt=0, i=0;
			while(cnt<n){
				cnt += k+1;
				sum += cost[i++];
			}
			return sum;
		}

	84) Number of Good Indices:
		Problem statement:
			You are given an array 'A' of length 'N' consisting of positive integers. 
			Your task is to tell the number of 'good indices' in the array 'A'.
			An index 'X' is called a 'good index' if and only if:
			There are at least 2 indices 'i != X' and 'j != X', such that 'A[X] % A[i] = 0' and 'A[X] % A[j] = 0'.
			Your task is to return the number of 'good indices'.
			Example:
				'N' = 5
				'A' - [4, 2, 2, 6, 7]
				Here, index '9' is a good index because its value '4' is divisible by values
				present at the indices *1' and '2'. Similarly, index '3' is a good index.
				Therefore, the answer is '2
			Sample Input 1:
				2
				6
				4 8 6 3 7 1
				6
				4 1 10 4 5 9
				Sample Output 1:
				2
				3
				Explanation Of Sample Input 1:
				For test case 1:
				The good indices are '1' and '2' because, for index '1', there are two indices whose value perfectly divides the value present at the index '1', i.e., index '0' and index '5'. Similarly, for index '2', the two indices are '3' and '5'.

				For test case 2:
				The good indices are '0', '2' and '3'. For index '0', the two indices are '1' and '3', whose value at those indices in the array perfectly divides the array. Similar is the case for index '2' and '3'.
				Sample Input 2:
				2
				6
				3 10 7 4 2 10
				6
				4 5 4 8 1 4
				Sample Output 2 :
				2
				4
		
		int numberOfGoodIndices(int n, vector<int>& a) {
			int MainCNT=0;
			for(int i=0; i<n; i++){
				int currentNum= a[i],cnt=0;
				for(int j=0; j<n; j++){
					if(i==j)
						continue;
					if(currentNum%a[j] == 0)
						cnt++;
					if(cnt>=2){
						MainCNT++;
						break;
					}
				}
			}
			return MainCNT;
		}

	85) Find First and Last Position of Element in Sorted Array:
		https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
		Given an array of integers nums sorted in non-decreasing order, 
		     find the starting and ending position of a given target value.
			If target is not found in the array, return [-1, -1].
			You must write an algorithm with O(log n) runtime complexity.

			Example 1:
				Input: nums = [5,7,7,8,8,10], target = 8
				Output: [3,4]
			Example 2:
				Input: nums = [5,7,7,8,8,10], target = 6
				Output: [-1,-1]
			Example 3:
				Input: nums = [], target = 0
				Output: [-1,-1]
			Constraints:
				0 <= nums.length <= 105
				-109 <= nums[i] <= 109
				nums is a non-decreasing array.
				-109 <= target <= 109
		//Brute Force Tech, Optimized.
			class Solution {
				public:
				vector<int> searchRange(vector<int>& nums, int target) {
					vector<int> ans;
					//traversing from start
					for(int i=0; i<nums.size(); i++){
						if(nums[i] == target){
							ans.push_back(i);
							break;
						}
					}
				
					if(ans.size()==0)
						ans = {-1,-1};

					/* or
						if(ans.size()==0){
							ans = {-1,-1};
							return ans;
						}

						if(ans.size()==0)
							return {-1,-1};					
					*/
				
					//traversing from end
					for(int i=nums.size()-1; i>=0; i--){
						if(nums[i] == target){
							ans.push_back(i);
							break;
						}
					}
					return ans;
				}
			};
		
		//Binary Search Tech. Optimized
			class Solution {
				public:
				vector<int> searchRange(vector<int>& nums, int target) {
					int start=0,end=nums.size()-1;
					int mid = (start+end)/2;
					int found;
					while(start<=end){
						if(nums[mid] == target){
							found = mid;
							break;
						}else if(target<nums[mid]){
							end = mid-1;
						}else{
							start = mid+1;
						}
						mid = (start+end)/2;
					}

					if(start>end)
						return {-1,-1};

					int left = found, right = found;
					leftCheck:
					if(left>0 && nums[left] == nums[left-1]){
						left--;
						goto leftCheck;
					}

					rightCheck:
					if(right<nums.size()-1 && nums[right] == nums[right+1]){
						right++;
						goto rightCheck;
					}
					return {left, right};
				}
			};

	86) Minimum Maximum Value❌
		Sample Input 2:
			2
			2*3+4
			2*3+1*5*4
			Sample Output 2:
			10 14
			26 160

	87) Product Array Puzzle:
		Problem Statement
			You are given an array of 'N' integers. You need to return another array 'product' such that 'product[i]
			contains the product of all the arrays except the element at the ith position in the given array.
			Note
			As the product of elements can be very large you need to return the answer in mod (10^9+7).
			Follow Up
			Try to do this without using the division operator '/', in constant space. The output
			array does not count as extra space for the purpose of space complexity analysis
			Detailed explanation ( Input/output format, Notes, Images )
			Constraints:
			1 <= T <= 10^2
			2 <= N<= 10^4
			1 <= A[i] <= 10^9
			Where 'T' is the number of test cases, 'N' is the size of the array, 'A[i]' is the size
			of the array elements.
			Time Limit: 1 sec
			Sample Input 1:
				2
				5 
				1 3 3 10 2
				6 
				2 4 6 3 1 1
				Sample Output 1:
				180 60 60 18 90
				72 36 24 48 144 144
				Explanation For Sample Input 1:
				Test case 1:
				Product of elements except 1 = 3 * 3 * 10 * 2 = 180       
				Product of elements except 3 = 1  * 3 * 10 * 2 = 60       
				Product of elements except 3 = 1 * 3  * 10 * 2 = 60       
				Product of elements except 10 = 1 * 3 * 3 * 2 = 18       
				Product of elements except 2 = 1 * 3 * 3 * 10 = 90       

				Test case 2:
				Product of elements except 2 = 4 * 6 * 3 * 1 * 1 = 72   
				Product of elements except 4 = 2 * 6 * 3 * 1 * 1 = 36   
				Product of elements except 6 = 2 * 4 * 3 * 1 * 1 = 24   
				Product of elements except 3 = 2 * 4 * 6 * 1 * 1 = 48  
				Product of elements except 1 = 2 * 4 * 6 * 1 * 1 = 144   
				Product of elements except 1 = 2 * 4 * 6 * 3 * 1 = 144  
				Sample Input 2:
				2
				5 
				1 10 1 2 2
				6
				2 12 1 1 20 1 
				Sample Output 2:
				40 4 40 20 20
				240 40 480 480 24 480
				Explanation For Sample Input 2:
				Test case 1:
				Product of elements except 1 = 10 * 1 * 2 * 2 = 40      
				Product of elements except 10 = 1  * 1 * 2 * 2 = 4      
				Product of elements except 2 = 1 * 10 * 1 * 2 = 20
				Product of elements except 2 = 1 * 10 * 1 * 2 = 20       

				Test case 2:
				Product of elements except 2 = 12 * 1 * 1 * 20 * 1 = 240
				Product of elements except 12 = 2 * 1 * 1 * 20 * 1 = 40 
				Product of elements except 1 = 2 * 12 * 1 * 20 * 1 = 480   
				Product of elements except 1 = 2 * 12 * 1 * 20 * 1 = 480
				Product of elements except 20 = 2 * 12 * 1 * 1 * 1 = 24  
				Product of elements except 1 = 2 * 12 * 1 * 1* 20 = 480

		//NOT Optimized:
			#include <bits/stdc++.h> 
			vector <int> productPuzzle(vector <int> & arr, int n) {
				vector <int> ans;
				int mod = 1e9+7;
				for(int i=0; i<n; i++){
					long long sum = 1;
					for(int j=0; j<n; j++){
						if(i==j)
							continue;
						sum *= arr[j];
						sum %= mod;
					}
					ans.push_back(sum);
				}
				return ans;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			vector <int> productPuzzle(vector <int> & arr, int n) {
				vector<int> ans(n, 1); // Initialize ans with 1's
				int mod = 1e9 + 7;

				// Calculate the prefix product from the left
				long long left_product = 1;
				for (int i = 0; i < n; i++) {
					ans[i] = (ans[i] * left_product) % mod;
					left_product = (left_product * arr[i]) % mod;
				}

				// Calculate the suffix product from the right
				long long right_product = 1;
				for (int i = n - 1; i >= 0; i--) {
					ans[i] = (ans[i] * right_product) % mod;
					right_product = (right_product * arr[i]) % mod;
				}
				return ans;
			}
		
	88) Swap Adjacent Bit Pairs:
		Problem Statement
			You are given an integer 'N'. Your task is to find the number formed after swapping each even bit of 'N' in its binary
			representation with its adjacent bit on the right, assuming that the least significant bit is an odd bit.
			For example:
				Consider the integer N = 45 whose binary representation is 101101. The resulting number formed
				after swapping each even bit with its adjacent bit to the right will be 30 (011110) in this case.
				Detailed explanation ( Input/output format, Notes, Images )
			Input Format :
				The first line of the input contains an integer, 'T,' denoting the number of test cases.
				The first and only line of each test case contains the integer 'N'
				Output Format :
				For each test case, print the resulting integer formed after swapping each even bit.
				Print the output of each test case in a new line.
				Note:
				You do not need to print anything. It has already been taken care of. Just implement the given function.
			Constraints:
				1 <= T <= 10^5
				1 <= N <= 10^9
			Time Limit: 1 sec
			Sample Input 1 :
				2
				9
				2
				Sample Output 1 :
				6 
				1
				Explanation For Sample Input 1 :
				For the first test case : 
				The binary representation of 9 is 1001. Here, we will swap the 2nd bit with the 1st bit and the 4th bit with 3rd bit. The resulting binary number will be 0110. Hence, the answer is 6 in this case.

				For the second test case : 
				The binary representation of 2 is 10. Here, we will swap the 2nd bit with the 1st bit. The resulting binary number will be 01 or 1. Hence, the answer is 1 in this case.
				Sample Input 2 :
				2
				7
				10
				Sample Output 2 :
				11
				5
		#include <bits/stdc++.h> 
		int swapAdjacentBits(int n){ 
			
			//creating empty string
			string s;

			//converting num to binary representation & storing it in string
			s = bitset<32>(n).to_string();

			//removing trailing zeros
			while(1){
				if(s[0] != '0')
					break;
				s.erase(0,1);
			}

			//its the length is odd then adding extra 0 char at beginning of string
			if(s.length() % 2 !=0)
				s.insert(s.begin(),'0');

			// cout<<s<<"\n";
			//swapping even bits with right
			for(int i= s.length()-1; i>=0; i-=2){
				swap(s[i],s[i-1]);
			}
			// cout<<s<<"\n";

			//to Binary Conversion,
			//converting the binary string back to num
			int cnt=0;
			int newNum=0;
			for(int i=s.length()-1; i>=0; i--){
				// newNum += (s[i]-48)*pow(2,cnt++);
				//or
				newNum += (s[i]- '0')*pow(2,cnt++);
			}
			return newNum;
		}

	89) Smallest number divisible by K:
		Problem Statement
			Ninja's favorite numbers are the numbers whose all digits are '1' So Let's consider numbers that have only the digit
			'1'. For example, ('1', '11' '111'...].
			You are given an integer 'K' Your task is to find the number of digits in the Ninja's smallest favorite number that is
			divisible by 'K'. If there is no such number that is divisible by 'K', then return -1.
			Detailed explanation (Input/output format, Notes, Images )
			Input Format:
				The first line contains an integer 'T' which denotes the number of test cases or queries to be
				The first line of each test case contains an integer denoting the value of 'K'.
			Output Format:
				For each test case, print a single line containing a single integer denoting the number of digits
				in the smallest number that is divisible by given 'K' if it exists else print -1°
				The output of each test case will be printed in a separate line.
			Note:
			You do not need to input or print anything, and it has already been taken care of. Just implement
			the given function.
			Constraints:
				142 T/= 5
				1 <= K <= 10 ^ 5
			Where 'T' is the total number of test cases, and 'K' is the given integer.
			Sample Input 1:
				2
				1
				8
				Sample Output 1:
				1
				-1
				Explanation of Sample Input 1:
				Test case 1:
				‘1’ is itself divided by one, that has only 1 digit, hence the answer will be 1.

				Test case 2:
				There is no number whose all digits are ‘1’ and divisible 8 , so the answer will be -1.
				Sample Input 2:
				1
				11
				Sample Output 2:
				2
				Explanation of Sample Input 2:
				Test case 1:
				‘11’ is itself divided by 11 which have 2 digits hence the answer will be 2.

		#include <bits/stdc++.h> 
		int lengthOfNumber(int k){

			//it will work till 18 digit checks,
			// long long arr[] = {1,11,111,1111,11111, 111111, 1111111, 11111111, 111111111, 1111111111, 11111111111, 111111111111,
			// 			 1111111111111, 11111111111111, 111111111111111, 1111111111111111, 11111111111111111, 111111111111111111 };
			// int digit=0;
			// for(int i=0;; i++){
			// 	if(arr[i] % k ==0){
			// 		return i+1;
			// 	}
			// }
			// return -1;

			unordered_set<int> remainders;
			int currentRemainder = 1 % k;
			int num_digit = 1;
			while(currentRemainder !=0 ){
				currentRemainder = (currentRemainder*10 +1)%k;
				num_digit++;
				if(remainders.find(currentRemainder) != remainders.end())
					return -1;
				remainders.insert(currentRemainder);
			}
			return num_digit;
		}

	90) Check If Given Words Are Present In A String:
		Problem Statement
			Given a string 'S' and a list 'wordList' that consists of 'N' distinct words. Let 'Wi' denote word at index 'i in 'wordList'.
			For each word 'Wi' in 'wordList', you need to determine whether it is present in string 'S' or not. Return a boolean
			array, where a boolean value at index ' represents whether the word 'Wi' is present in the string 'S' or not.
			Detailed explanation (Input/output format, Notes, Images
			Constraints:
				1 < T <= 50
				1 <= |S| <= 10^3
				1 <• N <= 10^3
				1 <= |W| <= 10
			Where |S|' denotes the length of string and |w| denotes the maximum length of the word present in 'wordList'
			Time limit: 1 sec
			Sample Input 1 :
				2
				This is a large String
				4
				This this is age 
				ILikeCodingNinjas
				3
				Ninja Coding Code
				Sample Output 1 :
				True False True False
				True True False
				Explanation Of Sample Input 1 :
				Test case 1:

				Here String ‘S’ is “This is a large String” and ‘wordList’ is [“This”, “this”, “is”, “age”] 

				The word “This” is present from index ‘0’ to index ‘3’ in ‘S’.
				The word “this” is not present in ‘S’.
				The word “is” is present from index ‘2’ to index ‘3’’ and from  ‘5’ to index ‘6’  in ‘S’. 
				The word  “age” is not present in ‘S’.
				Note:  All words are case sensitive and we consider 0 based indexing in 'S'.

				Test case 2:

				Here String ‘S’ is “ILikeCodingNinjas” and ‘wordList’ is [“Ninja” “Coding” “Code”] 

				The word “Ninja” is present from index ‘11’ to index ‘15’ in ‘S’.
				The word “Coding” is present from index ‘5’ to index ‘10’ in ‘S’.
				The word “Code” is not present in  ‘S’. 
				Sample Input 2 :
				3
				This is String
				2
				This String
				Code Infy
				3
				C I F
				coding
				1
				CodingNinjas
				Sample Output 2 :
				True True 
				True True False 
				False 
				Explanation Of Sample Input 2 :
				Test case 1:
				Here String ‘S’ is “This is String” and ‘wordList’ is [“This”, “String” ] 

				The word “This” is present from index ‘0’ to index ‘3’ in ‘S’.
				The word  “String” is present from index ‘8’ to index ‘13’’ in ‘S’. 

				Test case 2:

				Here String ‘S’ is “Code Infy” and ‘wordList’ is [“C” “I” “F”] 

				The word “C” is present at index ‘0’ ’ in ‘S’.
				The word “I”  is present at index ‘5’ in ‘S’.
				The word “F” is not present in  ‘S’. 

				Test case 3:

				Here String ‘S’ is “Coding” and ‘wordList’ is [“ CodingNinjas”] 

				The word “CodingNinjas” is not in ‘S’.
		#include <bits/stdc++.h> 
		vector<bool> checkWordsInString(string &s, int n, vector<string> &wordList) {
			vector<bool> ans(n);
			for(int i=0; i<n; i++){
				string sub = wordList[i];
				if(s.find(sub) != string::npos)
					ans[i]=1;
				else
					ans[i]=0;
			}
			return ans;
		}	

	91) Find Peak Element
		Problem Statement
			You are given an array 'arr' of length 'n' Find the index(0-based) of a peak element in the array. 
			If there are multiple peak numbers, return the index of any peak number.
			Peak element is defined as that element that is greater than both of its neighbors. 
			If 'arr[i]' is the peak element, 'arr[i -1]' < 'arrfil' and 'arr[i + 1]' < 'arril'
			Assume 'arr[-1]' and 'arr[n]' as negative infinity.
			Note:
				1. There are no 2 adjacent elements having same value (as mentioned in the constraints).
				2. Do not print anything, just return the index of the peak element (0 - indexed).
				3. 'True'/'False' will be printed depending on whether your answer is correct or not.
			Example:
			Input: 'arr' = [1, 8, 1, 5, 3]
			Output: 3
			Explanation: There are two possible answers. Both 8 and 5 are peak elements, so the correct
			answers are their positions, 1 and 3.
			Sample Input 1:
				5
				1 8 1 5 3
				Expected Answer:
					1

				Output On Console:
					True

				Explanation Of Sample Input 1 :
				There are two possible answers. Both 8 and 5 are peak elements, so the correct answers are their positions, 1 and 3. Any of these 2 numbers will print 'True'.

				Sample Input 2:
					3
					1 2 1 

				Expected Answer:
					1

				Output On Console:
					True

				Expected Time Complexity:
					The expected time complexity is O(log 'n').


				Constraints:
					1 <= 'n' <= 10^5
					1 <= 'arr[i]' <= 10^5
					'arr[i]' != 'arr[i + 1]' for all 'i' in range 0 <= 'i' < 'n' - 1

		int findPeakElement(vector<int> &arr) {

			//this not working for edge test case like arr[-1] & arr[n];
			//  for(int i=1; i<arr.size()-1; i++){
			//     if((arr[i]> arr[i-1]) && (arr[i]>arr[i+1]))
			//         return i;
			// }
			// return 0;
			int left = 0;
			int right = arr.size() - 1;

			while (left < right) {
				int mid = (left + right) / 2;
				if (arr[mid] > arr[mid + 1]) {
					right = mid;
				} else {
					left = mid + 1;
				}
			}

			return left;
		}

	92) Container With Most Water:
		Given a sequence of 'N' space-separated non-negative integers A [1], A [2], A [3]…....A [i].....A[n]. Where each
		number of the sequence represents the height of the line drawn at point '. Hence on the cartesian plane,
		each line is drawn from coordinate (I',O) to coordinate ('i', 'A[i]'), here 'i' ranges from 1 to 'N'. Find two lines,
		which, together with the x-axis forms a container, such that the container contains the most area of water.
		Note:
			1. You can not slant the container i.e. the height of the water is equal to the minimum
			height of the two lines which define the container.
			2. Do not print anything, you just need to return the area of the container with maximum
			water
		
		Sample Input 1 :
			2
			5
			4 3 2 1 4
			3
			1 2 1
			Sample Output 1 :
			16
			2 
			Explanation Of The Sample Input 1:
			For the first case: 
			We can create ‘n(n+1)/2’ different containers using ‘N' containers for example with 1st and 3rd line we can create a container of area = (3-1)*min(4,2)=4.

			All Possible Containers:  


			Lines used          Area
			4,3         area=min(4,3)*1=3
			4,2         area=min(4,2)*2=4
			4,1         area=min(4,1)*3=3
			4,4         area=min(4,4)*4=16
			3,2         area=min(3,2)*1=2
			3,1         area=min(3,1)*2=2
			3,4         area=min(3,4)*3=9
			2,1         area=min(2,1)*1=1
			2,4         area=min(2,4)*2=4
			1,4         area=min(1,4)*1=1

			But among all such containers the one with the maximum area will be formed by 
			using the first and last line, the area of which is : (5-1)*min(4,4)=16.
			Hence we return 16.

			For the second case: 
			We can take the first and third line to get an area of 
			(3-1)*min(1,1)=2 which is the maximum possible area in this sequence.
			Sample Input 2 :
				2
				5
				12 4 6 8 1
				3
				1 2 3
				Sample Output 2 :
				24
				2


		//Not Optimized:
			int maxArea(vector<int>& height) {
				int ans=0;
					for(int i=0; i<height.size(); i++){
					int dist = 1;
					for(int j=i+1; j<height.size(); j++){
						int minn = (min(height[i],height[j]))* dist;
						ans = max(ans, minn);
						dist++;
					}
				}
				return ans;
			}

		//Optimized:
			int maxArea(vector<int>& height) {
				int left=0;
				int right=height.size()-1;
				int mxArea=0;

				while(left < right){
					int minH = min(height[left],height[right]);
					int dist = right-left;
					
					int newArea = minH * dist;
					mxArea = max(mxArea,newArea);

					if(height[left] < height[right]){
						left++;
					}else{
						right--;
					}
				}
				return mxArea;
			}
			
	93) Interesting Alphabets:
		As a part of its competition, the school will conduct a codeathon, Lock the Code, where it has been given a
		value, and the participants have to decode it.
		The participants are given a value denoting the number of rows in the matrix; they need to print the pattern.
		Example:
			For N=5, Pattern:
			E
			DE
			CDE
			BCDE
			ABCDE
			Among the participants, Ninja is new to programming and doesn't have much experience; he asks you to
			solve the problem. Can you help solve this problem?
		Sample Input 1:
			2
			5
			4
			Sample Output 1:
			E
			DE
			CDE
			BCDE
			ABCDE

			D
			CD
			BCD
			ABCD
			Explanation For Sample Input 1:
			In the first test case, value of ‘N’ is 5, so print the ‘N’ rows from 1 to ‘N’ where in each row start from (N - i - 1)the character which goes on till ‘Nth character. Hence the answer is [‘E’,’DE’,’CDE,’ BCDE’,’ABCDE’].

			In the second test case, the value of ‘N’ is 4, so print the ‘N’ rows from 1 to ‘N’ where each row starts from (N - i - 1)the character, which goes on till ‘Nth character. Hence the answer is [‘D’,’CD’,BCD’,’ABCD’].
			Sample Input 2:
			2
			3
			2
			Sample Output 2:
			C
			BC
			ABC

			B
			AB

		#include <bits/stdc++.h> 
		vector<vector<char>> interestingPattern(int n){
			vector<vector<char>> ans;
			vector<char> temp;
			char ch1 = 'A'+ (n-1);
			for(int j=n-1; j>=0; j--){
				char ch = ch1;
				for(int i=n-1; i>=j; i--){
					temp.push_back(ch++);
				}
				ans.push_back(temp);
				temp.clear();
				ch1--;
			}
			return ans;
		}

		#include <bits/stdc++.h> 
		vector<vector<char>> interestingPattern(int n){
			char ch = 64+n;
			vector<vector<char>> ans;
			for(int i=0; i<n; i++){
				char currentCh = ch--;
				vector<char> temp;
				for(int j=0; j<=i; j++){
					temp.push_back(currentCh++);
				}
				ans.push_back(temp);
			}
			return ans;
		}

	94) Isomorphic Strings:
		Problem Statement
			You have been given two strings, 'str1'and 'str2'
			Your task is to return true if the given two strings are isomorphic to each other, else return false.
			Note :
			Two strings are isomorphic if a one-to-one mapping is possible for every character of the
			first string 'str1' to every character of the second string 'str2' while preserving the
			order of the characters.
			All occurrences of every character in the first string 'str1' should map to the same
			character in the second string, 'str2'
			For Example:
			If stri = "aab" and str2 = "xxy" then the output will be 1. 'a' maps to 'x' and 'b' maps
			to 'y'.
			If stri = "aab" and str2 = "xyz" then the output will be 0. There are two different
			characters in 'strl', while there are three different characters in 'str2'. so there won't
			be one to one mapping between 'stri' and 'str2'
			Sample Input 1 :
				aab 
				xxy
				Sample Output 1 :
				1
				Explanation Of Sample Input 1:
				The character ‘a’ maps to ‘x’ and ‘b’ maps to ‘y’. Hence, the answer is 1 in this case.
				Sample Input 2 :
				aab
				xyz
				Sample Output 2 :
				0
				Constraints :
				1 <= |str1|, |str2| <= 10^3

				|str1| is the length of the string str1, and |str2| is the length of the string str2.
				Follow Up:
				Can you solve this in O(N) time?

		bool areIsomorphic(string &str1, string &str2){
			
			if(str1.length() !=  str2.length())
				return 0;

			vector<int> countStr1(26,0);
			vector<int> countStr2(26,0);

			//mapper for str1;
			for(int i=0; i<str1.length(); i++)
				countStr1[str1[i]-'a']++;
			
			//mapper for str2;
			for(int i=0; i<str2.length(); i++)
				countStr2[str2[i]-'a']++;

			sort(countStr1.begin(), countStr1.end());
			sort(countStr2.begin(), countStr2.end());
			
			for(int i=0; i<26; i++)
				if(countStr1[i] != countStr2[i])
					return 0;
			return 1;
		}
		
	95) Cyclically Rotate An Array By One:
		You are given an integer array of size N. Your task is to rotate the array by one position in the clockwise direction.
		For Example:
			If N = 5 and arr[ ] = (1, 2, 3, 4, 5} then output will be 5 1 2 3 4.
			If N = 8 and arr[ ] = {9, 8, 7, 6, 4, 2, 1, 3] then output will be 3 9 8 7 6 4 2 1.
		Sample Input 1 :
			5
			1 2 3 4 5
			Sample Output 1 :
			5 1 2 3 4
			Explanation For Sample Input 1 :
			The first four elements are shifted towards the right by one position, and the last element i.e. 5 is shifted to the first position.
			Sample Input 2 :
			1
			8
			9 8 7 6 4 2 1 3
			Sample Output 2 :
			3 9 8 7 6 4 2 1

		//Optimized:
			#include <bits/stdc++.h> 
			void rotate(vector<int>& arr, int n) {
				int lastDigit = arr[n-1];
				for(int i=n-1; i>0; i--){
					arr[i] = arr[i-1];
				}
				arr[0] = lastDigit;
			}
		
		//more optimized:
			#include <bits/stdc++.h> 
			void rotate(vector<int>& arr, int n) {
				int lastDigit = arr.back();
				arr.pop_back();
				arr.insert(arr.begin(), lastDigit);    
			}

	96) Program to check the validity of a Password:
		problem statement:
			Ninjas are trying to hack a system of a terrorist organization so that they can know where they will be going
			to attack next. But to hack the system and to get access to data they need a password that must satisfy
			certain conditions as described below:
			1) Length of the password must be between 8 to 15 characters.
			2) At least one digit (0-9), one lowercase letter (a-z), one uppercase letter (A-Z) and
			one special character (%, ^, &, #, *, %, etc) must be present.
			3) Password must not contain any space.
			You are given a string 'STR', help ninjas to find whether it's a valid password or not.
			For example:
			Given 'STR' = "Codingninja#" As it satisfies all the above conditions so it is a valid
			password and therefore you have to return true.
			Sample Input 1:
				3
				CODiNGNinja+1
				abcXyz 123
				itsnotValid1
				Sample Output 1:
				Valid
				Not Valid
				Not Valid
				Explanation of Sample Input 1:
				Test Case 1 :  
				Given ‘STR’ = CODiNGNinja+1
				As we can see that this string satisfies all the given conditions in the problem.
				Therefore, it's a valid password.

				Test Case 2 : 
				Given ‘STR’ = abcXyz 123 
				As the given string contains a space, so it's not a valid password.

				Test Case 3:
				Given ‘STR’ =  itsnotValid1
				As the string does not contain any special character, so it’s not a valid password.
				Sample Input 2:
				3
				&1CodingISBest
				Ab@3
				HEllo@World#0
				Sample Output 2:
				Valid
				Not Valid
				Valid

		//optimized
			bool isValid(string &str) {
				if(str.length()<8 || str.length()>15)
					return 0;

				//checking contain digit
				int cnt=0;
				for(int i=0; i<str.length(); i++){
					if(isdigit(str[i])){
						cnt++;
						break;
					}
				}
				if(cnt==0)
					return 0;
				
				//checking lowercase char
				cnt=0;
				for(int i=0; i<str.length(); i++){
					if(islower(str[i])){
						cnt++;
						break;
					}
				}
				if(cnt==0)
					return 0;

				//checking uppercase char
				cnt=0;
				for(int i=0; i<str.length(); i++){
					if(isupper(str[i])){
						cnt++;
						break;
					}
				}
				if(cnt==0)
					return 0;

				//checking contain space?
				for(int i=0; i<str.length(); i++){
					if(isblank(str[i])){
						return 0;
					}
				}
				return 1;		
			}

		//more optimized:
			bool isValid(string &str) {
				int length = str.length();
				
				// Check length
				if (length < 8 || length > 15) {
					return false;
				}

				bool hasDigit = false;
				bool hasLowercase = false;
				bool hasUppercase = false;

				for (int i = 0; i < length; i++) {
					if (isdigit(str[i])) {
						hasDigit = true;
					} else if (islower(str[i])) {
						hasLowercase = true;
					} else if (isupper(str[i])) {
						hasUppercase = true;
					}
					
					if (str[i] == ' ') {
						return false;  // Check for spaces
					}
				}

				// Check for at least one digit, lowercase, and uppercase
				return hasDigit && hasLowercase && hasUppercase;	
			}

		//or
			bool isValid(string &str){
				if(str.length()<8 || str.length()>15)
					return 0;
				
				bool atLeastOneDigit, atLeastOneLowercase, atLeastOneUppercase, atLeastOneSpecialChar;
				atLeastOneDigit = atLeastOneLowercase = atLeastOneUppercase = atLeastOneSpecialChar = 0;

				for(int i=0; i<str.length(); i++){
					if(str[i] ==  ' ')
						return 0;

					if(isdigit(str[i]))
						atLeastOneDigit=1;
					else if(islower(str[i]))
						atLeastOneLowercase=1;
					else if(isupper(str[i]))
						atLeastOneUppercase =1;
					else
						atLeastOneSpecialChar=1;	
				}
				return atLeastOneSpecialChar && atLeastOneDigit && atLeastOneLowercase && atLeastOneUppercase;
			}

	97) Pascal's Triangle II:
		https://leetcode.com/problems/pascals-triangle-ii/description/
			#include <iostream>
			#include<vector>
			using namespace std;

			vector<int> getRow(int rowIndex) {
				vector<int> ans;
				if(rowIndex == 0)
					return {1};
				else if(rowIndex == 1)
					return {1,1};
				else{
					ans = {1,1};
					for(int i=1; i<rowIndex; i++){
						vector<int> temp;
						temp.push_back(1);
						for(int j=0; j<rowIndex-1; j++){
							int num = ans[j]+ans[j+1];
							temp.push_back(num);
						}
						temp.push_back(1);
						ans.clear();
						ans = temp;
					}
					// ans.pop_back();
					}
					return ans;
				}
			int main(){
				
				vector<int> ansss;
				ansss = getRow(4);
				for(int z: ansss)
					std::cout << z << "\t";
				return 0;
			}

		//leetcode working code:
			class Solution {
				public:
				vector<int> getRow(int rowIndex) {
					vector<int> ans(rowIndex + 1, 0);  // Initialize the result vector with 0s.
					ans[0] = 1;  // The first element of each row is always 1.

					for (int i = 1; i <= rowIndex; i++) {
						for (int j = i; j >= 1; j--) {
							ans[j] += ans[j - 1];
						}
					}
					return ans;
				}
			};

		//GFG Pascal Triangle:
			class Solution{
				public:
				vector<long long> nthRowOfPascalTriangle(int n) {
					vector<long long> ans;
					int mod = 1e9+7;
					if(n == 1)
						return {1};
					else if(n==2)
						return {1,1};
					else{
						ans = {1,1};
						for(int i=1; i<n-1; i++){
							vector<long long> temp;
							temp.push_back(1);
							for(int j=0; j<ans.size()-1; j++){
								int num = (ans[j] + ans[j+1]) % mod;
								temp.push_back(num);
							}
							temp.push_back(1);
							ans.clear();
							ans = temp;
						}
						return ans;
					}
				}
			};

	98) Count Squares:
		Problem Statement
			You are given a matrix of size N* M. Can you count the number of squares in it?
			As the count will be very large, so compute it with modulo 10^9 + 7.(1e9+7)
			For Example:
				Let N = 3 and M = 5
				The number of squares of size 1 will be 15.
				The number of squares of size 2 will be 8.
				The number of squares of size 3 will be 3
				Thus the answer will be 26.
			Constraints:
				1 <= T <= 10^5
				1 <= N <= 10^9
				1 <= M <= 10^9
			Time limit: 1 sec
			Sample Input 1:
				2		
				3 5
				2 3
				Sample Output 1:
				26
				8
				Explanation
				Test Case 1: Refer to the example described above.

				Test Case 2:
				The number of squares of size 1 will be 6.
				The number of squares of size 2 will be 2.
				Thus, the answer will be 8.
				Sample Input 2:
				3
				1 8
				6 4
				3 3
				Sample Output 2:
				8
				50
				14
		//not Optimized:
			#include <bits/stdc++.h> 
			int countSquares(int n, int m){
				long long SUM=0;
				int mod = 1e9+7;

				int iterator = n;
				for(int i=0; i< iterator; i++){
					SUM = (SUM + (n*m)%mod)%mod;
					n--; m--;
					if(m==0)
						break;
				}
				return SUM;
				
					//or
				// int mod = 1e9 + 7;
				// long long SUM = 0;
				// int iterator = std::min(n, m); // Use the minimum of n and m to determine the number of squares.

				// for (int i = 1; i <= iterator; i++) {
				//     SUM = (SUM + 1LL*(n) * m) % mod;            //or we can use static_cast<long long> to convert int to long long instead of 1ll or 1LL
				//                                             //SUM = (SUM + static_cast<long long>(n) * m) % mod;
				//     n--;
				//     m--;
				// }
				// return SUM;
			}

	99) Win or Lose
		Problem Statement
			You and your friends are playing a turn-based game. You will make the first move. 
			Initially, you have an integer 'N'. On each player's turn, that player makes a move consisting of two steps.
				1) Choose an integer 'i such that 0 < 'ї < 'N' and 'N" is divisible by 'ї.
				2) Update number 'N' to 'N -ї.
			If a player cannot make a move, they lose the game.
			You are given the initial number 'N: You have to print "YES" if you win the game; otherwise, print "NO".
			For example:
			If the number 'N' = 6 and you select "i to be 2, then the new number N' will be 6 - 2 = 4.

		Sample Input-1
			2
			2
			3
			Sample Output-1
			YES
			NO
			Explanation For Sample Input 1:
			For test case 1:
			You can choose only ‘1’; the new number becomes 2 - 1 = 1.
			Your friend can’t make any move. Hence you win the game.
			For test case 2:
			You can choose only ‘1’; the new number becomes 3 - 1 = 2.
			Your friend can choose only ‘1’; the new number becomes 2 - 1 = 1.
			You can’t make any move. Hence you lose the game.
			Sample Input -2
			2
			13
			16
			Sample Output -2
			NO
			YES
		
		#include <bits/stdc++.h>
		string winOrLose(int N) {
			if(N&1)
				return "NO";
			return "YES";
		}

	100) Leaders in an array:
		Problem Statement
			Given a sequence of numbers. Find all leaders in sequence. An element is a leader if it is strictly greater than
			all the elements on its right side.
			Note:
				1. Rightmost element is always a leader.
				2. The order of elements in the return sequence must be the same as the given sequence
			Example:
				The given sequence is 13, 14, 3, 8, 2 •
				13 Not a leader because on the right side 14 is greater than 13.
				14 lt is a leader because no one greater element in the right side.
				3 Not a leader because on the right side 8 are greater than 3.
				8 It is a leader because no one greater element on the right side.
				2 It is a leader because it is the rightmost element in a sequence.
			Hence there are 3 leaders in the above sequence which are 14, 8, 2.
			Sample Input 1:
				2
				6
				6 7 4 2 5 3
				4
				11 10 9 8
				Sample Output 1:
				7 5 3
				11 10 9 8
				Explanation Of Sample Output 1:
				In test case 1,
					6 Not a leader because on the right side 7 is greater than 6.
					7 lt is a leader because no one greater element in the right side.
					4 Not a leader because on the right side 5 are greater than 4.
					2 Not a leader because on the right side 5, 3 are greater than 2.
					5 lt is a leader because no one greater element in the right side.
					3 It is a leader because it is a rightmost element in a sequence.
					Hence there are 3 leaders in sequence 7, 5, 3. 

				In test case 2,
					Given sequence is in descending order, so all elements are leaders

				Sample Input 2:
					2
					6
					5 10 11 12 -1 -2
					4
					10 -11 -3 -2
					Sample Output 2:
					12 -1 -2
					10 -2
				Explanation Of Sample Output 2:
				In test case 1,
					5 Not a leader because on the right side 10 is greater than 5.
					10 Not a leader because on the right side 11 is greater than 10.
					11 Not a leader because on the right side 12 are greater than 11.
					12 lt is a leader because no one greater element in the right side.
					-1 lt is a leader because no one greater element in the right side.
					-2 It is a leader because it is a rightmost element in a sequence.
				Hence there are 3 leaders in sequence 12, -1, -2. 
				In test case 2,
					10 lt is a leader because no one greater element in the right side.
					-11 Not a leader because on the right side -3 are greater than -11.
					-3 Not a leader because on the right side -2 are greater than -3.
					-2 It is a leader because it is a rightmost element in a sequence.
				Hence there are 2 leaders in sequence 10, -2. 

		#include <bits/stdc++.h> 
		vector<int> findLeaders(vector<int> &elements, int n) {
			vector<int> leaders;
			leaders.push_back(elements[n-1]);
			for(int i=n-2; i>=0; i--){
				int j;
				for(j=i+1; j<n; j++){
					if(elements[i] <= elements[j])
						break;
				}
				if(j==n)
					leaders.push_back(elements[i]);
			}
			reverse(leaders.begin(), leaders.end());
			return leaders;
		}

	101) Reverse the String:
		Problem Statement
			You are given a string 'STR'. The string contains [a-z] [A-Z] [0-9] [special characters]. You have to find the
			reverse of the string.
			For example:
			If the given string is: STR = "abcde". You have to print the string "edcba
			Follow Up:
			Try to solve the problem in 0(1) space complexity.
			Detailed explanation (Input/output format, Notes, Images )
			Constraints:
				1 ≤ T ≤ 10
				1 < STR| ≤ 10 ^ 5
				Where STR is the length of the string STR.
				Time limit: 1 sec.
			Sample Input 1:
				3
				abcde
				coding
				hello1
				Sample Output 1:
				edcba
				gnidoc
				1olleh
				Explanation Of The Sample Input 1:
				For the first test case, STR = "abcde". We need to reverse the string, that is the first element becomes the last element and the last element becomes the first element, the second element becomes the second last element and the second last element becomes the second element and so on. So we get, "edcba".
				Sample Input 2:
				3
				a
				1det@Z
				$1xYuP
				Sample Output 2
				a
				Z@ted1
				PuYx1$

		#include <bits/stdc++.h> 
		string reverseString(string str){
			// string rev;
			// int i=str.length()-1;
			// while(i>=0){
			// 	rev += str[i];
			// 	i--;
			// }
			// return rev;
			
			//or

			reverse(str.begin(), str.end());
			return str;
		} 
	
	102) Check whether second string can be formed from characters of first string:
		Problem Statement
			You are given two strings STR1 and STR2. You need to check whether STR2 can be
			formed from the characters of STR1. Both the strings can contain any characters.
			For Example:
				If STR1 = "codingninjas" and STR2 = "sing". We can form the second
				string using the characters of the first string. This is because "s",
				"i", "n", "g" are present in the string STR1.
			Constraints:
				1 ≤ T ≤ 100
				1 ≤ STR1|, STR2| ≤ 1000
			Where 'T' is the number of test cases, ISTR1| and [STR2| are the lengths of the strings STR1 and STR2 respectively.
			Time Limit: 1 sec.
			Sample Input 1:
				3
				codingninjas
				sing
				good human
				14good
				coder
				code
				Sample Output 1:
				YES
				NO
				YES
				Explanation Of Input 1:
				The first test case has already been explained in the problem statement.

				For the second test case, STR1 = “good human” and STR2 = “14good”. We cannot form the second string using the characters of the first string. This is because “1” and “4” are not present in the string STR1.

				For the third test case, STR1 = “coder” and STR2 = “code. We can form the second string using the characters of the first string. This is because “c”, “o”, “d”, “e” are present in the string STR1.
				Sample Input 2:
				3
				madam
				adam
				H#LLO
				hello
				orange
				orange
				Sample Output 2
				YES
				NO
				YES
		
		#include <bits/stdc++.h> 
		string canFormSecondString(string str1, string str2){
			if(str2.length() >  str1.length())
				return "NO";
				
			for(int s2=0; s2<str2.length(); s2++){
				int s1;
				for(s1=0; s1<str1.length(); s1++){
					if(str2[s2] == str1[s1]){
						str1[s1] = '>';
						break; 
					}
				}
				if(s1 == str1.length())
					return "NO";
			}
			return "YES";
		}

	103) Base 58:
		Problem Statement
			You are given a number N. Your goal is to convert the number into base 58.
			The Base58 alphabet consists of the following characters:
			"123456789ABCDEFGH|KLMNPORSTUVWXYZabcdefghijkmnopqrstuvwxyz"
			Each byte value from 0 to 57 maps to the alphabet above.
			Conversion Eg: ( according to above mapping).
			Base 10   |	Base 58
			0		|		1
			1		|		2
			10		|		A
			20		|		L
			30		|		W
			53		|		u
			Sample Input 1:
				2
				10
				67
				Sample Output 1:
				B
				2A
				Explanation For Sample Input 1:
				In test case 1:

				If we represent 10 in powers of 58, it will be, 10 = 10*(58^0)
				10 in base 10 corresponds to B in base 58 ( according to the above mapping).
				Thus our answer is: B

				In test case 2:

				If we represent 66 in powers of 58, it will be, 67 = 1*(58^1) + 9*(58^0)
				1 in base 10 corresponds to 2 in base 58, 9 in base 10 corresponds to A in base 58.
				Thus our answer is: 2A
				Sample Input 2:
				3
				4364
				1786
				6978
				Sample Output 2:
				2JF
				Xo
				35K
		#include <bits/stdc++.h> 
		string encodeBase58(int N) {
			string ans;
			string mapper = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
			if(N == 0)
				return "1";
			while(N){
				ans += mapper[N%58];
				N /= 58;
			}
			reverse(ans.begin(), ans.end());
			return ans;
		}

	104) Find Palindromes:
		Problem Statement
			You are given an integer 'N' Your task is to find all palindromic numbers from 1 to 'N'
			Palindromic integers are those integers that read the same backward or forwards.
			Note: Order of numbers should be in the non-decreasing matter.
			For Example:
				You are given 'N' as 12, so the output should be [1, 2, 3, 4, 5, 6, 7, 8, 9, 11], as all
				single-digit numbers are palindromic, and 11 is also a palindromic number.
			Sample Input 1:
					2
					12
					5
				Sample Output 1:
					1 2 3 4 5 6 7 8 9 11
					1 2 3 4 5
				Explanation:
				For the first test case, all the single-digit numbers are palindromic, 
				and the number 11 is also palindromic. Hence the output is [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].

				For the second test case, N is less than 9. Therefore all the numbers from 1 to N 
				are palindromes. Hence the output is [1, 2, 3, 4, 5].
				Sample Input 2:
					2
					15
					22
				Sample Output 2:
					1 2 3 4 5 6 7 8 9 11
					1 2 3 4 5 6 7 8 9 11 22

		#include <bits/stdc++.h> 
		vector<int> getPalindromes(int n){
			vector<int> palidromes;

			for(int i=1; i<=n; i++) {
				//this will work we used so many built in fuction,
				//so TLE will be there.
				// string s = to_string(i);
				// reverse(s.begin(), s.end());
				// int rev = stoi(s);
				// if(rev == i){
				// 	palidromes.push_back(i);
				// }
				int num = i;
				int reversed = 0;

				while (num > 0) {
					reversed = reversed * 10 + num % 10;
					num /= 10;
				}

				if (reversed == i) {
					palidromes.push_back(i);
				}
			}
			return palidromes;
		}

	105) Mindbending Product:
		Problem Statement
			You are given an array 'ARR' of size N. You have to construct a Product Array 'P' of the same size such that
			P[i] is equal to the product of all the elements of ARR except ARR[i]. The constraint is that you are not
			allowed to use the division operator.
			For Example:
			For an array {1, 2, 3, 4, 5}:
			The required product array generated from the given array is {120, 60, 40, 30, 24 }
			This can be generated in the following manner:
			For generating 120 we have 2 * 3 * 4 * 5 i.e. the product of other array elements except 1.
			For generating 60 we have 1 * 3 * 4 * 5 i.e. the product of other array elements except 2.
			For generating 40 we have 1 * 2 * 4 * 5 i.e. the product of other array elements except 3.
			For generating 30 we have 1 * 2 * 3 * 5 i.e. the product of other array elements except 4.
			For generating 24 we have 1 * 2 * 3 * 4 i.e. the product of other array elements except 5.
		Sample Input 1:
			2
			5
			10 3 5 6 2
			2
			12 20
			Sample Output 1:
			180 600 360 300 900
			20 12
			Explanation:
			Test Case 1: 
			For the product array P,
			At i=0 we have 3*5*6*2 = 180.
			At i=1 we have 10*5*6*2 = 600. 
			At i=2 we have 10*3*6*2 = 360. 
			At i=3 we have 10*3*5*2 = 300. 
			At i=4 we have 10*3*5*6 = 900
			So, the P array is 180 600 360 300 900

			Test Case 2: 
			For the product array P, 
			At i=0, we have 20. 
			At i=1, we have 12.
			So, the P array is 20 12. 
		vector<long long> getProductArray(int arr[], int n){
			vector<long long> ans;
			if(n==1)
				return {0};
			
			for(int i=0; i<n; i++){
				long long pro =1;
				for(int j=0; j<n; j++){
				if(i==j)
					continue;
				pro *= arr[j];         
				}
				ans.push_back(pro);
			}
			return ans;
		}

	106) Count Even Odd:
		Problem Statement
			You have been given an array/list of integers 'ARR' of size 'N'. Your task is to find two things-
			1. The number of elements that are occurring an Odd number of times.
			2. The number of elements that are occurring Even a number of times.
			For Example:
				ARR = [2, 1, 2, 1, 5, 5, 2]
				Output: 1 2
				2 occurs three(odd) times.
				1 occurs two(even) times.
				5 occurs two(even) times.
			So, the total 1 element is occurring an odd number of times and 2 elements are occurring
			an even number of times.
			Detailed explanation (Input/output format, Notes, Images )
			Constraints:
				1 <= T <= 10^2
				0 <= N <= 5 * 10^3
				1 <= ARR[i] <= 10^9
				Time Limit: 1 sec
		Sample Input 1:
			2
			5
			4 5 1 2 1
			4
			2 1 2 1 
			Sample Output 1:
			3 1
			0 2
			Explanation For Sample 1:
			In the first test case, three integers(4, 5 and 2) occur odd times and the only integer 1 occurs even times.

			In the second test case, no integer occurs odd times and two integers(1 and 2) occurs even times.
			Sample Input 2:
			1
			8
			5 2 9 9 7 5 1 3
			Sample Output 2:
			4 2

		#include <bits/stdc++.h> 
		vector<int> countEvenOdd(vector<int> &arr, int n){
			//NOT optimized
			// int oddOccs=0, evenOcc=0;
			// for(int i=0; i<n; i++){
			// 	int cnt=1;
			// 	if(arr[i] != -1){
			// 		for(int j=i+1; j<n; j++){
			// 			if(arr[i] == arr[j]){
			// 				arr[j] =-1;
			// 				cnt++;
			// 			}
			// 		}
			// 		if(cnt&1)
			// 			oddOccs++;
			// 		else
			// 			evenOcc++;
			// 	}
			// }
			// return {oddOccs, evenOcc};
			unordered_map<int, int> occurrenceMap;
			int oddOccs = 0, evenOcc = 0;

			for (int i = 0; i < n; i++) {
				occurrenceMap[arr[i]]++;
			}

			for (auto const& entry : occurrenceMap) {
				if (entry.second % 2 == 1) {
					oddOccs++;
				} else {
					evenOcc++;
				}
			}
			return {oddOccs, evenOcc};
		}
	
	107) Flip given bits:
		Problem Statement
			You have been given an integer 'NUM' (32 bits) and an array of size 'N'.
			Your task is to flip all the bits of 'NUM' at position 'ARR[i]' where 0<= i <= N-1.
				Constraints:
				1 <= 'T' <= 10
				1 <= 'NUM' <= 10^9
				1 <= 'N' <= 10^5
				1 <= 'ARR[il' <= 31
				Time Limit: 1 sec
			Sample Input 1:
				2
				21
				3
				4 2 1
				40
				1
				4
			Sample Output 1:
				30
				32
			Explanation For Sample Input 1:
				Before flipping
				21 => 10101
				After flipping the 4th, 2nd and 1st bit from the end we get 
				30 => 11110

				Before flipping
				40 => 101000
				After flipping the 4th bit from the end we get 
				32 => 100000
			Sample Input 2:
				1
				5
				3
				6 2 5
				Sample Output 2:
				55
		#include <bits/stdc++.h> 
		int flipSomeBits(int num, vector<int> &arr, int n){
			string s = bitset<32>(num).to_string();
			reverse(s.begin(), s.end());
			
			for(int i=0; i<n; i++){
				if(s[arr[i]-1]=='1'){
					s[arr[i]-1] = '0';
				}else{
					s[arr[i]-1] = '1';
				}
			}
			reverse(s.begin(), s.end());

			//removing leading zeros
			while(s[0] == '0')
				s.erase(0,1);

			// cout<<s<<endl;
			//binary to decimal conversion
			int ans=0, cnt=0;
			for(int i=s.length(); i>=0; i--){
				if(s[i] == '1')
					ans += pow(2,cnt);
				cnt++;
			}

			//or
			// return stoi(s, 0, 2);
			return ans/2;
		}
			//or
				#include <bits/stdc++.h> 
				int flipSomeBits(int num, vector<int> &arr, int n){
					string s = bitset<32>(num).to_string();
					reverse(s.begin(), s.end());
					
					for(int i=0; i<n; i++){
						if(s[arr[i]-1]=='1'){
							s[arr[i]-1] = '0';
						}else{
							s[arr[i]-1] = '1';
						}
					}
					reverse(s.begin(), s.end());
					return stoi(s,0,2);
				}
	
	108) Maximum In Sliding Windows Of Size K:
		Problem Statement
			Given an array/list of integers of length 'N', there is a sliding window of size 'K' which moves from the
			beginning of the array, to the very end. You can only see the 'K' numbers in a particular window at a
			time. For each of the 'N'-'K'+1 different windows thus formed, you are supposed to return the
			maximum element in each of them, from the given array/list.
			Constraints :
				1 <= T <= 50
				1 <= N <= 10^4
				1 <= K <= N
				0 <= ARR[i] <= 10^5
				Where, ARR[i] denotes the i-th element in the array/list.
					Time Limit: 1 sec.
			Sample Input 1 :
				2
				3 1
				1 2 2
				5 2
				4 2 1 4 4
				Sample Output 1 :
				1 2 2
				4 2 4 4
				Explanation To Sample Input 1 :
				In the first test case, 
				The maximum of window {1} is 1.
				The maximum of window {2} is 2.
				The maximum of window {2} is 2.
				So the output will be {1, 2, 2}.

				In the second test case, 
				The maximum of window {4,2} is 4.
				The maximum of window {2,1} is 2.
				The maximum of window {1,4} is 4.
				The maximum of window {4,4} is 4.
				So the output will be {4, 2, 4, 4}.
				Sample Input 2 :
				2
				5 3
				2 2 2 3 3
				7 4
				2 3 1 4 5 1 5
				Sample Output 2 :
				2 3 3
				4 5 5 5
				Explanation To Sample Input 2 :
				In the first test case, 
				The maximum of window {2,2,2} is 2.
				The maximum of window {2,2,3} is 3.
				The maximum of window {2,3,3} is 3.
				So the output will be {2, 3, 3}.

				In the second test case, 
				The maximum of window {2,3,1,4} is 4.
				The maximum of window {3,1,4,5} is 5.
				The maximum of window {1,4,5,1} is 5.
				The maximum of window {4,5,1,5} is 5.
				So the output will be {4, 5, 5, 5}.
		
		//not optimized
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				for (int i = 0; i <= nums.size() - k; i++) {
					// parsing window of size k.
					vector<int> temp(nums.begin() + i, nums.begin() + k + i);
					int mx = *max_element(temp.begin(), temp.end());
					ans.push_back(mx);
				}
				return ans;
			}

		//or
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				for(int i=0; i<nums.size()-k+1; i++){
					vector<int> temp;
					int cnt=k;          //window size
					for (int j = i; cnt > 0; cnt--) {
						temp.push_back(nums[j++]);
					}
					ans.push_back(*max_element(temp.begin(), temp.end()));
				}
				return ans;
			}

		//or
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				for(int i=0; i<nums.size()-k+1; i++){
					vector<int> temp;
					for (int j = i; j < i + k; j++) {
						temp.push_back(nums[j]);
					}
					ans.push_back(*max_element(temp.begin(), temp.end()));
				}
				return ans;
			}
		
		//optimized:
			#include <bits/stdc++.h> 
			vector<int> slidingWindowMaximum(vector<int> &nums, int &k){
				vector<int> ans;
				std::deque<int> maxDeque;

				for (int i = 0; i < nums.size(); i++) {
					// Remove elements that are out of the current window
					while (!maxDeque.empty() && maxDeque.front() < i - k + 1) {
						maxDeque.pop_front();
					}

					// Remove elements that are less than the current element
					while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
						maxDeque.pop_back();
					}

					// Add the current element to the deque
					maxDeque.push_back(i);

					// The front element of the deque is the maximum in the current window
					if (i >= k - 1) {
						ans.push_back(nums[maxDeque.front()]);
					}
				}
				return ans;
			}

	109)	Day 1: ENG vs NZ: Interesting Toss
		Problem Statement
			In the inaugural match between ENG and NZ, the ICC has replaced the traditional coin flip with a unique game.
			The ICC has provided a set of coins, where 'X" coins are valued at 10 rupees and Y' coins are valued at 75 rupees.
			Each captain, on their turn, selects coins with a total value of exactly 105 rupees and removes them from the
			set. The captain who fails to do so loses the toss. As ENG is the home team for this match, they make the first move.
			Your task is to return 1 if ENG wins this special toss game; otherwise, return 0.
			Example :
				Input: 'X' = 15, 'y' = 1
				Output: 1
			The captain of ENG starts the game and picks one 75 rupee coin and three 10 rupee coins,
			making a total of 105 rupees.
			Now, the captain of NZ cannot make 105 rupees with the remaining coins (12 ten rupee coins). Hence, ENG wins the special toss game.
		// wrong  (not optimized)
			int coinGame(int x, int y) {
				int turn=0;
				int sum;
				sum = x*10 + y*75;
				while(sum>=105){
					sum -= 105;
					turn++;
				}
				if(turn&1)
					return 1;
				return 0;
			}
		
		//wrong (little optimized)
			int coinGame(int x, int y) {
				int cn=0;
				while(y>0){
					y-=1;
					if (x >= 3) {
						x-=3;
						cn++;
					}
				}
				if(cn!=0 && cn%2!=0){
					return 1;
				}
				return 0;
			}

	110) Day 1: ENG vs NZ: Jersey Quest:
		Problem Statement
			The batting lineup of the England cricket team for their match against New Zealand consists of 'N' players standing
			in a line. You have an array 'A' of length 'N' such that 'A[i]' represents the 'i-th player's jersey number.
			In one operation, you can swap any two adjacent players.
			Return the minimum difference between the jersey numbers of any two adjacent players after performing the
			For Example:-
			Let 'N' =5, 'A'= [1, 5, 11, 2, 7].
			We first swap the third and fourth players, "A' becomes [1, 5, 2, 11, 7]. We then swap the second
			and third players, 'A' becomes [1, 2, 5, 11, 71.
			Now, the difference between the first and second jersey numbers is "1'
			It can be shown that this is the minimum possible difference. Thus, the answer is '1'.
			Constraints:-
				1 <= 'T' ‹= 10
				2 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
			The Sum of 'N' overall test cases does not exceed 10^5.
			Time Limit: 1 sec
			Sample Input 1:-
				2
				3 
				4 1 7
				4
				1 4 2 3
				Sample Output 1:-
				3
				1
				Explanation Of Sample Input 1:-
				First test case:-
				Here, the difference between the first and second jersey numbers is 3, which is the minimum possible.
				Thus, the answer is '3'.

				Second test case:-
				Here, the difference between the third and fourth jersey numbers is 1, which is the minimum possible.
				Thus, the answer is '1'.
				Sample Input 2:-
				2
				2
				4 6
				5 
				9 12 5 16 2
				Sample Output 2:-
				2
				3

		#include<bits/stdc++.h>
		int minDifference(vector<int> &a) {
			sort(a.begin(), a.end());
			int minN = INT_MAX;
			for(int i=0; i<a.size()-1; i++){
				int n = a[i+1] - a[i];
				minN = min(minN, n);
			}
			return minN;
		}

	111) Take Away The Bottle:❌
		Problem Statement
			There is a row of numbered bottles, and now you need to take them all away. 
			You can only take several consecutive bottles at a time, and you need to make sure that 
			the bottle number is a palindrome string. Palindrome string refers to the same string read 
			in both forward and reverse directions 
			For example:
				"4664" when read forward and backward will give the same result. Hence it is a palindrome.
				Your task is to find the minimum number of times it takes to remove all bottles.
			Constraints:
				1 <= N <= 500
				1<= bottles[i] <= 1000|
				Time limit: 1 sec
			Sample Input 1 :
				2
				5
				1 3 4 1 5
				3
				4 6 4
				Sample Output 1 :
				3
				1     
				Explanation For Sample Output 1 :
				For test case 1 :
				We can take bottle number 4, then the bottle array will be: 1 3 1 5

				Then we can take 1 3 1 at the same time since it is a palindrome and the array will be: 5
				Then we will take bottle number 5

				For test case 2 :
				We can take all the bottles at once since they form a palindrome
				Sample Input 2 :
				2
				6
				1 2 3 5 3 1
				6
				1 1 2 3 1 1
				Sample Output 2 :
				2
				2

				sample input 3:
					4
						5 
						5 5 20 17 12 
						6 
						13 16 20 17 18 12 
						5 
						16 18 16 3 13 
						4 
						12 13 11 15 
				sample output:
					4
					6
					3
					4

	112) Day 2: PAK vs NED: Run Rate Lift
		Problem Statement
			Pakistan is playing a crucial match against the Netherlands. 
			Pakistan is currently batting and needs to lift their run
			rate from '0' to exactly 'D' runs per over to secure victory.
			Pakistan has two types of batsmen:
			- Explosive Hitters: These batsmen lift the run rate by '3' runs per over.
			- Steady Accumulators: These batsmen lower the run rate by "2' runs per over.
			In one over, Pakistan can send in either an Explosive Hitter or a Steady Accumulator.
			Return the minimum number of overs Pakistan needs to play in order to reach the required run rate of 'D' and secure
			a win against the Netherlands?
			Example:
			'D' = 6
			They can send Explosive Hitter in each of the first two 
			overs and reach the required run rate of '6' per over.
			So, the answer is '2'.
			Constraints :
				1 <= T <= 10
				1 ‹= D <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				0
				12
				Sample Output 1:
				0
				4
				Explanation Of Sample Input 1:
				For test case 1:
				The current run rate is already at '0', so they don't need any more overs.
				So, the answer is '0'. 

				For test case 2:
				They can send Explosive Hitter in each of the first four overs and reach the required run rate of '12' per over.
				So, the answer is '4'. 
				Sample Input 2:
				2
				25
				30
				Sample Output 2:
				10
				10

		int liftStruggle(int d) {
			int over=0;
			if(d%3 ==0)
				return d/3;

			over = d/3;
			int run= over*3;

			while(run != d){
				run +=1;
				over+=2;
			}
			return over;
		}

		//or
		int liftStruggle(int d) {
			int over=0;
			int run=0;
			while(run != d){
				if(run<d){
					run+=3;
					over++;
				}else{
					run-=2;
					over++;
				}
			}
			return over;
		}

	113) Check N numbers:
		Problem Statement
			Given an array 'arr' of 'N' integers, make a number from those set of all integers from the 'arr' such that if number of
			'ith' set bits are greater than the number of 'ith' unset bits then make that 'ith' bit of the new number as set bi
			otherwise make that 'ith' bit as unset bit.
			For Example:
			There are three numbers, say 8, 5 and 10.
			8 can be written as 1000.
			5 can be written as 0101.
			10 can be written as 1010.
			So we can see majority bit at ith position are set bits so ith bit will be 1. Similarly for
			positions of j, kand 1 are set as 0 0 0 respectively.
			Detailed explanation (Input/output format, Notes, Images)
			Input Format:
				The first line contains a single integer 'T' representing the number of test cases.
				Then 'T' test cases follows:
				First line of each test case contains an integer 'N' representing the size of the input array "arr'.
			Next line contains 'N' space separated integers denoting the elements in the 'arr'.
			Output format :
				Output of each test case an integer as per the condition.
			Constraints:
				1 ‹= T <= 5
				1 ‹= N ‹= 10 ^ 3
				1 <= arr[i] <= 5 * (10 ^ 3)
				Time Limit: 1sec
		Sample Input 1:
			2
			3
			8 4 2
			3
			8 8 2
			Sample Output 1:
			0
			8
			Explanation For Sample Test Case 1:
			Test Case 1 :
			Numbers can be represented in bits as:
			1 0 0 0
			0 1 0 0
			0 0 1 0
			i j k l
			Number of set bits for ith index is 1. Number of unset bits for ith index is 2. 
			Therefore the number of unset bits for ith index is greater than the number 
			of set bits for ith index. So ith bit for the number will be 0.

			Similarly for jth, kth and lth bit will be 0. As the number of unset bits is greater than 
			the number of set bits. Answer will be 0 0 0 0 which represents number 0.

			Test Case 2:
			Numbers can be represented in bits as
			1 0 0 0
			1 0 0 0
			0 0 1 0
			i j k l

			Number of set bits for ith index is 2. Number of unset bits for ith index is 1. 
			Therefore the number of set bits for ith index is greater than the number of unset 
			bits for ith index. So ith bit for the number will be 1.

			Similarly for jth, kth and lth bit will be 0. As the number of unset bits is greater 
			than the number of set bits. Answer will be 1 0 0 0 which represents the number 8.
			Sample Input 2:
			2
			5
			1 2 3 4 5
			4
			6 7 8 9
			Sample Output 2:
			1
			0

			Sample Input 3:
				5
				1 
				87
				10 
				64 92 77 36 61 93 45 56 97 81 
				10 
				11 47 65 58 45 76 26 93 13 24 
				10 
				3 87 68 41 84 0 74 39 47 29 
				10 
				36 30 6 65 82 69 89 74 27 96
				Sample Output 3:
					87
					77
					9
					5
					64
 

		#include <bits/stdc++.h> 
		int getNewNum(vector<int> arr, int n) {
			string s;

			for(int j=0; j<32; j++){
				int cnt=0;
				for(int i=0; i<n; i++){
					if(arr[i]&1)
						cnt++;
					arr[i] >>=1;
				}

				int numsOfzero = n - cnt;
				int numsOfone = cnt;

				if(numsOfone> numsOfzero)
					s += '1';
				else
					s += '0';
			}
			reverse(s.begin(), s.end());
			// cout<<s<<endl;
			return stoi(s,0,2);				//converting string to binary.
		}

	114) Day 27 : Magician and Chocolates:
		Problem Statement
			In a magic event, you are given 'N' bags, each bag containing 'A[i]' chocolates. In one unit of time, you can choose
			any bag 'ї and eat all the chocolates 'A[i]' in that bag and then the magician fills the ith bag with floor('A[i]' / 2)
			chocolates. Your task is to find the maximum number of chocolate you can eat in 'K' units of time.
			Since the answer could be large, return answer modulo 10^9 + 7.
			For Example:
			For the array [ 4, 7, 9, 10] and 'k'=2
			In the first step, we can choose the last bag. So the answer will be 10 and the array will be [4,7, 9, 5].
			In the second step, we can choose the second last bag. So the answer will be 19 and the array
			will be [4, 7, 4, 5].
			So the final output will be 19.
			Constraints:
				1 <= Т ‹= 100
				1 ‹= N <= 10^5
				1 ‹= ARR[i] ‹= 10^5]
				Time Limit: 1 sec.
			Sample Input 1:
				2
				4 1
				3 8 2 4
				4 2
				10 4 7 22
				Sample Output 1:
				8
				33
				Explanation For Sample Output 1:
				For the first test case,
				In the first step, we can choose the second bag. So the answer will be 8 and the array will be [3, 4, 2, 4].
				So, the final answer will be 8.

				For the second test case,
				In the first step, we can choose the last bag. So the answer will be 22 and the array will be [10, 4, 7, 11].
				In the second step, we can choose the last bag. So the answer will be 33 and the array will be [10, 4, 7, 5].
				So, the final answer will be 33.
				Sample Input 2:
				2
				5 3
				3 6 10 12 8
				4 1
				2 10 4 3
				Sample Output 2:
				30
				10
		
			Sample Input 3:
			5
			6 100
			1 1 1 1 1 1
			6 2
			1 1 1 1 1 1
			6 10
			1 2 3 4 5 6
			6 6
			6 5 4 3 2 1
			6 4
			1 3 4 6 10 200
			Sample Output 3:
				6
				2
				29
				23
				375
		
		#include <bits/stdc++.h> 
		int maximumChocolates(vector<int> &arr, int k){
			long long sum=0;
			while(k>0){
				auto mx = max_element(arr.begin(), arr.end());
				sum +=*mx;
				int index = distance(arr.begin(),mx);
				arr[index] /= 2;
				k--;
			}
			return sum;
		}

	115) Distinct Enemies:
		Problem Statement
			Ninja has somehow got the list of enemies and their strength. Now ninja wants to make a plan according to enemies
			on the basis of their strength. But ninja wants to first count the distinct type of enemies as some of them have the
			same strength.
			So help our ninja in counting the distinct type of enemies from the given array where 'ARR[i]' represents the strength
			of the i-th enemy.
			Note:
				Two enemies are distinct if their strengths are different.
			Constraints:
				1 <= T <= 5
				1 <= N <= 5000
				0 <= ARR[i] < 10 ^ 6
				Where 'ARR[i]' represents the elements of the array.
			Time Limit: 1 sec
			Sample Input 1 :
				2
				5
				2 3 5 3 2
				5
				2 2 2 2 3
				Sample Output 1 :
				3
				2
				Explanation For Sample Input 1 :
				Test Case 1:
				For the first test case, the given array is { 2, 3, 5, 3, 2 } so we return ‘3’ 
				as we can say ‘3’ distinct values are present in the array i.e { 2, 3, 5}.

				Test Case 2:
				For this test case, the given array is { 2, 2, 2, 2, 3 } so we return ‘2’ 
				as we can say ‘2’ distinct values are present in the array i.e { 2, 3}.
				Sample Input 2 :
				2
				2
				5 5
				5
				1 6 7 9 4
				Sample Output 2 :
				1
				5
		#include <bits/stdc++.h> 
		int distinctEnemies(vector<int> &arr, int n) {
			set<int> DifferentValues;
			for (int i = 0; i < n; i++) {
				DifferentValues.insert(arr[i]);
			}
			return DifferentValues.size();
		}

	116) Find Minimum Number Of Coins:
		Problem Statement
			Given an infinite supply of Indian currency i.e. [1, 2, 5, 10, 20, 50, 100, 500, 1000] valued coins and an amount 'N'.
			Find the minimum coins needed to make the sum equal to 'N'. You have to return the list containing the value of coins
			required in decreasing order.
			For Example
				For Amount = 70, the minimum number of coins required is 2 i.e an Rs. 50 coin and a Rs. 20 coin.
			Note
			It is always possible to find the minimum number of coins for the given amount. So, the answer
			will always exist.
			Sample Input 1
				13
				Sample Output 1
				10 2 1
				Explanation Of Sample Input 1
				The minimum number of coins to change is 3 {1, 2, 10}.
				Sample Input 2
				50
				Sample Output 2
				50
				Constraints
				1 <= 'N' <= 10^5

				Time Limit: 1 sec

		//optimized
			vector<int> MinimumCoins(int n){
				int sum =0;
				vector<int> ans;
				int total = n;

				while(sum != total){
					//check by 1000
					if(n>=1000){
						ans.push_back(1000);
						sum += 1 * 1000;
						n -= 1000;
					}
					//check by 500
					else if (n >= 500) {
						ans. push_back(500);
						sum += 1 * 500;
						n -= 500;
					}

					//check by 100
					else if (n >= 100) {
						ans. push_back(100);
						sum += 1 * 100;
						n -= 100;
					}
					
					//check by 50
					else if (n >= 50) {
						ans. push_back(50);
						sum += 1 * 50;
						n -= 50;
					}
					
					//check by 20
					else if (n >= 20) {
						ans. push_back(20);
						sum += 1 * 20;
						n -= 20;
					}

					//check by 10
					else if (n >= 10) {
						ans.push_back(10);
						sum += 1 * 10;
						n -= 10;
					}
					//check by 5
					else if (n >= 5) {
						ans. push_back(5);
						sum += 1 * 5;
						n -= 5;
					}
					//check by 2
					else if (n >= 2) {
						ans.push_back(2);
						sum += 1 * 2;
						n -= 2;
					}
					//check by 1
					else{
						ans.push_back(1);
						sum +=1 * 1;
						n -= 1;
					}
				}
				return ans;
			}

		//much more optimized
			vector<int> MinimumCoins(int n) {
				vector<int> ans;
				const std::vector<int> coinDenominations = {1000, 500, 100, 50, 20, 10, 5, 2, 1};

				for (const int denomination : coinDenominations) {
					while (n >= denomination) {
						ans.push_back(denomination);
						n -= denomination;
					}
				}

				return ans;
			}
	
	117) Product Of Array Except Self:
		Problem Statement
			You have been given an integer array/list (ARR) of size N. You have to return an array/list PRODUCT such
			that PRODUCT[] is equal to the product of all the elements of ARR except ARR[i].
			Note:
				Each product can cross the integer limits, so we should take modulo of the operation.
				Take MOD = 10^9 + 7 to always stay in the limits.
			Follow Up:
			Can you try solving the problem in 0(1) space?
			Constraints:
				1 <= Т <= 100
				0 <= N <= 10^5
				0 <= ARRi1 <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				1 2 3
				3
				5 2 2
				Sample Output 1 :
				6 3 2
				4 10 10
				Explanation For Sample Output 1 :
				Test case 1 : Given array = {1, 2, 3] 
				Required array = [2 * 3, 1 * 3, 1 * 2] = [6, 3, 2]
				Test case 2 : Given array = {5, 2, 2] 
				Required array = [2 * 2, 5 * 2, 5 * 2] = [4, 10, 10]
				Sample Input 2 :
				2
				1
				100
				2
				1 2
				Sample Output 2 :
				1
				2 1

		int *getProductArrayExceptSelf(int *arr, int n) {
			int *ans = new int[n];
			long long temp = 1;
			int mod = 1e9 + 7;

			for (int i = 0; i < n; i++) {
				ans[i] = temp;
				temp = (temp * arr[i]) % mod;
			}

			temp = 1;
			for (int i = n - 1; i >= 0; i--) {
				ans[i] = (ans[i] * temp) % mod;
				temp = (temp * arr[i]) % mod;
			}

			return ans;
		}
	
	118) Factorial of a Number:
		Problem Statement
			You are given an integer 'N'. You have to print the value of Factorial of 'N' The Factorial of a number 'N' is
			defined as the product of all numbers from 1 to 'N'
			For Example:
			Consider if 'N' = 4, the Factorial of 4 will be the product of all numbers from 1 to 4,
			which is 1 * 2 * 3 * 4 = 24. 
			Hence, the answer is 24.
			Input Format:
				The first line of the input contains an integer, 'T,' denoting the number of test cases.
				The first and only line of each test case contains one single integer 'N' representing the given integer.
			Output Format:
				For each test case, print the value of factorial of 'N'.
				Print the output of each test case in a separate line.
			Constraints:
				1 <= T <= 10
				1 <= N <= 100
				Time limit: 1 sec
			Sample Input 1:
				2
				4
				3
				Sample Output 1:
				24
				6
				Explanation Of Sample Input 1:
				For the first test case, 
					The Factorial of 4 is the product of all numbers from 1 to 4, 
					which is 1 * 2 * 3 * 4 = 24. Hence, the answer is 24.

				For the second test case,
					The Factorial of 3 is the product of all numbers from 1 to 3, which is 1 * 2 * 3 = 6. 
					Hence, the answer is 6.
				Sample Input 2:
				2
				8
				11
				Sample Output 2:
				40320
				39916800

		//Partially Accepted
			void factorial(int n) {
				vector<int> factAns;
				int originalNum = n;
				while(n>9){
					//num spliting
					factAns.insert(factAns.begin(), n%10);
					n/=10;
				}
				
				//inserting last digit manually
				factAns.insert(factAns.begin(), n%10);

				n = originalNum;
				int prod, carry=0, lastDigit;

				while(--n) {
					vector<int> temp;
					for(int i=factAns.size()-1; i>=0; i--){
						prod = factAns[i] * n + carry;
						lastDigit = prod %10;
						carry = prod/10;
						temp.insert(temp.begin(), lastDigit);
					}
					while(carry){
						temp.insert(temp.begin(), carry%10);
						carry /=10;
					}
					factAns = temp;
				}

				for(int i=0; i<factAns.size(); i++) {
					cout<<factAns[i];
				}
				cout<<endl;
			}
	
		//more optimized:
			void factorial(int n) {
				if (n <= 1) {
					std::cout << "1" << std::endl;
					return;
				}

				std::vector<int> factAns;
				factAns.push_back(1);  // Initialize the result with 1

				for (int i = 2; i <= n; ++i) {
					int carry = 0;
					for (int j = 0; j < factAns.size(); ++j) {
						int prod = factAns[j] * i + carry;
						factAns[j] = prod % 10;
						carry = prod / 10;
					}
					while (carry) {
						factAns.push_back(carry % 10);
						carry /= 10;
					}
				}

				// Print the result in reverse order
				for (int i = factAns.size() - 1; i >= 0; --i) {
					std::cout << factAns[i];
				}
				std::cout << std::endl;
			}

	119) Find the Winner:
		Problem Statement
			You have been given an array/list of "VOTES" which contains the name of the candidates where each entry
			represents the name of the candidate who got the vote.
			You are supposed to find the name of the candidate who received the maximum number of votes. If there is a
			tie, then print the lexicographically smaller name.
			Input Format:
				The first line contains an integer 'T' denoting the number of test cases. Then each test
				case follows.
				The first input line of each test case contains an integer 'N' denoting the total number
				of votes cast.
				Each of the next 'N' lines contains the name of the candidate who received the vote.
			Output Format :
				For each test case, print the name of the candidate who received the maximum number of
				votes.
			Print the output of each test case in a separate line.
			Note:
				You are not required to print the expected output; it has already been taken care of. Just
				implement the function.
			Constraints :
				1 <= T <= 50
				1 <= 'N' <= 10^3
				1 <= NAME <= 20
				Where N' is the number of votes cast and |NAME| denotes the length of the candidate's
				name.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				John
				Tim
				Marry
				John
				2
				Rahul
				Ankur
				Sample Output 1 :
				John
				Ankur
				Explanation For Sample Intput 1 :
				For the first test case, “John” has received the maximum number of votes (2 votes).

				For the second test case, both “Rahul” and “Ankur” has received one vote each since “Ankur” is lexicographically smaller than “Rahul”, print “Ankur”.
				Sample Input 2 :
				2
				1
				Arya
				2
				Atul
				Atul    
				Sample Output 2 :
				Arya
				Atul
				Explanation For Sample Intput 2 :
				For the first test case, “Arya” is the only candidate in the election who has received the maximum number of votes.  

				For the second test case, “Atul” has received all the votes.

		#include <bits/stdc++.h> 
		string getWinner(vector <string> & votes) {
			int mx = 1;
			vector<string> mxString = {votes[0]};
			for(int i=0; i<votes.size(); i++){
				int cnt =1;
				for(int j=i+1; j<votes.size(); j++){
					if(votes[i] == votes[j]){
						cnt++;
					}
				}
				if(cnt == mx){
					mxString.push_back(votes[i]);
				}

				if(cnt > mx){
					mx = cnt;
					mxString.clear();
					mxString.push_back(votes[i]);
				}
			}
			sort(begin(mxString), end(mxString));
			return mxString[0];
		}

	120) Day 10 : Minimum Operations:
		Problem Statement
			You are given an array 'ARR' of 'N' positive integers. You need to find the minimum number of operations
			needed to make all elements of the array equal. You can perform addition, multiplication, subtraction or
			division with any element on an array element.
			Addition, Subtraction, Multiplication or Division on any element of the array will be considered as a single
			operation.
			Example:
				If the given array is [1,2,3] then the answer would be 2. One of the ways to make all the
				elements of the given array equal is by adding 1 to the array element with value 1 and
				subtracting 1 from the array element with value 3. So that final array would become
				[2,2, 2].
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^5
				0 <= ARR[il <= 10^5
			Where 'ARR[i]' is the element of the array 'ARR' at index 'i'.
				Time Limit: 1 sec
			Sample Input 1:
				1
				4
				1 2 3 4
				1
				5
				Sample Output 1:
				3
				0
				Explanation For Sample Output 1:
				In test case 1, There can be many ways by which we can convert the array elements equal, one of the way is:

				1 + 2 = 3
				2 + 1 = 3
				4 - 1 = 3

				Here the first operand is the element of the array and the second operand is the operation that we did for making all the numbers of the array equal.

				Hence, we did 3 operations to change the elements of the array to 3. Hence the answer is 3.

				In test case 2, There is only 1 element and hence no need to make equal and so answer is 0.
				Sample Input 2:
				2
				3
				2 4 2
				5
				1 2 1 4 1
				Sample Output 2:
				1
				2
				Explanation For Input 2:
				In test case 1, by dividing 4 by 2 (i.e. 4 / 2) we can have all the elements equal to 2. Thus only 1 operation is performed and so answer is 1.

				In test case 2, There can be many ways by which we can convert the array elements equal, one of the way is:

				2 / 2 = 1
				4 / 4 = 1

				Here the first operand is the elements of the array and the second operand is the operation that we did for making all the numbers of the array equal.

				Hence, we did 2 operations to change the elements of the array to 2. Hence the answer is 2.

		//own solution:
			#include <bits/stdc++.h> 
			int minimumOperation(vector<int> &arr, int n) {
				if(n == 1)
					return 0;
				
				unordered_map<int, int> occs;
				for(int i=0; i<n; i++){
					occs[arr[i]]++;			//storing the frequency of Elements
				}
				vector<int> maxOccurenceStorer;
				for(auto i=occs.begin(); i!= occs.end(); i++){
					maxOccurenceStorer.push_back(i->second);		//storing the repetition of element
				}
				int mxRepetFromOccs = *max_element(maxOccurenceStorer.begin(), maxOccurenceStorer.end());		//extracting the element repeated maximum no.of times.
				return n-mxRepetFromOccs;
			}
		
		//or
			#include <bits/stdc++.h> 
			int minimumOperation(vector<int> &arr, int n) {
				unordered_map<int,int>mpp;
				for(int i=0;i<n;i++)
				{
					mpp[arr[i]]++;			//storing the occurrences of element
				}
				int max_freq=INT_MIN;
				for(auto it:mpp)
				{
					max_freq=max(max_freq,it.second);		//picking the element which is occurred maximum times

				}
				return n-max_freq;
			}

	121) Day 3: AFG vs BAN: Team Selection:
		Problem Statement
			As a team selector for the upcoming matches, you are given an array 'A' of 'N' players, where 'A[i] represents
			the skill level of the "i-th' player.
			To maximize your chances of winning, you are tasked with selecting a team of exactly 'K' players, each with
			a skill level of "9".
			If it is possible to select such a team, return 1. Otherwise, return 0.
			For Example :
				Let 'N' = 5, 'A' = [ 1, 9, 2, 3, 9 ], 'K' = 2.
				The team consisting of the "1-st' and '4-th' players has a skill level array of [ 9, 9 ].
				Therefore, it is possible to select a team of 'K = 2' players, each with a skill level of
				"9".
			Constraints :
				1 <= 'T' <= 10
				1 <= 'K' <= 'N' <= 10^5
				0 <= 'A[i]' <= 9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4 1
				9 6 0 9
				5 3
				1 1 0 3 7
				Sample Output 1 :
				1
				0
				Explanation Of Sample Input 1 :
				First test case:-
				The team consisting of only the ‘0-th’ player has a skill level array of [ 9 ]. 
				Therefore, it is possible to select a team of ‘K = 1’ players, each with a skill level of ‘9’. 

				Thus, the answer is '1'.

				Second test case:-
				None of the players have a skill level of ‘9’. 
				Therefore, it is impossible to select a team of ‘K = 3’ players, each with a skill level of ‘9’. 
				Thus, the answer is '0'.
				Sample Input 2 :
				2
				4 2
				0 0 9 1
				6 6
				9 9 9 9 9 9
				Sample Output 2 :
				0
				1
		int nines(int n, vector<int> &a, int k) {
			int cnt=0;
			for(int i=0; i<n; i++){
				if(a[i] == 9)
					cnt++;
			}
			if(cnt>=k)
				return 1;

			return 0;
		}

	122) Power of Four:
		https://leetcode.com/problems/power-of-four/description/
		Given an integer n, return true if it is a power of four. Otherwise, return false.
				An integer n is a power of four, if there exists an integer x such that n == 4x.
				Example 1:
					Input: n = 16
					Output: true
					Example 2:

					Input: n = 5
					Output: false
					Example 3:

					Input: n = 1
					Output: true

				Constraints:
					-231 <= n <= 231 - 1

		class Solution {
			public:
			bool isPowerOfFour(int n) {
				if(n==1)
					return 1;
				
				for(int i=1; ;i++){
					long long currPOW = pow(4,i);
					if(currPOW == n)
						return 1;
					if(currPOW>n)
						return 0;
				}
				return 0;
			}
		};
	
	123) Power of Three:
		https://leetcode.com/problems/power-of-three/description/
		Given an integer n, return true if it is a power of three. Otherwise, return false.
		An integer n is a power of three, if there exists an integer x such that n == 3^x.
		Example 1:
		Input: n = 27
		Output: true
		Explanation: 27 = 33

		Example 2:
		Input: n = 0
		Output: false
		Explanation: There is no x where 3x = 0.
		Example 3:

		Input: n = -1
		Output: false
		Explanation: There is no x where 3x = (-1).
	
		Constraints:
			-231 <= n <= 231 - 1

		Follow up: 
			Could you solve it without loops/recursion?


		class Solution {
			public:
			bool isPowerOfThree(int n) {
				if(n<1)
					return 0;
				for(int i=0; ;i++){
					long long currPOW = pow(3,i);
					if(n == currPOW)
						return 1;
					
					if(currPOW>n)
						return 0;
				}
				return 0;
			}
		};

		//without using loops or recursion:
			class Solution {
				public:
				bool isPowerOfThree(int n) {
					if(n<1)
						return 0;
					double p = log10(n)/ log10(3);

					if(p - (int)p == 0)
						return 1;
					return 0;
				}
			};

	124) Binary strings with no consecutive 1s
		Problem Statement
			You have been given an integer N. Your task is to generate and return all binary strings of length 'N' such
			that there are no consecutive 1's in the string.
			A binary string is that string which contains only '0' and '1'
			For Example:
				Let 'N'=3, hence the length of the binary string would be 3.
				We can have the following binary strings with no consecutive 1s:
				000 001 010 100 101.
			Sample Input 1:
				4
				Sample Output 1:
				0000 0001 0010 0100 0101 1000 1001 1010 
				Explanation Of Sample Input 1:
				For N = 4 we get the following Strings:

				0000 0001 0010 0100 0101 1000 1001 1010 

				Note that none of the strings has consecutive 1s. Also, note that they are in a lexicographically increasing order.
				Sample Input 2:
				2
				Sample Output 2:
				00 01 10
				Constraints:
				1 <= 'N' <= 20

				Time limit: 1 second

		//own
			bool checkIfConsecutive(string inString){
				char frstChar = inString[0];
				for(int i=1; i<inString.length(); i++)
					if(inString[i-1]=='1' && inString[i]=='1')
						return 0;
				return 1;
			}
			vector<string> generateString(int N) {
				vector<string> ans;
				for (int i = 0; i < (1 << N); i++) {
					string startS = bitset<32>(i).to_string().substr(32 - N);
					if (checkIfConsecutive(startS)) {
						ans.push_back(startS);
					}
				}
				return ans;
			}

		//or (optional)
			bool checkIfConsecutive(const string& inString) {
				char prevChar = '0'; // Initialize prevChar to '0'
				for (char currentChar : inString) {
					if (prevChar == '1' && currentChar == '1') {
						return false;
					}
					prevChar = currentChar; // Update prevChar
				}
				return true;
			}

			vector<string> generateString(int N) {
				vector<string> ans;
				string startS(N, '0'); // Initialize with N '0's
				
				while (true) {
					if (checkIfConsecutive(startS)) {
						ans.push_back(startS);
					}

					// Increment startS manually (simulating binary addition)
					int carry = 1;
					for (int i = N - 1; i >= 0; i--) {
						if (startS[i] == '0' && carry == 1) {
							startS[i] = '1';
							carry = 0;
						} else if (startS[i] == '1' && carry == 1) {
							startS[i] = '0';
						}
					}

					// If carry is still 1, we've reached the end
					if (carry == 1) {
						break;
					}
				}

				return ans;
			}
	
	125) Overlapping ABBA
		-Simple words checking that string should contain 'AB' then 'BA' in any order.
		-if the string contain "AB" then "BA" or "BA" then "AB", & they are not Overlapping with each other then 
		 return true else false.
		Problem Statement
			Anish is given a string S and has been asked to determine if the given string S contains two non-overlapping
			substrings "AB" and "BA" (the substrings can go in any order).
			As a friend of Anish, your task is to return "True" if the string S contains two non-overlapping substrings "AB"
			and "BA" (the substrings can go in any order) otherwise return "False" (without quotes).
			Example:-
				The string "ABBA" has two non-overlapping substrings "AB" and
				will be printed(without quotes)
				respectively. So "True"
			Constraints :
				1 <= T <= 10
				1 <= |S| <= 10^4
				The string S contains uppercase Latin letters only.
				Time Limit = 1 sec
		Sample Input 1 :
			2
			ABA
			BACFAB
			Sample Output 1 :
			False
			True
			Explanation For Sample Output 1 :
			In the first test case, there are no two non-overlapping substrings, so “False” is printed.

			In the second test case, there are two non-overlapping substrings (BACFAB), so “True” is printed. 
			Sample Input 2 :
			2
			ABBA
			AXBYBXA
			Sample Output 2 :
			True
			False

		bool findOverlap(string &s){
			int cnt=0;
			for(int i=1; i<s.length(); i++){
				if(s[i] == 'A' && s[i-1] == 'B'){
					// s[i] = '0';						//replacing A, B with 0, so that it should not match again with A, B.
					// s[i-11] = '0';
					i++;
					cnt++;
				}
				if(s[i] == 'B' && s[i-1] == 'A'){
					// s[i] = '0';
					// s[i-11] = '0';
					i++;
					cnt++;
				}
			}
			if(cnt >= 2)
				return 1;
			return 0;
		}

	126) K-th Symbol in Grammar:
		We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, 
			we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
			For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
			Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

			Example 1:
				Input: n = 1, k = 1
				Output: 0
				Explanation: row 1: 0
				Example 2:

			Input: n = 2, k = 1
				Output: 0
				Explanation: 
				row 1: 0
				row 2: 01

			Example 3:
				Input: n = 2, k = 2
				Output: 1
				Explanation: 
				row 1: 0
				row 2: 01
			Constraints:
				1 <= n <= 30
				1 <= k <= 2n - 1

		//Not optimized:
			class Solution {
				public:
				int kthGrammar(int n, int k) {
					string s="0", newString;
					for(int i=2; i<=n; i++){
						int a=0;
						while(a<s.length() && a<k){
							if(s[a] == '0'){
								newString += "01";
							}else{
								newString += "10";
							}
							a++;
						}
						s = newString;
						newString = "";
					}
					return s[k-1]-48;
				}
			};

		//optimized:	
			class Solution {
				public:
				int kthGrammar(int n, int k) {
					if (n == 1 && k == 1) 
							return 0;

						// Calculate the midpoint of the previous row
						int mid = 1 << (n - 2);

						// If k is in the first half of the row, we can recursively find it in the previous row
						if (k <= mid) 
							return kthGrammar(n - 1, k);

						// If k is in the second half, we flip the bit from the previous row's result
						return 1 - kthGrammar(n - 1, k - mid);
				}
			};

	127) Reverse Words In A String:
		Problem Statement
			You are given a string 'str'of length 'N' Your task is to reverse the original string word by word.
			There can be multiple spaces between two words and there can be leading or trailing spaces but in the
			output reversed string you need to put a single space between two words, and your reversed string should
			not contain leading or trailing spaces.
			Example :
				If the given input string is "Welcome to Coding Ninjas", then you should return "Ninjas
				Coding to welcome" as the reversed string has only a single space between two words and
				there is no leading or trailing space.
			Sample Input 1 :
				Welcome to Coding Ninjas
				Sample Output 1:
					Ninjas Coding to Welcome
				Explanation For Sample Input 1:
					You need to reduce multiple spaces between two words to a single space 
					in the reversed string and observe how the multiple spaces, leading and trailing spaces have been removed.
				Sample Input 2 :
					I am a star
				Sample Output 2:
					star a am I
				Explanation For Sample Input 2:
					Your reversed string should not contain leading or trailing spaces.
				Constraints :
					0 <= N <= 10^5
					Time Limit: 1 sec
				Follow-Up:
					If the string data type is mutable in your language, can you solve it in place with O(1) extra space?

		string reverseString(string &str){
			vector<string> holder;
			string temp;
			for(int i=0; i<str.length(); i++){
				if(str[i] == ' '){
					if(!temp.empty()){
						holder.push_back(temp);
						temp.clear();
					}
					continue;
				}
				temp += str[i];	
			}
			
			//inserting last strig manually
			holder.push_back(temp);

			reverse(holder.begin(), holder.end());
			string ans;
			for(int i=0; i<holder.size(); i++){
				ans += holder[i];
				if(i!= holder.size()-1)
					ans += ' ';
			}

			//removing leading spaces
			while(ans[0] == ' '){
				ans.erase(0,1);
			}

			return ans;
		}

	128) Strobogrammatic Number (Problem no-23 Refer):
		Problem Statement
			Given a string 'N' that represents a number, you need to check if the given number is a strobogrammatic number or not.
			A strobogrammatic number is a number that looks the same when rotated by 180.
			In other words, a number that on rotating right side up and upside down appears the same is a strobogrammatic number.
			For Example:
				'986' is a strobogrammatic number because on rotating 986' by 180, "986' will be obtained.
			986		---180॰--> 986
			8008		---180॰--> 8008
			Constraints:
				1 <= T ‹= 50
				0 < = N <= 10^5
				Time limit: 1 sec
			Sample Input 1:
				2
				191
				8008
				Sample Output 1:
				False
				True
				Explanation Of Sample Input 1:
				Test Case 1: On rotating ‘191’ by 180, ‘161’ will be formed. So ‘191’ is not a strobogrammatic number.

				Test Case 2: On rotating ‘8008’, ‘8008’ will be obtained. So ‘8008’ is a strobogrammatic number.

				Sample Input 2:
				2
				8888
				543
				Sample Output 2:
				True
				False
		#include <bits/stdc++.h> 
		bool isStrobogrammatic(string &n) {
			for(int i=0; i<n.length(); i++)
				if(n[i] == '2' || n[i] == '3' || n[i] == '4' || n[i] == '5' || n[i] == '7')
					return 0;

			string revrs = n;
			reverse(revrs.begin(), revrs.end());

			for(int i=0; i<revrs.length(); i++){
				if(revrs[i] == '9'){
					revrs[i] = '6';
					continue;
				}
				if(revrs[i] == '6'){
					revrs[i] = '9';
				}
			}

			if(n == revrs)
				return 1;
			return 0;
		}
	
	129) Day 21: AUS vs NED: Sub-Squad
		-just have to return the total distinct number present in vector
		Problem Statement
			For the preparation of the upcoming Australia vs Netherlands world cup match, Australia is in the process of
			rearranging their squad. They have a squad of 'N' players represented by the array 'A', where the "ith' player
			has A[i] skill level.
			In one operation, you can rearrange the squad by swapping any two players. 
			Return the maximum length of any sub-squad after performing some operations such that all skill levels in
			that sub-squad are different.
			Example:-
				Let 'N' = 5, 'A' = [1, 3, 2, 3, 4].
				We can swap players at indexes 4 and 5 (1-based indexing)-
				So, our answer is 4.
				-here total 5 elements are there in vector but distinct elements are 1,2,3 & 4 ie. total 4 element unique.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' ‹= 10^5
				1 <= 'A[i]' <= 10^5
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				5
				1 4 1 3 1
				3
				2 5 1
				Sample Output 1:-
				3
				3
				Explanation Of Sample Input 1:-
				First test case:-
				Sub-squad from index 2 to 4 can be our answer.
				So, our answer is 3.

				Second test case:-
				All the players of the squad have distinct skill level.
				So, our answer is 3.
				Sample Input 2:-
				2
				2
				1 1
				4
				9 6 6 9
				Sample Output 2:-
				1
				2

		#include<bits/stdc++.h>
		int subsquad(vector<int> &a) {
			set<int> unique;
			for(int i=0; i<a.size(); i++)
				unique.insert(a[i]);
			return unique.size();
		}

	130) Day 20: SA vs BAN: Best Team:
		Problem Statement
			During this World Cup, brawls arise among fans about which team is the best. Since the strength of the team
			is a subjective matter, the ICC decided the strength by the number of fans a team has.
			You are given an array 'A' of length 'N' denoting the number of fans of each of the 'N' teams.
			Tension between two teams is minimum when the difference between the strengths of the teams is
			maximum because the weaker team just accepts the fact that the other team is better than them.
			Since they are underdog supporters, the weaker team switch sides and become fans of the stronger team
			when tension is minimum. After switching sides, the strength of the weaker team will be added to the
			strength of the stronger team, and the strength of the weaker team will become '0'.

			Return the strength of the stronger team before the last switch. The last switch is the one after which all fans
			support only one team.
			For Example :
				Let 'N' = 3, 'A' = [ '7, 4, 1' ].
				First, 'A[ 2 ]' will be added to 'A[ 0 ]' as their absolute difference between their
				strength is '7 - 1 = 6'.
				Then 'A[ 0 ]' becomes equal to '7 + 1 = 8'.
				Thus 'A' becomes [ '8, 4, 0' ].
				Now, 'A[ 1 ]' will be added to 'A[ 0 ]', changing 'A' to [ '12, 0, 0' ].
				Thus, '8' is the strength of the stronger team before last switch.
				Therefore, the answer is '8'.
			Constraints :
				1 <= 'T' ‹= 10
				2 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
				All elements of 'A' are unique.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				7 16 6
				2
				11 100
				Sample Output 1 :
				22
				100
				Explanation Of Sample Input 1 :
				First test case:-
					First, 'A[ 2 ]' will be added to 'A[ 1 ]' as their absolute difference is '16 - 6 = 10'.
					Then 'A[ 1 ]' becomes equal to '16 + 6 = 22'.
					Thus 'A' becomes [ '7, 22, 0' ].
					Now, 'A[ 0 ]' will be added to 'A[ 1 ]', changing 'A' to [ '0, 29, 0' ].
					Therefore the strength of the stronger team before last switch is '22'.
					Thus, the answer is '22'.

				Second test case:-
				Since we start with '2' teams, the last and only switch is between '11' and '100'.
				Therefore the strength of the stronger team before last switch is '100'.
				Thus, the answer is '100'.
				Sample Input 2 :
				2
				6
				101 267 953 764 11 690
				7
				123 456 789 1011 1213 1415 1617
				Sample Output 2 :
				2022
				5209

		//own solution:
			#include<bits/stdc++.h>
			long long gunDevil(int n, vector<int> &a) {
				long long mxer = *max_element(a.begin(), a.end());          //1.finding the first maximum element from vector
				int rep = a.size()-1;
				while(--rep){
					//2.then finding the min element from vector size()-1 times, 
					//  ie. if size=5 then 4 times, but but (in while loop it decrement the value first then uses it so) actual its for 3 time,
					//  we finding the min element & adding it to mxer variable.
					mxer += *min_element(a.begin(), a.end());     
					
					//3.changing the value to max at index where min element is there,
					//  coz it should not get caught again this, as min element
					// int index = min_element(a.begin(), a.end()) - a.begin();
					int index = distance(a.begin(), min_element(a.begin(), a.end()));
					a[index] = INT_MAX;
				}
				return mxer;
			}

		//Other solution:
			#include<bits/stdc++.h>
			long long gunDevil(int n, vector<int> &a) {
				long long mxer = *max_element(a.begin(), a.end()); // Find the maximum element.

				for (int i = 1; i < a.size() - 1; ++i) {            //adding the num till size()-
					int min_val = *min_element(a.begin(), a.end()); // Find the minimum element.

					mxer += min_val; // Add the minimum element to mxer.

					// Change the value to INT_MAX at the index where the minimum element is found.
					auto it = std::find(a.begin(), a.end(), min_val);			//syntax to find the iterator in vector with that min_val var name
					if (it != a.end()) {
						*it = INT_MAX;
					}
				}

				return mxer;
			}

	131) Day 17: ENG VS SA: Gear Selection:
		-just have to return n * (n-1);
		Problem Statement
			A cricket player is gearing up for the Cricket World Cup match between ENG and SA. He has 'N' jerseys and
			'N' track pants. The 'i-th' jersey and 'i-th' track pants have a color of type 'ї.
			A cricket gear consists of a single jersey and a single track pant. The player will like their gear if the color of
			the jersey and track pant is different.
			Return the number of cricket gears the player would like.
			Example:
				'N' - 3
				Let's assume the player has jerseys and track pants of colors 'Red', 'Green', and 'Blue'.
				The player will like cricket gears with:
				'Red jersey and Green track pant'
				'Red jersey and Blue track pant'

				'Green jersey and Red track pant'
				'Green jersey and Blue track pant'
				
				'Blue jersey and Red track pant'
				'Blue jersey and Green track pant'
				 So, the player will like '6' outfits.
			Constraints :
				1 <= T <= 10
				2 <= 'N' <= 2023
				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				3    
				Sample Output 1:
				4
				6
				Explanation Of Sample Input 1:
				For test case 1:
				Let's assume the player has jersey and track pants of colors 'Red', and 'Green'.

				The player will like cricket gears with:
				'Red jersey and Green track pant'
				'Green jersey and Red track pant'

				So, the player will like '2' cricket gears.

				For test case 2:
				Let's assume the player has jerseys and track pants of colors 'Red', 'Green', and 'Blue'.

				The player will like cricket gears with:
				'Red jersey and Green track pant'
				'Red jersey and Blue track pant'
				'Green jersey and Red track pant'
				'Green jersey and Blue track pant'
				'Blue jersey and Red track pant'
				'Blue jersey and Green track pant'

				So, the player will like '6' outfits.
				Sample Input 2:
				2
				14
				20
				Sample Output 2:
				182
				380

		int gearSelection(int n) {
			return n*(n-1);
		}

	132) Day 13: SA vs NED: Super Spell:
		-this problem mean to say, after sorting the array 2 element should not be same, 
		 if same return 0, not single element is repeated return 1.
		Problem Statement
			You have an array 'A' of length 'N' representing speeds of 'N' balls thrown in a spell.
			A spell is called 'Super Spell' if the balls thrown can be arranged in a way such that one of the following
			conditions is satisfied for each ball thrown:
			• It is the first ball thrown in the spell.
			• The speed of previous ball is strictly less than the speed of the current one.
			Return '1' if 'A' represents a super spell and return '0' otherwise.
			For Example:-
				Let 'N' = 5, 'A' = [ 5, 1, 2, 4, 8 ].
				Here, the spell can be arranged as [ 1, 2, 4, 5, 8 ].
			For the first ball, first condition is satisfied while the second condition is satisfied
			for next four balls.
			Hence, the answer is 1.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' ‹= 10^5
				1 <= 'A[i]' ‹= 10^5
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			
			Sample Input 1:-
				2
				4
				3 4 1 4
				2
				6 3
				Sample Output 1:-
				0
				1
				Explanation Of Sample Input 1:-
				First test case:-
				It can be shown that there is no such arrangement where this spell can be called super spell.
				So the answer is 0.

				Second test case:-
				Here, the spell can be arranged as [ 3, 6 ], making this spell a super spell.
				So the answer is 1.
				Sample Input 2:-
				2
				3
				3 2 1
				6
				3 6 1 4 3 6
				Sample Output 2:-
				1
				0

		//Approach-1
			#include<bits/stdc++.h>
			int candies(vector<int> &a) {
				sort(a.begin(), a.end());
				for(int i=1; i<a.size(); i++){
					if(a[i] == a[i-1])
						return 0;
				}
				return 1;
			}

		//Approach-2
			#include<bits/stdc++.h>
			int candies(vector<int> &a) {
				unordered_map<int, int> OCCScnt;
				for(int i = 0; i < a.size(); i++) {
					OCCScnt[a[i]]++;					//storing the cnt of occurrences of element in unordered_map.
				}
				for(auto it = OCCScnt.begin(); it != OCCScnt.end(); ++it) {
					if(it->second >= 2) {					//checking if the occurrence count, if its >= 2 
														//then you can say current spell ball has same power of previous spell ball 
														//so here 2 spell balls has same power.
						return 0;
					}
				}
				return 1;				//didn't found same power for spell ball, all balls have different power.
			}
	
	133) Odds Matter:
		Problem Statement
			You are given an array 'A' of length 'N'. You want to focus on its odd indices, so you delete all the elements on even indices.
			Return the final array.
			For Example :
				Let 'N' = 5, 'A' = [ 7, 2, 1, 3, 10 ]-
				The 'O-th', '2-nd', and '4-th' elements are deleted.
				Thus, the answer is [ 2, 3 ].
			Constraints :
				1 <= 'T' <= 10
				2 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				1 10 3 7
				2
				9 6
				Sample Output 1 :
				10 7
				6
				Explanation Of Sample Input 1 :
				First test case:-
				The '0-th' and '2-nd' elements are
				deleted. Thus, the answer is [ 10, 7 ].
				Second test case:-
					Only the '0-th' element is deleted Thus, the answer is [ 6 ].
				Sample Input 2
					2
					6
					4 3 4 9 19
					5
					8 9 7 11 14
					Sample Output 2 :
					3 9 9
					9 11

		vector<int> oddsMatter(int n, vector<int> &a) {
			vector<int> oddIndexElements;
			for(int i=1; i<a.size(); i+=2)
				oddIndexElements.push_back(a[i]);
			return oddIndexElements;
		}
				
	134) Ninja and String Conversion
		Problem Statement 
			Ninja has a string 'S' of length 'N' consisting of both  lowercase and uppercase letter.
			He has to perform these tasks: 
				If the letter is in lowercase, then replace it with
				the next letter e.g. replace 'a' with 'b', 'b' with 'c',
				and 'z' with 'a'.

				If the letter is in uppercase, then replace it with
				the previous letter e.g. replace 'B' with 'A', 'C'
				with 'B', and 'A' with 'Z'.
				
				Return the updated string after performing these tasks.
		Example:
			'N' = 4
			'S' = "bDcF"
			Here, 'b' and 'c' are two lowercase
			letters in the string, so we replace
			them with letters after that i.e. 'c'
			and 'd', respectively.
			'D' and 'F' are two uppercase letters in
			the string, so we replace them with
			letters before that i.e. 'C' and 'E'
			respectively.
			Hence the updated string is "cCdE".

			Constraints:
				1 <= T <= 100
				2 <= N <= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				3
				Aad
				3
				Pqr
				Sample Output 1:
				Zbe
				Ors

			Explanation Of Sample Input 1:
				For test case 1:
					Here 'a' and 'd' are two lowercase
					letters in the string so we replace them
					with letters after that i.e. 'b' and 'e'
					respectively.
					'A' is an uppercase letter in the string
					so we replace them with letters before
					that i.e. 'Z'.
					Hence the updated string is "Zbe".
				For test case 2:
					Here 'q' and 'r' are two lowercase
					letters in the string so we replace them
					with letters after that i.e. 'r' and 's'
					respectively.
					'P' is an uppercase letter in the string so we replace them with letters before that i.e. 'o'.
					Hence the updated string is "Ors"
				Sample Input 2:
					xyz
					hEx
					Sample Output 2:
					yza
					iDy

		string ninjaAndStringConversion(int n, string &s){
			string ans;
			for(int i=0; i<n; i++){
				if(s[i] == 'A'){
					ans += 'Z';
				}else if(s[i] == 'z'){
					ans += 'a';
				}else if(s[i]>= 'a' && s[i] <= 'y'){
					ans += ++s[i];
				}else if(s[i]>= 'B' && s[i] <= 'Z'){
					ans += --s[i];
				}
			}
			return ans;
		}
	
	135) Division:
		Problem Statement
			Alice has an integer, 'N'. He recently learned division. Alice says an integer is good if it satisfies the following
			conditions:
				1. It lies within the range '[1, N]' both inclusive.
				2. It is divisible by '2' and not by '3'.
			Determine the number of such good integers for the given 'N'.
			Example:
			'N' = 6
			Only '2' and '4' will satisfy both the conditions.
			The First is '2', which is divisible by '2' and not divisible by "3'.
			The second is '4', which is also divisible by '2' and not divisible by "3'.
			"6" does not satisfy the condition since it is divisible by '2' but is also divisible by "3".
			So the answer is '2'.

			Constraints :
				1 <= T <= 10
				1 <= N <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				14
				Sample Output 1:
					2
					5
			Sample Output 1 :
				Explanation Of Sample Input 1
				For test case 1:
				Only '[2,4]' will satisfy the conditions '1' and '3' are not divisible by "2'
				Both '2' and '4' are divisible by "2' and not by "3'.

				For test case 2:
					In this case, only '[2,4,8,10,14]' will satisfy the conditions.
					Here, "6" will not satisfy the conditions as it is divisible by "3".
					[1,3,5,7,9,11,13] will not satisfy as they are not divisible by "2".
					Only [2,4,8,10,14] will satisfy both conditions. The answer will be 5.
					Sample Input 2:
						2
						17
						23
					Sample Output 2:
						6
						8

		//solution:
			int division(int n) {
				int cnt=0;
				// for(int i=1; i<=n; i++){
				// 	if(i % 2 == 0)
				// 		if(i % 3 != 0)
				// 			cnt++;
				// }
				// return cnt;

				//or
				// vector<int> holder;
				for(int i=2; i<=n; i+=2)
					if(i % 3 != 0)
						cnt++;	
				return cnt;
				
			}

		//or
			int division(int n) {
				vector<int> holder;
				for(int i=1; i<=n; i++){
					if(i % 2 == 0)
						if(i % 3 != 0)
							holder.push_back(i);
				}
				return holder.size();

				//or
				// vector<int> holder;
				// for(int i=2; i<=n; i+=2)
				// 	if(i % 3 != 0)
				// 		holder.push_back(i);
				
				// return holder.size();
			}

	136) Odd To Even:
		❌Pending

		//Not Optimized:
			#include <bits/stdc++.h> 
			string oddToEven(string &num) {
				vector<string> evenNumHolder;
				int i;
				for(i=0; i<num.length(); i++){
					if((num[i]-48)%2 == 0)				//here instead subtracting 48 you can subtract '0' as char, coz 0 has ascii value of 48.
						break;
				}
				if(i==num.length())
					return "-1";

				//finding the first even num;
				for(int i=0; i<num.length(); i++){
					string temp = num;
					if((num[i]-48) % 2 == 0){					//like ((num[i] - '0')%2 == 0)
						swap(temp[i], temp[temp.length()-1]);
						evenNumHolder.push_back(temp);
					}
				}

				if(evenNumHolder.size()==1)
					return evenNumHolder[0];


				string ans =  evenNumHolder[0];
				for(int i=1; i<evenNumHolder.size(); i++){

					string two = evenNumHolder[i];
					for(int j=0; j<two.length(); j++){
						if(ans[j] == two[j])
							continue;
						if((ans[j]-48) > (two[j]-48)){
							ans;
							break;
						}
						else{
							ans = two;
							break;
						}
					}
				}
				return ans;
			}

			//or
			string oddToEven(string &num) {
				int n = num.length();
				int firstEvenIndex = -1;

				for (int i = 0; i < n; i++) {
					if (num[i] % 2 == 0) {
						firstEvenIndex = i;
						break;
					}
				}

				if (firstEvenIndex == -1) {
					return "-1";
				}

				vector<string> evenNumHolder;

				for (int i = 0; i < n; i++) {
					if (num[i] % 2 == 0) {
						string temp = num;
						swap(temp[i], temp[n - 1]);
						evenNumHolder.push_back(temp);
					}
				}

				if (evenNumHolder.size() == 1) {
					return evenNumHolder[0];
				}

				sort(evenNumHolder.begin(), evenNumHolder.end(), greater<string>()); // Sort in descending order

				return evenNumHolder[0];
			}

	137) Minimum Operations:
		Given a number N. Find the minimum number of operations required to reach N starting from 0.
		 You have 2 operations available:

			◈Double the number
			◈Add one to the number

			Example 1:
				Input:
				N = 8
				Output: 4
				Explanation: 
					0 + 1 = 1 --> 1 + 1 = 2 --> 2 * 2 = 4 --> 4 * 2 = 8.
			Example 2:

				Input: 
				N = 7
				Output: 5
				Explanation: 
					0 + 1 = 1 --> 1 + 1 = 2 --> 1 + 2 = 3 --> 3 * 2 = 6 --> 6 + 1 = 7.
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function minOperation() 
				which accepts an integer N and return number of minimum operations required to reach N from 0.

			Expected Time Complexity: O(LogN)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 106

		//Optimized:
			class Solution {
				public:
				int minOperation(int N){
					if(N == 1)
						return 1;
					else if(N == 2)
						return 2;
					else{
						int OPcnt=0;
						while(N!=0){
							if(N&1){
								OPcnt++;
								N--;
								continue;
							}
							N/=2;
							OPcnt++;
						}
						return OPcnt;
					}
				}
			};

		//or more optimized:
			class Solution {
				public:
				int minOperation(int N){
					int OPcnt=0;
					while(N!=0){
						if(N&1){
							OPcnt++;
							N--;
							continue;
						}
						N/=2;
						OPcnt++;
					}
					return OPcnt;
				}
			};

	138) Different Subsequences GCD:
		-just have to return the count of different gcd nums.
		Problem Statement
			You are given an array "ARR" of positive integers. Your task is to find the number of different GCD's in all the
			non-empty subsequences of the given array.
			Note:
				The GCD of a list of numbers is defined as the greatest number that perfectly divides all
				the members of the given list. For example, the GCD of 6, 8, and 10 is 2.
				A subsequence of the array is a list that can be made by using some elements of the given array. All the
				elements can also be part of a subsequence.
			For example: 
				the array [1, 2] has subsequences: [1], [2] and [1, 2]. Similarly for the
				array [1, 2, 3], one of the subsequences is [1, 3].
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^4
				1 <= ARR[i] ≤= 10^5
				Where "T' is the number of test cases, 'N', denotes the size of the array 'ARR', and
				'ARR[i]' denotes the elements of the array
				Time limit: 1 sec

			Sample Input 1:
				2
				3
				6 8 10
				3
				1 2 1
				Sample Output 1:
				4
				2
				Explanation For Sample Input 1:
				In the first test case, 
					subsequence 		|			GCD
					  6				|			6
					  8				|			8
					  10				|			10
					  6,8 			|			2
					  6,10			|			2
					  8,10			|			2
					  6,8,10			|			2
				The subsequences and their GCD’s are:
				The different GCD’s from the above table are 6, 8, 10, 2. So, the answer is 4.    

				In the second test case, 
					subsequence 		|			GCD
					  1				|			1
					  2				|			2
					  1				|			1
					  1,2 			|			1
					  1,1			|			1
					  2,1			|			1
					  1,2,1			|			1
				The subsequences and their GCD’s are:
				The different GCD’s from the above table are 1, 2. So, the answer is 2.  

				Sample Input 2:
				2
				4
				5 10 15 20
				3
				2 5 10
				Sample Output 2:
				4
				4
	
		//using online compiler c++ GDB
			#include <iostream>
			#include <bits/stdc++.h>
			using namespace std;
			int differentGCDSubsequence(vector<int> &arr) {
				vector<vector<int>> GCDstore;
				for(int i=0; i<arr.size(); i++){
					vector<int> temp;
					temp.push_back(arr[i]);
					GCDstore.push_back(temp);
				}

				//setting one to many relation 
				for(int i=0; i<arr.size()-1; i++){
					vector<int> temp;
					for(int j=i+1; j<arr.size(); j++){
						temp.push_back(arr[i]);
						temp.push_back(arr[j]);
						GCDstore.push_back(temp);
						temp.clear();               //making vector empty again.
					}
				}

				GCDstore.push_back(arr);

				set<int> uniqGCDs;
				//now finding the total no.of GCDs
				for(int i=0; i<GCDstore.size(); i++){
					if(GCDstore[i].size() ==1)
						uniqGCDs.insert(GCDstore[i][0]);
					else{
						int start = 2;
						int minValueFromCurrentArray = *min_element(GCDstore[i].begin(), GCDstore[i].end());
						int a;

						//traversing current vector only.
						int currentMAX = 1; 
						while(start <= minValueFromCurrentArray){
							for(a=0; a<GCDstore[i].size(); a++){
								if(GCDstore[i][a]%start == 0)
								continue;
								else
								break;
							}
							if(a == GCDstore[i].size() && start > currentMAX){
								currentMAX = start;
							}
							start++;
						}
						uniqGCDs.insert(currentMAX);
					}
				}
				for(int i: uniqGCDs){
					std::cout << i << std::endl;
				}
				return uniqGCDs.size();
			}

			int main() {   
				vector<int> arr = {5,10,15,20};
				std::cout << differentGCDSubsequence(arr) <<endl;
				return 0;
			}
	
		//Coding ninja platform (not optimized):
			#include <bits/stdc++.h>
			int differentGCDSubsequence(vector<int> &arr) {
				vector<vector<int>> GCDstore;
				for(int i=0; i<arr.size(); i++){
					vector<int> temp;
					temp.push_back(arr[i]);
					GCDstore.push_back(temp);
				}

				//setting one to many relation 
				for(int i=0; i<arr.size()-1; i++){
					vector<int> temp;
					for(int j=i+1; j<arr.size(); j++){
						temp.push_back(arr[i]);
						temp.push_back(arr[j]);
						GCDstore.push_back(temp);
						temp.clear();               //making vector empty again.
					}
				}

				GCDstore.push_back(arr);

				set<int> uniqGCDs;
				//now finding the total no.of GCDs
				for(int i=0; i<GCDstore.size(); i++){
					if(GCDstore[i].size() ==1)
						uniqGCDs.insert(GCDstore[i][0]);
					else{
						int start = 2;
						int minValueFromCurrentArray = *min_element(GCDstore[i].begin(), GCDstore[i].end());
						int a;

						//traversing current vector only.
						int currentMAX = 1; 
						while(start <= minValueFromCurrentArray){
							for(a=0; a<GCDstore[i].size(); a++){
								if(GCDstore[i][a]%start == 0)
								continue;
								else
								break;
							}
							if(a == GCDstore[i].size() && start > currentMAX){
								currentMAX = start;
							}
							start++;
						}
						uniqGCDs.insert(currentMAX);
					}
				} 
				return uniqGCDs.size();
			}

			//less code:
					#include <bits/stdc++.h>
					int differentGCDSubsequence(vector<int> &arr) {
						set<int> uniqGCDs;
						for (int num : arr) {
							set<int> newGCDs; // Store GCDs for current number
							newGCDs.insert(num); // Add the number itself

							// Combine GCDs from previous numbers
							for (int gcd : uniqGCDs) {
								newGCDs.insert(__gcd(num, gcd));
							}

							// Add the new GCDs to the set
							uniqGCDs.insert(newGCDs.begin(), newGCDs.end());
						}

						return uniqGCDs.size();

						//or below code
						// const int MAX_VALUE = 100001; // Adjust this based on the maximum possible value in the input array
						// vector<int> dp(MAX_VALUE, 0);
						// dp[0] = 1;

						// for (int num : arr) {
						//     for (int gcd = MAX_VALUE - 1; gcd >= 0; gcd--) {
						//         if (dp[gcd]) {
						//             int new_gcd = __gcd(gcd, num);
						//             dp[new_gcd] = 1;
						//         }
						//     }
						// }

						// int distinct = count(dp.begin(), dp.end(), 1) - 1; // Subtract 1 to exclude GCD 0
						// return distinct;

					}
	
	139) Shortest Word Distance II:
		Problem Statement
			You have a bookshelf in the form of an array 'arr' in which names of the books(single word name) are given.
			You are also given names of two books, 'book1' and 'book2'. You are supposed to find the minimum distance
			between 'book1' and book2'.
			Distance between two books is defined as the absolute difference between the indices of the books i.e for
			two books at index 'i' and 'j' the distance is equal to |i-j|.
			Note:
				1. There may be multiple occurrences of any book.
				2. book1 and book2 are present on the bookshelf.
				3. The name of the books is in lower-case.
				4. book is not equal to book2.
			Constraints:
				1<= T <= 50
				2 <= N <= 10^4
				1 <= arr[i].length <= 10^4
				All strings consist of lowercase letters only.
				Where 'T' is the number of test cases, and N denotes the number of elements in the array
				'arr', arr[i] denotes the element at index 'i'
				Time Limit: 1 sec
			Sample Input 1:
				2
				8
				coding ninjas help to crack product based companies
				coding product
				8
				eat code sleep repeat eat code sleep repeat 
				eat repeat
				Sample Output 1:
				5
				1
				Explanation For Sample Input 1:
				In the first test case, there are 8 books on the bookshelf.
				book1 = “coding”, book2 = “product”. The distance between book1 and book2 is 5. So, the answer is 5.
				In the second test case, there are 8 books on the bookshelf. and there are 2 occurrences in every book.
				book1 = “eat”, book2 = “repeat”.  book1 is present at indices 0 and 4. book2 is present at indices 3 and 7. The distances are 3, 7, 1, 4. The minimum of these is 1. So, the answer is 1.
				Sample Input 2:
				2
				5
				alpha beta gamma theta beta
				theta beta
				6
				be cool whatever the situation is
				situation cool
				Sample Output 2:
				1
				3

		#include <bits/stdc++.h> 
		int minimumDistance(vector<string> &arr, string book1, string book2) {
			int minDist = INT_MAX;
			//storing the indexes of book1 & book2
			vector<int> indexesB1;
			
			vector<int> indexesB2;
			for(int i=0; i<arr.size(); i++){
				if(book1 == arr[i])
					indexesB1.push_back(i+1);

				if(book2 == arr[i])
					indexesB2.push_back(i+1);
			}

			for(int i=0; i<indexesB1.size(); i++){
				for(int j=0; j<indexesB2.size(); j++){
					int tempNum = abs(indexesB1[i] - indexesB2[j]);
					if(tempNum < minDist)
						minDist = tempNum;
				}
			}

			return minDist;
		}
	
	140) Product Of Array Except Self (difficult):
		Problem Statement
			You have been given an integer array/list (ARR) of size N. You have to return an array/list PRODUCT such
			that PRODUCT[i] is equal to the product of all the elements of ARR except ARR[i]
			Note:
				Each product can cross the integer limits, so we should take modulo of the operation.
				Take MOD = 10^g + 7 to always stay in the limits.
			Follow Up:
				Can you try solving the problem in 0(1) space?
			Constraints :
				1 <= T <= 100
				0 <= N <= 10^5
				0 < = ARR[i] <= 10^5
				Time Limit: 1 sec	
			Sample Input 1 :
				2
				3
				1 2 3
				3
				5 2 2
				Sample Output 1 :
				6 3 2
				4 10 10
				Explanation For Sample Output 1 :
				Test case 1 : Given array = {1, 2, 3] 
				Required array = [2 * 3, 1 * 3, 1 * 2] = [6, 3, 2]
				Test case 2 : Given array = {5, 2, 2] 
				Required array = [2 * 2, 5 * 2, 5 * 2] = [4, 10, 10]
				Sample Input 2 :
				2
				1
				100
				2
				1 2
				Sample Output 2 :
				1
				2 1

		int *getProductArrayExceptSelf(int *arr, int n) {
			int *brr = new int[n];
			int *leftProducts = new int[n];
			int *rightProducts = new int[n];
			int mod = 1000000007; // 1e9 + 7

			// Calculate the product of elements to the left of each element.
			leftProducts[0] = 1;
			for (int i = 1; i < n; i++) {
				leftProducts[i] = (1LL * leftProducts[i - 1] * arr[i - 1]) % mod;
			}

			// Calculate the product of elements to the right of each element.
			rightProducts[n - 1] = 1;
			for (int i = n - 2; i >= 0; i--) {
				rightProducts[i] = (1LL * rightProducts[i + 1] * arr[i + 1]) % mod;
			}

			// Calculate the final result by multiplying leftProducts and rightProducts.
			for (int i = 0; i < n; i++) {
				brr[i] = (1LL * leftProducts[i] * rightProducts[i]) % mod;
			}
			return brr;
		}
	
	141) Day 22: ENG vs SL: All Caps :
		Problem Statement
			Given an array 'A' of length 'N' representing 'N' caps, the score required to win 'i-th' cap is 'A[i]'. Because you
			want to become the greatest cricket player alive, you challenge yourself to win all of these 'N' caps.
			But there is an issue: you can only achieve the score to win a particular cap if you have already won all caps
			with a lower score.
			If you have won the 'i-th' cap most recently and you want the 'j-th' cap, you must have won all caps with a
			score lower than the 'j-th' cap, and you have to work for '|j-i|' hours.
			Return the minimum number of hours you have to work to win all 'N' caps if, initially, you are at the first cap.
			For Example :
			Let 'N' = 3, 'A' = [ 4, 1, 2 ].
			Initially, you can win second cap by working for | 0 - 1 | = 1' hour.
			Then, your score allows you to win the third cap by working for '| 1 - 2 | = 1' hour.
			Finally, your score allows you to win the first cap by working for '| 2 - 0 | = 2' hours.
			The total hours you worked are '1 + 1 + 2 = 4' hours. It can be shown that this is the
			minimum work possible
			Thus, the answer is '4'.
			Constraints :
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				1 < 'A[i]' ‹= 10^9|
				The elements of 'A' are pairwise
				distinct.
				Time Limit: 1 sec
			Sample Input 1 :
				2
				3
				10 37 1
				2
				8 9
				Sample Output 1 :
				5
				1
				Explanation Of Sample Input 1 :
				First test case:-
				Initially, you can win the third cap by working for '| 0 - 2 | = 2' hours.
				Then, your score allows you to win the first cap by working for '| 2 - 0 | = 2' hours.
				Finally, your score allows you to win the second cap by working for '| 0 - 1 | = 1' hour.
				The total hours you worked are '1 + 2 + 2 = 5' hours. It can be shown that this is the minimum work possible.
				Thus, the answer is '5'.

				Second test case:-
				First, you can win the first cap by working for '| 0 - 0 | = 0' hour.
				Then, your score allows you to win the second cap by working for '| 0 - 1 | = 1' hour.
				Thus, the answer is '1'.
				Sample Input 2 :
				2
				4
				11 9 5 6
				5
				20 2 3 4 1
				Sample Output 2 :
				6
				12

		//NOT optimized:
			#include <bits/stdc++.h>
			long long underwaterValves(int n, vector<int> &h) {
				long long ans=0;
				int currentMinElementIndex = abs(h.begin() - min_element(h.begin(), h.end()));
				int prevMinElementIndex;

				ans += currentMinElementIndex;
				
				vector<int> sortedVec = h;
				sort(sortedVec.begin(), sortedVec.end());

				for(int i=1; i<h.size(); i++){
					prevMinElementIndex = currentMinElementIndex;
					currentMinElementIndex = abs(h.begin() - find(h.begin(), h.end(), sortedVec[i]));
					ans += abs(prevMinElementIndex - currentMinElementIndex);
				}
				return ans;
			}

		//Optimized:
			#include <bits/stdc++.h>
			long long underwaterValves(int n, vector<int> &h) {
				long long ans = 0;
				
				vector<int> sortedVec = h;
				sort(sortedVec.begin(), sortedVec.end());
				
				unordered_map<int, int> indexMap;
				for (int i = 0; i < n; i++) {
					indexMap[h[i]] = i;
				}
				
				int currentMinElementIndex = distance(h.begin(), min_element(h.begin(), h.end()));
				ans += currentMinElementIndex;
				
				for (int i = 1; i < n; i++) {
					int prevMinElementIndex = currentMinElementIndex;
					currentMinElementIndex = indexMap[sortedVec[i]];
					ans += abs(prevMinElementIndex - currentMinElementIndex);
				}
				
				return ans;
			}

		(optional) bit similar,
			#include <iostream>
			#include<bits/stdc++.h>

			using namespace std;
			int main() {
				// vector<int> vec = {20,25,3,4,1};
				// vector<int> vec = {20,2,3,4,1};
				vector<int> vec = {8,9};
				
				// vector<int> vec = {11,5,9,6};
				// vector<int> vec = {10,37,1};
				
				if(vec.size() ==2){
					cout<<"Final ans :"<<1;
					return 0;
				}
				
				for(int i: vec)
					std::cout << i << " ";

				std::cout << std::endl;
				vector<int> sortedVec = vec;
				
				sort(sortedVec.begin(), sortedVec.end());
				
				int ans =0;
				auto prevIndex = abs(vec.begin() - max_element(vec.begin(), vec.end()));
				
				for(int i=0; i<vec.size(); i++){
					int currentIndex = abs(vec.begin()- find(vec.begin(), vec.end(), sortedVec[i]));
					cout<<prevIndex << "  "<< currentIndex<<" ";
					int dist = abs(currentIndex - prevIndex);
					cout<<"Dist "<< dist<<" \t";
					ans +=  dist;
					prevIndex = currentIndex;
					cout<<ans<<"\n";
					
				}

				std::cout << endl<< "Final ans "<< ans << std::endl;
				return 0;
			}
	
	142) Split String:
		Problem Statement
			You are given a string 'str' of even length. Your task is to find out if we divide the 'str' from the middle, will
			both the substrings contain an equal number of vowels or not.
			For Example:
				You are given, 'str'= 'codingninjas', when we split this string we get, "coding' and
				'ninjas' which both contain 2 vowels each. Hence the answer is "True'…
			Constraints:
				1 <= T <= 10
				1 <= str ‹= 10^6
				"str' will contain upper and lower case characters of the English alphabet. |str| is even.
				Time Limit: 1 sec.
			Note :
				You do not need to print anything. It has already been taken care of. Just implement the given function.
		Sample Input 1:
			2
			codingninjas
			helloworld
			Sample Output 2:
			True
			False
			Explanation:
			For the first test case, ‘str’= ‘codingninjas’, when we split this string we get, ‘coding’ and ‘ninjas’ which both contain 2 vowels each. Hence the answer is ‘True’.

			For the second test case, ‘str’= ‘helloworld’, when we split this string we get ‘hello and ‘world’, which contain 2 and 1 vowels respectively. Hence the answer is ‘False’.
			Sample Input 2:
			2
			Aa
			AbbaaA
			Sample Output 2:
			True
			False
		#include <bits/stdc++.h> 
		bool splitString(string &str){
			//converting original string to lower case
			transform(str.begin(), str.end(), str.begin(), ::tolower);
			
			string s1 = str.substr(0, str.length()/2);          //from start till mid.
			string s2 = str.substr(str.length()/2);             //from (mid+1) to till end
			int cnt1 =0, cnt2=0;
			for(int i=0; i<s1.length(); i++){
				if(s1[i] == 'a' || s1[i] == 'e' || s1[i] == 'i' || s1[i] == 'o' || s1[i] == 'u')
					cnt1++;

				if(s2[i] == 'a' || s2[i] == 'e' || s2[i] == 'i' || s2[i] == 'o' || s2[i] == 'u')
					cnt2++;
			}

			if(cnt1 == cnt2)
				return 1;
			return 0;
		}
	
	143) Check whether K-th bit is set or not:
		Practice:
			#include <iostream>
			#include<bits/stdc++.h>
			using namespace std;

			void binaryRepresentation_NthBit(int num, int bit){
				std::cout <<"The binary num of "<< num << " " <<bitset<32>(num) <<" & "<<bit<<"s bit is : "<< ((num & (1<<bit))!=0) << std::endl;
			}

			int main() {
				int num = 4, nthBit=0;          //0-index
				binaryRepresentation_NthBit(num, nthBit);
				
				
				binaryRepresentation_NthBit(4, 1);
				binaryRepresentation_NthBit(4, 2);
				
				std::cout << std::endl;
				binaryRepresentation_NthBit(15, 0);
				binaryRepresentation_NthBit(15, 1);
				binaryRepresentation_NthBit(15, 2);
				binaryRepresentation_NthBit(15, 3);
				binaryRepresentation_NthBit(15, 4);
				
				return 0;
			}

		Problem Statement
			Given a number N and a bit number K, check if Kth index bit of N is set or not. 
			A bit is called set if it is 1. Position of set bit '1' should be indexed 
			starting with 0 from LSB side in binary representation of the number.
			Note: 
				Index is starting from 0. You just need to return true or false, 
				driver code will take care of printing "Yes" and "No".

			Example 1:
				Input: 
				N = 4
				K = 0
				Output: 
				No
				Explanation: 
					Binary representation of 4 is 100, in which 0th index bit from LSB is not set. So, return false.

			Example 2:
				Input: 
				N = 4
				K = 2
				Output: 
				Yes
				Explanation: 
					Binary representation of 4 is 100, in which 2nd index bit from LSB is set. So, return true.
		
			Example 3:
				Input: 
				N = 500
				K = 3
				Output: 
				No
				Explanation: 
					Binary representation of 500 is 111110100, in which 3rd index bit from LSB is not set. So, return false.
			Your task:
				You don't have to read input or print anything. 
				Your task is to complete the function checkKthbit that takes n and k as parameters 
				and returns either true(if kth bit is set) or false(if kth bit is not set).

			Expected Time Complexity: O(1).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ N ≤ 109
				0 ≤ K ≤ 31

		class Solution {
			public:
				// Function to check if Kth bit is set or not.
				bool checkKthBit(int n, int k) {
					while(k>0){					//or while(k!=0)
						k--;
						n>>=1;
					}
					if(n&1)
						return 1;
					return 0;
				}
		};

		class Solution {
			public:
				// Function to check if Kth bit is set or not.
				bool checkKthBit(int n, int k) {
					string s = bitset<32>(n).to_string();
					int i;
					for(i=s.length()-1; k>0; k--, i--){
						
					}
					if(s[i] == '1')
						return 1;
					return 0;
				}
		};

		//or for loop changed:
			class Solution {
				public:
					// Function to check if Kth bit is set or not.
					bool checkKthBit(int n, int k) {
						string s = bitset<32>(n).to_string();
						int i;
						for(i=s.length()-1; k>0; k--, i--);
						
						if(s[i] == '1')
							return 1;
						return 0;
					}
			};
	
		//or	string modified:
			class Solution {
				public:
					// Function to check if Kth bit is set or not.
					bool checkKthBit(int n, int k) {
						string s = bitset<32>(n).to_string();
						reverse(s.begin(), s.end());
						
						int i;
						for(i=0; i<k ;i++);			//checking till k. if k=4 then i incremented till 4 only.
						if(s[i] == '1')
							return 1;
						return 0;
					}
			};

		//or OPTIMIZED/ Advance:
			(1 << n) means 2ⁿ
			eg.
				1) n=2
					result=4 (because 2²=4)
					explanation:
						1 << 2		(left shift by 2)
						-> 1		initially
						->10		1st left shift	
						->100		2nd left shift	
						= 100 which is 4
				2) n = 5
					result = 32 (because 2⁵=32)
					explanation:
					1 << 5		(left shift by 5)
					-> 1		initially
					->10		1st left shift
					->100		2nd left shift
					->1000		3rd left shift
					->10000		4th left shift
					->100000		5th left shift
					= 1000000 which is 32

			class Solution {
			public:
				// Function to check if Kth bit is set or not.
				bool checkKthBit(int n, int k) {
					return ((n&(1<<k)) != 0);			//making kth bit directly 1 & checking. if its zero, 0 != 0 which is false & all expression leads to false
													//if its not zero then non-zero value, leads to true.
				}
			};

	144) Odd Even:
		Problem Statement
			Alice has two numbers, 'X' and 'Y'. He is asked to perform the following operations any number of times.
			Alice adds 1 to 'X' if 'X' is odd. Alice adds 2 to 'X' if 'X' is even. Will he be able to make 'X' equal to 'Y?
			Return 1 if 'X' can be made equal to 'Y' using the above operations any number of times(possibly 0) and 0 otherwise.
			Note: Assume 1-based indexing.
			For Example:
				Let 'X' = 3 and '' =6, Alice adds 1 to 'X' since 'X' is odd. Now 'X' will become 4.
				Then, Alice will add 2 to 'X', since 'X' is even, and it will become 6. 'X' becomes equal
				to 'Y'. Hence we will return 1 as the answer.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'X', 'Y' <= 10^9
				Time Limit: 1 sec
			Sample Input 1:-
					2
					4 8
					1 1
					Sample Output 1:-
					1
					1
					Explanation Of Sample Input 1:-
					First test case:- 
					In 1st operation, Alice will add 2 to 'X' as 'X' is even. Now, 'X' is 6. Again, in the 2nd operation, Alice will add 2 to 'X'. Now 'X' is 8, which is equal to 'Y'. So, the answer is 1.

					Second test case:-
					'X' is already equal to 'Y'. So, the answer is 1.
					Sample Input 2:-
					2
					4 9 
					7 8
					Sample Output 2:-
					0
					1
	
		int isPossible(int x, int y) {
			if(x==y)
				return 1;
			else if(x<=y && y%2==0)
				return 1;
			else
				return 0;	
		}
	
	145) EvenlySame:
		Problem Statement
			You are given two strings 'A', and 'B' of length 'N'. These strings are 'EvenlySame' if there are an even
			number of indices 'ї' such that 'A[i] == B[i]'
			Return 1, if 'A' and 'B' are 'EvenlySame' otherwise return 0.
			For Example:-
				Let 'N' = 5, 'A' = "abcde", 'B' = "xbfge".
				There are two indexes, 2, and 5 (1-based indexing) such that characters at these indexes are the same.
				So our answer is 1.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				'A' and 'B' consist of 'N' lowercase English letters
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				5
				pfeyu
				zuegh
				4
				pqrs
				pqrs
				Sample Output 1:-
				0
				1
				Explanation Of Sample Input 1:-
				First test case:-
				There is 1 index, 3 (1-based indexing) such that characters at this index are the same.
				So our answer is 0.

				Second test case:-
				There are four indexes, 1, 2, 3, and 4 (1-based indexing) such that characters at these indexes are the same.
				So our answer is 1.
				Sample Input 2:-
				2
				4
				abcc
				ajjc
				5
				uvvhy
				cddhi
				Sample Output 2:-
				1
				0

		int evenlySame(string a, string b) {
			int cnt=0;
			for(int i=0; i<b.length(); i++){
				if(a[i] == b[i])
					cnt++;
			}
			if(cnt&1)
				return 0;
			return 1;
		}
	
	146) Cut Array:
		Problem Statement
			You are given an array 'A' of length 'N'. You can cut an array at an index 'i' to split the array into two arrays,
			one containing elements from indices 0 to 'i - 1' and the other containing the rest.
			Your goal is to make all arrays sorted in non-decreasing order. You can perform cuts on 'A' and all
			subsequent arrays formed from cuts.
			Return the minimum number of cuts you have to perform.
			For Example:
				Let 'N' = 3, 'A' = [ 2, 5, 3 ].
				We perform a cut at index '2' to obtain the arrays: [2, 5] and [3 ]. All arrays are now
				sorted in non-decreasing order
				It can be shown that this is the minimum number of cuts needed. Thus, the answer is '1'.
			Constraints :
				1 <= 'T' <= 10
				3 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^9
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				100 7 11 3
				3
				3 9 13
				Sample Output 1 :
				2
				0
				Explanation Of Sample Input 1 :
				First test case:-
				We perform a cut at index '3' to obtain the arrays: [ 100, 7, 11 ] and [ 3 ].
				We perform another cut at index '1' of the first array to obtain the arrays: [ 100 ], [ 7, 11 ], and [ 3 ]. All arrays are now sorted in non-decreasing order.
				It can be shown that this is the minimum number of cuts needed.
				Thus, the answer is '2'.

				Second test case:-
				The array is already sorted in non-decreasing order.
				Thus, the answer is '0'.
				Sample Input 2 :
				2
				5
				3 2 1 2 3
				6
				8 9 2 30 20 17
				Sample Output 2 :
				2
				3

		int cutArray(int n, vector<int> &a) {
			int cnt=0;
			for(int i=1; i<a.size(); i++){
				if(a[i] >= a[i-1])
					continue;
				else
					cnt++;
			}
			return cnt;
		}
	
	147) Square Root Of An Integer:
		Problem Statement
			You are given an integer 'A: Your task is to find the greatest non-negative integer whose square is less than
			or equal to 'A.
			Square of a number is the product of the number with itself. 
			For e.g. square of 3 is 9.
			Constraints
				1 <= T <= 10^4
				0 <= A <= 10^5
				Time Limit: 1 sec
			Sample Input 1
				2
				8
				9
				Sample Output 1
				2
				3
				Explanation Of Input 1
				The greatest non-negative integer for test case 1 whose square is less than equal to 8 is 2 
				as the square of 3 is 9 which is greater than 8.

				The greatest non-negative integer for test case 2 whose square is less than equal to 9 is 3 
				as the square of 4 is 16 which is greater than 9. 
				Sample Input 2
					2
					1
					0
					Sample Output 2
					1
					0

		//not optimized:
			#include <bits/stdc++.h> 
			int squareRoot(int a) {
				int i=0;
				int ans =i;
				while(i<=a){
					if(pow(i,2) <= a)
						ans = i;
					i++;		
				}
				return ans;
			}
		
		//Optimized:
			#include <bits/stdc++.h> 
			int squareRoot(int a) {
					if (a <= 1) {
					return a;
				}

				int left = 1;
				int right = a;
				int result = 0;

				while (left <= right) {
					int mid = left + (right - left) / 2;
					if (mid <= a / mid) {
						left = mid + 1;
						result = mid;
					} else {
						right = mid - 1;
					}
				}

				return result;
			}
	
	148) (Ninja) Ninja's Frustrating Homework:
		Problem Statement
			Ninja got a summer vacation homework in which he got a booklet containing a very long string and some set
			of words written in his diary for which he had to search all these words in that string booklet.
			His teacher asked him to write all the starting indices for all the words written in the diary after searching
			that from the string booklet.
			Ninja finds this work very frustrating. He tries to find some help from his neighbor and currently, you are the
			one who is his neighbor.
			It is very time consuming to find every word in the string booklet manually. So you decide to design a code
			for that. Help Ninja!
			Note:
				Follow 0 based indexing
				Print the indices in sorted order
			
			Sample Input 1 :
				2
				abcab
				3
				a cab abca
				ninjasmart
				3
				jas art nin 
				Sample Output 1:
				0 1 2
				0 3 7 
				Explanation For Sample Input 1:
				Test Case 1 :
				The given string is “abcab”. The word “a” is present in the string starting from index 0 and ending at index 0, The word “cab” has starting index 2 and ending index 4 , “abca” has starting index 0 ending index 3.

				Test Case 2:
				The given string is “ninjasmart”. “Jas” has starting index 3 ending index 5, “art” has starting index 8 ending index 10, “nin” has starting index 0 ending index 2.
				Sample Input 2:
				2
				ahishers
				4
				he she his hers
				bheythis
				2
				hey this 
				Sample Output 2:
				1 3 4 4
				1 4

		#include <bits/stdc++.h> 
		vector<int> searchWords(string booklet, vector<string> &diary) {
			vector<int> ans;
			for (int i = 0; i < diary.size(); i++) {
				int pos = booklet.find(diary[i]);
				while (pos != string::npos) {
					ans.push_back(pos);
						
						//finding the next occurrenece of that word
					pos = booklet.find(diary[i], pos + 1);
				}
			}

			sort(ans.begin(), ans.end());
			return ans;
		}

	149) Russian Doll Envelopes:
		Problem Statement
			You are given a set of 'N' rectangular envelopes. The height and width of each envelope are given by arrays,
			'height' and 'width' respectively, each consisting of 'N' positive integers. The height, width of the ith envelope
			is given by 'height[i]' and 'width[i]" respectively.
			You can put one envelope inside another envelope if and only if both the height and width of one envelope is
			strictly greater than the height and width of the other envelope.
			What is the maximum number of envelopes you can Russian doll? (put one inside other)|
			Note
				Rotation of envelope is not allowed, that is, height and width can't be exchanged
			Constraints:
				1 <= T <= 50
				1 <= n <= 10^4
				1 <= height[i] <= 10^9
				1 <= width[i] <= 10^9
				Time Limit: 2 sec
		
		Sample Input 1:
			2
			4
			5 6 6 2
			4 4 7 3
			2
			2 1 
			2 1
			Sample Output 1:
			3 
			2
			Explanation For Sample Output 1:
			Test Case 1:
			The number envelopes, ‘N’ = 4 
			‘height’ = {5, 6, 6, 2}
			‘width’= {4, 4, 7, 3}
			Let denote dimensions of the envelope in (Height, Width) manner then, one way of Russian Doll envelopes in outermost to the innermost manner is as follow:

			Select the third envelope, i.e., envelope with dimensions (6, 7) as the outermost envelope.

			Place the first envelope i.e envelope with dimensions (5, 4) inside the outermost envelope. You can do this because both the height and width of this envelope is strictly less than the outermost envelope.

			Place the fourth envelope i.e envelope with dimensions (2, 3) inside the previous envelope.

			In this way, we can Russian Doll 3 envelopes. 

			No other way can Russian Doll more than 3 envelopes.

			Test Case 2:
			You can put the second envelope inside the first envelope because both the height and width of the second envelope are strictly less than the first envelope.
			Sample Input 2:
			2
			1
			2
			3
			3
			1 1 1
			1 1 1
			Sample Output 2:
			1
			1

		//Not optimized:
			#include <bits/stdc++.h>
			int findMaxEnvelopes(vector<int> &height, vector<int> &width, int n) {
				vector<pair<int, int>> envelopes;
				for (int i = 0; i < n; i++) {
					envelopes.push_back({height[i], width[i]});
				}

				// Sort the envelopes based on height and then width in ascending order.
				sort(envelopes.begin(), envelopes.end());

				// Create an array to store the longest increasing subsequence ending at each index.
				vector<int> dp(n, 1);

				for (int i = 1; i < n; i++) {
					for (int j = 0; j < i; j++) {
						if (envelopes[i].first > envelopes[j].first && envelopes[i].second > envelopes[j].second) {
							dp[i] = max(dp[i], dp[j] + 1);
						}
					}
				}

				// Find the maximum value in the dp array, which represents the maximum number of nested envelopes.
				int maxEnvelopes = *max_element(dp.begin(), dp.end());

				return maxEnvelopes;
			}
	
		//Optimized:
			#include <bits/stdc++.h>
			bool envelopeComparator(const pair<int, int> &a, const pair<int, int> &b) {
				return (a.first < b.first) || (a.first == b.first && a.second > b.second);
			}

			int findMaxEnvelopes(vector<int> &height, vector<int> &width, int n) {
				vector<pair<int, int>> envelopes;
				for (int i = 0; i < n; i++) {
					envelopes.push_back({height[i], width[i]});
				}

				sort(envelopes.begin(), envelopes.end(), envelopeComparator);

				vector<int> dp;
				for (const auto &env : envelopes) {
					auto it = lower_bound(dp.begin(), dp.end(), env.second);
					if (it == dp.end()) {
						dp.push_back(env.second);
					} else {
						*it = env.second;
					}
				}

				return dp.size();
			}

	150) Bleak Numbers: ❌Pending
		Given an integer, check whether it is Bleak or not.
			A number n is called Bleak if it cannot be represented as sum of 
			a positive number x and set bit count in x, i.e., x + countSetBits(x) is 
			not equal to n for any non-negative number x.

			Example 1:
				Input: 
				4
				Output: 
				1
				Explanation: 
				There is no x such that x + countSetbit(x) = 4

			Example 2:
				Input: 
				3
				Output: 
				0
				Explanation: 
				3 is a Bleak number as 2 + countSetBit(2) = 3.

			Your Task:
			You don't need to read or print anything. Your task is to complete the 
			function is_bleak() which takes n as input parameter and returns 1.
			if n is not a Bleak number otherwise returns 0.

			Expected Time Complexity: O(log(n) * log(n))
			Expected Space Complexity: O(1)
			
			Constraints:
				1 <= n <= 10^9

		//Not Optimized:
			class Solution {
				public:
				int bitCounter(int n){
					int cnt=0;
					while(n!=0){
						if(n&1)
						cnt++;
						n >>=1;
					}
					return cnt;
				}
				
				int is_bleak(int n) {
					//counting the set bit in given num
					int cnt =0,sum=0;
					while(n > sum){
						sum = cnt + bitCounter(cnt);
						
						if(sum == n)
							return 0;
						cnt++;
					}
					return 1;
				}
			};

	151) Sort Integers by The Number of 1 Bits:
		You are given an integer array arr. Sort the integers in the array in ascending order 
			by the number of 1's in their binary representation and in case of two or more 
			integers have the same number of 1's you have to sort them in ascending order.
			Return the array after sorting it.

			Example 1:
				Input: arr = [0,1,2,3,4,5,6,7,8]
				Output: [0,1,2,4,8,3,5,6,7]
				Explantion: [0] is the only integer with 0 bits.
					[1,2,4,8] all have 1 bit.
					[3,5,6] have 2 bits.
					[7] has 3 bits.
					The sorted array by bits is [0,1,2,4,8,3,5,6,7]

			Example 2:
				Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
				Output: [1,2,4,8,16,32,64,128,256,512,1024]
				Explantion: All integers have 1 bit in the binary representation, 
					you should just sort them in ascending order.
			
			Constraints:
				1 <= arr.length <= 500
				0 <= arr[i] <= 104

		class Solution {
			public:
			vector<int> sortByBits(vector<int>& arr) {
				vector<pair<int, int>> manipulator;

				for(int i=0; i<arr.size(); i++){
					int currentElementCnt = __builtin_popcount(arr[i]);
					pair<int, int> temp = {arr[i], currentElementCnt};
					manipulator.push_back(temp);
				}

				sort(manipulator.begin(), manipulator.end(), [](pair<int,int> &a, pair<int,int> &b){
					if(a.second != b.second)
						return a.second < b.second;
					return a.first < b.first;
				});

				vector<int> ans;

				for(int i=0; i<arr.size(); i++){
					int value = manipulator[i].first;
					ans.push_back(value);
				}
				return ans;
			}
		};

	152) Beautiful Xor Pairs:
		Problem Statement
			Ninja has an array 'ARR' consisting of 'N' positive integers. He also has two positive integers 'LOW', 'HIGH'
			such that 'HIGH' >= 'LOW'.
			According to Ninja, a pair of integers (i, j) is considered beautiful if 0 <i <j < 'N' and 'LOW' <= ('ARR[i]' XOR
			'ARRI]') <= 'HIGH'.
			Ninja wants to count beautiful pairs in 'ARR'. Find and return the number of beautiful pairs in 'ARR' on behalf
			of Ninja.
			Note:
				1. Consider 0 based indexing in "ARR'

		Constraints:
			1 <= T <= 50
			1 <= N <= 10000
			1 <= ARR[i] <= 20000
			1 <= LOW <= HIGH <= 20000
			Where "T' is the number of test cases, 'N' is the size of "ARR', and 'LOW', "HIGH' are
			the integers that Ninja have, "ARR[i]' is the 'i-th' element of arraylist "ARR'
			Time limit: 1 sec
		Sample Input 1:
			2
			1 1 2
			1
			4 6 8
			3 4 5 2
			Sample Output 1:
			0
			4
			Explanation Of Sample Input 1:
			In the first test case, there is only one integer in ‘ARR’ so no pair is possible.

			In the second test case, There are 6 pairs as follow -:
			1. (0, 1):  ‘ARR[0]’ XOR ‘ARR[1]’ = 3 XOR 4 = 7
			2. (0, 2):  ‘ARR[0]’ XOR ‘ARR[2]’ = 3 XOR 5 = 6
			3. (0, 3):  ‘ARR[0]’ XOR ‘ARR[3]’ = 3 XOR 2 = 1
			4. (1, 2):  ‘ARR[1]’ XOR ‘ARR[2]’ = 4 XOR 5 = 1
			5. (1, 3):  ‘ARR[1]’ XOR ‘ARR[3]’ = 4 XOR 2 = 6
			6. (2, 3):  ‘ARR[2]’ XOR ‘ARR[3]’ = 5 XOR 2 = 7
			Clearly, there are 4 beautiful pairs i.e (0, 1), (0, 2), (1, 3) and (2, 3)
			Sample Input 2:
			2
			4 2 6
			1 4 2 7
			5 5 14
			9 8 4 2 1
			Sample Output 2:
			6
			8

		//Not Optimized:
			#include <bits/stdc++.h> 
			int countBeautifulPairs(vector<int> &arr, int low, int high) {
				int cnt=0;
				for(int i=0; i < arr.size(); i++){
					for(int j=i+1; j<arr.size(); j++){
						int checker = arr[i] ^ arr[j];
						if((low <= checker) && (checker <= high)){
							cnt++;
						}
					}
				}
				return cnt;
			}

	153) Move all zeroes to end of array: (Lecture-20 Problem-4)
		Given an array arr[] of n positive integers.
			Push all the zeros of the given array to the right end of the array 
			while maintaining the order of non-zero elements. 
			Do the mentioned change in the array in-place.

			Example 1:
				Input:
				N = 5
				Arr[] = {3, 5, 0, 0, 4}
				Output: 3 5 4 0 0
				Explanation: The non-zero elements
				preserve their order while the 0
				elements are moved to the right.

			Example 2:
				Input:
				N = 4
				Arr[] = {0, 0, 0, 4}
				Output: 4 0 0 0
				Explanation: 4 is the only non-zero
				element and it gets moved to the left.

			Your Task:
				You don't need to read input or print anything. 
				Complete the function pushZerosToEnd() which takes the array 
				arr[] and its size n as input parameters and modifies arr[] 
				in-place such that all the zeroes are moved to the right.  

			Expected Time Complexity: O(n)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 105
				0 ≤ arri ≤ 105

		class Solution{
			public:
				void pushZerosToEnd(int arr[], int n) {
				
					vector<int> storer;
					for(int i=0; i<n; i++){
						if(arr[i] != 0)
							storer.push_back(arr[i]);
					}
					
					int i;
					for(i=0; i<storer.size(); i++){
						arr[i] = storer[i];
					}
					
					for(i;i<n; i++){
						arr[i] = 0;
					}
				}
		};

		//in-place(without using extra space, O(1)):
			class Solution{
				public:
					void pushZerosToEnd(int arr[], int n) {
						int cnt=0;
						for(int i=0; i<n; i++){
							if(arr[i] != 0)
								arr[cnt++] = arr[i];
						}
						for(int i=cnt;i<n; i++){
							arr[i] = 0;
						}
					}
			};

			//or
				class Solution{
					public:
						void pushZerosToEnd(int arr[], int n) {
							int cnt=0;
							for(int i=0; i<n; i++){
								if(arr[i] != 0)
									swap(arr[cnt++], arr[i]);
							}
						}
					};

	154) Missing Number:
		Given an array nums containing n distinct numbers in the range [0, n], 
			return the only number in the range that is missing from the array.		

			Example 1:
				Input: nums = [3,0,1]
				Output: 2
				Explanation: n = 3 since there are 3 numbers, 
				so all numbers are in the range [0,3]. 
				2 is the missing number in the range since 
				it does not appear in nums.

			Example 2:
				Input: nums = [0,1]
				Output: 2
				Explanation: n = 2 since there are 2 numbers, 
				so all numbers are in the range [0,2]. 
				2 is the missing number in the range since 
				it does not appear in nums.

			Example 3:
				Input: nums = [9,6,4,2,3,5,7,0,1]
				Output: 8
				Explanation: n = 9 since there are 9 numbers, 
				so all numbers are in the range [0,9]. 
				8 is the missing number in the range since 
				it does not appear in nums.

			Constraints:
				n == nums.length
				1 <= n <= 104
				0 <= nums[i] <= n
				All the numbers of nums are unique.

		class Solution {
			public:
			int missingNumber(vector<int>& nums) {
				int n = nums.size();

				//finding sum of n num.
				int Actualsum = n*(n+1)/2;

				int FakeSum = 0;
				for(int i: nums){
					FakeSum += i;
				}
				return Actualsum-FakeSum;
			}
		};
	
	155) Frequencies of Limited Range Array Elements:
		Given an array arr[] of N positive integers which can contain integers from 1 to P 
			where elements can be repeated or can be absent from the array. 
			Your task is to count the frequency of all numbers from 1 to N. 
			Make in-place changes in arr[], such that arr[i] = frequency(i). Assume 1-based indexing.
			Note: The elements greater than N in the array can be ignored for counting and do modify the array in-place. 

			Example 1:
				Input:
				N = 5
				arr[] = {2, 3, 2, 3, 5}
				P = 5
				Output:
				0 2 2 0 1
				Explanation: 
				Counting frequencies of each array element
				We have:
				1 occurring 0 times.
				2 occurring 2 times.
				3 occurring 2 times.
				4 occurring 0 times.
				5 occurring 1 time.

			Example 2:
				Input:
				N = 4
				arr[] = {3,3,3,3}
				P = 3
				Output:
				0 0 4 0
				Explanation: 
				Counting frequencies of each array element
				We have:
				1 occurring 0 times.
				2 occurring 0 times.
				3 occurring 4 times.
				4 occurring 0 times.

			Example 3:
				Input:
				N = 2
				arr[] = {8,9}
				P = 9
				Output:
				0 0
				Explanation: 
				Counting frequencies of each array element
				We have:
				1 occurring 0 times.
				2 occurring 0 times.
				Since here P=9, but there are no 9th Index present so can't count the value.
			
			Your Task:
				You don't need to read input or print anything. 
				Complete the function frequencyCount() that takes the array arr, and integers n, 
				and p as input parameters and modify the array in-place to denote the frequency count of each element from 1 to N.

			Expected time complexity: O(N)
			Expected auxiliay space: O(1)

			Constraints:
				1 ≤ N ≤ 105
				1 ≤ P ≤ 4*104 
				1 <= arr[i] <= P

		//Not Optimized:
			class Solution{
				public:
				//Function to count the frequency of all elements from 1 to N in the array.
				void frequencyCount(vector<int>& arr,int N, int P) { 
					int value = 1;
					vector<int> ans;
					for(int i=0; i<N; i++){
						int cnt=0;
						for(int j=0; j<N; j++){
							if(arr[j] == value)
								cnt++;
						}
						ans.push_back(cnt);
						value++;
					}
					arr = ans;
				}
			};

		//Optimized:
			class Solution{
				public:
				//Function to count the frequency of all elements from 1 to N in the array.
				void frequencyCount(vector<int>& arr,int N, int P) {

					//using unordered_map to keep the frequency of element
					unordered_map<int, int> FreqCounter;
					for(int i=0; i<N; i++){
						FreqCounter[arr[i]]++;				//mapping that element count, if the element found then we are incrementing their value in map.
					}									//& default in map, if key has corresponding value then it takes that value, else the default value is zero only.
					
					int value=1;
					for(int i=0; i<N; i++){
						arr[i] = FreqCounter[value];				//here checking for that key what's the value is there in map. 
						value++;								//if found takes that value else default is zero only
					}
				}
			};

	156) Special Sum of Array:
		Problem Statement
			You have been given an array/list 'arr' of length 'N', which contains single digit elements at every index. Your
			task is to return the sum of all elements of the array. But the final sum should also be a single digit.
			To keep the output single digit - you need to keep adding the digits of the output number till a single digit is left.
			For Example:
				For the given array [5, 8, 4, 9]
				The sum of the elements of the array will be
				5 + 8 + 4 + 9 = 26
				Since 26 is not a single-digit number, we will again take the sum of the digits of 26.
				2 + 6 = 8.
				Now 8 is a single-digit number. So we will stop here and return 8.
			Constraints:
				1 <= Т <= 100
				1 <= N <= 10^3
				0 <= arr[i] <= 9
				It is guaranteed that the sum of 'N' over all test cases doesn't exceed 10^5.
				Time Limit: 1 sec.

			Sample Input 1:
				2
				5
				8 7 0 1 2
				4
				4 2 1 1
				Sample Output 1:
				9
				8
				Explanation For Sample Output 1:
				Test Case 1:

				For the given array [8, 7, 0, 1, 2]
				The sum of the elements of the array will be
				8 + 7 + 0 + 1 + 2 = 18.

				Since 18 is not a single-digit number, we will again take the sum of the digits of 18. 
				1 + 8 = 9.
				Now 9 is a single-digit number. So we will stop here and return 9.

				Test Case 2:

				For the given array [4, 2, 1, 1]
				The sum of the elements of the array will be
				4 + 2+ 1 + 1 = 8.
				Since 8 is a single-digit number, we will just return 8.
				Sample Input 2:
				2
				4
				3 1 2 1
				9
				1 9 4 6 2 8 2 0 1
				Sample Output 2:
				7
				6

		#include <bits/stdc++.h> 
		int specialSum(vector<int>& arr, int n){
			int sum =0;
			for(int i=0; i<n; i++){
				sum += arr[i];
			}
			check:
			if(sum <= 9)
				return sum;

			vector<int> ans;
			while(sum != 0 ){
				ans.push_back(sum%10);
				sum /= 10;
			}
			sum =0;
			for(int i=0; i<ans.size(); i++){
				sum += ans[i];
			}
			goto check;
		}
	
	157) Left Rotate an Array by One:
		Problem Statement
			Given an array 'arr' containing 'n' elements, rotate this array left once and return it.
			Rotating the array left by one means shifting all elements by one place to the left and moving the first
			element to the last position in the array.
			Example:
				Input: 'a' = 5, 'arr' = [1, 2, 3, 4, 5]
				Output: [2, 3, 4, 5, 1]
				Explanation: We moved the 2nd element to the 1st position, and 3rd element to the 2nd
				position, and 4th element to the 3rd position, and the 5th element to the 4th position,
				and move the 1st element to the 5th position.
			Expected Time Complexity:
				O( n ), Where ‘n’ is the size of an input array ‘arr’.

			Constraints :
				1 <= 'n' <= 10^5
				1 <= 'arr[i] <= 10^9
				Time Limit: 1 sec

			Sample Input 1:
				4
				5 7 3 2 
				Sample Output 1:
				7 3 2 5
				Explanation Of Sample Input 1:
				Move the first element to the last and rest all the elements to the left.
				Sample Input 2:
				5
				4 0 3 2 5 
				Sample Output 2:
				0 3 2 5 4
				Explanation Of Sample Input 2:
				Same as sample input 1, Move the first element to the last and rest all the elements to the left

		#include <bits/stdc++.h> 
		vector<int> rotateArray(vector<int>& arr, int n) {
			int value = arr[0];
			arr.erase(arr.begin());
			arr.push_back(value);
			return arr;
		}

		//or
			#include <bits/stdc++.h> 
			vector<int> rotateArray(vector<int>& arr, int n) {
				int value = arr[0];
				for(int i=0; i<n-1; i++){
					arr[i] = arr[i+1];
				}
				arr[n-1] = value;
				return arr;
			}

	158) Digit Count In Range:
		Problem Statement
			You are given an integer "K', and two numbers 'A' and 'B'. You need 
			to count the occurrences of the given digit 'K', in the range [A, B].
			Note:
				You need to count occurrences at every place of the number. You also need to include the
				lower and higher limits of the given range
			For Example:
				Given K = 3, A = 1, B = 15, then 3 occurs 2 times(3, 13) in the range [1, 15], so you need
				to print 2.
			Constraints:
				1 ‹= T ‹= 100
				0 <= K <= 9
				0 ‹= А, В ‹= 10^18
				where "T' is the number of test cases, "K' is the digit and "A' and "B"  are the two integers.
				Time limit: 1 sec
			Sample Input 1:
				2
				3
				1 15
				2
				2 12
				Sample Output 1:
				2
				2
				Explanation Of Sample Input 1:
				In the first test case, 
				Number of occurrences of 3 in range [1, 13] = 2 (3, 13). Return 2


				In the second test case, 
				Number of occurrences of 2 in range [2, 12] = 2 (2, 12). Return 2
				Sample Input 2:
				2
				1 
				1 15
				3
				3 33
				Sample Output 2:
				8
				8
				Explanation Of Sample Input 1:
				In the first test case, 
				Number of occurrences of 1 in range [1, 15] = 8 (1, 10, 11, 12, 13, 14, 15). Return 8

				In the second test case, 
				Number of occurrences of 3 in range [3, 33] = 8 (3, 13, 23, 30, 31, 32, 33). Return 8
		
		//Not Optimized:
			#include <bits/stdc++.h> 
			long long int digitCount(int K, long long int A, long long int B) {
				// Write your code here
				long long int cnt=0;
				for(long long int i = A; i<=B; i++){
					long long int currentValue = i;
					while(currentValue != 0){
						if(K == (currentValue%10))
							cnt++;
						currentValue /=10;
					}
				}
				return cnt;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			long long int dp[2][2][20][20];

			long long int solve(string &x, bool is_started, bool is_smaller, long long int sum, int ind, int k){
				if(ind == x.size())return sum;
				if(dp[is_started][is_smaller][sum][ind]!=-1)return dp[is_started][is_smaller][sum][ind];

				int range = is_smaller?9:(x[ind]-'0');
				long long int ans = 0LL;

				for(int i=0;i<=range;i++){
					bool newIs_smaller = is_smaller?true: (i!=range);
					bool newIs_started = is_started?true: (i!=0);
					if(newIs_started)ans +=solve(x,newIs_started,newIs_smaller,sum+(i==k),ind+1,k);
					else ans +=solve(x,newIs_started,newIs_smaller,sum,ind+1,k);
				}

				return dp[is_started][is_smaller][sum][ind] = ans;
			}

			long long int helper(long long int n, int k) {
				memset(dp,-1,sizeof(dp));
				string num = to_string(n);
				return solve(num,0,0,0,0,k);
			}

			long long int digitCount(int K, long long int A, long long int B) {
				return helper(B,K)-helper(A-1,K);
			}
	
	159) Alternate Positive and Negative:
		Problem Statement
			You are given an array 'arr' that contains an equal number of positive and negative elements. Rearrange the
			given array such that positive and negative numbers are arranged alternatively. Also, the respective relative
			order of positive and negative should be maintained.
			For example:
				For the given arr[ ] = { -1, 3, 5, 0, -2, -5 }
				arr[ ] = {3, -1, 5, -2, 0, -5 } is valid rearrangement.
				arr[ ] - {3, -1, 0, -2, 5, -5 } is invalid rearrangement; order of 0 and 5 is changed.
				arr[ ] - {3, -1, 5, 0, -2, -5 } is invalid rearrangement; positive and negative elements are not alternative.
			Note:
				Make changes in the same array and no returning or printing is needed.
				Consider zero(0) as a positive element for this question.
				
			It is guaranteed that an answer always exists.
			Constraints:
				1 <= T <= 5
				1 <= N <= 5 * 10 ^ 3
				-10 ^ 9 <= arr[i] <= 10 ^ 9
				Time Limit: 1 sec.
			
			Sample Input 1:
				2
				6
				1 2 3 -1 -2 -3
				8
				1 -10 5 -1 2 -3 0 -2
				Sample Output 1:
				1 -1 2 -2 3 -3 
				1 -10 5 -1 2 -3 0 -2 
				Explanation Of Sample Input 1:
				In the first test case, the output is an array of alternative positive and negative numbers, 
				and also order is maintained (relative order of positive numbers are 1 -> 2 -> 3 and for negative numbers are -1 -> 2 -> -3 )

				In the first test case, it is already in valid arrangement.
				Sample Input 2:
				1
				4
				-1 0 0 -1
				Sample Output 2:
				0 -1 0 -1 
				Explanation Of Sample Output 2:
				In the first test case, the output is an array of alternative positive and negative numbers and also order is maintained.

		#include <bits/stdc++.h> 
		void posAndNeg(vector<int> &arr) {
			vector<int> negativeStorer;
			vector<int> postiveStorer;
			int n = arr.size();
			for(int i=0; i<n; i++){
				if(arr[i] < 0 )
					negativeStorer.push_back(arr[i]);
				else
					postiveStorer.push_back(arr[i]);
			}

			int cntPOS=0, cntNEG=0;
			for(int i=0; i<n; i++){
				if(i&1)
					arr[i] = negativeStorer[cntNEG++];
				else
					arr[i] = postiveStorer[cntPOS++];
			}
		}
	
	160) Minimum distance between two numbers:
		You are given an array a, of n elements. 
			Find the minimum index based distance between two distinct elements of the array, x and y. 
			Return -1, if either x or y does not exist in the array.

			Example 1:
				Input:
				N = 4
				A[] = {1,2,3,2}
				x = 1, y = 2
				Output: 1
				Explanation: x = 1 and y = 2. There are
				two distances between x and y, which are
				1 and 3 out of which the least is 1.

			Example 2:
				Input:
				N = 7
				A[] = {86,39,90,67,84,66,62}
				x = 42, y = 12
				Output: -1
				Explanation: x = 42 and y = 12. We return
				-1 as x and y don't exist in the array.

			Your Task:
				Complete the function minDist() which takes the array a, and 3 integers n, x and y 
				as input parameters and returns the minimum distance between x and y in the array. 
				Return -1, if either x or y does not exist in the array.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= n <= 105
				0 <= a[i], x, y <= 105
				x != y

		class Solution{
			public:
			int minDist(int a[], int n, int x, int y) {
				vector<int> ans(a, a+n);
				
				//checking elements are present, if any one of them is not present then directly return -1, CLOSING PROGRAM
				if(find(ans.begin(), ans.end(), x) == ans.end() || find(ans.begin(), ans.end(), y) == ans.end())
					return -1;
				
				vector<int> indexX;
				vector<int> indexY;
				
				for(int i=0; i<n; i++){
					if(a[i] == x)
						indexX.push_back(i);
					
					if(a[i] == y)
						indexY.push_back(i);
				}
				
				int minSpace=INT_MAX;
				
				for(int i=0; i<indexX.size(); i++){
					for(int j=0; j<indexY.size(); j++){
						int value = abs(indexX[i] - indexY[j]);
						if(minSpace > value){
							minSpace = value;
						}
					}
				}
				return minSpace;
			}
		};

	161) Author And Books:
		Problem Statement
			You are given a certain format of books and their authors.
			For example -
				NameOfAuthor1 Book1 Book2
				NameoffAuthor2 Book1
				Your task is to print the given information in the following manner:
				1. NameOfAuthor1
					A. Book1
					B. Book2
				2. NameOfAuthor2
					A. Book1
				You are given a 2D array of strings 'S' where each vector is the information about the i-th author, 
				the first index of this vector is the 'NameOfAuthor" and the other indexes 
				are the 'Books' written by the author. You are supposed to print the Authors and 
				their books in the above mentioned format.
			Sample Input 1 :
				2
				2
				4 ChetanBhagat TwoStates Revolution HalfGirlfriend OneIndianGirl
				2 JKRowling HarryPotter FantasticBeasts
				1
				2 JeffreyArcher OldLove FalseImpression
				Sample Output 1 :
				1. ChetanBhagat
				A. TwoStates
				B. Revolution
				C. HalfGirlfriend
				D. OneIndianGirl 
				2. JKRowling
				A. HarryPotter
				B. FantasticBeasts
				1. JeffreyArcher
				A. OldLove 
				B. FalseImpression
				Explanation For Sample Input 1 :
				For, the first test case, the expected array to be returned is,
				[“1. ChetanBhagat”, “B. Revolution”, “C. HalfGirlfriend”, “D. OneIndianGirl”,  “ 2. JKRowling
				“, “A. HarryPotter”, “B. FantasticBeasts”]
				For, the second test case the expected array to be returned is,
				[“1. JeffreyArcher”, “A. OldLove”, “B. FalseImpression”].
				Sample Input 2 :
				2
				1
				2 RoaldDahl LambToTheSlaughter TheWitches
				1
				1 JhumpaLahiri ARealDurwan
				Sample Output 2 :
				1. RoaldDahl
				A. LambToTheSlaughter
				B. TheWitches
				1. JhumpaLahiri
				A. ARealDurwan

		#include <bits/stdc++.h> 
		vector<string> arrangeAuthors(vector<vector<string> > &s) {
			vector<string> ans;
			for(int i=0; i<s.size(); i++){
				string temp = to_string(i+1)+ ". "+s[i][0];
				ans.push_back(temp);
				char ch = 'A';
				for(int j=1; j<s[i].size(); j++){
					string temp2 = string(1,ch) +". "+s[i][j];
					ans.push_back(temp2);
					ch++;
				}
			}
			return ans;
		}

	162)	Secret Omen Patten:
		Problem  Statement:
			Your task is to determine whether there exists a "secret pattern" within the
			array, and if so, return '1'; otherwise, return '0'.
			A "secret pattern" is defined as a set of three consecutive elements in the array,
			the sum of which is divisible by '10'.
			Sample Input 1 :
				2
				5
				1 2 3 4 1
				4
				30 10 20 10
				Sample Output 1 :
				0
				1
				Explanation of sample input 1 :
				First test case:-
				There are three sets of three consecutive elements in the given array.
				The sums of all three sets are less than '10'.
				Thus, the answer is '0'.

				Second test case:-
				Every element is divisible by '10'.
				Therefore, the sum of any three consecutive elements will be divisible by '10'.
				Thus, the answer is '1'.
				Sample Input 2 :
				2
				3
				1082 1 1037
				4
				34 225 17 9
				Sample Output 2 :
				1
				0
			Constraints :
				1 <= 'T' <= 10
				3 <= 'N' <= 10^5
				1 <= 'A[i]' <= 10^8
				Time Limit: 1 sec

			Example :
				Let 'N' = 4, 'A' = [ 10, 11, 21, 8 ].
				There are two sets of three consecutive elements in the given
				array.
				The first, second, and third elements make the first set, with a
				sum of '10 + 11 + 21 = 42', which is not divisible by '10'.
				The second, third, and fourth elements make the second set, with a
				sum of '11 + 21 + 8 = 40', which is divisible by '10'. Therefore,
				the array does contain the 'secret code'.
				Thus, the answer is '1'.

		int secretCode(int n, vector<int> &a) {
			int sum =0;
			for(int i=0; i<a.size()-2; i++){
				sum = a[i]+a[i+1]+a[i+2];
				if(sum %10==0)
					return 1;
				sum=0;
			}
			return 0;
		}
	
	163) Supreme Bat
		Problem Statement
			You have an array 'A' of length 'N' representing 'N' bats, with the weight of the
			'i-th' bat being 'A[i]'.
			A player from the Australian cricket team is searching for a 'Supreme' bat. A bat
			is called 'Supreme' if its weight is greater than or equal to 'X' and less than or
			equal to 'Y'.
			Since lighter bats are preferred by players, return the weight of the lightest
			'Supreme bat' from 'A'. If there is no such bat, return '-1'.
			For Example:-
				Let 'N' - 5, 'X' - 2, 'Y' - 7, and 'A' - [1, 5, 3, 4, 8].
				The lightest bat with a weight greater than or equal to 'X' and
				less than or equal to 'Y' is of weight '3'.
				Hence, the final output is '3'.
			Constraints:-
				1 <= 'T' <= 10
				1 <= 'N' <= 10^5
				1 ‹= 'X' ‹= 'Y' <= 10^5
				1 < 'A[i]' <= 10^5
				The Sum of 'N' overall test cases does not exceed 10^5.
				Time Limit: 1 sec
			Sample Input 1:-
				2
				4 5 8
				3 4 1 4
				2 5 8
				6 3
				Sample Output 1:-
				-1
				6
				Explanation of sample input 1:-
					First test case:-
					Here, a bat with a weight greater than or equal to 'X' and less
					than or equal to 'Y' is not present. Thus, no such bat exists.
					Hence, the answer is '-1'.
				Second test case:-
				The lightest bat with a weight greater than or equal to 'X' and
				less than or equal to 'Y' is of weight '6'
				Hence, the answer is '6'.
				Sample Input 2:-
				2
				3 1 1
				3 2 1
				6 6 8
				3 6 1 4 3 6
				Sample Output 2:-
				1
				6

		int xAndY(int x, int y, vector<int> &a) {
			// Write your code here.
			int minValue=INT_MAX;
			for(int i=0; i<a.size(); i++){
				if(a[i]>=x && a[i]<=y){
					minValue = min(minValue,a[i]);
				}
			}
			if(minValue != INT_MAX)
				return minValue;
			return -1;
		}

		//or not optimized
		int xAndY(int x, int y, vector<int> &a) {
			sort(a.begin(), a.end());
			for(int i=0; i<a.size(); i++) {
				if(a[i]>=x && a[i]<=y) {
					return a[i];
				}
			}
			return -1;
		}
	
	164) Performance Impact Sum:
		Problem statement:
			1. If the performance value 'X[i]' is divisible by '3', 'Y[i]' is set to 'X[i]'.
			2. If 'X[]' is not divisible by '3', 'Y[i]' is the square of 'X[I]'.
			Your task is to calculate the sum of the elements in the 'Y' array, which
			represents the overall impact or contribution of the players in the match based
			on these rules.

			Example:
				'N' = 3 'X'= [3, 4, 1]
				Since X[0] is divisible by "3', Y[0]=3.
				Here X[1] and X[2] are not divisible by 3,
				So Y[1]=4*4=16 and Y[2]=1*1=1.
				Y[0]+Y[1]+Y[2]=20.

			Sample Input 1 :
				2
				3 
				6 3 1
				3 
				1 2 1
				Sample Output 1 :
				10
				6   
				Explanation Of Sample Input 1 :
				For test case 1:
				As X[0] and X[1] are divisible by ‘3’ and X[2] is not divisible by ‘3’, Y=[6,3,1]. Hence sum is 10.

				For test case 2:
				All array ‘X’ elements are not divisible by ‘3’, Y=[1,4,1]. Hence the answer is 6.
				Sample Input 2 :
				2
				3
				1 1 1
				4  
				1 2 3 4 
				Sample Output 2 :
				3
				30
			Constraints:
			1 <= T <= 10
			1 <= N <= 10^4
			1 <= X[i] <= 10^2
			Time Limit: 1 sec

		int divisible3(int n, vector<int> x) {
			int sum =0;
			for(int i=0; i<x.size(); i++){
				if(x[i] % 3 ==0)
				sum += x[i];
				else
				sum += (x[i] * x[i]);
			}
			return sum;
		}
	
	165) Binary Search:
		Sample Input 1:
			7
			1 3 7 9 11 12 45
			3
			Sample Output 1:
			1
			Explanation of sample output 1:
			nums = [1, 3, 7, 9, 11, 12, 45],
			The index of element '3' is 1.
			Hence, the answer is '1'.


			Sample Input 2:
			7
			1 2 3 4 5 6 7
			9
			Sample Output 2:
			-1
			Explanation of sample output 2:
			nums = [1, 2, 3, 4, 5, 6, 7],
			Element '9' doesn't exist.
			Hence, the answer is '-1'.

		int search(vector<int> &nums, int target) {
			int start = 0;
			int end = nums.size()-1;
			int mid = (start+end)/2;

			while(start<=end){
				mid= (start+end)/2;
				if(nums[mid] == target)
					return mid;
				else if(nums[mid] > target)
					end = mid - 1;
				else
					start = mid + 1;
			}
			return -1;
			// for(int i=0; i< nums.size(); i++){
			//     if(target == nums[i])
			//         return i;
			// }
			// return -1;
		}
	
	166) Binary to Decimal:
		Sample Input 1:
				2
				7
				1010101
				4
				1011
				Sample Output 1:
				85
				11
				Explanation of Sample Input 1:
				Test case 1:

				The Decimal equivalent of the Binary number “1010101” is 85.

				Test case 2:
				The Decimal equivalent of the Binary number “1011” is 11.
				Sample Input 2:
				2
				4
				1111       
				1
				0
				Sample Output 2:
				15
				0
				Explanation of Sample Input 2:
				Test case 1:

				The Decimal equivalent of the Binary number “1111” is 15.

				Test case 2:

				The Decimal equivalent of the Binary number “0” is 0.

		#include <bits/stdc++.h>
		int convert(int N,string &str) {
			return stoi(str, 0,2);
		}
	
	167) Linear Probing:
		Problem Statement:
			The hash function you need to consider is H(X) = X mod N i.e. index = X mod N.
			Return an array 'HASH_TABLE' of size N in which:
			HASH_TABLE[i] = KEYS[j] where, i = KEYS[j] mod N
			In short, an element at index 'ї is the element from the given array KEYS which is mapped to that index.
			You can refer to the example given below:
			Sample Input 1:
				2
				5
				5 3 2 6 4
				4
				1 5 3 7
				Sample Output 1:
				5 6 2 3 4
				7 1 5 3
				Explanation
				For test case 1:
				H(X) = X mod 5
				All the numbers have unique hash values so there is no collision. Just map each index to its hash index.

				For test case 2:
				H(1) = 1L index 1 is unoccupied so we will map index 1 with 1.
				H(5) = 1: but, index 1 is occupied, so, we will use index 2 which is unoccupied, and will map index 2 with 5.
				H(3) = 3: index 3 is unoccupied so we will map index 3 with 3.
				H(7) = 3, but index 3 is occupied so we will use index 0 which is unoccupied and will map index 0 with 7.
				Sample Input 2:
				2
				6
				4 7 8 1 2 5
				3
				6 7 10
				Sample Output 2:
				5 7 8 1 4 2
				6 7 10

			Constraints:
				1 <= T <= 10
				1 <= N <= 500
				0 <= KEYS[ i ] <= 10^9
				Time limit: 1 sec

			#include <bits/stdc++.h> 
			vector<int> linearProbing(vector<int> keys) {
				int n = keys.size();
				vector<int> hashedAns(n, -1);

				for(int i=0; i<keys.size(); i++){
					int index = keys[i] % n;

					back:
					if(hashedAns[index] == -1)
						hashedAns[index] = keys[i];
					else{
						index++;
						index = index % n;
						goto back;
					}
				}
				return hashedAns;    
			}

	168) Find Transition Point:
		Problem Statement:
			Given a sorted array containing only 0s and 1s, find the transition point, 
			i.e., the first index where 1 was observed, and before that, only 0 was observed.

			Example 1:
				Input:
				N = 5
				arr[] = {0,0,0,1,1}
				Output: 3
				Explanation: index 3 is the transition 
				point where 1 begins.

			Example 2:
				Input:
				N = 4
				arr[] = {0,0,0,0}
				Output: -1
				Explanation: Since, there is no "1",
				the answer is -1.

			Your Task:
				You don't need to read input or print anything. 
				The task is to complete the function transitionPoint() that takes array arr and N as 
				input parameters and returns the 0-based index of the position where 0 ends and 1 begins. 
				If array does not have any 1, return -1. If array does not have any 0, return 0.

			Expected Time Complexity: O(Log(N))
			Expected Auxiliary Space: O(1)

			Constraints:
				1 ≤ N ≤ 105
				0 ≤ arr[i] ≤ 1

		int transitionPoint(int arr[], int n) {
			for(int i=0; i<n; i++){
				if(arr[i] == 1)
					return i;
			}
			return -1;
			// int i;
			// for (i = 0; i < n && arr[i] == 0; i++) {
			//     // Iterate until a 1 is found, or the end of the array is reached.
			// }
			// return (i < n) ? i : -1;

			/*or
				 int i;
				for (i = 0; i < n && arr[i] == 0; i++);
				return (i < n) ? i : -1;
			*/
		}

	169) Ninjas and Indices:
		Problem Statement
			Ninja is given three arrays 'A', 'B' and 'C' of length 'N' each. A pair of indices (i, j) where 0<= i, j < 'N'is
			called 'good' if 'A[i]' is equal to 'B[C[j]]'.
			Return an integer 'X' denoting the number of good indexes.
			Assume 0-based indexing.
			For Example:
				Let 'N' = 3, 'A' = [0, 1, 1], 'B' = [2, 0, 1] and 'C' = [1, 2, 1].
				(0, 0) is a good pair as 'A[0]' = 'B[C[°]]'.
				(0, 2) is a good pair as 'A[0]' = 'B[C[2]]' -
				(1, 1) is a good pair as 'A[1]' = 'B[C[1]]'.|
				(2, 1) is a good pair as 'A[2]' = 'B[C[1]]'-
				Hence the answer is 4.
			Constraints:-
				1 <= 'T' ‹= 10
				1 ‹= 'N' ‹= 10^5
				0 < 'A[i]', 'B[i]', 'C[i]' < 'N'
				The sum of 'N' over all test cases does not exceed 10^5.
				Time Limit: 1 sec.
		Sample Input 1:-
			2
			3
			0 1 2
			1 0 1
			0 1 2
			1 
			0
			0
			0
			Sample Output 1:-
			3
			1
			Explanation Of Sample Input 1:-
			First test case:-
			(0, 1) is a good pair as 'A[0]' = 'B[C[1]]'.
			(1, 2) is a good pair as 'A[1]' = 'B[C[2]]'.
			(1, 0) is a good pair as 'A[1]' = 'B[C[0]]'.
			Hence the answer is 3.

			Second test case:-
			'N' is 1. So, only one good pair exists.
			Sample Input 2:-
			2
			3
			0 1 0
			2 2 2
			0 1 0
			2
			0 1
			1 1
			0 0
			Sample Output 2:-
			0
			2
		
		long long findCount(int n, vector<int> &a, vector<int> &b, vector<int> &c){
			long long cnt=0;
			for(int i=0; i<n; i++){
				for(int j=0; j<n; j++){
					if(a[i] == b[c[j]])
						cnt++;
				}
			}
			return cnt;
		}

	170) String Clear:
		Problem Statement
			You are given a string 'S' consisting only of characters 'c' and 'n'
			In one move, you can choose any two consecutive characters that are different from each other and remove
			them from the string.
			If it is possible to make the whole string empty by applying this move any number of times, return 1.
			Otherwise, return 0.
			Hint:
				Focus on how the counts of 'c' and 'n' change after each operation.
				We are asked to check if both of these counts reach zero at the end.
			Example:
				'S' = "encenn"
				We can apply the operations in the following manner to make the string empty:
				"cnecnn" → "encn" → "cn" → ""
				So, the answer will be 1.
			Constraints :
				1 <= T ‹= 10
				1 <= '|5|' ‹= 10^5,
				Where S| denotes the length of the string 'S'.
				Time Limit: 1 sec

			Sample Input 1:
				2
				cn
				c
				Sample Output 1:
				1
				0
				Explanation Of Sample Input 1:
				For test case 1:
				You can erase the whole string in a single move as the two characters are different.

				For test case 2:
				You can't make a move because there is only a single character.
				Sample Input 2:
				2
				cncncnccnn
				cncncnccnc
				Sample Output 2:
				1
				0

		int stringClear(string &s){
			int cntC=0, cntN=0;
			for(int i=0; i<s.length(); i++){
				if(s[i] == 'c')
					cntC++;
				else
					cntN++;
			}
			return (cntN==cntC)?1:0;
		}
	
	171) Top K Frequent Elements in Array - |:
		Problem statement:
			Given a non-empty array nums[] of integers of length N, 
			find the top k elements which have the highest frequency in the array. 
			If two numbers have same frequencies, then 
			the larger number should be given more preference.

			Example 1:
				Input:
				N = 6
				nums = {1,1,1,2,2,3}
				k = 2
				Output: {1, 2}

			Example 2:
				Input:
				N = 8
				nums = {1,1,2,2,3,3,3,4}
				k = 2
				Output: {3, 2}
				Explanation: Elements 1 and 2 have the
				same frequency ie. 2. Therefore, in this
				case, the answer includes the element 2
				as 2 > 1.

			User Task:
				You don't have to read or print anything. 
				You will have to complete the function topK() that takes an array nums[] 
				and integer k as input and returns a list of top k most frequent elements. 
				If any two elements have same frequencies, then give more preference to the larger elemet.

			Expected Time Complexity : O(NlogN)
			Expected Auxilliary Space : O(N)

			Constraints:
				1 <= N <= 105
				1<= nums[i] <=105
				1 <= k <= N

		class Solution {
			public:
			static bool comp(pair<int, int> a, pair<int, int> b){			//defining another function inside class then use static keyword
				if(a.second == b.second)								//or else define it outside the class.
					return a.first > b.first;
				return a.second > b.second; 
			}
			
			vector<int> topK(vector<int>& nums, int k) {
				unordered_map<int, int> FreqStorer;
				for(int i=0; i<nums.size(); i++){
					FreqStorer[nums[i]]++;
				}
				
				vector<pair<int,int>> ans;
				for(auto i: FreqStorer){
					pair<int, int> temp = {i.first, i.second};
					ans.push_back(temp);
				}
				
				vector<int> topKelements;
				sort(ans.begin(), ans.end(), comp);			//refer below code also, comp function written inside sort function only.
				
				int cnt=0;
				for(int i=0; i<ans.size() && cnt<k; i++){
					topKelements.push_back(ans[i].first);
					cnt++;
				}
				
				return topKelements;
			}
		};

		//or
			vector<int> topK(vector<int>& nums, int k) {
				unordered_map<int, int> FreqStorer;
				for(int i=0; i<nums.size(); i++){
					FreqStorer[nums[i]]++;
				}
				
				vector<pair<int,int>> ans;
				for(auto i: FreqStorer){
					pair<int, int> temp = {i.first, i.second};
					ans.push_back(temp);
				}
				
				vector<int> topKelements;
				sort(ans.begin(), ans.end(), [](pair<int, int> a, pair<int, int> b){
					if(a.second == b.second)
						return a.first > b.first;
					return a.second > b.second;
				});
				
				int cnt=0;
				for(int i=0; i<ans.size() && cnt<k; i++){
					topKelements.push_back(ans[i].first);
					cnt++;
				}
				
				return topKelements;
			}

	172) Find the Winner of an Array Game:
		Problem Statement:
			Given an integer array arr of distinct integers and an integer k.
			A game will be played between the first two elements of the array 
			(i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], 
			the larger integer wins and remains at position 0, and the smaller integer moves to the 
			end of the array. The game ends when an integer wins k consecutive rounds.

			Return the integer which will win the game.
			It is guaranteed that there will be a winner of the game.

			Example 1:
				Input: arr = [2,1,3,5,4,6,7], k = 2
				Output: 5
				Explanation: Let's see the rounds of the game:
				Round |       arr       | winner | win_count
				1  	 | [2,1,3,5,4,6,7] | 2      | 1
				2  	 | [2,3,5,4,6,7,1] | 3      | 1
				3   	 | [3,5,4,6,7,1,2] | 5      | 1
				4   	 | [5,4,6,7,1,2,3] | 5      | 2
				So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.

			Example 2:
				Input: arr = [3,2,1], k = 10
				Output: 3
				Explanation: 3 will win the first 10 rounds consecutively.
			
			Constraints:
				2 <= arr.length <= 10^5
				1 <= arr[i] <= 10^6
				arr contains distinct integers.
				1 <= k <= 10^9

		//Not Optimized:
			class Solution {
				public:
				int getWinner(vector<int>& arr, int k) {
					int winCNT=0;

					if(k>= arr.size()-1)					//if k is greater or equal to array size, then max element always wins.
						return *max_element(arr.begin(), arr.end());

					while(winCNT < k){
						if(arr[0] > arr[1]){
							int value = arr[1];
							arr.erase(arr.begin()+1);
							arr.push_back(value);
							winCNT++;
						}else{
							winCNT=1;
							int value = arr[0];
							arr.erase(arr.begin());
							arr.push_back(value);
						}
					}
					return arr[0];
				}
			};
	
		//Optimized:
			class Solution {
				public:
				int getWinner(vector<int>& arr, int k) {
					int winCNT=0;

					if(k>= arr.size()-1)
						return *max_element(arr.begin(), arr.end());

					int winner = arr[0];
					
					for(int i=1; i<arr.size(); i++){
						if(winner > arr[i]){
							winCNT++;
						}else{
							winner = arr[i];
							winCNT=1;
						}
						
						if(winCNT == k)
								break;
					}
					return winner;
				}
			};
	
	173) Reverse First K elements of Queue:
		Problem Statement
			You are given a QUEUE containing 'N' integers and an integer 'K'. You need to reverse the order of the first 'K'
			elements of the queue, leaving the other elements in the same relative order.
			You can only use the standard operations of the QUEUE STL:
				1. enqueue(x): Adds an item x to rear of the queue
				2. dequeue() : Removes an item from front of the queue
				3. size() : Returns number of elements in the queue…
				4. front() : Finds the front element.
				For Example:
					Let the given queue be { 1, 2, 3, 4, 5 } and K be 3.
					You need to reverse the first K integers of Queue which are 1, 2, and з.
					Thus, the final response will be { 3, 2, 1, 4, 5 }.
				Constraints:
					1 ‹= T ‹= 10
					1 ‹= N <= 10 ^ 5
					0 <= K <=N
					-10 ^ 9 <= queue elements <= 10 ^ 9
					Time limit: 1 sec
				Sample Input 1:
					2
					5 3
					1 2 3 4 5
					4 2
					6 2 4 1
					Sample Output 1:
					3 2 1 4 5
					2 6 4 1
					Explanation:
					For test case 1: Refer to the example explained above.

					For test case 2:
					The queue after reversing the first 2 elements i.e., 6 and 2 will be { 2, 6, 4, 1 }.
					Sample Input 2:
					2
					5 2
					5 3 2 6 4
					4 4
					1 2 3 4
					Sample Output 2:
					3 5 2 6 4
					4 3 2 1

		#include <bits/stdc++.h> 
		queue<int> reverseElements(queue<int> q, int k) {
			int size = q.size();
			queue<int> ans;
			vector<int> holder;
			for(int i=0; i<k; i++){
				int value = q.front();
				q.pop();
				holder.push_back(value);
			}
			reverse(holder.begin(), holder.end());

			int i;
			for(i=0; i<k; i++){
				ans.push(holder[i]);
			}

			for(i;i<size; i++){
				int value = q.front();
				q.pop();
				ans.push(value);
			}
			return ans;
		}
	
	174) Maximum XOR:
		Problem Statement
			You are given two arrays of non-negative integers say 'arr1' and 'arr2'. Your task is to find the maximum
			value of ( 'A' xor 'B') where 'A' and 'B' are any elements from 'arr1' and 'arr2' respectively and 'xor' represents
			the bitwise xor operation.
			Constraints:
				1 <= T <= 5
				1 <= N, M <= 1000
				0 <= arri[i], arr2[i] <= 10 ^ 9
				Where "T' denotes the number of test cases, 'N', 'M' denotes the number of elements in the
				first array and second array, 'arr[i]', and 'arr2[i]' denotes the 'i-th' element of the
				first array and second array
				Time limit: 1 sec

			Sample Input 1:
				1
				7 7
				6 6 0 6 8 5 6
				1 7 1 7 8 0 2
				Sample Output 1:
				15
				Explanation of sample input 1:
				First testcase:
				Possible pairs are (6, 7), (6, 8), (6, 2), (8, 7), (8, 8), (6, 2). And 8 xor 7 will give the maximum result i.e. 15
				Sample Input 2:
				1
				3 3
				25 10 2
				8 5 3
				Sample Output 2:
				28
				Explanation of sample input 2:
				First test case:
				28 is the maximum possible xor given by pair = (25, 5). It is the maximum possible xor among all possible pairs.

		//Not Optimized:				
			int maxXOR(int n, int m, vector<int> &arr1, vector<int> &arr2) {
				int mxer= INT_MIN;
				for(int i=0; i<arr1.size(); i++)
					for(int j=0; j<arr2.size(); j++)
						if(mxer < (arr1[i]^arr2[j]))
							mxer = arr1[i]^arr2[j];
				
				return mxer;  
			}
		
		//Optimized:
			#include <bits/stdc++.h>
			class TrieNode {
				public:
				TrieNode* children[2];

				TrieNode() {
					children[0] = nullptr;
					children[1] = nullptr;
				}
			};

			void insert(TrieNode* root, int num) {
				TrieNode* curr = root;

				for (int i = 31; i >= 0; i--) {
					int bit = (num >> i) & 1;

					if (!curr->children[bit]) {
						curr->children[bit] = new TrieNode();
					}

					curr = curr->children[bit];
				}
			}

			int findMaxXOR(TrieNode* root, vector<int>& arr) {
				int maxXOR = INT_MIN;

				for (int num : arr) {
					int currentXOR = 0;
					TrieNode* curr = root;

					for (int i = 31; i >= 0; i--) {
						int bit = (num >> i) & 1;
						int oppositeBit = 1 - bit;

						if (curr->children[oppositeBit]) {
							currentXOR |= (1 << i);
							curr = curr->children[oppositeBit];
						} else {
							curr = curr->children[bit];
						}
					}

					maxXOR = max(maxXOR, currentXOR);
				}

				return maxXOR;
			}

			int maxXOR(int n, int m, vector<int> &arr1, vector<int> &arr2) {
				TrieNode* root = new TrieNode();

				for (int num : arr1) {
					insert(root, num);
				}

				return findMaxXOR(root, arr2);
			}
	
	175) Sum of upper and lower triangles:
		Problem Statement:
			Given a square matrix of size N*N, print the sum of upper and lower triangular elements. 
			Upper Triangle consists of elements on the diagonal and above it. 
			The lower triangle consists of elements on the diagonal and below it. 

			Example 1:
				Input:
				N = 3 
				mat[][] = {{6, 5, 4},
						{1, 2, 5}
						{7, 9, 7}}
				Output: 
				29 32
				Explanation:
				The given matrix is
				6 5 4
				1 2 5
				7 9 7
				The elements of upper triangle are
				6 5 4
				  2 5
				    7
				Sum of these elements is 6+5+4+2+5+7=29.
				The elements of lower triangle are
				6
				1 2
				7 9 7
				Sum of these elements is 6+1+2+7+9+7= 32.

			Example 2:
				Input:
				N = 2
				mat[][] = {{1, 2},
						{3, 4}}
				Output: 
				7 8
				Explanation:
				Upper triangular matrix:
				1 2
				  4
				Sum of these elements are 7.
				Lower triangular matrix:
				1
				3 4
				Sum of these elements are 8.

			Your Task:
				You don't need to read input or print anything. 
				Complete the function sumTriangles() that takes matrix and 
				its size N as input parameters and returns the list of integers 
				containing the sum of upper and lower triangle.

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(1)

			Constraints: 
				1 <= N <= 10^3
				1 <= matrix[i][j] <= 10^6
		
		class Solution {  
			public:
			//Function to return sum of upper and lower triangles of a matrix.
			vector<int> sumTriangles(const vector<vector<int> >& matrix, int n) {
				vector<int> ans;
				int Usum,Lsum;
				Usum=Lsum=0;
				
				for(int i=0; i<n; i++)
					for(int j=0; j<n; j++){
						if(i <= j)
							Usum += matrix[i][j];
						
						if(i >= j)
							Lsum += matrix[i][j];
					}
				ans.push_back(Usum);
				ans.push_back(Lsum);
				return ans;
			}
		};
	
	176) Print Matrix in snake Pattern:
		Problem Statement:
			Given a matrix of size N x N. 
			Print the elements of the matrix in the snake like pattern depicted below.
			Example 1:
				Input:
				N = 3 
				matrix[][] = {{45, 48, 54},
						{21, 89, 87}
						{70, 78, 15}}
				Output: 
				45 48 54 87 89 21 70 78 15 
				Explanation:
				Matrix is as below:
				45 48 54
				21 89 87
				70 78 15
				Printing it in snake pattern will lead to 
				the output as 45 48 54 87 89 21 70 78 15.

			Example 2:
				Input:
				N = 2
				matrix[][] = {{1, 2},
						{3, 4}}
				Output: 
				1 2 4 3
				Explanation:
				Matrix is as below:
				1 2 
				3 4
				Printing it in snake pattern will 
				give output as 1 2 4 3.

			Your Task:
				You dont need to read input or print anything. 
				Complete the function snakePattern() that takes matrix as input 
				parameter and returns a list of integers in order of the values visited in the snake pattern. 

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(N * N) for the resultant list only.

			Constraints:
				1 <= N <= 10^3
				1 <= mat[i][j] <= 10^9

		class Solution {   
			public:
			//Function to return list of integers visited in snake pattern in matrix.
			vector<int> snakePattern(vector<vector<int> > matrix) {   
				vector<int> ans;
				for(int i=0; i<matrix.size(); i++){
					if(i&1)
						for(int j=matrix[0].size()-1; j>=0; j--)
							ans.push_back(matrix[i][j]);
					else
						for(int j=0; j<matrix[0].size(); j++)
							ans.push_back(matrix[i][j]);
				}
				return ans;
			}
		};
	
	177) Maximum XOR of Two Numbers in an Array:
		Problem Statement
			An array 'A' of 'N' integers is provided. Return the maximum possible number which can be created by taking
			bitwise XOR of any 2 integers of the array.
			Example:
				If the array is 2,5 and 6
				2 XOR 5 is 7
				2 XOR 6 is 4
				5 XOR 6 is 3
				Hence the answer is 7.

			Constraints:
				1 <= N <= 10^4
				1 <= A[i] <= 10^9 
				Time Limit: 1 sec

			Sample Input 1:
				3
				2 1 4
				Sample Output 1:
				6
				Explanation For Sample Input 1:
				Select the 1st and 3rd element leading to a xor value of 6.
				Sample Input 2:
				2
				3 2
				Sample Output 2:
				1

		int maximumXor(vector<int> A) {
			int mxer = 0;
			for(int i=0; i<A.size(); i++)
				for(int j=i+1; j<A.size(); j++)
					if(mxer < (A[i] ^ A[j]))
						mxer = A[i] ^ A[j];

			return mxer; 
		}
	
	178) Count Of Divisible Pairs:
		Problem Statement
			You are given two integers 'N' and 'M'. A pair (x, y) is a divisible pair if it satisfies the following conditions:
				a) 1 <=×<= 'N'
				b) 1 <= y <= 'M'
				c) x + y is divisible by 5.
			Your task is to return the count of all divisible pairs that can be formed from given 'N' and 'M'.
			Example :
				If N = 3 and M = 5, then { × = 1, y = 4 }, {× = 2, y = 3 }, {× = 3, y = 2 } are the
				pairs that satisfy the given conditions.
			Constraints :
				1 <= T ‹= 10
				1 <= N, M <= 10^9
				Time limit: 1 sec
			Sample Input 1 :
				2
				1 5
				2 3
				Sample Output 1 :
				1
				1
				Explanation Of Sample Output 1 :
				For test case 1 :
				Only (1,4) satisfy the given condition.

				For test case 2 :
				Only (2,3) satisfy the given conditions.
				Sample Input 2 :
				2
				1 3
				6 12
				Sample Output 2 :
				0
				14

		#include <bits/stdc++.h> 
		int countOfDivisiblePairs(int n, int m){
			int cnt=0;
			for(int i=1; i<=n; i++){
				for(int j=1; j<=m; j++){
					int value = i+j;
					if(value % 5 == 0)				//or	if((i+j) % 5 == 0)
						cnt++;
				}
			}
			return cnt;
		}
		
	179) Predict the Column:
		Problem Statement:
			Given a matrix(2D array) M of size N*N consisting of 0s and 1s only.
			The task is to find the column with maximum number of 0s. 
			If more than one column exists, print the one which comes first. 
			If the maximum number of 0s is 0 then return -1.

			Example:
				Input:
				N = 3
				M[][] = {{0, 0, 0},
						{1, 0, 1},
						{0, 1, 1}}
				Output:
				0
				Explanation:
				0th column (0-based indexing) is having 2 zeros which is maximum among all columns and comes first.
			Your Task:
				Your task is to complete the function columnWithMaxZero() which should return the column number 
				with the maximum number of zeros. 

			Expected Time Complexity: O(N * N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^3
				0 <= A[i][j] <= 1

		class Solution{
			public:
			/*Function to count zeros in each column
			* N : Number of rows and columns in array
			M is the matrix that is globally declared
			*/
			int columnWithMaxZeros(vector<vector<int>>arr,int N){
				
				// Your code here
				int col=0, cnt=0, maxCnt=0;
				int i,j;
				for(i=0; i<N; i++){
					for(j=0; j<N; j++){
						if(arr[j][i] == 0)
							cnt++;
					}
					
					if(maxCnt<cnt){
						col = i;
						maxCnt = cnt;
					}
					cnt=0;
				}
				
				if(maxCnt==0)
					return -1;
				return col;
			}
		};
		
	180) Find MSB In O(1):
		Problem Statement
			You are given a positive integer 'N'. 
			Your task is to find the greatest integer less than or equal to 'N' which is a power of 2.
			For Example:
				If N = 14, then the nearest integer that is less than or equal to 14 and is a power of two
				is 8(2^3). So, the answer is 8.
			Follow Up:
				Can you solve this in constant time and space complexity?
			Constraints:
				1 <= T ‹= 2 * 10^3
				1 <- N <= 10^9
				Time Limit: 1 second
			
			Sample Input 1:
				2
				4
				22
				Sample Output 1:
				4
				16
				Explanation For Sample 1:
				For the first test case, 4 itself is a power of two.
				For the second test case, the nearest integer that is less than or equal to 22 and also is a power of two is 16.
				Sample Input 2:
				2
				1
				63
				Sample Output 2:
				1
				32
				Explanation For Sample 1:
				For the first test case, 1 itself is a power of two.
				For the second test case, the nearest integer that is less than or equal to 63 and also is a power of two is 32.

		#include <bits/stdc++.h> 
		int findMSB(int n){
			int sqr=1,cnt=0;
			int miner;
			while(sqr <= n){
				sqr = pow(2,cnt++);
				if(sqr <= n)
					miner = sqr;
			}
			return miner;
		}
	
	181) Minimum Deletions To Make Character Frequencies Unique: ❌Pending
		Problem Statement
			You are given a string 'STR' consisting of lowercase English alphabets. Your take
			is to find out the minimum number of character deletions required such that each
			character in the final string has a unique frequency.
			Detailed explanation ( Input/output format, Notes, Images )|
			Constraints :
				1 <= T <= 10
				2 ‹= |STR| ‹= 10^5
				where |STR| denotes the length of the initial string "STR'.
				Time limit: 1 second
		Sample Input 1 :
			2
			babccbc
			gttqtq
			Sample Output 1 :
			1
			0
			Explanation For Sample Input 1 :
			Test Case 1 :
			The frequency of ‘a’ is 1, of ‘b’ is 3 and of ‘c’ is 3. Therefore after deletion of one character of either ‘b’ or ‘c’ makes the frequencies 1,2 and 3.

			Test Case 2 :
			The frequency of 'g' is 1, 't' is 3 and 'q' is 2. Therefore there is no need for a delete operation.
			Sample Input 2 :
			2
			abbccc
			cbbd
			Sample Output 2 :
			0
			1
			Explanation For Sample Input 2 :
			For the first test case, each character already has a unique frequency(1 for ‘a’, 2 for ‘b’ and 3 for ‘c’), hence we don’t need to do any deletions.

			For the second test case frequency of ‘c’ and ‘d’ is equal hence we need to delete either of them. Therefore the answer is 1.

		#include <bits/stdc++.h>
		int minDeletions(string str) {
			int deletionCNT=0;
			unordered_map<char, int> FreqCnt;

			for(int i=0; i<str.length(); i++){
				FreqCnt[str[i]]++;
			}

			vector<int> holder;
			for(auto i: FreqCnt){
				holder.push_back(i.second);
			}

			for(int i=0; i<holder.size(); i++){
				for(int j=i+1; j<holder.size(); j++){
					if(holder[i] == holder[j]){
						holder[i]--;
						deletionCNT++;
						j=i+1;
					}
				}
			}
			return deletionCNT;
		}
	
	182) K'th Special Number in Range: ❌Pending
		Problem Statement
			Ninja wants to practice martial arts in order to master it but he has a pending school assignment and wants
			your help to solve it.
			You are given two integers 'L' and 'R' denoting the range of integers [L, R]. A special number is a number that
			has (101)₂  subarray in its binary representation. You have a simple task, you need to find the 'K'th' special
			number that lies in the given range, print -1 if it is not possible.
			For Example :
				If L = 5 and R = 7, and you need to find the 1'st special number lying in the range [5, 7]
				The answer for this is equal to 5, as 5 is the first special number lying in the given
				range, it is a special number because it has a subarray 101 in its binary representation.
			Constraints :
				1 ≤ T ≤ 10
				1 ≤ L ≤ R ≤ 50000
				1 ≤ K ≤ 50000
				Time limit: 1 sec
			Sample Input 1 :
				2
				5 7 1
				8 11 3
				Sample Output 1 :
				5
				-1
				Explanation For Sample Input 1 :
				For test case 1 :
				We will print 5 because:
				5 is the first special number lying in the given range, it is a special number because it has a subarray 101 in its binary representation.

				For test case 2 : 
				We will print -1 because:
				There are two special numbers lying in the range [8, 11], these are 10 = (1010)2 and 11 = (1011)2 as both of them have a subarray of 101 in their binary representation. As third special number doesn’t exist in this range, hence we will print -1.
				Sample Input 2 :
				2
				1 10 2
				1 5 1
				Sample Output 2 :
				10
				5

		//NOT Optimized
			#include <bits/stdc++.h>
			int kthSpecialNumber(int l, int r, int k) {
				vector<int> NumsContain101;

				for(int i=l; i<=r; i++){
					string s = bitset<32>(i).to_string();

					if(s.find("101") != string::npos)
						NumsContain101.push_back(i);
				}

				if(k > NumsContain101.size())
					return -1;
				return NumsContain101[k-1];

				//or
				// for (int i = l; i <= r; ++i) {
				//     std::string binary = std::bitset<32>(i).to_string();
				//     if (binary.find("101") != std::string::npos) {
				//         if (--k == 0) {
				//             return i;
				//         }
				//     }
				// }
				// return -1;
			}

		//Optimized:
			int kthSpecialNumberHelper(int i, int lst, int prefix, int ctr, int dp[32][4][2][2], int x) {
				if (i == -1) {
					if (ctr == 1) {
						return 1;
					}
					return 0;
				}

				if (dp[i][lst][prefix][ctr] != -1) {
					return dp[i][lst][prefix][ctr];
				}

				int ans = 0;
				if (prefix == 0) {
					ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2, 0, ctr, dp, x);
					if (lst == 2) 
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 0, 1, dp, x);
					else 
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 0, ctr, dp, x);
				}

				if (prefix == 1) {
					if ((1 << i) & x) {
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2, 0, ctr, dp, x);
						if (lst == 2) 
							ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 1, 1, dp, x);
						else 
							ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2 + 1, 1, ctr, dp, x);
					} else {
						ans += kthSpecialNumberHelper(i - 1, (lst % 2) * 2, 1, ctr, dp, x);
					}
				}

				dp[i][lst][prefix][ctr] = ans;
				return dp[i][lst][prefix][ctr];
			}

			int kthSpecialNumber(int l, int r, int k) {
				int dp[32][4][2][2];
				memset(dp, -1, sizeof(dp));
				int cnt = kthSpecialNumberHelper(31, 0, 1, 0, dp, l - 1);
				cnt += k;
				int ans = -1;
				int low = l, high = r;

				while (low <= high) {
					int mid = (low + high) / 2;
					memset(dp, -1, sizeof(dp));
					int temp = kthSpecialNumberHelper(31, 0, 1, 0, dp, mid);

					if (temp >= cnt) {
						ans = mid;
						high = mid - 1;
					} else {
						low = mid + 1;
					}
				}
				return ans;
			}

	183) Left Rotations of An Array:
		Problem Statement
			You are given an array consisting of 'N' elements and you need to perform 'Q' queries
			on the given array. Each query consists of an integer which tells the number of
			elements by which you need to left rotate the given array. For each query return the
			final array obtained after performing the left rotations.
			Note:
			Perform each query on the original array only i.e. every output
			should be according to the original order of elements.
			Example:
			Let the array be [1, 2, 3, 4, 5, 6] and the queries be {2, 4, 1}. For
			every query, we'll perform the required number of left rotations on
			the array
			For the first query, rotate the given array to the left by 2
			elements, so the resultant array is: [3, 4, 5, 6, 1, 2].
			For the second query, rotate the given array to the left by 4
			elements, so the resultant array is: [5, 6, 1, 2, 3, 4].
			For the third query, rotate the given array to the left by 1 element,
			so the resultant array is: [2, 3, 4, 5, 6, 1].
			Constraints:
				1 <= T <= 10
				1 <= N <= 1000
				1 <= Q <= 100
				0 ‹= Queries[i] ‹= 10^5
				-10^5 ‹= Array[i] ‹= 10^5]
				Where 'Queries[i]' denotes the extent to which the array in each
				query needs to be rotated and 'Array[i]' denotes the array element.
				Time limit: 1 sec
			
			Sample Input 1:
				2
				5 3
				7 8 6 1 2
				8 4 3
				2 2
				12 15
				1 2    
				Sample Output 1:
				1 2 7 8 6 
				2 7 8 6 1
				1 2 7 8 6 
				15 12
				12 15
				Explanation For Sample Output 1:
				In test case 1, we have, array: [7, 8, 6, 1, 2] and three queries: {8, 4, 3}.

				For the first query we rotate the given array to the left 8 times, so the resultant array is: [1, 2, 7, 8, 6].

				For the second query we rotate the given array to the left 4 times, so the resultant array is: [2, 7, 8, 6, 1].

				For the third query we rotate the given array to the left 3 times, so the resultant array is: [1, 2, 7, 8, 6].

				In test case 2, we have, array: [12, 15] and two queries: {1, 2}.

				For the first query we rotate the given array to the left 1 time, so the resultant array is: [15, 12].

				For the second query we rotate the given array to the left 2 times, so the resultant array is: [12, 15].
				Sample Input 2:
				2
				6 3
				10 20 30 40 50 60
				12 2 5
				1 2
				-15
				100 89
				Sample Output 2:
				10 20 30 40 50 60 
				30 40 50 60 10 20 
				60 10 20 30 40 50 
				-15
				-15
				Explanation For Sample Output 2:
				In test case 1, we have, array: [10, 20, 30, 40, 50, 60] and three queries: {12, 2, 5}.

				For the first query we rotate the given array to the left 12 times, so the resultant array is: [10, 20, 30, 40, 50, 60].

				For the second query we rotate the given array to the left 2 times, so the resultant array is: [30, 40, 50, 60, 10, 20].

				For the third query we rotate the given array to the left 5 times, so the resultant array is: [60, 10, 20, 30, 40, 50]

				In test case 2, we have, array: [-15] and two queries: {100, 89}.

				For the first query we rotate the given array to the left 100 times, so the resultant array is: [-15].

				For the second query we rotate the given array to the left 89 times, so the resultant array is: [-15].

		//Not Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> leftRotationsOfArray(vector<int> nums, vector<int> queries) {
				vector<vector<int>> ans;
				for(int i=0; i<queries.size(); i++){
					int num = queries[i];
					vector<int> temp = nums;
					for(int a=0; a<num; a++){
						int value = temp[0];
						temp.erase(temp.begin());
						temp.push_back(value);
					}
					ans.push_back(temp);        
				}
				return ans;   
			}

		//Optimized:
			#include <bits/stdc++.h> 
			vector<vector<int>> leftRotationsOfArray(vector<int> nums, vector<int> queries) {
				std::vector<std::vector<int>> ans;
				const int n = nums.size();

				for (const int& num : queries) {
					std::vector<int> temp(n);
					for (int i = 0; i < n; ++i) {
						temp[i] = nums[(i + num) % n];
					}
					ans.push_back(temp);
				}
				return ans;
			} 
	
	184) Convert Number To Words: ❌Pending
		Problem Statement
			You are given an Integer 'N' you have to convert the integer to words.
			For example you are given integer N = 2234 then you have to return the string "two
			thousand two hundred and thirty four".
			Constraints :
				1 <= T <= 100
				1 <= N <= 999999999
				Time Limit: 1 sec
			Sample Input 1 :
				3
				1234
				45821
				555093
				Sample Output 1 :
				one thousand two hundred and thirty four
				forty five thousand eight hundred and twenty one
				five lakh fifty five thousand and ninety three
				Explanation Of Sample Input 1 :
				For the first test case:
				The given integer is 1234 we can see that in words it is represented as “one thousand two hundred and thirty four”.

				For the second test case:
				The given integer is 45821; we can see that in words it is represented as “forty five thousand eight hundred and twenty-one”.

				For the third test case
				The given integer is 555093; we can see that in words it is represented as “five lakh fifty five thousand and ninety three”.
				Sample Input 2 :
				3
				99999
				1000
				30000 
				Sample Output 2 :
				ninety nine thousand nine hundred and ninety nine
				one thousand  
				thirty thousand  

		#include <bits/stdc++.h>
		string a[] = {"", "one ", "two ", "three ", "four ",
				"five ", "six ", "seven ", "eight ", "nine ",
				"ten ", "eleven ", "twelve ", "thirteen ", "fourteen ",
				"fifteen ", "sixteen ", "seventeen ", "eighteen ", "nineteen "};

		string b[] = {"", "", "twenty ", "thirty ", "forty ",
				"fifty ", "sixty ", "seventy ", "eighty ", "ninety "};

		string c[] = {"", "", "hundred ", "thousand ", "", "lakh ", "", "crore "};

		string handleAll(int n) {
			string z;

			while (n) {
				z += ('0' + ((int)n % 10));
				n /= 10;
			}

			reverse(z.begin(), z.end());

			int k = z.size() - 1;
			string t;
			int g = 0;

			for (int i = 0; i < z.size(); i++) {
				if (z[i] == '0') {
					k -= 1;
					continue;
				}

				if (k % 2 == 0 and k > 3) {
					if (z[i] == '1' and i + 1 < z.size()) {
						t += a[10 + (z[i + 1] - '0')];
						t += c[k - 1];
					} else {
						t += b[(z[i] - '0')];
						t += a[z[i + 1] - '0'];
						t += c[k - 1];
					}

					i++;
					k -= 2;
				} else if (k > 1) {
					t += (a[z[i] - '0']);
					t += c[k];
					k -= 1;
				} else {
					if (g == 0) {
						t += "and ";
						g = 1;
					}

					if (z[i] == '1' and i + 1 < z.size()) {
						t += a[10 + (z[i + 1] - '0')];
						k -= 1;
						i++;
					} else {
						if (i + 1 < z.size()) {
							t += b[(z[i] - '0')];
						} else {
							t += a[z[i] - '0'];
						}

						k -= 1;
					}
				}
			}
			return t;
		}
	
	185) Print the Kth Digit: ❌Pending

		Sample Input 1:
			1
			2 4 1
			Sample Output 1:
			6
			Explanation For Sample Input 1:
			2 ^ 4 = 16, and the 1st digit in 16 from the right is 6.
			Sample Input 2:
			1
			3 3 2       
			Sample Output 2:
			2
			Explanation For Sample Input 2:
			3^3 = 27, and the 2nd digit in 27 from the right is 2.

		#include <bits/stdc++.h> 
		int findKthFromRight(int n, int m, int k) {
			int power = pow(n,m);
			int num;
			for(int i=0; i<k; i++){
				num = power % 10;
				power /=10;
			}
			return num;
		}
	
	186) Matrix Multiplication: ❌Pending
		Sample Input 1:
			1
			2 1 1 2
			2
			0
			1 2
			Sample Output 1:
			2 4
			0 0
			Explanation for Sample Output 1:
			For sample test case 1: 
			1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] ie. 2 * 1 = 2
			2. MAT3[0][1] = MAT1[0][0] * MAT2[0][1] ie. 2 * 2 = 4
			3. MAT3[1][0] = MAT1[0][1] * MAT2[0][0] ie. 0 * 1 = 0 
			4. MAT3[1][1] = MAT1[1][1] * MAT2[0][1] ie. 0 * 2 = 0
			Sample Input 2:
			2
			1 1 1 2
			3
			1 0
			1 1 1 1
			-1
			7
			Sample Output 2:
			3 0
			-7
			Explanation for Sample Output 1:
			For sample test case 1: 
			1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] ie. 3 * 1 = 3
			2. MAT3[0][1] = MAT1[0][0] * MAT2[0][1] ie. 3 * 0 = 0

			For sample test case 2: 
			1. MAT3[0][0] = MAT1[0][0] * MAT2[0][0] ie. -1 * 7 = -7

		#include <bits/stdc++.h> 
		vector<vector<int>> multiplyMatrices(vector<vector<int>> &mat1, vector<vector<int>> &mat2) {
			int m = mat1.size();    // Number of rows in mat1
			int n = mat1[0].size(); // Number of columns in mat1
			int p = mat2[0].size(); // Number of columns in mat2

			vector<vector<int>> ans(m, vector<int>(p, 0));
			for (int i = 0; i < m; ++i) {
				for (int j = 0; j < p; ++j) {
					for (int k = 0; k < n; ++k) {
						ans[i][j] += mat1[i][k] * mat2[k][j];
					}
				}
			}

			return ans;
		}
	
	187) Maximum Swap: ❌Pending
		Problem Statement
			Given a positive integer N, you can do the following operation at most once
				a) Swap two digits of the integer N
			You need to determine the largest integer you can get by performing the above operation at most once.
			Constraints:
				1 <= T <= 10
				1 <= N <= 10^9
				Time limit: 1 sec

			Sample Input 1:
				2
				4589
				99538
				Sample Output 1:
				9584
				99835
				Explanation Of Sample Input 1:
				For the first test case, swap the first digit with the last digit, So, return 9584.
				For the second test case, swap the third digit with the last digit. So, return 99835.
				Sample Input 2:
				2
				4321   
				18
				Sample Output 2:
				4321
				81
				Explanation Of Sample Input 2:
				For the first test case, the number given is biggest among all possible answers, So, return 4321.
				For the second test case, swap the first digit with the last digit. So, return 81.
		#include <bits/stdc++.h> 
		int maximumSwap(int n) {
			string s = to_string(n);
			int flg = 1;
			for (int i = 0; i < s.length(); i++) {
				int curIndex = i;  // Initialize curIndex to i
				for (int j = s.length() - 1; j > i; j--) {
					if (s[j] > s[curIndex]) {
						curIndex = j;
						flg = 0;
					}
				}
				if (flg == 0) {
					swap(s[i], s[curIndex]);
					break;
				}
			}
			n = stoi(s);
			return n;
		}
	
	188) Power Set:❌Pending
		Problem Statement
			You are given a sorted array of 'N' integers. You have to generate the power set for
			this array where each subset of this power set is individually sorted.
			A set is a well-defined collection of distinct elements. Power set P(ARR) of a set
			'ARR' is defined as a set of all possible subsets of 'ARR'.
			You have to return the array of subsets. The elements in the subset should be sorted
			in ascending order. The order of subsets in the array does not matter. Hence there
			can be more than 1 possible solution for a given array.
			For Example :
			If we are given an array ARR=[1,2,3] then the power set P(ARR) of the
			set ARR is: [ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]]
			Note :
			For every subset 'X' present in power set P(ARR) of set ARR, X must
			be sorted i.e. in the example above:
			P1(ARR) = [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
			P2 (ARR) = [[], [1], [1,2,3], [2], [1,2], [3], [1,3], [2,3]]
			P3(ARR) = [[], [1], [2], [1,2], [3], [1,3], [2,3], [2,3,1]]
			P1 (ARR) and P2 (ARR) will be considered correct power sets but P3 (ARR)
			will not be considered correct because there the last subset [2, 3,1] is not sorted.

			Sample Input 1 :
				3
				1 2 3    
				Sample Output 1 :
				1
				2
				3
				1 2
				1 3
				2 3

				1 2 3 
				Explanation Of Sample Input 1 :
				The power set P(ARR) of set ARR = [1, 2, 3] is [ [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] ].
				Sample Input 2 :
				3
				5 7 8    
				Sample Output 2 :
				8
				7

				5
				5 8
				5 7
				5 7 8

		#include <bits/stdc++.h> 
		vector<vector<int>> pwset(vector<int>v) {
			vector<vector<int>> ans;
			int n = v.size();
			
			// Generate all subsets using bit manipulation
			for (int mask = 0; mask < (1 << n); ++mask) {
				vector<int> subset;
				for (int i = 0; i < n; ++i) {
					if (mask & (1 << i)) {
						subset.push_back(v[i]);
					}
				}
				ans.push_back(subset);
			}
			return ans;
		}
	
	189) Radix Sort:
		Constraints:
			1 <= 'T' <= 10
			1 <= 'N' <= 10^4
			1 <= ARR[i] <= 10^9
			Time Limit: 1 sec
		Sample Input 1 :
			2
			4
			1 4 3 5
			5 
			5 4 3 2 1
			Sample Output 1 :
			1 3 4 5
			1 2 3 4 5
			Explanation Of Sample Input 1 :
			In test case ‘1’, ‘1 3 4 5’ is the increasing sorted order.
			In test case ‘2’. ‘1 2 3 4 5’ is the increasing sorted order.
			Sample Input 2 :
			2
			2
			30 25
			6 
			2 2 2 2 2 2
			Sample Output 2 :
			25 30
			2 2 2 2 2 2

		#include <bits/stdc++.h> 
		vector<int> radixSort(int n, vector<int>& arr) {
			sort(arr.begin(), arr.end());
			return arr;

			// vector<int> ans;
			// for(int i=0; i<arr.size(); i++){
			//     for(int j=i+1; j<arr.size(); j++){
			//         if(arr[i] > arr[j]){
			//             swap(arr[i],arr[j]);
			//         }
			//     }
			// }

			// return arr;
			// for(int i: arr){
			//     ans.push_back(i);
			// }
			// return ans;
		}
	
	190) Set Matrix Zeros:
		Sample Input 1 :
			2
			2 3
			7 19 3
			4 21 0
			3 3
			1 2 3
			4 0 6
			7 8 9
			Sample Output 1 :
			7 19 0
			0 0 0
			1 0 3
			0 0 0
			7 0 9
			Explanation For Sample Input 1 :
			For First Case - Similar to the example explained above. 

			For Second Case - 
			Only the cell (2,2) has zero. So all the elements of the second row and second column are changed to zeros.
			Sample Input 2 :
			2
			4 2
			1 0
			2 7
			3 0
			4 8
			3 3
			0 2 3
			1 0 3
			1 2 0
			Sample Output 2 :
			0 0
			2 0
			0 0
			4 0
			0 0 0
			0 0 0
			0 0 0

		#include <bits/stdc++.h>
		void setZeros(vector<vector<int>> &matrix) {
			vector<vector<int>> ans = matrix;

			for(int i=0; i<matrix.size(); i++){
				for(int j=0; j<matrix[0].size(); j++){
					if(matrix[i][j] == 0){
						//making complete row 0
						for(int a=0; a<ans[0].size(); a++){
							ans[i][a] = 0;
						}

						//making complete col 0
						for(int a=0; a<ans.size(); a++){
							ans[a][j] = 0;
						}
					}
				}
			}
			matrix = ans;
		}

	191) Ninja and Subarrays:
		Problem Statement
			One day Ninja got an array and started to play with it. He is finding subarrays of
			the array randomly and suddenly starts to wonder about the maximum of the
			sum of the smallest and the second smallest elements of all the subarrays
			possible of size at least 2.
			For Example:
			For the array [3 2 1]
			All the subarrays of size at least 2 are:
			[3 2], [2 1], [3 2 1]
			For the first subarray, the smallest and second smallest elements are 2 and 3,
			and their sum is 5.
			For the second subarray, the smallest and second smallest elements are 1 and 2
			and their sum is 3.
			For the third subarray, the smallest and second smallest elements are 1 and 2,
			and their sum is 3.
			So the maximum among these sums is 5.
			Since Ninja is too lazy to do this task, he asked you for help. You have to find
			the maximum of the sum of the smallest and the second smallest elements of
			all the subarray possible of size at least 2.
		
			Constraints:
				1 <= T <= 5
				2 <= N <= 10^5
				1 <= A[i] <= 10^4
				Time Limit: 1 sec.
		
		Sample Input 1:
			2
			4
			1 2 3 4
			2
			3 8
			Sample Output 1:
			7
			11
			Explanation For Sample Output 1:
			For the first test case, all the possible subarrays of size at least 2 are:
			[1 2], [1 2 3], [1 2 3 4], [2 3], [2 3 4], [3 4].
			The respective sum of the smallest and second smallest elements are 3, 3, 3, 5, 5, 7.
			So the answer will be the maximum of all of them, i.e., 7.

			For the second test case, there is only one subarray possible [3 8]. So the answer will be 11. 
			Sample Input 2:
			2
			5
			8 3 7 2 4
			4
			6 4 7 5
			Sample Output 2:
			11
			12

		//not optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int mxr=INT_MIN;
				if(n==2)
					return arr[0]+arr[1];

				for(int i=0; i<n-1; i++){
					vector<int> temp;
					temp.push_back(arr[i]);
					for(int j=i+1; j<n; j++){
						temp.push_back(arr[j]);
						vector<int> holder = temp;

						int firstSmall = *min_element(holder.begin(), holder.end());
						holder.erase(holder.begin() + (min_element(holder.begin(), holder.end()) - holder.begin()));

						int secondSmall = *min_element(holder.begin(), holder.end());
						holder.erase(holder.begin() + (min_element(holder.begin(), holder.end()) - holder.begin()));

						mxr = max(mxr, (firstSmall+secondSmall));
					}
				}
				return mxr;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int sumOfSmallestAndSecondSmallest(int n, vector<int> &arr){
				int alltimeSum = arr[0] + arr[1], currentSum = arr[0] + arr[1];
				for(int i=1;i<n-1;i++){
					currentSum = currentSum - arr[i-1] + arr[i+1];
					alltimeSum = max(currentSum, alltimeSum); 
				}
				return alltimeSum;
			}

	192) Shuffle integers:
		Problem statement:
			Given an array arr of n elements in the following format 
			{a1, a2, a3, a4, ... , an/2, b1, b2, b3, b4, ... , bn/2}, 
			the task is shuffle the array to {a1, b1, a2, b2, a3, b3, ... , an/2, bn/2} 
			without using extra space.
			Note that n is even.

			Example 1:
				Input: 
				n = 4, arr = {1, 2, 9, 15}
				Output:  
				1 9 2 15
				Explanation: 
					a1=1, a2=2, b1=9, b2=15. So the final array will be: a1, b1, a2, b2 = {1,9,2,15}.

			Example 2:
				Input: 
				n = 6 arr = {1, 2, 3, 4, 5, 6} 
				Output: 
				1 4 2 5 3 6
			Your Task:
				This is a function problem. 
				You don't need to take any input, as it is already accomplished by the driver code. 
				You just need to complete the function shuffleArray() that takes array arr, and an integer n as 
				parameters and modifies the given array according to the above-given pattern.

			Expected Time Complexity: O(n).
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ n ≤ 105
				1 ≤ arr[i] ≤ 10^3
		
		class Solution{
			public:
			void shuffleArray(int arr[],int n) {
				vector<int> aHolder;
				vector<int> bHolder;
				int i;
				for(i=0; i<n/2; i++){
					aHolder.push_back(arr[i]);
				}
				
				for(i; i<n; i++){
					bHolder.push_back(arr[i]);
				}
				
				int cnt=0;
				for(int z=0; z<n; z++){
					if(z&1)
						arr[z] = bHolder[cnt++];
					else
						arr[z] = aHolder[cnt];	
				}
		}

	193) Find Character Case:
		Problem Statement
			You are given a character "CH" as input, return either 1, 0 or -1 according to the
			following rules:
				1, if the character is an uppercase alphabet (A - Z)
				0, if the character is a lowercase alphabet (a - z).
				-1, if the character is not an alphabet.
			For Example :
			If 'CH' = 'a', then since it is a lowercase letter, your program should return 0.
			Constraints:
				1 <= T <= 10
				"CH" = ASCII character
				Time Limit: 1 sec 
			Sample Input 1:
				2
				A
				t
				Sample Output 1:
				1
				0
				Explanation For Sample Input 1:
				For sample case 1, ‘A’ is an uppercase letter, hence output is 1.
				For sample case 2, ‘t’ is a lowercase letter, hence output is 0.
				Sample Input 2:
				2
				#
				P
				Sample Output 2:
				-1
				1
				Explanation For Sample Input 2:
				For sample case 1, ‘#’ is not an alphabet, hence output is -1.
				For sample case 2, ‘P’ is an uppercase letter, hence output is 1.

		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(!isalpha(ch))
				return -1;
			else if(isupper(ch))
				return 1;
			else 
				return 0;
		}

		//or
		#include <bits/stdc++.h> 
		int findCase(char ch) {
			if(islower(ch))
				return 0;
			else if(isupper(ch))
				return 1;
			else
				return -1;
		}
		
	194) Nth Number:
		Problem Statement
			In a series of numbers where each number is such that the sum of its digits
			equals 10. Given an integer value 'N', your task is to find the N-th positive integer
			whose sum of digits equals to 10.
			Constraints:
				1 <= T <= 100
				1<= N <= 10^7
				Time Limit: 1sec

		Sample Input 1:
			2
			1
			4
			Sample Output 1:
			19
			46   
			Explanation of Sample Input 1:
			Since N=1 here, therefore, the first number having a sum of digits equal to 10 is 19. Therefore, the output here is 19.

			Since N=4 here, therefore, The first four numbers having a sum of digits equal to 10 are 19, 28, 37, and 46. Therefore, the output here becomes 46.
			Sample Input 2:
			2
			5
			9
			Sample Output 2:
			55
			91

		//Not optimized:
			#include <bits/stdc++.h> 
			long long nthNumberWithSum10(long long n) {
				// int i=1;
				// vector<long long> holder;
				// while(holder.size() < n){
				//    int currentNum = i;
					
				//    int sum=0;
				//    while(currentNum !=0 ){
				//       sum += currentNum %10;
				//       currentNum /=10;
				//    }

				//    if(sum == 10)
				//       holder.push_back(i);
				//    i++;
				// }
				// return holder.back();

				std::vector<long long> holder;
				int currentNum = 19;  // Starting from the first number with digit sum 10
				int increment = 9;    // Increment to the next number with digit sum 10

				while (holder.size() < n) {
					int sum = 0;
					int num = currentNum;

					while (num > 0) {
					sum += num % 10;
					num /= 10;
					}

					if (sum == 10) {
					holder.push_back(currentNum);
					}

					currentNum += increment;
				}

				return holder.back();
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int dp[21][180][2];
			long long int solve(string &str,int pos,int sum,int res) {
				if(pos>=str.length()) {
					return dp[pos][sum][res]= sum==10;
				}

				if(dp[pos][sum][res]!=-1) {
					return dp[pos][sum][res];
				}
				long long int ans=0;
				if(res==1) {
					for(int i=0;i<=str[pos]-'0';i++) {
						if(i==str[pos]-'0') {
							ans+=solve(str,pos+1,sum+i,1) ;
						} else {
							ans+=solve(str,pos+1,sum+i,0);
						}	
					}
				} else {
					for(int i=0;i<=9;i++) {
						ans+=solve(str,pos+1,sum+i,0);
					}
				}
				return dp[pos][sum][res]=ans; 
			}

			long long nthNumberWithSum10(long long n) {
				long long int s=19;
				long long int e=LONG_MAX;
				long long int ans=0;
				while(s<=e) {
					long long int mid=s+(e-s)/2;
					string str=to_string(mid);
					memset(dp,-1,sizeof(dp));
					long long int cnt=solve(str,0,0,1);
					if(cnt>=n) {
						ans=mid;
						e=mid-1;
					} else {
						s=mid+1;
					}
				}
				return ans;
			}

	195) Print Pattern:
		Problem Statement:
			Print a sequence of numbers starting with N, without using loop, 
			where replace N with N - 5, until N > 0. 
			After that replace N with N + 5 until N regains its initial value.

			Example 1:
				Input: 
				N = 16
				Output: 
				16 11 6 1 -4 1 6 11 16
				Explaination: 
				The value decreases until it is greater than 0. After that it increases and stops when it becomes 16 again.

			Example 2:
				Input: 
				N = 10
				Output: 
				10 5 0 5 10
				Explaination: It follows the same logic as per the above example.

			Your Task:
			You do not need to read input or print anything. 
			Your task is to complete the function pattern() which takes N as input parameters 
			and returns a list containing the pattern.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				-10^5 ≤ N ≤ 10^5
		
		class Solution{
			public:
			vector<int> pattern(int N){
				vector<int> ans;
				int cnt=N;
				while(cnt>0){
					ans.push_back(cnt);
					cnt -=5;
				}
				
				while(cnt<=N){
					ans.push_back(cnt);
					cnt+=5;
				}
				return ans;
			}
		};

	196) Print the Pattern:
		Problem Statement
			Ninja is given a pattern. Now he is asked to print the same pattern for any given 'N' number of rows.
			Note:
				There is only one space between the values of each column in a row.
				For example, Pattern for 'N' = 5 will be.
				1 2 3 4 5
				11 12 13 14 15
				21 22 23 24 25
				16 17 18 19 20
				6 7 8 9 10
			Sample Input1 :
				1 
				5
				Sample Output2 :
				1 2 3 4 5 
				11 12 13 14 15 
				21 22 23 24 25 
				16 17 18 19 20 
				6 7 8 9 10 
				Explanation of Sample Input 1:
				For test case 1:
				We print the given pattern for the given 5 rows where each row has different values in increasing order with a difference in the value of 1 between each element and 1 space between each column in a row.
				Sample Input2 :
				1
				4
				Sample Output2 :
				1 2 3 4
				9 10 11 12
				13 14 15 16
				5 6 7 8
				Explanation of Sample Input 2:
				For test case 1:
				We print the given pattern for the given 4 rows where each row has different values in increasing order with a difference of 1 in the value of 1 between each element and 1 space between each column in a row.

		#include <bits/stdc++.h> 
		vector<string> printPattern(int n) {
			vector<string> ans(n);

			vector<vector<int>> holder;
			int cnt=1;
			for(int i=1; i<=n; i++){
				vector<int> temp;
				for(int j=1; j<=n; j++){
					temp.push_back(cnt++);
				}
				holder.push_back(temp);
				temp.clear();
			}

			int index;
			int start =0;
			int end = n-1;
			for(int i=0; i<n; i++){
				if(i&1){
					index = end--;
				} else {
					index = start++;
				}
				for(int j=0; j<n; j++){
					ans[index] += (to_string(holder[i][j]) + " ");
				}
			}
			return ans;
		}

	197) Number of 1 Bits:
		Problem Statement:
			Write a function that takes the binary representation of an unsigned integer 
			and returns the number of '1' bits it has (also known as the Hamming weight).

			Note:
				Note that in some languages, such as Java, there is no unsigned integer type. In this case,
				the input will be given as a signed integer type. 
				It should not affect your implementation, as the integer's internal binary representation 
				is the same, whether it is signed or unsigned. In Java, the compiler represents the signed 
				integers using 2's complement notation. 
				Therefore, in Example 3, the input represents the signed integer. -3.
			
			Example 1:
				Input: n = 00000000000000000000000000001011
				Output: 3
				Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

			Example 2:
				Input: n = 00000000000000000000000010000000
				Output: 1
				Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.

			Example 3:
				Input: n = 11111111111111111111111111111101
				Output: 31
				Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
				
			Constraints:
				The input must be a binary string of length 32.

		class Solution {
		public:
			int hammingWeight(uint32_t n) {
				return __builtin_popcount(n);
				// int cnt=0;
				// while(n!=0){
				//     if(n&1)
				//         cnt++;
				//     n>>=1;
				// }
				// return cnt;
			}
		};

	198) Find All Anagrams in a String
		Problem statement
			You have been given a string STR and a non-empty string PTR. Your task is to
			find all the starting indices of PTR's anagram in STR.
			An anagram of a string is another string which contains the same characters
			and is obtained by rearranging the characters.
			For example: 'SILENT and 'LISTEN" are anagrams of each other. 'ABA' and 'ABB'
			are not anagram because we can't convert 'ABA' to 'ABB' by rearranging the
			characters of particular strings.
			Note:
				1. Both STR and PTR consist of English uppercase letters.
				2. Length of string 'STR' will always be greater than or equal to the length of
				string 'PTR.
				3. In case, there is no anagram substring, then return an empty sequence.
				4. In case of more than one anagrams, return the indices in increasing order.
			Constraints:
				1 <=T <= 100
				1 <= N <= 10^5
				1<=M <=N
				Time limit: 1 second
		Sample Input 1 :
			2
			10 3
			CBAEBABACD
			ABC
			5 2
			ABADE
			BA
			Sample Output 1 :
			0 6
			0 1
			Explanation For Sample Output 1:
			Test Case 1:

			'STR' is ‘CBAEBABACD’ and ‘PTR’ is ‘ABC’.

			0-2 in 'STR' index 0,1,2 are ‘CBA’, and it is an anagram with ‘ABC’.
			1-3 in 'STR' index 1,2,3 are ‘BAE’, and it is not anagram with ‘ABC’.
			2-4 in 'STR' index 2,3,4 are ‘AEB’, and it is not anagram with ‘ABC’.
			3-5 in 'STR' index 3,4,5 are ‘EBA’, and it is not anagram with ‘ABC’.
			4-6 in 'STR' index 4,5,6 are ‘BAB’, and it is not anagram with ‘ABC’.
			5-7 in 'STR' index 5,6,7 are ‘ABA’, and it is not anagram with ‘ABC’.
			6-8 in 'STR' index 6,7,8 are ‘BAC’, and it is an anagram with ‘ABC’.
			7-9 in 'STR' index 7,8,9 are ‘ACD’, and it is not anagram with ‘ABC’.

			Hence, there are only two substrings in the given string 'STR'  that are anagram with given string  ‘PTR’ which are ‘CBA’, and ‘BAC’ and starting indices of respective anagram substrings are 0 and 6.


			Test case 2:

			'STR' is ‘ABADE’ and ‘PTR’ is ‘BA’.

			In the given string ‘ABADE’ the substring of length 2 starting with index 0 is ‘AB’ which is an anagram with the string ‘BA’ and a substring of length 2 starting with index 1 is ‘BA’ which is also an anagram with the string ‘BA’. Because 0 and 1 are starting indices of the substrings, we print 0 and 1.
			Sample Input 2:
			2
			10 4
			BACDGABCDA
			ABCD
			7 1
			ABABABA
			A
			Sample Output 2:
			0 5 6
			0 2 4 6

		//not optimized:
			bool checker(int a1[26], int b1[26]){
				for(int i=0; i<26; i++){
					if(a1[i] != b1[i])
						return false;
				}
				return true;
			}

			vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
				
				//finding the ptr letter's positions
				int ptrHolder[26] = { 0 };

				for(int i=0; i<ptr.length(); i++){
					ptrHolder[ptr[i]-'A']++;
				}

				vector<int> ans;

				//for str
				int len = ptr.length();
				for(int i=0; i<str.length(); i++){
					int tempStrHolder[26] = {0};
					
					for(int a=i; a<len; a++){
						tempStrHolder[str[a]-'A']++;
					}
					len++;							//little bit problem with this len var.

					if(checker(ptrHolder, tempStrHolder))
						ans.push_back(i);
				}
				return ans;
			}
	
		//Optimized:
			bool checker(int a1[26], int b1[26]){
				for(int i=0; i<26; i++){
					if(a1[i] != b1[i])
						return false;
				}
				return true;
			}

			vector<int> findAnagramsIndices(string str, string ptr, int n, int m){
				int ptrHolder[26] = {0};
				for (char c : ptr) {
					ptrHolder[c - 'A']++;
				}

				vector<int> ans;

				int len = ptr.length();
				int tempStrHolder[26] = {0};

				// Initialize tempStrHolder for the first window
				for (int i = 0; i < len; i++) {
					tempStrHolder[str[i] - 'A']++;
				}

				// Check the first window
				if (checker(ptrHolder, tempStrHolder)) {
					ans.push_back(0);
				}

				// Iterate through the remaining windows
				for (int i = len; i < str.length(); i++) {
					// Update tempStrHolder for the current window
					tempStrHolder[str[i] - 'A']++;
					tempStrHolder[str[i - len] - 'A']--;

					// Check if the current window is an anagram
					if (checker(ptrHolder, tempStrHolder)) {
						ans.push_back(i - len + 1);
					}
				}
				return ans;
			}

	199) One Odd Occurring:
		Problem statement
			Given an array 'ARR'of 'N' integers, where all the elements occur an even
			number of times and only one number occurs an odd number of times.
			Find and return the number which occurs an odd number of times.
			For example:
				'N' = 5, 'ARR' = [1, 2, 3, 2, 3]
				Output: 1
			Except for number 1, all numbers occur an even number of times.
			Sample Input 1 :
				9
				4 5 6 5 6 9 9 4 4
				Sample Output 1 :
				4
				Explanation Of Sample Input 1 :
				5, 6, and 9 occur an even number of times, and only 4 occur odd number of times.
				Sample Input 2 :
				5
				1 1 1 1 1
				Sample Output 2 :
				1
			Constraints :
				1 <= 'N' <= 10^5
				1 <= 'ARR[i]' <= 10^5
				Time Limit: 1 sec
		
		int missingNumber(int n, vector<int> &arr){
			unordered_map<int, int> FreqCounter;
			for(int i=0; i<n; i++){
				FreqCounter[arr[i]]++;
			}

			int num;
			for(auto i: FreqCounter){
				if((i.second % 2) != 0){
					num = i.first;
					break;
				}
			}
			return num;
		}

		//or
			int missingNumber(int n, vector<int> &arr){
				unordered_map<int, int> FreqCounter;
				for(int i=0; i<n; i++)
					FreqCounter[arr[i]]++;

				for(auto i: FreqCounter)
					if(i.second & 1)
						return i.first;
			}

	200) Reverse Number:
		Problem Statement:
			Ninja is feeling very bored and wants to try something new. So, he decides to
			find the reverse of a given number. But he cannot do it on his own and needs
			your help.
			Note:
				If a number has trailing zeros, then its reverse will not include them. For e.g., the
				reverse of 10400 will be 401 instead of 00401.
			Sample Input 1:
				2
				10400
				12345
				Sample Output 1:
				401
				54321
				Explanation of Sample Input 1:
				Test case 1:
				For the first test case of sample output 1, as the number 
				is ‘10400’, after finding the reverse, it turns out to be ‘00401’ but 
				we need to leave the trailing zeros. Therefore our solution is 401

				Test case 2:   
				For the second test case of sample output 1, as the number is ‘12345’, the reverse will be ‘54321’
				Sample Input 2:
				2
				1000
				7654321
				Sample Output 2:
				1
				1234567
				Explanation of Sample Input 2:
				Test case 1:
				For the first test case of sample output 2, as the input number is ‘1000’, we get the reverse as ‘1’.

				Test case 2:   
				For the second test case of sample output 2, as the input number is ‘7654321’, we get the reverse as ‘1234567’.

		#include <bits/stdc++.h> 
		long long int reverseNumber(long long int n) {
			string s = to_string(n);
			reverse(s.begin(), s.end());
			return stoll(s);
		}

	201) Check If Two String Arrays are Equivalent:
		Problems Statement:
			Given two string arrays word1 and word2, 
			return true if the two arrays represent the same string, 
			and false otherwise. A string is represented by an array 
			if the array elements concatenated in order forms the string.			
			
			Example 1:
				Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
				Output: true
				Explanation:
				word1 represents string "ab" + "c" -> "abc"
				word2 represents string "a" + "bc" -> "abc"
				The strings are the same, so return true.

			Example 2:
				Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
				Output: false

			Example 3:
				Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
				Output: true
			
			Constraints:
				1 <= word1.length, word2.length <= 103
				1 <= word1[i].length, word2[i].length <= 103
				1 <= sum(word1[i].length), sum(word2[i].length) <= 103
				word1[i] and word2[i] consist of lowercase letters.

		class Solution {
			public:
				bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {
					string s1,s2;
					for(int i=0; i<word1.size(); i++){
						s1 += word1[i];
					}
					
					for(int i=0; i<word2.size(); i++){
						s2 += word2[i];
					}

					//if(s1 == s2)
					//	return 1;
					//return 0;
					return s1==s2;
				}
		};

	202) Program to validate IP address:
		Problem statement
			You are given the text 'IPAddress'. Your task is to check if the given text
			'IPAddress' is a valid "IPv4' or not.
			Conditions for a valid 'IPv4' are:
				1. Text form of 'IPAddress' must be 'a.b.c.d'
				2. The values of a,b,c and d can vary from '0' to '255' and both '0' and '255' are
			inclusive.
			Constraints:
				1 <= T <= 10^4
				1 <= length of given text <= 50
				Time limit: 1 sec
			Sample Input 1:
				4
				123.111.12.k
				122.0.330.0
				1.1.1.250
				1.0.0.0.1
				Sample Output 1:
				False
				False
				True
				False
				Explanation of sample input 1:
				Test Case 1:
				Given text ‘IPAddress = 123.111.12.k’, it is satisfying the first condition that given ‘IPAddress’ must be ‘a.b.c.d’ formed but it not satisfying the second condition that d must in a range of ‘0’ to ‘255’ but the value of ‘d’ is ‘k’.
				Hence return ‘False’.

				Test Case 2:
				Given text ‘IPAddress = 122.0.330.0’, it is satisfying the first condition that given ‘IPAddress’ must be ‘a.b.c.d’ formed but it not satisfying the second condition that c must in a range of ‘0’ to ‘255’ but the value of ‘c’ is ‘330’ and it is out of range.
				Hence return ‘False’.

				Test Case 3:
				Given text ‘IPAddress = 1.1.1.250’, it is satisfying the first condition that given ‘IPAddress’ must be ‘a.b.c.d’ formed as well as it satisfying the second condition that a,b,c, and d must in range of ‘0’ to ‘250’.
				Hence return ‘True’.

				Test Case 4:
				Given text ‘IPAddress = 1.0.0.0.1’, it is not satisfying the first condition for valid ‘IPv4’, that text ‘IPAddress’ must be in form of ‘a.b.c.d’ but given text is a form of ‘a.b.c.d.e’
				Hence return ‘False’.
				Sample Input 2:
				2
				1.90.21.1
				1.1
				Sample Output 2:
				True
				False

		#include <bits/stdc++.h> 
		bool isValidIPv4(string ipAddress) {
			int cnt=0;
			for(int i=0; i<ipAddress.length();i++){
				if(ipAddress[i]== '.')
					cnt++;
			}

			for (char c : ipAddress) {
				if (!isdigit(c) && c !='.') {
					return false; // Non-digit characters are not allowed
				}
			}    
			if(cnt!=3)
				return 0;

			for(int i=0; i<ipAddress.length(); i++){
				string temp;
				while(i<ipAddress.length() && ipAddress[i] != '.' ){
					if(ipAddress[i] < '0' || ipAddress[i] > '9')
						return 0;
					temp += ipAddress[i];
					i++;
				}

				int num = stoi(temp);
				if(num>=0 && num<=255){
					//nothing
					//go for next iteration.
				}else{
					return 0;
				}
			}
			return 1;
		}
	
	203) Find Words That Can Be Formed by Characters:
		Problem statement:
			You are given an array of strings words and a string chars.
			A string is good if it can be formed by characters from chars 
			(each character can only be used once).
			Return the sum of lengths of all good strings in words.

			Example 1:

				Input: words = ["cat","bt","hat","tree"], chars = "atach"
				Output: 6
				Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.

			Example 2:
				Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
				Output: 10
				Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.

			Constraints:
				1 <= words.length <= 1000
				1 <= words[i].length, chars.length <= 100
				words[i] and chars consist of lowercase English letters.

		class Solution {
		public:
			int countCharacters(vector<string>& words, string chars) {
				int size=0;
				for(int i=0; i<words.size(); i++){
					string currentWord = words[i];
					string duplicateChars = chars;
					int a;
					for(a=0; a<currentWord.length(); a++) {
						char currentCH = currentWord[a];
						int flg = 1;
						for(int z=0; z<duplicateChars.length(); z++){
							if(currentCH == duplicateChars[z]){
								duplicateChars[z] = '0';
								flg = 0;
								break;
							}else{
								flg = 1;
								continue;
							}
						}
						if(flg)
							break;  
					}
					if(a == currentWord.length())
						size += currentWord.length();
				}
				return size;
			}
		};
	
	204) Four Divisors:
		Problem statement
			Ninja was planning to propose to his crush, Nina, with his spectacular martial
			arts moves. But Nina was more interested in numbers and divisors, so she gave
			Ninja a challenge to complete. If Ninja solves it, only then she will date him.
			Nina gave him an array of positive integers, 'ARR' and asked him to find the sum
			of divisors of the integers in 'ARR' with exactly four divisors. In case there is no
			such integer with exactly four divisors, then the answer is 0. Ninja has been
			struggling for a very long time, so he needs your help to solve the problem.
			Constraints:
				1 <= T <= 5
				1 <= N <= 2000
				1 <= ARR[i] <= 10 ^ 5
				Where 'T' is the number of test cases, 'N' is the number of integers in the array,
				ARR' and 'ARR[i]' is the 'ith element in the 'ARR' array.
				Time limit: 1 second
			Sample Input 1:
				2
				4
				2 5 6 15
				3
				4 18 21
				Sample Output 1:
				36
				32
				Explanation of Sample Output 1:
				Test Case 1 :  
				Divisors of 2 are 1 and 2.
				Divisors of 5 are 1 and 5.
				Divisors of 6 are 1, 2, 3 and 6.
				Divisors of 15 are 1, 3, 5 and 15.
				Since 6 and 15 have exactly four divisors. Sum of their divisors is (1 + 2 + 3 + 6) + (1 + 3 + 5 + 15) = 36.

				Test Case 2 : 
				Divisors of 4 are 1, 2 and 4.
				Divisors of 18 are 1, 2, 3, 6, 9 and 18.
				Divisors of 21 are 1, 3, 7 and 21.
				Since only 21 has exactly four divisors. Sum of its divisors is (1 + 3 + 7 + 21) = 32.
				Sample Input 2:
				2
				5
				7 35 64 11 8
				6
				27 13 42 25 25 25
				Sample Output 2:
				63
				40

		#include <bits/stdc++.h> 
		int sumFourDivisors(vector<int> &arr, int n) {
			int ans=0;
			for(int i=0; i<n; i++){
				int numDivisors=2;
				int sum=1;
				for(int j=2; j <= arr[i]/2; j++){
					if(arr[i] % j == 0){
						numDivisors++;
						sum += j;
					}

					if(numDivisors > 4)
						break;
				}
				sum += arr[i];
				if(numDivisors == 4)
					ans += sum;
			}
			return ans;
		}

	205) Minimum Difference in an Array:
		Problem statement
			Given an array of integers, print the minimum of the absolute difference of all
			possible pairs of elements.
			Example:
				N = 5
				ARR = [3, -6, 7, -7, 0]
			Out of all pairs, (-7,-6) have a difference of '1', and no other pair has less
			difference. So 'ANS' is '1'
			Constraints :
				1 <= T <= 10
				2 <= N <= 10^5
				-10^8 <= ARR[i] <= 10^8
				Sum of N <= 10^5
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4
				1 8 3 10   
				2
				5 5
				Sample Output 1 :
				2
				0
				Explanation Of Sample Input 1 :
				For test case 1, 
				Out of all pairs (1,3) and (8,10) have the minimum difference ‘2’ so the answer is ‘2’.
				For test case 2,
				There is only one possible pair (5,5) so the answer is ‘0’.
				Sample Input 2 :
				2
				3
				8 1 8
				2
				-3 3
				Sample Output 2 :
				0
				6

		//not optimized:
			#include <bits/stdc++.h> 
			int minDiff(int n, vector < int > arr) {
				int mnnr=INT_MAX;
				
				for(int i=0; i<n; i++){
					for(int j=i+1; j<n; j++){
					int num = abs(arr[i] - arr[j]);
					if(mnnr > num)
						mnnr = num;
					}
				}
				return mnnr;
			}

		//Optimized:
			#include <bits/stdc++.h> 
			int minDiff(int n, vector < int > arr) {
				int mnnr=INT_MAX;
				sort(arr.begin(), arr.end());

				for(int i=1; i<n; i++){
					int num = abs(arr[i] - arr[i-1]);
					if(mnnr > num)
					mnnr = num;
				}
				return mnnr;
			}

	206) Find The Nearest Supporter:
			Problem Statement
				There are contestants standing in a row. Each contestant is assigned a rating,
				which is an integer. A contestant supports all those whose rating is greater than
				their rating.
				Now for each contestant standing in the row, you need to tell the rating of its
				closest supporter on the left.
				If no supporter is there, store -1 in that place.
				For Example
					Consider the row: [3, 1, 5, 12, 10], with 1-based indexing -
					For index 3, there would be 2 supporters, index 1 and index 2, but index 2 is
					closest, hence for index 3, we will store '1' (Rating of contestant).
					For index 5, we will store '5'(at index 3).
				Constraints
					1 <= T <= 50
					1<=N<= 10000
					-10^9 <= data <= 10^9
					Where 'data' represents the given row elements.
					Time limit: 1 sec
			
			#include <bits/stdc++.h> 
			vector<int> prevSmall(vector<int> arr, int n) {
				// vector<int> ans(n,-1);
				// for(int i=1; i<n; i++){
				//     for(int j=i-1; j>=0; j--){
				//         if(arr[j] < arr[i]){
				//             ans[i] = arr[j];
				//             break;
				//         }
				//     }
				// }
				// return ans;

				//optimized
				vector<int>ans(n,-1);
				stack<int>s;
				for(int i=0;i<n;i++){
					while(!s.empty() and s.top()>=arr[i]) s.pop();
					if(!s.empty()) ans[i]=s.top();
					s.push(arr[i]);
				}
				return ans;
			}
	
	207) Find K-Th Element From Product Array:
		Problem statement
			You are given an integer array 'Arr' of length 'N'. Your task is to find the th
			element of the 'product' array when the 'product' array is sorted in non-decreasing order.
			The 'product' array of 'Arr' is an array of size (N*(N-1)) / 2 which consist|
			multiplication of each pair of elements present in the array 'Arr', i.e product[k] =Arr[i] * Arr[j], where 0 ≤i < j< 'N.
			Note:
			Return -1 if the value of 'K' exceeds the number of elements in the array 'product.
			For Example :
				Input array "arr"= [1, 2, 3, 4] and K = 3
				Output: 4
			Explanation: The 'product' array i.e array formed by multiplying each pair of
			element of 'Arr' is [1*2, 1*3, 1*4, 2*3, 2*4, 3*4] = [2, 3, 4, 6, 8, 12]. So the Kth(K =3) element in this sorted 'product' array is 4.
			Constraints:
				1 <= T <= 50
				1 <=N <= 10^4
				1 <=K<= 1019
				-10^4 <= Arr[i] <= 10^4
				Time Limit: 1 sec
			Sample Input 1 :
				2
				4 2
				1 2 3 -1
				3 2
				-1 0 1
				Sample Output 1 :
				-2
				0
				Explanation For Sample Input 1 :
				Test Case 1:
				The ‘product’ array formed by multiplying any two numbers taken two at a time is : [-1 * 1, -1 * 2, -1 * 3, 1 * 2, 1 * 3, 2 * 3] = [-1, -2, -3, 2, 3, 6] and this array after sorting  is: [-3, -2, -1, 2, 3, 6]. So the 2nd element in the sorted ‘product’ array is -2.

				Test Case 2:
				The ‘product’ array formed by multiplying any two numbers taken two at a time is : [-1 * 0, -1 * 1, -0 * 1] [0, -1] and sorted ‘product’ array is: [-1, 0, 0]. So the 2nd element in the sorted ‘product’ array is 0.
				Sample Input 2 :
				2
				3 5
				1 3 4
				1 1
				-1
				Sample Output 2 :
				-1
				-1

		//not Optimized:
			#include <bits/stdc++.h> 
			int kthSmallest(vector<int> &arr, int k) {
				// vector<int> Vholder;
				// for(int i=0; i<arr.size()-1; i++){
				// 	for(int j=i+1; j<arr.size(); j++){
				// 		Vholder.push_back(arr[i]*arr[j]);
				// 	}
				// }

				// sort(Vholder.begin(), Vholder.end());
				// if(k>Vholder.size())
				// 	return -1;
				// return Vholder[k-1];
				

				//little optimized
				std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
				// Push the initial products into the min-heap
				for (int i = 0; i < arr.size() - 1; ++i) {
					for (int j = i + 1; j < arr.size(); ++j) {
						minHeap.push(arr[i] * arr[j]);
					}
				}

				// Check if k is greater than the number of products
				if (k > minHeap.size()) {
					return -1;
				}

				// Pop (k-1) smallest elements from the min-heap
				for (int i = 0; i < k - 1; ++i) {
					minHeap.pop();
				}

				// The top of the min-heap now contains the k-th smallest product
				return minHeap.top();
			}

		//Optimized:
			#include <bits/stdc++.h> 
			bool checkPair(std::vector<int> &pos, std::vector<int> &neg, int k, int mid) {
				int pairs = 0;
				int temp = neg.size() - 1;
				int negSize = neg.size() - 1;
				int posSize = pos.size() - 1;

				for (int i = 0; i < neg.size(); i++) {
					while (temp >= 0 && (neg[i] * neg[temp] <= mid)) {
						temp = temp - 1;
					}
					pairs = pairs + std::min(negSize - temp, negSize - i);
				}

				temp = 0;

				for (int i = pos.size() - 1; i >= 0; i--) {
					while ((temp < pos.size()) && (pos[i] * pos[temp] <= mid)) {
						temp = temp + 1;
					}
					pairs = pairs + std::min(temp, i);
				}

				temp = pos.size() - 1;

				for (int i = neg.size() - 1; i >= 0; i--) {
					while ((temp >= 0) && (neg[i] * pos[temp] <= mid)) {
						temp = temp - 1;
					}
					pairs = pairs + posSize - temp;
				}

				return pairs >= k;
			}

			int kthSmallest(std::vector<int> &arr, int k) {
				int n = arr.size();

				if (k > (n * (n - 1)) / 2) {
					return -1;
				}

				std::vector<int> pos;
				std::vector<int> neg;

				for (int i = 0; i < n; i++) {
					if (arr[i] >= 0) {
						pos.push_back(arr[i]);
					} else {
						neg.push_back(arr[i]);
					}
				}

				std::sort(neg.begin(), neg.end());
				std::sort(pos.begin(), pos.end());

				int l = -1 * 1e9;
				int ans = 0;
				int r = 1e9;

				while (l <= r) {
					int mid = (l + r) / 2;

					if (checkPair(pos, neg, k, mid)) {
						ans = mid;
						r = mid - 1;
					} else {
						l = mid + 1;
					}
				}

				return ans;
			}

	208) Largest 3-Same-Digit Number in String:
		Problem Statement:
			You are given a string num representing a large integer. 
			An integer is good if it meets the following conditions:
				It is a substring of num with length 3.
				It consists of only one unique digit.
			Return the maximum good integer as a string or an empty string "" if no such integer exists.

			Note:
			A substring is a contiguous sequence of characters within a string.
			There may be leading zeroes in num or a good integer.
			
			Example 1:
				Input: num = "6777133339"
				Output: "777"
				Explanation: There are two distinct good integers: "777" and "333".
				"777" is the largest, so we return "777".

			Example 2:
				Input: num = "2300019"
				Output: "000"
				Explanation: "000" is the only good integer.

			Example 3:
				Input: num = "42352338"
				Output: ""
				Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.

			Constraints:
				3 <= num.length <= 1000
				num only consists of digits.

		class Solution {
			public:
			string largestGoodInteger(string num) {
				string ans;
				for(int i=2; i<num.length(); i++){
					if(num[i] == num[i-1]){
						if(num[i-1] == num[i-2]){
							string temp = string(3,num[i]);
							if(ans.empty())
								ans = temp;
							else{
								if(ans[0] < temp[0])
									ans = temp;
							}
						}
					}
				}
				return ans;
			}
		};
	
	209) Count of Matches in Tournament:
		Problem Statement:
			You are given an integer n, the number of teams in a tournament that has strange rules:
			-If the current number of teams is even, each team gets paired with another team. 
			 A total of n / 2 matches are played, and n / 2 teams advance to the next round.
			-If the current number of teams is odd, one team randomly advances in the tournament, 
			 and the rest gets paired. A total of (n - 1) / 2 matches are played, 
			 and (n - 1) / 2 + 1 teams advance to the next round.
			 Return the number of matches played in the tournament until a winner is decided.

			Example 1:

				Input: n = 7
				Output: 6
				Explanation: Details of the tournament: 
				- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
				- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
				- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
				Total number of matches = 3 + 2 + 1 = 6.

			Example 2:
				Input: n = 14
				Output: 13
				Explanation: Details of the tournament:
				- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
				- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
				- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
				- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
				Total number of matches = 7 + 3 + 2 + 1 = 13.

			Constraints:
				1 <= n <= 200
			
		class Solution {
			public:
			int numberOfMatches(int n) {
				int cnt=0;
				while(n>0){
					if(n&1){
						cnt += (n-1)/2;
						n = ((n-1)/2) + 1; 
						if(n==1)
							break;
					}else{
						cnt += n/2;
						n = (n/2);
					}
				}
				return cnt;
			}
		};

		//or
			class Solution {
				public:
				int numberOfMatches(int n) {
					return n-1;
				}
			};
	
	210) Median of two sorted arrays:
		Problem statement
			Given two sorted arrays 'a' and 'b'of size 'n' and 'm'respectively.
			Find the median of the two sorted arrays.
			Median is defined as the middle value of a sorted list of numbers. In case the
			length of list is even, median is the average of the two middle elements.
			The expected time complexity is O(min(logn, logm)), where 'n' and 'm' are the
			sizes of arrays 'a' and 'b', respectively, and the expected space complexity is
			O(1).
			Example:
				Input: 'a' = [2, 4, 6] and 'b' = [1, 3, 5]
				Output: 3.5
				Explanation: The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 5, 6 }. Here two
				medians are 3 and 4. So the median will be the average of 3 and 4, which is 3.5.
			Sample Input 1:
				3 3
				2 4 6
				1 3 5
				Sample Output 1:
				3.5
				Explanation of Sample Input 1 :
				The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 5, 6 }. 
				Here two medians are 3 and 4. So the median will be the average of 3 and 4, which is 3.5.
				Sample Input 2:
				3 2
				2 4 6
				1 3  
				Sample Output 2:
				3
				Explanation of Sample Input 2 :
				The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 6 }. 
				The median is 3.
				Sample Input 3:
				3 3
				1 2 2
				2 4 4
				Sample Output 3:
				2.0
				Explanation of Sample Input 3 :
				The array after merging 'a' and 'b' will be { 1, 2, 2, 2, 4, 4 }. 
				Here two medians are 2 and 2. So the median will be the average of 2 and 2, which is 2.
			Constraints:
				1 <= 'n' <= 10 ^ 6
				1 <= 'm' <= 10 ^ 6
				1 <= 'a[i]' <= 10 ^ 9
				1 <= 'b[i]' <= 10 ^ 9
				Time limit: 1 sec.

		//Not Optimized:
			double median(vector<int>& a, vector<int>& b) {
				vector<int> holder;
				for(int i: a)
					holder.push_back(i);
				
				for(int i: b)
					holder.push_back(i);

				sort(holder.begin(), holder.end());

				if(holder.size()&1)
					return holder[(holder.size()/2)];

				double n = holder[holder.size()/2] + holder[(holder.size()/2)-1];
				return n/2;
			}

		//Optimized:
			double median(std::vector<int>& a, std::vector<int>& b) {
				int n1 = a.size(), n2 = b.size();
				int i = 0, j = 0;
				int n = n1 + n2;
				int ind2 = n / 2;
				int ind1 = ind2 - 1;
				int cnt = 0;
				int ind1el = -1, ind2el = -1;

				while (i < n1 && j < n2) {
					if (a[i] < b[j]) {
						if (cnt == ind1) ind1el = a[i];
						if (cnt == ind2) ind2el = a[i];
						cnt++;
						i++;
					} else {
						if (cnt == ind1) ind1el = b[j];
						if (cnt == ind2) ind2el = b[j];
						cnt++;
						j++;
					}
					if (ind1el != -1 && ind2el != -1)
						break;
				}

				while (i < n1) {
					if (cnt == ind1) ind1el = a[i];
					if (cnt == ind2) ind2el = a[i];
					cnt++;
					i++;
					if (ind1el != -1 && ind2el != -1)
						break;
				}

				while (j < n2) {
					if (cnt == ind1) ind1el = b[j];
					if (cnt == ind2) ind2el = b[j];
					cnt++;
					j++;
					if (ind1el != -1 && ind2el != -1)
						break;
				}

				if (n % 2 == 1) return ind2el;

				// return static_cast<double>(ind1el + ind2el) / 2.0;
				//or
				return (double)(double)(ind1el+ind2el)/2.0;
			}

	211) Query And Matrix:
		Problem statement
			You are given a binary matrix with 'M' rows and 'N' columns initially consisting of
			all 0's. 'Q' queries follow. The queries can be of 4 types:
			Query 1: 1 R index
			Query 2: 1 C index
			Query 3: 2 R index
			Query 4: 2 C index
			In each query, the first input is the type of the query, the second input is whether
			we have to consider the row ('R') or the column ('C') and the third input is the
			index of the row/column.
			For each type 1 query, we need to flip the elements of the row/column having the
			given index.
			For each type 2 query, we have to output the number of zeros present in the
			row/column having the given index.
			Note:
			Note that the matrix is a binary matrix, meaning that it only contains either 0 or 1.
			Example :
				Given M = 3, N = 3,
				Queries : 1R1, 1R2, 2C1
				So, in the above example the change in the matrix would look like this:
				
					0	0	0		0	0	0		0	0	0	
					0	0	0		1	1	1		1	1	1		
					0	0	0		0	0	0		1	1	1

				Next query 2C1 will return the count of the number of zeroes in the 1st column: 1
			Constraints:
				1 <= T <= 10
				1 <= M, N <= 100
				1 <= Q ≤= 1000
				1 <= R<= M
				1 <= C <=N
				type = 1, 2
				Time limit: 1 sec

			Sample Input 1:
				2
				3 3
				3
				1R1
				1R2
				2C1

				2 2
				1
				2R1
				Sample Output 1:
				1
				2
				Explanation of Sample Output 1:
					In test case 1, Next query 2C1 will return the count of the number of zeroes in the 1st column: 1
					The change in the matrix after the first and second queries would look like this:
						
					0	0	0		0	0	0		0	0	0	
					0	0	0		1	1	1		1	1	1		
					0	0	0		0	0	0		1	1	1

				In test case 2, all the matrix elements are zero and hence the count of zeroes will be 2 for the first row.
				Sample Input 2:
				2
				3 3
				4
				2C1
				1R1
				1R1
				2R1
				2 2
				5
				2C1
				1R1
				1R1
				1R1
				2R1
				Sample Output 2:
				3 3
				2 0
				Explanation of Sample Output 2:
				In test case 1, 
				First query 2C1 will return the count of the number of zeroes in the 1st column: 3
				Next query 2R1 will return the count of the number of zeroes in the 1st row: 3
				The change in the matrix after the second and third queries would look like this:
					
					0	0	0		0	0	0		0	0	0	
					0	0	0		1	1	1		0	0	0		
					0	0	0		0	0	0		0	0	0

				In test case 2,
				First query 2C1 will return the count of the number of zeroes in the 1st column: 2
				Next query 2R1 will return the count of the number of zeroes in the 1st column: 0
				The change in the matrix after the second and third queries would look like this:

					0	0			0	0			0	0		0	0
					0	0			1	1			0	0		1	1

		//not Optimized:
			vector<int> query(vector<vector<int>> &mat, int m, int n, vector<string> &q){
				vector<int> ans;
				vector<vector<int>> holder(m, vector<int>(n,0));

				for(int i=0; i<q.size(); i++){
					string current = q[i];
					if(current[0] == '1'){
						if(current[1] == 'R'){
							for(int a = 0; a<n; a++){
								if(holder[current[2]-'0'][a] == 0){
									holder[current[2]-'0'][a] = 1;
								}else{
									holder[current[2]-'0'][a] = 0;
								}
							}
						}else{
							for(int a = 0; a<m; a++){
								if(holder[a][current[2]-'0'] == 0){
									holder[a][current[2]-'0'] = 1;
								}else{
									holder[a][current[2]-'0'] = 0;
								}
							}
						}
					}else{
						int cnt=0;
						if(current[1] == 'R'){
							for(int y=0; y<n; y++){
								if(holder[current[2]-'0'][y] == 0)
									cnt++;
							}
						}else{
							for(int y=0; y<m; y++){
								if(holder[y][current[2]-'0'] == 0)
									cnt++;
							}
						}
						ans.push_back(cnt);
					}
				}
				return ans;	
			}

	212) Mailing Problem: ❌Pending
		Problem Statement:
			Dr. Doofenshmirtz is trying to make another big mischief. To prevent this, Major
			Francis Monogram wants to send mail to Perry the Platypus to inform him about
			the mischief. He just needs to send a secret message 's' to perry. He has a
			special keyboard "keyboard" in which all the letters are in a straight line but
			jumbled. The time taken to move his finger from index 'ї to index j' is lj - il. He
			wants to know how much time will it take to send the secret message to Perry.
			Note:
			Initially, he is at the first letter of the keyboard.
			All letters are in lower-case English letters.
			For Example :
				Let s = "perry", keyboard = "qwertyuiopasdfghjkIzxcvbnm".
				Now In this example, Francis will start from the first index and go to 'p', which
				will take 9 seconds, now from 'p' to 'e', the distance is of 7 indexes, from 'e' to 'r'
				the distance is 1, from 'r' to 'f' it will be zero, and from '"' to 'y the distance will
				be 2. Hence the total time taken is 9 + 7 + 1 + 0 + 2 = 19.
				Hence the answer is 19.
			Sample Input 1 :
				2
				abcdefghijklmnopqrstuvwxyz
				abc
				zyxwvutsrqponmlkjihgfedcba
				zayb
				Sample Output 1 :
				2
				72
				Explanation For Sample Output 1 :
				For the first test case, Francis is currently on ‘a’ so he does not have to move his fingers for the first letter and then move one index from ‘a’ to ‘b’ and again one index from ‘b’ to ‘c’.
				Hence the answer is 2.

				For the second test case, he will start from the 0th index and then move to 25 to type ‘a’, then to index 1 to type ‘y’, and at last to index 24 to type ‘b’. Hence the total time taken is 0 + 25 + 24 + 23 = 72.
				Sample Input 2 :
				2
				mvpglaejurowcfbtisdkzhxqny
				ferb
				bjqtcxmkgzfeowdlsuaypnivrh
				phineas
				Sample Output 2 :
				28
				48
	
	213) Calculate Money in Leetcode Bank:
		Problems Statement:
			Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.
			He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, 
			he will put in $1 more than the day before. On every subsequent Monday, 
			he will put in $1 more than the previous Monday.
			Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

			Example 1:
				Input: n = 4
				Output: 10
				Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.

			Example 2:
				Input: n = 10
				Output: 37
				Explanation: After the 10th day, the total is 
				(1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.

			Example 3:
				Input: n = 20
				Output: 96
				Explanation: After the 20th day, the total is 
				(1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.

			Constraints:
				1 <= n <= 1000
		
		class Solution {
			public:
			int totalMoney(int n) {
				int ttl=0, day=0, start=1, num=1;
				for(int i=0; i<n; i++){
					if(day == 7){
						day =0;
						start++;
						num = start;
					}
					ttl += num++;
					day++;
				}
				return ttl;
			}
		};

		//or
		class Solution {
			public:
			int totalMoney(int n) {
				int ttl=0;
				int start=1;
				int num=start;

				for(int i=1; i<=n; i++){
					ttl += num++;
					if(i % 7 == 0){
						start++;
						num = start;
					}
				}
				return ttl;
			}
		};

	214) How Many X's:
		Problem Statement:
			Given two integers L, R, and digit X. Find the number of occurrences 
			of X in all the numbers in the range (L, R) excluding L and R.

			Example 1:
				Input:
				L=10, R=19, X=1
				Output:
				9
				Explanation:
				There are 9 1s (11, 12, 13, 14, 15, 16, 17, 18) in the numbers in the range (10,19).

			Example 2:
				Input:
				L=18, R=81, X=9
				Output:
				7
				Explanation:
				There are 7 occurrences of the digit 9 in the numbers in the range (18,81).
			Your Task:
				You don't need to read input or print anything. Your task is to complete the function 
				countX() which takes three integers L, R, and X as input parameters and 
				returns the number of occurrences of X in the numbers in the range(L, R).

			Expected Time Complexity:O(RLogR)
			Expected Auxillary Space:O(1)

			Constraints:
				1 <= L< R <= 105
				0 <= X <= 9 

		class Solution {
			public:
			int countX(int L, int R, int X) {
				int cnt=0;
				for(int i=L+1; i<R; i++){
					int num = i;
					while(num != 0){
						if(X == (num%10))
							cnt++;
						num /=10;
					}
				}
				return cnt;
			}
		};

	215) Faulty Key:
		problem statement:
			Addition wihtout using + & ++ operator.
				Ninja is trying to write a function that takes two integers and returns their sum.
				But, due to some faults in his keyboard, he can not use the "+", operator, which
				means he is not able to simply return 'A + 'B', where A and 'B' are the numbers
				to be added. You need to help Ninja in finding the sum of two numbers without
				using the "+" operator anywhere in your code.
				Note:
					You should also not use the increment "++" operator too.
				For example:
					You are given A = 4, B = 6, their sum = 10, you need to return 10.
			Constraints:
				1 <=Т<= 100
				-10000 <= A, B <= 10000
				where 'T' is the number of test cases and 'A' and 'B' are the two integers.
				Time limit: 1 sec
			Sample Input 1:
				2
				1 1
				4 6
				Sample Output 1:
				2
				10
				Explanation of sample input 1:
				In the first test case, 
				Sum of the two numbers = 1 + 1 = 2. 

				In the second test case, 
				Sum of the two numbers = 4 + 6 = 10.
				Sample Input 2:
				2
				-1 1
				0 1
				Sample Output 2:
				0
				1
				Explanation of sample input 1:
				In the first test case, 
				Sum of the two numbers = (-1) + 1 = 0.

				In the second test case, 
				Sum of the two numbers = 0 + 1 = 1.
		
		#include <bits/stdc++.h> 
		int getSum(int a, int b) {
			// return a -(-b);
			
			//or
			while (b != 0) {
				// Calculate the carry
				int carry = a & b;

				// XOR a and b to get the sum
				a = a ^ b;

				// Shift the carry by 1 position to the left
				b = carry << 1;
			}
			return a;
		}

	216) Generate Binary Numbers:
		Problem statement
			Your friend Ninja has been learning about binary numbers lately. In order to
			understand binary numbers with perfection, Ninja asks you to generate a list of
			binary numbers from 1 to 'N', which he can use later for reference.
			For every integer Ninja gives, your task is to generate all the binary numbers
			from 1 to 'N'.
			Example:
			Consider N = 5,
				All the binary numbers from 1 to 5 are: 1, 10, 11, 100, 101.
			Constraints:
				1 <= T <= 10
				1 <=N<= 10^5
				Time Limit: 1 sec
			Sample Input 1:
				2
				2
				6
				Sample Output 1:
				1 10
				1 10 11 100 101 110
				Explanation 1:
				For the first test case when N = 2. 
				We need all the binary numbers from 1 to 2:
				1 -> 1
				2 -> 10
				Thus, the output is 1, 10.

				For the second test case when N = 6
				We need all the binary numbers from 1 to 6:
				1 -> 1
				2 -> 10
				3 -> 11
				4 -> 100
				5 -> 101
				6 -> 110
				Thus, the output is 1, 10, 11, 100, 101, 110.
				Sample Input 2:
				2
				8
				4
				Sample Output 2:
				1 10 11 100 101 110 111 1000
				1 10 11 100

		#include <bits/stdc++.h> 
		vector<string> generateBinaryNumbers(int n) {
			vector<string> ansHolder;

			for(int i=1; i<=n; i++){
				string s = bitset<32>(i).to_string();

				//This while loop also works
				while(s[0] == '0')
					s.erase(s.begin());

				//converting string back to num so we can get rid of leading zeros,
				//in this scenario getting runtime error. This is not working
					// int num = stoi(s);
					// s = to_string(num);

				//to remove leading zeros use below line
				//This substr method also works
				// s = s.substr(s.find('1'));

				ansHolder.push_back(s);   
			}
			return ansHolder;
		}

	217)	Largest Odd Number in String:
		Problem Statement:
			You are given a string num, representing a large integer. 
			Return the largest-valued odd integer (as a string) that is a 
			non-empty substring of num, or an empty string "" if no odd integer exists.

			A substring is a contiguous sequence of characters within a string.

			Example 1:
				Input: num = "52"
				Output: "5"
				Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.

			Example 2:
				Input: num = "4206"
				Output: ""
				Explanation: There are no odd numbers in "4206".

			Example 3:
				Input: num = "35427"
				Output: "35427"
				Explanation: "35427" is already an odd number.

			Constraints:
				1 <= num.length <= 105
				num only consists of digits and does not contain any leading zeros.
	
		class Solution {
			public:
			string largestOddNumber(string num) {
				// if((num[num.size()-1] - '0') % 2 != 0)
				//     return num;
				
				// string s;
				// for(int i=num.size(); i>=0; i--){
				//     //checking if its odd
				//     if((num[i]-'0') & 1){
				//         for(int j=0; j<=i; j++){
				//             s += num[j];
				//         }
				//         return s;
				//     }
				// }
				// return "";

				//or
				for(int i=num.size()-1; i>=0; i--){
					if((num[i]-'0') & 1){
						return num;
					}
					num.erase(num.begin()+i);
				}
				return "";
			}
		};
	
	218) Transform to prime:
		Problem Statement:
			Given an array of n integers. Find the minimum positive number to be inserted in array, 
			so that sum of all elements of array becomes prime.

			Example 1:
				Input:
				N=5
				arr = {2, 4, 6, 8, 12}
				Output:  
				5
				Explanation: 
				The sum of the array is 32 ,we can add 5 to this to make it 37 which is a prime number.

			Example 2:
				Input:
				N=3
				arr = {1, 5, 7}
				Output:  
				0 
				Explanation: 
				The sum of the array is 13 which is already prime. 

			Your Task:
				You don't need to read input or print anything. 
				Your task is to complete the function minNumber() that takes array arr 
				and integer N as input parameters and returns the minimum positive 
				number to be inserted in the array so as to make it's sum a prime number.

			Expected Time Complexity: O(N log(log N))
			Expected Auxiliary Space: O(1).

			Constraints:
				1 ≤ N ≤ 10^5
				1 ≤ sum of all elements ≤ 10^6

		class Solution {
			public:
			int minNumber(int arr[],int N) {

				//calculating sum of array
				vector<int> holder;
				holder.assign(arr, arr+N);
				int sum =0;

				for(int i: holder)
					sum += i;
				
				int adder=0;
				while(1){
					//checking sum is prime or not
					int i;
					for(i=2; i<=sum/2; i++){
						if(sum % i == 0)
							break;
					}
					
					if(i == (sum/2)+1)
						return adder;
					sum ++;
					adder++;
				}
			}
		};

	219)	Transpose Matrix:
		Problem Statement:
			Given a 2D integer array matrix, return the transpose of matrix.
			The transpose of a matrix is the matrix flipped over its main diagonal, 
			switching the matrix's row and column indices.

			Example 1:
				Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
				Output: [[1,4,7],[2,5,8],[3,6,9]]

			Example 2:
				Input: matrix = [[1,2,3],[4,5,6]]
				Output: [[1,4],[2,5],[3,6]]

			Constraints:
				m == matrix.length
				n == matrix[i].length
				1 <= m, n <= 1000
				1 <= m * n <= 10^5
				-10^9 <= matrix[i][j] <= 10^9

		class Solution {
		public:
			vector<vector<int>> transpose(vector<vector<int>>& matrix) {
				vector<vector<int>> transpose;
				for(int i=0; i<matrix[0].size(); i++){
					vector<int> holder;
					for(int j=0; j<matrix.size(); j++){
						holder.push_back(matrix[j][i]);
					}
					transpose.push_back(holder);
				}
				return transpose;
			}
		};

		//or
			class Solution {
			public:
				vector<vector<int>> transpose(vector<vector<int>>& matrix) {
					vector<vector<int>> transpose(matrix[0].size(),vector<int>(matrix.size()));
					
					for(int i=0; i<matrix.size(); i++)
						for(int j=0; j<matrix[0].size(); j++)
							transpose[j][i] = matrix[i][j];
					
					return transpose;
				}
			};
	
	220)	Count the loop: ❌Pending
		-Count the no.of times loop will iterate.
		Problem statement
			Alice and Bob recently studied bitwise operators and were extremely fascinated
			by them. Alice found the following function in a book:
			Function magic(P, Q)
				while Q > 0:
				A = P AND Q
				B = P XOR Q
				Q = A* 2
				P = В
				return P
			Alice wondered how many times the while loop would run for any value of 'P'
			and 'Q'. Alice gave Bob the binary representation of 'P' and 'Q' and asked him to
			help her count this.
			Help Bob count the number of times the while loop would run for the given value
			of 'P' and 'Q.

		//Not optimized:
			#include <bits/stdc++.h> 
			int countLoop(string p, string q) {
				int cnt=0;
				int p = stoi(p1,0,2);
				int q = stoi(q1,0,2);

				while(q>0){
					int a = p & q;
					int b = p ^ q;
					q = a << 1;
					p = b;
					cnt++;
				}
				return cnt;
			}
		
		//optimized:
			#include <bits/stdc++.h>
			int countLoop(string p, string q) {
					if (q[0] == '0') {
					// 'q' is already zero.
					return 0;
				}

				// Reversing both the strings.
				std::string reversedP = p;
				std::string reversedQ = q;
				std::reverse(reversedP.begin(), reversedP.end());
				std::reverse(reversedQ.begin(), reversedQ.end());

				// Adding ‘0’ to the end so that both their lengths become equal.
				while (reversedP.size() < reversedQ.size()) {
					reversedP += "0";
				}

				while (reversedQ.size() < reversedP.size()) {
					reversedQ += "0";
				}

				int carry = 0, ans = 0, cur = 0;

				for (int i = 0; i < static_cast<int>(reversedP.size()); i++) {
					carry = carry + (reversedP[i] - '0') + (reversedQ[i] - '0');

					if (carry == 2) {
						// Continuing carry chain.
						cur += 1;
					} else {
						if (carry <= 1) {
							// Carry chain broken.
							cur = 0;
						} else {
							// Carry chain broken and new chain started.
							cur = 1;
						}
					}

					if (carry <= 1) {
						carry = 0;
					} else {
						carry = 1;
					}

					// Storing the longest carry chain.
					ans = std::max(ans, cur + 1);
				}

				return ans;
			}
	
	221) Max Sum Subarray of size K:
		Problem Statement:
			Given an array of integers Arr of size N and a number K. 
			Return the maximum sum of a subarray of size K.
			NOTE*: A subarray is a contiguous part of any given array.

			Example 1:
				Input:
				N = 4, K = 2
				Arr = [100, 200, 300, 400]
				Output:
				700
				Explanation:
				Arr3  + Arr4 =700,
				which is maximum.

			Example 2:
				Input:
				N = 4, K = 4
				Arr = [100, 200, 300, 400]
				Output:
				1000
				Explanation:
				Arr1 + Arr2 + Arr3 + Arr4 =1000,
				which is maximum.

			Your Task:
				You don't need to read input or print anything. Your task is to complete the function 
				maximumSumSubarray() which takes the integer K, 
				vector Arr with size N, containing the elements of the array 
				and returns the maximum sum of a subarray of size K.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 105
				1 <= Arri <= 105
				1 <= K <= N
		
		//not optimized
			class Solution{
				public:
				long maximumSumSubarray(int K, vector<int> &Arr , int N){
					long mxr=0;
					for(int i=0; i<=N-K; i++){
						long sum =0;
						for(int j=i; j<i+K; j++){
							sum += Arr[j];
						}
						if(mxr<sum)
							mxr = sum;
					}
					return mxr;
				}
			};

		//optimized:
			class Solution{   
				public:
				long maximumSumSubarray(int K, vector<int> &Arr , int N){
					long mxr = 0;
					long sum = 0;

					// Calculate the sum of the first subarray of length K
					for (int i = 0; i < K; i++) {
						sum += Arr[i];
					}
				
					mxr = sum;
				
					// Use a sliding window to efficiently find the maximum sum
					for (int i = K; i < N; i++) {
						// Update the sum by removing the first element of the window
						// and adding the current element to the window
						sum = sum - Arr[i - K] + Arr[i];
				
						// Update the maximum sum if needed
						mxr = max(mxr, sum);
					}
					return mxr;
				}
			};

	222) Ninja And His Old Friends
		Problem Statement:
			Ninja wants to meet his 'N' old friends standing in a row. All the friends along
			with Ninja are very happy because they are meeting after a long time. The
			happiness of each friend can be represented as a positive integer. Initially, Ninja
			has some happiness value "K. Ninja shakes hands with all of his 'N' friends
			standing in a row one by one.
			While shaking hands if the happiness value of Ninja matches with that of his
			friend, then the happiness value of Ninja becomes double. Ninja wants to
			calculate his happiness value after he shakes hands with all of his friends.
			For Example: For 'FRIENDS' = [3, 2, 1, 4]. And 'K = 2, following are the results
			after each hand shake:
			1. At index 0 the happiness value of his friend is 3 and the happiness value of
			Ninja is 2. Both are unequal so "K' remains the same.
			2. At index 1 the happiness value of his friend is 2 and the happiness value of
			Ninja is 2. Both are equal so "K" becomes 4.
			3. At index 2 the happiness value of his friend is 1 and the happiness value of
			4 At index the epines solve or mistine is 4 and the happiness value of
			Ninja is 4. Both are equal so "K' becomes 8.
			As Ninja is busy with his friends so he needs your help. Can you help Ninja to
			find his final happiness value after all the handshakes?

			Constraints:
				1 <= T <= 100
				1 <= N <= 10 ^ 4
				1 <= К <= 10 ^ 3
				1 <= FRIENDS[i] <= 10 ^ 6
				Where 'FRIENDS[I]' denotes the happiness value of the friend at the 'ї index,
				respectively.
				Time Limit: 1 sec
			
			Sample Input 1:
				2
				3 1
				1 2 4 
				2 4 
				1 2
				Sample Output 1:
				8
				4 
				Explanation of Sample Input 1:
				For the first test case:
				1. At index 0 the happiness value of his friend is 1 and the happiness value of Ninja is 1. Both are equal so ‘K’ becomes 2.
				2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 2. Both are equal so ‘K’ becomes 4.
				3. At index 2 the happiness value of his friend is 4 and the happiness value of Ninja is 4. Both are equal so ‘K’ becomes 8.

				For the second test case:
				1. At index 0 the happiness value of his friend is 1 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same. 
				2. At index 1 the happiness value of his friend is 2 and the happiness value of Ninja is 4. Both are unequal so ‘K’ remains the same. 
				Sample Input 2:
				2
				2 5
				5 5 
				3 8
				2 4 8 
				Sample Output 2:
				10
				16
				Explanation of Sample Input 2:
				For the first test case:
				1. At index 0 the happiness value of his friend is 5 and the happiness value of Ninja is 5. Both are equal so ‘K’ becomes 10.
				2. At index 1 the happiness value of his friend is 5 and the happiness value of Ninja is 10. Both are unequal so ‘K’ remains the same.    

				For the second test case:
				1. At index 0 the happiness value of his friend is 2 and the happiness value of Ninja is 8. Both are unequal so ‘K’ remains the same.
				2. At index 1 the happiness value of his friend is 4 and the happiness value of Ninja is 8. Both are unequal so ‘K’ remains the same.
				3. At index 2 the happiness value of his friend is 8 and the happiness value of Ninja is 8. Both are equal so ‘K’ becomes 16.

		#include <bits/stdc++.h> 
		int shakeHands(vector<int> &friends ,int n, int k) {
			for(int i=0; i<n; i++)  
				if(friends[i] == k)
					k *=2;

			return k;
		}

	223) First Unique Character in a String:
		Problem Statement:
			Given a string s, find the first non-repeating character in it and return its index. 
			If it does not exist, return -1.

			Example 1:
				Input: s = "leetcode"
				Output: 0

			Example 2:
				Input: s = "loveleetcode"
				Output: 2

			Example 3:
				Input: s = "aabb"
				Output: -1
			
			Constraints:
				1 <= s.length <= 105
				s consists of only lowercase English letters.
		
		class Solution {
			public:
			int firstUniqChar(string s) {
				for(int i=0; i<s.length(); i++){
					int j;
					for(j=0; j<s.length(); j++){
						if(i==j)
							continue;
						if(s[i] == s[j])
							break;
					}
					if(j==s.length())
						return i;
				}
				return -1;
			}
		};

	224) Element Appearing More Than 25% In Sorted Array:
		Problem Statement:
			Given an integer array sorted in non-decreasing order, 
			there is exactly one integer in the array 
			that occurs more than 25% of the time, return that integer. 
			Example 1:
				Input: arr = [1,2,2,6,6,6,6,7,10]
				Output: 6
			Example 2:
				Input: arr = [1,1]
				Output: 1

			Constraints:
				1 <= arr.length <= 104
				0 <= arr[i] <= 105
		
		class Solution {
			public:
			int findSpecialInteger(vector<int>& arr) {
				int cnt=1,i;
				if(arr.size()==1)
					return arr[0];

				for(i=1; i<arr.size(); i++){
					if(arr[i] == arr[i-1])
						cnt++;
					else
						cnt=1;
					
					if(cnt > (arr.size()/4))
						break;
				}
				return arr[i];    
			}
		};

	225) Maximum Product of Two Elements in an Array:
		Problem Statement:
			Given the array of integers nums, you will choose two different indices i and j of that array. 
			Return the maximum value of (nums[i]-1)*(nums[j]-1). 

			Example 1:
				Input: nums = [3,4,5,2]
				Output: 12 
				Explanation: If you choose the indices i=1 and j=2 (indexed from 0), 
				you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 

			Example 2:
				Input: nums = [1,5,4,5]
				Output: 16
				Explanation: Choosing the indices i=1 and j=3 (indexed from 0), 
				you will get the maximum value of (5-1)*(5-1) = 16.

			Example 3:
				Input: nums = [3,7]
				Output: 12

			Constraints:
				2 <= nums.length <= 500
				1 <= nums[i] <= 10^3
		
		//Optimized:
			class Solution {
				public:
				int maxProduct(vector<int>& nums) {
					int maxPro=0;
					for(int i=0; i<nums.size(); i++){
						for(int j=0; j<nums.size(); j++){
							if(i==j)
								continue;
							int crntValue = (nums[i]-1) * (nums[j]-1);
							maxPro = max(crntValue, maxPro);
						}
					}
					return maxPro;
				}
			};

		//much more Optimized:
			class Solution {
				public:
				int maxProduct(vector<int>& nums) {
					sort(nums.begin(), nums.end());
					return (nums[nums.size()-1]-1) * (nums[nums.size()-2]-1);
				}
			};

	226) Sub Query Sum:
		Problem statement
			You have given a 2-dimensional array 'ARR' with "N' rows and "M' columns. The
			queries are given in a 2-dimensional array 'Queries' of size 'K', in which Queries[i]
			contains four integers denoting the left top and right bottom indices of the
			submatrix whose sum we need to find. Your task is to find the sum of the
			submatrix for each query given in the array 'Queries'.
			For example:
			Consider ARR = [[1, 2, 3] , [3, 4, 1], [2, 1, 2]] and Queries = [[0, 0, 1, 2]], the
			submatrix with the left top index (0, 0) and right bottom index (1, 2) is
			[[1, 2,3],
			[3, 4, 1]].
			The sum of the submatrix is 14. Hence, the answer is 14 in this case.
			Constraints :
				1 <= N <= 10 ^ 3
				1 <= M <= 10 ^ 3
				1 <= К <= 10 ^ 3
				1 <= ARR[i][j] <= 10 ^ 6
				0 <= Queries[i][0] , Queries[i][2] < N
				0 <= Queries[i][1] , Queries[i][3] < M
				Where 'T"' denotes the number of test cases, 'N"' and 'M' denotes the number of
				rows and the number of columns in the array 'ARR" respectively, "K' denotes the
				number of rows in the array 'Queries', 'ARR[i][j]' denotes the "j-th' element of 'i-
				th' row of the array 'ARR' and 'Queries[i]' contains four integers denoting the left
				top and right bottom indices of the submatrix.
				Time Limit: 1sec

		Sample Input 1 :
			2
			2 2 1
			4 2 
			1 3 
			0 0 1 0
			3 3 2
			2 1 2
			3 2 6 
			1 4 5
			1 1 2 2
			0 1 0 2
			Sample Output 1 :
			5
			17 3   
			Explanation of sample input 1:
			For the first test case, 
			The submatrix with the left top index (0 , 0) and right bottom index (1 , 0) is  
								[[4] , 
								[1]]. 
			The sum of the submatrix is 5. Hence, the answer is 5 in this case.

			For the second test case,
			The submatrix with the left top index (1 ,1) and right bottom index (2 , 2) is  
								[[2 , 6] , 
								[4 , 5]]. 
			The sum of the submatrix is 17. Hence, the answer is 17 in this case.

			The submatrix with the left top index (0 , 1) and right bottom index (0 , 2) is  
								[[1 , 2]].  
			The sum of the submatrix is 3. Hence, the answer is 3 in this case.
			Sample Input 2 :
			2
			2 2 2
			5 6 
			7 5 
			0 0 0 0
			0 0 1 1
			3 3 2
			3 4 3
			4 3 4 
			1 1 1
			0 0 0 2
			0 0 2 1
			Sample Output 2 :
			5 23
			10 16

		#include <bits/stdc++.h> 
		vector<int> findSubmatrixSum(vector<vector<int>> &arr, vector<vector<int>> &queries) {
			vector<int> ans;
			for(int i=0; i<queries.size(); i++){
				int startRow, startCol, endRow, endCol;
				startRow = queries[i][0];
				startCol = queries[i][1];
				endRow = queries[i][2];
				endCol = queries[i][3];
				int sum=0;
				
				for(int x=startRow; x<=endRow; x++)
					for(int y=startCol; y<=endCol; y++)
						sum += arr[x][y];
				
				ans.push_back(sum);
			}
			return ans;
		}

	227) Consecutive 1's not allowed: ❌Pending
		Problem Statement:
			Given a positive integer N, count all possible distinct binary 
			strings of length N such that there are no consecutive 1’s. 
			Output your answer modulo 109 + 7.
			Example 1:

				Input:
				N = 3
				Output: 5
				Explanation:
				5 strings are (000,
				001, 010, 100, 101).
			Example 2:
				Input:
				N = 2
				Output: 3
				Explanation: 
				3 strings are (00,01,10).

			Your Task:
				You don't have to print answer or take inputs. 
				Complete the function countStrings() which takes single integer n, 
				as input parameters and returns an integer denoting the answer. 

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(N)

			Constraints:
				1 ≤ N ≤ 10^5
		
		//not Optimized:
			class Solution{
				public:
				// #define ll long long
				ll countStrings(int n) {
					long long cnt=0;
					int mod = 1e9+7;
					for(int i=0; ; i++){
						string s = bitset<32>(i).to_string();
						// std::cout << s << std::endl;
						string st;
						if(find(s.begin(), s.end(), '1') != s.end()){
							st = s.substr(find(s.begin(), s.end(), '1')-s.begin());
							// std::cout << st << std::endl;
						}
						
						if(st.length() > n)
							break;
						
						int flag=1;
						for(int a=1; a<st.length(); a++){
							if(st[a]=='1' && st[a-1] == '1'){
							flag=0;
							break;
							}
						}
						if(flag)
							cnt++;
							
						cnt %= mod;
					}
					return cnt;
				}
			};	

		//Optimized:
			class Solution{
				public:
				// #define ll long long
				ll countStrings(int n) {
				ll dp[n+1];
				int mod = 1e9+7;
				dp[1] = 2;
				dp[2] = 3;
				int i;
				for(int i=3; i<=n; i++){
					dp[i] = (dp[i-1]+dp[i-2]) %mod;
				}
				return dp[n];
				}
			};
	
	228) Difference Between Ones and Zeros in Row and Column:
		Problem Statement:
			You are given a 0-indexed m x n binary matrix grid.
			A 0-indexed m x n difference matrix diff is created with the following procedure:

			Let the number of ones in the ith row be onesRowi.
			Let the number of ones in the jth column be onesColj.
			Let the number of zeros in the ith row be zerosRowi.
			Let the number of zeros in the jth column be zerosColj.

			diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
			Return the difference matrix diff.

			Example 1:
				Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
				Output: [[0,0,4],[0,0,4],[-2,-2,2]]
				Explanation:
				- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
				- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
				- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
				- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
				- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
				- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
				- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
				- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
				- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2

			Example 2:
				Input: grid = [[1,1,1],[1,1,1]]
				Output: [[5,5,5],[5,5,5]]
				Explanation:
				- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
				- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
				- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
				- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
				- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
				- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5

			Constraints:
				m == grid.length
				n == grid[i].length
				1 <= m, n <= 105
				1 <= m * n <= 105
				grid[i][j] is either 0 or 1.

		class Solution {
			public:
			vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {
				vector<vector<int>> diff (grid.size(),vector<int> (grid[0].size()));
				
				for(int row=0; row<grid.size(); row++){
					//current Row operation
					int RowOnes=0, rowZero=0;
					for(int c=0; c<grid[0].size(); c++){
						if(grid[row][c] == 1)
							RowOnes++;
						else
							rowZero++;
					}
					for(int col=0; col<grid[0].size(); col++){
						//current Col operation
						int colOnes=0, colZero=0;
						for(int r=0; r<grid.size(); r++){
							if(grid[r][col] ==1)
							colOnes++;
							else
							colZero++;
						}
						diff[row][col] = RowOnes+colOnes - rowZero - colZero;
					}
				}
				return diff;
			}
		};
	
	229) Average Marks:
		Problem Statement:
			Problem statement
				You are given the name of a student in the form of a character
				"firstLetterOfName' and 3 integers M1', 'M2, 'M3' representing the marks of the
				student in 3 subjects. You have to print the firstLetterOfName' of the student
				and the average marks obtained by the student.
				Note: You need to print the integer part of the average only and neglect the
				decimal part.
				For Example :
					If "firstLetterOfName' = 'K', M1' = 10, M2' = 6 and 'M3' = 9, then the average
					marks would be around 7.67. Hence, the output should be as follows: K 7
				Constraints:
					1 <= T <= 10
					'A' <= 'firstLetterOfName' <= 'Z'
					0 <= M1 <= 100
					0 <= M2 <= 100
					0 <= M3 <= 100
					Time Limit: 1 sec
			
			Sample Input 1:
				2
				A
				3 4 6
				T
				7 3 8
				Sample Output 1:
				A 4
				T 6
				Explanation For Sample Input 1:
				For sample case 1, average marks of the student are (3 + 4 + 6)/3 = 4.33 
				and his/her first character of the name is ‘A’. 
				Therefore, the output is : A 4
				
				For sample case 2, average marks of the student are (7 + 3 + 8)/3 = 6 
				and his/her first character of the name is ‘T’. 
				Therefore, the output is : T 6
				Sample Input 2:
				2
				Q
				10 34 96
				P
				71 80 3
				Sample Output 2:
				Q 46
				P 51
				Explanation For Sample Input 2:
				For sample case 1, average marks of the student are (10 + 34 + 96)/3 = 46.67 
				and his/her first character of the name is ‘Q’. 
				Therefore, the output is : Q 46
				
				For sample case 2, average marks of the student are (71 + 80 + 3)/3 = 51.33 
				and his/her first character of the name is ‘P’. 
				Therefore, the output is : P 51

		#include <bits/stdc++.h> 
		#include <utility>

		pair<char, int> averageMarks(char firstLetterOfName, int m1, int m2, int m3) {
			char ch = firstLetterOfName;
			int avg = (m1 +m2 +m3)/3;
			return {ch, avg};
		}

		//or
		pair<char, int> averageMarks(char firstLetterOfName, int m1, int m2, int m3) {
			char ch = firstLetterOfName;
			int avg = (m1 +m2 +m3)/3;
			pair<char, int> p = {ch, avg};
			return p;
		}

		//or
		pair<char, int> averageMarks(char firstLetterOfName, int m1, int m2, int m3) {
			char ch = firstLetterOfName;
			int avg = (m1 +m2 +m3)/3;
			pair<char, int> p;
			p.first = firstLetterOfName;
			p.second = avg;
			return p;
		}

	230) Destination City:
		Problem Statement:
			You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. 
			Return the destination city, that is, the city without any path outgoing to another city.
			It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

			Example 1:
				Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
				Output: "Sao Paulo" 
				Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".

			Example 2:
				Input: paths = [["B","C"],["D","B"],["C","A"]]
				Output: "A"
				Explanation: All possible trips are: 
				"D" -> "B" -> "C" -> "A". 
				"B" -> "C" -> "A". 
				"C" -> "A". 
				"A". 
				Clearly the destination city is "A".

			Example 3:
				Input: paths = [["A","Z"]]
				Output: "Z"

			Constraints:
				1 <= paths.length <= 100
				paths[i].length == 2
				1 <= cityAi.length, cityBi.length <= 10
				cityAi != cityBi
				All strings consist of lowercase and uppercase English letters and the space character.
		
		class Solution {
			public:
			string destCity(vector<vector<string>>& paths) {
				string currentDestination = paths[0][1];
				for(int i=0; i<paths.size(); i++){
					if(currentDestination == paths[i][0]){
						currentDestination = paths[i][1];
						i=0;
					}
				}
				return currentDestination;
			}
		};

	231) Set Bits:
		Problem statement
			Write a program to count the number of 1's in the binary representation of an integer.
			Constraints
				1 <= N <= 100
		Sample Input 1:
			9
			Sample Output 1:
			2
			Explanation of Sample Input 1:
			Binary Representation of 9 is 1001.
			Sample Input 2:
			13
			Sample Output 2:
			3

		#include <bits/stdc++.h> 
		#include <iostream>

		using namespace std;

		//Write your countBits function here
		int countBits(int n){
			//return __builtin_popcount(n);
			
			//or
			int cnt=0;
			while(n>0){
				if(n&1)
					cnt++;
				n>>=1;
			}
			return cnt;
		}

		int main() {
			int n;
			cin >> n;
			cout<<countBits(n);
			return 0;
		}
	
	232) Valid Anagram:
		Problem Statement:
			Given two strings s and t, return true if t is an anagram of s, and false otherwise.
			An Anagram is a word or phrase formed by rearranging the letters of a 
			different word or phrase, typically using all the original letters exactly once.

			Example 1:
				Input: s = "anagram", t = "nagaram"
				Output: true

			Example 2:
				Input: s = "rat", t = "car"
				Output: false

			Constraints:
				1 <= s.length, t.length <= 5 * 104
				s and t consist of lowercase English letters.
		
		class Solution {
			public:
			bool isAnagram(string s, string t) {
				if(s.length() != t.length())
					return 0;
				
				int forS[26]={0}, forT[26]={0};
				//mapping for s
				for(int i=0; i<s.length(); i++){
					forS[s[i]-'a']++;
				}

				//mapping for t
				for(int i=0; i<t.length(); i++){
					forT[t[i]-'a']++;
				}

				for(int i=0; i<26; i++){
					if(forS[i] != forT[i])
						return 0;
				}
				return 1;
			}
		};

		//or
		class Solution {
			private:
				int checker[26]={0};
			public:
				bool isAnagram(string s, string t) {
					if(s.length() != t.size())          //you can use length or size method to access the no.of letter in string
						return 0;
					
					//mapper for s
					for(int i=0; i<s.size(); i++){
						checker[s[i]-'a']++;
					}

					//mapper for t
					for(int i=0; i<t.length(); i++){
						checker[t[i]-'a']--;
					}

					for(int z=0; z<26; z++)
						if(checker[z] != 0)
							return 0;
					return 1;
				}
		};
		
	233) Count Customers Who Did Not Get A Computer: ❌Pending
		Problem statement:
			Mr. X runs an internet cafe which has 'K' computers. His internet cafe has 'N'
			customers who can come anytime throughout the day. Initially, all the 'K
			computers are available for customer use. When a customer enters the cafe he
			first checks whether any available computer is there. If he finds one he starts
			using it and it is marked unavailable. When he leaves the cafe that computer is
			again marked as available. If the customer is not able to find any available
			computer he leaves the cafe immediately.
			You are given an integer array 'ARR' in which each value occurs exactly 2 times,
			the index of the first occurrence of any value denotes the arrival time of the
			customer while the second occurrence denotes the departing time of the
			customer. Your task is to find the no. of customers who were not able to find any
			available computer and had to leave the cafe immediately.
			For example :
			Consider the sequence of customers as [ 1, 2, 3, 2, 3, 1] for N = 3 and K = 2.
			The procedure takes place as follows:
			1) At the start, Customer 1 comes and finds an available computer and starts
			using it and now the number of available computers is reduced by 1.
			2) Customer 2 comes and he is also able to find an available computer and he
			starts using the computer. Now all the computers are unavailable.
			3) Customer 3 comes and goes back immediately as there are no computers
			available currently.
			4) Customer 2 leaves the cafe making 1 computer available.
			5) As customer 3 has already left no new computers are made available.
			6) Customer 1 leaves the cafe and all the computers are again available.
			As only Customer 3 was unable to find any available computers therefore the
			answer is 1 for this case.
			
			Constraints :
				1 <=T <= 10
				1 <= N <= 10^5
				1 <= К <= 10^5
				1 <= ARR[i] <= N
				Time Limit: 1 sec
			Sample Input 1:
				2
				2 2
				1 2 2 1
				3 2 
				1 3 2 1 2 3
				Sample Output 1:
				0
				1
				Explanation for Sample Input 1:
				For the first test case:
					1) Initially, Customer 1 comes and finds an available computer 
					and starts using it. Now only 1 computer is available.
					2) Then Customer 2 comes and takes the only available computer. Now all computers are unavailable.
					3) Customer 1 leaves the cafe making 1 computer available.
					4) Customer 2 leaves the cafe making all the computers available.
					As all customers were able to find an available computer and nobody 
					left without using a computer. Hence, the answer is 0 in this case.

				For the second test case : 
				The procedure takes place as follows :
					1) At the start, Customer 1 comes and finds an available computer and 
					starts using it and now the number of available computers is reduced by 1. 
					2) Customer 3 comes and he is also able to find an available computer 
					and he starts using the computer. Now all the computers are unavailable.
					3) Customer 2 comes and goes back immediately as there are no computers available currently. 
					4) Customer 1 leaves the cafe making 1 computer available. 
					5) As customer 2 has already left no new computers are made available. 
					6) Customer 3 leaves the cafe and all the computers are again available. 

				As only Customer 2 was unable to find any available computers therefore the answer is 1 for this case.
				Sample Input 2:
				2
				4 1
				1 2 3 4 4 3 2 1
				2 2
				1 2 1 2
				Sample Output 2:
				3
				0

		//not optimized:
			#include <bits/stdc++.h> 
			int countCustomers(vector<int> &arr, int k) {
				set<int> s;
				for(int i=0; i<arr.size(); i++)
					s.insert(arr[i]);

				if(s.size() == k)
					return 0;

				int left=0;
				vector<int> holder;
				vector<int> alreadyGone;
				for(int i=0; i<arr.size(); i++){
					if(find(holder.begin(), holder.end(), arr[i]) == holder.end()){
						if(k>0 && find(alreadyGone.begin(), alreadyGone.end(), arr[i]) == alreadyGone.end()){
							k--;
							holder.push_back(arr[i]);
						}else{
							alreadyGone.push_back(arr[i]);
							left++;
						}
					}else{
						k++;
					}
				}

				return (left/2);
			}

		//optimized:
			#include <bits/stdc++.h> 
			int countCustomers(vector<int> &arr, int k) {
				int count = 0;
				std::unordered_map<int, int> hashh;
				int check = 0;

				for (int i = 0; i < arr.size(); i++) {
					if (hashh[arr[i]] == 0) {
						if (check < k) {
							hashh[arr[i]] = 1;
							check++;
						} else {
							hashh[arr[i]] = -1;
							count++;
						}
					} else if (hashh[arr[i]] == 1) {
						check--;
					}
				}
				return count;
			}
	
	234) Game of XOR: ❌Pending
		Problem Statement:
			Given an array A of size N. 
			The value of an array is denoted by the bit-wise XOR of all elements it contains. 
			Find the bit-wise XOR of the values of all subarrays of A.

			Example 1:
				Input: 
				N = 3 
				A = [1,2,3] 
				Output: 
				2
				Explanation:
				xor[1] = 1
				xor[1, 2] = 3
				xor[2, 3] = 1
				xor[1, 2, 3] = 0
				xor[2] = 2
				xor[3] = 3
				Result : 1 ^ 3 ^ 1 ^ 0 ^ 2 ^ 3 = 2

			Example 2:
				Input: 
				N = 2
				A = [1,2]
				Output: 
				0
				Explanation:
				xor[1] = 1
				xor[1, 2] = 3
				xor[2] = 2
				Result : 1 ^ 3 ^ 2 = 0

			Your Task:
				You don't need to read input or print anything.
				Your task is to complete the function gameOfXor() which takes an integer N and array A[] 
				as input parameters and returns the answer.

			Expected Time Complexity: O(N)
			Expected Auxiliary Space: O(1)

			Constraints:
				1 <= N <= 10^5
				0 <= A[i] <= 10^9

		//not Optimized:
			class Solution {
				public:
				int gameOfXor(int N , int A[]) {
					
					//first individual insertion of all elements
					vector<int> holder;
					for(int i=0; i<N; i++){
						holder.push_back(A[i]);
					}
					
					//SubArray Ops
					for(int i=0; i<N-1; i++){
						vector<int> temp;
						temp.push_back(A[i]);
						for(int j=i+1; j<N; j++){
							temp.push_back(A[j]);
							
							//Xor ops
							int result = temp[0];
							for(int z=1; z<temp.size(); z++){
								result ^= temp[z];
							}
							holder.push_back(result);
						}
					}
					
					int res = holder[0];
					for(int y=1; y<holder.size(); y++)
						res ^= holder[y];
					
					return res;
				}
			};

		//Optimized:
			class Solution {
				public:
				int gameOfXor(int N , int A[]) {
					int exor=0,extra=0,times=0;
					for(int i=0;i<N;i++){
						times=(N-i);
						
						if( i == 0 )
							extra=0;
						else
							extra=(i)*(N-i);
						
						// cout<<fac+ex<<endl;
						if((times+extra) & 1) 
							exor^=A[i];
					}
					return exor;
				}
			};
	
	235) Maximum Product Difference Between Two Pairs:
		Problem Statement:
			The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).
			For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
			Given an integer array nums, choose four distinct indices w, x, y, and z 
			such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

			Return the maximum such product difference.
			Example 1:
				Input: nums = [5,6,2,7,4]
				Output: 34
				Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
				The product difference is (6 * 7) - (2 * 4) = 34.

			Example 2:
				Input: nums = [4,2,5,9,7,4,8]
				Output: 64
				Explanation: We can choose indices 3 and 6 for the first pair (9, 8) 
				and indices 1 and 5 for the second pair (2, 4).
				The product difference is (9 * 8) - (2 * 4) = 64.

			Constraints:
				4 <= nums.length <= 104
				1 <= nums[i] <= 104
				
		class Solution {
			public:
			int maxProductDifference(vector<int>& nums) {
				sort(nums.begin(), nums.end());
				return (nums[nums.size()-1]*nums[nums.size()-2]) - (nums[0]*nums[1]);
			}
		};
		
	236) Reversing a Queue:
		Problem statement:
			You are given a queue of 'N' elements. Your task is to reverse the order of
			elements present in the queue.
			You can only use the standard operations of the QUEUE STL.
			1. enqueue(x): Add an item x to the rear of the queue.
			2. dequeue(): Removes an item from the front of the queue.
			3. size(): Returns the number of elements in the queue.
			4. front(): Finds front element.
			5. empty(): Checks whether the queue is empty or not.
			Constraints:
				1 <= T <= 100
				1 <= N <= 3000
				-10 ^ 5 <= Queue[i] <= 10 ^ 5
				Time Limit: 1 sec
			Sample Input 1:
				2
				1
				9
				5
				10 6 8 12 3
				Sample Output 1:
				9 
				3 12 8 6 10
				Explanation 1:
				For the first test case, the queue has only one element, i.e. 9. So, even after reversing, our queue remains the same.

				For the second test case, the queue has elements in the order: 10, 6, 8, 12, 3. Reversing the queue changes the order of elements to - 3, 12, 8, 6, 10.
				Sample Input 2:
				2
				2
				99 89
				6
				1 2 3 4 5 6
				Sample Output 2:
				89 99
				6 5 4 3 2 1

		#include <bits/stdc++.h> 
		queue<int> reverseQueue(queue<int> q) {
			// Write your code here.
			queue<int> reversed;
			vector<int> holder;
			while(!q.empty()){
				holder.push_back(q.front());
				q.pop();
			}
			reverse(holder.begin(), holder.end());
			for(int i=0; i<holder.size(); i++){
				reversed.push(holder[i]);
			}
			return reversed;
		}

		//or
			#include <bits/stdc++.h> 
			queue<int> reverseQueue(queue<int> q) {
				stack<int> ans;
				//inserting all elements of q into stack ans.
				while(!q.empty()){
					ans.push(q.front());
					q.pop();
				}

				//reversing queue
				while(!ans.empty()){
					int currentElement = ans.top();
					ans.pop();   
					q.push(currentElement);
				}
				return q;
			}
	
	237) Rightmost different bit:
		Problem statement:
			Given two numbers M and N. 
			The task is to find the position of the rightmost different bit in the binary representation of numbers. 
			If both M and N are the same then return -1 in this case.

			Example 1: 
				Input: 
				M = 11, N = 9
				Output: 
				2
				Explanation: 
				Binary representation of the given numbers are: 1011 and 1001, 2nd bit from right is different.

			Example 2:
				Input: 
				M = 52, N = 4
				Output: 
				5
				Explanation: 
				Binary representation of the given numbers are: 110100 and 0100, 5th-bit from right is different.

			User Task:
				The task is to complete the function posOfRightMostDiffBit() 
				which takes two arguments M and N and returns 
				the position of first different bits in M and N from right. 
				If both m and n are the same then return -1 in this case.

			Expected Time Complexity: O(max(log M, log N)).
			Expected Auxiliary Space: O(1).

			Constraints:
				0 <= M, N <= 109

		class Solution {
			public:
			//Function to find the first position with different bits.
			int posOfRightMostDiffBit(int m, int n) {
				string SM = bitset<32>(m).to_string();
				string SN = bitset<32>(n).to_string();
				
				int cnt=1;
				for(int i=SM.size()-1; i>=0; i--){
					if(SM[i] != SN[i])
						break;
					cnt++;
				}
				
				if(cnt == 33)
					return -1;
				return cnt;
			}
		};

		//or
			class Solution {
				public:
				//Function to find the first position with different bits.
				int posOfRightMostDiffBit(int m, int n) {
					string SM = bitset<32>(m).to_string();
					string SN = bitset<32>(n).to_string();
					
					int cnt=1;
					for(int i=SM.size()-1; i>=0; i--){
						if(SM[i] != SN[i])
							return cnt;
						cnt++;
					}
					return -1;
				}
			};

		//or using XOR operation:
			class Solution {
				public:
				//Function to find the first position with different bits.
				int posOfRightMostDiffBit(int m, int n) {
					int XOR = m ^ n;
					if(XOR == 0)
						return -1;
					
					int pos=1;
					while((XOR & 1) == 0){
						XOR >>= 1;
						pos++;
					}
					return pos;
				}
			};
	
	238) Image Smoother:
		Problem Statement:
			-Average of all surrounding elements.
			An image smoother is a filter of the size 3 x 3 that can be applied 
			to each cell of an image by rounding down the average of the cell and 
			the eight surrounding cells (i.e. the average of the nine cells in the blue smoother). 
			If one or more of the surrounding cells of a cell is not present, 
			we do not consider it in the average (i.e. the average of the four cells in the red smoother).

			Given an m x n integer matrix img representing the grayscale of an image, 
			return the image after applying the smoother on each cell of it.

			Example 1:
				Input: img = [[1,1,1],[1,0,1],[1,1,1]]
				Output: [[0,0,0],[0,0,0],[0,0,0]]
				Explanation:
				For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
				For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
				For the point (1,1): floor(8/9) = floor(0.88888889) = 0

			Example 2:
				Input: img = [[100,200,100],[200,50,200],[100,200,100]]
				Output: [[137,141,137],[141,138,141],[137,141,137]]
				Explanation:
				For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
				For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
				For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
				

			Constraints:
				m == img.length
				n == img[i].length
				1 <= m, n <= 200
				0 <= img[i][j] <= 255
		
		class Solution {
			public:
			vector<vector<int>> imageSmoother(vector<vector<int>>& img) {
				vector<vector<int>> ans (img.size(),vector<int> (img[0].size()));

				for(int row=0; row<img.size(); row++){
					for(int col=0; col<img[0].size(); col++){
						int value = img[row][col];
						int cnt=1;

						//upper side & checking are they present
							int upperRow = row -1;
							if(upperRow<img.size() && upperRow>=0){
							value += img[upperRow][col];
							cnt++;

							int sideR_Upper = col+1, sideL_Upper= col-1;
							if(sideR_Upper>=0 && sideR_Upper < img[0].size()){
								cnt++;
								value += img[upperRow][sideR_Upper];
							}

							if(sideL_Upper>=0 && sideL_Upper < img[0].size()){
								cnt++;
								value += img[upperRow][sideL_Upper];
							}
							}

						//middle both sides
							int midL_col = col-1;
							if(midL_col >=0 && midL_col < img[0].size()){
							cnt++;
							value += img[row][midL_col];
							}

							int midR_col = col+1;
							if(midR_col >=0 && midR_col < img[0].size()){
							cnt++;
							value += img[row][midR_col];
							}

						//lower Side
							int lowerRow= row+1;
							if(lowerRow>=0 && lowerRow<img.size()){
							cnt++;
							value += img[lowerRow][col];

							int sideR_Lower = col+1, sideL_Lower= col-1;
							if(sideR_Lower>=0 && sideR_Lower < img[0].size()){
								cnt++;
								value += img[lowerRow][sideR_Lower];
							}

							if(sideL_Lower>=0 && sideL_Lower < img[0].size()){
								cnt++;
								value += img[lowerRow][sideL_Lower];
							}
							}
			
			
						value /= cnt;
						ans[row][col] = value;
					}
				}
				return ans;
			}
		};
	
	239) Slot Game:
		Problem statement
			You're given a slot machine with four slots where each slot will contain the color
			Red (R), Yellow(Y), Green(G), Blue(B), respectively. You don't know the colors of
			this slot beforehand. You have to guess the colors. When you guess the correct
			color for the correct slot, you get a perfect hit, and you get 2 points, but if you
			guess a color that exists in the machine but is in the wrong slot, you get a
			pseudo hit, and you get 1 point.
			You're given the original string representing the slots' colors and the guess
			string, and your task is to calculate and return the total number of points you
			have scored.
			Note:
				A slot that has been counted as a perfect hit can never count as a pseudo-hit.
			Example:
				Original String = "RGYB" and Guess String = "YGRR".

				The second slot of both the guess and original matches, hence it's a perfect hit.
				The guess string contains yellow, which is also present in the original string but
				not at the same slot as the guess slot. Hence it's a pseudo hit. The guess string
				also contains two red slots, but the original string contains only one red which is
				also not at the same slot as the guess string; hence it is also a pseudo hit.
				Therefore total points will be 2+1+1= 4.

			Constraints:
				1<=T<= 5
				length(original) = length(guess) = 4
				Time limit: 1 sec
			Sample Input 1
				1
				RGBY
				GGRR
				Sample Output 1:
				3
				Explanation of Sample Input 1:
				The second slot of both the string matches. 
				Therefore, it is a perfect hit, and we get 2 points. 
				Our guess string contains the color Red ‘R’ two times, 
				which is also present in the original string but only one time, 
				and it is not in the same slot as the guess slot; 
				hence we get a pseudo hit we get 1 point. 
				Therefore total points will be 2+1=3.

				Sample Input 2:
					1
					RGYB
					YGRR
					Sample Output 2:
					4
					Explanation of Sample Input 2:

					The second slot of both the string matches. Therefore it is a perfect hit, and we get 2 points. 
					Our guess strings also contain the color Yellow ‘Y’, which is also present in the original slot,
					but it is not in the same slot as the guess string; hence we get a pseudo hit, and we get 1 point. 
					Similarly, Our guess strings also contain the color  Red ‘R’ two times, which is also present in the 
					original slot but only once, and it is not in the same slot as the guess string; hence we get a pseudo 
					hit and get 1 point. Hence total points will be 2+1+1=4.

		#include <bits/stdc++.h> 
		int slotScore(string &original, string &guess) {
			int value=0;
			for(int i=0; i<guess.length(); i++){
				if(guess[i] == original[i]){
					original[i] = '0';				//putting something different char (anything) '0' here we kept.
												//than the thing ie. (Z) which is kept in guess.
					guess[i] = 'Z';
					value +=2;
				}
			}


			for(int i=0; i<guess.length(); i++){
				if (find(original.begin(), original.end(), guess[i]) != original.end()) {
					int index = abs(distance(find(original.begin(), original.end(), guess[i]),original.begin()));
					original[index] = '0';
					guess[i] = 'Z';			//putting any random char so for next time they don't get match.
					value++;
				}
			}

			//USE ABOVE FOR LOOP OR BELOW BOTH WORKS.

			// for(int i=0; i<guess.length(); i++){
			// 	for(int j=0; j<original.length(); j++){
			// 		if(guess[i] == original[j]){
			// 			original[j]='0';
			// 			guess[i] = 'Z';
			// 			value++;
			// 			break;
			// 		}
			// 	}
			// }
			return value;
		}

	240) Buy Two Chocolates:
		Problem Statement:
			You are given an integer array prices representing the prices of various chocolates in a store. 
			You are also given a single integer money, which represents your initial amount of money.
			You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. 
			You would like to minimize the sum of the prices of the two chocolates you buy.

			Return the amount of money you will have leftover after buying the two chocolates. 
			If there is no way for you to buy two chocolates without ending up in debt, return money. 
			Note that the leftover must be non-negative.

			Example 1:
				Input: prices = [1,2,2], money = 3
				Output: 0
				Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.

			Example 2:
				Input: prices = [3,2,3], money = 3
				Output: 3
				Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.

			Constraints:
				2 <= prices.length <= 50
				1 <= prices[i] <= 100
				1 <= money <= 100

		class Solution {
			public:
			int buyChoco(vector<int>& prices, int money) {

				sort(prices.begin(), prices.end());

				if((prices[0]+prices[1]) <= money){
					return money-(prices[0]+prices[1]);
				}
				return money;
			}
		};

		//or
			class Solution {
				public:
				int buyChoco(vector<int>& prices, int money) {
					sort(prices.begin(), prices.end());

					if((prices[0]+prices[1]) > money)
						return money;
					return money-(prices[0]+prices[1]);
				}
			};

	241) 

	242) 

	243) 

	244) 

	245) 

	246) 

	247) 

	248) 

	249) 

	250) 

POTD-END
---------------------------------------------------------------------------------------------------------
#Hacker Rank Problems:
	1) Plus Minus:
		Problem statement:
			Given an array of integers, calculate the ratios of its elements that are positive, 
			negative, and zero. 
			Print the decimal value of each fraction on a new line with  places after the decimal.
			Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, 
			though answers with absolute error of up to  are acceptable.
			arr = [1,1, 0, -1, -1]
			There are n = 5 elements, two positive, two negative and one zero. Their ratios are
			2/5 	= 0.400000, 2/5 = 0.400000 and 1/5 = 0.200000. Results are printed as:
				0.400000
				0.400000
				0.200000
			Print the following 3 lines, each to 6 decimals:

			1)proportion of positive values
			2)proportion of negative values
			3)proportion of zeros

				Sample Input
				STDIN           Function
				-----           --------
				6               arr[] size n = 6
				-4 3 -9 0 4 1   arr = [-4, 3, -9, 0, 4, 1]

				Sample Output
				3/6 = 0.500000
				2/6 = 0.333333
				1/6 = 0.166667

		#include<bits/stdc++.h>
		void plusMinus(vector<int> arr) {
			float pos, neg, zr, len = arr.size();
			pos=neg=zr=0;
			for(int i=0; i<arr.size(); i++){
				if(arr[i]<0)
					neg++;
				else if(arr[i]>0)
					pos++;
				else
					zr++;
			}
			cout<< pos/len <<endl;
			cout<< neg/len <<endl;
			cout<< zr/len;
		}

	2) Mini-Max Sum:
		Problem Statement:
			Given five positive integers, find the minimum and maximum values that can be calculated 
			by summing exactly four of the five integers. 
			Then print the respective minimum and maximum values as a single line of two space-separated long integers
			Example
				arr = [1, 3, 5, 7, 9]
				The minimum sum is 1 + 3 + 5 + 7 = 16 and the maximum sum is 3 + 5 + 7 + 9 = 24. 
				The function prints
					16 24
				Function Description
				Complete the miniMaxSum function in the editor below.
				miniMaxSum has the following parameter(S):
				• arr: an array of 5 integers
				Print two space-separated integers on one line: the minimum sum and the maximum sum of 4 of 5 elements.
				Input Format
					A single line of five space-separated integers.
				Constraints
					1 ≤ arri] ≤ 10^9
				Output Format
					Print two space-separated long integers denoting the respective 
					minimum and maximum values that can be calculated by summing 
					exactly four of the five integers. (The output can be greater than a 32 bit integer.)

				Sample Input
					1 2 3 4 5
				Sample Output
					10 14
				Explanation
					The numbers are 1, 2, 3, 4, and 5. Calculate the following sums using four of the five integers:
					1. Sum everything except 1, the sum is 2 + 3 + 4 + 5 = 14.
					2. Sum everything except 2, the sum is 1 + 3 + 4 + 5 = 13.
					3. Sum everything except 3, the sum is 1 + 2 + 4 + 5 = 12.
					4. Sum everything except 4, the sum is 1 + 2 + 3 + 5 = 11.
					5. Sum everything except 5, the sum is 1 + 2 + 3 + 4 = 10.
					Hints: Beware of integer overflow! Use 64-bit Integer.
		
		// using different sum
		void miniMaxSum(vector<int> arr) {

			sort(arr.begin(), arr.end());
			
			long long mnSum=0;
			long long mxSum=0;
			
			for(int i=0; i<4; i++)
				mnSum += arr[i];
			
			for(int i=1; i<5; i++)
				mxSum += arr[i];
				
			cout<<mnSum<<" "<<mxSum;
		}

		//or Using total sum
			void miniMaxSum(vector<int> arr) {

				sort(arr.begin(), arr.end());
						
				long long Sum=0;
				for(int i=0; i<5; i++)
						Sum += arr[i];

				cout<<Sum-arr[4]<<" "<<Sum-arr[0];
			}
		
		//or using accumulate function
			void miniMaxSum(vector<int> arr) {

				sort(arr.begin(), arr.end());
				
				long long value =0;
				long long Sum =0;
				
				// Sum = accumulate(arr.begin(), arr.end(), value);			//here value is initial value of summation.
				//Sum = accumulate(arr.begin(), arr.end(), 0LL);				//you can use ll or LL any to convert/cast into long long.
				Sum = accumulate(arr.begin(), arr.end(), 0ll);

				cout<<Sum-arr[4]<<" "<<Sum-arr[0];
			}
		
		//or using max_element & min_element function
			void miniMaxSum(vector<int> arr) {
				long long SUM=0;
				
				for(int i=0; i<5; i++)
					SUM += arr[i];
				
				long long minSum= SUM - *max_element(arr.begin(), arr.end());
				long long maxSum= SUM - *min_element(arr.begin(), arr.end());
				
				// cout << SUM-*max_element(arr.begin(), arr.end()) << " " << SUM-*min_element(arr.begin(), arr.end());
				
				cout << minSum << " " << maxSum;
			}
				
	3) Time Conversion:
		Problem statement:
			Given a time in 12-hour AM/PM format, convert it to military (24-hour) time.
			Note: - 12:00:00AM on a 12-hour clock is 00:00:00 on a 24-hour clock.
			- 12:00:00PM on a 12-hour clock is 12:00:00 on a 24-hour clock.
			Example
			• s = '12:01:00PM'
			Return '12:01:00'.
			• s = '12:01:00AM'
			Return '00:01:00'.
			Function Description
			Complete the timeConversion function in the editor below. It should return a new string
			representing the input time in 24 hour format.
			timeConversion has the following parameter(S):
			• string s: a time in 12 hour format
			Returns
			• string: the time in 24 hour format
			Input Format
			A single string s that represents a time in 12-hour clock format (i.e.: hh:mm:ssAM or
			hh:mm:ssPM).
			Constraints
			• All input times are valid
			Sample Input
				07:05:45PM
			Sample Output
				19:05:45

		string timeConversion(string s) {
			string ampmHolder = s.substr(s.length()-2);
			string hour = s.substr(0,2);
			
			if(ampmHolder == "PM" && hour != "12"){
				hour = to_string((stoi(hour) + 12));
			}else if(ampmHolder == "AM" && hour == "12"){
				hour = "00";   
			}
			
			return hour+s.substr(2,6);
		}
	
	4) Sparse Arrays:
		Problem Statement:
			There is a collection of input strings and a collection of query strings. For each query string, determine how many times it
			occurs in the list of input strings. Return an array of the results.
			Example
			strings = ['ab', 'ab', 'abc']
			queries = ['ab', 'abc', 'bc']
			There are 2 instances of 'ab', 1 of 'abc' and 0 of 'bc'. For each query, add an element to the return array, results = [2, 1, 0].
			Function Description
			Complete the function matchingStrings in the editor below. The function must return an array of integers representing the
			frequency of occurrence of each query string in strings.
			matchingStrings has the following parameters:
			• string strings[n] - an array of strings to search
			• string queries[q] - an array of query strings
			Returns
			• int[q]: an array of results for each query
			Input Format
			The first line contains and integer n, the size of strings[].
			Each of the next n lines contains a string strings [i].
			The next line contains q, the size of queries[]].
			Each of the next q lines contains a string queries[i].
			Constraints
				1 ≤ n ≤ 1000
				1 ≤ q ≤ 1000
				1 ≤ |strings[i]|, |queries[i]| ≤ 20.
			Sample Input 1
				4
				aba
				baba
				aba
				xzxb
				3
				aba
				xzxb
				ab
				Sample Output 1
					2
					1
					0

			Sample Input 2
				3
				def
				de
				fgh
				3
				de
				lmn
				fgh
				Sample Output 2
					1
					0
					1

			Sample Input 3
				13
				abcde
				sdaklfj
				asdjf
				na
				basdn
				sdaklfj
				asdjf
				na
				asdjf
				na
				basdn
				sdaklfj
				asdjf
				5
				abcde
				sdaklfj
				asdjf
				na
				basdn
				Sample Output 3
					1
					3
					4
					3
					2

		vector<int> matchingStrings(vector<string> strings, vector<string> queries) {
			vector<int> ans;
			for(int i=0; i<queries.size(); i++){
				// string crntString = queries[i];
				int cnt=0;
				for(int j=0; j<strings.size(); j++){
					if(queries[i] == strings[j])
						cnt++;
				}
				ans.push_back(cnt);
			}
			return ans;
		}

	5) Lonely Integer:
		Problem Statement:
			Given an array of integers, where all elements but one occur twice, find the unique element.
			Example
			a = [1, 2, 3, 4, 3, 2, 1]
			The unique element is 4.
			Function Description
			Complete the lonelyinteger function in the editor below.
			lonelyinteger has the following parameter(s):
			• int a[n]: an array of integers
			Returns
			• int: the element that occurs only once
			Input Format
			The first line contains a single integer, n, the number of integers in the array.
			The second line contains n space-separated integers that describe the values in a.
			Constraints
				• 1 ≤ n < 100
				• It is guaranteed that n is an odd number and that there is one unique element.
				• 0 ≤ ali] ≤ 100, where 0 ≤ i < n.

		#include<bits/stdc++.h>
		int lonelyinteger(vector<int> a) {
			map<int, int> FreqStore;
			for(int i=0; i<a.size(); i++){
				FreqStore[a[i]]++;
			}
			
			int ans;
			for(auto i: FreqStore)
				if(i.second == 1){
					ans = i.first;
					break;   
				}
			return ans;
		}

		//or using XOR operator cause xor of n & n is 0.
			0 xor 0 = 0
			0 xor 1 = 1

			int lonelyinteger(vector<int> a) {
				int result = 0;
				for(int i: a)
					result ^= i;
				return result;
			}

	6) Flipping bits:
		Problem Statement:
			You will be given a list of 32 bit unsigned integers. Flip all the bits (1 → 0 and 0 → 1) and
			return the result as an unsigned integer.
			Example
			n = 9
			9 = (1001). We're working with 32 bits, so:
			00000000000000000000000000001001 = 9
			11111111111111111111111111110110 = 4294967286
			Return 4294967286.
			Function Description
			Complete the flippingBits function in the editor below.
			flippingBits has the following parameter(s):
			• int n: an integer
			Returns
			• int: the unsigned decimal integer result
			Input Format
			The first line of the input contains q, the number of queries.
			Each of the next q lines contains an integer, n, to process.
			Constraints
			1 ≤ q ≤ 100
			0 <= n < 2^32
			Sample Input
				3 
				2147483647 
				1 
				0
				Sample Output

				2147483648 
				4294967294 
				4294967295
				Explanation

				Take 1 for example, as unsigned 32-bits is 
				00000000000000000000000000000001 and doing the flipping we get 
				11111111111111111111111111111110 which in turn is 4294967294.

		long flippingBits(long n) {
			bitset<32> bits(n);
			bits.flip();
			return static_cast<long>(bits.to_ulong());
		}

		//or
			long flippingBits(long n) {
				bitset<32> bits(n);
				return static_cast<long>(bits.flip().to_ulong());
			}

		//or
			long flippingBits(long n) {
				bitset<32> bits(n);
				long a = bits.flip().to_ulong();				//to convert string or any other type of data into unsigned long int use
				return a;									// .to_ulong();
			}

			//to_ulong() :-
				used to convert the binary representation stored in a bitset into an unsigned long integer.
	
	7) 
	
	8)
	
	9)
	
	10)
---------------------------------------------------------------------------------------------------------
calender:
	today 2nd sept 2023 (saturday)
	what is day on 30th may 2023?
	->
		how many days between dates = may +june + july +august+ sept
						 1 + 30d + 31d + 31d + 2  = 95
						 =95/7 -> 4 remainder,
						 4 days back from today (fri, thurs, wed, tuesday)
						 => Tuesday is on 30th of may.
--------------------------------------------------------------------------------------------------------
	#include <bits/stdc++.h>
		using namespace std;
		#define setSize 32
		int main() {
		bitset<setSize> bset1; // value is 00000000000000000000000000000000
		bitset<setSize> bset2(20); //value is 00000000000000000000000000010100
		bitset<setSize> bset3(string("1100")); // value is 00000000000000000000000000001100
		cout<<"The values of bitsets are : " ;
		cout<<"bitset 1 : "<<bset1<<endl;
		cout<<"bitset 2 : "<<bset2<<endl;
		cout<<"bitset 3 : "<<bset3<<endl;
		cout << endl;
		bitset<8> bset4; // value is 00000000
		bset4[1] = 1;
		cout<<"value after changing a bit :"<<bset4<<endl;
		bset4[4] = bset4[1];
		cout <<"changing value using other method :"<<bset4<<endl;
		int numberofone = bset4.count();
		int numberofzero = bset4.size() - numberofone;
		cout<<"The set"<<bset4<<"has"<<numberofone<<"ones and"<<numberofzero<<"zeros
		";
		cout << "bool representation of " << bset4 << " : ";
		for (int i = 0; i < bset4.size(); i++)
			cout << bset4.test(i) << " ";
		cout << endl;
		if (!bset1.none())
			cout << "bset1 has some bit set
		";
			cout <<".set() method sets all bits, bset4.set() = "<< bset4.set() << endl;
			cout<<"changing a specific bit(4) to 0 "<<bset4.set(4, 0)<<endl;
			cout<<"changing a specific bit(4) to 1 "<<bset4.set(4)<<endl;
			cout<<"Resetting bit at position 2 :"<<bset4.reset(2)<<endl;
			cout<<"Resetting bits of full bitset : "<<bset4.reset()<<endl;
			cout<<"Flipping bit at position 2 : "<< bset4.flip(2) << endl;
			cout<<"Flipping bit of array : "<<bset4.flip() << endl;
			int num = 100;
			cout << "
		Decimal number: " << num << " Binary equivalent: " << bitset<8>(num);
		return 0;
		}

	The bitset all() function an inbuilt function of the C++ STL( Standard Template Library).
		This function returns a Boolean value. The returned value is true if all the bits of the 
		calling bitset are 1 else it will return false.

		The function does not accept any parameter and returns a Boolean value.

		Syntax
		Bool bitset_name .all()
		Sample
		Bitset = 100101
		Output
		false
		Because all bits of the set need to be true in order to return a true value.

		Example
		#include <bits/stdc++.h>
		using namespace std;
		void printer(bool val){
		if(val){
			cout<< "The bitset has all bits set"<< endl;
		} else{
			cout << "The bitset does not have all bits set"<< endl;
		}
		}
		int main() {
		bitset<4> bit1(string("1011"));
		bitset<6> bit2(string("111111"));
		cout<<"The bitset is "<<bit1<<endl;
		printer(bit1.all());
		cout<<"The bitset is "<<bit2<<endl;
		printer(bit2.all());
		return 0;
		}

	The bitset flip() method is an inbuilt method of C++ STL( Standard Template Library). 
		It flips the bits of the calling bitset. This method flips all 0’s to 1’s 
		and all 1’s to 0’s, which means it reverse each and every bit of the calling bitset when no parameter is passed.

		If a parameter is passed the flip method will flip only the nth bit for the integer n passed. 
		For example, if 5 is passed then the flip method will flip 5th bit of of the calling bitset.

		Syntax
		bitset_name.flip(int pos)
		Sample

		Initial bitset: 011001
		After applying the bits flip function with no parameter: 100110

		After applying the Beta function with 6: 011000

		Example
		#include <bits/stdc++.h>
		using namespace std;
		int main() {
			bitset<6> bit1(string("100110"));
			bitset<10> bit2(string("0100001111"));
			cout << bit1 << " after applying flip() function with nothing passed as parameter returns "
			<< bit1.flip() << endl;
			cout << bit2 << " after applying flip() function with 1 passed as parameter will flip 1st index element"<< bit2.flip(1)<<endl;
			cout << bit2 << " after applying flip() function with 1 passed as parameter will flip 0th index element"<< bit2.flip(0)<<endl;
			
			
			std::cout << std::endl;
			int n=10;
			std::cout << "10 in binary: " << bitset<32>(n)  << std::endl;
			std::cout << "Flipping 10 binary (0 to 1 & 1 to 0)" << bitset<32>(n).flip(0) << std::endl;          //just flip the 0th index element
			std::cout << "Flipping 10 binary (0 to 1 & 1 to 0)" << bitset<32>(n).flip() << std::endl;          //flip all the elements.
			
			return 0;
		}

	#include <iostream>
		#include<algorithm>
		#include<bitset>

		using namespace std;
		int main(){
		
		int n=8;
		string s = bitset<8> (n).to_string('V','S');
		
		int num =15;
		bitset<32> numBit(num);
		
		std::cout << s << std::endl;
		std::cout << "Size of bitset n is :: "<< bitset<8>(n).size() << std::endl;
		
		std::cout << "Set bits in numBit "<< numBit.count() << std::endl;
		std::cout << "no.of zeros in numBit "<< numBit.size() - numBit.count() << std::endl;
		
		std::cout << "flipping the bits of numBit \nBefore: "<< numBit << "\nAfter : "<< numBit.flip() << std::endl;
		std::cout << "Flipping 5th bit of numBit (0-indexed) from last : "<< numBit.flip(5) << std::endl;
		std::cout <<  bitset<8>(n).flip(2) << std::endl;
		return 0;
		}

	#include <iostream>
	#include<bitset>
	using namespace std;

	int main()
	{
	int arr[] = {1,2,3,4,5,6,7,8,9,10,100000};
	long long arr2[10];
	
	//printing binary for all,
	for(int i=0;i<11;i++){
		string s = bitset<32> (arr[i]).to_string();
		long long j = 0;
	
		// Traversing string
		for (char c : s) {
			// Checking if the element is number
			if (c >= '0' && c <= '9') 
				j = j * 10 + (c - '0');
		}
		cout<<j<<endl;
		arr2[i] = j; 
		std::cout << s << std::endl;
	}
	
	std::cout << "Second array" << std::endl;
	for(int i=0;i<11;i++)
		std::cout << arr2[i] << std::endl;
	return 0;
	}
--------------------------------------------------------------------------------------------------------
//❌Pending
	//Excel Column Number https://www.codingninjas.com/studio/problems/excel-column-number_630461 ❌Pending

	//K Sum Subset https://www.codingninjas.com/studio/problems/k-sum-subset_2546852 ❌Pending

	//power of n wihtout using looops & recursion ❌Pending
	https://www.geeksforgeeks.org/find-whether-given-integer-power-3-not/

	https://www.codingninjas.com/studio/problem-details/two-substrings_920397 ❌Pending